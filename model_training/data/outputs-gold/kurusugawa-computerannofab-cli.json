from typing import Any , List [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] from annofabcli . common . utils import get_file_scheme_path , is_file_scheme , read_multiheader_csv [EOL] [EOL] out_path = Path ( [string] ) [EOL] data_path = Path ( [string] ) [EOL] [EOL] [EOL] def test_is_file_scheme ( ) : [EOL] assert is_file_scheme ( [string] ) == True [EOL] assert is_file_scheme ( [string] ) == False [EOL] [EOL] [EOL] def test_get_file_scheme_path ( ) : [EOL] assert get_file_scheme_path ( [string] ) == [string] [EOL] assert get_file_scheme_path ( [string] ) is None [EOL] [EOL] [EOL] def test_get_read_multiheader_csv ( ) : [EOL] df = read_multiheader_csv ( str ( data_path / [string] ) , header_row_count = [number] ) [EOL] columns = list ( df . columns ) [EOL] assert columns == [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] from annofabcli . task . complete_tasks import CompleteTasksMain [EOL] [EOL] [EOL] def test_inspection_list_to_dict ( ) : [EOL] inspection_list = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] expected = { [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , } , } [EOL] [EOL] assert CompleteTasksMain . inspection_list_to_dict ( inspection_list ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [EOL] [EOL] def set_logger ( ) : [EOL] logging_formatter = [string] [EOL] logging . basicConfig ( format = logging_formatter ) [EOL] logging . getLogger ( [string] ) . setLevel ( level = logging . DEBUG ) [EOL] logging . getLogger ( [string] ) . setLevel ( level = logging . DEBUG ) [EOL] logging . getLogger ( [string] ) . setLevel ( level = logging . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] import pathlib [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] from annofabcli . common . cli import get_json_from_args , get_list_from_args [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] [EOL] [EOL] def test_get_json_from_args ( ) : [EOL] expected = { [string] : [number] } [EOL] assert get_json_from_args ( [string] ) == expected [EOL] assert get_json_from_args ( f" [string] " ) == expected [EOL] assert get_json_from_args ( None ) is None [EOL] [EOL] [EOL] def test_get_list_from_args ( ) : [EOL] expected = [ [string] , [string] , [string] ] [EOL] [EOL] actual = get_list_from_args ( [ [string] , [string] , [string] ] ) [EOL] assert all ( [ a == b for a , b in zip ( actual , expected ) ] ) [EOL] [EOL] actual = get_list_from_args ( [ [string] ] ) [EOL] assert all ( [ a == b for a , b in zip ( actual , expected ) ] ) [EOL] [EOL] actual = get_list_from_args ( None ) [EOL] assert len ( actual ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Tuple [EOL] import builtins [EOL] import annofabcli [EOL] import datetime [EOL] import typing [EOL] import pathlib [EOL] import datetime [EOL] import os [EOL] import uuid [EOL] from pathlib import Path [EOL] [EOL] from annofabcli . input_data . list_input_data import create_datetime_range_list [EOL] from annofabcli . input_data . put_input_data import CsvInputData , PutInputData [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] [EOL] [EOL] def is_uuid4 ( target ) : [EOL] try : [EOL] uuid . UUID ( target , version = [number] ) [EOL] return True [EOL] except ValueError : [EOL] return False [EOL] [EOL] [EOL] def test_get_input_data_list_from_csv ( ) : [EOL] csv_path = test_dir / [string] [EOL] actual_members = PutInputData . get_input_data_list_from_csv ( csv_path ) [EOL] print ( actual_members ) [EOL] assert actual_members [ [number] ] == CsvInputData ( input_data_name = [string] , input_data_path = [string] , input_data_id = [string] , sign_required = None ) [EOL] assert actual_members [ [number] ] == CsvInputData ( input_data_name = [string] , input_data_path = [string] , input_data_id = [string] , sign_required = True ) [EOL] assert actual_members [ [number] ] == CsvInputData ( input_data_name = [string] , input_data_path = [string] , input_data_id = [string] , sign_required = False ) [EOL] [EOL] assert is_uuid4 ( actual_members [ [number] ] . input_data_id ) [EOL] [EOL] [EOL] def test_create_datetime_range_list ( ) : [EOL] first_datetime = datetime . datetime ( [number] , [number] , [number] ) [EOL] last_datetime = datetime . datetime ( [number] , [number] , [number] ) [EOL] [EOL] actual = create_datetime_range_list ( first_datetime = first_datetime , last_datetime = last_datetime , days = [number] ) [EOL] expected = [ ( None , datetime . datetime ( [number] , [number] , [number] ) ) , ( datetime . datetime ( [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] ) ) , ( datetime . datetime ( [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] ) ) , ( datetime . datetime ( [number] , [number] , [number] ) , None ) , ] [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import configparser [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import json [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] [EOL] from annofabcli . statistics . csv import Csv [EOL] from annofabcli . statistics . database import Database [EOL] from annofabcli . statistics . table import Table [EOL] [EOL] out_path = Path ( [string] ) [EOL] data_path = Path ( [string] ) [EOL] ( out_path / [string] ) . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] service = annofabapi . build_from_netrc ( ) [EOL] [EOL] csv_obj = Csv ( str ( out_path ) ) [EOL] database_obj = Database ( service , project_id , chekpoint_dir = str ( data_path ) , query = None , ) [EOL] table_obj = Table ( database_obj ) [EOL] [EOL] [EOL] class TestDatabase : [EOL] def test_read_annotation_summary ( self ) : [EOL] with open ( data_path / [string] ) as f : [EOL] task_list = json . load ( f ) [EOL] result = database_obj . read_annotation_summary ( task_list , table_obj . _create_annotation_summary ) [EOL] assert [string] in result [EOL] assert [string] in result [EOL] [EOL] def test_read_input_data_from_json ( self ) : [EOL] task_list = [ { [string] : [string] , [string] : [ [string] ] } ] [EOL] result = database_obj . read_input_data_from_json ( task_list ) [EOL] assert [string] in result [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $annofabcli.statistics.database.Database$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $annofabcli.statistics.table.Table$ 0 0 0 $annofabcli.statistics.database.Database$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $annofabcli.statistics.database.Database$ 0 0 0 $typing.Any$ 0 $annofabcli.statistics.table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.statistics.database.Database$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple [EOL] import asyncio [EOL] import configparser [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import asyncio [EOL] import configparser [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] [EOL] service = annofabapi . build_from_netrc ( ) [EOL] [EOL] out_path = Path ( [string] ) [EOL] data_path = Path ( [string] ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] def test_download_all_file_with_async ( ) : [EOL] downloading_obj = DownloadingFile ( service ) [EOL] is_latest = False [EOL] wait_options = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] gather = asyncio . gather ( downloading_obj . download_input_data_json_with_async ( project_id , dest_path = str ( out_path / [string] ) , is_latest = is_latest , wait_options = wait_options , ) , downloading_obj . download_task_json_with_async ( project_id , dest_path = str ( out_path / [string] ) , is_latest = is_latest , wait_options = wait_options ) , downloading_obj . download_annotation_zip_with_async ( project_id , dest_path = str ( out_path / [string] ) , is_latest = is_latest , wait_options = wait_options ) , downloading_obj . download_task_history_json_with_async ( project_id , dest_path = str ( out_path / [string] ) ) , downloading_obj . download_inspection_json_with_async ( project_id , dest_path = str ( out_path / [string] ) ) , return_exceptions = True , ) [EOL] result = loop . run_until_complete ( gather ) [EOL] print ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import configparser [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] [EOL] from annofabcli . project . list_project import ListProjectMain [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] out_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] service = annofabapi . build_from_netrc ( ) [EOL] [EOL] [EOL] class TestListProject : [EOL] @ classmethod def setup_class ( cls ) : [EOL] cls . main_obj = ListProjectMain ( service ) [EOL] [EOL] def test_get_project_list_from_project_id ( self ) : [EOL] actual = self . main_obj . get_project_list_from_project_id ( [ project_id ] ) [EOL] print ( actual ) [EOL] [EOL] def test_get_project_list_from_organization ( self ) : [EOL] organization , _ = service . api . get_organization_of_project ( project_id ) [EOL] actual = self . main_obj . get_project_list_from_organization ( organization [ [string] ] ) [EOL] print ( actual ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , Any , List [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] import pandas [EOL] [EOL] from annofabcli . labor . list_worktime_by_user import LaborAvailability , ListWorktimeByUser [EOL] [EOL] out_path = Path ( [string] ) [EOL] data_path = Path ( [string] ) [EOL] ( out_path / [string] ) . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] [EOL] class TestListWorktimeByUser : [EOL] def test_get_first_and_last_date ( self ) : [EOL] first_date , last_date = ListWorktimeByUser . get_first_and_last_date ( [string] ) [EOL] assert first_date == [string] [EOL] assert last_date == [string] [EOL] [EOL] def test_get_first_and_last_date2 ( self ) : [EOL] first_date , last_date = ListWorktimeByUser . get_first_and_last_date ( [string] ) [EOL] assert first_date == [string] [EOL] assert last_date == [string] [EOL] [EOL] def test_get_start_and_end_date_from_month ( self ) : [EOL] start_date , end_date = ListWorktimeByUser . get_start_and_end_date_from_month ( [string] , [string] ) [EOL] assert start_date == [string] [EOL] assert end_date == [string] [EOL] [EOL] def test_get_start_and_end_date_from_month2 ( self ) : [EOL] start_date , end_date = ListWorktimeByUser . get_start_and_end_date_from_month ( [string] , [string] ) [EOL] assert start_date == [string] [EOL] assert end_date == [string] [EOL] [EOL] def test_create_worktime_df_per_date_user ( self ) : [EOL] worktime_df = pandas . read_csv ( data_path / [string] ) [EOL] user_df = pandas . read_csv ( data_path / [string] ) [EOL] df = ListWorktimeByUser . create_worktime_df_per_date_user ( worktime_df , user_df = user_df ) [EOL] df . to_csv ( out_path / [string] ) [EOL] [EOL] labor_availability_list_dict = { [string] : [ LaborAvailability ( date = [string] , account_id = [string] , user_id = [string] , username = [string] , availability_hour = [number] ) , LaborAvailability ( date = [string] , account_id = [string] , user_id = [string] , username = [string] , availability_hour = [number] ) , ] , [string] : [ LaborAvailability ( date = [string] , account_id = [string] , user_id = [string] , username = [string] , availability_hour = [number] ) , LaborAvailability ( date = [string] , account_id = [string] , user_id = [string] , username = [string] , availability_hour = [number] ) , ] , } [EOL] df2 = ListWorktimeByUser . create_worktime_df_per_date_user ( worktime_df , user_df = user_df , labor_availability_list_dict = labor_availability_list_dict ) [EOL] df2 . to_csv ( out_path / [string] ) [EOL] [EOL] [comment] [EOL] df3 = ListWorktimeByUser . create_worktime_df_per_date_user ( worktime_df = pandas . DataFrame ( columns = [ [string] , [string] , [string] , [string] ] ) , user_df = user_df , labor_availability_list_dict = labor_availability_list_dict , ) [EOL] df3 . to_csv ( out_path / [string] ) [EOL] [EOL] [comment] [EOL] df4 = ListWorktimeByUser . create_worktime_df_per_date_user ( worktime_df = pandas . DataFrame ( columns = [ [string] , [string] , [string] , [string] ] ) , user_df = user_df , labor_availability_list_dict = None , ) [EOL] df4 . to_csv ( out_path / [string] ) [EOL] [EOL] def test_create_worktime_df_per_user ( self ) : [EOL] worktime_df_per_date_user = pandas . read_csv ( data_path / [string] ) [EOL] user_df = pandas . read_csv ( data_path / [string] ) [EOL] df = ListWorktimeByUser . create_worktime_df_per_user ( worktime_df_per_date_user , user_df ) [EOL] df . to_csv ( out_path / [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabcli.labor.list_worktime_by_user.LaborAvailability]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[annofabcli.labor.list_worktime_by_user.LaborAvailability]]$ 0 $typing.Dict[builtins.str,typing.List[annofabcli.labor.list_worktime_by_user.LaborAvailability]]$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[annofabcli.labor.list_worktime_by_user.LaborAvailability]]$ 0 $typing.Dict[builtins.str,typing.List[annofabcli.labor.list_worktime_by_user.LaborAvailability]]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[annofabcli.labor.list_worktime_by_user.LaborAvailability]]$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0
from typing import Dict , Any , List [EOL] import configparser [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import datetime [EOL] import json [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] [EOL] from annofabcli . experimental . dashboard import ( PrintDashBoardMain , RemainingTaskCount , get_remaining_task_count_info_from_task_list , get_worktime_for_period , ) [EOL] from annofabcli . experimental . utils import create_column_list , create_column_list_per_project [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] out_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] service = annofabapi . build_from_netrc ( ) [EOL] [EOL] [EOL] class TestListLaborWorktime : [EOL] def test_create_column_list_per_project ( self ) : [EOL] total_df = pandas . read_csv ( str ( test_dir / [string] ) ) [EOL] df = create_column_list_per_project ( total_df ) [EOL] df . to_csv ( out_dir / [string] , index = False ) [EOL] [EOL] def test_create_column_list ( self ) : [EOL] total_df = pandas . read_csv ( str ( test_dir / [string] ) ) [EOL] df = create_column_list ( total_df ) [EOL] df . to_csv ( out_dir / [string] , index = False ) [EOL] [EOL] [EOL] class TestDashboard : [EOL] @ classmethod def setup_class ( cls ) : [EOL] cls . main_obj = PrintDashBoardMain ( service ) [EOL] [EOL] task_list = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL] [EOL] def test_get_remaining_task_count_info_from_task_list ( self ) : [EOL] actual = get_remaining_task_count_info_from_task_list ( self . task_list ) [EOL] assert actual == RemainingTaskCount ( complete = [number] , annotation_not_started = [number] ) [EOL] [EOL] def test_get_worktime_for_period ( self ) : [EOL] actual_worktime_dict = { [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] actual = get_worktime_for_period ( actual_worktime_dict , lower_date = datetime . date ( [number] , [number] , [number] ) , upper_date = datetime . date ( [number] , [number] , [number] ) ) [EOL] assert actual == [number] [EOL] [EOL] def test_get_task_phase_statistics ( self ) : [EOL] actual = self . main_obj . get_task_phase_statistics ( project_id ) [EOL] [EOL] def test_create_dashboard_values ( self ) : [EOL] with open ( test_dir / [string] ) as f : [EOL] task_list = json . load ( f ) [EOL] actual = self . main_obj . create_dashboard_data ( project_id , date = [string] , task_list = task_list ) [EOL] print ( actual ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.dashboard.RemainingTaskCount$ 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.dashboard.RemainingTaskCount$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , Any [EOL] import configparser [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] import pytest [EOL] [EOL] from annofabcli . __main__ import main [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] task_id = annofab_config [ [string] ] [EOL] [EOL] service = annofabapi . build_from_netrc ( ) [EOL] user_id = service . api . login_user_id [EOL] [EOL] out_path = Path ( [string] ) [EOL] data_path = Path ( [string] ) [EOL] [EOL] organization_name = service . api . get_organization_of_project ( project_id ) [ [number] ] [ [string] ] [EOL] [EOL] [EOL] class TestAnnotation : [EOL] def test_annotation ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , str ( out_path / [string] ) , ] ) [EOL] [EOL] def test_dump_annotation ( self ) : [EOL] output_dir = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , task_id , [string] , output_dir , [string] , ] ) [EOL] [EOL] def test_delete_and_restore_annotation ( self ) : [EOL] backup_dir = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , task_id , [string] , backup_dir , [string] , ] ) [EOL] [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , task_id , [string] , backup_dir , [string] , ] ) [EOL] [EOL] def test_import_annotation ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , str ( data_path / [string] ) , [string] , task_id , [string] , [string] , ] ) [EOL] [EOL] [EOL] class TestAnnotationSpecs : [EOL] command_name = [string] [EOL] [EOL] def test_annotation_specs_histories ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_annotation_specs_list_label ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_old_annotation_specs_list_label ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , [string] , [string] , out_file ] ) [EOL] [EOL] def test_annotation_specs_list_label_from_history_id ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] histories , _ = service . api . get_annotation_specs_histories ( project_id ) [EOL] history_id = histories [ [number] ] [ [string] ] [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , history_id , [string] , out_file , ] ) [EOL] [EOL] def test_annotation_specs_list_label_color ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] [EOL] class TestFilesystem : [EOL] def test_filesystem ( self ) : [EOL] zip_path = data_path / [string] [EOL] output_image_dir = out_path / [string] [EOL] label_color_file = data_path / [string] [EOL] [EOL] main ( [ [string] , [string] , [string] , str ( zip_path ) , [string] , str ( output_image_dir ) , [string] , [string] , [string] , f" [string] { str ( label_color_file ) }" , [string] , [string] , ] ) [EOL] [EOL] [EOL] class TestInputData : [EOL] command_name = [string] [EOL] [EOL] def test_delete_input_data ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] ] ) [EOL] [EOL] def test_list_input_data ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] def test_list_input_data_with_batch ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] def test_list_input_data_merged_task_with_downloading ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_input_data_merged_task_with_json ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , str ( data_path / [string] ) , [string] , str ( data_path / [string] ) , [string] , out_file , ] ) [EOL] [EOL] def test_put_input_data ( self ) : [EOL] csv_file = str ( data_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , csv_file , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] @ pytest . mark . submitting_job def test_put_input_data_with_zip ( self ) : [EOL] [comment] [EOL] zip_file = str ( data_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , zip_file , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] class TestInspectionComment : [EOL] def test_list_inspection_comment ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , task_id , [string] , out_file ] ) [EOL] [EOL] def test_list_inspection_comment_from_json ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] inspection_comment_json = str ( data_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , inspection_comment_json , [string] , out_file , ] ) [EOL] [EOL] def test_list_unprocessed_inspection_comment ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , task_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_unprocessed_inspection_comment_from_json ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] inspection_comment_json = str ( data_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , inspection_comment_json , [string] , out_file , ] ) [EOL] [EOL] [EOL] class TestInstruction : [EOL] def test_upload_instruction ( self ) : [EOL] html_file = str ( data_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , html_file ] ) [EOL] [EOL] def test_copy_instruction ( self ) : [EOL] src_project_id = project_id [EOL] dest_project_id = project_id [EOL] main ( [ [string] , [string] , src_project_id , dest_project_id , [string] ] ) [EOL] [EOL] [EOL] class TestJob : [EOL] def test_list_job ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] def test_list_last_job ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] [EOL] class TestLabor : [EOL] def test_list_worktime_by_user_with_project_id ( self ) : [EOL] output_dir = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , service . api . login_user_id , [string] , [string] , [string] , [string] , [string] , [string] , str ( output_dir ) , ] ) [EOL] [EOL] def test_list_worktime_by_user_with_organization_name ( self ) : [EOL] output_dir = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , organization_name , [string] , service . api . login_user_id , [string] , [string] , [string] , [string] , [string] , str ( output_dir ) , ] ) [EOL] [EOL] [EOL] class TestOrganizationMember : [EOL] def test_list_organization_member ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , organization_name , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] [EOL] class TestProject : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_diff_project ( self ) : [EOL] main ( [ [string] , [string] , project_id , project_id ] ) [EOL] [EOL] def test_download_project_task ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_download_project_input_data ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_download_project_inspection_comment ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_download_project_task_history_event ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_download_project_task_history ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_download_project_simple_annotation ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , out_file ] ) [EOL] [EOL] def test_list_project ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , organization_name , [string] , [string] , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] def test_update_annotation_zip ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id ] ) [EOL] [EOL] [EOL] class TestProjectMember : [EOL] def test_put_project_member ( self ) : [EOL] csv_file = str ( data_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , csv_file , [string] ] ) [EOL] [EOL] def test_list_project_member ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id ] ) [EOL] main ( [ [string] , [string] , [string] , organization_name ] ) [EOL] [EOL] def test_copy_project_member ( self ) : [EOL] main ( [ [string] , [string] , project_id , project_id , [string] ] ) [EOL] [EOL] def test_invite_project_member ( self ) : [EOL] main ( [ [string] , [string] , [string] , user_id , [string] , [string] , [string] , project_id ] ) [EOL] [EOL] def test_change_project_member ( self ) : [EOL] main ( [ [string] , [string] , [string] , [string] , project_id , [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] class TestStatistics : [EOL] def test_visualize ( self ) : [EOL] output_dir = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] , [string] , output_dir , [string] , ] ) [EOL] [EOL] def test_list_task_progress ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_cumulative_labor_time ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_annotation_count ( self ) : [EOL] output_dir = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , output_dir , [string] , [string] , ] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , output_dir , [string] , [string] , ] ) [EOL] [EOL] def test_summarize_task_count ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , str ( data_path / [string] ) , [string] , out_file , ] ) [EOL] [EOL] def test_summarize_task_count_by_task_id ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_summarize_task_count_by_user ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_by_date_user ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_labor_time_per_user ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] [EOL] class TestSupplementary : [EOL] def test_list_supplementary ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , [string] ] ) [EOL] [EOL] def test_put_supplementar ( self ) : [EOL] main ( [ [string] , [string] , [string] , project_id , [string] , str ( data_path / [string] ) , [string] , [string] , ] ) [EOL] [EOL] [EOL] class TestTask : [EOL] command_name = [string] [EOL] [EOL] def test_cancel_acceptance ( self ) : [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , task_id , [string] ] ) [EOL] [EOL] def test_change_operator ( self ) : [EOL] [comment] [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , task_id , [string] , user_id , [string] , ] ) [EOL] [EOL] [comment] [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , task_id , [string] , [string] , ] ) [EOL] [EOL] def test_delete_task ( self ) : [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , [string] , [string] ] ) [EOL] [EOL] def test_list ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , f' [string] { user_id } [string] ' , [string] , out_file , [string] , [string] , ] ) [EOL] [EOL] def test_list_with_task_json ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] task_json = str ( data_path / [string] ) [EOL] [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , task_json , [string] , out_file , [string] , [string] , ] ) [EOL] [EOL] def test_list_added_task_history ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , f' [string] { user_id } [string] ' , [string] , out_file , [string] , [string] , ] ) [EOL] [EOL] def test_list_added_task_history_with_downloading ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , out_file , ] ) [EOL] [EOL] def test_list_task_history ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , task_id , [string] , [string] , [string] , out_file , ] ) [EOL] [EOL] def test_list_input_data_merged_task_with_json ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , out_file , [string] , str ( data_path / [string] ) , [string] , str ( data_path / [string] ) , ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ pytest . mark . submitting_job def test_put_task ( self ) : [EOL] csv_file = str ( data_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , csv_file , ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class TestExperimental : [EOL] command_name = [string] [EOL] [EOL] def test_list_labor_worktime ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , [string] , [string] , [string] , [string] , str ( out_file ) , [string] , ] ) [EOL] [EOL] def test_dashboad ( self ) : [EOL] out_file = str ( out_path / [string] ) [EOL] main ( [ self . command_name , [string] , [string] , project_id , [string] , [string] , [string] , str ( out_file ) , [string] , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
import pathlib [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] from annofabcli . experimental . mask_user_info import create_masked_name , create_masked_user_info_df [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] [EOL] [EOL] class TestMaskUserInfo : [EOL] def test_create_masked_name ( self ) : [EOL] assert create_masked_name ( [string] ) == [string] [EOL] [EOL] def test_create_masked_user_info_df ( self ) : [EOL] [comment] [EOL] df = create_masked_user_info_df ( test_dir / [string] , csv_header = [number] ) [EOL] print ( df ) [EOL] [EOL] df = create_masked_user_info_df ( test_dir / [string] , csv_header = [number] , not_masked_biography_set = { [string] } , not_masked_user_id_set = None ) [EOL] print ( df ) [EOL] [EOL] df = create_masked_user_info_df ( test_dir / [string] , csv_header = [number] , not_masked_biography_set = None , not_masked_user_id_set = { [string] } ) [EOL] print ( df ) [EOL] [EOL] df = create_masked_user_info_df ( test_dir / [string] , csv_header = [number] , not_masked_biography_set = { [string] } , not_masked_user_id_set = { [string] } ) [EOL] print ( df ) [EOL] [EOL] def test_create_masked_user_info_df2 ( self ) : [EOL] [comment] [EOL] df = create_masked_user_info_df ( test_dir / [string] , csv_header = [number] , not_masked_biography_set = { [string] } , not_masked_user_id_set = { [string] } ) [EOL] print ( df ) [EOL] [EOL] def test_create_masked_user_info_df3 ( self ) : [EOL] [comment] [EOL] df = create_masked_user_info_df ( test_dir / [string] , csv_header = [number] ) [EOL] print ( df ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple [EOL] import annofabapi [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] import json [EOL] import os [EOL] import zipfile [EOL] from pathlib import Path [EOL] [EOL] from annofabapi . parser import SimpleAnnotationDirParser , SimpleAnnotationParser , SimpleAnnotationZipParser [EOL] [EOL] from annofabcli . common . image import write_annotation_image , write_annotation_images_from_path [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] [EOL] with ( test_dir / [string] ) . open ( encoding = [string] ) as f : [EOL] label_color_json = json . load ( f ) [EOL] label_color_dict = { label_name : tuple ( rgb ) for label_name , rgb in label_color_json . items ( ) } [EOL] [EOL] [EOL] def test_write_image ( ) : [EOL] zip_path = test_dir / [string] [EOL] output_image_file = out_dir / [string] [EOL] [EOL] with zipfile . ZipFile ( zip_path ) as zip_file : [EOL] parser = SimpleAnnotationZipParser ( zip_file , [string] ) [EOL] [EOL] write_annotation_image ( parser = parser , image_size = ( [number] , [number] ) , label_color_dict = label_color_dict , output_image_file = output_image_file , background_color = ( [number] , [number] , [number] ) , ) [EOL] [EOL] [EOL] def test_write_image_wihtout_outer_file ( ) : [EOL] output_image_file = out_dir / [string] [EOL] [EOL] [comment] [EOL] parser = SimpleAnnotationDirParser ( test_dir / [string] ) [EOL] write_annotation_image ( parser = parser , image_size = ( [number] , [number] ) , label_color_dict = label_color_dict , output_image_file = output_image_file , background_color = ( [number] , [number] , [number] ) , ) [EOL] [EOL] [EOL] def test_write_annotation_images_from_path ( ) : [EOL] zip_path = test_dir / [string] [EOL] output_image_dir = out_dir / [string] [EOL] [EOL] def is_target_parser_func ( parser ) : [EOL] return parser . task_id == [string] [EOL] [EOL] write_annotation_images_from_path ( annotation_path = zip_path , image_size = ( [number] , [number] ) , label_color_dict = label_color_dict , output_dir_path = output_image_dir , background_color = ( [number] , [number] , [number] ) , is_target_parser_func = is_target_parser_func , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import configparser [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] [EOL] from annofabcli . task . change_operator import ChangeOperatorMain [EOL] from tests . utils_for_test import set_logger [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] out_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] task_id = annofab_config [ [string] ] [EOL] service = annofabapi . build ( ) [EOL] [EOL] set_logger ( ) [EOL] [EOL] [EOL] class TestChangeOperator : [EOL] @ classmethod def setup_class ( cls ) : [EOL] cls . main_obj = ChangeOperatorMain ( service , all_yes = True ) [EOL] [EOL] def test_change_operator_for_task ( self ) : [EOL] actual = self . main_obj . change_operator_for_task ( project_id = project_id , task_id = task_id , new_account_id = None ) [EOL] print ( actual ) [EOL] [EOL] def test_change_operator ( self ) : [EOL] actual = self . main_obj . change_operator ( project_id = project_id , task_id_list = [ task_id ] , new_user_id = service . api . login_user_id ) [EOL] print ( actual ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , Any [EOL] import configparser [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import annofabapi [EOL] [EOL] from annofabcli . common . facade import AnnofabApiFacade [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] inifile = configparser . ConfigParser ( ) [EOL] inifile . read ( [string] , [string] ) [EOL] annofab_config = dict ( inifile . items ( [string] ) ) [EOL] [EOL] project_id = annofab_config [ [string] ] [EOL] [EOL] service = annofabapi . build_from_netrc ( ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] out_path = Path ( [string] ) [EOL] data_path = Path ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 $typing.Any$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pathlib [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] from annofabcli . project_member . change_project_members import ChangeProjectMembers [EOL] from annofabcli . project_member . put_project_members import Member , PutProjectMembers [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) + [string] ) [EOL] [EOL] test_dir = Path ( [string] ) [EOL] out_dir = Path ( [string] ) [EOL] [EOL] [EOL] class TestPutProjectMembers : [EOL] def test_get_members_from_csv ( self ) : [EOL] csv_path = test_dir / [string] [EOL] actual_members = PutProjectMembers . get_members_from_csv ( csv_path ) [EOL] expected_members = [ Member ( [string] , ProjectMemberRole . OWNER , sampling_inspection_rate = None , sampling_acceptance_rate = None ) , Member ( [string] , ProjectMemberRole . ACCEPTER , sampling_inspection_rate = [number] , sampling_acceptance_rate = [number] ) , Member ( [string] , ProjectMemberRole . WORKER , sampling_inspection_rate = None , sampling_acceptance_rate = [number] ) , Member ( [string] , ProjectMemberRole . TRAINING_DATA_USER , sampling_inspection_rate = [number] , sampling_acceptance_rate = None , ) , ] [EOL] assert actual_members == expected_members [EOL] [EOL] [EOL] class TestChangeProjectMembers : [EOL] def test_validate_member_info ( self ) : [EOL] assert ( ChangeProjectMembers . validate_member_info ( { [string] : [number] , [string] : [number] , [string] : [string] } ) == True ) [EOL] [EOL] assert ChangeProjectMembers . validate_member_info ( { [string] : [number] } ) == True [EOL] [EOL] assert ChangeProjectMembers . validate_member_info ( { [string] : [number] } ) == True [EOL] [EOL] assert ChangeProjectMembers . validate_member_info ( { } ) == False [EOL] [EOL] assert ChangeProjectMembers . validate_member_info ( { [string] : [string] } ) == False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Sequence [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Optional , Sequence [EOL] [EOL] import annofabcli . annotation . subcommand_annotation [EOL] import annofabcli . annotation_specs . subcommand_annotation_specs [EOL] import annofabcli . experimental . subcommand_experimental [EOL] import annofabcli . filesystem . subcommand_filesystem [EOL] import annofabcli . input_data . subcommand_input_data [EOL] import annofabcli . inspection_comment . subcommand_inspection_comment [EOL] import annofabcli . instruction . subcommand_instruction [EOL] import annofabcli . job . subcommand_job [EOL] import annofabcli . labor . subcommand_labor [EOL] import annofabcli . organization_member . subcommand_organization_member [EOL] import annofabcli . project . subcommand_project [EOL] import annofabcli . project_member . subcommand_project_member [EOL] import annofabcli . statistics . subcommand_statistics [EOL] import annofabcli . supplementary . subcommand_supplementary [EOL] import annofabcli . task . subcommand_task [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def main ( arguments = None ) : [EOL] [docstring] [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] , formatter_class = argparse . ArgumentDefaultsHelpFormatter ) [EOL] parser . add_argument ( [string] , action = [string] , version = f" [string] { annofabcli . __version__ }" ) [EOL] parser . set_defaults ( command_help = parser . print_help ) [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] annofabcli . annotation . subcommand_annotation . add_parser ( subparsers ) [EOL] annofabcli . annotation_specs . subcommand_annotation_specs . add_parser ( subparsers ) [EOL] annofabcli . input_data . subcommand_input_data . add_parser ( subparsers ) [EOL] annofabcli . inspection_comment . subcommand_inspection_comment . add_parser ( subparsers ) [EOL] annofabcli . instruction . subcommand_instruction . add_parser ( subparsers ) [EOL] annofabcli . job . subcommand_job . add_parser ( subparsers ) [EOL] annofabcli . labor . subcommand_labor . add_parser ( subparsers ) [EOL] annofabcli . organization_member . subcommand_organization_member . add_parser ( subparsers ) [EOL] annofabcli . project . subcommand_project . add_parser ( subparsers ) [EOL] annofabcli . project_member . subcommand_project_member . add_parser ( subparsers ) [EOL] annofabcli . statistics . subcommand_statistics . add_parser ( subparsers ) [EOL] annofabcli . supplementary . subcommand_supplementary . add_parser ( subparsers ) [EOL] annofabcli . task . subcommand_task . add_parser ( subparsers ) [EOL] [EOL] annofabcli . filesystem . subcommand_filesystem . add_parser ( subparsers ) [EOL] annofabcli . experimental . subcommand_experimental . add_parser ( subparsers ) [EOL] [EOL] if arguments is None : [EOL] args = parser . parse_args ( ) [EOL] else : [EOL] args = parser . parse_args ( arguments ) [EOL] [EOL] if hasattr ( args , [string] ) : [EOL] try : [EOL] annofabcli . cli . load_logging_config_from_args ( args ) [EOL] args . subcommand_func ( args ) [EOL] except Exception as e : [EOL] logger . exception ( e ) [EOL] raise e [EOL] [EOL] else : [EOL] [comment] [EOL] args . command_help ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
[comment] [EOL] from typing import Dict , List , Tuple , Callable , Any , Optional , Literal , Type [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import PIL [EOL] import annofabcli [EOL] import typing_extensions [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import logging [EOL] import uuid [EOL] from pathlib import Path [EOL] from typing import Any , Callable , Dict , List [EOL] [EOL] import annofabapi [EOL] import PIL [EOL] import PIL . Image [EOL] import PIL . ImageDraw [EOL] from annofabapi . models import Annotation [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import build_annofabapi_resource_and_login [EOL] from annofabcli . common . typing import InputDataSize [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] FilterDetailsFunc = Callable [ [ Annotation ] , bool ] [EOL] [docstring] [EOL] [EOL] [EOL] class RegisterAnnotation : [EOL] def __init__ ( self , service , facade ) : [EOL] self . service = service [EOL] self . facade = facade [EOL] [EOL] [comment] [EOL] def get_annotations_for_editor ( self , project_id , task_id , input_data_id ) : [EOL] url_path = f" [string] { project_id } [string] { task_id } [string] { input_data_id } [string] " [EOL] http_method = [string] [EOL] keyword_params = { } [EOL] return self . service . api . _request_wrapper ( http_method , url_path , ** keyword_params ) [EOL] [EOL] @ staticmethod def draw_annotation_list ( annotation_list , draw ) : [EOL] [docstring] [EOL] for annotation in annotation_list : [EOL] data = annotation [ [string] ] [EOL] color = ( [number] , [number] , [number] , [number] ) [EOL] data_type = data [ [string] ] [EOL] if data_type == [string] : [EOL] xy = [ ( data [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] ) , ( data [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] ) , ] [EOL] draw . rectangle ( xy , fill = color ) [EOL] [EOL] elif data_type == [string] : [EOL] [comment] [EOL] xy = [ ( e [ [string] ] , e [ [string] ] ) for e in data [ [string] ] ] [EOL] draw . polygon ( xy , fill = color ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return draw [EOL] [EOL] def update_annotation_with_image ( self , project_id , task_id , input_data_id , image_file_list , account_id , filter_details , ) : [EOL] [docstring] [EOL] [EOL] old_annotations = self . get_annotations_for_editor ( project_id , task_id , input_data_id ) [ [number] ] [EOL] old_details = old_annotations [ [string] ] [EOL] [EOL] details = [ e for e in old_details if filter_details ( e ) ] [EOL] for detail in details : [EOL] detail . pop ( [string] , None ) [EOL] detail . pop ( [string] , None ) [EOL] [EOL] for e in image_file_list : [EOL] image_file = e [ [string] ] [EOL] label_id = e [ [string] ] [EOL] [EOL] s3_path = self . service . wrapper . upload_file_to_s3 ( project_id , image_file , [string] ) [EOL] annotation_id = str ( uuid . uuid4 ( ) ) [EOL] [EOL] detail = { [string] : account_id , [string] : [ ] , [string] : annotation_id , [string] : None , [string] : None , [string] : [string] , [string] : None , [string] : False , [string] : label_id , [string] : s3_path , [string] : None , [string] : None , } [EOL] [EOL] details . append ( detail ) [EOL] [EOL] request_body = { [string] : project_id , [string] : task_id , [string] : input_data_id , [string] : details , [string] : old_annotations [ [string] ] , } [EOL] [EOL] return self . service . api . put_annotation ( project_id , task_id , input_data_id , request_body = request_body ) [ [number] ] [EOL] [EOL] def write_segmentation_image ( self , input_data , label , label_id , tmp_image_path , input_data_size , ) : [EOL] [EOL] image = PIL . Image . new ( mode = [string] , size = input_data_size , color = ( [number] , [number] , [number] , [number] ) ) [EOL] draw = PIL . ImageDraw . Draw ( image ) [EOL] [EOL] [comment] [EOL] annotation_list = [ e for e in input_data [ [string] ] if e [ [string] ] == label_id ] [EOL] if len ( annotation_list ) == [number] : [EOL] logger . info ( f"{ input_data [ [string] ] } [string] { input_data [ [string] ] } [string] " f" [string] { label } [string] { label_id } [string] " ) [EOL] return False [EOL] [EOL] [comment] [EOL] self . draw_annotation_list ( annotation_list , draw ) [EOL] [EOL] tmp_image_path . parent . mkdir ( parents = True , exist_ok = True ) [EOL] image . save ( str ( tmp_image_path ) ) [EOL] logger . info ( f"{ str ( tmp_image_path ) } [string] " ) [EOL] return True [EOL] [EOL] def write_segmentation_image_for_labels ( self , labels , input_data , default_input_data_size , tmp_image_dir , ) : [EOL] [docstring] [EOL] [EOL] image_file_list = [ ] [EOL] for label_dict in labels : [EOL] label = label_dict [ [string] ] [EOL] label_id = label_dict [ [string] ] [EOL] [EOL] tmp_image_path = tmp_image_dir / f"{ label } [string] " [EOL] [EOL] result = self . write_segmentation_image ( input_data = input_data , label = label , label_id = label_id , tmp_image_path = tmp_image_path , input_data_size = default_input_data_size , ) [EOL] [EOL] if result : [EOL] image_file_list . append ( { [string] : str ( tmp_image_path ) , [string] : label_id } ) [EOL] [EOL] return image_file_list [EOL] [EOL] def register_raster_annotation_from_polygon ( self , annotation_dir , default_input_data_size , tmp_dir , labels , project_id , task_id_list , filter_details , ) : [EOL] annotation_dir_path = Path ( annotation_dir ) [EOL] tmp_dir_path = Path ( tmp_dir ) [EOL] [EOL] tmp_dir_path . mkdir ( exist_ok = True ) [EOL] [EOL] account_id = self . facade . get_my_account_id ( ) [EOL] [EOL] for task_id in task_id_list : [EOL] task_dir = annotation_dir_path / task_id [EOL] [EOL] for input_data_json_path in task_dir . iterdir ( ) : [EOL] if not input_data_json_path . is_file ( ) : [EOL] continue [EOL] [EOL] with open ( str ( input_data_json_path ) ) as f : [EOL] input_data = json . load ( f ) [EOL] [EOL] input_data_id = input_data [ [string] ] [EOL] [EOL] tmp_image_dir = tmp_dir_path / task_dir . name / input_data_json_path . stem [EOL] try : [EOL] image_file_list = self . write_segmentation_image_for_labels ( labels , input_data , default_input_data_size , tmp_image_dir ) [EOL] [EOL] except Exception as e : [EOL] logger . exception ( e ) [EOL] logger . warning ( f"{ task_id } [string] { input_data_id } [string] { str ( tmp_image_dir ) } [string] " ) [EOL] continue [EOL] [EOL] if len ( image_file_list ) == [number] : [EOL] continue [EOL] [EOL] try : [EOL] [comment] [EOL] task = self . service . api . get_task ( project_id , task_id ) [ [number] ] [EOL] if task [ [string] ] == account_id and task [ [string] ] == [string] : [EOL] logger . info ( f"{ task_id } [string] { input_data_id } [string] " ) [EOL] else : [EOL] self . facade . change_operator_of_task ( project_id , task_id , account_id ) [EOL] self . facade . change_to_working_status ( project_id , task_id , account_id ) [EOL] except Exception as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f"{ task_id } [string] { input_data_id } [string] " ) [EOL] continue [EOL] [EOL] try : [EOL] [comment] [EOL] self . update_annotation_with_image ( project_id , task_id , input_data_id , account_id = account_id , image_file_list = image_file_list , filter_details = filter_details , ) [EOL] [EOL] self . facade . change_to_break_phase ( project_id , task_id ) [EOL] [EOL] logger . info ( f"{ task_id } [string] { input_data_id } [string] " ) [EOL] [EOL] except Exception as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f"{ task_id } [string] { input_data_id } [string] " ) [EOL] [EOL] def main ( self , args ) : [EOL] [docstring] [EOL] [EOL] annofabcli . common . cli . load_logging_config_from_args ( args , __file__ ) [EOL] [EOL] logger . info ( f" [string] { args }" ) [EOL] [EOL] try : [EOL] default_input_data_size = annofabcli . common . cli . get_input_data_size ( args . input_data_size ) [EOL] [EOL] except Exception as e : [EOL] logger . error ( [string] ) [EOL] raise e [EOL] [EOL] def filter_details ( annotation ) : [EOL] [docstring] [EOL] exclude_label_ids = [ [string] , [string] , ] [EOL] label_id = annotation [ [string] ] [EOL] [comment] [EOL] return label_id not in exclude_label_ids [EOL] [EOL] labels = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL] [EOL] task_id_list = annofabcli . utils . read_lines_except_blank_line ( args . task_id_file ) [EOL] [EOL] self . register_raster_annotation_from_polygon ( annotation_dir = args . annotation_dir , default_input_data_size = default_input_data_size , tmp_dir = args . tmp_dir , labels = labels , project_id = args . project_id , filter_details = filter_details , task_id_list = task_id_list , ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] RegisterAnnotation ( service , facade ) . main ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] global_parser = argparse . ArgumentParser ( description = [string] [string] , parents = [ annofabcli . common . cli . create_parent_parser ( ) ] , ) [EOL] [EOL] parse_args ( global_parser ) [EOL] [EOL] try : [EOL] main ( global_parser . parse_args ( ) ) [EOL] except Exception as e : [EOL] logger . exception ( e ) [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 $pathlib.Path$ 0 $annofabcli.common.typing.InputDataSize$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.typing.InputDataSize$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $annofabcli.common.typing.InputDataSize$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $annofabcli.common.typing.InputDataSize$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabcli.common.typing.InputDataSize$ 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $FilterDetailsFunc$ 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Any$ 0 $annofabcli.common.typing.InputDataSize$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $FilterDetailsFunc$ 0 $FilterDetailsFunc$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $annofabapi.models.Annotation$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $annofabapi.models.Annotation$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from annofabcli . common import cli , enums , exceptions , typing , utils [EOL] from annofabcli . common . facade import AnnofabApiFacade [EOL] [EOL] from . __version__ import __version__ [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . labor . list_worktime_by_user [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . labor . list_worktime_by_user . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Callable , Any , Optional , Type [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import logging [EOL] import sys [EOL] from typing import Callable , List , Optional [EOL] [EOL] import annofabapi [EOL] import requests [EOL] from annofabapi . models import Inspection [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] from annofabcli . common . visualize import AddProps [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] FilterInspectionFunc = Callable [ [ Inspection ] , bool ] [EOL] [EOL] [EOL] def create_filter_func ( only_reply , exclude_reply , ) : [EOL] def filter_inspection ( arg_inspection ) : [comment] [EOL] [comment] [EOL] if only_reply : [EOL] if arg_inspection [ [string] ] is None : [EOL] return False [EOL] [EOL] if exclude_reply : [EOL] if arg_inspection [ [string] ] is not None : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] return filter_inspection [EOL] [EOL] [EOL] class PrintInspections ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] self . visualize = AddProps ( self . service , args . project_id ) [EOL] [EOL] def filter_inspection_list ( self , inspection_list , task_id_list = None , arg_filter_inspection = None , ) : [EOL] [docstring] [EOL] [EOL] def filter_task_id ( e ) : [EOL] if task_id_list is None or len ( task_id_list ) == [number] : [EOL] return True [EOL] return e [ [string] ] in task_id_list [EOL] [EOL] def filter_inspection ( e ) : [EOL] if arg_filter_inspection is None : [EOL] return True [EOL] return arg_filter_inspection ( e ) [EOL] [EOL] inspection_list = [ e for e in inspection_list if filter_inspection ( e ) and filter_task_id ( e ) ] [EOL] return [ self . visualize . add_properties_to_inspection ( e ) for e in inspection_list ] [EOL] [EOL] def print_inspections ( self , project_id , task_id_list , filter_inspection = None , inspection_list_from_json = None , ) : [EOL] [docstring] [EOL] [EOL] if inspection_list_from_json is None : [EOL] inspection_list = self . get_inspections ( project_id , task_id_list = task_id_list , filter_inspection = filter_inspection ) [EOL] [EOL] else : [EOL] inspection_list = self . filter_inspection_list ( inspection_list_from_json , task_id_list = task_id_list , arg_filter_inspection = filter_inspection ) [EOL] [EOL] logger . info ( f" [string] { len ( inspection_list ) }" ) [EOL] [EOL] self . print_according_to_format ( inspection_list ) [EOL] [EOL] def get_inspections_by_input_data ( self , project_id , task_id , input_data_id , input_data_index ) : [EOL] [docstring] [EOL] [EOL] detail = { [string] : input_data_index } [EOL] inspectins , _ = self . service . api . get_inspections ( project_id , task_id , input_data_id ) [EOL] return [ self . visualize . add_properties_to_inspection ( e , detail ) for e in inspectins ] [EOL] [EOL] def get_inspections ( self , project_id , task_id_list , filter_inspection = None ) : [EOL] [docstring] [EOL] [EOL] all_inspections = [ ] [EOL] for task_id in task_id_list : [EOL] try : [EOL] task , _ = self . service . api . get_task ( project_id , task_id ) [EOL] input_data_id_list = task [ [string] ] [EOL] logger . info ( f" [string] { task_id } [string] { len ( input_data_id_list ) }" ) [EOL] for input_data_index , input_data_id in enumerate ( input_data_id_list ) : [EOL] [EOL] inspections = self . get_inspections_by_input_data ( project_id , task_id , input_data_id , input_data_index ) [EOL] [EOL] if filter_inspection is not None : [EOL] inspections = [ e for e in inspections if filter_inspection ( e ) ] [EOL] [EOL] all_inspections . extend ( inspections ) [EOL] [EOL] except requests . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] [EOL] return all_inspections [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] if args . inspection_comment_json is None and args . task_id is None : [EOL] print ( [string] [string] , file = sys . stderr , ) [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] if args . inspection_comment_json is not None : [EOL] with open ( args . inspection_comment_json , encoding = [string] ) as f : [EOL] inspection_list = json . load ( f ) [EOL] else : [EOL] inspection_list = None [EOL] [EOL] filter_inspection = create_filter_func ( only_reply = args . only_reply , exclude_reply = args . exclude_reply ) [EOL] self . print_inspections ( args . project_id , task_id_list , inspection_list_from_json = inspection_list , filter_inspection = filter_inspection , ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( required = False , help_message = [string] [string] [string] , ) [EOL] [EOL] reply_comment_group = parser . add_mutually_exclusive_group ( ) [EOL] reply_comment_group . add_argument ( [string] , action = [string] , help = [string] ) [EOL] reply_comment_group . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON , FormatArgument . INSPECTION_ID_LIST , ] , default = FormatArgument . CSV , ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_query ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] PrintInspections ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] [EOL] subcommand_help = [string] [EOL] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[annofabapi.models.Inspection],builtins.bool]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.common.visualize.AddProps$ 0 0 0 0 0 $annofabapi.Resource$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 $typing.Optional[typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.Optional[FilterInspectionFunc]$ 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[annofabapi.models.Inspection]]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Optional[FilterInspectionFunc]$ 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Optional , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import json [EOL] import logging [EOL] import sys [EOL] from typing import Callable , Optional [EOL] [EOL] from annofabapi . models import Inspection [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ArgumentParser , FormatArgument , build_annofabapi_resource_and_login [EOL] from annofabcli . inspection_comment . list_inspections import PrintInspections [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def create_filter_func ( commenter_user_id , inspection_comment , phase , phase_stage , ) : [EOL] def filter_inspection ( arg_inspection ) : [comment] [EOL] [EOL] [comment] [EOL] if arg_inspection [ [string] ] != [string] : [EOL] return False [EOL] [EOL] [comment] [EOL] if arg_inspection [ [string] ] is not None : [EOL] return False [EOL] [EOL] if commenter_user_id is not None : [EOL] if arg_inspection [ [string] ] != commenter_user_id : [EOL] return False [EOL] [EOL] if inspection_comment is not None : [EOL] if arg_inspection [ [string] ] != inspection_comment : [EOL] return False [EOL] [EOL] if phase is not None : [EOL] if arg_inspection [ [string] ] != phase : [EOL] return False [EOL] [EOL] if phase_stage is not None : [EOL] if arg_inspection [ [string] ] != phase_stage : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] return filter_inspection [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( required = False , help_message = [string] [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON , FormatArgument . INSPECTION_ID_LIST , ] , default = FormatArgument . CSV , ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_query ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def validate ( args ) : [EOL] if args . inspection_comment_json is None and args . task_id is None : [EOL] print ( [string] [string] , file = sys . stderr , ) [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] [EOL] if not validate ( args ) : [EOL] return [EOL] [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] [EOL] filter_inspection = create_filter_func ( args . commenter_user_id , args . inspection_comment , phase = args . phase , phase_stage = args . phase_stage ) [EOL] [EOL] if args . inspection_comment_json is not None : [EOL] with open ( args . inspection_comment_json , encoding = [string] ) as f : [EOL] inspection_list = json . load ( f ) [EOL] else : [EOL] inspection_list = None [EOL] [EOL] PrintInspections ( service , facade , args ) . print_inspections ( project_id = args . project_id , task_id_list = task_id_list , filter_inspection = filter_inspection , inspection_list_from_json = inspection_list , ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] [EOL] subcommand_help = [string] [EOL] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[annofabapi.models.Inspection],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . inspection_comment . list_inspections [EOL] import annofabcli . inspection_comment . list_unprocessed_inspections [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . inspection_comment . list_inspections . add_parser ( subparsers ) [EOL] annofabcli . inspection_comment . list_unprocessed_inspections . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import logging [EOL] from typing import List [EOL] [EOL] import requests [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class InviteUser ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def assign_role_with_organization ( self , organization_name , user_id_list , member_role ) : [EOL] [EOL] [comment] [EOL] my_account_id = self . facade . get_my_account_id ( ) [EOL] projects = self . service . wrapper . get_all_projects_of_organization ( organization_name , query_params = { [string] : [string] , [string] : my_account_id } ) [EOL] [EOL] for project in projects : [EOL] project_id = project [ [string] ] [EOL] project_title = project [ [string] ] [EOL] [EOL] try : [EOL] if not self . facade . my_role_is_owner ( project_id ) : [EOL] logger . warning ( f" [string] " f" [string] { project_id } [string] { project_title }" ) [EOL] continue [EOL] [EOL] self . service . wrapper . assign_role_to_project_members ( project_id , user_id_list , member_role ) [EOL] logger . info ( f"{ project_title } [string] { project_id }" ) [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { project_title } [string] " ) [EOL] [EOL] def assign_role_with_project_id ( self , project_id_list , user_id_list , member_role ) : [EOL] for project_id in project_id_list : [EOL] [EOL] try : [EOL] if not self . facade . my_role_is_owner ( project_id ) : [EOL] logger . warning ( f" [string] " f" [string] { project_id }" ) [EOL] continue [EOL] [EOL] project_title = self . service . api . get_project ( project_id ) [ [number] ] [ [string] ] [EOL] self . service . wrapper . assign_role_to_project_members ( project_id , user_id_list , member_role ) [EOL] logger . info ( f"{ project_title } [string] { project_id }" ) [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { project_id }" ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] user_id_list = annofabcli . common . cli . get_list_from_args ( args . user_id ) [EOL] [EOL] if args . organization is not None : [EOL] self . assign_role_with_organization ( args . organization , user_id_list , args . role ) [EOL] [EOL] elif args . project_id is not None : [EOL] project_id_list = annofabcli . common . cli . get_list_from_args ( args . project_id ) [EOL] self . assign_role_with_project_id ( project_id_list , user_id_list , args . role ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] InviteUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] role_choices = [ ProjectMemberRole . OWNER . value , ProjectMemberRole . WORKER . value , ProjectMemberRole . ACCEPTER . value , ProjectMemberRole . TRAINING_DATA_USER . value , ] [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , nargs = [string] , required = True , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , choices = role_choices , help = [string] ) [EOL] [EOL] assign_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] assign_group . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] , ) [EOL] assign_group . add_argument ( [string] , [string] , type = str , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] [docstring] [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import more_itertools [EOL] import requests [EOL] from annofabapi . models import ProjectMember [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] from annofabcli . common . visualize import AddProps [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ListUser ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def get_all_project_members ( self , project_id , include_inactive = False , include_outside_organization = False ) : [EOL] def member_exists ( members , account_id ) : [EOL] m = more_itertools . first_true ( members , default = None , pred = lambda e : e [ [string] ] == account_id ) [EOL] return m is not None [EOL] [EOL] query_params = { } [EOL] if include_inactive : [EOL] query_params . update ( { [string] : [string] } ) [EOL] [EOL] project_members = self . service . wrapper . get_all_project_members ( project_id , query_params = query_params ) [EOL] organization_members = self . facade . get_organization_members_from_project_id ( project_id ) [EOL] [EOL] [comment] [EOL] if not include_outside_organization : [EOL] project_members = [ e for e in project_members if member_exists ( organization_members , e [ [string] ] ) ] [EOL] [EOL] return project_members [EOL] [EOL] def get_project_members_with_organization ( self , organization_name , include_inactive = False , include_outside_organization = False ) : [EOL] [EOL] [comment] [EOL] my_account_id = self . facade . get_my_account_id ( ) [EOL] projects = self . service . wrapper . get_all_projects_of_organization ( organization_name , query_params = { [string] : [string] , [string] : my_account_id } ) [EOL] [EOL] all_project_members = [ ] [EOL] [EOL] for project in projects : [EOL] project_id = project [ [string] ] [EOL] project_title = project [ [string] ] [EOL] [EOL] project_members = self . get_all_project_members ( project_id , include_inactive = include_inactive , include_outside_organization = include_outside_organization ) [EOL] logger . info ( f"{ project_title } [string] { len ( project_members ) } [string] { project_id }" ) [EOL] [EOL] for member in project_members : [EOL] AddProps . add_properties_of_project ( member , project_title ) [EOL] [EOL] all_project_members . extend ( project_members ) [EOL] [EOL] return all_project_members [EOL] [EOL] def get_project_members_with_project_id ( self , project_id_list , include_inactive = False , include_outside_organization = False ) : [EOL] all_project_members = [ ] [EOL] [EOL] for project_id in project_id_list : [EOL] try : [EOL] project , _ = self . service . api . get_project ( project_id ) [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { project_id } [string] " ) [EOL] continue [EOL] [EOL] project_title = project [ [string] ] [EOL] project_members = self . get_all_project_members ( project_id , include_inactive = include_inactive , include_outside_organization = include_outside_organization ) [EOL] logger . info ( f"{ project_title } [string] { len ( project_members ) } [string] { project_id }" ) [EOL] [EOL] for member in project_members : [EOL] AddProps . add_properties_of_project ( member , project_title ) [EOL] [EOL] all_project_members . extend ( project_members ) [EOL] [EOL] return all_project_members [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] project_members = [ ] [EOL] if args . organization is not None : [EOL] project_members = self . get_project_members_with_organization ( args . organization , include_inactive = args . include_inactive , include_outside_organization = args . include_outside_organization , ) [EOL] [EOL] elif args . project_id is not None : [EOL] project_id_list = annofabcli . common . cli . get_list_from_args ( args . project_id ) [EOL] project_members = self . get_project_members_with_project_id ( project_id_list , include_inactive = args . include_inactive , include_outside_organization = args . include_outside_organization , ) [EOL] [EOL] self . print_according_to_format ( project_members ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] list_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] list_group . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] , ) [EOL] [EOL] list_group . add_argument ( [string] , [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = ( [string] [string] ) , ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON , FormatArgument . USER_ID_LIST ] , default = FormatArgument . CSV , ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_query ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[annofabapi.models.ProjectMember]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import sys [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import requests [EOL] from annofabapi . models import ProjectMember , ProjectMemberRole , ProjectMemberStatus [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . project_member . put_project_members import PutProjectMembers [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ChangeProjectMembers ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def put_project_member ( self , project_id , user_id , old_member , member_role = None , member_info = None , ) : [EOL] [docstring] [EOL] [EOL] def get_value ( key ) : [EOL] if member_info is None : [EOL] return old_member [ key ] [EOL] [EOL] if key not in member_info : [EOL] return old_member [ key ] [EOL] [EOL] return member_info [ key ] [EOL] [EOL] str_member_role = member_role . value if member_role is not None else old_member [ [string] ] [EOL] [EOL] request_body = { [string] : ProjectMemberStatus . ACTIVE . value , [string] : str_member_role , [string] : get_value ( [string] ) , [string] : get_value ( [string] ) , [string] : old_member [ [string] ] , } [EOL] [EOL] updated_project_member = self . service . api . put_project_member ( project_id , user_id , request_body = request_body ) [ [number] ] [EOL] return updated_project_member [EOL] [EOL] def change_project_members ( self , project_id , user_id_list , member_role = None , member_info = None , ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER ] ) [EOL] [EOL] old_project_members = self . service . wrapper . get_all_project_members ( project_id ) [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] [EOL] count_invite_members = [number] [EOL] [comment] [EOL] logger . info ( f"{ project_title } [string] { len ( user_id_list ) } [string] " ) [EOL] for user_id in user_id_list : [EOL] if user_id == self . service . api . login_user_id : [EOL] logger . warning ( f" [string] { user_id } [string] " ) [EOL] continue [EOL] [EOL] old_member = PutProjectMembers . find_member ( old_project_members , user_id ) [EOL] if old_member is None : [EOL] logger . warning ( f" [string] { user_id } [string] " ) [EOL] continue [EOL] [EOL] message_for_confirm = f" [string] { user_id } [string] " [EOL] if not self . confirm_processing ( message_for_confirm ) : [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] self . put_project_member ( project_id , user_id , member_info = member_info , old_member = old_member ) [EOL] logger . debug ( f" [string] { user_id } [string] { member_role } [string] { member_info }" ) [EOL] count_invite_members += [number] [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { user_id }" ) [EOL] [EOL] logger . info ( f"{ project_title } [string] { count_invite_members } [string] { len ( user_id_list ) } [string] " ) [EOL] [EOL] def get_all_user_id_list_except_myself ( self , project_id ) : [EOL] [docstring] [EOL] member_list = self . service . wrapper . get_all_project_members ( project_id ) [EOL] return [ e [ [string] ] for e in member_list if e [ [string] ] != self . service . api . login_user_id ] [EOL] [EOL] @ staticmethod def validate ( args , member_info = None ) : [EOL] COMMON_MESSAGE = [string] [EOL] if args . role is None and args . member_info is None : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr ) [EOL] return False [EOL] [EOL] elif member_info is not None and not ChangeProjectMembers . validate_member_info ( member_info ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr ) [EOL] return False [EOL] [EOL] else : [EOL] return True [EOL] [EOL] @ staticmethod def validate_member_info ( member_info ) : [EOL] KEYS = [ [string] , [string] ] [EOL] return any ( k in member_info for k in KEYS ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] if args . all_user : [EOL] user_id_list = self . get_all_user_id_list_except_myself ( project_id ) [EOL] else : [EOL] user_id_list = annofabcli . common . cli . get_list_from_args ( args . user_id ) [EOL] [EOL] member_info = annofabcli . common . cli . get_json_from_args ( args . member_info ) [EOL] member_role = ProjectMemberRole ( args . role ) if args . role is not None else None [EOL] [EOL] if not self . validate ( args , member_info ) : [EOL] return [EOL] [EOL] self . change_project_members ( args . project_id , user_id_list = user_id_list , member_role = member_role , member_info = member_info ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ChangeProjectMembers ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] role_choices = [ e . value for e in ProjectMemberRole ] [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] user_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] user_group . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] [string] , ) [EOL] user_group . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = role_choices , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] [string] [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.ProjectMember$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[annofabapi.models.ProjectMemberRole]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[annofabapi.models.ProjectMemberRole]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $argparse.Namespace$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . project_member . change_project_members [EOL] import annofabcli . project_member . copy_project_members [EOL] import annofabcli . project_member . delete_users [EOL] import annofabcli . project_member . invite_users [EOL] import annofabcli . project_member . list_users [EOL] import annofabcli . project_member . put_project_members [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . project_member . change_project_members . add_parser ( subparsers ) [EOL] annofabcli . project_member . copy_project_members . add_parser ( subparsers ) [EOL] annofabcli . project_member . delete_users . add_parser ( subparsers ) [EOL] annofabcli . project_member . invite_users . add_parser ( subparsers ) [EOL] annofabcli . project_member . list_users . add_parser ( subparsers ) [EOL] annofabcli . project_member . put_project_members . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import annofabapi [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] from annofabcli . common . visualize import AddProps [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class AnnotationSpecsHistories ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] self . visualize = AddProps ( self . service , args . project_id ) [EOL] [EOL] def get_annotation_specs_histories ( self , project_id ) : [EOL] annotation_specs_histories , _ = self . service . api . get_annotation_specs_histories ( project_id ) [EOL] return [ self . visualize . add_properties_to_annotation_specs_history ( e ) for e in annotation_specs_histories ] [EOL] [EOL] def list_annotation_specs_histories ( self , project_id ) : [EOL] super ( ) . validate_project ( project_id ) [EOL] [EOL] annotation_specs_histories = self . get_annotation_specs_histories ( project_id ) [EOL] self . print_according_to_format ( annotation_specs_histories ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] self . list_annotation_specs_histories ( args . project_id ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] AnnotationSpecsHistories ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON ] , default = FormatArgument . CSV ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_query ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.common.visualize.AddProps$ 0 0 0 0 0 $annofabapi.Resource$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import logging [EOL] import sys [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PrintAnnotationSpecsLabel ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] COMMON_MESSAGE = [string] [EOL] [EOL] def print_annotation_specs_label ( self , project_id , arg_format , output = None , history_id = None ) : [EOL] annotation_specs = self . service . api . get_annotation_specs ( project_id , query_params = { [string] : history_id } ) [ [number] ] [EOL] labels = annotation_specs [ [string] ] [EOL] [EOL] if arg_format == [string] : [EOL] self . _print_text_format_labels ( labels , output = output ) [EOL] [EOL] elif arg_format in [ FormatArgument . JSON . value , FormatArgument . PRETTY_JSON . value ] : [EOL] annofabcli . utils . print_according_to_format ( target = labels , arg_format = FormatArgument ( arg_format ) , output = output ) [EOL] [EOL] @ staticmethod def _get_name_list ( messages ) : [EOL] [docstring] [EOL] ja_name = [ e [ [string] ] for e in messages if e [ [string] ] == [string] ] [ [number] ] [EOL] en_name = [ e [ [string] ] for e in messages if e [ [string] ] == [string] ] [ [number] ] [EOL] return [ ja_name , en_name ] [EOL] [EOL] @ staticmethod def _print_text_format_labels ( labels , output = None ) : [EOL] output_lines = [ ] [EOL] for label in labels : [EOL] output_lines . append ( [string] . join ( [ label [ [string] ] , label [ [string] ] ] + PrintAnnotationSpecsLabel . _get_name_list ( label [ [string] ] [ [string] ] ) ) ) [EOL] for additional_data_definition in label [ [string] ] : [EOL] output_lines . append ( [string] . join ( [ [string] , additional_data_definition [ [string] ] , additional_data_definition [ [string] ] , ] + PrintAnnotationSpecsLabel . _get_name_list ( additional_data_definition [ [string] ] [ [string] ] ) ) ) [EOL] if additional_data_definition [ [string] ] in [ [string] , [string] ] : [EOL] for choice in additional_data_definition [ [string] ] : [EOL] output_lines . append ( [string] . join ( [ [string] , [string] , choice [ [string] ] , [string] ] + PrintAnnotationSpecsLabel . _get_name_list ( choice [ [string] ] [ [string] ] ) ) ) [EOL] [EOL] annofabcli . utils . output_string ( [string] . join ( output_lines ) , output ) [EOL] [EOL] def get_history_id_from_before_index ( self , project_id , before ) : [EOL] histories , _ = self . service . api . get_annotation_specs_histories ( project_id ) [EOL] if before + [number] > len ( histories ) : [EOL] logger . warning ( f" [string] { len ( histories ) } [string] { before } [string] " ) [EOL] return None [EOL] history = histories [ - ( before + [number] ) ] [EOL] logger . info ( f"{ history [ [string] ] } [string] " f" [string] { history [ [string] ] } [string] { history [ [string] ] }" ) [EOL] return histories [ - before + [number] ] [ [string] ] [EOL] [EOL] def main ( self ) : [EOL] [EOL] args = self . args [EOL] [EOL] if args . before is not None : [EOL] history_id = self . get_history_id_from_before_index ( args . project_id , args . before ) [EOL] if history_id is None : [EOL] print ( f"{ self . COMMON_MESSAGE } [string] { args . before } [string] " , file = sys . stderr , ) [EOL] return [EOL] else : [EOL] [comment] [EOL] history_id = args . history_id [EOL] [EOL] self . print_annotation_specs_label ( args . project_id , arg_format = args . format , output = args . output , history_id = history_id ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] [comment] [EOL] old_annotation_specs_group = parser . add_mutually_exclusive_group ( ) [EOL] old_annotation_specs_group . add_argument ( [string] , type = str , help = ( [string] [string] [string] ) , ) [EOL] [EOL] old_annotation_specs_group . add_argument ( [string] , type = int , help = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , choices = [ [string] , FormatArgument . PRETTY_JSON . value , FormatArgument . JSON . value ] , default = [string] , help = f" [string] " [string] f"{ FormatArgument . PRETTY_JSON . value } [string] " f"{ FormatArgument . JSON . value } [string] " , ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] PrintAnnotationSpecsLabel ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] [EOL] subcommand_help = [string] [EOL] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . annotation_specs . list_annotation_specs_history [EOL] import annofabcli . annotation_specs . list_annotation_specs_label [EOL] import annofabcli . annotation_specs . print_label_color [EOL] import annofabcli . common . cli [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . annotation_specs . list_annotation_specs_history . add_parser ( subparsers ) [EOL] annofabcli . annotation_specs . list_annotation_specs_label . add_parser ( subparsers ) [EOL] annofabcli . annotation_specs . print_label_color . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , Tuple [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , Tuple [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , FormatArgument , build_annofabapi_resource_and_login , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PrintLabelColor ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def get_rgb ( label ) : [EOL] color = label [ [string] ] [EOL] return color [ [string] ] , color [ [string] ] , color [ [string] ] [EOL] [EOL] def print_label_color ( self , project_id ) : [EOL] [docstring] [EOL] [EOL] annotation_specs = self . service . api . get_annotation_specs ( project_id ) [ [number] ] [EOL] labels = annotation_specs [ [string] ] [EOL] [EOL] label_color_dict = { self . facade . get_label_name_en ( label ) : self . get_rgb ( label ) for label in labels } [EOL] [EOL] self . print_according_to_format ( label_color_dict ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] self . print_label_color ( args . project_id ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . JSON , FormatArgument . PRETTY_JSON ] , default = FormatArgument . PRETTY_JSON ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] PrintLabelColor ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] [EOL] subcommand_help = [string] [EOL] [EOL] description = ( [string] [string] [string] ) [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import json [EOL] import logging [EOL] from collections import defaultdict [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] from annofabapi . models import ProjectMemberRole , TaskHistory , TaskPhase [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . utils import isoduration_to_hour [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ListSubmittedTaskCountMain : [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] self . facade = AnnofabApiFacade ( service ) [EOL] [EOL] @ staticmethod def from_datetime_to_date ( datetime ) : [EOL] return datetime [ [number] : [number] ] [EOL] [EOL] @ staticmethod def _get_actual_worktime_hour ( labor ) : [EOL] working_time_by_user = labor [ [string] ] [ [string] ] [EOL] if working_time_by_user is None : [EOL] return [number] [EOL] [EOL] value = working_time_by_user . get ( [string] ) [EOL] if value is None : [EOL] return [number] [EOL] else : [EOL] return value / [number] / [number] [EOL] [EOL] @ staticmethod def to_formatted_dataframe ( submitted_task_count_df , account_statistics_df , labor_df , user_df , ) : [EOL] df = ( submitted_task_count_df . merge ( account_statistics_df , how = [string] , on = [ [string] , [string] ] ) . merge ( labor_df , how = [string] , on = [ [string] , [string] ] ) . fillna ( [number] ) . merge ( user_df , how = [string] , on = [string] ) ) [EOL] df . sort_values ( [ [string] , [string] ] , inplace = True ) [EOL] columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] return df [ columns ] [EOL] [EOL] def get_task_history_dict ( self , project_id , task_history_json_path ) : [EOL] if task_history_json_path is not None : [EOL] json_path = task_history_json_path [EOL] else : [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] json_path = cache_dir / f" [string] { project_id } [string] " [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] downloading_obj . download_task_history_json ( project_id , dest_path = str ( json_path ) ) [EOL] [EOL] logger . debug ( f" [string] { json_path }" ) [EOL] with json_path . open ( encoding = [string] ) as f : [EOL] task_history_dict = json . load ( f ) [EOL] return task_history_dict [EOL] [EOL] def create_user_df ( self , project_id ) : [EOL] member_list = self . facade . get_organization_members_from_project_id ( project_id ) [EOL] return pandas . DataFrame ( member_list , columns = [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] @ staticmethod def _is_contained_daterange ( target_date , start_date = None , end_date = None ) : [EOL] if start_date is not None : [EOL] if target_date < start_date : [EOL] return False [EOL] if end_date is not None : [EOL] if target_date > end_date : [EOL] return False [EOL] return True [EOL] [EOL] def create_account_statistics_df ( self , project_id , start_date = None , end_date = None ) : [EOL] account_statistics = self . service . wrapper . get_account_statistics ( project_id ) [EOL] data_list = [ ] [EOL] for stat_by_user in account_statistics : [EOL] account_id = stat_by_user [ [string] ] [EOL] histories = stat_by_user [ [string] ] [EOL] for stat in histories : [EOL] data = { [string] : account_id , [string] : isoduration_to_hour ( stat [ [string] ] ) , [string] : stat [ [string] ] , [string] : stat [ [string] ] , } [EOL] if not self . _is_contained_daterange ( data [ [string] ] , start_date = start_date , end_date = end_date ) : [EOL] continue [EOL] [EOL] if data [ [string] ] == [number] and data [ [string] ] == [number] : [EOL] continue [EOL] [EOL] data_list . append ( data ) [EOL] [EOL] if len ( data_list ) > [number] : [EOL] return pandas . DataFrame ( data_list ) [EOL] else : [EOL] return pandas . DataFrame ( columns = [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def create_labor_df ( self , project_id , start_date = None , end_date = None ) : [EOL] def to_new_labor ( e ) : [EOL] return dict ( date = e [ [string] ] , account_id = e [ [string] ] , actual_worktime_hour = self . _get_actual_worktime_hour ( e ) , ) [EOL] [EOL] labor_list = self . service . api . get_labor_control ( { [string] : project_id , [string] : start_date , [string] : end_date } ) [ [number] ] [EOL] new_labor_list = [ to_new_labor ( e ) for e in labor_list if e [ [string] ] is not None and self . _get_actual_worktime_hour ( e ) > [number] ] [EOL] if len ( new_labor_list ) > [number] : [EOL] return pandas . DataFrame ( new_labor_list ) [EOL] else : [EOL] return pandas . DataFrame ( columns = [ [string] , [string] , [string] ] ) [EOL] [EOL] def create_submitted_task_count_df ( self , task_history_dict , start_date = None , end_date = None , ) : [EOL] def _set_zero_if_not_exists ( df ) : [EOL] for phase in TaskPhase : [EOL] col = f"{ phase . value } [string] " [EOL] if col not in df . columns : [EOL] df [ col ] = [number] [EOL] [EOL] task_history_count_dict = defaultdict ( int ) [EOL] for _ , task_history_list in task_history_dict . items ( ) : [EOL] for task_history in task_history_list : [EOL] if task_history [ [string] ] is not None and task_history [ [string] ] is not None : [EOL] ended_date = self . from_datetime_to_date ( task_history [ [string] ] ) [EOL] task_history_count_dict [ ( task_history [ [string] ] , task_history [ [string] ] , ended_date ) ] += [number] [EOL] [EOL] data_list = [ ] [EOL] for key , task_count in task_history_count_dict . items ( ) : [EOL] account_id , phaes , date = key [EOL] data = { [string] : date , [string] : phaes , [string] : account_id , [string] : task_count } [EOL] if not self . _is_contained_daterange ( data [ [string] ] , start_date = start_date , end_date = end_date ) : [EOL] continue [EOL] [EOL] data_list . append ( data ) [EOL] [EOL] if len ( data_list ) == [number] : [EOL] return pandas . DataFrame ( columns = [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] df = pandas . DataFrame ( data_list ) [EOL] df2 = df . pivot_table ( columns = [string] , values = [string] , index = [ [string] , [string] ] ) . fillna ( [number] ) [EOL] df2 . rename ( columns = { [string] : [string] , [string] : [string] , [string] : [string] , } , inplace = True , ) [EOL] _set_zero_if_not_exists ( df2 ) [EOL] return df2 [EOL] [EOL] def create_user_statistics_by_date ( self , project_id , task_history_json_path , start_date = None , end_date = None , ) : [EOL] task_history_dict = self . get_task_history_dict ( project_id , task_history_json_path ) [EOL] [EOL] submitted_task_count_df = self . create_submitted_task_count_df ( task_history_dict = task_history_dict , start_date = start_date , end_date = end_date ) [EOL] labor_df = self . create_labor_df ( project_id , start_date = start_date , end_date = end_date ) [EOL] account_statistics_df = self . create_account_statistics_df ( project_id , start_date = start_date , end_date = end_date ) [EOL] user_df = self . create_user_df ( project_id ) [EOL] [EOL] df2 = self . to_formatted_dataframe ( submitted_task_count_df , account_statistics_df , labor_df , user_df ) [EOL] return df2 [EOL] [EOL] [EOL] class ListSubmittedTaskCountArgs ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , project_member_roles = [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] [EOL] main_obj = ListSubmittedTaskCountMain ( service = self . service ) [EOL] df = main_obj . create_user_statistics_by_date ( project_id , args . task_history_json , start_date = args . start_date , end_date = args . end_date ) [EOL] self . print_csv ( df ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] parser . add_argument ( [string] , type = Path , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListSubmittedTaskCountArgs ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.TaskHistory]]$ 0 0 0 $builtins.str$ 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 $pathlib.Path$ 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.TaskHistory]]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pandas.DataFrame$ 0 0 0 0 $pandas.DataFrame$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Tuple[builtins.str,builtins.str,builtins.str],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.TaskHistory]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Tuple[builtins.str,builtins.str,builtins.str],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Tuple[builtins.str,builtins.str,builtins.str],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.Optional[pathlib.Path]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.statistics.list_by_date_user.ListSubmittedTaskCountMain$ 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.statistics.list_by_date_user.ListSubmittedTaskCountMain$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Sequence , Any , Optional , Type [EOL] import builtins [EOL] import logging [EOL] import pandas [EOL] import bokeh [EOL] import annofabcli [EOL] import typing [EOL] import logging [EOL] import math [EOL] from pathlib import Path [EOL] from typing import Any , List , Optional , Sequence , Tuple [EOL] [EOL] import bokeh [EOL] import bokeh . layouts [EOL] import bokeh . palettes [EOL] import numpy [EOL] import pandas [EOL] from annofabapi . models import TaskPhase [EOL] from bokeh . models import HoverTool [EOL] from bokeh . plotting import ColumnDataSource , figure [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Scatter : [EOL] [docstring] [EOL] [EOL] my_palette = bokeh . palettes . Category20 [ [number] ] [EOL] [EOL] dict_phase_name = { TaskPhase . ANNOTATION . value : [string] , TaskPhase . INSPECTION . value : [string] , TaskPhase . ACCEPTANCE . value : [string] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , outdir , palette = None ) : [EOL] self . scatter_outdir = outdir [EOL] Path ( self . scatter_outdir ) . mkdir ( exist_ok = True , parents = True ) [EOL] if palette is not None : [EOL] self . my_palette = palette [EOL] [EOL] @ staticmethod def _set_legend ( fig ) : [EOL] [docstring] [EOL] fig . legend . location = [string] [EOL] fig . legend . click_policy = [string] [EOL] fig . legend . title = [string] [EOL] if len ( fig . legend ) > [number] : [EOL] legend = fig . legend [ [number] ] [EOL] fig . add_layout ( legend , [string] ) [EOL] [EOL] @ staticmethod def _create_hover_tool ( tool_tip_items ) : [EOL] [docstring] [EOL] [EOL] def exclude_phase_name ( name ) : [EOL] tmp = name . split ( [string] ) [EOL] return [string] . join ( tmp [ [number] : len ( tmp ) - [number] ] ) [EOL] [EOL] detail_tooltips = [ ( exclude_phase_name ( e ) , [string] % e ) for e in tool_tip_items ] [EOL] hover_tool = HoverTool ( tooltips = detail_tooltips ) [EOL] return hover_tool [EOL] [EOL] @ staticmethod def _scatter ( fig , source , x_column_name , y_column_name , legend_label , color , ) : [EOL] [docstring] [EOL] if legend_label == [string] : [EOL] legend_label = [string] [EOL] [EOL] fig . circle ( x = x_column_name , y = y_column_name , source = source , legend_label = legend_label , color = color , muted_alpha = [number] ) [EOL] fig . text ( x = x_column_name , y = y_column_name , source = source , text = [string] , text_font_size = [string] , legend_label = legend_label , muted_alpha = [number] , ) [EOL] [EOL] @ staticmethod def _plot_bubble ( fig , source , x_column_name , y_column_name , size_column_name , legend_label , color , ) : [EOL] [docstring] [EOL] [EOL] def _worktime_hour_to_scatter_size ( worktime_hour ) : [EOL] [docstring] [EOL] MIN_SCATTER_SIZE = [number] [EOL] if worktime_hour <= [number] : [EOL] return MIN_SCATTER_SIZE [EOL] tmp = int ( math . log2 ( worktime_hour ) * [number] - [number] ) [EOL] if tmp < MIN_SCATTER_SIZE : [EOL] return MIN_SCATTER_SIZE [EOL] else : [EOL] return tmp [EOL] [EOL] if legend_label == [string] : [EOL] legend_label = [string] [EOL] [EOL] tmp_size_field = f" [string] { size_column_name }" [EOL] source . data [ tmp_size_field ] = numpy . array ( list ( map ( _worktime_hour_to_scatter_size , source . data [ size_column_name ] ) ) ) [EOL] fig . scatter ( x = x_column_name , y = y_column_name , source = source , legend_label = legend_label , color = color , fill_alpha = [number] , muted_alpha = [number] , size = tmp_size_field , ) [EOL] fig . text ( x = x_column_name , y = y_column_name , source = source , text = [string] , text_align = [string] , text_baseline = [string] , text_font_size = [string] , legend_label = legend_label , muted_alpha = [number] , ) [EOL] [EOL] @ staticmethod def _get_phase_list ( df ) : [EOL] columns = list ( df . columns ) [EOL] phase_list = [ TaskPhase . ANNOTATION . value , TaskPhase . INSPECTION . value , TaskPhase . ACCEPTANCE . value ] [EOL] if ( [string] , TaskPhase . INSPECTION . value ) not in columns : [EOL] phase_list . remove ( TaskPhase . INSPECTION . value ) [EOL] if ( [string] , TaskPhase . ACCEPTANCE . value ) not in columns : [EOL] phase_list . remove ( TaskPhase . ACCEPTANCE . value ) [EOL] return phase_list [EOL] [EOL] @ staticmethod def _plot_average_line ( fig , value , dimension ) : [EOL] if value is None : [EOL] return [EOL] span_average_line = bokeh . models . Span ( location = value , dimension = dimension , line_color = [string] , line_width = [number] , ) [EOL] fig . add_layout ( span_average_line ) [EOL] [EOL] @ staticmethod def _plot_quartile_line ( fig , quartile , dimension ) : [EOL] if quartile is None : [EOL] return [EOL] [EOL] for value in quartile : [EOL] span_average_line = bokeh . models . Span ( location = value , dimension = dimension , line_color = [string] , line_width = [number] , ) [EOL] fig . add_layout ( span_average_line ) [EOL] [EOL] @ staticmethod def _get_average_value ( df , numerator_column , denominator_column ) : [EOL] numerator = df [ numerator_column ] . sum ( ) [EOL] denominator = df [ denominator_column ] . sum ( ) [EOL] if denominator > [number] : [EOL] return numerator / denominator [EOL] else : [EOL] return None [EOL] [EOL] @ staticmethod def _get_quartile_value ( df , column ) : [EOL] tmp = df [ column ] . describe ( ) [EOL] if tmp [ [string] ] > [number] : [EOL] return ( tmp [ [string] ] , tmp [ [string] ] , tmp [ [string] ] ) [EOL] else : [EOL] return None [EOL] [EOL] @ staticmethod def _create_div_element ( ) : [EOL] [docstring] [EOL] return bokeh . models . Div ( text = [string] ) [EOL] [EOL] def write_scatter_for_productivity_by_monitored_worktime ( self , df ) : [EOL] [docstring] [EOL] [EOL] def create_figure ( title ) : [EOL] return figure ( plot_width = [number] , plot_height = [number] , title = title , x_axis_label = [string] , y_axis_label = [string] , ) [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . scatter_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] phase_list = self . _get_phase_list ( df ) [EOL] figure_list = [ create_figure ( f"{ self . dict_phase_name [ phase ] } [string] " ) for phase in phase_list ] [EOL] [EOL] df [ [string] ] = df [ [string] ] . fillna ( [string] ) [EOL] [EOL] for biography_index , biography in enumerate ( set ( df [ [string] ] ) ) : [EOL] x_column = [string] [EOL] y_column = [string] [EOL] for fig , phase in zip ( figure_list , phase_list ) : [EOL] filtered_df = df [ ( df [ [string] ] == biography ) & df [ ( x_column , phase ) ] . notna ( ) & df [ ( y_column , phase ) ] . notna ( ) ] [EOL] if len ( filtered_df ) == [number] : [EOL] continue [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] self . _scatter ( fig = fig , source = source , x_column_name = f"{ x_column } [string] { phase }" , y_column_name = f"{ y_column } [string] { phase }" , legend_label = biography , color = self . my_palette [ biography_index ] , ) [EOL] [EOL] for fig , phase in zip ( figure_list , phase_list ) : [EOL] average_value = self . _get_average_value ( df , numerator_column = ( [string] , phase ) , denominator_column = ( [string] , phase ) , ) [EOL] self . _plot_average_line ( fig , average_value , dimension = [string] ) [EOL] quartile = self . _get_quartile_value ( df , ( [string] , phase ) ) [EOL] self . _plot_quartile_line ( fig , quartile , dimension = [string] ) [EOL] [EOL] for fig , phase in zip ( figure_list , phase_list ) : [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , ] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] fig . add_tools ( hover_tool ) [EOL] self . _set_legend ( fig ) [EOL] [EOL] div_element = self . _create_div_element ( ) [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( [ div_element ] + figure_list ) ) [EOL] [EOL] def write_scatter_for_productivity_by_actual_worktime ( self , df ) : [EOL] [docstring] [EOL] [EOL] def create_figure ( title ) : [EOL] return figure ( plot_width = [number] , plot_height = [number] , title = title , x_axis_label = [string] , y_axis_label = [string] , ) [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . scatter_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] phase_list = self . _get_phase_list ( df ) [EOL] figure_list = [ create_figure ( f"{ self . dict_phase_name [ phase ] } [string] " ) for phase in phase_list ] [EOL] [EOL] df [ [string] ] = df [ [string] ] . fillna ( [string] ) [EOL] for biography_index , biography in enumerate ( set ( df [ [string] ] ) ) : [EOL] x_column = [string] [EOL] y_column = [string] [EOL] for fig , phase in zip ( figure_list , phase_list ) : [EOL] filtered_df = df [ ( df [ [string] ] == biography ) & df [ ( x_column , phase ) ] . notna ( ) & df [ ( y_column , phase ) ] . notna ( ) ] [EOL] if len ( filtered_df ) == [number] : [EOL] continue [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] self . _scatter ( fig = fig , source = source , x_column_name = f"{ x_column } [string] { phase }" , y_column_name = f"{ y_column } [string] { phase }" , legend_label = biography , color = self . my_palette [ biography_index ] , ) [EOL] [EOL] for fig , phase in zip ( figure_list , phase_list ) : [EOL] average_value = self . _get_average_value ( df , numerator_column = ( [string] , phase ) , denominator_column = ( [string] , phase ) , ) [EOL] self . _plot_average_line ( fig , average_value , dimension = [string] ) [EOL] [EOL] quartile = self . _get_quartile_value ( df , ( [string] , phase ) ) [EOL] self . _plot_quartile_line ( fig , quartile , dimension = [string] ) [EOL] [EOL] for fig , phase in zip ( figure_list , phase_list ) : [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , ] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] fig . add_tools ( hover_tool ) [EOL] self . _set_legend ( fig ) [EOL] [EOL] div_element = self . _create_div_element ( ) [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( [ div_element ] + figure_list ) ) [EOL] [EOL] def write_scatter_for_quality ( self , df ) : [EOL] [docstring] [EOL] [EOL] def create_figure ( title , x_axis_label , y_axis_label ) : [EOL] return figure ( plot_width = [number] , plot_height = [number] , title = title , x_axis_label = x_axis_label , y_axis_label = y_axis_label , ) [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . scatter_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figure_list = [ create_figure ( title = f" [string] " , x_axis_label = [string] , y_axis_label = [string] ) , create_figure ( title = f" [string] " , x_axis_label = [string] , y_axis_label = [string] ) , ] [EOL] column_pair_list = [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] phase = [string] [EOL] [EOL] df [ [string] ] = df [ [string] ] . fillna ( [string] ) [EOL] for biography_index , biography in enumerate ( set ( df [ [string] ] ) ) : [EOL] for column_pair , fig in zip ( column_pair_list , figure_list ) : [EOL] x_column = column_pair [ [number] ] [EOL] y_column = column_pair [ [number] ] [EOL] filtered_df = df [ ( df [ [string] ] == biography ) & df [ ( x_column , phase ) ] . notna ( ) & df [ ( y_column , phase ) ] . notna ( ) ] [EOL] if len ( filtered_df ) == [number] : [EOL] continue [EOL] [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] self . _scatter ( fig = fig , source = source , x_column_name = f"{ x_column } [string] { phase }" , y_column_name = f"{ y_column } [string] { phase }" , legend_label = biography , color = self . my_palette [ biography_index ] , ) [EOL] [EOL] for column_pair , fig in zip ( [ ( [string] , [string] ) , ( [string] , [string] ) ] , figure_list , ) : [EOL] average_value = self . _get_average_value ( df , numerator_column = ( column_pair [ [number] ] , phase ) , denominator_column = ( column_pair [ [number] ] , phase ) ) [EOL] self . _plot_average_line ( fig , average_value , dimension = [string] ) [EOL] [EOL] for column , fig in zip ( [ [string] , [string] ] , figure_list , ) : [EOL] quartile = self . _get_quartile_value ( df , ( column , phase ) ) [EOL] self . _plot_quartile_line ( fig , quartile , dimension = [string] ) [EOL] [EOL] for fig in figure_list : [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , ] [EOL] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] fig . add_tools ( hover_tool ) [EOL] self . _set_legend ( fig ) [EOL] [EOL] div_element = self . _create_div_element ( ) [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( [ div_element ] + figure_list ) ) [EOL] [EOL] def write_scatter_for_productivity_by_actual_worktime_and_quality ( self , df ) : [EOL] [docstring] [EOL] [EOL] def create_figure ( title , x_axis_label , y_axis_label ) : [EOL] return figure ( plot_width = [number] , plot_height = [number] , title = title , x_axis_label = x_axis_label , y_axis_label = y_axis_label , ) [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . scatter_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figure_list = [ create_figure ( title = f" [string] " , x_axis_label = [string] , y_axis_label = [string] ) , create_figure ( title = f" [string] " , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] column_pair_list = [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] phase = TaskPhase . ANNOTATION . value [EOL] df [ [string] ] = df [ [string] ] . fillna ( [string] ) [EOL] for biography_index , biography in enumerate ( set ( df [ [string] ] ) ) : [EOL] for fig , column_pair in zip ( figure_list , column_pair_list ) : [EOL] x_column , y_column = column_pair [EOL] filtered_df = df [ ( df [ [string] ] == biography ) & df [ ( x_column , phase ) ] . notna ( ) & df [ ( y_column , phase ) ] . notna ( ) ] [EOL] if len ( filtered_df ) == [number] : [EOL] continue [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] self . _plot_bubble ( fig = fig , source = source , x_column_name = f"{ x_column } [string] { phase }" , y_column_name = f"{ y_column } [string] { phase }" , size_column_name = f" [string] { phase }" , legend_label = biography , color = self . my_palette [ biography_index ] , ) [EOL] [EOL] x_average_value = self . _get_average_value ( df , numerator_column = ( [string] , phase ) , denominator_column = ( [string] , phase ) , ) [EOL] for column_pair , fig in zip ( [ ( [string] , [string] ) , ( [string] , [string] ) ] , figure_list , ) : [EOL] self . _plot_average_line ( fig , x_average_value , dimension = [string] ) [EOL] y_average_value = self . _get_average_value ( df , numerator_column = ( column_pair [ [number] ] , phase ) , denominator_column = ( column_pair [ [number] ] , phase ) , ) [EOL] self . _plot_average_line ( fig , y_average_value , dimension = [string] ) [EOL] [EOL] x_quartile = self . _get_quartile_value ( df , ( [string] , phase ) ) [EOL] for column , fig in zip ( [ [string] , [string] ] , figure_list , ) : [EOL] self . _plot_quartile_line ( fig , x_quartile , dimension = [string] ) [EOL] quartile = self . _get_quartile_value ( df , ( column , phase ) ) [EOL] self . _plot_quartile_line ( fig , quartile , dimension = [string] ) [EOL] [EOL] for fig in figure_list : [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , f" [string] { phase }" , ] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] fig . add_tools ( hover_tool ) [EOL] self . _set_legend ( fig ) [EOL] [EOL] div_element = self . _create_div_element ( ) [EOL] div_element . text += [string] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( [ div_element ] + figure_list ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float,builtins.float]]$ 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0
from typing import Type , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] [comment] [EOL] Task = Dict [ str , Any ] [EOL] Inspection = Dict [ str , Any ] [EOL] Annotation = Dict [ str , Any ] [EOL] TaskHistory = Dict [ str , Any ] [EOL] TaskHistoryEvent = Dict [ str , Any ] [EOL] TaskId = str [EOL] InputDataId = str [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 $typing.Type[builtins.str]$ 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import logging [EOL] import builtins [EOL] import pandas [EOL] import holoviews [EOL] import annofabcli [EOL] import typing [EOL] import logging [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] [EOL] import holoviews as hv [EOL] import numpy as np [EOL] import pandas [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] hv . extension ( [string] ) [EOL] [EOL] [EOL] @ dataclass class HistogramName : [EOL] [docstring] [EOL] [EOL] title = ... [EOL] [docstring] [EOL] x_axis_label = ... [EOL] [docstring] [EOL] column = ... [EOL] [docstring] [EOL] y_axis_label = [string] [EOL] [docstring] [EOL] [EOL] [EOL] class Histogram : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , outdir ) : [EOL] self . histogram_outdir = outdir [EOL] Path ( self . histogram_outdir ) . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] @ staticmethod def _create_histogram ( df , histogram_name , bins = [number] ) : [EOL] [docstring] [EOL] mean = round ( df [ histogram_name . column ] . mean ( ) , [number] ) [EOL] std = round ( df [ histogram_name . column ] . std ( ) , [number] ) [EOL] title = f"{ histogram_name . title } [string] { mean } [string] { std } [string] { len ( df ) }" [EOL] [EOL] data = df [ histogram_name . column ] . values [EOL] [EOL] frequencies , edges = np . histogram ( data , bins ) [EOL] hist = ( hv . Histogram ( ( edges , frequencies ) , kdims = histogram_name . x_axis_label , vdims = histogram_name . y_axis_label , label = title ) . options ( width = [number] , title = title , fontsize = { [string] : [number] , [string] : [number] } ) . opts ( hv . opts ( tools = [ [string] ] ) ) ) [EOL] return hist [EOL] [EOL] def _create_histogram_by_user ( self , df , column , x_axis_label , username , user_id ) : [EOL] [docstring] [EOL] histogram_name = HistogramName ( column = column , x_axis_label = x_axis_label , title = f"{ username } [string] { user_id } [string] " ) [EOL] hist = self . _create_histogram ( df , histogram_name = histogram_name ) [EOL] return hist [EOL] [EOL] def write_histogram_for_annotation_worktime_by_user ( self , df ) : [EOL] [docstring] [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] output_file_worktime = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file_worktime } [string] " ) [EOL] output_file_first_worktime = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file_first_worktime } [string] " ) [EOL] [EOL] first_annotation_user_id_list = df [ [string] ] . dropna ( ) . unique ( ) . tolist ( ) [EOL] if len ( first_annotation_user_id_list ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] histograms_worktime = [ ] [EOL] histograms_first_worktime = [ ] [EOL] for user_id in first_annotation_user_id_list : [EOL] [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] histograms_worktime . append ( self . _create_histogram_by_user ( filtered_df , [string] , [string] , user_id = user_id , username = username ) ) [EOL] histograms_first_worktime . append ( self . _create_histogram_by_user ( filtered_df , [string] , [string] , user_id = user_id , username = username ) ) [EOL] [EOL] layout_worktime = ( hv . Layout ( histograms_worktime ) . cols ( [number] ) . opts ( hv . opts . Histogram ( width = [number] ) , hv . opts . Layout ( shared_axes = True ) ) ) [EOL] hv . renderer ( [string] ) . save ( layout_worktime , output_file_worktime ) [EOL] [EOL] layout_first_worktime = ( hv . Layout ( histograms_first_worktime ) . cols ( [number] ) . opts ( hv . opts . Histogram ( width = [number] ) , hv . opts . Layout ( shared_axes = True ) ) ) [EOL] hv . renderer ( [string] ) . save ( layout_first_worktime , output_file_first_worktime ) [EOL] [EOL] def write_histogram_for_inspection_worktime_by_user ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] output_file_worktime = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file_worktime } [string] " ) [EOL] output_file_first_worktime = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file_first_worktime } [string] " ) [EOL] [EOL] first_inspection_user_id_list = df [ [string] ] . dropna ( ) . unique ( ) . tolist ( ) [EOL] if len ( first_inspection_user_id_list ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] histograms_worktime = [ ] [EOL] histograms_first_worktime = [ ] [EOL] for user_id in first_inspection_user_id_list : [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] [EOL] histograms_worktime . append ( self . _create_histogram_by_user ( filtered_df , [string] , [string] , user_id = user_id , username = username ) ) [EOL] histograms_first_worktime . append ( self . _create_histogram_by_user ( filtered_df , [string] , [string] , user_id = user_id , username = username ) ) [EOL] [EOL] layout_worktime = ( hv . Layout ( histograms_worktime ) . cols ( [number] ) . opts ( hv . opts . Histogram ( width = [number] ) , hv . opts . Layout ( shared_axes = True ) ) ) [EOL] hv . renderer ( [string] ) . save ( layout_worktime , output_file_worktime ) [EOL] [EOL] layout_first_worktime = ( hv . Layout ( histograms_first_worktime ) . cols ( [number] ) . opts ( hv . opts . Histogram ( width = [number] ) , hv . opts . Layout ( shared_axes = True ) ) ) [EOL] hv . renderer ( [string] ) . save ( layout_first_worktime , output_file_first_worktime ) [EOL] [EOL] def write_histogram_for_acceptance_worktime_by_user ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] output_file_worktime = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file_worktime } [string] " ) [EOL] output_file_first_worktime = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file_first_worktime } [string] " ) [EOL] [EOL] first_acceptance_user_id_list = df [ [string] ] . dropna ( ) . unique ( ) . tolist ( ) [EOL] if len ( first_acceptance_user_id_list ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] histograms_worktime = [ ] [EOL] histograms_first_worktime = [ ] [EOL] for user_id in first_acceptance_user_id_list : [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] histograms_worktime . append ( self . _create_histogram_by_user ( filtered_df , [string] , [string] , user_id = user_id , username = username ) ) [EOL] histograms_first_worktime . append ( self . _create_histogram_by_user ( filtered_df , [string] , [string] , user_id = user_id , username = username ) ) [EOL] [EOL] layout_worktime = ( hv . Layout ( histograms_worktime ) . cols ( [number] ) . opts ( hv . opts . Histogram ( width = [number] ) , hv . opts . Layout ( shared_axes = True ) ) ) [EOL] hv . renderer ( [string] ) . save ( layout_worktime , output_file_worktime ) [EOL] [EOL] layout_first_worktime = ( hv . Layout ( histograms_first_worktime ) . cols ( [number] ) . opts ( hv . opts . Histogram ( width = [number] ) , hv . opts . Layout ( shared_axes = True ) ) ) [EOL] hv . renderer ( [string] ) . save ( layout_first_worktime , output_file_first_worktime ) [EOL] [EOL] def write_histogram_for_worktime ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] renderer = hv . renderer ( [string] ) [EOL] [EOL] output_file = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] histogram_name_list = [ HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] ) , ] [EOL] [EOL] histograms = [ ] [EOL] for histogram_name in histogram_name_list : [EOL] filtered_df = df [ df [ histogram_name . column ] . notnull ( ) ] [EOL] hist = self . _create_histogram ( filtered_df , histogram_name = histogram_name ) [EOL] histograms . append ( hist ) [EOL] [EOL] [comment] [EOL] filtered_df = df [ df [ [string] ] . notnull ( ) ] [EOL] histograms . append ( self . _create_histogram ( filtered_df [ ~ filtered_df [ [string] ] ] , histogram_name = HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , ) ) [EOL] [EOL] [comment] [EOL] filtered_df = df [ df [ [string] ] . notnull ( ) ] [EOL] histograms . append ( self . _create_histogram ( filtered_df [ ~ filtered_df [ [string] ] ] , histogram_name = HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , ) ) [EOL] [EOL] [comment] [EOL] layout = hv . Layout ( histograms ) . options ( shared_axes = False ) . cols ( [number] ) [EOL] renderer . save ( layout , output_file ) [EOL] [EOL] def write_histogram_for_other ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] renderer = hv . renderer ( [string] ) [EOL] [EOL] output_file = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] histogram_name_list = [ HistogramName ( column = [string] , x_axis_label = [string] , title = [string] ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , HistogramName ( column = [string] , x_axis_label = [string] , title = [string] , ) , ] [EOL] [EOL] histograms = [ ] [EOL] for histogram_name in histogram_name_list : [EOL] filtered_df = df [ df [ histogram_name . column ] . notnull ( ) ] [EOL] hist = self . _create_histogram ( filtered_df , histogram_name = histogram_name ) [EOL] histograms . append ( hist ) [EOL] [EOL] [comment] [EOL] layout = hv . Layout ( histograms ) . options ( shared_axes = False ) . cols ( [number] ) [EOL] renderer . save ( layout , output_file ) [EOL] [EOL] def write_histogram_for_annotation_count_by_label ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] renderer = hv . renderer ( [string] ) [EOL] [EOL] output_file = f"{ self . histogram_outdir } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] histograms = [ ] [EOL] label_columns = [ e for e in df . columns if e . startswith ( [string] ) ] [EOL] [EOL] for column in label_columns : [EOL] label_name = column [ len ( [string] ) : ] [EOL] histogram_name = HistogramName ( column = column , x_axis_label = f" [string] { label_name } [string] " , title = f"{ label_name }" ) [EOL] hist = self . _create_histogram ( df , histogram_name = histogram_name ) [EOL] [EOL] histograms . append ( hist ) [EOL] [EOL] [comment] [EOL] layout = hv . Layout ( histograms ) . options ( shared_axes = False ) . cols ( [number] ) [EOL] renderer . save ( layout , output_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $holoviews.Histogram$ 0 $pandas.DataFrame$ 0 $HistogramName$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pandas.DataFrame$ 0 $HistogramName$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pandas.DataFrame$ 0 $HistogramName$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $HistogramName$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 $HistogramName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $HistogramName$ 0 0 0 0 0 $HistogramName$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $holoviews.Histogram$ 0 0 0 $pandas.DataFrame$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $annofabcli.statistics.histogram.HistogramName$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $annofabcli.statistics.histogram.HistogramName$ 0 $annofabcli.statistics.histogram.HistogramName$ 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[annofabcli.statistics.histogram.HistogramName]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[annofabcli.statistics.histogram.HistogramName]$ 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[annofabcli.statistics.histogram.HistogramName]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[annofabcli.statistics.histogram.HistogramName]$ 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $annofabcli.statistics.histogram.HistogramName$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $annofabcli.statistics.histogram.HistogramName$ 0 $annofabcli.statistics.histogram.HistogramName$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . utils import isoduration_to_hour [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TaskProgress ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def get_task_phase_statistics ( self , project_id ) : [EOL] [docstring] [EOL] task_phase_statistics = self . service . wrapper . get_task_phase_statistics ( project_id ) [EOL] row_list = [ ] [EOL] for stat_by_date in task_phase_statistics : [EOL] date = stat_by_date [ [string] ] [EOL] phase_stat_list = stat_by_date [ [string] ] [EOL] for phase_stat in phase_stat_list : [EOL] phase_stat [ [string] ] = date [EOL] phase_stat [ [string] ] = isoduration_to_hour ( phase_stat [ [string] ] ) [EOL] row_list . extend ( phase_stat_list ) [EOL] return row_list [EOL] [EOL] def list_cumulative_labor_time ( self , project_id ) : [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] phase_stat_list = self . get_task_phase_statistics ( project_id ) [EOL] if len ( phase_stat_list ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] df = pandas . DataFrame ( phase_stat_list ) [EOL] [comment] [EOL] target_df = df [ [ [string] , [string] , [string] ] ] [EOL] annofabcli . utils . print_csv ( target_df , output = self . output , to_csv_kwargs = self . csv_format ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] project_id = args . project_id [EOL] self . list_cumulative_labor_time ( project_id ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] TaskProgress ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . statistics . list_annotation_count [EOL] import annofabcli . statistics . list_by_date_user [EOL] import annofabcli . statistics . list_cumulative_labor_time [EOL] import annofabcli . statistics . list_labor_time_per_user [EOL] import annofabcli . statistics . list_task_progress [EOL] import annofabcli . statistics . summarize_task_count [EOL] import annofabcli . statistics . summarize_task_count_by_task_id [EOL] import annofabcli . statistics . summarize_task_count_by_user [EOL] import annofabcli . statistics . visualize_statistics [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . statistics . list_annotation_count . add_parser ( subparsers ) [EOL] annofabcli . statistics . list_cumulative_labor_time . add_parser ( subparsers ) [EOL] annofabcli . statistics . list_labor_time_per_user . add_parser ( subparsers ) [EOL] annofabcli . statistics . list_by_date_user . add_parser ( subparsers ) [EOL] annofabcli . statistics . list_task_progress . add_parser ( subparsers ) [EOL] annofabcli . statistics . list_task_progress . add_parser ( subparsers ) [EOL] annofabcli . statistics . summarize_task_count . add_parser ( subparsers ) [EOL] annofabcli . statistics . summarize_task_count_by_task_id . add_parser ( subparsers ) [EOL] annofabcli . statistics . summarize_task_count_by_user . add_parser ( subparsers ) [EOL] annofabcli . statistics . visualize_statistics . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import json [EOL] import logging [EOL] from enum import Enum [EOL] from typing import List [EOL] [EOL] import pandas [EOL] from annofabapi . models import ProjectMemberRole , Task , TaskPhase , TaskStatus [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] DEFAULT_TASK_ID_DELIMITER = [string] [EOL] [EOL] [EOL] class TaskStatusForSummary ( Enum ) : [EOL] [docstring] [EOL] [EOL] ANNOTATION_NOT_STARTED = [string] [EOL] [docstring] [EOL] INSPECTION_NOT_STARTED = [string] [EOL] [docstring] [EOL] ACCEPTANCE_NOT_STARTED = [string] [EOL] [docstring] [EOL] [EOL] WORKING = [string] [EOL] BREAK = [string] [EOL] ON_HOLD = [string] [EOL] COMPLETE = [string] [EOL] [EOL] @ staticmethod def from_task ( task ) : [EOL] status = task [ [string] ] [EOL] if status == TaskStatus . NOT_STARTED . value : [EOL] phase = task [ [string] ] [EOL] if phase == TaskPhase . ANNOTATION . value : [EOL] return TaskStatusForSummary . ANNOTATION_NOT_STARTED [EOL] elif phase == TaskPhase . INSPECTION . value : [EOL] return TaskStatusForSummary . INSPECTION_NOT_STARTED [EOL] elif phase == TaskPhase . ACCEPTANCE . value : [EOL] return TaskStatusForSummary . ACCEPTANCE_NOT_STARTED [EOL] else : [EOL] raise RuntimeError ( f" [string] { phase } [string] " ) [EOL] else : [EOL] return TaskStatusForSummary ( status ) [EOL] [EOL] [EOL] def add_info_to_task ( task ) : [EOL] task [ [string] ] = TaskStatusForSummary . from_task ( task ) . value [EOL] return task [EOL] [EOL] [EOL] def create_task_count_summary_df ( task_list ) : [EOL] [docstring] [EOL] [EOL] def add_columns_if_not_exists ( df , column ) : [EOL] if column not in df . columns : [EOL] df [ column ] = [number] [EOL] [EOL] df_task = pandas . DataFrame ( [ add_info_to_task ( t ) for t in task_list ] ) [EOL] df_summary = df_task . pivot_table ( values = [string] , index = [ [string] ] , columns = [ [string] ] , aggfunc = [string] , fill_value = [number] ) . reset_index ( ) [EOL] [EOL] for status in TaskStatusForSummary : [EOL] add_columns_if_not_exists ( df_summary , status . value ) [EOL] [EOL] return df_summary [EOL] [EOL] [EOL] class SummarizeTaskCountByUser ( AbstractCommandLineInterface ) : [EOL] def create_user_df ( self , project_id , account_id_list ) : [EOL] user_list = [ ] [EOL] for account_id in account_id_list : [EOL] user = self . facade . get_organization_member_from_account_id ( project_id = project_id , account_id = account_id ) [EOL] if user is not None : [EOL] user_list . append ( user ) [EOL] return pandas . DataFrame ( user_list , columns = [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def create_summary_df ( self , project_id , task_list ) : [EOL] df_task_count = create_task_count_summary_df ( task_list ) [EOL] df_user = self . create_user_df ( project_id , df_task_count [ [string] ] ) [EOL] df = pandas . merge ( df_user , df_task_count , how = [string] , on = [ [string] ] ) [EOL] [EOL] task_count_columns = [ s . value for s in TaskStatusForSummary ] [EOL] df [ task_count_columns ] = df [ task_count_columns ] . fillna ( [number] ) [EOL] return df [EOL] [EOL] def print_summarize_df ( self , df ) : [EOL] columns = [ [string] , [string] , [string] ] + [ status . value for status in TaskStatusForSummary ] [EOL] target_df = df [ columns ] . sort_values ( [string] ) [EOL] annofabcli . utils . print_according_to_format ( target_df , arg_format = FormatArgument ( FormatArgument . CSV ) , output = self . output , csv_format = self . csv_format , ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] [EOL] if args . task_json is not None : [EOL] task_json_path = args . task_json [EOL] else : [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] task_json_path = cache_dir / f"{ project_id } [string] " [EOL] [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] downloading_obj . download_task_json ( project_id , dest_path = str ( task_json_path ) , is_latest = args . latest , wait_options = wait_options ) [EOL] [EOL] with open ( task_json_path , encoding = [string] ) as f : [EOL] task_list = json . load ( f ) [EOL] [EOL] df = self . create_summary_df ( project_id , task_list ) [EOL] self . print_summarize_df ( df ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] SummarizeTaskCountByUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $"TaskStatusForSummary"$ 0 $annofabapi.models.Task$ 0 0 0 $typing.Any$ 0 $annofabapi.models.Task$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $annofabapi.models.Task$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import json [EOL] import logging [EOL] from enum import Enum [EOL] from typing import List [EOL] [EOL] import pandas [EOL] from annofabapi . models import ProjectMemberRole , Task , TaskPhase , TaskStatus [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . enums import FormatArgument [EOL] from annofabcli . statistics . summarize_task_count import get_step_for_current_phase [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] DEFAULT_TASK_ID_DELIMITER = [string] [EOL] [EOL] [EOL] class TaskStatusForSummary ( Enum ) : [EOL] [docstring] [EOL] [EOL] COMPLETE = [string] [EOL] ON_HOLD = [string] [EOL] ANNOTATION_NOT_STARTED = [string] [EOL] [docstring] [EOL] INSPECTION_NOT_STARTED = [string] [EOL] [docstring] [EOL] ACCEPTANCE_NOT_STARTED = [string] [EOL] [docstring] [EOL] OTHER = [string] [EOL] [docstring] [EOL] [EOL] @ staticmethod def _get_not_started_status ( task ) : [EOL] [comment] [EOL] step = get_step_for_current_phase ( task , number_of_inspections = [number] ) [EOL] if step == [number] : [EOL] phase = TaskPhase ( task [ [string] ] ) [EOL] if phase == TaskPhase . ANNOTATION : [EOL] return TaskStatusForSummary . ANNOTATION_NOT_STARTED [EOL] elif phase == TaskPhase . INSPECTION : [EOL] return TaskStatusForSummary . INSPECTION_NOT_STARTED [EOL] elif phase == TaskPhase . ACCEPTANCE : [EOL] return TaskStatusForSummary . ACCEPTANCE_NOT_STARTED [EOL] else : [EOL] raise ValueError ( f" [string] { phase . value } [string] " ) [EOL] else : [EOL] return TaskStatusForSummary . OTHER [EOL] [EOL] @ staticmethod def from_task ( task ) : [EOL] status = TaskStatus ( task [ [string] ] ) [EOL] if status == TaskStatus . COMPLETE : [EOL] return TaskStatusForSummary . COMPLETE [EOL] [EOL] elif status == TaskStatus . ON_HOLD : [EOL] return TaskStatusForSummary . ON_HOLD [EOL] [EOL] elif status == TaskStatus . NOT_STARTED : [EOL] return TaskStatusForSummary . _get_not_started_status ( task ) [EOL] else : [EOL] [comment] [EOL] return TaskStatusForSummary . OTHER [EOL] [EOL] [EOL] def get_task_id_prefix ( task_id , delimiter = DEFAULT_TASK_ID_DELIMITER ) : [EOL] tmp_list = task_id . split ( delimiter ) [EOL] if len ( tmp_list ) <= [number] : [EOL] return [string] [EOL] else : [EOL] return delimiter . join ( tmp_list [ [number] : len ( tmp_list ) - [number] ] ) [EOL] [EOL] [EOL] def add_task_id_prefix_to_task_list ( task_list , delimiter = DEFAULT_TASK_ID_DELIMITER ) : [EOL] for task in task_list : [EOL] task [ [string] ] = get_task_id_prefix ( task [ [string] ] , delimiter = delimiter ) [EOL] task [ [string] ] = TaskStatusForSummary . from_task ( task ) . value [EOL] [EOL] return task_list [EOL] [EOL] [EOL] def create_task_count_summary_df ( task_list , delimiter = DEFAULT_TASK_ID_DELIMITER ) : [EOL] [docstring] [EOL] [EOL] def add_columns_if_not_exists ( df , column ) : [EOL] if column not in df . columns : [EOL] df [ column ] = [number] [EOL] [EOL] df_task = pandas . DataFrame ( add_task_id_prefix_to_task_list ( task_list , delimiter = delimiter ) ) [EOL] [EOL] df_summary = df_task . pivot_table ( values = [string] , index = [ [string] ] , columns = [ [string] ] , aggfunc = [string] , fill_value = [number] ) . reset_index ( ) [EOL] [EOL] for status in TaskStatusForSummary : [EOL] add_columns_if_not_exists ( df_summary , status . value ) [EOL] [EOL] df_summary [ [string] ] = ( df_task . pivot_table ( values = [string] , index = [ [string] ] , aggfunc = [string] , fill_value = [number] ) . reset_index ( ) . fillna ( [number] ) [ [string] ] ) [EOL] [EOL] return df_summary [EOL] [EOL] [EOL] class SummarizeTaskCountByTaskId ( AbstractCommandLineInterface ) : [EOL] def print_summarize_task_count ( self , df ) : [EOL] columns = [ [string] ] + [ status . value for status in TaskStatusForSummary ] + [ [string] ] [EOL] annofabcli . utils . print_according_to_format ( df [ columns ] , arg_format = FormatArgument ( FormatArgument . CSV ) , output = self . output , csv_format = self . csv_format , ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] [EOL] if args . task_json is not None : [EOL] task_json_path = args . task_json [EOL] else : [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] task_json_path = cache_dir / f"{ project_id } [string] " [EOL] [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] downloading_obj . download_task_json ( project_id , dest_path = str ( task_json_path ) , is_latest = args . latest , wait_options = wait_options ) [EOL] [EOL] with open ( task_json_path , encoding = [string] ) as f : [EOL] task_list = json . load ( f ) [EOL] [EOL] df = create_task_count_summary_df ( task_list , delimiter = args . delimiter ) [EOL] self . print_summarize_task_count ( df ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] SummarizeTaskCountByTaskId ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $"TaskStatusForSummary"$ 0 $annofabapi.models.Task$ 0 0 0 0 0 $builtins.int$ 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TaskStatusForSummary"$ 0 $annofabapi.models.Task$ 0 0 0 $typing.Any$ 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Callable , Any , Optional , Set , Type [EOL] import builtins [EOL] import logging [EOL] import asyncio [EOL] import annofabcli [EOL] import annofabapi [EOL] import datetime [EOL] import typing [EOL] import pathlib [EOL] import asyncio [EOL] import datetime [EOL] import json [EOL] import logging [EOL] import multiprocessing [EOL] import os [EOL] import pickle [EOL] import shutil [EOL] import zipfile [EOL] from dataclasses import dataclass [EOL] from functools import partial [EOL] from pathlib import Path [EOL] from typing import Any , Callable , Dict , List , Optional , Set [EOL] [EOL] import annofabapi [EOL] import annofabapi . utils [EOL] import dateutil [EOL] import dateutil . parser [EOL] import more_itertools [EOL] from annofabapi . models import InputData , InputDataId , Inspection , JobStatus , JobType , Task , TaskHistory [EOL] from annofabapi . parser import SimpleAnnotationZipParser [EOL] [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . exceptions import DownloadingFileNotFoundError [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] InputDataDict = Dict [ InputDataId , Dict [ str , Any ] ] [EOL] AnnotationDict = Dict [ str , InputDataDict ] [EOL] AnnotationSummaryFunc = Callable [ [ List [ Dict [ str , Any ] ] ] , Dict [ str , Any ] ] [EOL] [docstring] [EOL] [EOL] [EOL] def _get_task_histories_dict ( api , project_id , task_id ) : [EOL] task_histories , _ = api . get_task_histories ( project_id , task_id ) [EOL] return { task_id : task_histories } [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Query : [EOL] [docstring] [EOL] [EOL] task_query_param = None [EOL] ignored_task_id_list = None [EOL] start_date = None [EOL] end_date = None [EOL] [EOL] [EOL] class Database : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] filename_timestamp = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , annofab_service , project_id , chekpoint_dir , query = None ) : [EOL] [docstring] [EOL] [EOL] self . annofab_service = annofab_service [EOL] self . project_id = project_id [EOL] self . checkpoint_dir = chekpoint_dir [EOL] self . query = query if query is not None else Query ( ) [EOL] [EOL] [comment] [EOL] self . tasks_json_path = Path ( f"{ self . checkpoint_dir } [string] " ) [EOL] self . input_data_json_path = Path ( f"{ self . checkpoint_dir } [string] " ) [EOL] self . inspection_json_path = Path ( f"{ self . checkpoint_dir } [string] " ) [EOL] self . task_histories_json_path = Path ( f"{ self . checkpoint_dir } [string] " ) [EOL] self . annotations_zip_path = Path ( f"{ self . checkpoint_dir } [string] " ) [EOL] [EOL] def __write_checkpoint ( self , obj , pickle_file_name ) : [EOL] [docstring] [EOL] [EOL] pickle_file_path = f"{ self . checkpoint_dir } [string] { pickle_file_name }" [EOL] if os . path . exists ( pickle_file_path ) : [EOL] dest_file_name = f"{ self . filename_timestamp } [string] { pickle_file_name }" [EOL] dest_path = f"{ self . checkpoint_dir } [string] { dest_file_name }" [EOL] shutil . copyfile ( pickle_file_path , dest_path ) [EOL] [EOL] with open ( pickle_file_path , [string] ) as file : [EOL] pickle . dump ( obj , file ) [EOL] [EOL] def __read_checkpoint ( self , pickle_file_name ) : [EOL] file_path = f"{ self . checkpoint_dir } [string] { pickle_file_name }" [EOL] if not os . path . exists ( file_path ) : [EOL] return None [EOL] with open ( file_path , [string] ) as file : [EOL] return pickle . load ( file ) [EOL] [EOL] def read_account_statistics_from_checkpoint ( self ) : [EOL] result = self . __read_checkpoint ( [string] ) [EOL] return result if result is not None else [ ] [EOL] [EOL] def read_labor_list_from_checkpoint ( self ) : [EOL] result = self . __read_checkpoint ( [string] ) [EOL] return result if result is not None else [ ] [EOL] [EOL] @ staticmethod def task_exists ( task_list , task_id ) : [EOL] task = more_itertools . first_true ( task_list , pred = lambda e : e [ [string] ] == task_id ) [EOL] if task is None : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def read_annotation_summary ( self , task_list , annotation_summary_func ) : [EOL] logger . debug ( f" [string] { str ( self . annotations_zip_path ) }" ) [EOL] [EOL] def read_annotation_summary_per_input_data ( task_id , input_data_id_ ) : [EOL] json_path = f"{ task_id } [string] { input_data_id_ } [string] " [EOL] parser = SimpleAnnotationZipParser ( zip_file , json_path ) [EOL] simple_annotation = parser . load_json ( ) [EOL] return annotation_summary_func ( simple_annotation [ [string] ] ) [EOL] [EOL] with zipfile . ZipFile ( self . annotations_zip_path , [string] ) as zip_file : [EOL] annotation_dict = { } [EOL] [EOL] task_count = [number] [EOL] for task in task_list : [EOL] task_count += [number] [EOL] if task_count % [number] == [number] : [EOL] logger . debug ( f"{ task_count } [string] { len ( task_list ) } [string] " ) [EOL] [EOL] task_id = task [ [string] ] [EOL] input_data_id_list = task [ [string] ] [EOL] [EOL] try : [EOL] input_data_dict = { } [EOL] for input_data_id in input_data_id_list : [EOL] input_data_dict [ input_data_id ] = read_annotation_summary_per_input_data ( task_id , input_data_id ) [EOL] annotation_dict [ task_id ] = input_data_dict [EOL] except Exception as e : [comment] [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] logger . warning ( e ) [EOL] continue [EOL] [EOL] return annotation_dict [EOL] [EOL] def read_inspections_from_json ( self , task_id_list ) : [EOL] logger . debug ( f" [string] { self . inspection_json_path }" ) [EOL] [EOL] with open ( str ( self . inspection_json_path ) ) as f : [EOL] all_inspections = json . load ( f ) [EOL] [EOL] tasks_dict = { } [EOL] [EOL] for inspection in all_inspections : [EOL] task_id = inspection [ [string] ] [EOL] if task_id not in task_id_list : [EOL] continue [EOL] [EOL] input_data_id = inspection [ [string] ] [EOL] [EOL] input_data_dict = tasks_dict . get ( task_id , { } ) [EOL] [EOL] inspection_list = input_data_dict . get ( input_data_id , [ ] ) [EOL] [EOL] inspection_list . append ( inspection ) [EOL] [EOL] input_data_dict [ input_data_id ] = inspection_list [EOL] tasks_dict [ task_id ] = input_data_dict [EOL] [EOL] return tasks_dict [EOL] [EOL] def read_input_data_from_json ( self , task_list ) : [EOL] path = self . input_data_json_path [EOL] logger . debug ( f" [string] { path }" ) [EOL] with open ( str ( path ) ) as f : [EOL] all_input_data_list = json . load ( f ) [EOL] [EOL] all_input_data_dict = { e [ [string] ] : e for e in all_input_data_list } [EOL] tasks_dict = { } [EOL] [EOL] for task in task_list : [EOL] task_id = task [ [string] ] [EOL] input_data_id_list = task [ [string] ] [EOL] tasks_dict [ task_id ] = [ all_input_data_dict [ input_data_id ] for input_data_id in input_data_id_list ] [EOL] [EOL] return tasks_dict [EOL] [EOL] def read_task_histories_from_json ( self , task_id_list = None ) : [EOL] logger . debug ( f" [string] { self . task_histories_json_path }" ) [EOL] with open ( str ( self . task_histories_json_path ) ) as f : [EOL] task_histories_dict = json . load ( f ) [EOL] [EOL] if task_id_list is not None : [EOL] removed_task_id_set = set ( task_histories_dict . keys ( ) ) - set ( task_id_list ) [EOL] for task_id in removed_task_id_set : [EOL] del task_histories_dict [ task_id ] [EOL] [EOL] return task_histories_dict [EOL] [EOL] def wait_for_completion_updated_annotation ( self , project_id ) : [EOL] MAX_JOB_ACCESS = [number] [EOL] JOB_ACCESS_INTERVAL = [number] [EOL] MAX_WAIT_MINUTU = MAX_JOB_ACCESS * JOB_ACCESS_INTERVAL / [number] [EOL] result = self . annofab_service . wrapper . wait_for_completion ( project_id , job_type = JobType . GEN_ANNOTATION , job_access_interval = JOB_ACCESS_INTERVAL , max_job_access = MAX_JOB_ACCESS , ) [EOL] if result : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTU } [string] " ) [EOL] return [EOL] [EOL] def wait_for_completion_updated_task_json ( self , project_id ) : [EOL] MAX_JOB_ACCESS = [number] [EOL] JOB_ACCESS_INTERVAL = [number] [EOL] MAX_WAIT_MINUTU = MAX_JOB_ACCESS * JOB_ACCESS_INTERVAL / [number] [EOL] result = self . annofab_service . wrapper . wait_for_completion ( project_id , job_type = JobType . GEN_TASKS_LIST , job_access_interval = JOB_ACCESS_INTERVAL , max_job_access = MAX_JOB_ACCESS , ) [EOL] if result : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTU } [string] " ) [EOL] return [EOL] [EOL] def update_annotation_zip ( self , project_id , should_update_annotation_zip = False ) : [EOL] [docstring] [EOL] [EOL] project , _ = self . annofab_service . api . get_project ( project_id ) [EOL] last_tasks_updated_datetime = project [ [string] ] [ [string] ] [EOL] logger . debug ( f" [string] { last_tasks_updated_datetime }" ) [EOL] [EOL] annotation_specs_history = self . annofab_service . api . get_annotation_specs_histories ( project_id ) [ [number] ] [EOL] annotation_specs_updated_datetime = annotation_specs_history [ - [number] ] [ [string] ] [EOL] logger . debug ( f" [string] { annotation_specs_updated_datetime }" ) [EOL] [EOL] job_list = self . annofab_service . api . get_project_job ( project_id , query_params = { [string] : JobType . GEN_ANNOTATION . value , [string] : [number] } ) [ [number] ] [ [string] ] [EOL] if len ( job_list ) > [number] : [EOL] job = job_list [ [number] ] [EOL] logger . debug ( f" [string] { job [ [string] ] } [string] { job [ [string] ] }" ) [EOL] [EOL] if should_update_annotation_zip : [EOL] if len ( job_list ) == [number] : [EOL] self . annofab_service . api . post_annotation_archive_update ( project_id ) [EOL] self . wait_for_completion_updated_annotation ( project_id ) [EOL] else : [EOL] job = job_list [ [number] ] [EOL] job_status = JobStatus ( job [ [string] ] ) [EOL] if job_status == JobStatus . PROGRESS : [EOL] logger . info ( f" [string] " ) [EOL] self . wait_for_completion_updated_annotation ( project_id ) [EOL] [EOL] elif job_status == JobStatus . SUCCEEDED : [EOL] if dateutil . parser . parse ( job [ [string] ] ) < dateutil . parser . parse ( last_tasks_updated_datetime ) : [EOL] logger . info ( f" [string] " ) [EOL] self . annofab_service . api . post_annotation_archive_update ( project_id ) [EOL] self . wait_for_completion_updated_annotation ( project_id ) [EOL] [EOL] elif dateutil . parser . parse ( job [ [string] ] ) < dateutil . parser . parse ( annotation_specs_updated_datetime ) : [EOL] logger . info ( f" [string] " ) [EOL] self . annofab_service . api . post_annotation_archive_update ( project_id ) [EOL] self . wait_for_completion_updated_annotation ( project_id ) [EOL] [EOL] else : [EOL] logger . info ( f" [string] " ) [EOL] [EOL] elif job_status == JobStatus . FAILED : [EOL] logger . info ( [string] ) [EOL] self . annofab_service . api . post_annotation_archive_update ( project_id ) [EOL] self . wait_for_completion_updated_annotation ( project_id ) [EOL] [EOL] def update_task_json ( self , project_id , should_update_task_json = False ) : [EOL] [docstring] [EOL] [EOL] job_list = self . annofab_service . api . get_project_job ( project_id , query_params = { [string] : JobType . GEN_TASKS_LIST . value , [string] : [number] } ) [ [number] ] [ [string] ] [EOL] [EOL] if len ( job_list ) == [number] : [EOL] if should_update_task_json : [EOL] self . annofab_service . api . post_project_tasks_update ( project_id ) [EOL] self . wait_for_completion_updated_task_json ( project_id ) [EOL] [EOL] else : [EOL] job = job_list [ [number] ] [EOL] logger . debug ( f" [string] { job [ [string] ] } [string] { job [ [string] ] }" ) [EOL] [EOL] if should_update_task_json : [EOL] job_status = JobStatus ( job [ [string] ] ) [EOL] if job_status == JobStatus . PROGRESS : [EOL] logger . info ( f" [string] " ) [EOL] self . wait_for_completion_updated_task_json ( project_id ) [EOL] [EOL] elif job_status == JobStatus . SUCCEEDED : [EOL] self . annofab_service . api . post_project_tasks_update ( project_id ) [EOL] self . wait_for_completion_updated_task_json ( project_id ) [EOL] [EOL] elif job_status == JobStatus . FAILED : [EOL] logger . info ( [string] ) [EOL] self . annofab_service . api . post_project_tasks_update ( project_id ) [EOL] self . wait_for_completion_updated_task_json ( project_id ) [EOL] [EOL] def _write_task_histories_json ( self ) : [EOL] task_list = self . read_tasks_from_json ( ) [EOL] task_histories_dict = self . get_task_histories_dict ( task_list ) [EOL] with self . task_histories_json_path . open ( mode = [string] ) as f : [EOL] json . dump ( task_histories_dict , f ) [EOL] [EOL] def _log_annotation_zip_info ( self ) : [EOL] project , _ = self . annofab_service . api . get_project ( self . project_id ) [EOL] last_tasks_updated_datetime = project [ [string] ] [ [string] ] [EOL] logger . debug ( f" [string] { last_tasks_updated_datetime }" ) [EOL] [EOL] annotation_specs_history = self . annofab_service . api . get_annotation_specs_histories ( self . project_id ) [ [number] ] [EOL] annotation_specs_updated_datetime = annotation_specs_history [ - [number] ] [ [string] ] [EOL] logger . debug ( f" [string] { annotation_specs_updated_datetime }" ) [EOL] [EOL] job_list = self . annofab_service . api . get_project_job ( self . project_id , query_params = { [string] : JobType . GEN_ANNOTATION . value , [string] : [number] } ) [ [number] ] [ [string] ] [EOL] if len ( job_list ) == [number] : [EOL] logger . debug ( f" [string] " ) [EOL] else : [EOL] job = job_list [ [number] ] [EOL] logger . debug ( f" [string] { job [ [string] ] } [string] { job [ [string] ] }" ) [EOL] [EOL] def _download_db_file ( self , is_latest ) : [EOL] [docstring] [EOL] [EOL] downloading_obj = DownloadingFile ( self . annofab_service ) [EOL] [EOL] wait_options = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] TASK_JSON_INDEX = [number] [EOL] INPUT_DATA_JSON_INDEX = [number] [EOL] ANNOTATION_ZIP_INDEX = [number] [EOL] TASK_HISTORY_JSON_INDEX = [number] [EOL] INSPECTION_JSON_INDEX = [number] [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] coroutines = [ None ] * [number] [EOL] coroutines [ TASK_JSON_INDEX ] = downloading_obj . download_task_json_with_async ( self . project_id , dest_path = str ( self . tasks_json_path ) , is_latest = is_latest , wait_options = wait_options ) [EOL] coroutines [ INPUT_DATA_JSON_INDEX ] = downloading_obj . download_input_data_json_with_async ( self . project_id , dest_path = str ( self . input_data_json_path ) , is_latest = is_latest , wait_options = wait_options , ) [EOL] coroutines [ ANNOTATION_ZIP_INDEX ] = downloading_obj . download_annotation_zip_with_async ( self . project_id , dest_path = str ( self . annotations_zip_path ) , is_latest = is_latest , wait_options = wait_options , ) [EOL] coroutines [ TASK_HISTORY_JSON_INDEX ] = downloading_obj . download_task_history_json_with_async ( self . project_id , dest_path = str ( self . task_histories_json_path ) ) [EOL] coroutines [ INSPECTION_JSON_INDEX ] = downloading_obj . download_inspection_json_with_async ( self . project_id , dest_path = str ( self . inspection_json_path ) ) [EOL] gather = asyncio . gather ( * coroutines , return_exceptions = True ) [EOL] results = loop . run_until_complete ( gather ) [EOL] [EOL] if isinstance ( results [ INSPECTION_JSON_INDEX ] , DownloadingFileNotFoundError ) : [EOL] [comment] [EOL] self . inspection_json_path . write_text ( [string] , encoding = [string] ) [EOL] elif isinstance ( results [ INSPECTION_JSON_INDEX ] , Exception ) : [EOL] raise results [ INSPECTION_JSON_INDEX ] [EOL] [EOL] if isinstance ( results [ TASK_HISTORY_JSON_INDEX ] , DownloadingFileNotFoundError ) : [EOL] [comment] [EOL] self . _write_task_histories_json ( ) [EOL] elif isinstance ( results [ TASK_HISTORY_JSON_INDEX ] , Exception ) : [EOL] raise results [ TASK_HISTORY_JSON_INDEX ] [EOL] [EOL] for result in [ results [ TASK_JSON_INDEX ] , results [ INPUT_DATA_JSON_INDEX ] , results [ ANNOTATION_ZIP_INDEX ] ] : [EOL] if isinstance ( result , Exception ) : [EOL] raise result [EOL] [EOL] @ staticmethod def _to_datetime_with_tz ( str_date ) : [EOL] dt = dateutil . parser . parse ( str_date ) [EOL] dt = dt . replace ( tzinfo = dateutil . tz . tzlocal ( ) ) [EOL] return dt [EOL] [EOL] def read_tasks_from_json ( self , ) : [EOL] [docstring] [EOL] query = self . query [EOL] [EOL] [comment] [EOL] dt_end_date = ( self . _to_datetime_with_tz ( query . end_date ) + datetime . timedelta ( days = [number] ) [EOL] if query . end_date is not None [EOL] else None ) [EOL] [EOL] def filter_task ( arg_task ) : [EOL] [docstring] [EOL] [EOL] flag = True [EOL] if query . task_query_param is not None : [EOL] if [string] in query . task_query_param : [EOL] flag = flag and arg_task [ [string] ] == query . task_query_param [ [string] ] [EOL] [EOL] if [string] in query . task_query_param : [EOL] flag = flag and arg_task [ [string] ] == query . task_query_param [ [string] ] [EOL] [EOL] if [string] in query . task_query_param : [EOL] flag = flag and str ( query . task_query_param [ [string] ] ) . lower ( ) in str ( arg_task [ [string] ] ) . lower ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if dt_end_date is not None : [EOL] flag = flag and ( dateutil . parser . parse ( arg_task [ [string] ] ) < dt_end_date ) [EOL] [EOL] if query . ignored_task_id_list is not None : [EOL] flag = flag and arg_task [ [string] ] not in query . ignored_task_id_list [EOL] [EOL] return flag [EOL] [EOL] logger . debug ( f" [string] { self . tasks_json_path }" ) [EOL] with open ( str ( self . tasks_json_path ) ) as f : [EOL] all_tasks = json . load ( f ) [EOL] [EOL] filtered_task_list = [ task for task in all_tasks if filter_task ( task ) ] [EOL] [EOL] if self . query . start_date is not None : [EOL] [comment] [EOL] dict_task_histories = self . read_task_histories_from_json ( ) [EOL] filtered_task_list = self . _filter_task_with_task_history ( filtered_task_list , dict_task_histories = dict_task_histories , start_date = self . query . start_date ) [EOL] [EOL] logger . debug ( f" [string] { len ( filtered_task_list ) }" ) [EOL] return filtered_task_list [EOL] [EOL] @ staticmethod def _filter_task_with_task_history ( task_list , dict_task_histories , start_date ) : [EOL] [docstring] [EOL] dt_start_date = Database . _to_datetime_with_tz ( start_date ) [EOL] [EOL] def pred ( task_id ) : [EOL] task_histories = dict_task_histories . get ( task_id ) [EOL] if task_histories is None or len ( task_histories ) == [number] : [EOL] return False [EOL] [EOL] first_started_datetime = task_histories [ [number] ] [ [string] ] [EOL] if first_started_datetime is None : [EOL] return False [EOL] return dateutil . parser . parse ( first_started_datetime ) >= dt_start_date [EOL] [EOL] return [ task for task in task_list if pred ( task [ [string] ] ) ] [EOL] [EOL] def update_db ( self , is_latest ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] self . filename_timestamp = [string] . format ( datetime . datetime . now ( ) ) [EOL] [EOL] [comment] [EOL] self . _download_db_file ( is_latest ) [EOL] self . _log_annotation_zip_info ( ) [EOL] [EOL] [comment] [EOL] account_statistics = self . annofab_service . wrapper . get_account_statistics ( self . project_id ) [EOL] self . __write_checkpoint ( account_statistics , [string] ) [EOL] [EOL] [comment] [EOL] labor_list = self . _get_labor_list ( self . project_id ) [EOL] self . __write_checkpoint ( labor_list , [string] ) [EOL] [EOL] @ staticmethod def _get_worktime_hour ( working_time_by_user , key ) : [EOL] if working_time_by_user is None : [EOL] return [number] [EOL] [EOL] value = working_time_by_user . get ( key ) [EOL] if value is None : [EOL] return [number] [EOL] else : [EOL] return value / [number] / [number] [EOL] [EOL] def _get_labor_list ( self , project_id ) : [EOL] def to_new_labor ( e ) : [EOL] return dict ( date = e [ [string] ] , account_id = e [ [string] ] , worktime_plan_hour = self . _get_worktime_hour ( e [ [string] ] [ [string] ] , [string] ) , worktime_result_hour = self . _get_worktime_hour ( e [ [string] ] [ [string] ] , [string] ) , ) [EOL] [EOL] [comment] [EOL] end_date = ( self . query . end_date if self . query . end_date is not None else datetime . datetime . now ( ) . strftime ( [string] ) ) [EOL] labor_list = self . annofab_service . api . get_labor_control ( { [string] : project_id , [string] : self . query . start_date , [string] : end_date } ) [ [number] ] [EOL] [EOL] return [ to_new_labor ( e ) for e in labor_list if e [ [string] ] is not None ] [EOL] [EOL] @ staticmethod def get_not_updated_task_ids ( old_tasks , new_tasks ) : [EOL] [docstring] [EOL] updated_task_ids = set ( ) [EOL] for new_task in new_tasks : [EOL] filterd_list = [ e for e in old_tasks if e [ [string] ] == new_task [ [string] ] ] [EOL] if len ( filterd_list ) == [number] : [EOL] continue [EOL] old_task = filterd_list [ [number] ] [EOL] if dateutil . parser . parse ( old_task [ [string] ] ) == dateutil . parser . parse ( new_task [ [string] ] ) : [EOL] updated_task_ids . add ( new_task [ [string] ] ) [EOL] [EOL] return updated_task_ids [EOL] [EOL] def get_task_histories_dict ( self , all_tasks ) : [EOL] [docstring] [EOL] if self . query . ignored_task_id_list is None : [EOL] ignored_task_ids = set ( ) [EOL] else : [EOL] ignored_task_ids = set ( self . query . ignored_task_id_list ) [EOL] [EOL] tasks = [ e for e in all_tasks if e [ [string] ] not in ignored_task_ids ] [EOL] logger . info ( f" [string] { len ( tasks ) }" ) [EOL] [EOL] tasks_dict = { } [EOL] if len ( tasks ) == [number] : [EOL] return tasks_dict [EOL] [EOL] task_id_list = [ e [ [string] ] for e in tasks ] [EOL] partial_func = partial ( _get_task_histories_dict , self . annofab_service . api , self . project_id ) [EOL] with multiprocessing . Pool ( ) as pool : [EOL] task_index = [number] [EOL] for obj in pool . map ( partial_func , task_id_list ) : [EOL] if task_index % [number] == [number] : [EOL] logger . debug ( f" [string] { task_index } [string] { len ( tasks ) } [string] " ) [EOL] tasks_dict . update ( obj ) [EOL] task_index += [number] [EOL] [EOL] return tasks_dict [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 $typing.List[annofabapi.models.Task]$ 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Task.History]]$ 0 $builtins.str$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Task.History]]$ 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Task.History]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Task.History]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Task.History]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Task.History]]$ 0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . utils import isoduration_to_hour [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class LaborTimePerUser ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def get_labor_time_per_user ( self , project_id ) : [EOL] [docstring] [EOL] account_statistics = self . service . wrapper . get_account_statistics ( project_id ) [EOL] row_list = [ ] [EOL] for stat_by_user in account_statistics : [EOL] account_id = stat_by_user [ [string] ] [EOL] member = self . facade . get_organization_member_from_account_id ( project_id , account_id ) [EOL] [EOL] histories = stat_by_user [ [string] ] [EOL] for stat in histories : [EOL] stat [ [string] ] = account_id [EOL] stat [ [string] ] = member [ [string] ] if member is not None else None [EOL] stat [ [string] ] = member [ [string] ] if member is not None else None [EOL] stat [ [string] ] = member [ [string] ] if member is not None else None [EOL] stat [ [string] ] = isoduration_to_hour ( stat [ [string] ] ) [EOL] [EOL] row_list . extend ( histories ) [EOL] return row_list [EOL] [EOL] def list_cumulative_labor_time ( self , project_id ) : [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] account_stat_list = self . get_labor_time_per_user ( project_id ) [EOL] df = pandas . DataFrame ( account_stat_list ) [EOL] [comment] [EOL] target_df = df [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] [EOL] annofabcli . utils . print_csv ( target_df , output = self . output , to_csv_kwargs = self . csv_format ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] project_id = args . project_id [EOL] self . list_cumulative_labor_time ( project_id ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] LaborTimePerUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import pandas [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Any , List , Optional [EOL] [EOL] import pandas [EOL] from annofabapi . models import TaskPhase [EOL] [EOL] from annofabcli . common . utils import print_csv [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Csv : [EOL] [docstring] [EOL] [EOL] CSV_FORMAT = { [string] : [string] , [string] : False } [EOL] [EOL] def __init__ ( self , outdir ) : [EOL] self . outdir = outdir [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _write_csv ( self , filename , df ) : [EOL] [docstring] [EOL] output_path = Path ( f"{ self . outdir } [string] { filename }" ) [EOL] output_path . parent . mkdir ( exist_ok = True , parents = True ) [EOL] logger . debug ( f"{ str ( output_path ) } [string] " ) [EOL] df . to_csv ( str ( output_path ) , sep = [string] , encoding = [string] , index = False ) [EOL] [EOL] @ staticmethod def _create_required_columns ( df , prior_columns , dropped_columns = None ) : [EOL] remained_columns = list ( df . columns . difference ( prior_columns ) ) [EOL] all_columns = prior_columns + remained_columns [EOL] if dropped_columns is not None : [EOL] for key in dropped_columns : [EOL] if key in all_columns : [EOL] all_columns . remove ( key ) [EOL] return all_columns [EOL] [EOL] def write_inspection_list ( self , df , dropped_columns = None , only_error_corrected = True , ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if only_error_corrected : [EOL] suffix = [string] [EOL] else : [EOL] suffix = [string] [EOL] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] self . _write_csv ( f" [string] { suffix } [string] " , df [ required_columns ] ) [EOL] [EOL] def write_task_list ( self , df , dropped_columns = None ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if dropped_columns is None : [EOL] dropped_columns = [ ] [EOL] dropped_columns . extend ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_task_history_list ( self , df , dropped_columns = None ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] df = df . sort_values ( [ [string] , [string] ] ) [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_labor_list ( self , df , dropped_columns = None ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] df = df . sort_values ( [ [string] , [string] ] ) [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_worktime_summary ( self , df ) : [EOL] [docstring] [EOL] columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] stat_df = df [ columns ] . describe ( ) . T [EOL] stat_df [ [string] ] = df [ columns ] . sum ( ) . values [EOL] stat_df [ [string] ] = stat_df . index [EOL] [EOL] [comment] [EOL] ignored_auto_inspection_df = df [ ~ df [ [string] ] ] [EOL] columns_inspection = [ [string] , [string] , [string] , ] [EOL] stat_inspection_df = ignored_auto_inspection_df [ columns_inspection ] . describe ( ) . T [EOL] stat_inspection_df [ [string] ] = df [ columns_inspection ] . sum ( ) . values [EOL] stat_inspection_df [ [string] ] = stat_inspection_df . index + [string] [EOL] [EOL] [comment] [EOL] ignore_auto_acceptance_df = df [ ~ df [ [string] ] ] [EOL] columns_acceptance = [ [string] , [string] , [string] , ] [EOL] stat_acceptance_df = ignore_auto_acceptance_df [ columns_acceptance ] . describe ( ) . T [EOL] stat_acceptance_df [ [string] ] = df [ columns_acceptance ] . sum ( ) . values [EOL] stat_acceptance_df [ [string] ] = stat_acceptance_df . index + [string] [EOL] [EOL] target_df = pandas . concat ( [ stat_df , stat_inspection_df , stat_acceptance_df ] ) [EOL] target_df = target_df [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ] [EOL] [EOL] self . _write_csv ( f" [string] " , target_df ) [EOL] [EOL] def write_count_summary ( self , df ) : [EOL] [docstring] [EOL] columns = [ [string] , [string] , [string] , ] [EOL] stat_df = df [ columns ] . describe ( ) . T [EOL] stat_df [ [string] ] = df [ columns ] . sum ( ) . values [EOL] stat_df [ [string] ] = stat_df . index [EOL] [EOL] target_df = stat_df [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ] [EOL] [EOL] self . _write_csv ( f" [string] " , target_df ) [EOL] [EOL] def write_task_count_summary ( self , df ) : [EOL] [docstring] [EOL] columns = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] sum_series = df [ columns ] . sum ( ) [EOL] sum_df = pandas . DataFrame ( ) [EOL] sum_df [ [string] ] = sum_series . index [EOL] sum_df [ [string] ] = sum_series . values [EOL] sum_df = sum_df . append ( { [string] : [string] , [string] : len ( df ) } , ignore_index = True ) [EOL] self . _write_csv ( f" [string] " , sum_df ) [EOL] [EOL] def write_member_list ( self , df , dropped_columns = None ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_ラベルごとのアノテーション数 ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , ] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns = None ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_教師付作業者別日毎の情報 ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns = None ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_ユーザ別日毎の作業時間 ( self , df ) : [EOL] [docstring] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] prior_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns = None ) [EOL] self . _write_csv ( f" [string] " , df [ required_columns ] ) [EOL] [EOL] def write_メンバー別作業時間平均_画像1枚あたり ( self , df , phase ) : [EOL] if len ( df ) == [number] : [EOL] logger . info ( f" [string] { phase . value } [string] " ) [EOL] return [EOL] self . _write_csv ( f" [string] { phase . value } [string] " , df ) [EOL] [EOL] def write_メンバー別作業時間平均_タスク1個あたり ( self , df , phase ) : [EOL] if len ( df ) == [number] : [EOL] logger . info ( f" [string] { phase . value } [string] " ) [EOL] return [EOL] self . _write_csv ( f" [string] { phase . value } [string] " , df ) [EOL] [EOL] def write_productivity_per_user ( self , df , dropped_columns = None , output_path = None ) : [EOL] [docstring] [EOL] [EOL] def get_phase_list ( ) : [EOL] columns = list ( df . columns ) [EOL] phase_list = [ TaskPhase . ANNOTATION . value , TaskPhase . INSPECTION . value , TaskPhase . ACCEPTANCE . value ] [EOL] if ( [string] , TaskPhase . INSPECTION . value ) not in columns : [EOL] phase_list . remove ( TaskPhase . INSPECTION . value ) [EOL] if ( [string] , TaskPhase . ACCEPTANCE . value ) not in columns : [EOL] phase_list . remove ( TaskPhase . ACCEPTANCE . value ) [EOL] return phase_list [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] phase_list = get_phase_list ( ) [EOL] [EOL] user_columns = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] monitored_worktime_columns = ( [ ( [string] , phase ) for phase in phase_list ] + [ ( [string] , [string] ) ] + [ ( [string] , phase ) for phase in phase_list ] ) [EOL] production_columns = ( [ ( [string] , phase ) for phase in phase_list ] + [ ( [string] , phase ) for phase in phase_list ] + [ ( [string] , phase ) for phase in phase_list ] ) [EOL] [EOL] actual_worktime_columns = [ ( [string] , [string] ) ] + [ ( [string] , phase ) for phase in phase_list ] [EOL] [EOL] productivity_columns = ( [ ( [string] , phase ) for phase in phase_list ] + [ ( [string] , phase ) for phase in phase_list ] + [ ( [string] , phase ) for phase in phase_list ] + [ ( [string] , phase ) for phase in phase_list ] ) [EOL] [EOL] inspection_comment_columns = [ ( [string] , TaskPhase . ANNOTATION . value ) , ( [string] , TaskPhase . ANNOTATION . value ) , ( [string] , TaskPhase . ANNOTATION . value ) , ] [EOL] [EOL] prior_columns = ( user_columns + monitored_worktime_columns + production_columns + actual_worktime_columns + productivity_columns + inspection_comment_columns ) [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] target_df = df [ required_columns ] [EOL] if output_path is None : [EOL] self . _write_csv ( f" [string] " , target_df ) [EOL] else : [EOL] print_csv ( df , output = str ( output_path ) , to_csv_kwargs = self . CSV_FORMAT ) [EOL] [EOL] def write_whole_productivity_per_date ( self , df , dropped_columns = None , output_path = None ) : [EOL] [docstring] [EOL] production_columns = [ [string] , [string] , [string] , ] [EOL] worktime_columns = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] velocity_columns = [ f"{ numerator } [string] { denominator }{ suffix }" for numerator in [ [string] , [string] ] for denominator in [ [string] , [string] , [string] ] for suffix in [ [string] , [string] ] ] [EOL] [EOL] prior_columns = ( [ [string] , [string] , [string] , [string] ] + production_columns + worktime_columns + velocity_columns + [ [string] ] ) [EOL] [EOL] required_columns = self . _create_required_columns ( df , prior_columns , dropped_columns ) [EOL] target_df = df [ required_columns ] [EOL] if output_path is None : [EOL] self . _write_csv ( f" [string] " , target_df ) [EOL] else : [EOL] print_csv ( df , output = str ( output_path ) , to_csv_kwargs = self . CSV_FORMAT ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $pandas.DataFrame$ 0 $typing.List[typing.Any]$ 0 $typing.Optional[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Callable , Any , Optional [EOL] import builtins [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import json [EOL] import logging . handlers [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from typing import Any , Callable , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] from annofabapi . models import ProjectMemberRole , TaskPhase [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . statistics . csv import Csv [EOL] from annofabcli . statistics . database import Database , Query [EOL] from annofabcli . statistics . histogram import Histogram [EOL] from annofabcli . statistics . linegraph import LineGraph , OutputTarget [EOL] from annofabcli . statistics . scatter import Scatter [EOL] from annofabcli . statistics . table import AggregationBy , Table [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class CommnadLineArgs : [EOL] task_query = ... [EOL] user_id_list = ... [EOL] start_date = ... [EOL] end_date = ... [EOL] ignored_task_id_list = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class ProjectSummary : [EOL] project_id = ... [EOL] project_title = ... [EOL] measurement_datetime = ... [EOL] [docstring] [EOL] args = ... [EOL] [docstring] [EOL] [EOL] [EOL] def write_project_name_file ( annofab_service , project_id , command_line_args , output_project_dir ) : [EOL] [docstring] [EOL] project_info = annofab_service . api . get_project ( project_id ) [ [number] ] [EOL] project_title = project_info [ [string] ] [EOL] logger . info ( f" [string] { project_title }" ) [EOL] filename = annofabcli . utils . to_filename ( project_title ) [EOL] output_project_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] prject_summary = ProjectSummary ( project_id = project_id , project_title = project_title , measurement_datetime = annofabapi . utils . str_now ( ) , args = command_line_args , ) [EOL] [EOL] with open ( str ( output_project_dir / f"{ filename } [string] " ) , [string] ) as f : [EOL] json . dump ( prject_summary . to_dict ( ) , f , ensure_ascii = False , indent = [number] ) [comment] [EOL] [EOL] [EOL] def catch_exception ( function ) : [EOL] [docstring] [EOL] [EOL] def wrapped ( * args , ** kwargs ) : [EOL] try : [EOL] return function ( * args , ** kwargs ) [EOL] except Exception as e : [comment] [EOL] logger . warning ( e ) [EOL] logger . exception ( e ) [EOL] [EOL] return wrapped [EOL] [EOL] [EOL] class WriteCsvGraph : [EOL] task_df = None [EOL] annotation_df = None [EOL] account_statistics_df = None [EOL] df_by_date_user = None [EOL] task_history_df = None [EOL] labor_df = None [EOL] productivity_df = None [EOL] whole_productivity_df = None [EOL] [EOL] def __init__ ( self , table_obj , output_dir , minimal_output = False ) : [EOL] self . table_obj = table_obj [EOL] self . csv_obj = Csv ( str ( output_dir ) ) [EOL] self . histogram_obj = Histogram ( str ( output_dir / [string] ) ) [EOL] self . linegraph_obj = LineGraph ( str ( output_dir / [string] ) ) [EOL] self . scatter_obj = Scatter ( str ( output_dir / [string] ) ) [EOL] self . minimal_output = minimal_output [EOL] [EOL] def _get_task_df ( self ) : [EOL] if self . task_df is None : [EOL] self . task_df = self . table_obj . create_task_df ( ) [EOL] return self . task_df [EOL] [EOL] def _get_task_history_df ( self ) : [EOL] if self . task_history_df is None : [EOL] self . task_history_df = self . table_obj . create_task_history_df ( ) [EOL] return self . task_history_df [EOL] [EOL] def _get_annotation_df ( self ) : [EOL] if self . annotation_df is None : [EOL] self . annotation_df = self . table_obj . create_task_for_annotation_df ( ) [EOL] return self . annotation_df [EOL] [EOL] def _get_account_statistics_df ( self ) : [EOL] if self . account_statistics_df is None : [EOL] self . account_statistics_df = self . table_obj . create_account_statistics_df ( ) [EOL] return self . account_statistics_df [EOL] [EOL] def _get_df_by_date_user ( self ) : [EOL] if self . df_by_date_user is None : [EOL] task_df = self . _get_task_df ( ) [EOL] self . df_by_date_user = self . table_obj . create_dataframe_by_date_user ( task_df ) [EOL] return self . df_by_date_user [EOL] [EOL] def _get_labor_df ( self ) : [EOL] if self . labor_df is None : [EOL] self . labor_df = self . table_obj . create_labor_df ( ) [EOL] return self . labor_df [EOL] [EOL] def _get_productivity_df ( self ) : [EOL] if self . productivity_df is None : [EOL] task_history_df = self . _get_task_history_df ( ) [EOL] task_df = self . _get_task_df ( ) [EOL] annotation_count_ratio_df = self . table_obj . create_annotation_count_ratio_df ( task_history_df , task_df ) [EOL] productivity_df = self . table_obj . create_productivity_per_user_from_aw_time ( df_task_history = task_history_df , df_labor = self . _get_labor_df ( ) , df_worktime_ratio = annotation_count_ratio_df , ) [EOL] self . productivity_df = productivity_df [EOL] return self . productivity_df [EOL] [EOL] def _get_whole_productivity_df ( self ) : [EOL] if self . whole_productivity_df is None : [EOL] task_df = self . _get_task_df ( ) [EOL] labor_df = self . _get_labor_df ( ) [EOL] self . whole_productivity_df = self . table_obj . create_whole_productivity_per_date ( task_df , labor_df ) [EOL] return self . whole_productivity_df [EOL] [EOL] def write_histogram_for_task ( self ) : [EOL] [docstring] [EOL] task_df = self . _get_task_df ( ) [EOL] catch_exception ( self . histogram_obj . write_histogram_for_worktime ) ( task_df ) [EOL] catch_exception ( self . histogram_obj . write_histogram_for_other ) ( task_df ) [EOL] [EOL] if not self . minimal_output : [EOL] catch_exception ( self . histogram_obj . write_histogram_for_annotation_worktime_by_user ) ( task_df ) [EOL] catch_exception ( self . histogram_obj . write_histogram_for_inspection_worktime_by_user ) ( task_df ) [EOL] catch_exception ( self . histogram_obj . write_histogram_for_acceptance_worktime_by_user ) ( task_df ) [EOL] [EOL] def write_histogram_for_annotation ( self ) : [EOL] [docstring] [EOL] annotation_df = self . _get_annotation_df ( ) [EOL] catch_exception ( self . histogram_obj . write_histogram_for_annotation_count_by_label ) ( annotation_df ) [EOL] [EOL] def write_scatter_per_user ( self ) : [EOL] [docstring] [EOL] productivity_df = self . _get_productivity_df ( ) [EOL] catch_exception ( self . scatter_obj . write_scatter_for_productivity_by_monitored_worktime ) ( productivity_df ) [EOL] catch_exception ( self . scatter_obj . write_scatter_for_productivity_by_actual_worktime ) ( productivity_df ) [EOL] catch_exception ( self . scatter_obj . write_scatter_for_quality ) ( productivity_df ) [EOL] catch_exception ( self . scatter_obj . write_scatter_for_productivity_by_actual_worktime_and_quality ) ( productivity_df ) [EOL] [EOL] def write_linegraph_for_task_overall ( self ) : [EOL] [docstring] [EOL] task_df = self . _get_task_df ( ) [EOL] task_cumulative_df_overall = Table . create_cumulative_df_overall ( task_df ) [EOL] catch_exception ( self . linegraph_obj . write_cumulative_line_graph_overall ) ( task_cumulative_df_overall ) [EOL] [EOL] def write_whole_linegraph ( self ) : [EOL] whole_productivity_df = self . _get_whole_productivity_df ( ) [EOL] catch_exception ( self . linegraph_obj . write_whole_productivity_line_graph ) ( whole_productivity_df ) [EOL] catch_exception ( self . linegraph_obj . write_whole_cumulative_line_graph ) ( whole_productivity_df ) [EOL] [EOL] def write_linegraph_by_user ( self , user_id_list = None ) : [EOL] [docstring] [EOL] task_df = self . _get_task_df ( ) [EOL] if len ( task_df ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] [EOL] output_target_list = None [EOL] if self . minimal_output : [EOL] output_target_list = [ OutputTarget . ANNOTATION ] [EOL] [EOL] task_cumulative_df_by_annotator = self . table_obj . create_cumulative_df_by_first_annotator ( task_df ) [EOL] catch_exception ( self . linegraph_obj . write_cumulative_line_graph_for_annotator ) ( df = task_cumulative_df_by_annotator , output_target_list = output_target_list , first_annotation_user_id_list = user_id_list , ) [EOL] [EOL] task_cumulative_df_by_inspector = self . table_obj . create_cumulative_df_by_first_inspector ( task_df ) [EOL] catch_exception ( self . linegraph_obj . write_cumulative_line_graph_for_inspector ) ( df = task_cumulative_df_by_inspector , output_target_list = output_target_list , first_inspection_user_id_list = user_id_list , ) [EOL] [EOL] task_cumulative_df_by_acceptor = self . table_obj . create_cumulative_df_by_first_acceptor ( task_df ) [EOL] catch_exception ( self . linegraph_obj . write_cumulative_line_graph_for_acceptor ) ( df = task_cumulative_df_by_acceptor , output_target_list = output_target_list , first_acceptance_user_id_list = user_id_list , ) [EOL] [EOL] if not self . minimal_output : [EOL] df_by_date_user = self . _get_df_by_date_user ( ) [EOL] catch_exception ( self . linegraph_obj . write_productivity_line_graph_for_annotator ) ( df = df_by_date_user , first_annotation_user_id_list = user_id_list ) [EOL] [EOL] def write_linegraph_for_worktime_by_user ( self , user_id_list = None ) : [EOL] account_statistics_df = self . _get_account_statistics_df ( ) [EOL] cumulative_account_statistics_df = self . table_obj . create_cumulative_df_by_user ( account_statistics_df ) [EOL] catch_exception ( self . linegraph_obj . write_cumulative_line_graph_by_date ) ( df = cumulative_account_statistics_df , user_id_list = user_id_list ) [EOL] [EOL] def write_csv_for_task ( self ) : [EOL] [docstring] [EOL] task_df = self . _get_task_df ( ) [EOL] catch_exception ( self . csv_obj . write_task_list ) ( task_df , dropped_columns = [ [string] ] ) [EOL] [EOL] def write_csv_for_summary ( self ) : [EOL] [docstring] [EOL] task_df = self . _get_task_df ( ) [EOL] catch_exception ( self . csv_obj . write_task_count_summary ) ( task_df ) [EOL] catch_exception ( self . csv_obj . write_worktime_summary ) ( task_df ) [EOL] catch_exception ( self . csv_obj . write_count_summary ) ( task_df ) [EOL] [EOL] def write_whole_productivity_csv_per_date ( self ) : [EOL] [docstring] [EOL] whole_productivity_df = self . _get_whole_productivity_df ( ) [EOL] catch_exception ( self . csv_obj . write_whole_productivity_per_date ) ( whole_productivity_df ) [EOL] [EOL] def _write_メンバー別作業時間平均_画像1枚あたり_by_phase ( self , phase ) : [EOL] df_by_inputs = self . table_obj . create_worktime_per_image_df ( AggregationBy . BY_INPUTS , phase ) [EOL] self . csv_obj . write_メンバー別作業時間平均_画像1枚あたり ( df_by_inputs , phase ) [EOL] [EOL] df_by_tasks = self . table_obj . create_worktime_per_image_df ( AggregationBy . BY_TASKS , phase ) [EOL] self . csv_obj . write_メンバー別作業時間平均_タスク1個あたり ( df_by_tasks , phase ) [EOL] [EOL] def write_メンバー別作業時間平均_画像1枚あたり_by_phase ( self ) : [EOL] for phase in TaskPhase : [EOL] catch_exception ( self . _write_メンバー別作業時間平均_画像1枚あたり_by_phase ) ( phase ) [EOL] [EOL] def write_csv_for_inspection ( self ) : [EOL] [docstring] [EOL] inspection_df = self . table_obj . create_inspection_df ( ) [EOL] inspection_df_all = self . table_obj . create_inspection_df ( only_error_corrected = False ) [EOL] [EOL] catch_exception ( self . csv_obj . write_inspection_list ) ( df = inspection_df , dropped_columns = [ [string] ] , only_error_corrected = True ) [EOL] catch_exception ( self . csv_obj . write_inspection_list ) ( df = inspection_df_all , dropped_columns = [ [string] ] , only_error_corrected = False , ) [EOL] [EOL] def write_csv_for_annotation ( self ) : [EOL] [docstring] [EOL] annotation_df = self . _get_annotation_df ( ) [EOL] catch_exception ( self . csv_obj . write_ラベルごとのアノテーション数 ) ( annotation_df ) [EOL] [EOL] def write_csv_for_account_statistics ( self ) : [EOL] account_statistics_df = self . _get_account_statistics_df ( ) [EOL] catch_exception ( self . csv_obj . write_ユーザ別日毎の作業時間 ) ( account_statistics_df ) [EOL] [EOL] def write_csv_for_date_user ( self ) : [EOL] [docstring] [EOL] df_by_date_user = self . _get_df_by_date_user ( ) [EOL] catch_exception ( self . csv_obj . write_教師付作業者別日毎の情報 ) ( df_by_date_user ) [EOL] [EOL] def write_productivity_csv_per_user ( self ) : [EOL] productivity_df = self . _get_productivity_df ( ) [EOL] catch_exception ( self . csv_obj . write_productivity_per_user ) ( productivity_df ) [EOL] [EOL] def write_labor_and_task_history ( self ) : [EOL] task_history_df = self . _get_task_history_df ( ) [EOL] catch_exception ( self . csv_obj . write_task_history_list ) ( task_history_df ) [EOL] [EOL] df_labor = self . _get_labor_df ( ) [EOL] catch_exception ( self . csv_obj . write_labor_list ) ( df_labor ) [EOL] [EOL] [EOL] class VisualizeStatistics ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def visualize_statistics ( self , project_id , work_dir , output_dir , task_query , ignored_task_id_list , user_id_list , update = False , download_latest = False , start_date = None , end_date = None , minimal_output = False , ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , project_member_roles = [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] [EOL] checkpoint_dir = work_dir / project_id [EOL] checkpoint_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] database = Database ( self . service , project_id , str ( checkpoint_dir ) , query = Query ( task_query_param = task_query , ignored_task_id_list = ignored_task_id_list , start_date = start_date , end_date = end_date , ) , ) [EOL] if update : [EOL] database . update_db ( download_latest ) [EOL] [EOL] table_obj = Table ( database , ignored_task_id_list ) [EOL] if len ( table_obj . _get_task_list ( ) ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] if len ( table_obj . _get_task_histories_dict ( ) . keys ( ) ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] [EOL] write_project_name_file ( self . service , project_id = project_id , command_line_args = CommnadLineArgs ( task_query = task_query , user_id_list = user_id_list , start_date = start_date , end_date = end_date , ignored_task_id_list = ignored_task_id_list , ) , output_project_dir = output_dir , ) [EOL] write_obj = WriteCsvGraph ( table_obj , output_dir , minimal_output ) [EOL] write_obj . write_csv_for_task ( ) [EOL] [EOL] write_obj . write_csv_for_summary ( ) [EOL] write_obj . write_whole_productivity_csv_per_date ( ) [EOL] write_obj . write_productivity_csv_per_user ( ) [EOL] [EOL] [comment] [EOL] write_obj . write_scatter_per_user ( ) [EOL] [EOL] [comment] [EOL] write_obj . write_histogram_for_task ( ) [EOL] [EOL] [comment] [EOL] write_obj . write_linegraph_by_user ( user_id_list ) [EOL] write_obj . write_whole_linegraph ( ) [EOL] [EOL] if not minimal_output : [EOL] write_obj . write_histogram_for_annotation ( ) [EOL] write_obj . write_linegraph_for_worktime_by_user ( user_id_list ) [EOL] [EOL] [comment] [EOL] write_obj . write_labor_and_task_history ( ) [EOL] write_obj . write_csv_for_annotation ( ) [EOL] write_obj . write_csv_for_account_statistics ( ) [EOL] write_obj . write_csv_for_date_user ( ) [EOL] write_obj . write_csv_for_inspection ( ) [EOL] write_obj . write_メンバー別作業時間平均_画像1枚あたり_by_phase ( ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] task_query = annofabcli . common . cli . get_json_from_args ( args . task_query ) [EOL] ignored_task_id_list = ( annofabcli . common . cli . get_list_from_args ( args . ignored_task_id ) if args . ignored_task_id is not None else None ) [EOL] user_id_list = annofabcli . common . cli . get_list_from_args ( args . user_id ) if args . user_id is not None else None [EOL] [EOL] if args . work_dir is not None : [EOL] work_dir = args . work_dir [EOL] else : [EOL] work_dir = annofabcli . utils . get_cache_dir ( ) [EOL] [EOL] self . visualize_statistics ( args . project_id , output_dir = Path ( args . output_dir ) , work_dir = Path ( work_dir ) , task_query = task_query , ignored_task_id_list = ignored_task_id_list , user_id_list = user_id_list , update = not args . not_update , download_latest = args . download_latest , start_date = args . start_date , end_date = args . end_date , minimal_output = args . minimal , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] VisualizeStatistics ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , nargs = [string] , help = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , help = [string] [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , nargs = [string] , help = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $CommnadLineArgs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 $typing.Optional[pandas.DataFrame]$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Tuple , List , Any , Optional , Type , Union [EOL] import builtins [EOL] import logging [EOL] import pandas [EOL] import bokeh [EOL] import annofabcli [EOL] import typing [EOL] import logging [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] from typing import Dict , List , Optional [EOL] [EOL] import bokeh [EOL] import bokeh . layouts [EOL] import bokeh . palettes [EOL] import dateutil [EOL] import pandas [EOL] from bokeh . core . properties import Color [EOL] from bokeh . models import DataRange1d , HoverTool , LinearAxis [EOL] from bokeh . plotting import ColumnDataSource , figure [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class OutputTarget ( Enum ) : [EOL] ANNOTATION = [string] [EOL] INPUT_DATA = [string] [EOL] TASK = [string] [EOL] [EOL] [EOL] class LineGraph : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] my_palette = bokeh . palettes . Category20 [ [number] ] [EOL] my_small_palette = bokeh . palettes . Category10 [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , outdir ) : [EOL] self . line_graph_outdir = outdir [EOL] Path ( self . line_graph_outdir ) . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] @ staticmethod def _create_hover_tool ( tool_tip_items = None ) : [EOL] [docstring] [EOL] if tool_tip_items is None : [EOL] tool_tip_items = [ ] [EOL] [EOL] detail_tooltips = [ ( e , [string] % e ) for e in tool_tip_items ] [EOL] [EOL] hover_tool = HoverTool ( tooltips = [ ( [string] , [string] ) , ( [string] , [string] ) ] + detail_tooltips ) [EOL] return hover_tool [EOL] [EOL] @ staticmethod def _plot_line_and_circle ( fig , source , x_column_name , y_column_name , legend_label , color , ** kwargs , ) : [EOL] [docstring] [EOL] [EOL] fig . line ( x = x_column_name , y = y_column_name , source = source , legend_label = legend_label , line_color = color , line_width = [number] , muted_alpha = [number] , muted_color = color , ** kwargs , ) [EOL] fig . circle ( x = x_column_name , y = y_column_name , source = source , legend_label = legend_label , muted_alpha = [number] , muted_color = color , color = color , ** kwargs , ) [EOL] [EOL] @ staticmethod def _plot_moving_average ( fig , source , x_column_name , y_column_name , legend_label , color , ** kwargs , ) : [EOL] [docstring] [EOL] [EOL] fig . line ( x = x_column_name , y = y_column_name , source = source , legend_label = legend_label , line_color = color , line_width = [number] , line_dash = [string] , line_alpha = [number] , muted_alpha = [number] , muted_color = color , ** kwargs , ) [EOL] [EOL] @ staticmethod def _set_legend ( fig , hover_tool ) : [EOL] [docstring] [EOL] fig . add_tools ( hover_tool ) [EOL] fig . legend . location = [string] [EOL] fig . legend . click_policy = [string] [EOL] if len ( fig . legend ) > [number] : [EOL] legend = fig . legend [ [number] ] [EOL] fig . add_layout ( legend , [string] ) [EOL] [EOL] def create_user_id_list ( self , df , user_id_column , datetime_column , arg_user_id_list = None , ) : [EOL] [docstring] [EOL] max_user_length = len ( self . my_palette ) [EOL] tmp_user_id_list = ( df . sort_values ( by = datetime_column , ascending = False ) [ user_id_column ] . dropna ( ) . unique ( ) . tolist ( ) ) [EOL] [EOL] if arg_user_id_list is None or len ( arg_user_id_list ) == [number] : [EOL] user_id_list = tmp_user_id_list [EOL] else : [EOL] user_id_list = [ user_id for user_id in tmp_user_id_list if user_id in arg_user_id_list ] [EOL] [EOL] if len ( user_id_list ) > max_user_length : [EOL] logger . info ( f" [string] { max_user_length } [string] " ) [EOL] [EOL] return user_id_list [ [number] : max_user_length ] [EOL] [EOL] def write_productivity_line_graph_for_annotator ( self , df , first_annotation_user_id_list = None , ) : [EOL] [docstring] [EOL] [EOL] def write_cumulative_graph ( fig_info_list , html_title ) : [EOL] [docstring] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figs = [ ] [EOL] for fig_info in fig_info_list : [EOL] figs . append ( figure ( plot_width = [number] , plot_height = [number] , title = fig_info [ [string] ] , x_axis_label = fig_info [ [string] ] , x_axis_type = [string] , y_axis_label = fig_info [ [string] ] , ) ) [EOL] [EOL] for user_index , user_id in enumerate ( first_annotation_user_id_list ) : [comment] [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] if filtered_df . empty : [EOL] logger . debug ( f" [string] { user_id }" ) [EOL] continue [EOL] [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] color = self . my_palette [ user_index ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] [EOL] for fig , fig_info in zip ( figs , fig_info_list ) : [EOL] self . _plot_line_and_circle ( fig , x_column_name = fig_info [ [string] ] , y_column_name = fig_info [ [string] ] , source = source , legend_label = username , color = color , ) [EOL] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] for fig in figs : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( figs ) ) [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] first_annotation_user_id_list = self . create_user_id_list ( df , [string] , datetime_column = [string] , arg_user_id_list = first_annotation_user_id_list , ) [EOL] logger . debug ( f" [string] { first_annotation_user_id_list }" ) [EOL] [EOL] df [ [string] ] = df [ [string] ] . map ( lambda e : dateutil . parser . parse ( e ) . date ( ) ) [EOL] [EOL] fig_info_list_annotation_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_annotation_count , html_title = [string] , ) [EOL] [EOL] fig_info_list_input_data_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_input_data_count , html_title = [string] ) [EOL] [EOL] fig_info_list_value = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_value , html_title = [string] ) [EOL] [EOL] def write_cumulative_line_graph_for_annotator ( self , df , output_target_list = None , first_annotation_user_id_list = None , ) : [EOL] [docstring] [EOL] [EOL] def write_cumulative_graph ( fig_info_list , html_title ) : [EOL] [docstring] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figs = [ ] [EOL] for fig_info in fig_info_list : [EOL] figs . append ( figure ( plot_width = [number] , plot_height = [number] , title = fig_info [ [string] ] , x_axis_label = fig_info [ [string] ] , y_axis_label = fig_info [ [string] ] , ) ) [EOL] [EOL] for user_index , user_id in enumerate ( first_annotation_user_id_list ) : [comment] [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] if filtered_df . empty : [EOL] logger . debug ( f" [string] { user_id }" ) [EOL] continue [EOL] [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] color = self . my_palette [ user_index ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] [EOL] for fig , fig_info in zip ( figs , fig_info_list ) : [EOL] self . _plot_line_and_circle ( fig , x_column_name = fig_info [ [string] ] , y_column_name = fig_info [ [string] ] , source = source , legend_label = username , color = color , ) [EOL] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] for fig in figs : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( figs ) ) [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] first_annotation_user_id_list = self . create_user_id_list ( df , [string] , datetime_column = [string] , arg_user_id_list = first_annotation_user_id_list , ) [EOL] logger . debug ( f" [string] { first_annotation_user_id_list }" ) [EOL] [EOL] if output_target_list is None or OutputTarget . ANNOTATION in output_target_list : [EOL] [comment] [EOL] fig_info_list_annotation_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_annotation_count , html_title = [string] ) [EOL] [EOL] if output_target_list is None or OutputTarget . INPUT_DATA in output_target_list : [EOL] [comment] [EOL] fig_info_list_input_data_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_input_data_count , html_title = [string] ) [EOL] [EOL] if output_target_list is None or OutputTarget . TASK in output_target_list : [EOL] [comment] [EOL] fig_info_list_task_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_task_count , html_title = [string] ) [EOL] [EOL] def write_cumulative_line_graph_for_inspector ( self , df , output_target_list = None , first_inspection_user_id_list = None , ) : [EOL] [docstring] [EOL] [EOL] def write_cumulative_graph ( fig_info_list , html_title ) : [EOL] [docstring] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figs = [ ] [EOL] for fig_info in fig_info_list : [EOL] figs . append ( figure ( plot_width = [number] , plot_height = [number] , title = fig_info [ [string] ] , x_axis_label = fig_info [ [string] ] , y_axis_label = fig_info [ [string] ] , ) ) [EOL] [EOL] for user_index , user_id in enumerate ( first_inspection_user_id_list ) : [comment] [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] if filtered_df . empty : [EOL] logger . debug ( f" [string] { user_id }" ) [EOL] continue [EOL] [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] color = self . my_palette [ user_index ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] [EOL] for fig , fig_info in zip ( figs , fig_info_list ) : [EOL] self . _plot_line_and_circle ( fig , x_column_name = fig_info [ [string] ] , y_column_name = fig_info [ [string] ] , source = source , legend_label = username , color = color , ) [EOL] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] for fig in figs : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( figs ) ) [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] first_inspection_user_id_list = self . create_user_id_list ( df , [string] , datetime_column = [string] , arg_user_id_list = first_inspection_user_id_list , ) [EOL] [EOL] if len ( first_inspection_user_id_list ) == [number] : [EOL] logger . info ( f" [string] " ) [EOL] return [EOL] [EOL] logger . debug ( f" [string] { first_inspection_user_id_list }" ) [EOL] [EOL] if output_target_list is None or OutputTarget . ANNOTATION in output_target_list : [EOL] [comment] [EOL] fig_info_list_annotation_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_annotation_count , html_title = [string] ) [EOL] [EOL] if output_target_list is None or OutputTarget . INPUT_DATA in output_target_list : [EOL] [comment] [EOL] fig_info_list_input_data_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_input_data_count , html_title = [string] ) [EOL] [EOL] def write_cumulative_line_graph_for_acceptor ( self , df , output_target_list = None , first_acceptance_user_id_list = None , ) : [EOL] [docstring] [EOL] [EOL] def write_cumulative_graph ( fig_info_list , html_title ) : [EOL] [docstring] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figs = [ ] [EOL] for fig_info in fig_info_list : [EOL] figs . append ( figure ( plot_width = [number] , plot_height = [number] , title = fig_info [ [string] ] , x_axis_label = fig_info [ [string] ] , y_axis_label = fig_info [ [string] ] , ) ) [EOL] [EOL] for user_index , user_id in enumerate ( first_acceptance_user_id_list ) : [comment] [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] if filtered_df . empty : [EOL] logger . debug ( f" [string] { user_id }" ) [EOL] continue [EOL] [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] color = self . my_palette [ user_index ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] [EOL] for fig , fig_info in zip ( figs , fig_info_list ) : [EOL] self . _plot_line_and_circle ( fig , x_column_name = fig_info [ [string] ] , y_column_name = fig_info [ [string] ] , source = source , legend_label = username , color = color , ) [EOL] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] for fig in figs : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( figs ) ) [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] first_acceptance_user_id_list = self . create_user_id_list ( df , [string] , datetime_column = [string] , arg_user_id_list = first_acceptance_user_id_list , ) [EOL] [EOL] if len ( first_acceptance_user_id_list ) == [number] : [EOL] logger . info ( f" [string] " ) [EOL] return [EOL] [EOL] logger . debug ( f" [string] { first_acceptance_user_id_list }" ) [EOL] [EOL] if output_target_list is None or OutputTarget . ANNOTATION in output_target_list : [EOL] [comment] [EOL] fig_info_list_annotation_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_annotation_count , html_title = [string] ) [EOL] [EOL] if output_target_list is None or OutputTarget . INPUT_DATA in output_target_list : [EOL] [comment] [EOL] fig_info_list_input_data_count = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) , ] [EOL] write_cumulative_graph ( fig_info_list_input_data_count , html_title = [string] ) [EOL] [EOL] def write_cumulative_line_graph_by_date ( self , df , user_id_list = None ) : [EOL] [docstring] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] [EOL] user_id_list = self . create_user_id_list ( df , [string] , datetime_column = [string] , arg_user_id_list = user_id_list ) [EOL] if len ( user_id_list ) == [number] : [EOL] logger . info ( f" [string] { html_title } [string] " ) [EOL] return [EOL] [EOL] logger . debug ( f"{ html_title } [string] { user_id_list }" ) [EOL] [EOL] [comment] [EOL] df [ [string] ] = df [ [string] ] . map ( lambda e : dateutil . parser . parse ( e ) . date ( ) ) [EOL] [EOL] fig_info_list = [ dict ( x = [string] , y = [string] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) ] [EOL] [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] figs = [ ] [EOL] for fig_info in fig_info_list : [EOL] figs . append ( figure ( plot_width = [number] , plot_height = [number] , title = fig_info [ [string] ] , x_axis_label = fig_info [ [string] ] , x_axis_type = [string] , y_axis_label = fig_info [ [string] ] , ) ) [EOL] [EOL] for user_index , user_id in enumerate ( user_id_list ) : [comment] [EOL] filtered_df = df [ df [ [string] ] == user_id ] [EOL] if filtered_df . empty : [EOL] logger . debug ( f" [string] { user_id }" ) [EOL] continue [EOL] [EOL] source = ColumnDataSource ( data = filtered_df ) [EOL] color = self . my_palette [ user_index ] [EOL] username = filtered_df . iloc [ [number] ] [ [string] ] [EOL] [EOL] for fig , fig_info in zip ( figs , fig_info_list ) : [EOL] self . _plot_line_and_circle ( fig , x_column_name = fig_info [ [string] ] , y_column_name = fig_info [ [string] ] , source = source , legend_label = username , color = color , ) [EOL] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] for fig in figs : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( figs ) ) [EOL] [EOL] def write_cumulative_line_graph_overall ( self , df ) : [EOL] [docstring] [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] fig = figure ( plot_width = [number] , plot_height = [number] , title = [string] , x_axis_label = [string] , y_axis_label = [string] , ) [EOL] [EOL] fig_info_list = [ dict ( x = [string] , y = [string] , legend_label = [string] ) , dict ( x = [string] , y = [string] , legend_label = [string] ) , dict ( x = [string] , y = [string] , legend_label = [string] ) , dict ( x = [string] , y = [string] , legend_label = [string] ) , ] [EOL] [EOL] source = ColumnDataSource ( data = df ) [EOL] [EOL] for index , fig_info in enumerate ( fig_info_list ) : [EOL] color = self . my_palette [ index ] [EOL] [EOL] self . _plot_line_and_circle ( fig , x_column_name = fig_info [ [string] ] , y_column_name = fig_info [ [string] ] , source = source , legend_label = fig_info [ [string] ] , color = color , ) [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( [ fig ] ) ) [EOL] [EOL] def write_whole_productivity_line_graph ( self , df ) : [EOL] [docstring] [EOL] [EOL] def create_figure ( title , y_axis_label ) : [EOL] return figure ( plot_width = [number] , plot_height = [number] , title = title , x_axis_label = [string] , x_axis_type = [string] , y_axis_label = y_axis_label , ) [EOL] [EOL] def plot_and_moving_average ( fig , y_column_name , legend_name , source , color , ** kwargs ) : [EOL] x_column_name = [string] [EOL] [EOL] [comment] [EOL] self . _plot_line_and_circle ( fig , x_column_name = x_column_name , y_column_name = y_column_name , source = source , color = color , legend_label = legend_name , ** kwargs , ) [EOL] [EOL] [comment] [EOL] self . _plot_moving_average ( fig , x_column_name = x_column_name , y_column_name = f"{ y_column_name } [string] " , source = source , color = color , legend_label = f"{ legend_name } [string] " , ** kwargs , ) [EOL] [EOL] def create_task_figure ( ) : [EOL] y_range_name = [string] [EOL] fig_task = create_figure ( title = [string] , y_axis_label = [string] ) [EOL] fig_task . add_layout ( LinearAxis ( y_range_name = y_range_name , axis_label = [string] , ) , [string] , ) [EOL] y_overlimit = [number] [EOL] fig_task . extra_y_ranges = { y_range_name : DataRange1d ( end = df [ [string] ] . max ( ) * ( [number] + y_overlimit ) ) } [EOL] plot_and_moving_average ( fig = fig_task , y_column_name = [string] , legend_name = [string] , source = source , color = self . my_small_palette [ [number] ] , ) [EOL] plot_and_moving_average ( fig = fig_task , y_column_name = [string] , legend_name = [string] , source = source , color = self . my_small_palette [ [number] ] , y_range_name = y_range_name , ) [EOL] return fig_task [EOL] [EOL] def create_input_data_figure ( ) : [EOL] y_range_name = [string] [EOL] fig_input_data = create_figure ( title = [string] , y_axis_label = [string] ) [EOL] fig_input_data . add_layout ( LinearAxis ( y_range_name = y_range_name , axis_label = [string] , ) , [string] , ) [EOL] y_overlimit = [number] [EOL] fig_input_data . extra_y_ranges = { y_range_name : DataRange1d ( end = df [ [string] ] . max ( ) * ( [number] + y_overlimit ) ) } [EOL] plot_and_moving_average ( fig = fig_input_data , y_column_name = [string] , legend_name = [string] , source = source , color = self . my_small_palette [ [number] ] , ) [EOL] plot_and_moving_average ( fig = fig_input_data , y_column_name = [string] , legend_name = [string] , source = source , color = self . my_small_palette [ [number] ] , y_range_name = y_range_name , ) [EOL] return fig_input_data [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] df [ [string] ] = df [ [string] ] . map ( lambda e : dateutil . parser . parse ( e ) . date ( ) ) [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] fig_list = [ create_figure ( title = [string] , y_axis_label = [string] ) , create_figure ( title = [string] , y_axis_label = [string] ) , create_figure ( title = [string] , y_axis_label = [string] ) , create_figure ( title = [string] , y_axis_label = [string] ) , ] [EOL] [EOL] fig_info_list = [ { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , } , { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , } , { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , } , { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , } , ] [EOL] [EOL] MOVING_WINDOW_SIZE = [number] [EOL] for column in [ [string] , [string] , [string] , [string] ] : [EOL] df [ f"{ column } [string] " ] = df [ column ] . rolling ( MOVING_WINDOW_SIZE ) . mean ( ) [EOL] [EOL] source = ColumnDataSource ( data = df ) [EOL] [EOL] for fig , fig_info in zip ( fig_list , fig_info_list ) : [EOL] y_info_list = fig_info [ [string] ] [comment] [EOL] for index , y_info in enumerate ( y_info_list ) : [EOL] color = self . my_small_palette [ index ] [EOL] [EOL] plot_and_moving_average ( fig = fig , y_column_name = y_info [ [string] ] , legend_name = y_info [ [string] ] , source = source , color = color ) [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] [EOL] fig_list . insert ( [number] , create_task_figure ( ) ) [EOL] fig_list . insert ( [number] , create_input_data_figure ( ) ) [EOL] [EOL] for fig in fig_list : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( fig_list ) ) [EOL] [EOL] def write_whole_cumulative_line_graph ( self , df ) : [EOL] [docstring] [EOL] [EOL] def create_figure ( title , y_axis_label ) : [EOL] return figure ( plot_width = [number] , plot_height = [number] , title = title , x_axis_label = [string] , x_axis_type = [string] , y_axis_label = y_axis_label , ) [EOL] [EOL] def create_task_figure ( ) : [EOL] y_range_name = [string] [EOL] fig = create_figure ( title = [string] , y_axis_label = [string] ) [EOL] fig . add_layout ( LinearAxis ( y_range_name = y_range_name , axis_label = [string] , ) , [string] , ) [EOL] y_overlimit = [number] [EOL] fig . extra_y_ranges = { y_range_name : DataRange1d ( end = df [ [string] ] . max ( ) * ( [number] + y_overlimit ) ) } [EOL] [EOL] [comment] [EOL] self . _plot_line_and_circle ( fig , x_column_name = x_column_name , y_column_name = [string] , source = source , color = self . my_small_palette [ [number] ] , legend_label = [string] , ) [EOL] [EOL] [comment] [EOL] self . _plot_line_and_circle ( fig , x_column_name = x_column_name , y_column_name = [string] , source = source , color = self . my_small_palette [ [number] ] , legend_label = [string] , y_range_name = y_range_name , ) [EOL] [EOL] return fig [EOL] [EOL] def create_input_data_figure ( ) : [EOL] y_range_name = [string] [EOL] fig = create_figure ( title = [string] , y_axis_label = [string] ) [EOL] fig . add_layout ( LinearAxis ( y_range_name = y_range_name , axis_label = [string] , ) , [string] , ) [EOL] y_overlimit = [number] [EOL] fig . extra_y_ranges = { y_range_name : DataRange1d ( end = df [ [string] ] . max ( ) * ( [number] + y_overlimit ) ) } [EOL] [EOL] [comment] [EOL] self . _plot_line_and_circle ( fig , x_column_name = x_column_name , y_column_name = [string] , source = source , color = self . my_small_palette [ [number] ] , legend_label = [string] , ) [EOL] [EOL] [comment] [EOL] self . _plot_line_and_circle ( fig , x_column_name = x_column_name , y_column_name = [string] , source = source , color = self . my_small_palette [ [number] ] , legend_label = [string] , y_range_name = y_range_name , ) [EOL] [EOL] return fig [EOL] [EOL] if len ( df ) == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] df [ [string] ] = df [ [string] ] . map ( lambda e : dateutil . parser . parse ( e ) . date ( ) ) [EOL] df [ [string] ] = df [ [string] ] . cumsum ( ) [EOL] [EOL] html_title = [string] [EOL] output_file = f"{ self . line_graph_outdir } [string] { html_title } [string] " [EOL] logger . debug ( f"{ output_file } [string] " ) [EOL] [EOL] fig_list = [ create_figure ( title = [string] , y_axis_label = [string] ) , ] [EOL] [EOL] fig_info_list = [ { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , } , ] [EOL] [EOL] source = ColumnDataSource ( data = df ) [EOL] [EOL] for fig , fig_info in zip ( fig_list , fig_info_list ) : [EOL] x_column_name = [string] [EOL] y_info_list = fig_info [ [string] ] [comment] [EOL] for index , y_info in enumerate ( y_info_list ) : [EOL] color = self . my_small_palette [ index ] [EOL] [EOL] [comment] [EOL] self . _plot_line_and_circle ( fig , x_column_name = x_column_name , y_column_name = y_info [ [string] ] , source = source , color = color , legend_label = y_info [ [string] ] , ) [EOL] [EOL] tooltip_item = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] hover_tool = self . _create_hover_tool ( tooltip_item ) [EOL] [EOL] fig_list . insert ( [number] , create_task_figure ( ) ) [EOL] fig_list . insert ( [number] , create_input_data_figure ( ) ) [EOL] [EOL] for fig in fig_list : [EOL] self . _set_legend ( fig , hover_tool ) [EOL] [EOL] bokeh . plotting . reset_output ( ) [EOL] bokeh . plotting . output_file ( output_file , title = html_title ) [EOL] bokeh . plotting . save ( bokeh . layouts . column ( fig_list ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0
from typing import Counter , Dict , Tuple , List , Any , Union , Optional , Set , Type , Iterator [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import collections [EOL] import pathlib [EOL] import argparse [EOL] import collections [EOL] import logging [EOL] import zipfile [EOL] from dataclasses import dataclass [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] from typing import Any , Counter , Dict , Iterator , List , Optional , Set , Tuple [EOL] [EOL] import pandas [EOL] from annofabapi . models import AdditionalDataDefinitionType , TaskPhase , TaskStatus [EOL] from annofabapi . parser import ( SimpleAnnotationParser , SimpleAnnotationParserByTask , lazy_parse_simple_annotation_dir , lazy_parse_simple_annotation_dir_by_task , lazy_parse_simple_annotation_zip , lazy_parse_simple_annotation_zip_by_task , ) [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . visualize import AddProps , MessageLocale [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] AttributesColumn = Tuple [ str , str , str ] [EOL] [docstring] [EOL] [EOL] LabelColumnList = List [ str ] [EOL] [EOL] AttributesColumnList = List [ AttributesColumn ] [EOL] [EOL] [EOL] class GroupBy ( Enum ) : [EOL] TASK_ID = [string] [EOL] INPUT_DATA_ID = [string] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class AnnotationCounterByTask : [EOL] [docstring] [EOL] [EOL] task_id = ... [EOL] task_status = ... [EOL] task_phase = ... [EOL] task_phase_stage = ... [EOL] labels_count = ... [EOL] attirbutes_count = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class AnnotationCounterByInputData : [EOL] [docstring] [EOL] [EOL] task_id = ... [EOL] task_status = ... [EOL] task_phase = ... [EOL] task_phase_stage = ... [EOL] [EOL] input_data_id = ... [EOL] input_data_name = ... [EOL] labels_count = ... [EOL] attirbutes_count = ... [EOL] [EOL] [EOL] class ListAnnotationCount ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] CSV_FORMAT = { [string] : [string] , [string] : False } [EOL] [EOL] @ staticmethod def lazy_parse_simple_annotation_by_input_data ( annotation_path ) : [EOL] if not annotation_path . exists ( ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] if annotation_path . is_dir ( ) : [EOL] return lazy_parse_simple_annotation_dir ( annotation_path ) [EOL] elif zipfile . is_zipfile ( str ( annotation_path ) ) : [EOL] return lazy_parse_simple_annotation_zip ( annotation_path ) [EOL] else : [EOL] raise RuntimeError ( f" [string] { annotation_path } [string] " ) [EOL] [EOL] @ staticmethod def lazy_parse_simple_annotation_by_task ( annotation_path ) : [EOL] if not annotation_path . exists ( ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] if annotation_path . is_dir ( ) : [EOL] return lazy_parse_simple_annotation_dir_by_task ( annotation_path ) [EOL] elif zipfile . is_zipfile ( str ( annotation_path ) ) : [EOL] return lazy_parse_simple_annotation_zip_by_task ( annotation_path ) [EOL] else : [EOL] raise RuntimeError ( f" [string] { annotation_path } [string] " ) [EOL] [EOL] @ staticmethod def count_for_input_data ( simple_annotation , target_attributes = None ) : [EOL] [docstring] [EOL] details = simple_annotation [ [string] ] [EOL] labels_count = collections . Counter ( [ e [ [string] ] for e in details ] ) [EOL] [EOL] attributes_list = [ ] [EOL] for detail in details : [EOL] label = detail [ [string] ] [EOL] for attribute , value in detail [ [string] ] . items ( ) : [EOL] if target_attributes is not None and ( label , attribute ) in target_attributes : [EOL] attributes_list . append ( ( label , attribute , str ( value ) ) ) [EOL] [EOL] attirbutes_count = collections . Counter ( attributes_list ) [EOL] [EOL] return AnnotationCounterByInputData ( task_id = simple_annotation [ [string] ] , task_phase = TaskPhase ( simple_annotation [ [string] ] ) , task_phase_stage = simple_annotation [ [string] ] , task_status = TaskStatus ( simple_annotation [ [string] ] ) , input_data_id = simple_annotation [ [string] ] , input_data_name = simple_annotation [ [string] ] , labels_count = labels_count , attirbutes_count = attirbutes_count , ) [EOL] [EOL] @ staticmethod def count_for_task ( task_parser , target_attributes = None ) : [EOL] [docstring] [EOL] [EOL] labels_count = collections . Counter ( ) [EOL] attirbutes_count = collections . Counter ( ) [EOL] [EOL] last_simple_annotation = None [EOL] for parser in task_parser . lazy_parse ( ) : [EOL] [comment] [EOL] simple_annotation_dict = parser . load_json ( ) [EOL] input_data = ListAnnotationCount . count_for_input_data ( simple_annotation_dict , target_attributes ) [EOL] labels_count += input_data . labels_count [EOL] attirbutes_count += input_data . attirbutes_count [EOL] last_simple_annotation = simple_annotation_dict [EOL] [EOL] if last_simple_annotation is None : [EOL] raise RuntimeError ( f"{ task_parser . task_id } [string] " ) [EOL] [EOL] return AnnotationCounterByTask ( task_id = last_simple_annotation [ [string] ] , task_status = TaskStatus ( last_simple_annotation [ [string] ] ) , task_phase = TaskPhase ( last_simple_annotation [ [string] ] ) , task_phase_stage = last_simple_annotation [ [string] ] , labels_count = labels_count , attirbutes_count = attirbutes_count , ) [EOL] [EOL] def print_labels_count_for_task ( self , task_counter_list , label_columns , output_dir ) : [EOL] def to_dict ( c ) : [EOL] d = { [string] : c . task_id , [string] : c . task_status . value , [string] : c . task_phase . value , [string] : c . task_phase_stage , } [EOL] d . update ( { f" [string] { label }" : c . labels_count [ label ] for label in label_columns } ) [EOL] return d [EOL] [EOL] columns = [ [string] , [string] , [string] , [string] ] [EOL] columns . extend ( [ f" [string] { e }" for e in label_columns ] ) [EOL] [EOL] df = pandas . DataFrame ( [ to_dict ( e ) for e in task_counter_list ] , columns = columns ) [EOL] output_file = str ( output_dir / [string] ) [EOL] annofabcli . utils . print_csv ( df , output = output_file , to_csv_kwargs = self . CSV_FORMAT ) [EOL] [EOL] def print_attirbutes_count_for_task ( self , task_counter_list , attribute_columns , output_dir , ) : [EOL] def to_cell ( c ) : [EOL] cell = { ( [string] , [string] , [string] ) : c . task_id , ( [string] , [string] , [string] ) : c . task_status . value , ( [string] , [string] , [string] ) : c . task_phase . value , ( [string] , [string] , [string] ) : c . task_phase_stage , } [EOL] for col in attribute_columns : [EOL] cell . update ( { col : c . attirbutes_count [ col ] } ) [EOL] [EOL] return cell [EOL] [EOL] columns = [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] [EOL] columns . extend ( attribute_columns ) [EOL] df = pandas . DataFrame ( [ to_cell ( e ) for e in task_counter_list ] , columns = pandas . MultiIndex . from_tuples ( columns ) ) [EOL] [EOL] output_file = str ( output_dir / [string] ) [EOL] annofabcli . utils . print_csv ( df , output = output_file , to_csv_kwargs = self . CSV_FORMAT ) [EOL] [EOL] def print_labels_count_for_input_data ( self , input_data_counter_list , label_columns , output_dir ) : [EOL] def to_dict ( c ) : [EOL] d = { [string] : c . input_data_id , [string] : c . input_data_name , [string] : c . task_id , [string] : c . task_status . value , [string] : c . task_phase . value , [string] : c . task_phase_stage , } [EOL] d . update ( { f" [string] { label }" : c . labels_count [ label ] for label in label_columns } ) [EOL] return d [EOL] [EOL] columns = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] columns . extend ( [ f" [string] { e }" for e in label_columns ] ) [EOL] [EOL] df = pandas . DataFrame ( [ to_dict ( e ) for e in input_data_counter_list ] ) [EOL] output_file = str ( output_dir / [string] ) [EOL] annofabcli . utils . print_csv ( df , output = output_file , to_csv_kwargs = self . CSV_FORMAT ) [EOL] [EOL] def print_attirbutes_count_for_input_data ( self , input_data_counter_list , attribute_columns , output_dir , ) : [EOL] def to_cell ( c ) : [EOL] cell = { ( [string] , [string] , [string] ) : c . input_data_id , ( [string] , [string] , [string] ) : c . input_data_name , ( [string] , [string] , [string] ) : c . task_id , ( [string] , [string] , [string] ) : c . task_status . value , ( [string] , [string] , [string] ) : c . task_phase . value , ( [string] , [string] , [string] ) : c . task_phase_stage , } [EOL] for col in attribute_columns : [EOL] cell . update ( { col : c . attirbutes_count [ col ] } ) [EOL] [EOL] return cell [EOL] [EOL] columns = [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] [EOL] columns . extend ( attribute_columns ) [EOL] df = pandas . DataFrame ( [ to_cell ( e ) for e in input_data_counter_list ] , columns = pandas . MultiIndex . from_tuples ( columns ) ) [EOL] [EOL] output_file = str ( output_dir / [string] ) [EOL] annofabcli . utils . print_csv ( df , output = output_file , to_csv_kwargs = self . CSV_FORMAT ) [EOL] [EOL] @ staticmethod def get_target_attributes_columns ( annotation_specs_labels ) : [EOL] [docstring] [EOL] [EOL] target_attributes_columns = [ ] [EOL] for label in annotation_specs_labels : [EOL] label_name_en = AddProps . get_message ( label [ [string] ] , MessageLocale . EN ) [EOL] label_name_en = label_name_en if label_name_en is not None else [string] [EOL] [EOL] for attribute in label [ [string] ] : [EOL] attribute_name_en = AddProps . get_message ( attribute [ [string] ] , MessageLocale . EN ) [EOL] attribute_name_en = attribute_name_en if attribute_name_en is not None else [string] [EOL] [EOL] if AdditionalDataDefinitionType ( attribute [ [string] ] ) in [ AdditionalDataDefinitionType . CHOICE , AdditionalDataDefinitionType . SELECT , ] : [EOL] for choice in attribute [ [string] ] : [EOL] choice_name_en = AddProps . get_message ( choice [ [string] ] , MessageLocale . EN ) [EOL] choice_name_en = choice_name_en if choice_name_en is not None else [string] [EOL] target_attributes_columns . append ( ( label_name_en , attribute_name_en , choice_name_en ) ) [EOL] [EOL] elif AdditionalDataDefinitionType ( attribute [ [string] ] ) == AdditionalDataDefinitionType . FLAG : [EOL] target_attributes_columns . append ( ( label_name_en , attribute_name_en , [string] ) ) [EOL] target_attributes_columns . append ( ( label_name_en , attribute_name_en , [string] ) ) [EOL] [EOL] else : [EOL] continue [EOL] [EOL] return target_attributes_columns [EOL] [EOL] @ staticmethod def get_target_label_columns ( annotation_specs_labels ) : [EOL] [docstring] [EOL] [EOL] def to_label_name ( label ) : [EOL] label_name_en = AddProps . get_message ( label [ [string] ] , MessageLocale . EN ) [EOL] label_name_en = label_name_en if label_name_en is not None else [string] [EOL] return label_name_en [EOL] [EOL] return [ to_label_name ( label ) for label in annotation_specs_labels ] [EOL] [EOL] def get_target_columns ( self , project_id ) : [EOL] annotation_specs , _ = self . service . api . get_annotation_specs ( project_id ) [EOL] annotation_specs_labels = annotation_specs [ [string] ] [EOL] label_columns = self . get_target_label_columns ( annotation_specs_labels ) [EOL] attributes_columns = self . get_target_attributes_columns ( annotation_specs_labels ) [EOL] return ( label_columns , attributes_columns ) [EOL] [EOL] def list_annotation_count_by_task ( self , project_id , annotation_path , output_dir ) : [EOL] task_counter_list = [ ] [EOL] iter_task_parser = self . lazy_parse_simple_annotation_by_task ( annotation_path ) [EOL] target_label_columns , target_attributes_columns = self . get_target_columns ( project_id ) [EOL] [EOL] target_attributes = { ( e [ [number] ] , e [ [number] ] ) for e in target_attributes_columns } [EOL] logger . info ( f" [string] " ) [EOL] for task_index , task_parser in enumerate ( iter_task_parser ) : [EOL] task_index += [number] [EOL] if task_index % [number] == [number] : [EOL] logger . debug ( f"{ task_index } [string] " ) [EOL] [EOL] task_counter = self . count_for_task ( task_parser , target_attributes = target_attributes ) [EOL] task_counter_list . append ( task_counter ) [EOL] [EOL] self . print_labels_count_for_task ( task_counter_list , label_columns = target_label_columns , output_dir = output_dir ) [EOL] [EOL] self . print_attirbutes_count_for_task ( task_counter_list , output_dir = output_dir , attribute_columns = target_attributes_columns , ) [EOL] [EOL] def list_annotation_count_by_input_data ( self , project_id , annotation_path , output_dir ) : [EOL] input_data_counter_list = [ ] [EOL] iter_parser = self . lazy_parse_simple_annotation_by_input_data ( annotation_path ) [EOL] target_label_columns , target_attributes_columns = self . get_target_columns ( project_id ) [EOL] [EOL] target_attributes = { ( e [ [number] ] , e [ [number] ] ) for e in target_attributes_columns } [EOL] logger . info ( f" [string] " ) [EOL] for index , parser in enumerate ( iter_parser ) : [EOL] if index % [number] == [number] : [EOL] logger . debug ( f"{ index } [string] " ) [EOL] [EOL] simple_annotation_dict = parser . load_json ( ) [EOL] input_data_counter = self . count_for_input_data ( simple_annotation_dict , target_attributes = target_attributes ) [EOL] input_data_counter_list . append ( input_data_counter ) [EOL] [EOL] self . print_labels_count_for_input_data ( input_data_counter_list , label_columns = target_label_columns , output_dir = output_dir ) [EOL] [EOL] self . print_attirbutes_count_for_input_data ( input_data_counter_list , output_dir = output_dir , attribute_columns = target_attributes_columns , ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] if args . annotation is not None : [EOL] annotation_path = Path ( args . annotation ) [EOL] else : [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] annotation_path = cache_dir / f" [string] { project_id } [string] " [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] downloading_obj . download_annotation_zip ( project_id , dest_path = str ( annotation_path ) , is_latest = args . latest , wait_options = wait_options , ) [EOL] [EOL] group_by = GroupBy ( args . group_by ) [EOL] if group_by == GroupBy . TASK_ID : [EOL] self . list_annotation_count_by_task ( project_id , annotation_path = annotation_path , output_dir = Path ( args . output_dir ) ) [EOL] elif group_by == GroupBy . INPUT_DATA_ID : [EOL] self . list_annotation_count_by_input_data ( project_id , annotation_path = annotation_path , output_dir = Path ( args . output_dir ) ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = [ GroupBy . TASK_ID . value , GroupBy . INPUT_DATA_ID . value ] , default = GroupBy . TASK_ID . value , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListAnnotationCount ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $annofabapi.models.TaskStatus$ 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 $builtins.int$ 0 0 0 $typing.Counter[builtins.str]$ 0 0 0 $typing.Counter[AttributesColumn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $annofabapi.models.TaskStatus$ 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Counter[builtins.str]$ 0 0 0 $typing.Counter[AttributesColumn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Tuple[LabelColumnList,AttributesColumnList]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Set[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.statistics.list_annotation_count.AnnotationCounterByTask$ 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.str,builtins.str]]$ 0 $typing.Set[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $annofabcli.statistics.list_annotation_count.AnnotationCounterByTask$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Set[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $annofabcli.statistics.list_annotation_count.AnnotationCounterByInputData$ 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Tuple[builtins.str,builtins.str]]$ 0 $typing.Set[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $annofabcli.statistics.list_annotation_count.AnnotationCounterByInputData$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 $annofabcli.statistics.list_annotation_count.GroupBy$ 0 0 0 $argparse.Namespace$ 0 $annofabcli.statistics.list_annotation_count.GroupBy$ 0 0 0 $annofabcli.statistics.list_annotation_count.GroupBy$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabcli.statistics.list_annotation_count.GroupBy$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TaskProgress ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def get_task_statistics ( self , project_id ) : [EOL] [docstring] [EOL] task_statistics = self . service . wrapper . get_task_statistics ( project_id ) [EOL] row_list = [ ] [EOL] for stat_by_date in task_statistics : [EOL] date = stat_by_date [ [string] ] [EOL] task_stat_list = stat_by_date [ [string] ] [EOL] for task_stat in task_stat_list : [EOL] task_stat [ [string] ] = date [EOL] row_list . extend ( task_stat_list ) [EOL] return row_list [EOL] [EOL] def list_task_progress ( self , project_id ) : [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] task_stat_list = self . get_task_statistics ( project_id ) [EOL] if len ( task_stat_list ) == [number] : [EOL] logger . info ( f" [string] " ) [EOL] return [EOL] [EOL] df = pandas . DataFrame ( task_stat_list ) [EOL] [comment] [EOL] target_df = df [ [ [string] , [string] , [string] , [string] ] ] [EOL] [EOL] annofabcli . utils . print_csv ( target_df , output = self . output , to_csv_kwargs = self . csv_format ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] project_id = args . project_id [EOL] self . list_task_progress ( project_id ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] TaskProgress ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import logging [EOL] import zipfile [EOL] from pathlib import Path [EOL] from typing import List , Optional [EOL] [EOL] from annofabapi . models import TaskStatus [EOL] from annofabapi . parser import SimpleAnnotationParser [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli . common . cli import ArgumentParser [EOL] from annofabcli . common . image import IsParserFunc , write_annotation_images_from_path [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] zipfile . is_zipfile ( [string] ) [EOL] [EOL] [EOL] class WriteAnnotationImage : [EOL] @ staticmethod def create_is_target_parser_func ( task_status_complete = False , task_id_list = None ) : [EOL] def is_target_parser ( parser ) : [EOL] simple_annotation = parser . parse ( ) [EOL] if task_status_complete : [EOL] if simple_annotation . task_status != TaskStatus . COMPLETE : [EOL] logger . debug ( f" [string] { simple_annotation . task_status . value } [string] " f"{ simple_annotation . task_id } [string] { simple_annotation . input_data_name } [string] " ) [EOL] return False [EOL] [EOL] if task_id_list is not None and len ( task_id_list ) > [number] : [EOL] if simple_annotation . task_id not in task_id_list : [EOL] logger . debug ( f" [string] { simple_annotation . task_id } [string] { simple_annotation . input_data_name } [string] " ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] return is_target_parser [EOL] [EOL] def main ( self , args ) : [EOL] logger . info ( f" [string] { args }" ) [EOL] [EOL] image_size = annofabcli . common . cli . get_input_data_size ( args . image_size ) [EOL] if image_size is None : [EOL] logger . error ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] label_color_dict = annofabcli . common . cli . get_json_from_args ( args . label_color ) [EOL] label_color_dict = { k : tuple ( v ) for k , v in label_color_dict . items ( ) } [EOL] [EOL] annotation_path = Path ( args . annotation ) [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] is_target_parser_func = self . create_is_target_parser_func ( args . task_status_complete , task_id_list ) [EOL] [EOL] [comment] [EOL] result = write_annotation_images_from_path ( annotation_path , image_size = image_size , label_color_dict = label_color_dict , output_dir_path = Path ( args . output_dir ) , output_image_extension = args . image_extension , background_color = args . background_color , is_target_parser_func = is_target_parser_func , ) [EOL] if not result : [EOL] logger . error ( f" [string] { annotation_path } [string] " ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] WriteAnnotationImage ( ) . main ( args ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = ( [string] [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] argument_parser . add_task_id ( required = False , help_message = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] [EOL] subcommand_help = [string] [EOL] [EOL] description = [string] + [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.image.IsParserFunc$ 0 $builtins.bool$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 $builtins.bool$ 0 $annofabapi.parser.SimpleAnnotationParser$ 0 0 0 $typing.Any$ 0 $annofabapi.parser.SimpleAnnotationParser$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $pathlib.Path$ 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 $typing.Dict[typing.Any,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . filesystem . write_annotation_image [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( ) [EOL] [EOL] [comment] [EOL] annofabcli . filesystem . write_annotation_image . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from enum import Enum [EOL] [EOL] [EOL] class FormatArgument ( Enum ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] CSV = [string] [EOL] [EOL] [comment] [EOL] MINIMAL_CSV = [string] [EOL] [EOL] [comment] [EOL] JSON = [string] [EOL] [EOL] [comment] [EOL] PRETTY_JSON = [string] [EOL] [EOL] [comment] [EOL] INPUT_DATA_ID_LIST = [string] [EOL] [EOL] [comment] [EOL] TASK_ID_LIST = [string] [EOL] [EOL] [comment] [EOL] INSPECTION_ID_LIST = [string] [EOL] [EOL] [comment] [EOL] USER_ID_LIST = [string] [EOL] [EOL] [comment] [EOL] PROJECT_ID_LIST = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Tuple , List , Callable , Any , Optional , Literal , Type [EOL] import builtins [EOL] import logging [EOL] import PIL [EOL] import annofabcli [EOL] import typing_extensions [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] import logging [EOL] import zipfile [EOL] from pathlib import Path [EOL] from typing import Any , Callable , Dict , Optional [EOL] [EOL] import PIL [EOL] import PIL . Image [EOL] import PIL . ImageDraw [EOL] from annofabapi . dataclass . annotation import SimpleAnnotationDetail [EOL] from annofabapi . exceptions import AnnotationOuterFileNotFoundError [EOL] from annofabapi . parser import SimpleAnnotationParser , lazy_parse_simple_annotation_dir , lazy_parse_simple_annotation_zip [EOL] [EOL] from annofabcli . common . typing import RGB , InputDataSize [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] IsParserFunc = Callable [ [ SimpleAnnotationParser ] , bool ] [EOL] [docstring] [EOL] [EOL] [EOL] def get_data_uri_of_outer_file ( annotation ) : [EOL] [docstring] [EOL] data = annotation . data [EOL] if data is None : [EOL] return None [EOL] [EOL] return data . get ( [string] ) [EOL] [EOL] [EOL] def fill_annotation ( draw , annotation , label_color_dict , outer_image = None , ) : [EOL] [docstring] [EOL] [EOL] data = annotation . data [EOL] if data is None : [EOL] [comment] [EOL] return draw [EOL] [EOL] color = label_color_dict . get ( annotation . label ) [EOL] if color is None : [EOL] logger . warning ( f" [string] { annotation . label } [string] " ) [EOL] color = ( [number] , [number] , [number] ) [EOL] [EOL] data_type = data [ [string] ] [EOL] if data_type == [string] : [EOL] xy = [ ( data [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] ) , ( data [ [string] ] [ [string] ] , data [ [string] ] [ [string] ] ) ] [EOL] draw . rectangle ( xy , fill = color ) [EOL] [EOL] elif data_type == [string] : [EOL] [comment] [EOL] xy = [ ( e [ [string] ] , e [ [string] ] ) for e in data [ [string] ] ] [EOL] draw . polygon ( xy , fill = color ) [EOL] [EOL] elif data_type in [ [string] , [string] ] : [EOL] [comment] [EOL] if outer_image is not None : [EOL] draw . bitmap ( [ [number] , [number] ] , outer_image , fill = color ) [EOL] else : [EOL] logger . warning ( f" [string] { data_type } [string] " f" [string] { annotation . annotation_id }" ) [EOL] [EOL] return draw [EOL] [EOL] [EOL] def fill_annotation_list ( draw , parser , label_color_dict ) : [EOL] [docstring] [EOL] simple_annotation = parser . parse ( ) [EOL] [EOL] for annotation in reversed ( simple_annotation . details ) : [EOL] [comment] [EOL] data_uri_outer_image = get_data_uri_of_outer_file ( annotation ) [EOL] if data_uri_outer_image is not None : [EOL] try : [EOL] with parser . open_outer_file ( data_uri_outer_image ) as f : [EOL] outer_image = PIL . Image . open ( f ) [EOL] [comment] [EOL] fill_annotation ( draw = draw , annotation = annotation , label_color_dict = label_color_dict , outer_image = outer_image ) [EOL] [EOL] except AnnotationOuterFileNotFoundError as e : [EOL] logger . warning ( str ( e ) ) [EOL] fill_annotation ( draw = draw , annotation = annotation , label_color_dict = label_color_dict , outer_image = None ) [EOL] [EOL] else : [EOL] fill_annotation ( draw = draw , annotation = annotation , label_color_dict = label_color_dict , outer_image = None ) [EOL] [EOL] return draw [EOL] [EOL] [EOL] def write_annotation_image ( parser , image_size , label_color_dict , output_image_file , background_color = None , ) : [EOL] [docstring] [EOL] [EOL] image = PIL . Image . new ( mode = [string] , size = image_size , color = background_color ) [EOL] draw = PIL . ImageDraw . Draw ( image ) [EOL] [EOL] fill_annotation_list ( draw , parser , label_color_dict ) [EOL] [EOL] output_image_file . parent . mkdir ( parents = True , exist_ok = True ) [EOL] image . save ( output_image_file ) [EOL] [EOL] [EOL] def write_annotation_images_from_path ( annotation_path , image_size , label_color_dict , output_dir_path , output_image_extension = [string] , background_color = None , is_target_parser_func = None , ) : [EOL] [docstring] [EOL] [EOL] if not annotation_path . exists ( ) : [EOL] logger . warning ( f" [string] { annotation_path } [string] " ) [EOL] return False [EOL] [EOL] if annotation_path . is_dir ( ) : [EOL] iter_lazy_parser = lazy_parse_simple_annotation_dir ( annotation_path ) [EOL] elif zipfile . is_zipfile ( str ( annotation_path ) ) : [EOL] iter_lazy_parser = lazy_parse_simple_annotation_zip ( annotation_path ) [EOL] else : [EOL] logger . warning ( f" [string] { annotation_path } [string] " ) [EOL] return False [EOL] [EOL] count_created_image = [number] [EOL] for parser in iter_lazy_parser : [EOL] logger . debug ( f"{ parser . json_file_path } [string] " ) [EOL] if is_target_parser_func is not None and not is_target_parser_func ( parser ) : [EOL] logger . debug ( f"{ parser . json_file_path } [string] " ) [EOL] continue [EOL] [EOL] output_image_file = output_dir_path / f"{ Path ( parser . json_file_path ) . stem } [string] { output_image_extension }" [EOL] write_annotation_image ( parser , image_size = image_size , label_color_dict = label_color_dict , background_color = background_color , output_image_file = output_image_file , ) [EOL] logger . debug ( f" [string] { str ( output_image_file ) } [string] " ) [EOL] count_created_image += [number] [EOL] [EOL] logger . info ( f"{ str ( output_dir_path ) } [string] { count_created_image } [string] " ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PIL.ImageDraw.Draw$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PIL.ImageDraw.Draw$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dataclasses import dataclass [EOL] from typing import Any , Dict [EOL] [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class WaitOptions : [EOL] [docstring] [EOL] [EOL] interval = ... [EOL] [docstring] [EOL] [EOL] max_tries = ... [EOL] [docstring] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class SimpleAnnotationDetail4Import : [EOL] [docstring] [EOL] [EOL] label = ... [EOL] [docstring] [EOL] [EOL] data = ... [EOL] [docstring] [EOL] [EOL] attributes = ... [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import annofabapi [EOL] import typing [EOL] [docstring] [EOL] [EOL] import enum [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import more_itertools [EOL] from annofabapi . models import ( AnnotationSpecsHistory , InputData , Inspection , OrganizationMember , Task , TaskHistory , TaskPhase , ) [EOL] from annofabapi . utils import get_number_of_rejections [EOL] [EOL] from annofabcli . common . utils import isoduration_to_hour [EOL] [EOL] [EOL] class MessageLocale ( enum . Enum ) : [EOL] EN = [string] [EOL] JA = [string] [EOL] [EOL] [EOL] class AddProps : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] _organization_members = None [EOL] [EOL] def __init__ ( self , service , project_id ) : [EOL] self . service = service [EOL] self . project_id = project_id [EOL] self . organization_name = self . _get_organization_name_from_project_id ( project_id ) [EOL] [EOL] annotation_specs , _ = self . service . api . get_annotation_specs ( project_id ) [EOL] self . specs_labels = annotation_specs [ [string] ] [EOL] self . specs_inspection_phrases = annotation_specs [ [string] ] [EOL] [EOL] @ staticmethod def millisecond_to_hour ( millisecond ) : [EOL] return millisecond / [number] / [number] [EOL] [EOL] @ staticmethod def get_message ( i18n_messages , locale ) : [EOL] messages = i18n_messages [ [string] ] [EOL] dict_message = more_itertools . first_true ( messages , pred = lambda e : e [ [string] ] == locale . value ) [EOL] if dict_message is not None : [EOL] return dict_message [ [string] ] [EOL] else : [EOL] return None [EOL] [EOL] @ staticmethod def add_properties_of_project ( target , project_title ) : [EOL] target [ [string] ] = project_title [EOL] return target [EOL] [EOL] def _add_user_info ( self , target ) : [EOL] user_id = None [EOL] username = None [EOL] [EOL] account_id = target [ [string] ] [EOL] if account_id is not None : [EOL] member = self . get_organization_member_from_account_id ( account_id ) [EOL] if member is not None : [EOL] user_id = member [ [string] ] [EOL] username = member [ [string] ] [EOL] [EOL] target [ [string] ] = user_id [EOL] target [ [string] ] = username [EOL] return target [EOL] [EOL] def get_organization_member_from_account_id ( self , account_id ) : [EOL] [docstring] [EOL] [EOL] def update_organization_members ( ) : [EOL] self . _organization_members = self . service . wrapper . get_all_organization_members ( self . organization_name ) [EOL] [EOL] def get_member ( ) : [EOL] member = more_itertools . first_true ( self . _organization_members , pred = lambda e : e [ [string] ] == account_id ) [EOL] return member [EOL] [EOL] if self . _organization_members is not None : [EOL] member = get_member ( ) [EOL] if member is not None : [EOL] return member [EOL] [EOL] else : [EOL] update_organization_members ( ) [EOL] return get_member ( ) [EOL] [EOL] else : [EOL] update_organization_members ( ) [EOL] return get_member ( ) [EOL] [EOL] def _get_organization_name_from_project_id ( self , project_id ) : [EOL] [docstring] [EOL] organization , _ = self . service . api . get_organization_of_project ( project_id ) [EOL] return organization [ [string] ] [EOL] [EOL] def get_phrase_name ( self , phrase_id , locale ) : [EOL] phrase = more_itertools . first_true ( self . specs_inspection_phrases , pred = lambda e : e [ [string] ] == phrase_id ) [EOL] if phrase is None : [EOL] return None [EOL] [EOL] return self . get_message ( phrase [ [string] ] , locale ) [EOL] [EOL] def get_label_name ( self , label_id , locale ) : [EOL] label = more_itertools . first_true ( self . specs_labels , pred = lambda e : e [ [string] ] == label_id ) [EOL] if label is None : [EOL] return None [EOL] [EOL] return self . get_message ( label [ [string] ] , locale ) [EOL] [EOL] def get_additional_data_name ( self , additional_data_definition_id , locale , label_id = None ) : [EOL] def _get_additional_data_name ( arg_additional_data_definitions ) : [EOL] additional_data = more_itertools . first_true ( arg_additional_data_definitions , pred = lambda e : e [ [string] ] == additional_data_definition_id , ) [EOL] if additional_data is None : [EOL] return None [EOL] return self . get_message ( additional_data [ [string] ] , locale ) [EOL] [EOL] if label_id is not None : [EOL] label = more_itertools . first_true ( self . specs_labels , pred = lambda e : e [ [string] ] == label_id ) [EOL] if label is None : [EOL] return None [EOL] else : [EOL] return _get_additional_data_name ( label [ [string] ] ) [EOL] else : [EOL] for label in self . specs_labels : [EOL] additional_data_name = _get_additional_data_name ( label [ [string] ] ) [EOL] if additional_data_name is not None : [EOL] return additional_data_name [EOL] [EOL] return None [EOL] [EOL] def add_properties_to_annotation_specs_history ( self , annotation_specs_history ) : [EOL] [docstring] [EOL] return self . _add_user_info ( annotation_specs_history ) [EOL] [EOL] def add_properties_to_inspection ( self , inspection , detail = None ) : [EOL] [docstring] [EOL] [EOL] def add_commenter_info ( ) : [EOL] commenter_user_id = None [EOL] commenter_username = None [EOL] [EOL] commenter_account_id = inspection [ [string] ] [EOL] if commenter_account_id is not None : [EOL] member = self . get_organization_member_from_account_id ( commenter_account_id ) [EOL] if member is not None : [EOL] commenter_user_id = member [ [string] ] [EOL] commenter_username = member [ [string] ] [EOL] [EOL] inspection [ [string] ] = commenter_user_id [EOL] inspection [ [string] ] = commenter_username [EOL] [EOL] add_commenter_info ( ) [EOL] inspection [ [string] ] = [ self . get_phrase_name ( e , MessageLocale . EN ) for e in inspection [ [string] ] ] [EOL] inspection [ [string] ] = [ self . get_phrase_name ( e , MessageLocale . JA ) for e in inspection [ [string] ] ] [EOL] [EOL] inspection [ [string] ] = self . get_label_name ( inspection [ [string] ] , MessageLocale . EN ) [EOL] inspection [ [string] ] = self . get_label_name ( inspection [ [string] ] , MessageLocale . JA ) [EOL] [EOL] if detail is not None : [EOL] inspection . update ( detail ) [EOL] [EOL] return inspection [EOL] [EOL] def add_properties_to_task ( self , task ) : [EOL] [docstring] [EOL] [EOL] self . _add_user_info ( task ) [EOL] task [ [string] ] = self . millisecond_to_hour ( task [ [string] ] ) [EOL] [EOL] histories = [ self . _add_user_info ( e ) for e in task [ [string] ] ] [EOL] task [ [string] ] = histories [EOL] [EOL] task [ [string] ] = get_number_of_rejections ( histories , TaskPhase . INSPECTION ) [EOL] task [ [string] ] = get_number_of_rejections ( histories , TaskPhase . ACCEPTANCE ) [EOL] [EOL] [comment] [EOL] task . pop ( [string] , None ) [EOL] return task [EOL] [EOL] def add_properties_to_task_history ( self , task_history ) : [EOL] [docstring] [EOL] [EOL] self . _add_user_info ( task_history ) [EOL] task_history [ [string] ] = isoduration_to_hour ( task_history [ [string] ] ) [EOL] return task_history [EOL] [EOL] @ staticmethod def add_properties_to_input_data ( input_data , task_id_list ) : [EOL] [docstring] [EOL] input_data [ [string] ] = task_id_list [EOL] return input_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[annofabapi.models.OrganizationMember]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $MessageLocale$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $MessageLocale$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Optional[annofabapi.models.OrganizationMember]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $MessageLocale$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $MessageLocale$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $MessageLocale$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $MessageLocale$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $MessageLocale$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $annofabapi.models.AnnotationSpecsHistory$ 0 0 0 $annofabapi.models.AnnotationSpecsHistory$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.AnnotationSpecsHistory$ 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 $annofabapi.models.Inspection$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 $annofabapi.models.Task$ 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 $annofabapi.models.Task.History$ 0 0 0 $annofabapi.models.Task.History$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task.History$ 0 0 $annofabapi.models.Task.History$ 0 0 0 0 0 0 $annofabapi.models.Task.History$ 0 0 0 0 0 0 $annofabapi.models.Task.History$ 0 0 0 0 0 $annofabapi.models.InputData$ 0 $annofabapi.models.InputData$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $annofabapi.models.InputData$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $annofabapi.models.InputData$ 0
from typing import Optional , List [EOL] import annofabapi [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List , Optional [EOL] [EOL] from annofabapi . models import OrganizationMemberRole , ProjectMemberRole [EOL] [EOL] [EOL] class AnnofabCliException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationError ( AnnofabCliException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , loing_user_id ) : [EOL] msg = f" [string] { loing_user_id }" [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class UpdatedFileForDownloadingError ( AnnofabCliException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg = None ) : [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class DownloadingFileNotFoundError ( AnnofabCliException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg = None ) : [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class AuthorizationError ( AnnofabCliException ) : [EOL] pass [EOL] [EOL] [EOL] class ProjectAuthorizationError ( AuthorizationError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , project_title , roles ) : [EOL] role_values = [ e . value for e in roles ] [EOL] msg = f" [string] { project_title } [string] { role_values } [string] " [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class OrganizationAuthorizationError ( AuthorizationError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , organization_name , roles ) : [EOL] role_values = [ e . value for e in roles ] [EOL] msg = f" [string] { organization_name } [string] { role_values } [string] " [EOL] super ( ) . __init__ ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
	0
import builtins [EOL] from typing import Type , Tuple , List [EOL] import typing [EOL] from typing import List , Tuple [EOL] [EOL] [comment] [EOL] RGB = Tuple [ int , int , int ] [EOL] [docstring] [EOL] [EOL] InputDataSize = Tuple [ int , int ] [EOL] [docstring] [EOL] [EOL] SubInputDataList = List [ Tuple [ str , str ] ] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.List[typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import asyncio [EOL] import functools [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import asyncio [EOL] import logging . config [EOL] from functools import partial [EOL] from typing import Optional [EOL] [EOL] import annofabapi [EOL] import requests [EOL] from annofabapi . models import JobType [EOL] [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . exceptions import DownloadingFileNotFoundError , UpdatedFileForDownloadingError [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DOWNLOADING_FILETYPE_DICT = { JobType . GEN_TASKS_LIST : [string] , JobType . GEN_INPUTS_LIST : [string] , JobType . GEN_ANNOTATION : [string] , } [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] class DownloadingFile : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] [EOL] @ staticmethod def get_max_wait_minutes ( wait_options ) : [EOL] return wait_options . max_tries * wait_options . interval / [number] [EOL] [EOL] def _wait_for_completion ( self , project_id , job_type , wait_options = None , job_id = None , ) : [EOL] if wait_options is None : [EOL] wait_options = DEFAULT_WAIT_OPTIONS [EOL] [EOL] max_wait_minutues = self . get_max_wait_minutes ( wait_options ) [EOL] filetype = DOWNLOADING_FILETYPE_DICT [ job_type ] [EOL] logger . info ( f"{ filetype } [string] { max_wait_minutues } [string] { job_id }" ) [EOL] result = self . service . wrapper . wait_for_completion ( project_id , job_type = job_type , job_access_interval = wait_options . interval , max_job_access = wait_options . max_tries , ) [EOL] if not result : [EOL] raise UpdatedFileForDownloadingError ( f"{ filetype } [string] { max_wait_minutues } [string] " ) [EOL] [EOL] async def download_annotation_zip_with_async ( self , project_id , dest_path , is_latest = False , wait_options = None ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] partial_func = partial ( self . download_annotation_zip , project_id , dest_path , is_latest , wait_options ) [EOL] result = await loop . run_in_executor ( None , partial_func ) [EOL] return result [EOL] [EOL] def download_annotation_zip ( self , project_id , dest_path , is_latest = False , wait_options = None ) : [EOL] logger . debug ( f" [string] { dest_path }" ) [EOL] if is_latest : [EOL] self . wait_until_updated_annotation_zip ( project_id , wait_options ) [EOL] self . service . wrapper . download_annotation_archive ( project_id , dest_path , v2 = True ) [EOL] [EOL] else : [EOL] try : [EOL] self . service . wrapper . download_annotation_archive ( project_id , dest_path , v2 = True ) [EOL] except requests . HTTPError as e : [EOL] if e . response . status_code == requests . codes . not_found : [EOL] logger . info ( f" [string] " ) [EOL] self . wait_until_updated_annotation_zip ( project_id , wait_options ) [EOL] self . service . wrapper . download_annotation_archive ( project_id , dest_path , v2 = True ) [EOL] else : [EOL] raise e [EOL] [EOL] def wait_until_updated_annotation_zip ( self , project_id , wait_options = None ) : [EOL] job_id = None [EOL] try : [EOL] job = self . service . api . post_annotation_archive_update ( project_id , query_params = { [string] : [string] } ) [ [number] ] [ [string] ] [EOL] job_id = job [ [string] ] [EOL] except requests . HTTPError as e : [EOL] [comment] [EOL] if e . response . status_code == requests . codes . conflict : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] raise e [EOL] [EOL] self . _wait_for_completion ( project_id , job_type = JobType . GEN_ANNOTATION , wait_options = wait_options , job_id = job_id ) [EOL] [EOL] async def download_input_data_json_with_async ( self , project_id , dest_path , is_latest = False , wait_options = None ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] partial_func = partial ( self . download_input_data_json , project_id , dest_path , is_latest , wait_options ) [EOL] result = await loop . run_in_executor ( None , partial_func ) [EOL] return result [EOL] [EOL] def download_input_data_json ( self , project_id , dest_path , is_latest = False , wait_options = None ) : [EOL] logger . debug ( f" [string] { dest_path }" ) [EOL] if is_latest : [EOL] self . wait_until_updated_input_data_json ( project_id , wait_options ) [EOL] self . service . wrapper . download_project_inputs_url ( project_id , dest_path ) [EOL] [EOL] else : [EOL] try : [EOL] self . service . wrapper . download_project_inputs_url ( project_id , dest_path ) [EOL] except requests . HTTPError as e : [EOL] if e . response . status_code == requests . codes . not_found : [EOL] logger . info ( f" [string] " ) [EOL] self . wait_until_updated_input_data_json ( project_id , wait_options ) [EOL] self . service . wrapper . download_project_inputs_url ( project_id , dest_path ) [EOL] else : [EOL] raise e [EOL] [EOL] def wait_until_updated_input_data_json ( self , project_id , wait_options = None ) : [EOL] job_id = None [EOL] try : [EOL] job = self . service . api . post_project_inputs_update ( project_id ) [ [number] ] [ [string] ] [EOL] job_id = job [ [string] ] [EOL] except requests . HTTPError as e : [EOL] [comment] [EOL] if e . response . status_code == requests . codes . conflict : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] raise e [EOL] [EOL] self . _wait_for_completion ( project_id , job_type = JobType . GEN_INPUTS_LIST , wait_options = wait_options , job_id = job_id ) [EOL] [EOL] async def download_task_json_with_async ( self , project_id , dest_path , is_latest = False , wait_options = None ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] partial_func = partial ( self . download_task_json , project_id , dest_path , is_latest , wait_options ) [EOL] result = await loop . run_in_executor ( None , partial_func ) [EOL] return result [EOL] [EOL] def download_task_json ( self , project_id , dest_path , is_latest = False , wait_options = None ) : [EOL] logger . debug ( f" [string] { dest_path }" ) [EOL] if is_latest : [EOL] self . wait_until_updated_task_json ( project_id , wait_options ) [EOL] self . service . wrapper . download_project_tasks_url ( project_id , dest_path ) [EOL] [EOL] else : [EOL] try : [EOL] self . service . wrapper . download_project_tasks_url ( project_id , dest_path ) [EOL] except requests . HTTPError as e : [EOL] if e . response . status_code == requests . codes . not_found : [EOL] logger . info ( f" [string] " ) [EOL] self . wait_until_updated_task_json ( project_id , wait_options ) [EOL] self . service . wrapper . download_project_tasks_url ( project_id , dest_path ) [EOL] else : [EOL] raise e [EOL] [EOL] def wait_until_updated_task_json ( self , project_id , wait_options = None ) : [EOL] job_id = None [EOL] try : [EOL] job = self . service . api . post_project_tasks_update ( project_id , query_params = { [string] : [string] } ) [ [number] ] [ [string] ] [EOL] job_id = job [ [string] ] [EOL] except requests . HTTPError as e : [EOL] [comment] [EOL] if e . response . status_code == requests . codes . conflict : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] raise e [EOL] [EOL] self . _wait_for_completion ( project_id , job_type = JobType . GEN_TASKS_LIST , wait_options = wait_options , job_id = job_id ) [EOL] [EOL] async def download_task_history_json_with_async ( self , project_id , dest_path ) : [EOL] [docstring] [EOL] return self . download_task_history_json ( project_id , dest_path = dest_path ) [EOL] [EOL] def download_task_history_json ( self , project_id , dest_path ) : [EOL] [docstring] [EOL] try : [EOL] logger . debug ( f" [string] { dest_path }" ) [EOL] self . service . wrapper . download_project_task_histories_url ( project_id , dest_path ) [EOL] except requests . HTTPError as e : [EOL] if e . response . status_code == requests . codes . not_found : [EOL] logger . info ( f" [string] " ) [EOL] raise DownloadingFileNotFoundError ( [string] ) from e [EOL] raise e [EOL] [EOL] async def download_inspection_json_with_async ( self , project_id , dest_path ) : [EOL] [docstring] [EOL] [EOL] return self . download_inspection_json ( project_id , dest_path = dest_path ) [EOL] [EOL] def download_inspection_json ( self , project_id , dest_path ) : [EOL] [docstring] [EOL] try : [EOL] logger . debug ( f" [string] { dest_path }" ) [EOL] self . service . wrapper . download_project_inspections_url ( project_id , dest_path ) [EOL] except requests . HTTPError as e : [EOL] if e . response . status_code == requests . codes . not_found : [EOL] logger . info ( f" [string] " ) [EOL] raise DownloadingFileNotFoundError ( [string] ) from e [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 $typing.Any$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 $typing.Any$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 $typing.Any$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 $typing.Optional[annofabcli.common.dataclasses.WaitOptions]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import annofabcli [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . statistics . csv import Csv [EOL] from annofabcli . statistics . table import Table [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class WritePerfomancePerUser ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] csv_obj = Csv ( outdir = args . output_dir ) [EOL] [EOL] df_task = pandas . read_csv ( args . task_csv ) [EOL] df_task_history = pandas . read_csv ( args . task_history_csv ) [EOL] df_labor = pandas . read_csv ( args . labor_csv ) [EOL] [EOL] df_count_ratio = Table . create_annotation_count_ratio_df ( df_task_history , df_task ) [EOL] [EOL] df_perfomance_per_user = Table . create_productivity_per_user_from_aw_time ( df_task_history , df_labor , df_count_ratio ) [EOL] [EOL] csv_obj . write_productivity_per_user ( df_perfomance_per_user ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] WritePerfomancePerUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] parser . add_argument ( [string] , type = str , required = True , help = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , type = str , required = True , help = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , type = str , required = True , help = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import List , Optional [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] from annofabcli . statistics . linegraph import LineGraph , OutputTarget [EOL] from annofabcli . statistics . table import Table [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def write_linegraph_per_user ( csv , output_dir , user_id_list = None , minimal_output = False ) : [EOL] [docstring] [EOL] task_df = pandas . read_csv ( str ( csv ) ) [EOL] if len ( task_df ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] [EOL] linegraph_obj = LineGraph ( outdir = str ( output_dir ) ) [EOL] [EOL] output_target_list = None [EOL] if minimal_output : [EOL] output_target_list = [ OutputTarget . ANNOTATION ] [EOL] [EOL] task_cumulative_df_by_annotator = Table . create_cumulative_df_by_first_annotator ( task_df ) [EOL] linegraph_obj . write_cumulative_line_graph_for_annotator ( df = task_cumulative_df_by_annotator , output_target_list = output_target_list , first_annotation_user_id_list = user_id_list , ) [EOL] [EOL] task_cumulative_df_by_inspector = Table . create_cumulative_df_by_first_inspector ( task_df ) [EOL] linegraph_obj . write_cumulative_line_graph_for_inspector ( df = task_cumulative_df_by_inspector , output_target_list = output_target_list , first_inspection_user_id_list = user_id_list , ) [EOL] [EOL] task_cumulative_df_by_acceptor = Table . create_cumulative_df_by_first_acceptor ( task_df ) [EOL] linegraph_obj . write_cumulative_line_graph_for_acceptor ( df = task_cumulative_df_by_acceptor , output_target_list = output_target_list , first_acceptance_user_id_list = user_id_list , ) [EOL] [EOL] if not minimal_output : [EOL] df_by_date_user = Table . create_dataframe_by_date_user ( task_df ) [EOL] linegraph_obj . write_productivity_line_graph_for_annotator ( df = df_by_date_user , first_annotation_user_id_list = user_id_list ) [EOL] [EOL] [EOL] class WriteLingraphPerUser ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] user_id_list = annofabcli . common . cli . get_list_from_args ( args . user_id ) if args . user_id is not None else None [EOL] write_linegraph_per_user ( csv = args . csv , output_dir = args . output_dir , user_id_list = user_id_list , minimal_output = args . minimal ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] WriteLingraphPerUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = Path , required = True , help = ( [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , nargs = [string] , help = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = Path , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli . experimental import ( dashboard , find_break_error , list_labor_worktime , list_out_of_range_annotation_for_movie , mask_user_info , merge_peformance_per_date , merge_peformance_per_user , merge_visualization_dir , write_linegraph_per_user , write_performance_csv_per_user , write_performance_scatter_per_user , write_task_histogram , write_whole_linegraph , ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] dashboard . add_parser ( subparsers ) [EOL] find_break_error . add_parser ( subparsers ) [EOL] list_labor_worktime . add_parser ( subparsers ) [EOL] list_out_of_range_annotation_for_movie . add_parser ( subparsers ) [EOL] mask_user_info . add_parser ( subparsers ) [EOL] merge_peformance_per_date . add_parser ( subparsers ) [EOL] merge_peformance_per_user . add_parser ( subparsers ) [EOL] merge_visualization_dir . add_parser ( subparsers ) [EOL] write_linegraph_per_user . add_parser ( subparsers ) [EOL] write_performance_csv_per_user . add_parser ( subparsers ) [EOL] write_performance_scatter_per_user . add_parser ( subparsers ) [EOL] write_task_histogram . add_parser ( subparsers ) [EOL] write_whole_linegraph . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , Any , Optional , Set , Union [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Dict , Optional , Set , Tuple , Union [EOL] [EOL] import numpy [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_list_from_args , ) [EOL] from annofabcli . common . exceptions import AnnofabCliException [EOL] from annofabcli . common . utils import read_multiheader_csv [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] ALPHABET_SIZE = [number] [EOL] DIGIT = [number] [EOL] [EOL] [EOL] def _create_uniqued_masked_name ( masked_name_set , masked_name ) : [EOL] if masked_name not in masked_name_set : [EOL] return masked_name [EOL] else : [EOL] base_masked_name = masked_name [ [number] : DIGIT ] [EOL] now_index = int ( masked_name [ DIGIT : ] ) if len ( masked_name ) > DIGIT else [number] [EOL] new_masked_name = base_masked_name + str ( now_index + [number] ) [EOL] return _create_uniqued_masked_name ( masked_name_set , new_masked_name ) [EOL] [EOL] [EOL] def create_replaced_dict ( name_set ) : [EOL] [docstring] [EOL] replaced_dict = { } [EOL] masked_name_set = set ( ) [EOL] for name in name_set : [EOL] masked_name = create_masked_name ( name ) [EOL] unique_masked_name = _create_uniqued_masked_name ( masked_name_set , masked_name ) [EOL] replaced_dict [ name ] = unique_masked_name [EOL] return replaced_dict [EOL] [EOL] [EOL] def create_replaced_biography_dict ( name_set ) : [EOL] replaced_dict = { } [EOL] masked_name_set = set ( ) [EOL] for name in name_set : [EOL] masked_name = create_masked_name ( name ) [EOL] unique_masked_name = _create_uniqued_masked_name ( masked_name_set , masked_name ) [EOL] replaced_dict [ name ] = unique_masked_name [EOL] return replaced_dict [EOL] [EOL] [EOL] def create_masked_name ( name ) : [EOL] [docstring] [EOL] [EOL] def _hash_str ( value ) : [EOL] hash_value = [number] [EOL] for c in value : [EOL] [comment] [EOL] hash_value = ( [number] * hash_value + ord ( c ) ) & [number] [EOL] return hash_value [EOL] [EOL] def _num2alpha ( num ) : [EOL] [docstring] [EOL] if num <= ALPHABET_SIZE : [EOL] return chr ( [number] + num ) [EOL] elif num % [number] == [number] : [EOL] return _num2alpha ( num // ALPHABET_SIZE - [number] ) + chr ( [number] ) [EOL] else : [EOL] return _num2alpha ( num // ALPHABET_SIZE ) + chr ( [number] + num % ALPHABET_SIZE ) [EOL] [EOL] SIZE = pow ( ALPHABET_SIZE , DIGIT ) [EOL] hash_value = ( _hash_str ( name ) % SIZE ) + [number] [EOL] return _num2alpha ( hash_value ) [EOL] [EOL] [EOL] def get_replaced_user_id_set_from_biography ( df , not_masked_location_set = None ) : [EOL] if not_masked_location_set is None : [EOL] filtered_df = df [EOL] else : [EOL] filtered_df = df [ df [ [string] ] . map ( lambda e : e not in not_masked_location_set ) ] [EOL] [EOL] return set ( filtered_df [ [string] ] ) [EOL] [EOL] [EOL] def _get_header_row_count ( df ) : [EOL] if isinstance ( df . columns , pandas . MultiIndex ) : [EOL] return len ( df . columns . levels ) [EOL] else : [EOL] return [number] [EOL] [EOL] [EOL] def _get_tuple_column ( df , column ) : [EOL] size = _get_header_row_count ( df ) [EOL] if size >= [number] : [EOL] return tuple ( [ column ] + [ [string] ] * ( size - [number] ) ) [EOL] else : [EOL] return column [EOL] [EOL] [EOL] def get_masked_username ( df , replace_dict_by_user_id ) : [EOL] [docstring] [EOL] user_id_column = _get_tuple_column ( df , [string] ) [EOL] username_column = _get_tuple_column ( df , [string] ) [EOL] [EOL] def _get_username ( row ) : [EOL] if row [ user_id_column ] in replace_dict_by_user_id : [EOL] return replace_dict_by_user_id [ row [ user_id_column ] ] [EOL] else : [EOL] return row [ username_column ] [EOL] [EOL] return df . apply ( _get_username , axis = [number] ) [EOL] [EOL] [EOL] def get_masked_account_id ( df , replace_dict_by_user_id ) : [EOL] [docstring] [EOL] user_id_column = _get_tuple_column ( df , [string] ) [EOL] account_id_column = _get_tuple_column ( df , [string] ) [EOL] [EOL] def _get_account_id ( row ) : [EOL] if row [ user_id_column ] in replace_dict_by_user_id : [EOL] return replace_dict_by_user_id [ row [ user_id_column ] ] [EOL] else : [EOL] return row [ account_id_column ] [EOL] [EOL] return df . apply ( _get_account_id , axis = [number] ) [EOL] [EOL] [EOL] def get_replaced_biography_set ( df , not_masked_location_set = None ) : [EOL] biography_set = set ( df [ [string] ] ) [EOL] if numpy . nan in biography_set : [EOL] biography_set . remove ( numpy . nan ) [EOL] [EOL] if not_masked_location_set is None : [EOL] return biography_set [EOL] else : [EOL] for not_masked_location in not_masked_location_set : [EOL] if not_masked_location in biography_set : [EOL] biography_set . remove ( not_masked_location ) [EOL] [EOL] return biography_set [EOL] [EOL] [EOL] def replate_user_info ( df , not_masked_biography_set = None , not_masked_user_id_set = None , ) : [EOL] if [string] in df : [EOL] replaced_user_id_set = get_replaced_user_id_set_from_biography ( df , not_masked_location_set = not_masked_biography_set ) [EOL] else : [EOL] replaced_user_id_set = set ( ) [EOL] if not_masked_user_id_set is not None : [EOL] replaced_user_id_set = replaced_user_id_set - not_masked_user_id_set [EOL] [EOL] replace_dict_by_user_id = create_replaced_dict ( replaced_user_id_set ) [EOL] if [string] in df : [EOL] df [ [string] ] = get_masked_username ( df , replace_dict_by_user_id = replace_dict_by_user_id ) [EOL] if [string] in df : [EOL] df [ [string] ] = get_masked_account_id ( df , replace_dict_by_user_id = replace_dict_by_user_id ) [EOL] df [ [string] ] = df [ [string] ] . replace ( replace_dict_by_user_id ) [EOL] [EOL] if [string] in df : [EOL] replaced_biography_set = get_replaced_biography_set ( df , not_masked_location_set = not_masked_biography_set ) [EOL] tmp_replace_dict_by_biography = create_replaced_dict ( replaced_biography_set ) [EOL] replace_dict_by_biography = { key : f" [string] { value }" for key , value in tmp_replace_dict_by_biography . items ( ) } [EOL] df [ [string] ] = df [ [string] ] . replace ( replace_dict_by_biography ) [EOL] return df [EOL] [EOL] [EOL] def create_masked_user_info_df ( csv , csv_header , not_masked_biography_set = None , not_masked_user_id_set = None , ) : [EOL] if csv_header == [number] : [EOL] df = pandas . read_csv ( str ( csv ) ) [EOL] else : [EOL] df = read_multiheader_csv ( str ( csv ) , header_row_count = csv_header ) [EOL] [EOL] if [string] not in df : [EOL] raise AnnofabCliException ( f" [string] " ) [EOL] [EOL] new_df = replate_user_info ( df , not_masked_biography_set = not_masked_biography_set , not_masked_user_id_set = not_masked_user_id_set ) [EOL] return new_df [EOL] [EOL] [EOL] class MaskUserInfo ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] not_masked_biography_set = ( set ( get_list_from_args ( args . not_masked_biography ) ) if args . not_masked_biography is not None else None ) [EOL] not_masked_user_id_set = ( set ( get_list_from_args ( args . not_masked_user_id ) ) if args . not_masked_user_id is not None else None ) [EOL] [EOL] df = create_masked_user_info_df ( csv = args . csv , csv_header = args . csv_header , not_masked_biography_set = not_masked_biography_set , not_masked_user_id_set = not_masked_user_id_set , ) [EOL] self . print_csv ( df ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] MaskUserInfo ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] parser . add_argument ( [string] , type = Path , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , type = int , help = [string] , default = [number] ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,typing.Tuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.Series$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.Series$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Optional[typing.Set[builtins.str]]$ 0 $typing.Optional[typing.Set[builtins.str]]$ 0 $typing.Optional[typing.Set[builtins.str]]$ 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] from annofabcli . statistics . linegraph import LineGraph [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def write_whole_linegraph ( csv , output_dir ) : [EOL] df = pandas . read_csv ( str ( csv ) ) [EOL] linegraph_obj = LineGraph ( outdir = str ( output_dir ) ) [EOL] linegraph_obj . write_whole_productivity_line_graph ( df ) [EOL] linegraph_obj . write_whole_cumulative_line_graph ( df ) [EOL] [EOL] [EOL] class WriteWholeLingraph ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] write_whole_linegraph ( csv = args . csv , output_dir = args . output_dir ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] WriteWholeLingraph ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = Path , required = True , help = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , [string] , type = Path , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] from annofabcli . common . utils import read_multiheader_csv [EOL] from annofabcli . statistics . csv import Csv [EOL] from annofabcli . statistics . table import Table [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def merge_peformance_per_user ( csv_path_list , output_path ) : [EOL] df_list = [ ] [EOL] for csv_path in csv_path_list : [EOL] df = read_multiheader_csv ( str ( csv_path ) ) [EOL] df_list . append ( df ) [EOL] [EOL] sum_df = df_list [ [number] ] [EOL] for df in df_list [ [number] : ] : [EOL] sum_df = Table . merge_productivity_per_user_from_aw_time ( sum_df , df ) [EOL] [EOL] csv_obj = Csv ( outdir = str ( output_path . parent ) ) [EOL] csv_obj . write_productivity_per_user ( sum_df , output_path = output_path ) [EOL] [EOL] [EOL] class MergePerfomancePerUser ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] merge_peformance_per_user ( csv_path_list = args . csv , output_path = args . output ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] MergePerfomancePerUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = Path , nargs = [string] , required = True , help = ( [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = Path , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Optional , Union [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import requests [EOL] import annofabcli [EOL] import annofabapi [EOL] import datetime [EOL] import typing [EOL] import argparse [EOL] import datetime [EOL] import json [EOL] import logging [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import dateutil . parser [EOL] import pandas as pd [EOL] import requests [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_list_from_args , ) [EOL] from annofabcli . common . utils import read_lines_except_blank_line [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def download_content ( url ) : [EOL] [docstring] [EOL] response = requests . get ( url ) [EOL] annofabapi . utils . raise_for_status ( response ) [EOL] return response . content [EOL] [EOL] [EOL] def get_err_history_events ( task_history_events , task_id_list ) : [EOL] [docstring] [EOL] err_history_events_dict = { } [EOL] [EOL] for task_history_event in task_history_events : [EOL] if task_id_list : [EOL] if task_history_event [ [string] ] in task_id_list : [EOL] if task_history_event [ [string] ] in err_history_events_dict : [EOL] err_history_events_dict [ task_history_event [ [string] ] ] . append ( task_history_event ) [EOL] else : [EOL] err_history_events_dict [ task_history_event [ [string] ] ] = [ task_history_event ] [EOL] else : [EOL] if task_history_event [ [string] ] in err_history_events_dict : [EOL] err_history_events_dict [ task_history_event [ [string] ] ] . append ( task_history_event ) [EOL] else : [EOL] err_history_events_dict [ task_history_event [ [string] ] ] = [ task_history_event ] [EOL] [EOL] return err_history_events_dict [EOL] [EOL] [EOL] class FindBreakError ( AbstractCommandLineInterface ) : [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] project_id_list = get_list_from_args ( args . project_id ) [EOL] self . project_id_list = list ( set ( project_id_list ) ) [EOL] [EOL] def _get_username ( self , project_id , account_id ) : [EOL] [docstring] [EOL] member = self . facade . get_organization_member_from_account_id ( project_id , account_id ) [EOL] if member is not None : [EOL] return member [ [string] ] [EOL] else : [EOL] return account_id [EOL] [EOL] def _get_all_tasks ( self , project_id , task_query = None ) : [EOL] [docstring] [EOL] tasks = self . service . wrapper . get_all_tasks ( project_id , query_params = task_query ) [EOL] return tasks [EOL] [EOL] def _project_task_history_events ( self , project_id , import_file_path = None ) : [EOL] [docstring] [EOL] project_task_history_events = [ ] [EOL] if import_file_path is None : [EOL] content , _ = self . service . wrapper . api . get_project_task_history_events_url ( project_id = project_id ) [EOL] url = content [ [string] ] [EOL] try : [EOL] history_events = download_content ( url ) [EOL] except requests . HTTPError : [EOL] [comment] [EOL] logger . warning ( f" [string] { project_id }" ) [EOL] return None [EOL] project_task_history_events = json . loads ( history_events ) [EOL] [EOL] else : [EOL] history_events = read_lines_except_blank_line ( import_file_path ) [EOL] project_task_history_events = json . loads ( history_events [ [number] ] ) [EOL] [EOL] return project_task_history_events [EOL] [EOL] def get_err_events ( self , err_history_events , time_list ) : [EOL] [docstring] [EOL] [EOL] def check_applicable_time ( from_time , to_time , date_time_list ) : [EOL] [comment] [EOL] from_time = dateutil . parser . parse ( from_time . strftime ( [string] ) ) [EOL] to_time = dateutil . parser . parse ( to_time . strftime ( [string] ) ) [EOL] [EOL] if date_time_list : [EOL] for date_time in date_time_list : [EOL] date_time = dateutil . parser . parse ( date_time . strftime ( [string] ) ) [EOL] if date_time in [ from_time , to_time ] : [EOL] return True [EOL] else : [EOL] return True [EOL] return False [EOL] [EOL] err_events_list = [ ] [EOL] date_time_list = [ dateutil . parser . parse ( time ) for time in time_list ] [EOL] for v in err_history_events . values ( ) : [EOL] v . sort ( key = lambda x : x [ [string] ] ) [EOL] for i , history_events in enumerate ( v ) : [EOL] if history_events [ [string] ] == [string] : [EOL] if len ( v ) == i + [number] : [EOL] continue [EOL] next_history_events = v [ i + [number] ] [EOL] if next_history_events [ [string] ] in [ [string] , [string] , [string] ] : [EOL] next_time = dateutil . parser . parse ( next_history_events [ [string] ] ) [EOL] this_time = dateutil . parser . parse ( history_events [ [string] ] ) [EOL] working_time = next_time - this_time [EOL] if working_time > datetime . timedelta ( minutes = self . args . task_history_time_threshold ) and check_applicable_time ( this_time , next_time , date_time_list ) : [EOL] history_events [ [string] ] = self . _get_username ( history_events [ [string] ] , history_events [ [string] ] ) [EOL] next_history_events [ [string] ] = self . _get_username ( history_events [ [string] ] , history_events [ [string] ] ) [EOL] history_events [ [string] ] = self . facade . get_project_title ( history_events [ [string] ] ) [EOL] next_history_events [ [string] ] = self . facade . get_project_title ( history_events [ [string] ] ) [EOL] err_events_list . append ( [ history_events , next_history_events ] ) [EOL] return err_events_list [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] if args . import_file_path is not None : [EOL] if not Path ( args . import_file_path ) . is_file ( ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] { args . import_file_path } [string] " , file = sys . stderr , ) [EOL] return False [EOL] project_id_list = get_list_from_args ( args . project_id ) [EOL] if len ( project_id_list ) > [number] and args . task_id : [EOL] print ( f"{ COMMON_MESSAGE } [string] { args . project_id } [string] " , file = sys . stderr , ) [EOL] return False [EOL] if args . task_id and len ( args . task_id ) > [number] and args . time : [EOL] print ( f"{ COMMON_MESSAGE } [string] { args . project_id } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] err_events = [ ] [EOL] for project_id in args . project_id : [EOL] task_history_events = self . _project_task_history_events ( project_id = project_id , import_file_path = args . import_file_path ) [EOL] if not task_history_events : [EOL] [comment] [EOL] continue [EOL] [comment] [EOL] err_history_events = get_err_history_events ( task_history_events = task_history_events , task_id_list = args . task_id if args . task_id else [ ] ) [EOL] [comment] [EOL] err_events . extend ( self . get_err_events ( err_history_events = err_history_events , time_list = args . time if args . time else [ ] ) ) [EOL] [EOL] output_err_events ( err_events_list = err_events , output = self . output , add = args . add ) [EOL] [EOL] [EOL] def output_err_events ( err_events_list , output = None , add = False ) : [EOL] [docstring] [EOL] [EOL] def _timedelta_to_HM ( td ) : [EOL] sec = td . total_seconds ( ) [EOL] return str ( round ( sec // [number] ) ) + [string] + str ( round ( sec % [number] // [number] ) ) + [string] [EOL] [EOL] data_list = [ ] [EOL] for i , data in enumerate ( err_events_list ) : [EOL] start_data , end_data = data [EOL] start_time = dateutil . parser . parse ( start_data [ [string] ] ) [EOL] end_time = dateutil . parser . parse ( end_data [ [string] ] ) [EOL] start_data [ [string] ] = start_time . isoformat ( ) [EOL] end_data [ [string] ] = end_time . isoformat ( ) [EOL] start_data [ [string] ] = [string] [EOL] end_data [ [string] ] = _timedelta_to_HM ( end_time - start_time ) [EOL] [EOL] df = pd . DataFrame ( [ start_data , end_data ] ) [EOL] df [ [string] ] = i + [number] [EOL] [EOL] del df [ [string] ] [EOL] del df [ [string] ] [EOL] del df [ [string] ] [EOL] data_list . append ( df ) [EOL] [EOL] if not data_list : [EOL] logger . warning ( [string] ) [EOL] return [EOL] elif len ( data_list ) == [number] : [EOL] pd_data = data_list [ [number] ] [EOL] else : [EOL] pd_data = pd . concat ( data_list ) [EOL] [EOL] if add : [EOL] to_csv_kwargs = { [string] : False , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , } [EOL] else : [EOL] to_csv_kwargs = { [string] : False , [string] : [string] , [string] : [string] } [EOL] [EOL] annofabcli . utils . print_csv ( pd_data [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] , output = output , to_csv_kwargs = to_csv_kwargs , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] FindBreakError ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , nargs = [string] , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $typing.List[datetime.datetime]$ 0 0 0 $datetime.datetime$ 0 $typing.List[datetime.datetime]$ 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Optional[typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import argparse [EOL] import annofabcli [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] from annofabcli . common . utils import read_multiheader_csv [EOL] from annofabcli . statistics . scatter import Scatter [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def write_performance_scatter_per_user ( csv , output_dir ) : [EOL] df = read_multiheader_csv ( str ( csv ) ) [EOL] scatter_obj = Scatter ( str ( output_dir ) ) [EOL] scatter_obj . write_scatter_for_productivity_by_monitored_worktime ( df ) [EOL] scatter_obj . write_scatter_for_productivity_by_actual_worktime ( df ) [EOL] scatter_obj . write_scatter_for_quality ( df ) [EOL] scatter_obj . write_scatter_for_productivity_by_actual_worktime_and_quality ( df ) [EOL] [EOL] [EOL] class WriteScatterPerUser ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] write_performance_scatter_per_user ( csv = args . csv , output_dir = args . output_dir ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] WriteScatterPerUser ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = Path , required = True , help = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , [string] , type = Path , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Coroutine , Tuple , List , Any , Optional , Set [EOL] import builtins [EOL] import logging [EOL] import asyncio [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] import zipfile [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] from annofabapi . parser import SimpleAnnotationZipParser [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . download import DownloadingFile [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _millisecond_to_hour ( millisecond ) : [EOL] return millisecond / [number] / [number] [EOL] [EOL] [EOL] def _get_time_range ( str_data ) : [EOL] tmp_list = str_data . split ( [string] ) [EOL] return ( int ( tmp_list [ [number] ] ) , int ( tmp_list [ [number] ] ) ) [EOL] [EOL] [EOL] class ListOutOfRangeAnnotationForMovieMain : [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] [EOL] @ staticmethod def get_max_seconds_for_webapi ( annotation ) : [EOL] details = annotation [ [string] ] [EOL] range_list = [ _get_time_range ( e [ [string] ] ) for e in details if e [ [string] ] is not None ] [EOL] if len ( range_list ) == [number] : [EOL] return [number] , [number] [EOL] else : [EOL] max_begin = max ( [ e [ [number] ] for e in range_list ] ) / [number] [EOL] max_end = max ( [ e [ [number] ] for e in range_list ] ) / [number] [EOL] return max_begin , max_end [EOL] [EOL] @ staticmethod def get_max_seconds_for_zip ( annotation ) : [EOL] details = annotation [ [string] ] [EOL] range_list = [ ( e [ [string] ] [ [string] ] , e [ [string] ] [ [string] ] ) for e in details if e [ [string] ] [ [string] ] == [string] ] [EOL] if len ( range_list ) == [number] : [EOL] return [number] , [number] [EOL] else : [EOL] max_begin = max ( [ e [ [number] ] for e in range_list ] ) / [number] [EOL] max_end = max ( [ e [ [number] ] for e in range_list ] ) / [number] [EOL] return max_begin , max_end [EOL] [EOL] def create_dataframe ( self , proejct_id , task_list , input_data_list , annotation_zip , ) : [EOL] if annotation_zip is None : [EOL] logger . info ( f"{ len ( task_list ) } [string] " ) [EOL] for task_index , task in enumerate ( task_list ) : [EOL] task [ [string] ] = _millisecond_to_hour ( task [ [string] ] ) [EOL] task [ [string] ] = task [ [string] ] [ [number] ] [EOL] annotation , _ = self . service . api . get_editor_annotation ( proejct_id , task [ [string] ] , task [ [string] ] ) [EOL] max_seconds = self . get_max_seconds_for_webapi ( annotation ) [EOL] task [ [string] ] = max_seconds [ [number] ] [EOL] task [ [string] ] = max_seconds [ [number] ] [EOL] if ( task_index + [number] ) % [number] == [number] : [EOL] logger . info ( f"{ task_index + [number] } [string] " ) [EOL] else : [EOL] logger . info ( f"{ len ( task_list ) } [string] { str ( annotation_zip ) } [string] " ) [EOL] with zipfile . ZipFile ( str ( annotation_zip ) , [string] ) as zip_file : [EOL] for task_index , task in enumerate ( task_list ) : [EOL] task [ [string] ] = _millisecond_to_hour ( task [ [string] ] ) [EOL] task [ [string] ] = task [ [string] ] [ [number] ] [EOL] [EOL] parser = SimpleAnnotationZipParser ( zip_file , f"{ task [ [string] ] } [string] { task [ [string] ] } [string] " ) [EOL] simple_annotation = parser . load_json ( ) [EOL] max_seconds = self . get_max_seconds_for_zip ( simple_annotation ) [EOL] task [ [string] ] = max_seconds [ [number] ] [EOL] task [ [string] ] = max_seconds [ [number] ] [EOL] [EOL] if ( task_index + [number] ) % [number] == [number] : [EOL] logger . info ( f"{ task_index + [number] } [string] " ) [EOL] [EOL] df_task = pandas . DataFrame ( task_list , columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] df_input_data = pandas . DataFrame ( input_data_list , columns = [ [string] , [string] ] ) [EOL] df_merged = pandas . merge ( df_task , df_input_data , how = [string] , on = [string] ) [EOL] return df_merged [EOL] [EOL] @ staticmethod def filter_task_list ( task_list , task_id_list ) : [EOL] def _exists ( task_id ) : [EOL] if task_id in task_id_set : [EOL] task_id_set . remove ( task_id ) [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] task_id_set = set ( task_id_list ) [EOL] task_list = [ e for e in task_list if _exists ( e [ [string] ] ) ] [EOL] if len ( task_id_set ) > [number] : [EOL] tmp = [string] . join ( task_id_set ) [EOL] logger . warning ( f" [string] { tmp }" ) [EOL] return task_list [EOL] [EOL] def list_out_of_range_annotation_for_movie ( self , project_id , task_id_list , parse_annotation_zip = False ) : [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] [EOL] input_data_json_path = cache_dir / f" [string] { project_id } [string] " [EOL] task_json_path = cache_dir / f" [string] { project_id } [string] " [EOL] awaitable_list = [ downloading_obj . download_task_json_with_async ( project_id , dest_path = str ( task_json_path ) ) , downloading_obj . download_input_data_json_with_async ( project_id , dest_path = str ( input_data_json_path ) , ) , ] [EOL] [EOL] annotation_zip_path = None [EOL] if parse_annotation_zip : [EOL] annotation_zip_path = cache_dir / f" [string] { project_id } [string] " [EOL] awaitable_list . append ( downloading_obj . download_annotation_zip_with_async ( project_id , dest_path = str ( annotation_zip_path ) , ) ) [EOL] [EOL] gather = asyncio . gather ( * awaitable_list ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( gather ) [EOL] [EOL] with input_data_json_path . open ( ) as f : [EOL] input_data_list = json . load ( f ) [EOL] [EOL] with task_json_path . open ( ) as f : [EOL] task_list = json . load ( f ) [EOL] if task_id_list is not None : [EOL] task_list = self . filter_task_list ( task_list , task_id_list ) [EOL] [EOL] df = self . create_dataframe ( project_id , task_list = task_list , input_data_list = input_data_list , annotation_zip = annotation_zip_path ) [EOL] return df [EOL] [EOL] [EOL] class ListOutOfRangeAnnotationForMovie ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) if args . task_id is not None else None [EOL] main_obj = ListOutOfRangeAnnotationForMovieMain ( self . service ) [EOL] df = main_obj . list_out_of_range_annotation_for_movie ( args . project_id , task_id_list , args . parse_annotation_zip ) [EOL] self . print_csv ( df ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListOutOfRangeAnnotationForMovie ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( required = False ) [EOL] argument_parser . add_output ( ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $builtins.bool$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.bool$ 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any]]$ 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any]]$ 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any]]$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $annofabcli.experimental.list_out_of_range_annotation_for_movie.ListOutOfRangeAnnotationForMovieMain$ 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.list_out_of_range_annotation_for_movie.ListOutOfRangeAnnotationForMovieMain$ 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import pandas [EOL] import _csv [EOL] import builtins [EOL] import typing [EOL] import csv [EOL] from enum import Enum [EOL] from typing import List , Tuple [EOL] [EOL] import numpy as np [EOL] import pandas as pd [EOL] [EOL] [EOL] class TimeUnitTarget ( Enum ) : [EOL] H = [string] [EOL] M = [string] [EOL] S = [string] [EOL] [EOL] [EOL] class FormatTarget ( Enum ) : [EOL] DETAILS = [string] [EOL] TOTAL = [string] [EOL] BY_NAME_TOTAL = [string] [EOL] COLUMN_LIST = [string] [EOL] COLUMN_LIST_PER_PROJECT = [string] [EOL] [EOL] [EOL] def timeunit_conversion ( df , time_unit = TimeUnitTarget . H ) : [EOL] if time_unit == TimeUnitTarget . H : [EOL] df [ [string] ] = df [ [string] ] / [number] [EOL] df [ [string] ] = df [ [string] ] / [number] [EOL] df [ [string] ] = df [ [string] ] / [number] [EOL] elif time_unit == TimeUnitTarget . S : [EOL] df [ [string] ] = df [ [string] ] * [number] [EOL] df [ [string] ] = df [ [string] ] * [number] [EOL] df [ [string] ] = df [ [string] ] * [number] [EOL] [EOL] return df [EOL] [EOL] [EOL] def calc_df_total ( df ) : [EOL] [comment] [EOL] del df [ [string] ] [EOL] del df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] . fillna ( [string] ) [EOL] total_df = pd . DataFrame ( df . groupby ( [ [string] , [string] , [string] , [string] ] , as_index = False ) . sum ( ) ) [EOL] [EOL] [comment] [EOL] sum_by_date = ( total_df [ [ [string] , [string] , [string] , [string] ] ] . groupby ( [ [string] ] , as_index = False ) . sum ( ) ) [EOL] sum_by_name = ( total_df [ [ [string] , [string] , [string] , [string] ] ] . groupby ( [ [string] ] , as_index = False ) . sum ( ) ) [EOL] sum_all = total_df [ [ [string] , [string] , [string] ] ] . sum ( ) . to_frame ( ) . transpose ( ) [EOL] [EOL] [comment] [EOL] sum_by_date [ [string] ] = sum_by_date [ [string] ] / sum_by_date [ [string] ] [EOL] sum_by_date [ [string] ] = sum_by_date [ [string] ] / sum_by_date [ [string] ] [EOL] [EOL] sum_by_name [ [string] ] = sum_by_name [ [string] ] / sum_by_name [ [string] ] [EOL] sum_by_name [ [string] ] = sum_by_name [ [string] ] / sum_by_name [ [string] ] [EOL] [EOL] sum_all [ [string] ] = sum_all [ [string] ] / sum_all [ [string] ] [EOL] sum_all [ [string] ] = sum_all [ [string] ] / sum_all [ [string] ] [EOL] [EOL] total_df [ [string] ] = total_df [ [string] ] / total_df [ [string] ] [EOL] total_df [ [string] ] = total_df [ [string] ] / total_df [ [string] ] [EOL] [EOL] return total_df , sum_by_date , sum_by_name , sum_all [EOL] [EOL] [EOL] def print_time_list_from_work_time_list ( df ) : [EOL] [comment] [EOL] total_df , sum_by_date , sum_by_name , sum_all = calc_df_total ( df = df ) [EOL] [comment] [EOL] del total_df [ [string] ] [EOL] del total_df [ [string] ] [EOL] [comment] [EOL] result = ( pd . concat ( [ total_df . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) , sum_by_date . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) , sum_by_name . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) , sum_all . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) , ] , sort = False , ) . sort_values ( [ [string] , [string] ] , ) . loc [ : , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ] ) [EOL] [comment] [EOL] result = result . set_index ( [ [string] , [string] ] ) [EOL] [comment] [EOL] result = result . stack ( [number] ) . unstack ( [number] , fill_value = [string] ) . unstack ( [number] , fill_value = [string] ) [EOL] result [ result . loc [ : , pd . IndexSlice [ : , [ [string] , [string] ] ] ] == [string] ] = [string] [EOL] [EOL] result . index = result . index . date [EOL] [EOL] [comment] [EOL] result = result . rename ( columns = { np . nan : [string] } , index = { pd . NaT : [string] } ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def print_byname_total_list ( df ) : [EOL] [comment] [EOL] _ , _ , sum_by_name , _ = calc_df_total ( df = df ) [EOL] [EOL] [comment] [EOL] result = sum_by_name . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) [EOL] return result [EOL] [EOL] [EOL] def print_total ( df ) : [EOL] [comment] [EOL] _ , _ , _ , sum_all = calc_df_total ( df = df ) [EOL] [EOL] [comment] [EOL] result = sum_all . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) [EOL] return result [EOL] [EOL] [EOL] def create_column_list ( df ) : [EOL] total_df , _ , _ , _ = calc_df_total ( df = df ) [EOL] [EOL] [comment] [EOL] result = ( total_df [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) ) [EOL] return result [EOL] [EOL] [EOL] def create_column_list_per_project ( df ) : [EOL] df [ [string] ] = df [ [string] ] . fillna ( [string] ) [EOL] df [ [string] ] = df [ [string] ] / df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] / df [ [string] ] [EOL] [comment] [EOL] result = ( df [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] . round ( [number] ) . replace ( { np . inf : [string] , np . nan : [string] } ) ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def print_time_list_csv ( print_time_list ) : [EOL] for time_list in print_time_list : [EOL] print ( * time_list , sep = [string] ) [EOL] [EOL] [EOL] def add_id_csv ( csv_path , id_list ) : [EOL] id_list [ [number] : [number] ] = [ [string] ] [EOL] [EOL] with open ( csv_path , mode = [string] , encoding = [string] , newline = [string] ) as f : [EOL] writer = csv . writer ( f , delimiter = [string] ) [EOL] writer . writerow ( [ ] ) [EOL] writer . writerow ( id_list ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pandas.DataFrame,pandas.DataFrame,pandas.DataFrame,pandas.DataFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Optional , TextIO [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import datetime [EOL] import typing [EOL] import argparse [EOL] import datetime [EOL] import logging [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [comment] [EOL] [EOL] import annofabapi [EOL] import numpy as np [EOL] import pandas as pd [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_list_from_args , ) [EOL] from annofabcli . experimental . utils import ( FormatTarget , TimeUnitTarget , add_id_csv , create_column_list , create_column_list_per_project , print_byname_total_list , print_time_list_from_work_time_list , print_total , timeunit_conversion , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Database : [EOL] def __init__ ( self , annofab_service , project_id , organization_id , start_date , end_date , ) : [EOL] self . annofab_service = annofab_service [EOL] self . project_id = project_id [EOL] self . organization_id = organization_id [EOL] self . start_date = start_date [EOL] self . end_date = end_date [EOL] [EOL] def get_labor_control ( self ) : [EOL] labor_control_df = self . annofab_service . api . get_labor_control ( { [string] : self . organization_id , [string] : self . project_id , [string] : self . start_date , [string] : self . end_date , } ) [ [number] ] [EOL] return labor_control_df [EOL] [EOL] def get_account_statistics ( self ) : [EOL] account_statistics = self . annofab_service . wrapper . get_account_statistics ( self . project_id ) [EOL] return account_statistics [EOL] [EOL] def get_project_members ( self ) : [EOL] project_members = self . annofab_service . api . get_project_members ( project_id = self . project_id ) [ [number] ] [EOL] return project_members [ [string] ] [EOL] [EOL] [EOL] class Table : [EOL] def __init__ ( self , database , facade ) : [EOL] self . database = database [EOL] self . project_id = database . project_id [EOL] self . facade = facade [EOL] [EOL] def create_labor_control_df ( self ) : [EOL] [EOL] labor_control = self . database . get_labor_control ( ) [EOL] labor_control_list = [ ] [EOL] for labor in labor_control : [EOL] if labor [ [string] ] is not None : [EOL] new_history = { [string] : self . _get_username ( labor [ [string] ] ) , [string] : self . _get_user_id ( labor [ [string] ] ) , [string] : self . _get_user_biography ( labor [ [string] ] ) , [string] : labor [ [string] ] , [string] : np . nan [EOL] if labor [ [string] ] [ [string] ] [ [string] ] is None [EOL] else int ( labor [ [string] ] [ [string] ] [ [string] ] ) / [number] , [string] : np . nan [EOL] if labor [ [string] ] [ [string] ] [ [string] ] is None [EOL] else int ( labor [ [string] ] [ [string] ] [ [string] ] ) / [number] , [string] : labor [ [string] ] [ [string] ] [ [string] ] [EOL] if labor [ [string] ] [ [string] ] [ [string] ] is not None [EOL] else None , } [EOL] labor_control_list . append ( new_history ) [EOL] [EOL] return labor_control_list [EOL] [EOL] def create_account_statistics_df ( self ) : [EOL] [docstring] [EOL] account_statistics = self . database . get_account_statistics ( ) [EOL] all_histories = [ ] [EOL] for account_info in account_statistics : [EOL] account_id = account_info [ [string] ] [EOL] histories = account_info [ [string] ] [EOL] if account_id is not None : [EOL] for history in histories : [EOL] new_history = { [string] : self . _get_username ( account_id ) , [string] : self . _get_user_id ( account_id ) , [string] : self . _get_user_biography ( account_id ) , [string] : history [ [string] ] , [string] : annofabcli . utils . isoduration_to_minute ( history [ [string] ] ) , } [EOL] all_histories . append ( new_history ) [EOL] [EOL] return all_histories [EOL] [EOL] def create_afaw_time_df ( self ) : [EOL] account_statistics_df = pd . DataFrame ( self . create_account_statistics_df ( ) ) [EOL] labor_control_df = pd . DataFrame ( self . create_labor_control_df ( ) ) [EOL] if len ( account_statistics_df ) == [number] and len ( labor_control_df ) == [number] : [EOL] df = pd . DataFrame ( [ ] ) [EOL] elif len ( account_statistics_df ) == [number] : [EOL] [EOL] labor_control_df [ [string] ] = np . nan [EOL] df = labor_control_df [EOL] elif len ( labor_control_df ) == [number] : [EOL] account_statistics_df [ [string] ] = np . nan [EOL] account_statistics_df [ [string] ] = np . nan [EOL] df = account_statistics_df [EOL] else : [EOL] df = pd . merge ( account_statistics_df , labor_control_df , on = [ [string] , [string] , [string] , [string] ] , how = [string] , ) [EOL] df [ [string] ] = self . project_id [EOL] df [ [string] ] = self . facade . get_project_title ( self . project_id ) [EOL] return df [EOL] [EOL] def _get_user_id ( self , account_id ) : [EOL] [docstring] [EOL] if account_id is None : [EOL] return None [EOL] [EOL] member = self . facade . get_organization_member_from_account_id ( self . project_id , account_id ) [EOL] if member is not None : [EOL] return member [ [string] ] [EOL] else : [EOL] return account_id [EOL] [EOL] def _get_username ( self , account_id ) : [EOL] [docstring] [EOL] if account_id is None : [EOL] return None [EOL] [EOL] member = self . facade . get_organization_member_from_account_id ( self . project_id , account_id ) [EOL] if member is not None : [EOL] return member [ [string] ] [EOL] else : [EOL] return account_id [EOL] [EOL] def _get_user_biography ( self , account_id ) : [EOL] [docstring] [EOL] if account_id is None : [EOL] return None [EOL] [EOL] member = self . facade . get_organization_member_from_account_id ( self . project_id , account_id ) [EOL] if member is not None : [EOL] return member [ [string] ] [EOL] else : [EOL] return account_id [EOL] [EOL] [EOL] def get_organization_id_from_project_id ( annofab_service , project_id ) : [EOL] [docstring] [EOL] organization , _ = annofab_service . api . get_organization_of_project ( project_id ) [EOL] return organization [ [string] ] [EOL] [EOL] [EOL] def refine_df ( df , start_date , end_date , user_id_list ) : [EOL] [comment] [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] ) . dt . date [EOL] refine_day_df = df [ ( df [ [string] ] >= start_date ) & ( df [ [string] ] <= end_date ) ] . copy ( ) [EOL] [comment] [EOL] refine_user_df = ( refine_day_df [EOL] if user_id_list is None [EOL] else refine_day_df [ refine_day_df [ [string] ] . str . contains ( [string] . join ( user_id_list ) , case = False ) ] . copy ( ) ) [EOL] return refine_user_df [EOL] [EOL] [EOL] class ListLaborWorktime ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def _get_project_title_list ( self , project_id_list ) : [EOL] return [ self . facade . get_project_title ( project_id ) for project_id in project_id_list ] [EOL] [EOL] def list_labor_worktime ( self , project_id , start_date , end_date ) : [EOL] [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , project_member_roles = [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] [comment] [EOL] [EOL] organization_id = get_organization_id_from_project_id ( self . service , project_id ) [EOL] database = Database ( self . service , project_id , organization_id , start_date , end_date = end_date ) [EOL] [comment] [EOL] table_obj = Table ( database = database , facade = self . facade ) [EOL] [comment] [EOL] [comment] [EOL] return table_obj . create_afaw_time_df ( ) [EOL] [EOL] def _output ( self , output , df , index , add_project_id , project_id_list ) : [EOL] if isinstance ( output , str ) : [EOL] Path ( output ) . parent . mkdir ( exist_ok = True , parents = True ) [EOL] df . to_csv ( output , date_format = [string] , encoding = [string] , line_terminator = [string] , float_format = [string] , index = index , ) [EOL] if output != sys . stdout and add_project_id : [EOL] add_id_csv ( output , self . _get_project_title_list ( project_id_list ) ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] format_target = FormatTarget ( args . format ) [EOL] time_unit = TimeUnitTarget ( args . time_unit ) [EOL] [EOL] start_date = datetime . datetime . strptime ( args . start_date , [string] ) . date ( ) [EOL] end_date = datetime . datetime . strptime ( args . end_date , [string] ) . date ( ) [EOL] user_id_list = get_list_from_args ( args . user_id ) if args . user_id is not None else None [EOL] [EOL] total_df = pd . DataFrame ( [ ] ) [EOL] [EOL] [comment] [EOL] project_id_list = get_list_from_args ( args . project_id ) [EOL] logger . info ( f"{ len ( project_id_list ) } [string] " ) [EOL] for i , project_id in enumerate ( list ( set ( project_id_list ) ) ) : [EOL] logger . debug ( f"{ i + [number] } [string] { project_id }" ) [EOL] try : [EOL] afaw_time_df = self . list_labor_worktime ( project_id , start_date . strftime ( [string] ) , end_date . strftime ( [string] ) ) [EOL] total_df = pd . concat ( [ total_df , afaw_time_df ] , sort = True ) [EOL] except Exception : [comment] [EOL] logger . error ( f" [string] { project_id } [string] " ) [EOL] [EOL] [comment] [EOL] if len ( total_df ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] total_df = refine_df ( total_df , start_date , end_date , user_id_list ) [EOL] if len ( total_df ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] [EOL] [comment] [EOL] total_df = timeunit_conversion ( df = total_df , time_unit = time_unit ) [EOL] [EOL] [comment] [EOL] if format_target == FormatTarget . BY_NAME_TOTAL : [EOL] df = print_byname_total_list ( total_df ) [EOL] elif format_target == FormatTarget . TOTAL : [EOL] df = print_total ( total_df ) [EOL] elif format_target == FormatTarget . COLUMN_LIST_PER_PROJECT : [EOL] df = create_column_list_per_project ( total_df ) [EOL] elif format_target == FormatTarget . COLUMN_LIST : [EOL] df = create_column_list ( total_df ) [EOL] elif format_target == FormatTarget . DETAILS : [EOL] df = print_time_list_from_work_time_list ( total_df ) [EOL] else : [EOL] raise RuntimeError ( f" [string] { format_target } [string] " ) [EOL] [comment] [EOL] if args . output : [EOL] out_format = args . output [EOL] else : [EOL] out_format = sys . stdout [EOL] self . _output ( out_format , df , index = ( format_target == FormatTarget . DETAILS ) , add_project_id = args . add_project_id , project_id_list = project_id_list , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListLaborWorktime ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] time_unit_choices = [ e . value for e in TimeUnitTarget ] [EOL] format_choices = [ e . value for e in FormatTarget ] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , nargs = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , type = str , nargs = [string] , default = None , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , default = [string] , choices = time_unit_choices , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , choices = format_choices , default = [string] , help = [string] [string] [string] [string] [string] [string] , ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] argument_parser . add_output ( required = False ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 0 0 0 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $annofabcli.experimental.list_labor_worktime.Table$ 0 0 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 $annofabcli.experimental.list_labor_worktime.Database$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.list_labor_worktime.Table$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.experimental.utils.TimeUnitTarget$ 0 0 0 $argparse.Namespace$ 0 $annofabcli.experimental.utils.TimeUnitTarget$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $datetime.date$ 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $datetime.date$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 $datetime.date$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.utils.TimeUnitTarget$ 0 $annofabcli.experimental.utils.TimeUnitTarget$ 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.TextIO$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 $annofabcli.experimental.utils.FormatTarget$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] from annofabcli . common . utils import _catch_exception [EOL] from annofabcli . statistics . histogram import Histogram [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def write_task_histogram ( csv , output_dir , minimal_output = False ) : [EOL] [docstring] [EOL] task_df = pandas . read_csv ( str ( csv ) ) [EOL] if len ( task_df ) == [number] : [EOL] logger . warning ( f" [string] " ) [EOL] return [EOL] [EOL] histogram_obj = Histogram ( outdir = str ( output_dir ) ) [EOL] _catch_exception ( histogram_obj . write_histogram_for_worktime ) ( task_df ) [EOL] _catch_exception ( histogram_obj . write_histogram_for_other ) ( task_df ) [EOL] [EOL] if not minimal_output : [EOL] _catch_exception ( histogram_obj . write_histogram_for_annotation_worktime_by_user ) ( task_df ) [EOL] _catch_exception ( histogram_obj . write_histogram_for_inspection_worktime_by_user ) ( task_df ) [EOL] _catch_exception ( histogram_obj . write_histogram_for_acceptance_worktime_by_user ) ( task_df ) [EOL] [EOL] [EOL] class WriteTaskHistogram ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] write_task_histogram ( csv = args . csv , output_dir = args . output_dir , minimal_output = args . minimal ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] WriteTaskHistogram ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = Path , required = True , help = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , [string] , type = Path , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import List , Optional [EOL] [EOL] import pandas [EOL] [EOL] import annofabcli [EOL] from annofabcli . common . cli import get_list_from_args [EOL] from annofabcli . common . utils import print_csv , print_json [EOL] from annofabcli . experimental . merge_peformance_per_date import merge_peformance_per_date [EOL] from annofabcli . experimental . merge_peformance_per_user import merge_peformance_per_user [EOL] from annofabcli . experimental . write_linegraph_per_user import write_linegraph_per_user [EOL] from annofabcli . experimental . write_performance_scatter_per_user import write_performance_scatter_per_user [EOL] from annofabcli . experimental . write_task_histogram import write_task_histogram [EOL] from annofabcli . experimental . write_whole_linegraph import write_whole_linegraph [EOL] from annofabcli . statistics . csv import Csv [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] FILENAME_PEFORMANCE_PER_USER = [string] [EOL] FILENAME_PEFORMANCE_PER_DATE = [string] [EOL] FILENAME_TASK_LIST = [string] [EOL] [EOL] [EOL] def merge_visualization ( project_dir_list , output_dir , user_id_list = None , minimal_output = False , ) : [EOL] def execute_merge_peformance_per_user ( ) : [EOL] performance_per_user_csv_list = [ dir / FILENAME_PEFORMANCE_PER_USER for dir in project_dir_list ] [EOL] merge_peformance_per_user ( csv_path_list = performance_per_user_csv_list , output_path = output_dir / FILENAME_PEFORMANCE_PER_USER ) [EOL] [EOL] def execute_merge_peformance_per_date ( ) : [EOL] performance_per_date_csv_list = [ dir / FILENAME_PEFORMANCE_PER_DATE for dir in project_dir_list ] [EOL] merge_peformance_per_date ( csv_path_list = performance_per_date_csv_list , output_path = output_dir / FILENAME_PEFORMANCE_PER_DATE ) [EOL] [EOL] def merge_task_list ( ) : [EOL] list_df = [ pandas . read_csv ( str ( dir / FILENAME_TASK_LIST ) ) for dir in project_dir_list ] [EOL] df = pandas . concat ( list_df , axis = [number] ) [EOL] return df [EOL] [EOL] def write_csv_for_summary ( df_task ) : [EOL] [docstring] [EOL] csv_obj = Csv ( str ( output_dir ) ) [EOL] csv_obj . write_task_count_summary ( df_task ) [EOL] csv_obj . write_worktime_summary ( df_task ) [EOL] csv_obj . write_count_summary ( df_task ) [EOL] [EOL] def write_info_json ( ) : [EOL] info = { [string] : [ str ( e ) for e in project_dir_list ] } [EOL] print_json ( info , is_pretty = True , output = str ( output_dir / [string] ) ) [EOL] [EOL] [comment] [EOL] execute_merge_peformance_per_user ( ) [EOL] execute_merge_peformance_per_date ( ) [EOL] df_task = merge_task_list ( ) [EOL] print_csv ( df_task , output = str ( output_dir / FILENAME_TASK_LIST ) ) [EOL] write_csv_for_summary ( df_task ) [EOL] [EOL] [comment] [EOL] write_performance_scatter_per_user ( csv = output_dir / FILENAME_PEFORMANCE_PER_USER , output_dir = output_dir / [string] ) [EOL] write_whole_linegraph ( csv = output_dir / FILENAME_PEFORMANCE_PER_DATE , output_dir = output_dir / [string] ) [EOL] write_linegraph_per_user ( csv = output_dir / FILENAME_TASK_LIST , output_dir = output_dir / [string] , minimal_output = minimal_output , user_id_list = user_id_list , ) [EOL] write_task_histogram ( csv = output_dir / FILENAME_TASK_LIST , output_dir = output_dir / [string] , minimal_output = minimal_output ) [EOL] [EOL] [comment] [EOL] write_info_json ( ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] user_id_list = get_list_from_args ( args . user_id ) if args . user_id is not None else None [EOL] merge_visualization ( project_dir_list = args . dir , user_id_list = user_id_list , minimal_output = args . minimal , output_dir = args . output_dir , ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = Path , nargs = [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = Path , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , nargs = [string] , help = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . supplementary . list_supplementary_data [EOL] import annofabcli . supplementary . put_supplementary_data [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . supplementary . list_supplementary_data . add_parser ( subparsers ) [EOL] annofabcli . supplementary . put_supplementary_data . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import copy [EOL] import logging [EOL] import uuid [EOL] from typing import Any , Dict , Optional [EOL] [EOL] from annofabapi . models import JobType , OrganizationMemberRole , ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CopyProject ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def copy_project ( self , src_project_id , dest_project_id , dest_title , wait_options , dest_overview = None , copy_options = None , wait_for_completion = False , ) : [EOL] [docstring] [EOL] [EOL] self . validate_project ( src_project_id , project_member_roles = [ ProjectMemberRole . OWNER ] , organization_member_roles = [ OrganizationMemberRole . ADMINISTRATOR , OrganizationMemberRole . OWNER ] , ) [EOL] [EOL] src_project_title = self . facade . get_project_title ( src_project_id ) [EOL] [EOL] if copy_options is not None : [EOL] copy_target = [ key . replace ( [string] , [string] ) for key in copy_options . keys ( ) if copy_options [ key ] ] [EOL] logger . info ( f" [string] { str ( copy_target ) }" ) [EOL] [EOL] confirm_message = f"{ src_project_title } [string] { src_project_id } [string] { dest_title } [string] { dest_project_id } [string] " [EOL] if not self . confirm_processing ( confirm_message ) : [EOL] return [EOL] [EOL] request_body = { } [EOL] if copy_options is not None : [EOL] request_body = copy . deepcopy ( copy_options ) [EOL] [EOL] request_body . update ( { [string] : dest_project_id , [string] : dest_title , [string] : dest_overview } ) [EOL] [EOL] self . service . api . initiate_project_copy ( src_project_id , request_body = request_body ) [EOL] logger . info ( f" [string] " ) [EOL] [EOL] if wait_for_completion : [EOL] MAX_WAIT_MINUTUE = wait_options . max_tries * wait_options . interval / [number] [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] [EOL] result = self . service . wrapper . wait_for_completion ( src_project_id , job_type = JobType . COPY_PROJECT , job_access_interval = wait_options . interval , max_job_access = wait_options . max_tries , ) [EOL] if result : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . info ( f" [string] " ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] dest_project_id = args . dest_project_id if args . dest_project_id is not None else str ( uuid . uuid4 ( ) ) [EOL] [EOL] copy_option_kyes = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] copy_options = { } [EOL] for key in copy_option_kyes : [EOL] copy_options [ key ] = getattr ( args , key ) [EOL] [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] [EOL] self . copy_project ( args . project_id , dest_project_id = dest_project_id , dest_title = args . dest_title , dest_overview = args . dest_overview , copy_options = copy_options , wait_for_completion = args . wait , wait_options = wait_options , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] CopyProject ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( help_message = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.float$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . project . copy_project [EOL] import annofabcli . project . diff_projects [EOL] import annofabcli . project . download [EOL] import annofabcli . project . list_project [EOL] import annofabcli . project . update_annotation_zip [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . project . copy_project . add_parser ( subparsers ) [EOL] annofabcli . project . diff_projects . add_parser ( subparsers ) [EOL] annofabcli . project . download . add_parser ( subparsers ) [EOL] annofabcli . project . list_project . add_parser ( subparsers ) [EOL] annofabcli . project . update_annotation_zip . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] from annofabapi . models import OrganizationMember , Project [EOL] from more_itertools import first_true [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def create_minimal_dataframe ( project_list ) : [EOL] [docstring] [EOL] df = pandas . DataFrame ( project_list ) [EOL] df [ [string] ] = [ e [ [string] ] [ [string] ] for e in project_list ] [EOL] return df [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] [EOL] [EOL] [EOL] class ListProjectMain : [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] self . facade = AnnofabApiFacade ( service ) [EOL] [EOL] @ staticmethod def get_account_id_from_user_id ( organization_member_list , user_id ) : [EOL] member = first_true ( organization_member_list , pred = lambda e : e [ [string] ] == user_id ) [EOL] if member is not None : [EOL] return member [ [string] ] [EOL] else : [EOL] return None [EOL] [EOL] def get_project_list_from_project_id ( self , project_id_list ) : [EOL] [docstring] [EOL] project_list = [ ] [EOL] for project_id in project_id_list : [EOL] project = self . service . wrapper . get_project_or_none ( project_id ) [EOL] if project is None : [EOL] logger . warning ( f" [string] { project_id } [string] " ) [EOL] continue [EOL] organization , _ = self . service . api . get_organization_of_project ( project_id ) [EOL] project [ [string] ] = organization [ [string] ] [EOL] project_list . append ( project ) [EOL] [EOL] return project_list [EOL] [EOL] def _modify_project_query ( self , organization_name , project_query ) : [EOL] [docstring] [EOL] [EOL] def remove_key ( arg_key ) : [EOL] if arg_key in project_query : [EOL] logger . info ( f" [string] { arg_key } [string] " ) [EOL] project_query . pop ( arg_key ) [EOL] [EOL] remove_key ( [string] ) [EOL] remove_key ( [string] ) [EOL] [EOL] organization_member_list = self . service . wrapper . get_all_organization_members ( organization_name ) [EOL] [EOL] if [string] in project_query : [EOL] user_id = project_query [ [string] ] [EOL] account_id = self . get_account_id_from_user_id ( organization_member_list , user_id ) [EOL] if account_id is not None : [EOL] project_query [ [string] ] = account_id [EOL] else : [EOL] logger . warning ( f" [string] { user_id } [string] " ) [EOL] [EOL] if [string] in project_query : [EOL] except_user_id = project_query [ [string] ] [EOL] except_account_id = self . get_account_id_from_user_id ( organization_member_list , except_user_id ) [EOL] if except_account_id is not None : [EOL] project_query [ [string] ] = except_account_id [EOL] else : [EOL] logger . warning ( f" [string] { except_user_id } [string] " ) [EOL] [EOL] return project_query [EOL] [EOL] def get_project_list_from_organization ( self , organization_name , project_query = None ) : [EOL] [docstring] [EOL] [EOL] if project_query is not None : [EOL] project_query = self . _modify_project_query ( organization_name , project_query ) [EOL] [EOL] logger . debug ( f" [string] { project_query }" ) [EOL] project_list = self . service . wrapper . get_all_projects_of_organization ( organization_name , query_params = project_query ) [EOL] [EOL] for project in project_list : [EOL] project [ [string] ] = organization_name [EOL] [EOL] return project_list [EOL] [EOL] [EOL] class ListProject ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_query = annofabcli . common . cli . get_json_from_args ( args . project_query ) [EOL] organization_name = args . organization [EOL] main_obj = ListProjectMain ( self . service ) [EOL] if organization_name is not None : [EOL] project_list = main_obj . get_project_list_from_organization ( organization_name , project_query ) [EOL] else : [EOL] assert args . project_id is not None [EOL] project_id_list = annofabcli . common . cli . get_list_from_args ( args . project_id ) [EOL] project_list = main_obj . get_project_list_from_project_id ( project_id_list ) [EOL] [EOL] logger . info ( f" [string] { len ( project_list ) }" ) [EOL] [EOL] if args . format == FormatArgument . MINIMAL_CSV . value : [EOL] df = create_minimal_dataframe ( project_list ) [EOL] self . print_csv ( df ) [EOL] else : [EOL] self . print_according_to_format ( project_list ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListProject ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] query_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] [EOL] query_group . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] , ) [EOL] [EOL] query_group . add_argument ( [string] , [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , help = [string] [string] [string] [string] [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . MINIMAL_CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON , FormatArgument . PROJECT_ID_LIST , ] , default = FormatArgument . CSV , ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] argument_parser . add_query ( ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.List[annofabapi.models.OrganizationMember]$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[annofabapi.models.OrganizationMember]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Project]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[annofabapi.models.Project]$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 $annofabcli.project.list_project.ListProjectMain$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $annofabcli.project.list_project.ListProjectMain$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabcli.project.list_project.ListProjectMain$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Tuple , List , Any , Set , Type [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import copy [EOL] import functools [EOL] import logging [EOL] import pprint [EOL] from enum import Enum [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] import annofabapi [EOL] import dictdiffer [EOL] import more_itertools [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] [EOL] DiffResult = Tuple [ bool , str ] [EOL] [docstring] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DiffTarget ( Enum ) : [EOL] [docstring] [EOL] [EOL] ANNOTATION_LABELS = [string] [EOL] INSPECTION_PHRASES = [string] [EOL] MEMBERS = [string] [EOL] SETTINGS = [string] [EOL] [EOL] [EOL] def sorted_inspection_phrases ( phrases ) : [EOL] return sorted ( phrases , key = lambda e : e [ [string] ] ) [EOL] [EOL] [EOL] def sorted_project_members ( project_members ) : [EOL] return sorted ( project_members , key = lambda e : e [ [string] ] ) [EOL] [EOL] [EOL] def create_ignored_label ( label ) : [EOL] [docstring] [EOL] [EOL] copied_label = copy . deepcopy ( label ) [EOL] copied_label . pop ( [string] , None ) [EOL] [EOL] additional_data_definitions = copied_label [ [string] ] [EOL] for additional_data in additional_data_definitions : [EOL] additional_data . pop ( [string] , None ) [EOL] choices = additional_data [ [string] ] [EOL] for choice in choices : [EOL] choice . pop ( [string] , None ) [EOL] [EOL] return copied_label [EOL] [EOL] [EOL] class DiffProjecs ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] [EOL] project_id1 = args . project_id1 [EOL] project_id2 = args . project_id2 [EOL] project_title1 = self . facade . get_project_title ( project_id1 ) [EOL] project_title2 = self . facade . get_project_title ( project_id2 ) [EOL] [EOL] self . project_title1 = project_title1 [EOL] self . project_title2 = project_title2 [EOL] [EOL] def diff_project_members ( self , project_id1 , project_id2 ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] [EOL] diff_message = [string] [EOL] [EOL] project_members1 = self . service . wrapper . get_all_project_members ( project_id1 ) [EOL] project_members2 = self . service . wrapper . get_all_project_members ( project_id2 ) [EOL] [EOL] [comment] [EOL] sorted_members1 = sorted_project_members ( project_members1 ) [EOL] sorted_members2 = sorted_project_members ( project_members2 ) [EOL] [EOL] user_ids1 = [ e [ [string] ] for e in sorted_members1 ] [EOL] user_ids2 = [ e [ [string] ] for e in sorted_members2 ] [EOL] [EOL] if user_ids1 != user_ids2 : [EOL] diff_message += ( f" [string] " f" [string] { set ( user_ids1 ) - set ( user_ids2 ) } [string] " f" [string] { set ( user_ids2 ) - set ( user_ids1 ) } [string] " ) [EOL] [EOL] return True , diff_message [EOL] [EOL] is_different = False [EOL] for member1 , member2 in zip ( sorted_members1 , sorted_members2 ) : [EOL] ignored_key = { [string] , [string] , [string] } [EOL] diff_result = list ( dictdiffer . diff ( member1 , member2 , ignore = ignored_key ) ) [EOL] if len ( diff_result ) > [number] : [EOL] is_different = True [EOL] diff_message += f" [string] { member1 [ [string] ] } [string] " f"{ pprint . pformat ( diff_result ) } [string] " [EOL] [EOL] if not is_different : [EOL] logger . info ( [string] ) [EOL] [EOL] return is_different , diff_message [EOL] [EOL] def validate_duplicated ( self , label_names1 , label_names2 ) : [EOL] [docstring] [EOL] [EOL] diff_message = [string] [EOL] [EOL] duplicated_set1 = annofabcli . utils . duplicated_set ( label_names1 ) [EOL] duplicated_set2 = annofabcli . utils . duplicated_set ( label_names2 ) [EOL] [EOL] flag = False [EOL] if len ( duplicated_set1 ) > [number] : [EOL] diff_message += f"{ self . project_title1 } [string] { duplicated_set1 } [string] " [EOL] flag = True [EOL] [EOL] if len ( duplicated_set2 ) > [number] : [EOL] diff_message += f"{ self . project_title2 } [string] { duplicated_set2 } [string] " [EOL] flag = True [EOL] [EOL] return flag , diff_message [EOL] [EOL] def diff_labels_of_annotation_specs ( self , labels1 , labels2 ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] [EOL] diff_message = [string] [EOL] [EOL] label_names1 = [ AnnofabApiFacade . get_label_name_en ( e ) for e in labels1 ] [EOL] label_names2 = [ AnnofabApiFacade . get_label_name_en ( e ) for e in labels2 ] [EOL] [EOL] [comment] [EOL] is_duplicated , duplicated_message = self . validate_duplicated ( label_names1 , label_names2 ) [EOL] diff_message += duplicated_message [EOL] if is_duplicated : [EOL] diff_message += f" [string] " [EOL] [EOL] if label_names1 != label_names2 : [EOL] diff_message += ( f" [string] " f" [string] { label_names1 } [string] " f" [string] { label_names2 } [string] " ) [EOL] [EOL] [comment] [EOL] is_different = True [EOL] label_names = list ( set ( label_names1 ) & set ( label_names2 ) ) [EOL] else : [EOL] is_different = False [EOL] label_names = label_names1 [EOL] [EOL] for label_name in label_names : [EOL] [EOL] def get_label_func ( label_name , label ) : [EOL] return AnnofabApiFacade . get_label_name_en ( label ) == label_name [EOL] [EOL] label1 = more_itertools . first_true ( labels1 , pred = functools . partial ( get_label_func , label_name ) ) [EOL] label2 = more_itertools . first_true ( labels2 , pred = functools . partial ( get_label_func , label_name ) ) [EOL] assert label1 is not None [EOL] assert label2 is not None [EOL] [EOL] diff_result = list ( dictdiffer . diff ( create_ignored_label ( label1 ) , create_ignored_label ( label2 ) ) ) [EOL] if len ( diff_result ) > [number] : [EOL] is_different = True [EOL] diff_message += f" [string] { label_name } [string] " f"{ pprint . pformat ( diff_result ) } [string] " [EOL] [EOL] else : [EOL] logger . debug ( f" [string] { label_name } [string] " ) [EOL] [EOL] if not is_different : [EOL] logger . info ( [string] ) [EOL] [EOL] return is_different , diff_message [EOL] [EOL] @ staticmethod def diff_inspection_phrases ( inspection_phrases1 , inspection_phrases2 ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] [EOL] diff_message = [string] [EOL] [EOL] [comment] [EOL] sorted_inspection_phrases1 = sorted_inspection_phrases ( inspection_phrases1 ) [EOL] sorted_inspection_phrases2 = sorted_inspection_phrases ( inspection_phrases2 ) [EOL] [EOL] phrase_ids1 = [ e [ [string] ] for e in sorted_inspection_phrases1 ] [EOL] phrase_ids2 = [ e [ [string] ] for e in sorted_inspection_phrases2 ] [EOL] [EOL] if phrase_ids1 != phrase_ids2 : [EOL] diff_message += ( f" [string] " f" [string] { set ( phrase_ids1 ) - set ( phrase_ids2 ) } [string] " f" [string] { set ( phrase_ids2 ) - set ( phrase_ids1 ) } [string] " ) [EOL] return True , diff_message [EOL] [EOL] is_different = False [EOL] for phrase1 , phrase2 in zip ( sorted_inspection_phrases1 , sorted_inspection_phrases2 ) : [EOL] diff_result = list ( dictdiffer . diff ( phrase1 , phrase2 ) ) [EOL] if len ( diff_result ) > [number] : [EOL] is_different = True [EOL] diff_message += f" [string] { phrase1 [ [string] ] } [string] " f"{ pprint . pformat ( diff_result ) } [string] " [EOL] [EOL] if not is_different : [EOL] logger . info ( [string] ) [EOL] [EOL] return is_different , diff_message [EOL] [EOL] def diff_annotation_specs ( self , project_id1 , project_id2 , diff_targets ) : [EOL] [docstring] [EOL] [EOL] diff_message = [string] [EOL] is_different = False [EOL] [EOL] annotation_specs1 , _ = self . service . api . get_annotation_specs ( project_id1 ) [EOL] annotation_specs2 , _ = self . service . api . get_annotation_specs ( project_id2 ) [EOL] [EOL] if DiffTarget . INSPECTION_PHRASES in diff_targets : [EOL] bool_result , message = self . diff_inspection_phrases ( annotation_specs1 [ [string] ] , annotation_specs2 [ [string] ] ) [EOL] is_different = is_different or bool_result [EOL] diff_message += message [EOL] [EOL] if DiffTarget . ANNOTATION_LABELS in diff_targets : [EOL] bool_result , message = self . diff_labels_of_annotation_specs ( annotation_specs1 [ [string] ] , annotation_specs2 [ [string] ] ) [EOL] is_different = is_different or bool_result [EOL] diff_message += message [EOL] [EOL] return is_different , diff_message [EOL] [EOL] def diff_project_settingss ( self , project_id1 , project_id2 ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] [EOL] diff_message = [string] [EOL] [EOL] config1 = self . service . api . get_project ( project_id1 ) [ [number] ] [ [string] ] [EOL] config2 = self . service . api . get_project ( project_id2 ) [ [number] ] [ [string] ] [EOL] [EOL] [comment] [EOL] diff_result = list ( dictdiffer . diff ( config1 , config2 ) ) [EOL] if len ( diff_result ) > [number] : [EOL] diff_message += f" [string] " f"{ pprint . pformat ( diff_result ) } [string] " [EOL] return True , diff_message [EOL] else : [EOL] logger . info ( [string] ) [EOL] return False , diff_message [EOL] [EOL] def validate_projects ( self , project_id1 , project_id2 ) : [EOL] [docstring] [EOL] roles = [ ProjectMemberRole . OWNER , ProjectMemberRole . ACCEPTER , ProjectMemberRole . TRAINING_DATA_USER ] [EOL] super ( ) . validate_project ( project_id1 , roles ) [EOL] super ( ) . validate_project ( project_id2 , roles ) [EOL] [EOL] def diff ( self , project_id1 , project_id2 , diff_targets ) : [EOL] self . validate_projects ( project_id1 , project_id2 ) [EOL] [EOL] logger . info ( f" [string] { self . project_title1 } [string] { project_id1 } [string] { self . project_title2 } [string] { project_id2 } [string] " ) [EOL] [EOL] diff_message = [string] [EOL] is_different = False [EOL] [EOL] if DiffTarget . MEMBERS in diff_targets : [EOL] bool_result , message = self . diff_project_members ( project_id1 , project_id2 ) [EOL] is_different = is_different or bool_result [EOL] diff_message += message [EOL] [EOL] if DiffTarget . SETTINGS in diff_targets : [EOL] bool_result , message = self . diff_project_settingss ( project_id1 , project_id2 ) [EOL] is_different = is_different or bool_result [EOL] diff_message += message [EOL] [EOL] if { DiffTarget . ANNOTATION_LABELS , DiffTarget . INSPECTION_PHRASES } <= set ( diff_targets ) : [EOL] bool_result , message = self . diff_annotation_specs ( project_id1 , project_id2 , diff_targets ) [EOL] is_different = is_different or bool_result [EOL] diff_message += message [EOL] [EOL] if is_different : [EOL] diff_message = ( f" [string] { self . project_title1 } [string] { project_id1 } [string] " f"{ self . project_title2 } [string] { project_id2 } [string] " + diff_message ) [EOL] return is_different , diff_message [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id1 = args . project_id1 [EOL] project_id2 = args . project_id2 [EOL] [EOL] diff_targets = [ DiffTarget ( e ) for e in args . target ] [EOL] _ , diff_message = self . diff ( project_id1 , project_id2 , diff_targets ) [EOL] print ( diff_message ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] choices = [ DiffTarget . ANNOTATION_LABELS , DiffTarget . INSPECTION_PHRASES , DiffTarget . MEMBERS , DiffTarget . SETTINGS ] [EOL] [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , choices = [ e . value for e in choices ] , default = [ [string] , [string] , [string] , [string] ] , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] DiffProjecs ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] + [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 $DiffResult$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[DiffTarget]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.List[DiffTarget]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[DiffTarget]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DiffTarget]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[DiffTarget]$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $typing.List[annofabcli.project.diff_projects.DiffTarget]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[annofabcli.project.diff_projects.DiffTarget]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , List [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from enum import Enum [EOL] from typing import Any , Callable [EOL] [EOL] from annofabapi . models import JobStatus , JobType [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] class DownloadTarget ( Enum ) : [EOL] TASK = [string] [EOL] INPUT_DATA = [string] [EOL] INSPECTION_COMMENT = [string] [EOL] TASK_HISTORY = [string] [EOL] TASK_HISTORY_EVENT = [string] [EOL] SIMPLE_ANNOTATION = [string] [EOL] FULL_ANNOTATION = [string] [EOL] [EOL] [EOL] class Download ( AbstractCommandLineInterface ) : [EOL] def is_job_progress ( self , project_id , job_type ) : [EOL] job_list = self . service . api . get_project_job ( project_id , query_params = { [string] : job_type . value } ) [ [number] ] [ [string] ] [EOL] if len ( job_list ) > [number] : [EOL] if job_list [ [number] ] [ [string] ] == JobStatus . PROGRESS . value : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def update_file_and_wait ( self , project_id , job_type , update_func , wait_options ) : [EOL] [docstring] [EOL] MAX_WAIT_MINUTUE = wait_options . max_tries * wait_options . interval / [number] [EOL] [EOL] if self . is_job_progress ( project_id , job_type = job_type ) : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . info ( f" [string] " ) [EOL] update_func ( project_id ) [EOL] [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] result = self . service . wrapper . wait_for_completion ( project_id , job_type = job_type , job_access_interval = wait_options . interval , max_job_access = wait_options . max_tries , ) [EOL] if result : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] [EOL] def download ( self , target , project_id , output , latest , wait_options ) : [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f"{ project_title } [string] { target . value } [string] " ) [EOL] [EOL] if target == DownloadTarget . TASK : [EOL] if latest : [EOL] self . update_file_and_wait ( project_id , JobType . GEN_TASKS_LIST , self . service . api . post_project_tasks_update , wait_options ) [EOL] [EOL] self . service . wrapper . download_project_tasks_url ( project_id , output ) [EOL] [EOL] elif target == DownloadTarget . INPUT_DATA : [EOL] if latest : [EOL] self . update_file_and_wait ( project_id , JobType . GEN_INPUTS_LIST , self . service . api . post_project_inputs_update , wait_options ) [EOL] [EOL] self . service . wrapper . download_project_inputs_url ( project_id , output ) [EOL] [EOL] elif target == DownloadTarget . INSPECTION_COMMENT : [EOL] self . service . wrapper . download_project_inspections_url ( project_id , output ) [EOL] [EOL] elif target == DownloadTarget . TASK_HISTORY : [EOL] self . service . wrapper . download_project_task_histories_url ( project_id , output ) [EOL] [EOL] elif target == DownloadTarget . TASK_HISTORY_EVENT : [EOL] self . service . wrapper . download_project_task_history_events_url ( project_id , output ) [EOL] [EOL] elif target in [ DownloadTarget . SIMPLE_ANNOTATION , DownloadTarget . FULL_ANNOTATION , DownloadTarget . TASK ] : [EOL] if latest : [EOL] self . update_file_and_wait ( project_id , JobType . GEN_ANNOTATION , self . service . api . post_annotation_archive_update , wait_options ) [EOL] [EOL] if target == DownloadTarget . SIMPLE_ANNOTATION : [EOL] self . service . wrapper . download_annotation_archive ( project_id , output , v2 = True ) [EOL] [EOL] elif target == DownloadTarget . FULL_ANNOTATION : [EOL] self . service . wrapper . download_full_annotation_archive ( project_id , output ) [EOL] [EOL] logger . info ( f" [string] { output }" ) [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] download_target = DownloadTarget ( args . target ) [EOL] if args . latest : [EOL] if download_target not in [ DownloadTarget . TASK , DownloadTarget . INPUT_DATA , DownloadTarget . SIMPLE_ANNOTATION , DownloadTarget . FULL_ANNOTATION , ] : [EOL] logger . warning ( f" [string] " ) [EOL] [EOL] if download_target == DownloadTarget . FULL_ANNOTATION : [EOL] logger . warning ( f" [string] " ) [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] self . download ( DownloadTarget ( args . target ) , args . project_id , output = args . output , latest = args . latest , wait_options = wait_options , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] Download ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] target_choices = [ e . value for e in DownloadTarget ] [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = target_choices , help = [string] [string] [string] [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = ( [string] + [string] [string] ) [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $annofabapi.models.JobType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $typing.Callable[[builtins.str],typing.Any]$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $builtins.float$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $annofabapi.models.JobType$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],typing.Any]$ 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $annofabapi.models.JobType$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $DownloadTarget$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.project.download.DownloadTarget$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $annofabcli.project.download.DownloadTarget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $annofabcli.project.download.DownloadTarget$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] [docstring] [EOL] import argparse [EOL] import logging [EOL] from enum import Enum [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import more_itertools [EOL] import pandas [EOL] from annofabapi . models import AdditionalDataDefinitionV1 , SingleAnnotation [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . visualize import AddProps [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class GroupBy ( Enum ) : [EOL] TASK_ID = [string] [EOL] INPUT_DATA_ID = [string] [EOL] [EOL] [EOL] class ListAnnotationCount ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] self . visualize = AddProps ( self . service , args . project_id ) [EOL] [EOL] @ staticmethod def _modify_attribute_of_query ( attribute_query , additional_data_definition ) : [EOL] if [string] in attribute_query : [EOL] choice_info = more_itertools . first_true ( additional_data_definition [ [string] ] , pred = lambda e : AnnofabApiFacade . get_choice_name_en ( e ) == attribute_query [ [string] ] , ) [EOL] [EOL] if choice_info is not None : [EOL] attribute_query [ [string] ] = choice_info [ [string] ] [EOL] else : [EOL] logger . warning ( f" [string] { attribute_query [ [string] ] } [string] " ) [EOL] [EOL] return attribute_query [EOL] [EOL] @ staticmethod def _find_additional_data_with_name ( additional_data_definitions , name ) : [EOL] [EOL] additional_data_definition = more_itertools . first_true ( additional_data_definitions , pred = lambda e : AnnofabApiFacade . get_additional_data_definition_name_en ( e ) == name , ) [EOL] return additional_data_definition [EOL] [EOL] @ staticmethod def _find_additional_data_with_id ( additional_data_definitions , definition_id ) : [EOL] [EOL] additional_data_definition = more_itertools . first_true ( additional_data_definitions , pred = lambda e : e [ [string] ] == definition_id ) [EOL] return additional_data_definition [EOL] [EOL] def _modify_attributes_of_query ( self , attributes_of_query , definitions ) : [EOL] for attribute_query in attributes_of_query : [EOL] definition_name = attribute_query . get ( [string] ) [EOL] if definition_name is not None : [EOL] additional_data_definition = self . _find_additional_data_with_name ( definitions , definition_name ) [EOL] if additional_data_definition is None : [EOL] logger . warning ( f" [string] { attribute_query [ [string] ] } [string] " ) [EOL] continue [EOL] [EOL] if additional_data_definition is not None : [EOL] attribute_query [ [string] ] = additional_data_definition [ [string] ] [EOL] [EOL] definition_id = attribute_query [ [string] ] [EOL] additional_data_definition = self . _find_additional_data_with_id ( definitions , definition_id ) [EOL] if additional_data_definition is None : [EOL] logger . warning ( f" [string] { attribute_query [ [string] ] } [string] " ) [EOL] continue [EOL] [EOL] self . _modify_attribute_of_query ( attribute_query , additional_data_definition ) [EOL] [EOL] return attributes_of_query [EOL] [EOL] def _modify_annotation_query ( self , project_id , annotation_query , task_id = None ) : [EOL] [docstring] [EOL] [EOL] annotation_specs , _ = self . service . api . get_annotation_specs ( project_id ) [EOL] specs_labels = annotation_specs [ [string] ] [EOL] [EOL] [comment] [EOL] if [string] in annotation_query : [EOL] label_name_en = annotation_query [ [string] ] [EOL] label = more_itertools . first_true ( specs_labels , pred = lambda e : AnnofabApiFacade . get_label_name_en ( e ) == label_name_en ) [EOL] if label is not None : [EOL] annotation_query [ [string] ] = label [ [string] ] [EOL] else : [EOL] logger . warning ( f" [string] { label_name_en } [string] " ) [EOL] [EOL] if annotation_query . keys ( ) >= { [string] , [string] } : [EOL] label = more_itertools . first_true ( specs_labels , pred = lambda e : e [ [string] ] == annotation_query [ [string] ] ) [EOL] if label is not None : [EOL] self . _modify_attributes_of_query ( annotation_query [ [string] ] , label [ [string] ] ) [EOL] else : [EOL] logger . warning ( f" [string] { annotation_query [ [string] ] } [string] " ) [EOL] [EOL] if task_id is not None : [EOL] annotation_query [ [string] ] = task_id [EOL] annotation_query [ [string] ] = True [EOL] [EOL] return annotation_query [EOL] [EOL] @ staticmethod def aggregate_annotations ( annotations , group_by ) : [EOL] df = pandas . DataFrame ( annotations ) [EOL] df = df [ [ [string] , [string] ] ] [EOL] df [ [string] ] = [number] [EOL] [EOL] if group_by == GroupBy . INPUT_DATA_ID : [EOL] return df . groupby ( [ [string] , [string] ] , as_index = False ) . count ( ) [EOL] [EOL] elif group_by == GroupBy . TASK_ID : [EOL] return df . groupby ( [ [string] ] , as_index = False ) . count ( ) . drop ( [ [string] ] , axis = [number] ) [EOL] [EOL] else : [EOL] return pandas . DataFrame ( ) [EOL] [EOL] def get_annotations ( self , project_id , annotation_query , task_id = None ) : [EOL] annotation_query = self . _modify_annotation_query ( project_id , annotation_query , task_id ) [EOL] logger . debug ( f" [string] { annotation_query }" ) [EOL] annotations = self . service . wrapper . get_all_annotation_list ( project_id , query_params = { [string] : annotation_query } ) [EOL] return annotations [EOL] [EOL] def list_annotations ( self , project_id , annotation_query , group_by , task_id_list ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] all_annotations = [ ] [EOL] if len ( task_id_list ) > [number] : [EOL] for task_id in task_id_list : [EOL] annotations = self . get_annotations ( project_id , annotation_query , task_id ) [EOL] logger . debug ( f" [string] { task_id } [string] { len ( annotations ) }" ) [EOL] if len ( annotations ) == [number] : [EOL] logger . warning ( [string] ) [EOL] all_annotations . extend ( annotations ) [EOL] else : [EOL] annotations = self . get_annotations ( project_id , annotation_query ) [EOL] if len ( annotations ) == [number] : [EOL] logger . warning ( [string] ) [EOL] all_annotations . extend ( annotations ) [EOL] [EOL] logger . debug ( f" [string] { len ( all_annotations ) }" ) [EOL] if len ( all_annotations ) > [number] : [EOL] df = self . aggregate_annotations ( all_annotations , group_by ) [EOL] self . print_csv ( df ) [EOL] else : [EOL] logger . info ( f" [string] " ) [EOL] return [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] annotation_query = annofabcli . common . cli . get_json_from_args ( args . annotation_query ) [EOL] [EOL] group_by = GroupBy ( args . group_by ) [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] self . list_annotations ( args . project_id , annotation_query = annotation_query , group_by = group_by , task_id_list = task_id_list ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListAnnotationCount ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_task_id ( required = False , help_message = ( [string] [string] [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = [ GroupBy . TASK_ID . value , GroupBy . INPUT_DATA_ID . value ] , default = GroupBy . TASK_ID . value , help = [string] , ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.common.visualize.AddProps$ 0 0 0 0 0 $annofabapi.Resource$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $annofabapi.models.AdditionalDataDefinitionV1$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $annofabapi.models.AdditionalDataDefinitionV1$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Optional[annofabapi.models.AdditionalDataDefinitionV1]$ 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[annofabapi.models.AdditionalDataDefinitionV1]$ 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.AdditionalDataDefinitionV1]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $pandas.DataFrame$ 0 $typing.List[annofabapi.models.SingleAnnotation]$ 0 $GroupBy$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[annofabapi.models.SingleAnnotation]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $GroupBy$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GroupBy$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.SingleAnnotation]$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $GroupBy$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $GroupBy$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 $annofabcli.annotation.list_annotation_count.GroupBy$ 0 0 0 $argparse.Namespace$ 0 $annofabcli.annotation.list_annotation_count.GroupBy$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $annofabcli.annotation.list_annotation_count.GroupBy$ 0 $annofabcli.annotation.list_annotation_count.GroupBy$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import json [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] import requests [EOL] from annofabapi . models import AnnotationDataHoldingType [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DumpAnnotation ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def dump_annotation_for_input_data ( self , project_id , task_id , input_data_id , task_dir ) : [EOL] annotation , _ = self . service . api . get_editor_annotation ( project_id , task_id , input_data_id ) [EOL] json_path = task_dir / f"{ input_data_id } [string] " [EOL] json_path . write_text ( json . dumps ( annotation , ensure_ascii = False ) , encoding = [string] ) [EOL] [EOL] details = annotation [ [string] ] [EOL] outer_details = [ e for e in details if e [ [string] ] == AnnotationDataHoldingType . OUTER . value ] [EOL] if len ( outer_details ) == [number] : [EOL] return [EOL] [EOL] outer_dir = task_dir / input_data_id [EOL] outer_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] for detail in outer_details : [EOL] if not detail [ [string] ] == AnnotationDataHoldingType . OUTER . value : [EOL] continue [EOL] [EOL] outer_file_url = detail [ [string] ] [EOL] response = self . service . api . session . get ( outer_file_url ) [EOL] if response . status_code != requests . codes . ok : [EOL] logger . warning ( f" [string] " f" [string] { response . status_code } [string] { response . url } [string] { response . text }" ) [EOL] continue [EOL] [EOL] annotation_id = detail [ [string] ] [EOL] outer_file_path = outer_dir / f"{ annotation_id }" [EOL] outer_file_path . write_bytes ( response . content ) [EOL] [EOL] def dump_annotation_for_task ( self , project_id , task_id , output_dir ) : [EOL] [docstring] [EOL] task = self . service . wrapper . get_task_or_none ( project_id , task_id ) [EOL] if task is None : [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] return False [EOL] [EOL] input_data_id_list = task [ [string] ] [EOL] task_dir = output_dir / task_id [EOL] task_dir . mkdir ( exist_ok = True , parents = True ) [EOL] logger . debug ( f" [string] { task_id } [string] { task_dir } [string] " ) [EOL] for input_data_id in input_data_id_list : [EOL] self . dump_annotation_for_input_data ( project_id , task_id , input_data_id , task_dir = task_dir ) [EOL] [EOL] return True [EOL] [EOL] def dump_annotation ( self , project_id , task_id_list , output_dir ) : [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f" [string] { project_title } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] output_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] for task_id in task_id_list : [EOL] self . dump_annotation_for_task ( project_id , task_id , output_dir = output_dir ) [EOL] [EOL] logger . info ( f" [string] " ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] output_dir = Path ( args . output_dir ) [EOL] self . dump_annotation ( project_id , task_id_list , output_dir = output_dir ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] DumpAnnotation ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $builtins.str$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $pathlib.Path$ 0 0 0 $argparse.Namespace$ 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import requests [EOL] from annofabapi . dataclass . task import Task [EOL] from annofabapi . models import ProjectMemberRole , TaskStatus [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . annotation . dump_annotation import DumpAnnotation [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , ) [EOL] from annofabcli . common . facade import AdditionalData , AdditionalDataForCli , AnnotationQuery , AnnotationQueryForCli [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ChangeAttributesOfAnnotation ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] self . dump_annotation_obj = DumpAnnotation ( service , facade , args ) [EOL] [EOL] def change_attributes_for_task ( self , project_id , task_id , annotation_query , attributes , force = False , backup_dir = None , ) : [EOL] [docstring] [EOL] dict_task = self . service . wrapper . get_task_or_none ( project_id , task_id ) [EOL] if dict_task is None : [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] return [EOL] [EOL] task = Task . from_dict ( dict_task ) [comment] [EOL] logger . info ( f" [string] { task . task_id } [string] { task . phase . value } [string] { task . status . value } [string] " f" [string] { task . updated_datetime }" ) [EOL] if task . status == TaskStatus . WORKING : [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] return [EOL] [EOL] if not force : [EOL] if task . status == TaskStatus . COMPLETE : [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] return [EOL] [EOL] annotation_list = self . facade . get_annotation_list_for_task ( project_id , task_id , query = annotation_query ) [EOL] logger . info ( f" [string] { task_id } [string] { len ( annotation_list ) }" ) [EOL] if len ( annotation_list ) == [number] : [EOL] logger . info ( f" [string] { task_id } [string] " ) [EOL] return [EOL] [EOL] if not self . confirm_processing ( f" [string] { task_id } [string] " ) : [EOL] return [EOL] [EOL] if backup_dir is not None : [EOL] self . dump_annotation_obj . dump_annotation_for_task ( project_id , task_id , output_dir = backup_dir ) [EOL] [EOL] try : [EOL] self . facade . change_annotation_attributes ( project_id , annotation_list , attributes ) [EOL] logger . info ( f" [string] { task_id } [string] " ) [EOL] except requests . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] [EOL] def change_annotation_attributes ( self , project_id , task_id_list , annotation_query , attributes , force = False , backup_dir = None , ) : [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER ] ) [EOL] [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f" [string] { project_title } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] if backup_dir is not None : [EOL] backup_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] for task_index , task_id in enumerate ( task_id_list ) : [EOL] logger . info ( f"{ task_index + [number] } [string] { len ( task_id_list ) } [string] { task_id } [string] " ) [EOL] self . change_attributes_for_task ( project_id , task_id , annotation_query = annotation_query , attributes = attributes , force = force , backup_dir = backup_dir , ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] [EOL] dict_annotation_query = get_json_from_args ( args . annotation_query ) [EOL] annotation_query_for_cli = AnnotationQueryForCli . from_dict ( dict_annotation_query ) [comment] [EOL] try : [EOL] annotation_query = self . facade . to_annotation_query_from_cli ( project_id , annotation_query_for_cli ) [EOL] except ValueError as e : [EOL] print ( f" [string] { e }" , file = sys . stderr ) [EOL] return [EOL] [EOL] attributes_of_dict = get_json_from_args ( args . attributes ) [EOL] attributes_for_cli = [ AdditionalDataForCli . from_dict ( e ) for e in attributes_of_dict ] [EOL] try : [EOL] attributes = self . facade . to_attributes_from_cli ( project_id , annotation_query . label_id , attributes_for_cli ) [EOL] except ValueError as e : [EOL] print ( f" [string] { e }" , file = sys . stderr ) [EOL] return [EOL] [EOL] if args . backup is None : [EOL] print ( [string] , file = sys . stderr ) [EOL] if not self . confirm_processing ( [string] ) : [EOL] return [EOL] backup_dir = None [EOL] else : [EOL] backup_dir = Path ( args . backup ) [EOL] [EOL] self . change_annotation_attributes ( project_id , task_id_list , annotation_query = annotation_query , attributes = attributes , force = args . force , backup_dir = backup_dir , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ChangeAttributesOfAnnotation ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( ) [EOL] [EOL] EXAMPLE_ANNOTATION_QUERY = ( [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] [string] [string] f" [string] { EXAMPLE_ANNOTATION_QUERY } [string] " , ) [EOL] [EOL] EXAMPLE_ATTIRBUTES = [string] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] [string] f" [string] { EXAMPLE_ATTIRBUTES } [string] " , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = False , help = [string] , ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = ( [string] [string] ) [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.annotation.dump_annotation.DumpAnnotation$ 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 $typing.List[annofabcli.common.facade.AdditionalData]$ 0 $builtins.bool$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 $builtins.str$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $annofabcli.common.facade.AnnotationQuery$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[annofabcli.common.facade.AdditionalData]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 $typing.List[annofabcli.common.facade.AdditionalData]$ 0 $builtins.bool$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $annofabcli.common.facade.AnnotationQuery$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 $typing.List[annofabcli.common.facade.AdditionalData]$ 0 $typing.List[annofabcli.common.facade.AdditionalData]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Optional[pathlib.Path]$ 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $annofabcli.common.facade.AnnotationQuery$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.List[annofabcli.common.facade.AdditionalData.ForCli]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 0 0 $typing.List[annofabcli.common.facade.AdditionalData.ForCli]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 $annofabcli.common.facade.AnnotationQuery$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . annotation . change_annotation_attributes [EOL] import annofabcli . annotation . delete_annotation [EOL] import annofabcli . annotation . dump_annotation [EOL] import annofabcli . annotation . import_annotation [EOL] import annofabcli . annotation . list_annotation_count [EOL] import annofabcli . annotation . restore_anotation [EOL] import annofabcli . common . cli [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . annotation . change_annotation_attributes . add_parser ( subparsers ) [EOL] annofabcli . annotation . delete_annotation . add_parser ( subparsers ) [EOL] annofabcli . annotation . dump_annotation . add_parser ( subparsers ) [EOL] annofabcli . annotation . import_annotation . add_parser ( subparsers ) [EOL] annofabcli . annotation . list_annotation_count . add_parser ( subparsers ) [EOL] annofabcli . annotation . restore_anotation . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . organization_member . list_organization_member [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . organization_member . list_organization_member . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ListOrganizationMember ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def print_organization_member_list ( self , organization_name ) : [EOL] [docstring] [EOL] [EOL] organization_member_list = self . service . wrapper . get_all_organization_members ( organization_name ) [EOL] logger . debug ( f" [string] { len ( organization_member_list ) }" ) [EOL] if len ( organization_member_list ) == [number] : [EOL] logger . warning ( [string] ) [EOL] [EOL] self . print_according_to_format ( organization_member_list ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] self . print_organization_member_list ( args . organization ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListOrganizationMember ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] parser . add_argument ( [string] , [string] , required = True , type = str , help = [string] ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON , FormatArgument . USER_ID_LIST ] , default = FormatArgument . CSV , ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] argument_parser . add_query ( ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import List [EOL] [EOL] import annofabapi [EOL] from annofabapi . models import JobType , ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_list_from_args , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DeleteJobMain : [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] self . facade = AnnofabApiFacade ( service ) [EOL] [EOL] def delete_job_list ( self , project_id , job_type , job_id_list ) : [EOL] for job_id in job_id_list : [EOL] logger . debug ( f" [string] { job_id } [string] " ) [EOL] try : [EOL] self . service . api . delete_project_job ( project_id , job_type . value , job_id ) [EOL] except Exception as e : [comment] [EOL] logger . warning ( e ) [EOL] [EOL] [EOL] class DeleteJob ( AbstractCommandLineInterface ) : [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , project_member_roles = [ ProjectMemberRole . OWNER ] ) [EOL] [EOL] job_type = JobType ( args . job_type ) [EOL] job_id_list = get_list_from_args ( args . job_id ) [EOL] [EOL] main_obj = DeleteJobMain ( self . service ) [EOL] main_obj . delete_job_list ( args . project_id , job_type = job_type , job_id_list = job_id_list ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] DeleteJob ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] job_choices = [ e . value for e in JobType ] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = job_choices , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , required = True , help = [string] + [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $annofabcli.job.delete_job.DeleteJobMain$ 0 0 0 0 0 0 0 0 $annofabcli.job.delete_job.DeleteJobMain$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import sys [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] from annofabapi . models import JobInfo , JobType , Project [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ListLastJob ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def get_last_job ( self , project_id , job_type ) : [EOL] [docstring] [EOL] query_params = { [string] : job_type . value } [EOL] content , _ = self . service . api . get_project_job ( project_id , query_params ) [EOL] job_list = content [ [string] ] [EOL] if len ( job_list ) == [number] : [EOL] logger . debug ( f" [string] { project_id } [string] { job_type . value } [string] " ) [EOL] return None [EOL] else : [EOL] return job_list [ - [number] ] [EOL] [EOL] def get_project_info ( self , project_id , project , add_details = False ) : [EOL] [docstring] [EOL] [EOL] project_info = { [string] : project [ [string] ] , [string] : project [ [string] ] } [EOL] [EOL] if add_details : [EOL] project_info [ [string] ] = project [ [string] ] [ [string] ] [EOL] [EOL] annotation_specs_history = self . service . api . get_annotation_specs_histories ( project_id ) [ [number] ] [EOL] project_info [ [string] ] = annotation_specs_history [ - [number] ] [ [string] ] [EOL] [EOL] return project_info [EOL] [EOL] @ annofabcli . utils . allow_404_error def get_project ( self , project_id ) : [EOL] project , _ = self . service . api . get_project ( project_id ) [EOL] return project [EOL] [EOL] def get_last_job_list ( self , project_id_list , job_type , add_details = False ) : [EOL] job_list = [ ] [EOL] for project_id in project_id_list : [EOL] project = self . get_project ( project_id ) [EOL] [EOL] if project is None : [EOL] logger . warning ( f" [string] { project_id } [string] " ) [EOL] continue [EOL] [EOL] project_info = self . get_project_info ( project_id = project_id , add_details = add_details , project = project ) [EOL] job = self . get_last_job ( project_id , job_type ) [EOL] if job is not None : [EOL] job_list . append ( { ** project_info , ** job } ) [EOL] else : [EOL] job_list . append ( project_info ) [EOL] [EOL] return job_list [EOL] [EOL] def print_job_list ( self , project_id_list , job_type , add_details = False ) : [EOL] [docstring] [EOL] [EOL] job_list = self . get_last_job_list ( project_id_list , job_type = job_type , add_details = add_details ) [EOL] logger . info ( f"{ len ( job_list ) } [string] { job_type . value } [string] " ) [EOL] self . print_according_to_format ( job_list ) [EOL] [EOL] def get_project_id_list ( self , organization_name ) : [EOL] [docstring] [EOL] my_account , _ = self . service . api . get_my_account ( ) [EOL] query_params = { [string] : [string] , [string] : my_account [ [string] ] } [EOL] project_list = self . service . wrapper . get_all_projects_of_organization ( organization_name , query_params = query_params ) [EOL] return [ e [ [string] ] for e in project_list ] [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] job_type = JobType ( args . job_type ) [EOL] [EOL] if args . organization is not None : [EOL] project_id_list = self . get_project_id_list ( args . organization ) [EOL] [EOL] elif args . project_id is not None : [EOL] project_id_list = annofabcli . common . cli . get_list_from_args ( args . project_id ) [EOL] [EOL] else : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [EOL] [EOL] self . print_job_list ( project_id_list , job_type = job_type , add_details = args . add_details ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListLastJob ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] job_choices = [ e . value for e in JobType ] [EOL] parser . add_argument ( [string] , type = str , choices = job_choices , required = True , help = [string] ) [EOL] [EOL] list_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] list_group . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] , ) [EOL] [EOL] list_group . add_argument ( [string] , [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON ] , default = FormatArgument . CSV ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] argument_parser . add_query ( ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[annofabapi.models.JobInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $annofabapi.models.Project$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $annofabapi.models.Project$ 0 0 0 0 0 0 $annofabapi.models.Project$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $annofabapi.models.Project$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.Project$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[annofabapi.models.JobInfo]$ 0 0 0 $typing.List[builtins.str]$ 0 $annofabapi.models.JobType$ 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.JobType$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 $annofabapi.models.JobType$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $annofabapi.models.JobType$ 0 $annofabapi.models.JobType$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.JobType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . job . delete_job [EOL] import annofabcli . job . list_job [EOL] import annofabcli . job . list_last_job [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] [EOL] annofabcli . job . delete_job . add_parser ( subparsers ) [EOL] annofabcli . job . list_job . add_parser ( subparsers ) [EOL] annofabcli . job . list_last_job . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import copy [EOL] import logging [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] from annofabapi . models import JobInfo , JobType [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ListJob ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def get_job_list ( self , project_id , job_type , job_query = None ) : [EOL] [docstring] [EOL] [EOL] if job_query is not None : [EOL] query_params = copy . deepcopy ( job_query ) [EOL] else : [EOL] query_params = { } [EOL] [EOL] query_params [ [string] ] = job_type . value [EOL] [EOL] logger . debug ( f" [string] { query_params }" ) [EOL] job_list = self . service . wrapper . get_all_project_job ( project_id , query_params = query_params ) [EOL] return job_list [EOL] [EOL] def print_job_list ( self , project_id , job_type , job_query = None ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] job_list = self . get_job_list ( project_id , job_type = job_type , job_query = job_query ) [EOL] logger . info ( f" [string] { len ( job_list ) }" ) [EOL] self . print_according_to_format ( job_list ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [comment] [EOL] job_type = JobType ( args . job_type ) [EOL] self . print_job_list ( args . project_id , job_type = job_type , job_query = None ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListJob ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] job_choices = [ e . value for e in JobType ] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = job_choices , required = True , help = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON ] , default = FormatArgument . CSV ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] argument_parser . add_query ( ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.JobInfo]$ 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $annofabapi.models.JobType$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.models.JobType$ 0 $annofabapi.models.JobType$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Tuple , List , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import asyncio [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_list_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . enums import FormatArgument [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] def millisecond_to_hour ( millisecond ) : [EOL] return millisecond / [number] / [number] [EOL] [EOL] [EOL] class ListInputDataMergedTaskMain : [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] self . facade = AnnofabApiFacade ( service ) [EOL] [EOL] @ staticmethod def _to_task_list_based_input_data ( task_list ) : [EOL] new_all_task_list = [ ] [EOL] for task in task_list : [EOL] for input_data_id in task [ [string] ] : [EOL] new_task = { [string] : task [ [string] ] , [string] : task [ [string] ] , [string] : task [ [string] ] , [string] : millisecond_to_hour ( task [ [string] ] ) , [string] : input_data_id , } [EOL] new_all_task_list . append ( new_task ) [EOL] return new_all_task_list [EOL] [EOL] @ staticmethod def _filter_input_data ( df_input_data , input_data_id_list = None , input_data_name_list = None , ) : [EOL] df = df_input_data [EOL] if input_data_id_list is not None : [EOL] df = df [ df [ [string] ] . isin ( input_data_id_list ) ] [EOL] [EOL] if input_data_name_list is not None : [EOL] df = pandas . concat ( [ df [ df [ [string] ] . str . lower ( ) . str . contains ( input_data_name . lower ( ) ) ] for input_data_name in input_data_name_list ] ) [EOL] return df [EOL] [EOL] def create_input_data_merged_task ( self , input_data_list , task_list , input_data_id_list = None , input_data_name_list = None , ) : [EOL] new_task_list = self . _to_task_list_based_input_data ( task_list ) [EOL] [EOL] df_input_data = pandas . DataFrame ( input_data_list ) [EOL] df_input_data = self . _filter_input_data ( df_input_data , input_data_id_list = input_data_id_list , input_data_name_list = input_data_name_list ) [EOL] [EOL] df_task = pandas . DataFrame ( new_task_list ) [EOL] [EOL] df_merged = pandas . merge ( df_input_data , df_task , how = [string] , on = [string] ) [EOL] [EOL] return df_merged [EOL] [EOL] [EOL] class ListInputDataMergedTask ( AbstractCommandLineInterface ) : [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] if args . project_id is None and ( args . input_data_json is None or args . task_json is None ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] if ( args . input_data_json is None and args . task_json is not None ) or ( args . input_data_json is not None and args . task_json is None ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def download_json_files ( self , project_id , output_dir , is_latest , wait_options ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] gather = asyncio . gather ( downloading_obj . download_input_data_json_with_async ( project_id , dest_path = str ( output_dir / [string] ) , is_latest = is_latest , wait_options = wait_options , ) , downloading_obj . download_task_json_with_async ( project_id , dest_path = str ( output_dir / [string] ) , is_latest = is_latest , wait_options = wait_options ) , ) [EOL] loop . run_until_complete ( gather ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] project_id = args . project_id [EOL] if project_id is not None : [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] self . download_json_files ( project_id , cache_dir , args . latest , wait_options ) [EOL] task_json_path = cache_dir / [string] [EOL] input_data_json_path = cache_dir / [string] [EOL] else : [EOL] task_json_path = args . task_json [EOL] input_data_json_path = args . input_data_json [EOL] [EOL] with open ( task_json_path , encoding = [string] ) as f : [EOL] task_list = json . load ( f ) [EOL] [EOL] with open ( input_data_json_path , encoding = [string] ) as f : [EOL] input_data_list = json . load ( f ) [EOL] [EOL] input_data_id_list = get_list_from_args ( args . input_data_id ) if args . input_data_id is not None else None [EOL] input_data_name_list = get_list_from_args ( args . input_data_name ) if args . input_data_name is not None else None [EOL] [EOL] main_obj = ListInputDataMergedTaskMain ( self . service ) [EOL] df_merged = main_obj . create_input_data_merged_task ( input_data_list = input_data_list , task_list = task_list , input_data_id_list = input_data_id_list , input_data_name_list = input_data_name_list , ) [EOL] annofabcli . utils . print_according_to_format ( df_merged , arg_format = FormatArgument ( FormatArgument . CSV ) , output = self . output , csv_format = self . csv_format ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListInputDataMergedTask ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , help = [string] ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $builtins.bool$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any,typing.Any]]$ 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabcli.input_data.list_input_data_merged_task.ListInputDataMergedTaskMain$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $annofabcli.input_data.list_input_data_merged_task.ListInputDataMergedTaskMain$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import functools [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import multiprocessing [EOL] import sys [EOL] from functools import partial [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] import annofabapi [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstracCommandCinfirmInterface , AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class UpdateMetadataMain ( AbstracCommandCinfirmInterface ) : [EOL] def __init__ ( self , service , all_yes = False ) : [EOL] self . service = service [EOL] AbstracCommandCinfirmInterface . __init__ ( self , all_yes ) [EOL] [EOL] def set_metadata_to_input_data ( self , project_id , input_data_id , metadata , input_data_index = None ) : [EOL] logging_prefix = f"{ input_data_index + [number] } [string] " if input_data_index is not None else [string] [EOL] [EOL] input_data = self . service . wrapper . get_input_data_or_none ( project_id , input_data_id ) [EOL] logger . debug ( f"{ logging_prefix } [string] { input_data [ [string] ] } [string] " f" [string] { input_data [ [string] ] }" ) [EOL] if not self . confirm_processing ( f" [string] { input_data [ [string] ] }" ) : [EOL] return False [EOL] [EOL] input_data [ [string] ] = input_data [ [string] ] [EOL] input_data [ [string] ] = metadata [EOL] self . service . api . put_input_data ( project_id , input_data_id , request_body = input_data ) [EOL] logger . debug ( f"{ logging_prefix } [string] { input_data [ [string] ] }" ) [EOL] return True [EOL] [EOL] def set_metadata_to_input_data_wrapper ( self , tpl , project_id , metadata ) : [EOL] input_data_index , input_data_id = tpl [EOL] return self . set_metadata_to_input_data ( project_id , input_data_id , metadata = metadata , input_data_index = input_data_index ) [EOL] [EOL] def update_metadata_of_input_data ( self , project_id , input_data_id_list , metadata , parallelism = None , ) : [EOL] logger . info ( f"{ len ( input_data_id_list ) } [string] { metadata } [string] " ) [EOL] [EOL] success_count = [number] [EOL] [EOL] if parallelism is not None : [EOL] partial_func = partial ( self . set_metadata_to_input_data , project_id = project_id , metadata = metadata , ) [EOL] with multiprocessing . Pool ( parallelism ) as pool : [EOL] result_bool_list = pool . map ( partial_func , enumerate ( input_data_id_list ) ) [EOL] success_count = len ( [ e for e in result_bool_list if e ] ) [EOL] [EOL] else : [EOL] [comment] [EOL] for input_data_index , input_data_id in enumerate ( input_data_id_list ) : [EOL] result = self . set_metadata_to_input_data ( project_id , input_data_id , metadata = metadata , input_data_index = input_data_index ) [EOL] if result : [EOL] success_count += [number] [EOL] [EOL] logger . info ( f"{ success_count } [string] { len ( input_data_id_list ) } [string] " ) [EOL] [EOL] [EOL] class UpdateMetadata ( AbstractCommandLineInterface ) : [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] [EOL] if args . parallelism is not None and not args . yes : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] input_data_id_list = annofabcli . common . cli . get_list_from_args ( args . input_data_id ) [EOL] metadata = annofabcli . common . cli . get_json_from_args ( args . metadata ) [EOL] super ( ) . validate_project ( args . project_id , [ ProjectMemberRole . OWNER ] ) [EOL] main_obj = UpdateMetadataMain ( self . service ) [EOL] main_obj . update_metadata_of_input_data ( args . project_id , input_data_id_list , metadata ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] UpdateMetadata ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_input_data_id ( required = True ) [EOL] [EOL] parser . add_argument ( [string] , required = True , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description = description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $annofabcli.input_data.update_metadata_of_input_data.UpdateMetadataMain$ 0 0 0 0 0 0 0 0 $annofabcli.input_data.update_metadata_of_input_data.UpdateMetadataMain$ 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Optional , Type , Union [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import annofabapi [EOL] import datetime [EOL] import typing [EOL] import argparse [EOL] import copy [EOL] import datetime [EOL] import logging [EOL] import urllib . parse [EOL] from dataclasses import dataclass [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] import annofabapi [EOL] from annofabapi . models import InputData , Task [EOL] from annofabapi . utils import to_iso8601_extension [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] from annofabcli . common . enums import FormatArgument [EOL] from annofabcli . common . visualize import AddProps [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DatetimeRange = Tuple [ Optional [ datetime . datetime ] , Optional [ datetime . datetime ] ] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class InputDataBatchQuery : [EOL] [docstring] [EOL] [EOL] first = ... [EOL] last = ... [EOL] days = ... [EOL] [EOL] [EOL] def str_to_datetime ( d ) : [EOL] [docstring] [EOL] return datetime . datetime . strptime ( d , [string] ) [EOL] [EOL] [EOL] def create_datetime_range_list ( first_datetime , last_datetime , days ) : [EOL] datetime_list = [ ] [EOL] datetime_list . append ( ( None , first_datetime ) ) [EOL] [EOL] from_datetime = first_datetime [EOL] while True : [EOL] to_datetime = from_datetime + datetime . timedelta ( days = days ) [EOL] datetime_list . append ( ( from_datetime , to_datetime ) ) [EOL] if to_datetime >= last_datetime : [EOL] break [EOL] [EOL] from_datetime = to_datetime [EOL] [EOL] datetime_list . append ( ( to_datetime , None ) ) [EOL] return datetime_list [EOL] [EOL] [EOL] class ListInputData ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] average_input_data_id_length = [number] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] self . visualize = AddProps ( self . service , args . project_id ) [EOL] self . average_input_data_id_length = args . averate_input_data_id_length [EOL] [EOL] @ staticmethod def _find_task_id_list ( task_list , input_data_id ) : [EOL] [docstring] [EOL] task_id_list = [ ] [EOL] for task in task_list : [EOL] if input_data_id in task [ [string] ] : [EOL] task_id_list . append ( task [ [string] ] ) [EOL] return task_id_list [EOL] [EOL] @ annofabcli . utils . allow_404_error def get_input_data ( self , project_id , input_data_id ) : [EOL] input_data , _ = self . service . api . get_input_data ( project_id , input_data_id ) [EOL] return input_data [EOL] [EOL] def get_input_data_from_input_data_id ( self , project_id , input_data_id_list ) : [EOL] input_data_list = [ ] [EOL] logger . debug ( f"{ len ( input_data_id_list ) } [string] " ) [EOL] for index , input_data_id in enumerate ( input_data_id_list ) : [EOL] if ( index + [number] ) % [number] == [number] : [EOL] logger . debug ( f"{ index + [number] } [string] " ) [EOL] [EOL] input_data = self . get_input_data ( project_id , input_data_id ) [EOL] if input_data is not None : [EOL] input_data_list . append ( input_data ) [EOL] else : [EOL] logger . warning ( f" [string] { input_data_id } [string] " ) [EOL] [EOL] return input_data_list [EOL] [EOL] def add_details_to_input_data_list ( self , project_id , input_data_list ) : [EOL] [docstring] [EOL] if len ( input_data_list ) == [number] : [EOL] return input_data_list [EOL] [EOL] logger . debug ( f" [string] { len ( input_data_list ) }" ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] MAX_URL_QUERY_LENGTH = [number] [comment] [EOL] average_input_data_id_length = self . average_input_data_id_length + [number] [comment] [EOL] chunk_size = MAX_URL_QUERY_LENGTH // average_input_data_id_length [EOL] initial_index = [number] [EOL] while True : [EOL] sub_input_data_list = input_data_list [ initial_index : initial_index + chunk_size ] [EOL] sub_input_data_id_list = [ e [ [string] ] for e in sub_input_data_list ] [EOL] str_input_data_id_list = [string] . join ( sub_input_data_id_list ) [EOL] encoded_input_data_id_list = urllib . parse . quote ( str_input_data_id_list ) [EOL] if len ( encoded_input_data_id_list ) > MAX_URL_QUERY_LENGTH : [EOL] differential_length = len ( encoded_input_data_id_list ) - MAX_URL_QUERY_LENGTH [EOL] decreasing_size = ( differential_length // average_input_data_id_length ) + [number] [EOL] logger . debug ( f" [string] { chunk_size } [string] { chunk_size - decreasing_size } [string] " f" [string] { len ( encoded_input_data_id_list ) }" ) [EOL] chunk_size = chunk_size - decreasing_size [EOL] if chunk_size <= [number] : [EOL] chunk_size = [number] [EOL] [EOL] continue [EOL] [EOL] logger . debug ( f" [string] { initial_index } [string] { initial_index + chunk_size } [string] " ) [EOL] task_list = self . service . wrapper . get_all_tasks ( project_id , query_params = { [string] : str_input_data_id_list } ) [EOL] [EOL] for input_data in sub_input_data_list : [EOL] [comment] [EOL] [comment] [EOL] task_id_list = self . _find_task_id_list ( task_list , input_data [ [string] ] ) [EOL] self . visualize . add_properties_to_input_data ( input_data , task_id_list ) [EOL] [EOL] initial_index = initial_index + chunk_size [EOL] if initial_index >= len ( input_data_list ) : [EOL] break [EOL] [EOL] return input_data_list [EOL] [EOL] def get_input_data_list ( self , project_id , input_data_id_list = None , input_data_query = None , add_details = False , ) : [EOL] [docstring] [EOL] if input_data_id_list is not None : [EOL] input_data_list = self . get_input_data_from_input_data_id ( project_id , input_data_id_list ) [EOL] else : [EOL] logger . debug ( f" [string] { input_data_query }" ) [EOL] input_data_list = self . service . wrapper . get_all_input_data_list ( project_id , query_params = input_data_query ) [EOL] [EOL] logger . debug ( f" [string] { len ( input_data_list ) }" ) [EOL] [EOL] [comment] [EOL] if add_details : [EOL] self . add_details_to_input_data_list ( project_id , input_data_list ) [EOL] [EOL] return input_data_list [EOL] [EOL] def get_input_data_with_batch ( self , project_id , batch_query , input_data_query = None , add_details = False , ) : [EOL] [docstring] [EOL] first_datetime = str_to_datetime ( batch_query . first ) [EOL] last_datetime = str_to_datetime ( batch_query . last ) [EOL] [EOL] all_input_data_list = [ ] [EOL] [EOL] datetime_range_list = create_datetime_range_list ( first_datetime , last_datetime , batch_query . days ) [EOL] for from_datetime , to_datetime in datetime_range_list : [EOL] idq = copy . deepcopy ( input_data_query ) if input_data_query is not None else { } [EOL] [EOL] if from_datetime is not None : [EOL] idq [ [string] ] = to_iso8601_extension ( from_datetime ) [EOL] if to_datetime is not None : [EOL] idq [ [string] ] = to_iso8601_extension ( to_datetime ) [EOL] [EOL] logger . debug ( f" [string] { idq }" ) [EOL] input_data_list = self . get_input_data_list ( project_id , input_data_query = idq , add_details = add_details ) [EOL] logger . debug ( f" [string] { len ( input_data_list ) } [string] " ) [EOL] if len ( input_data_list ) == [number] : [EOL] logger . warning ( [string] ) [EOL] [EOL] all_input_data_list . extend ( input_data_list ) [EOL] [EOL] return all_input_data_list [EOL] [EOL] def print_input_data ( self , project_id , input_data_query = None , input_data_id_list = None , add_details = False , batch_query = None , ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , project_member_roles = None ) [EOL] [EOL] if batch_query is None : [EOL] input_data_list = self . get_input_data_list ( project_id , input_data_query = input_data_query , input_data_id_list = input_data_id_list , add_details = add_details , ) [EOL] logger . info ( f" [string] { len ( input_data_list ) }" ) [EOL] if len ( input_data_list ) == [number] : [EOL] logger . warning ( [string] ) [EOL] [EOL] else : [EOL] input_data_list = self . get_input_data_with_batch ( project_id , input_data_query = input_data_query , add_details = add_details , batch_query = batch_query ) [EOL] logger . info ( f" [string] { len ( input_data_list ) }" ) [EOL] total_count = self . service . api . get_input_data_list ( project_id , query_params = input_data_query ) [ [number] ] [ [string] ] [EOL] if len ( input_data_list ) != total_count : [EOL] logger . warning ( f" [string] { len ( input_data_list ) } [string] { total_count } [string] " ) [EOL] [EOL] if len ( input_data_list ) > [number] : [EOL] self . print_according_to_format ( input_data_list ) [EOL] else : [EOL] logger . info ( f" [string] " ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] input_data_id_list = annofabcli . common . cli . get_list_from_args ( args . input_data_id ) [EOL] if len ( input_data_id_list ) == [number] : [EOL] input_data_id_list = None [EOL] [EOL] input_data_query = annofabcli . common . cli . get_json_from_args ( args . input_data_query ) [EOL] dict_batch_query = annofabcli . common . cli . get_json_from_args ( args . batch ) [EOL] batch_query = InputDataBatchQuery . from_dict ( dict_batch_query ) if dict_batch_query is not None else None [EOL] self . print_input_data ( args . project_id , input_data_id_list = input_data_id_list , input_data_query = input_data_query , add_details = args . add_details , batch_query = batch_query , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListInputData ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] query_group = parser . add_mutually_exclusive_group ( ) [EOL] [EOL] query_group . add_argument ( [string] , [string] , type = str , help = [string] [string] [string] [string] , ) [EOL] [EOL] query_group . add_argument ( [string] , [string] , type = str , nargs = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = ( [string] [string] [string] ) , ) [EOL] [EOL] argument_parser . add_format ( choices = [ FormatArgument . CSV , FormatArgument . JSON , FormatArgument . PRETTY_JSON , FormatArgument . INPUT_DATA_ID_LIST , ] , default = FormatArgument . CSV , ) [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] argument_parser . add_query ( ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DatetimeRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.common.visualize.AddProps$ 0 0 0 0 0 $annofabapi.Resource$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $builtins.int$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[annofabapi.models.Task]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Task]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.InputData$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 $builtins.str$ 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[annofabapi.models.InputData]$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 0 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[annofabapi.models.InputData]$ 0 0 0 $builtins.str$ 0 $InputDataBatchQuery$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $InputDataBatchQuery$ 0 0 0 0 $datetime.datetime$ 0 0 0 $InputDataBatchQuery$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Optional[datetime.datetime],typing.Optional[datetime.datetime]]]$ 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 $InputDataBatchQuery$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Optional[datetime.datetime],typing.Optional[datetime.datetime]]]$ 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[InputDataBatchQuery]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[InputDataBatchQuery]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Optional[InputDataBatchQuery]$ 0 $typing.Optional[InputDataBatchQuery]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $None$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $None$ 0 $None$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import requests [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DeleteInputData ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] @ annofabcli . utils . allow_404_error def get_input_data ( self , project_id , input_data_id ) : [EOL] input_data , _ = self . service . api . get_input_data ( project_id , input_data_id ) [EOL] return input_data [EOL] [EOL] def confirm_delete_input_data ( self , input_data_id , input_data_name ) : [EOL] message_for_confirm = ( f" [string] { input_data_id } [string] " f" [string] { input_data_name } [string] " ) [EOL] return self . confirm_processing ( message_for_confirm ) [EOL] [EOL] def delete_input_data ( self , project_id , input_data_id ) : [EOL] input_data = self . get_input_data ( project_id , input_data_id ) [EOL] if input_data is None : [EOL] logger . info ( f" [string] { input_data_id } [string] " ) [EOL] return False [EOL] [EOL] task_list = self . service . wrapper . get_all_tasks ( project_id , query_params = { [string] : input_data_id } ) [EOL] input_data_name = input_data [ [string] ] [EOL] if len ( task_list ) > [number] : [EOL] task_id_list = [ e [ [string] ] for e in task_list ] [EOL] logger . info ( f" [string] { input_data_id } [string] " f" [string] { input_data_name } [string] " f" [string] { task_id_list } [string] " ) [EOL] return False [EOL] [EOL] if not self . confirm_delete_input_data ( input_data_id , input_data_name ) : [EOL] return False [EOL] [EOL] self . service . api . delete_input_data ( project_id , input_data_id ) [EOL] logger . info ( f" [string] { input_data_id } [string] " f" [string] { input_data_name } [string] " ) [EOL] return True [EOL] [EOL] def delete_input_data_list ( self , project_id , input_data_id_list ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER ] ) [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f" [string] { project_title } [string] { len ( input_data_id_list ) } [string] " ) [EOL] [EOL] count_delete_input_data = [number] [EOL] for input_data_id in input_data_id_list : [EOL] try : [EOL] result = self . delete_input_data ( project_id , input_data_id ) [EOL] if result : [EOL] count_delete_input_data += [number] [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { input_data_id } [string] " ) [EOL] continue [EOL] [EOL] logger . info ( f" [string] { project_title } [string] { count_delete_input_data } [string] " ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] input_data_id_list = annofabcli . common . cli . get_list_from_args ( args . input_data_id ) [EOL] self . delete_input_data_list ( args . project_id , input_data_id_list = input_data_id_list ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] DeleteInputData ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , nargs = [string] , help = [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import functools [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging [EOL] import sys [EOL] import uuid [EOL] import zipfile [EOL] from dataclasses import dataclass [EOL] from distutils . util import strtobool [comment] [EOL] from functools import partial [EOL] from multiprocessing import Pool [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] import requests [EOL] from annofabapi . models import JobType , ProjectMemberRole [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , prompt_yesnoall , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . utils import get_file_scheme_path [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class CsvInputData : [EOL] [docstring] [EOL] [EOL] input_data_name = ... [EOL] input_data_path = ... [EOL] input_data_id = ... [EOL] sign_required = ... [EOL] [EOL] [EOL] class SubPutInputData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , all_yes = False ) : [EOL] self . service = service [EOL] self . facade = facade [EOL] self . all_yes = all_yes [EOL] [EOL] def put_input_data ( self , project_id , csv_input_data , last_updated_datetime = None ) : [EOL] [EOL] request_body = { [string] : last_updated_datetime } [EOL] [EOL] file_path = get_file_scheme_path ( csv_input_data . input_data_path ) [EOL] if file_path is not None : [EOL] request_body . update ( { [string] : csv_input_data . input_data_name , [string] : csv_input_data . sign_required } ) [EOL] logger . debug ( f" [string] { file_path } [string] { csv_input_data . input_data_name }" ) [EOL] self . service . wrapper . put_input_data_from_file ( project_id , input_data_id = csv_input_data . input_data_id , file_path = file_path , request_body = request_body ) [EOL] [EOL] else : [EOL] request_body . update ( { [string] : csv_input_data . input_data_name , [string] : csv_input_data . input_data_path , [string] : csv_input_data . sign_required , } ) [EOL] [EOL] self . service . api . put_input_data ( project_id , csv_input_data . input_data_id , request_body = request_body ) [EOL] [EOL] def confirm_processing ( self , confirm_message ) : [EOL] [docstring] [EOL] if self . all_yes : [EOL] return True [EOL] [EOL] yes , all_yes = prompt_yesnoall ( confirm_message ) [EOL] [EOL] if all_yes : [EOL] self . all_yes = True [EOL] [EOL] return yes [EOL] [EOL] def confirm_put_input_data ( self , csv_input_data , already_exists = False ) : [EOL] message_for_confirm = f" [string] { csv_input_data . input_data_name } [string] " [EOL] if already_exists : [EOL] message_for_confirm += f" [string] { csv_input_data . input_data_id } [string] " [EOL] return self . confirm_processing ( message_for_confirm ) [EOL] [EOL] def put_input_data_main ( self , project_id , csv_input_data , overwrite = False ) : [EOL] last_updated_datetime = None [EOL] input_data_id = csv_input_data . input_data_id [EOL] input_data_path = csv_input_data . input_data_path [EOL] input_data = self . service . wrapper . get_input_data_or_none ( project_id , input_data_id ) [EOL] [EOL] if input_data is not None : [EOL] if overwrite : [EOL] logger . debug ( f" [string] { input_data_id } [string] " ) [EOL] last_updated_datetime = input_data [ [string] ] [EOL] else : [EOL] logger . debug ( f" [string] { input_data_id } [string] " ) [EOL] return False [EOL] [EOL] file_path = get_file_scheme_path ( input_data_path ) [EOL] logger . debug ( f" [string] { csv_input_data }" ) [EOL] if file_path is not None : [EOL] if not Path ( file_path ) . exists ( ) : [EOL] logger . warning ( f"{ input_data_path } [string] " ) [EOL] return False [EOL] [EOL] if not self . confirm_put_input_data ( csv_input_data , already_exists = ( last_updated_datetime is not None ) ) : [EOL] return False [EOL] [EOL] [comment] [EOL] try : [EOL] self . put_input_data ( project_id , csv_input_data , last_updated_datetime = last_updated_datetime ) [EOL] logger . debug ( f" [string] " f" [string] { csv_input_data . input_data_id } [string] " f" [string] { csv_input_data . input_data_name }" ) [EOL] return True [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] " f" [string] { csv_input_data . input_data_id } [string] " f" [string] { csv_input_data . input_data_name }" ) [EOL] return False [EOL] [EOL] [EOL] class PutInputData ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def put_input_data_list ( self , project_id , input_data_list , overwrite = False , parallelism = None , ) : [EOL] [docstring] [EOL] [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f"{ project_title } [string] { len ( input_data_list ) } [string] " ) [EOL] [EOL] count_put_input_data = [number] [EOL] [EOL] obj = SubPutInputData ( service = self . service , facade = self . facade , all_yes = self . all_yes ) [EOL] if parallelism is not None : [EOL] partial_func = partial ( obj . put_input_data_main , project_id , overwrite = overwrite ) [EOL] with Pool ( parallelism ) as pool : [EOL] result_bool_list = pool . map ( partial_func , input_data_list ) [EOL] count_put_input_data = len ( [ e for e in result_bool_list if e ] ) [EOL] [EOL] else : [EOL] for csv_input_data in input_data_list : [EOL] result = obj . put_input_data_main ( project_id , csv_input_data = csv_input_data , overwrite = overwrite ) [EOL] if result : [EOL] count_put_input_data += [number] [EOL] [EOL] logger . info ( f"{ project_title } [string] { count_put_input_data } [string] { len ( input_data_list ) } [string] " ) [EOL] [EOL] @ staticmethod def get_input_data_list_from_csv ( csv_path ) : [EOL] def create_input_data ( e ) : [EOL] input_data_id = e . input_data_id if not pandas . isna ( e . input_data_id ) else str ( uuid . uuid4 ( ) ) [EOL] sign_required = bool ( strtobool ( str ( e . sign_required ) ) ) if not pandas . isna ( e . sign_required ) else None [EOL] return CsvInputData ( input_data_name = e . input_data_name , input_data_path = e . input_data_path , input_data_id = input_data_id , sign_required = sign_required , ) [EOL] [EOL] df = pandas . read_csv ( str ( csv_path ) , sep = [string] , header = None , names = ( [string] , [string] , [string] , [string] ) , ) [EOL] input_data_list = [ create_input_data ( e ) for e in df . itertuples ( ) ] [EOL] return input_data_list [EOL] [EOL] def put_input_data_from_zip_file ( self , project_id , zip_file , wait_options , input_data_name_for_zip = None , wait = False , ) : [EOL] [docstring] [EOL] [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f"{ project_title } [string] { str ( zip_file ) } [string] " ) [EOL] [EOL] request_body = { } [EOL] if input_data_name_for_zip is not None : [EOL] request_body [ [string] ] = input_data_name_for_zip [EOL] [EOL] self . service . wrapper . put_input_data_from_file ( project_id , input_data_id = str ( uuid . uuid4 ( ) ) , file_path = str ( zip_file ) , content_type = [string] , request_body = request_body , ) [EOL] logger . info ( f" [string] " ) [EOL] [EOL] if wait : [EOL] MAX_WAIT_MINUTUE = wait_options . max_tries * wait_options . interval / [number] [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] [EOL] result = self . service . wrapper . wait_for_completion ( project_id , job_type = JobType . GEN_INPUTS , job_access_interval = wait_options . interval , max_job_access = wait_options . max_tries , ) [EOL] if result : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . warning ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] if args . zip is not None : [EOL] if not Path ( args . zip ) . exists ( ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] { args . zip } [string] " , file = sys . stderr ) [EOL] return False [EOL] [EOL] if not zipfile . is_zipfile ( args . zip ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] { args . zip } [string] " , file = sys . stderr ) [EOL] return False [EOL] [EOL] if args . overwrite : [EOL] logger . warning ( f" [string] " ) [EOL] [EOL] if args . parallelism is not None : [EOL] logger . warning ( f" [string] " ) [EOL] [EOL] if args . csv is not None : [EOL] if not Path ( args . csv ) . exists ( ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] { args . csv } [string] " , file = sys . stderr ) [EOL] return False [EOL] [EOL] if args . wait : [EOL] logger . warning ( f" [string] " ) [EOL] [EOL] if args . input_data_name_for_zip : [EOL] logger . warning ( f" [string] " ) [EOL] [EOL] if args . parallelism is not None and not args . yes : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER ] ) [EOL] [EOL] if args . csv is not None : [EOL] input_data_list = self . get_input_data_list_from_csv ( Path ( args . csv ) ) [EOL] self . put_input_data_list ( project_id , input_data_list = input_data_list , overwrite = args . overwrite , parallelism = args . parallelism ) [EOL] [EOL] elif args . zip is not None : [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] self . put_input_data_from_zip_file ( project_id , zip_file = Path ( args . zip ) , input_data_name_for_zip = args . input_data_name_for_zip , wait = args . wait , wait_options = wait_options , ) [EOL] [EOL] else : [EOL] print ( f" [string] " , file = sys . stderr ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] PutInputData ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] file_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] file_group . add_argument ( [string] , type = str , help = ( [string] [string] [string] [string] [string] [string] ) , ) [EOL] [EOL] file_group . add_argument ( [string] , type = str , help = ( [string] ) ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = ( [string] [string] ) ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 $CsvInputData$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $CsvInputData$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $CsvInputData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $CsvInputData$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $CsvInputData$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $CsvInputData$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $CsvInputData$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 $CsvInputData$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $CsvInputData$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $CsvInputData$ 0 $builtins.str$ 0 $builtins.str$ 0 $CsvInputData$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $CsvInputData$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CsvInputData$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $CsvInputData$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $CsvInputData$ 0 $builtins.str$ 0 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $CsvInputData$ 0 $builtins.str$ 0 0 0 0 0 0 $CsvInputData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[CsvInputData]$ 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[CsvInputData]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $annofabcli.input_data.put_input_data.SubPutInputData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 $annofabcli.input_data.put_input_data.SubPutInputData$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 $typing.List[CsvInputData]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[CsvInputData]$ 0 0 $builtins.bool$ 0 $annofabcli.input_data.put_input_data.SubPutInputData$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[CsvInputData]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[CsvInputData]$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 $typing.Optional[builtins.bool]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.float$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[annofabcli.input_data.put_input_data.CsvInputData]$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[annofabcli.input_data.put_input_data.CsvInputData]$ 0 $typing.List[annofabcli.input_data.put_input_data.CsvInputData]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . input_data . delete_input_data [EOL] import annofabcli . input_data . list_input_data [EOL] import annofabcli . input_data . list_input_data_merged_task [EOL] import annofabcli . input_data . put_input_data [EOL] import annofabcli . input_data . update_metadata_of_input_data [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . input_data . delete_input_data . add_parser ( subparsers ) [EOL] annofabcli . input_data . list_input_data . add_parser ( subparsers ) [EOL] annofabcli . input_data . list_input_data_merged_task . add_parser ( subparsers ) [EOL] annofabcli . input_data . put_input_data . add_parser ( subparsers ) [EOL] annofabcli . input_data . update_metadata_of_input_data . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] from typing import Any , Dict , List [EOL] [EOL] import requests [EOL] from annofabapi . models import ProjectMemberRole , TaskStatus [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DeleteTask ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] @ annofabcli . utils . allow_404_error def get_task ( self , project_id , task_id ) : [EOL] task , _ = self . service . api . get_task ( project_id , task_id ) [EOL] return task [EOL] [EOL] def confirm_delete_task ( self , task_id ) : [EOL] message_for_confirm = f" [string] { task_id } [string] " [EOL] return self . confirm_processing ( message_for_confirm ) [EOL] [EOL] def get_annotation_list ( self , project_id , task_id ) : [EOL] query_params = { [string] : { [string] : task_id , [string] : True } } [EOL] annotation_list = self . service . wrapper . get_all_annotation_list ( project_id , query_params = query_params ) [EOL] return annotation_list [EOL] [EOL] def delete_task ( self , project_id , task_id , force = False ) : [EOL] [docstring] [EOL] task = self . get_task ( project_id , task_id ) [EOL] if task is None : [EOL] logger . info ( f" [string] { task_id } [string] " ) [EOL] return False [EOL] [EOL] logger . debug ( f" [string] { task [ [string] ] } [string] { task [ [string] ] } [string] " f" [string] { task [ [string] ] } [string] { task [ [string] ] }" ) [EOL] [EOL] task_status = TaskStatus ( task [ [string] ] ) [EOL] if task_status in [ TaskStatus . WORKING , TaskStatus . COMPLETE ] : [EOL] logger . info ( f" [string] " ) [EOL] return False [EOL] [EOL] annotation_list = self . get_annotation_list ( project_id , task_id ) [EOL] logger . debug ( f" [string] { task_id } [string] { len ( annotation_list ) } [string] " ) [EOL] if not force : [EOL] if len ( annotation_list ) > [number] : [EOL] logger . info ( f" [string] { len ( annotation_list ) } [string] { task_id } [string] " ) [EOL] return False [EOL] [EOL] if not self . confirm_delete_task ( task_id ) : [EOL] return False [EOL] [EOL] self . service . api . delete_task ( project_id , task_id ) [EOL] return True [EOL] [EOL] def delete_task_list ( self , project_id , task_id_list , force = False ) : [EOL] [docstring] [EOL] [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER ] ) [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f" [string] { project_title } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] count_delete_task = [number] [EOL] for task_index , task_id in enumerate ( task_id_list ) : [EOL] try : [EOL] result = self . delete_task ( project_id , task_id , force = force ) [EOL] if result : [EOL] count_delete_task += [number] [EOL] logger . info ( f"{ task_index + [number] } [string] { len ( task_id_list ) } [string] { task_id } [string] " ) [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( e ) [EOL] logger . warning ( f" [string] { task_id } [string] " ) [EOL] continue [EOL] [EOL] logger . info ( f" [string] { project_title } [string] { count_delete_task } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] self . delete_task_list ( args . project_id , task_id_list = task_id_list , force = args . force ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] DeleteTask ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import argparse [EOL] import argparse [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] import annofabcli . task . cancel_acceptance [EOL] import annofabcli . task . change_operator [EOL] import annofabcli . task . complete_tasks [EOL] import annofabcli . task . delete_tasks [EOL] import annofabcli . task . list_tasks [EOL] import annofabcli . task . list_tasks_added_task_history [EOL] import annofabcli . task . put_tasks [EOL] import annofabcli . task . reject_tasks [EOL] from annofabcli . task . list_task_history import add_parser as list_task_history_add_parser [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] subparsers = parser . add_subparsers ( dest = [string] ) [EOL] [EOL] [comment] [EOL] annofabcli . task . cancel_acceptance . add_parser ( subparsers ) [EOL] annofabcli . task . change_operator . add_parser ( subparsers ) [EOL] annofabcli . task . complete_tasks . add_parser ( subparsers ) [EOL] annofabcli . task . delete_tasks . add_parser ( subparsers ) [EOL] annofabcli . task . list_tasks . add_parser ( subparsers ) [EOL] annofabcli . task . list_tasks_added_task_history . add_parser ( subparsers ) [EOL] list_task_history_add_parser ( subparsers ) [EOL] annofabcli . task . put_tasks . add_parser ( subparsers ) [EOL] annofabcli . task . reject_tasks . add_parser ( subparsers ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , is_subcommand = False ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import logging [EOL] import builtins [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import copy [EOL] import json [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Any , Dict [EOL] [EOL] from annofabapi . models import JobType , ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] class PutTask ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] DEFAULT_BY_COUNT = { [string] : False , [string] : [string] } [EOL] [EOL] def put_task_by_count ( self , project_id , task_generate_rule ) : [EOL] project_last_updated_datetime = self . service . api . get_project ( project_id ) [ [number] ] [ [string] ] [EOL] task_generate_rule . update ( { [string] : [string] } ) [EOL] request_body = { [string] : task_generate_rule , [string] : project_last_updated_datetime , } [EOL] self . service . api . initiate_tasks_generation ( project_id , request_body = request_body ) [EOL] [EOL] def put_task_from_csv_file ( self , project_id , csv_file ) : [EOL] [docstring] [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f"{ project_title } [string] { str ( csv_file ) } [string] " ) [EOL] self . service . wrapper . initiate_tasks_generation_by_csv ( project_id , csvfile_path = str ( csv_file ) ) [EOL] [EOL] def wait_for_completion ( self , project_id , wait_options , wait = False , ) : [EOL] [docstring] [EOL] logger . info ( f" [string] " ) [EOL] [EOL] if wait : [EOL] MAX_WAIT_MINUTUE = wait_options . max_tries * wait_options . interval / [number] [EOL] logger . info ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] [EOL] result = self . service . wrapper . wait_for_completion ( project_id , job_type = JobType . GEN_TASKS , job_access_interval = wait_options . interval , max_job_access = wait_options . max_tries , ) [EOL] if result : [EOL] logger . info ( f" [string] " ) [EOL] else : [EOL] logger . warning ( f" [string] { MAX_WAIT_MINUTUE } [string] " ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER ] ) [EOL] [EOL] if args . csv is not None : [EOL] csv_file = Path ( args . csv ) [EOL] self . put_task_from_csv_file ( project_id , csv_file ) [EOL] elif args . by_count is not None : [EOL] by_count = copy . deepcopy ( PutTask . DEFAULT_BY_COUNT ) [EOL] by_count . update ( get_json_from_args ( args . by_count ) ) [EOL] self . put_task_by_count ( project_id , by_count ) [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] self . wait_for_completion ( project_id , wait = args . wait , wait_options = wait_options , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] PutTask ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] file_group = parser . add_mutually_exclusive_group ( required = True ) [EOL] file_group . add_argument ( [string] , type = str , help = ( [string] [string] [string] ) , ) [EOL] [EOL] file_group . add_argument ( [string] , type = str , help = f" [string] " [string] [string] f" [string] { json . dumps ( PutTask . DEFAULT_BY_COUNT ) } [string] " [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = ( [string] ) ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.float$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 $argparse.Namespace$ 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 $argparse.Namespace$ 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import functools [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import multiprocessing [EOL] import sys [EOL] import uuid [EOL] from functools import partial [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] import annofabapi . utils [EOL] import dateutil [EOL] import requests [EOL] from annofabapi . dataclass . task import Task [EOL] from annofabapi . models import Inspection , InspectionStatus , ProjectMemberRole , TaskPhase , TaskStatus [EOL] from more_itertools import first_true [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstracCommandCinfirmInterface , AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] InspectionJson = Dict [ str , Dict [ str , List [ Inspection ] ] ] [EOL] [docstring] [EOL] [EOL] [EOL] class CompleteTasksMain ( AbstracCommandCinfirmInterface ) : [EOL] def __init__ ( self , service , all_yes = False ) : [EOL] self . service = service [EOL] self . facade = AnnofabApiFacade ( service ) [EOL] AbstracCommandCinfirmInterface . __init__ ( self , all_yes ) [EOL] [EOL] @ staticmethod def inspection_list_to_input_data_dict ( inspection_list ) : [EOL] [docstring] [EOL] input_data_dict = { } [EOL] for inspection in inspection_list : [EOL] input_data_id = inspection [ [string] ] [EOL] inspection_list = input_data_dict . get ( input_data_id , [ ] ) [EOL] inspection_list . append ( inspection ) [EOL] input_data_dict [ input_data_id ] = inspection_list [EOL] return input_data_dict [EOL] [EOL] @ staticmethod def inspection_list_to_dict ( all_inspection_list ) : [EOL] [docstring] [EOL] task_dict = { } [EOL] for inspection in all_inspection_list : [EOL] task_id = inspection [ [string] ] [EOL] input_data_dict = task_dict . get ( task_id , { } ) [EOL] [EOL] input_data_id = inspection [ [string] ] [EOL] inspection_list = input_data_dict . get ( input_data_id , [ ] ) [EOL] inspection_list . append ( inspection ) [EOL] input_data_dict [ input_data_id ] = inspection_list [EOL] [EOL] task_dict [ task_id ] = input_data_dict [EOL] [EOL] return task_dict [EOL] [EOL] def reply_inspection_comment ( self , task , input_data_id , unanswered_comment_list , reply_comment , ) : [EOL] [docstring] [EOL] [EOL] def to_req_inspection ( i ) : [EOL] return { [string] : { [string] : task . project_id , [string] : reply_comment , [string] : task . task_id , [string] : input_data_id , [string] : str ( uuid . uuid4 ( ) ) , [string] : task . phase . value , [string] : task . phase_stage , [string] : self . service . api . account_id , [string] : i [ [string] ] , [string] : i [ [string] ] , [string] : InspectionStatus . NO_CORRECTION_REQUIRED . value , [string] : task . updated_datetime , } , [string] : [string] , } [EOL] [EOL] request_body = [ to_req_inspection ( e ) for e in unanswered_comment_list ] [EOL] return self . service . api . batch_update_inspections ( task . project_id , task . task_id , input_data_id , request_body = request_body ) [ [number] ] [EOL] [EOL] def update_status_of_inspections ( self , task , input_data_id , inspection_list , inspection_status , ) : [EOL] [EOL] if inspection_list is None or len ( inspection_list ) == [number] : [EOL] logger . warning ( f" [string] { task . task_id } [string] { input_data_id }" ) [EOL] return [EOL] [EOL] target_inspection_id_list = [ inspection [ [string] ] for inspection in inspection_list ] [EOL] [EOL] def filter_inspection ( arg_inspection ) : [EOL] [docstring] [EOL] [EOL] return arg_inspection [ [string] ] in target_inspection_id_list [EOL] [EOL] self . service . wrapper . update_status_of_inspections ( task . project_id , task . task_id , input_data_id , filter_inspection = filter_inspection , inspection_status = inspection_status , updated_datetime = task . updated_datetime , ) [EOL] logger . debug ( f"{ task . task_id } [string] { input_data_id } [string] { len ( inspection_list ) } [string] " ) [EOL] [EOL] def get_unprocessed_inspection_list ( self , task , input_data_id ) : [EOL] [docstring] [EOL] inspectin_list , _ = self . service . api . get_inspections ( task . project_id , task . task_id , input_data_id ) [EOL] return [ e for e in inspectin_list if e [ [string] ] == InspectionStatus . ANNOTATOR_ACTION_REQUIRED . value [EOL] and e [ [string] ] == task . phase . value [EOL] and e [ [string] ] == task . phase_stage ] [EOL] [EOL] def get_unprocessed_inspection_list_by_task_id ( self , project_id , task , target_phase , target_phase_stage ) : [EOL] all_inspection_list = [ ] [EOL] for input_data_id in task . input_data_id_list : [EOL] inspectins , _ = self . service . api . get_inspections ( project_id , task . task_id , input_data_id ) [EOL] all_inspection_list . extend ( [ e for e in inspectins if e [ [string] ] == InspectionStatus . ANNOTATOR_ACTION_REQUIRED . value [EOL] and e [ [string] ] == target_phase . value [EOL] and e [ [string] ] == target_phase_stage ] ) [EOL] [EOL] return all_inspection_list [EOL] [EOL] def change_to_working_status ( self , task ) : [EOL] [docstring] [EOL] [comment] [EOL] my_account_id = self . service . api . account_id [EOL] try : [EOL] if task . account_id != my_account_id : [EOL] self . facade . change_operator_of_task ( task . project_id , task . task_id , my_account_id ) [EOL] logger . debug ( f"{ task . task_id } [string] " ) [EOL] [EOL] dict_task = self . facade . change_to_working_status ( project_id = task . project_id , task_id = task . task_id , account_id = my_account_id ) [EOL] return Task . from_dict ( dict_task ) [comment] [EOL] [EOL] except requests . HTTPError as e : [EOL] logger . warning ( f"{ task . task_id } [string] " ) [EOL] raise e [EOL] [EOL] def get_unanswered_comment_list ( self , task , input_data_id ) : [EOL] [docstring] [EOL] [EOL] def exists_answered_comment ( parent_inspection_id ) : [EOL] [docstring] [EOL] if task . started_datetime is None : [EOL] [comment] [EOL] return False [EOL] task_started_datetime = task . started_datetime [EOL] answered_comment = first_true ( inspection_list , pred = lambda e : e [ [string] ] == parent_inspection_id [EOL] and dateutil . parser . parse ( e [ [string] ] ) >= dateutil . parser . parse ( task_started_datetime ) , ) [EOL] return answered_comment is not None [EOL] [EOL] inspection_list , _ = self . service . api . get_inspections ( task . project_id , task . task_id , input_data_id ) [EOL] [comment] [EOL] unprocessed_inspection_list = [ e for e in inspection_list if e [ [string] ] is None and e [ [string] ] == InspectionStatus . ANNOTATOR_ACTION_REQUIRED . value ] [EOL] [EOL] unanswered_comment_list = [ e for e in unprocessed_inspection_list if not exists_answered_comment ( e [ [string] ] ) ] [EOL] return unanswered_comment_list [EOL] [EOL] def complete_task_for_annotation_phase ( self , task , reply_comment = None , ) : [EOL] [docstring] [EOL] [EOL] unanswered_comment_list_dict = { } [EOL] for input_data_id in task . input_data_id_list : [EOL] unanswered_comment_list = self . get_unanswered_comment_list ( task , input_data_id ) [EOL] unanswered_comment_list_dict [ input_data_id ] = unanswered_comment_list [EOL] [EOL] unanswered_comment_count_for_task = sum ( [ len ( e ) for e in unanswered_comment_list_dict . values ( ) ] ) [EOL] if unanswered_comment_count_for_task == [number] : [EOL] if not self . confirm_processing ( f" [string] { task . task_id } [string] " ) : [EOL] return False [EOL] [EOL] self . change_to_working_status ( task ) [EOL] self . facade . complete_task ( task . project_id , task . task_id ) [EOL] logger . info ( f"{ task . task_id } [string] " ) [EOL] return True [EOL] else : [EOL] logger . debug ( f"{ task . task_id } [string] { unanswered_comment_count_for_task } [string] " ) [EOL] if reply_comment is None : [EOL] logger . warning ( f"{ task . task_id } [string] " ) [EOL] return False [EOL] elif not self . confirm_processing ( f" [string] { task . task_id } [string] " ) : [EOL] return False [EOL] else : [EOL] changed_task = self . change_to_working_status ( task ) [EOL] [EOL] logger . debug ( f"{ task . task_id } [string] { unanswered_comment_count_for_task } [string] " ) [EOL] for input_data_id , unanswered_comment_list in unanswered_comment_list_dict . items ( ) : [EOL] if len ( unanswered_comment_list ) == [number] : [EOL] continue [EOL] self . reply_inspection_comment ( changed_task , input_data_id = input_data_id , unanswered_comment_list = unanswered_comment_list , reply_comment = reply_comment , ) [EOL] [EOL] self . facade . complete_task ( task . project_id , task . task_id ) [EOL] logger . info ( f"{ task . task_id } [string] " ) [EOL] return True [EOL] [EOL] def complete_task_for_inspection_acceptance_phase ( self , task , inspection_status = None , ) : [EOL] unprocessed_inspection_list_dict = { } [EOL] for input_data_id in task . input_data_id_list : [EOL] unprocessed_inspection_list = self . get_unprocessed_inspection_list ( task , input_data_id ) [EOL] unprocessed_inspection_list_dict [ input_data_id ] = unprocessed_inspection_list [EOL] [EOL] unprocessed_inspection_count = sum ( [ len ( e ) for e in unprocessed_inspection_list_dict . values ( ) ] ) [EOL] [EOL] if unprocessed_inspection_count == [number] : [EOL] if not self . confirm_processing ( f" [string] { task . task_id } [string] " ) : [EOL] return False [EOL] [EOL] self . change_to_working_status ( task ) [EOL] self . facade . complete_task ( task . project_id , task . task_id ) [EOL] logger . info ( f"{ task . task_id } [string] " ) [EOL] return True [EOL] [EOL] else : [EOL] logger . debug ( f"{ task . task_id } [string] { unprocessed_inspection_count } [string] " ) [EOL] if inspection_status is None : [EOL] logger . warning ( f"{ task . task_id } [string] " ) [EOL] return False [EOL] elif not self . confirm_processing ( f" [string] { task . task_id } [string] " ) : [EOL] return False [EOL] [EOL] changed_task = self . change_to_working_status ( task ) [EOL] [EOL] logger . debug ( f"{ task . task_id } [string] { inspection_status . value } [string] " ) [EOL] for input_data_id , unprocessed_inspection_list in unprocessed_inspection_list_dict . items ( ) : [EOL] if len ( unprocessed_inspection_list ) == [number] : [EOL] continue [EOL] [EOL] self . update_status_of_inspections ( changed_task , input_data_id , inspection_list = unprocessed_inspection_list , inspection_status = inspection_status , ) [EOL] [EOL] self . facade . complete_task ( task . project_id , task . task_id ) [EOL] logger . info ( f"{ task . task_id } [string] " ) [EOL] return True [EOL] [EOL] def complete_task ( self , project_id , task_id , target_phase , target_phase_stage , reply_comment = None , inspection_status = None , task_index = None , ) : [EOL] logging_prefix = f"{ task_index + [number] } [string] " if task_index is not None else [string] [EOL] [EOL] dict_task = self . service . wrapper . get_task_or_none ( project_id , task_id ) [EOL] if dict_task is None : [EOL] logger . warning ( f"{ task_id } [string] " ) [EOL] return False [EOL] [EOL] task = Task . from_dict ( dict_task ) [comment] [EOL] logger . info ( f"{ logging_prefix } [string] { task_id } [string] " f" [string] { task . phase . value } [string] { task . phase_stage } [string] { task . status . value }" ) [EOL] if not ( task . phase == target_phase and task . phase_stage == target_phase_stage ) : [EOL] logger . warning ( f"{ task_id } [string] " ) [EOL] return False [EOL] [EOL] if task . status == TaskStatus . COMPLETE : [EOL] logger . warning ( f"{ task_id } [string] " ) [EOL] return False [EOL] [EOL] try : [EOL] if task . phase == TaskPhase . ANNOTATION : [EOL] return self . complete_task_for_annotation_phase ( task , reply_comment = reply_comment ) [EOL] else : [EOL] return self . complete_task_for_inspection_acceptance_phase ( task , inspection_status = inspection_status ) [EOL] [EOL] except Exception as e : [comment] [EOL] logger . warning ( f"{ task_id } [string] { task . phase } [string] " ) [EOL] logger . warning ( e ) [EOL] new_task = Task . from_dict ( self . service . wrapper . get_task_or_none ( project_id , task_id ) ) [comment] [EOL] if new_task . status == TaskStatus . WORKING and new_task . account_id == self . service . api . account_id : [EOL] self . facade . change_to_break_phase ( project_id , task_id ) [EOL] return False [EOL] [EOL] def complete_task_for_task_wrapper ( self , tpl , project_id , target_phase , target_phase_stage , reply_comment = None , inspection_status = None , ) : [EOL] task_index , task_id = tpl [EOL] return self . complete_task ( project_id = project_id , task_id = task_id , task_index = task_index , target_phase = target_phase , target_phase_stage = target_phase_stage , reply_comment = reply_comment , inspection_status = inspection_status , ) [EOL] [EOL] def complete_task_list ( self , project_id , task_id_list , target_phase , target_phase_stage , reply_comment = None , inspection_status = None , parallelism = None , ) : [EOL] [docstring] [EOL] [EOL] project_title = self . facade . get_project_title ( project_id ) [EOL] logger . info ( f"{ project_title } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] success_count = [number] [EOL] [EOL] if parallelism is not None : [EOL] partial_func = partial ( self . complete_task_for_task_wrapper , project_id = project_id , target_phase = target_phase , target_phase_stage = target_phase_stage , reply_comment = reply_comment , inspection_status = inspection_status , ) [EOL] [EOL] with multiprocessing . Pool ( parallelism ) as pool : [EOL] result_bool_list = pool . map ( partial_func , enumerate ( task_id_list ) ) [EOL] success_count = len ( [ e for e in result_bool_list if e ] ) [EOL] [EOL] else : [EOL] [comment] [EOL] for task_index , task_id in enumerate ( task_id_list ) : [EOL] result = self . complete_task ( project_id , task_id , task_index = task_index , target_phase = target_phase , target_phase_stage = target_phase_stage , reply_comment = reply_comment , inspection_status = inspection_status , ) [EOL] if result : [EOL] success_count += [number] [EOL] [EOL] logger . info ( f"{ success_count } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] [EOL] class ComleteTasks ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] if args . phase == TaskPhase . ANNOTATION . value : [EOL] if args . inspection_status is not None : [EOL] logger . warning ( f" [string] { TaskPhase . ANNOTATION . value } [string] " f" [string] " ) [EOL] elif args . phase in [ TaskPhase . INSPECTION . value , TaskPhase . ACCEPTANCE . value ] : [EOL] if args . reply_comment is not None : [EOL] logger . warning ( f" [string] { TaskPhase . INSPECTION . value } [string] { TaskPhase . ACCEPTANCE . value } [string] " f" [string] " ) [EOL] [EOL] if args . parallelism is not None and not args . yes : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] inspection_status = InspectionStatus ( args . inspection_status ) if args . inspection_status is not None else None [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER , ProjectMemberRole . ACCEPTER ] ) [EOL] [EOL] main_obj = CompleteTasksMain ( self . service , all_yes = self . all_yes ) [EOL] main_obj . complete_task_list ( project_id , task_id_list = task_id_list , target_phase = TaskPhase ( args . phase ) , target_phase_stage = args . phase_stage , inspection_status = inspection_status , reply_comment = args . reply_comment , parallelism = args . parallelism , ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] argument_parser . add_task_id ( required = True ) [EOL] [EOL] parser . add_argument ( [string] , type = str , required = True , choices = [ TaskPhase . ANNOTATION . value , TaskPhase . INSPECTION . value , TaskPhase . ACCEPTANCE . value ] , help = ( [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = ( [string] ) , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = ( f" [string] " f" [string] { TaskPhase . ANNOTATION . value } [string] " f" [string] " ) , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , choices = [ InspectionStatus . ERROR_CORRECTED . value , InspectionStatus . NO_CORRECTION_REQUIRED . value ] , help = ( [string] f" [string] { TaskPhase . INSPECTION . value } [string] { TaskPhase . ACCEPTANCE . value } [string] " [string] f"{ InspectionStatus . ERROR_CORRECTED . value } [string] " f"{ InspectionStatus . NO_CORRECTION_REQUIRED . value } [string] " ) , ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ComleteTasks ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = ( [string] [string] [string] [string] [string] ) [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 $InspectionJson$ 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 $InspectionJson$ 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 $InspectionJson$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $InspectionJson$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 $InspectionJson$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 $builtins.str$ 0 $typing.List[annofabapi.models.Inspection]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 $builtins.str$ 0 $typing.List[annofabapi.models.Inspection]$ 0 $annofabapi.models.Inspection.Status$ 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 $builtins.bool$ 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 $annofabapi.models.Inspection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $builtins.str$ 0 0 0 0 0 $annofabapi.models.Inspection.Status$ 0 $annofabapi.models.Inspection.Status$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 $builtins.str$ 0 $annofabapi.dataclass.task.Task$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[annofabapi.models.Inspection]$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[annofabapi.models.Inspection]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 $annofabapi.models.TaskPhase$ 0 $annofabapi.dataclass.task.Task$ 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 $annofabapi.dataclass.task.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 $builtins.str$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $annofabapi.models.TaskPhase$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 $annofabapi.models.TaskPhase$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 $typing.Optional[annofabapi.models.Inspection.Status]$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.task.complete_tasks.CompleteTasksMain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.task.complete_tasks.CompleteTasksMain$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import asyncio [EOL] import argparse [EOL] import pandas [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import annofabapi [EOL] import pandas [EOL] from annofabapi . models import ProjectMemberRole , Task , TaskHistory , TaskPhase [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login , get_json_from_args , get_wait_options_from_args , ) [EOL] from annofabcli . common . dataclasses import WaitOptions [EOL] from annofabcli . common . download import DownloadingFile [EOL] from annofabcli . common . enums import FormatArgument [EOL] from annofabcli . common . visualize import AddProps [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] TaskHistoryDict = Dict [ str , List [ TaskHistory ] ] [EOL] [docstring] [EOL] [EOL] DEFAULT_WAIT_OPTIONS = WaitOptions ( interval = [number] , max_tries = [number] ) [EOL] [EOL] [EOL] class ListTasksAddedTaskHistory ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , facade , args ) : [EOL] super ( ) . __init__ ( service , facade , args ) [EOL] self . visualize = AddProps ( self . service , args . project_id ) [EOL] [EOL] def _add_task_history_info ( self , task , task_history , column_prefix ) : [EOL] [docstring] [EOL] if task_history is None : [EOL] task . update ( { f"{ column_prefix } [string] " : None , f"{ column_prefix } [string] " : None , f"{ column_prefix } [string] " : None , } ) [EOL] return task [EOL] [EOL] account_id = task_history [ [string] ] [EOL] task . update ( { f"{ column_prefix } [string] " : task_history [ [string] ] } ) [EOL] [EOL] organization_member = self . visualize . get_organization_member_from_account_id ( account_id ) [EOL] if organization_member is not None : [EOL] task . update ( { f"{ column_prefix } [string] " : organization_member [ [string] ] , f"{ column_prefix } [string] " : organization_member [ [string] ] , } ) [EOL] else : [EOL] task . update ( { f"{ column_prefix } [string] " : None , f"{ column_prefix } [string] " : None } ) [EOL] [EOL] return task [EOL] [EOL] def _add_task_history_info_by_phase ( self , task , task_history_list , phase ) : [EOL] if task_history_list is not None : [EOL] task_history_by_phase = [ e for e in task_history_list if e [ [string] ] == phase . value ] [EOL] else : [EOL] task_history_by_phase = [ ] [EOL] [EOL] [comment] [EOL] first_task_history = task_history_by_phase [ [number] ] if len ( task_history_by_phase ) > [number] else None [EOL] self . _add_task_history_info ( task , first_task_history , column_prefix = f" [string] { phase . value }" ) [EOL] [EOL] [comment] [EOL] last_task_history = task_history_by_phase [ - [number] ] if len ( task_history_by_phase ) > [number] else None [EOL] self . _add_task_history_info ( task , last_task_history , column_prefix = f" [string] { phase . value }" ) [EOL] [EOL] [comment] [EOL] task [ f"{ phase . value } [string] " ] = sum ( [ annofabcli . utils . isoduration_to_hour ( e [ [string] ] ) for e in task_history_by_phase ] ) [EOL] [EOL] return task [EOL] [EOL] def create_df_task ( self , task_list , task_history_dict ) : [EOL] for task in task_list : [EOL] [comment] [EOL] task = self . visualize . add_properties_to_task ( task ) [EOL] task_id = task [ [string] ] [EOL] task_history_list = task_history_dict . get ( task_id ) [EOL] self . _add_task_history_info_by_phase ( task = task , task_history_list = task_history_list , phase = TaskPhase . ANNOTATION ) [EOL] self . _add_task_history_info_by_phase ( task = task , task_history_list = task_history_list , phase = TaskPhase . INSPECTION ) [EOL] self . _add_task_history_info_by_phase ( task = task , task_history_list = task_history_list , phase = TaskPhase . ACCEPTANCE ) [EOL] [EOL] return pandas . DataFrame ( task_list ) [EOL] [EOL] @ staticmethod def _get_output_target_columns ( ) : [EOL] base_columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] task_history_columns = [ f"{ step } [string] { phase . value } [string] { info }" for step in [ [string] , [string] ] for phase in [ TaskPhase . ANNOTATION , TaskPhase . INSPECTION , TaskPhase . ACCEPTANCE ] for info in [ [string] , [string] , [string] ] ] [EOL] return base_columns + task_history_columns [EOL] [EOL] def print_task_list_added_task_history ( self , task_list , task_history_dict ) : [EOL] logger . debug ( [string] ) [EOL] df_task = self . create_df_task ( task_list = task_list , task_history_dict = task_history_dict ) [EOL] [EOL] annofabcli . utils . print_according_to_format ( df_task [ self . _get_output_target_columns ( ) ] , arg_format = FormatArgument ( FormatArgument . CSV ) , output = self . output , csv_format = self . csv_format , ) [EOL] [EOL] def download_json_files ( self , project_id , task_json_path , task_history_json_path , is_latest , wait_options , ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] downloading_obj = DownloadingFile ( self . service ) [EOL] gather = asyncio . gather ( downloading_obj . download_task_json_with_async ( project_id , dest_path = str ( task_json_path ) , is_latest = is_latest , wait_options = wait_options ) , downloading_obj . download_task_history_json_with_async ( project_id , dest_path = str ( task_history_json_path ) , ) , ) [EOL] loop . run_until_complete ( gather ) [EOL] [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] if ( args . task_json is None and args . task_history_json is not None ) or ( args . task_json is not None and args . task_history_json is None ) : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] project_id = args . project_id [EOL] super ( ) . validate_project ( project_id , [ ProjectMemberRole . OWNER , ProjectMemberRole . TRAINING_DATA_USER ] ) [EOL] [EOL] if args . task_json is not None and args . task_history_json is not None : [EOL] task_json_path = args . task_json [EOL] task_history_json_path = args . task_history_json [EOL] else : [EOL] wait_options = get_wait_options_from_args ( get_json_from_args ( args . wait_options ) , DEFAULT_WAIT_OPTIONS ) [EOL] cache_dir = annofabcli . utils . get_cache_dir ( ) [EOL] task_json_path = cache_dir / f"{ project_id } [string] " [EOL] task_history_json_path = cache_dir / f"{ project_id } [string] " [EOL] self . download_json_files ( project_id , task_json_path = task_json_path , task_history_json_path = task_history_json_path , is_latest = args . latest , wait_options = wait_options , ) [EOL] [EOL] with open ( task_json_path , encoding = [string] ) as f : [EOL] task_list = json . load ( f ) [EOL] [EOL] with open ( task_history_json_path , encoding = [string] ) as f : [EOL] task_history_dict = json . load ( f ) [EOL] [EOL] self . print_task_list_added_task_history ( task_list = task_list , task_history_dict = task_history_dict ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] ListTasksAddedTaskHistory ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] [string] [string] [string] [string] , ) [EOL] [EOL] argument_parser . add_output ( ) [EOL] argument_parser . add_csv_format ( ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $annofabapi.Resource$ 0 $annofabcli.AnnofabApiFacade$ 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.common.visualize.AddProps$ 0 0 0 0 0 $annofabapi.Resource$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 $annofabapi.models.Task$ 0 $typing.Optional[annofabapi.models.Task.History]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[annofabapi.models.Task.History]$ 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 $typing.Any$ 0 $typing.Optional[annofabapi.models.Task.History]$ 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[annofabapi.models.Task.History]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 $annofabapi.models.Task$ 0 0 0 $annofabapi.models.Task$ 0 $typing.Optional[typing.List[annofabapi.models.Task.History]]$ 0 $annofabapi.models.TaskPhase$ 0 0 0 0 $typing.Optional[typing.List[annofabapi.models.Task.History]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Optional[typing.List[annofabapi.models.Task.History]]$ 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 $typing.Any$ 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 $typing.Any$ 0 0 0 0 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 $annofabapi.models.Task$ 0 0 $annofabapi.models.TaskPhase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $annofabapi.models.Task$ 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $TaskHistoryDict$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $TaskHistoryDict$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $TaskHistoryDict$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $TaskHistoryDict$ 0 $TaskHistoryDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $builtins.bool$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any,typing.Any]]$ 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.download.DownloadingFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.futures.Future[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $argparse.Namespace$ 0 0 0 $pathlib.Path$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 $argparse.Namespace$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $argparse.Namespace$ 0 0 0 $annofabcli.common.dataclasses.WaitOptions$ 0 $annofabcli.common.dataclasses.WaitOptions$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import functools [EOL] import annofabcli [EOL] import annofabapi [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import multiprocessing [EOL] import sys [EOL] from functools import partial [EOL] from typing import List , Optional , Tuple [EOL] [EOL] import annofabapi [EOL] import requests [EOL] from annofabapi . models import ProjectMemberRole [EOL] [EOL] import annofabcli [EOL] import annofabcli . common . cli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import ( AbstracCommandCinfirmInterface , AbstractCommandLineInterface , build_annofabapi_resource_and_login , ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CancelAcceptanceMain ( AbstracCommandCinfirmInterface ) : [EOL] def __init__ ( self , service , all_yes = False ) : [EOL] self . service = service [EOL] self . facade = AnnofabApiFacade ( service ) [EOL] AbstracCommandCinfirmInterface . __init__ ( self , all_yes ) [EOL] [EOL] def cancel_acceptance_for_task ( self , project_id , task_id , acceptor_user_id = None , assign_last_acceptor = True , task_index = None , ) : [EOL] logging_prefix = f"{ task_index + [number] } [string] " if task_index is not None else [string] [EOL] [EOL] try : [EOL] task , _ = self . service . api . get_task ( project_id , task_id ) [EOL] if task [ [string] ] != [string] : [EOL] logger . warning ( f"{ logging_prefix } [string] { task_id } [string] " f" [string] { task [ [string] ] } [string] { task [ [string] ] }" ) [EOL] return False [EOL] [EOL] acceptor_account_id = None [EOL] if assign_last_acceptor : [EOL] acceptor_account_id = task [ [string] ] [EOL] if acceptor_account_id is not None : [EOL] user_info = self . facade . get_organization_member_from_account_id ( project_id , acceptor_account_id ) [EOL] if user_info is not None : [EOL] acceptor_user_id = user_info [ [string] ] [EOL] [EOL] if not self . confirm_processing ( f"{ logging_prefix } [string] { task_id } [string] { acceptor_user_id } [string] " ) : [EOL] return False [EOL] [EOL] request_body = { [string] : [string] , [string] : acceptor_account_id , [string] : task [ [string] ] , } [EOL] self . service . api . operate_task ( project_id , task_id , request_body = request_body ) [EOL] logger . info ( f"{ logging_prefix } [string] { task_id } [string] { acceptor_user_id } [string] " ) [EOL] return True [EOL] [EOL] except requests . exceptions . HTTPError as e : [EOL] logger . warning ( f"{ logging_prefix } [string] { task_id } [string] " ) [EOL] logger . warning ( e ) [EOL] return False [EOL] [EOL] def cancel_acceptance_for_wrapper ( self , tpl , project_id , acceptor_user_id = None , assign_last_acceptor = True , ) : [EOL] task_index , task_id = tpl [EOL] return self . cancel_acceptance_for_task ( project_id = project_id , task_id = task_id , acceptor_user_id = acceptor_user_id , assign_last_acceptor = assign_last_acceptor , task_index = task_index , ) [EOL] [EOL] def cancel_acceptance_for_task_list ( self , project_id , task_id_list , acceptor_user_id = None , assign_last_acceptor = True , parallelism = None , ) : [EOL] [docstring] [EOL] logger . info ( f" [string] { len ( task_id_list ) }" ) [EOL] [EOL] success_count = [number] [EOL] if parallelism is not None : [EOL] partial_func = partial ( self . cancel_acceptance_for_wrapper , project_id = project_id , acceptor_user_id = acceptor_user_id , assign_last_acceptor = assign_last_acceptor , ) [EOL] with multiprocessing . Pool ( parallelism ) as pool : [EOL] result_bool_list = pool . map ( partial_func , enumerate ( task_id_list ) ) [EOL] success_count = len ( [ e for e in result_bool_list if e ] ) [EOL] [EOL] else : [EOL] [comment] [EOL] success_count = [number] [EOL] for task_index , task_id in enumerate ( task_id_list ) : [EOL] result = self . cancel_acceptance_for_task ( project_id , task_id , task_index = task_index , acceptor_user_id = acceptor_user_id , assign_last_acceptor = assign_last_acceptor , ) [EOL] if result : [EOL] success_count += [number] [EOL] [EOL] logger . info ( f"{ success_count } [string] { len ( task_id_list ) } [string] " ) [EOL] [EOL] [EOL] class CancelAcceptance ( AbstractCommandLineInterface ) : [EOL] @ staticmethod def validate ( args ) : [EOL] COMMON_MESSAGE = [string] [EOL] [EOL] if args . parallelism is not None and not args . yes : [EOL] print ( f"{ COMMON_MESSAGE } [string] " , file = sys . stderr , ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] if not self . validate ( args ) : [EOL] return [EOL] [EOL] task_id_list = annofabcli . common . cli . get_list_from_args ( args . task_id ) [EOL] [EOL] assign_last_acceptor = not args . not_assign and args . assigned_acceptor_user_id is None [EOL] [EOL] super ( ) . validate_project ( args . project_id , [ ProjectMemberRole . OWNER ] ) [EOL] main_obj = CancelAcceptanceMain ( self . service , all_yes = args . yes ) [EOL] main_obj . cancel_acceptance_for_task_list ( args . project_id , task_id_list , acceptor_user_id = args . assigned_acceptor_user_id , assign_last_acceptor = assign_last_acceptor , parallelism = args . parallelism , ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] CancelAcceptance ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , required = True , nargs = [string] , help = [string] , ) [EOL] [EOL] [comment] [EOL] assign_group = parser . add_mutually_exclusive_group ( ) [EOL] [EOL] assign_group . add_argument ( [string] , action = [string] , help = [string] [string] ) [EOL] [EOL] assign_group . add_argument ( [string] , type = str , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $annofabcli.common.facade.AnnofabApiFacade$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $functools.partial[builtins.bool]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $builtins.bool$ 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $annofabcli.task.cancel_acceptance.CancelAcceptanceMain$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $annofabcli.task.cancel_acceptance.CancelAcceptanceMain$ 0 0 0 $argparse.Namespace$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $argparse.Namespace$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import typing [EOL] import pathlib [EOL] import argparse [EOL] import logging . handlers [EOL] import time [EOL] import uuid [EOL] from pathlib import Path [EOL] [EOL] import pyquery [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , ArgumentParser , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class UploadInstruction ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def upload_html_to_instruction ( self , project_id , html_path ) : [EOL] pq_html = pyquery . PyQuery ( filename = str ( html_path ) ) [EOL] pq_img = pq_html ( [string] ) [EOL] [EOL] [comment] [EOL] for img_elm in pq_img : [EOL] src_value = img_elm . attrib . get ( [string] ) [EOL] if src_value is None : [EOL] continue [EOL] [EOL] if src_value . startswith ( [string] ) or src_value . startswith ( [string] ) or src_value . startswith ( [string] ) : [EOL] continue [EOL] [EOL] if src_value [ [number] ] == [string] : [EOL] img_path = Path ( src_value ) [EOL] else : [EOL] img_path = html_path . parent / src_value [EOL] [EOL] if img_path . exists ( ) : [EOL] image_id = str ( uuid . uuid4 ( ) ) [EOL] img_url = self . service . wrapper . upload_instruction_image ( project_id , image_id , str ( img_path ) ) [EOL] [EOL] logger . debug ( f" [string] { img_path } [string] { img_url }" ) [EOL] img_elm . attrib [ [string] ] = img_url [EOL] time . sleep ( [number] ) [EOL] [EOL] else : [EOL] logger . warning ( f" [string] { img_path }" ) [EOL] [EOL] [comment] [EOL] html_data = pq_html ( [string] ) . html ( ) [EOL] self . update_instruction ( project_id , html_data ) [EOL] logger . info ( [string] ) [EOL] [EOL] def update_instruction ( self , project_id , html_data ) : [EOL] histories , _ = self . service . api . get_instruction_history ( project_id ) [EOL] if len ( histories ) > [number] : [EOL] last_updated_datetime = histories [ [number] ] [ [string] ] [EOL] else : [EOL] last_updated_datetime = None [EOL] [EOL] request_body = { [string] : html_data , [string] : last_updated_datetime } [EOL] self . service . api . put_instruction ( project_id , request_body = request_body ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] self . upload_html_to_instruction ( args . project_id , Path ( args . html ) ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] UploadInstruction ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] argument_parser = ArgumentParser ( parser ) [EOL] [EOL] argument_parser . add_project_id ( ) [EOL] [EOL] [comment] [EOL] parser . add_argument ( [string] , type = str , required = True , help = [string] ) [EOL] [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = ( [string] + [string] [string] ) [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , Optional [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import annofabcli [EOL] import pyquery [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import mimetypes [EOL] from typing import Optional [EOL] [EOL] import requests [EOL] from annofabapi . models import ProjectMemberRole [EOL] from pyquery import PyQuery [EOL] [EOL] import annofabcli [EOL] from annofabcli import AnnofabApiFacade [EOL] from annofabcli . common . cli import AbstractCommandLineInterface , build_annofabapi_resource_and_login [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CopyInstruction ( AbstractCommandLineInterface ) : [EOL] [docstring] [EOL] [EOL] def validate_projects ( self , src_project_id , dest_project_id ) : [EOL] [docstring] [EOL] super ( ) . validate_project ( src_project_id , project_member_roles = None ) [EOL] super ( ) . validate_project ( dest_project_id , project_member_roles = [ ProjectMemberRole . ACCEPTER , ProjectMemberRole . OWNER ] ) [EOL] [EOL] @ staticmethod def get_instruction_image_id_from_url ( url ) : [EOL] [comment] [EOL] url_without_query = url . split ( [string] ) [ [number] ] [EOL] return url_without_query . split ( [string] ) [ - [number] ] [EOL] [EOL] @ staticmethod def _get_mime_type_from_filename ( filename ) : [EOL] [docstring] [EOL] DEFAULT_MIME_TYPE = [string] [EOL] if filename is None : [EOL] return DEFAULT_MIME_TYPE [EOL] [EOL] content_type = mimetypes . guess_type ( filename ) [ [number] ] [EOL] return content_type if content_type is not None else DEFAULT_MIME_TYPE [EOL] [EOL] def upload_instruction_image ( self , src_project_id , dest_project_id , pq_img ) : [EOL] [docstring] [EOL] [EOL] src_instruction_image_url = pq_img . attr [ [string] ] [EOL] if src_instruction_image_url is None : [EOL] logger . warning ( f"{ pq_img } [string] " ) [EOL] return None [EOL] [EOL] logger . debug ( f" [string] { src_instruction_image_url } [string] " ) [EOL] instruction_image_id = self . get_instruction_image_id_from_url ( src_instruction_image_url ) [EOL] [EOL] [comment] [EOL] content_type = self . _get_mime_type_from_filename ( pq_img . attr [ [string] ] ) [EOL] [EOL] try : [EOL] response_image = self . service . api . _request_get_with_cookie ( src_project_id , src_instruction_image_url ) [EOL] except requests . exceptions . RequestException as e : [EOL] logger . warning ( f" [string] { e }" ) [EOL] return None [EOL] [EOL] dest_instruction_image_url = self . service . wrapper . upload_data_as_instruction_image ( dest_project_id , instruction_image_id , data = response_image . content , content_type = content_type ) [EOL] return dest_instruction_image_url [EOL] [EOL] def put_instruction ( self , project_id , instruction_html ) : [EOL] old_instruction = self . service . wrapper . get_latest_instruction ( project_id ) [EOL] request_body = { [string] : instruction_html , [string] : old_instruction [ [string] ] if old_instruction is not None else None , } [EOL] self . service . api . put_instruction ( project_id , request_body = request_body ) [EOL] [EOL] def register_instruction ( self , src_project_id , dest_project_id , instruction_html ) : [EOL] [docstring] [EOL] [EOL] pq_html = PyQuery ( instruction_html ) [EOL] pq_img_list = pq_html ( [string] ) [EOL] [EOL] for img_elm in pq_img_list : [EOL] pq_img = PyQuery ( img_elm ) [EOL] [EOL] dest_instruction_image_url = self . upload_instruction_image ( src_project_id , dest_project_id , pq_img ) [EOL] if dest_instruction_image_url is not None : [EOL] pq_img . attr [ [string] ] = dest_instruction_image_url [comment] [EOL] [EOL] self . put_instruction ( dest_project_id , str ( pq_html ) ) [EOL] [EOL] def copy_instruction ( self , src_project_id , dest_project_id ) : [EOL] self . validate_projects ( src_project_id , dest_project_id ) [EOL] src_project_title = self . facade . get_project_title ( src_project_id ) [EOL] dest_project_title = self . facade . get_project_title ( dest_project_id ) [EOL] [EOL] src_instruction = self . service . wrapper . get_latest_instruction ( src_project_id ) [EOL] if src_instruction is None : [EOL] logger . warning ( f" [string] { src_project_title } [string] " ) [EOL] return [EOL] [EOL] if not self . confirm_processing ( f" [string] { src_project_title } [string] { dest_project_title } [string] " ) : [EOL] return [EOL] [EOL] self . register_instruction ( src_project_id , dest_project_id , instruction_html = src_instruction [ [string] ] ) [EOL] [EOL] def main ( self ) : [EOL] args = self . args [EOL] [EOL] self . copy_instruction ( src_project_id = args . src_project_id , dest_project_id = args . dest_project_id ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] service = build_annofabapi_resource_and_login ( args ) [EOL] facade = AnnofabApiFacade ( service ) [EOL] CopyInstruction ( service , facade , args ) . main ( ) [EOL] [EOL] [EOL] def parse_args ( parser ) : [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . set_defaults ( subcommand_func = main ) [EOL] [EOL] [EOL] def add_parser ( subparsers ) : [EOL] subcommand_name = [string] [EOL] subcommand_help = [string] [EOL] description = [string] [EOL] epilog = [string] [EOL] parser = annofabcli . common . cli . add_parser ( subparsers , subcommand_name , subcommand_help , description , epilog = epilog ) [EOL] parse_args ( parser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pyquery.PyQuery$ 0 0 0 0 0 0 $builtins.str$ 0 $pyquery.PyQuery$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 $pyquery.PyQuery$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pyquery.PyQuery$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0