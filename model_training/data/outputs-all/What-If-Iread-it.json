from typing import Any [EOL] import typing [EOL] import sys [EOL] import pytest [EOL] [EOL] [EOL] def run_tests ( ) : [EOL] exitcode = pytest . main ( [ [string] ] ) [EOL] if exitcode : [EOL] sys . exit ( exitcode ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run_tests ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import io [EOL] import typing [EOL] import jinja2 [EOL] import os [EOL] import shutil [EOL] [EOL] import apistar [EOL] import jinja2 [EOL] from apistar import App , codecs [EOL] [EOL] from app import routes [EOL] [EOL] [EOL] def make_doc ( directory ) : [EOL] app = App ( routes = routes ) [EOL] codec = codecs . OpenAPICodec ( ) [EOL] content = codec . encode ( app . document ) [EOL] document = codec . decode ( content ) [EOL] [EOL] loader = jinja2 . PrefixLoader ( { [string] : jinja2 . PackageLoader ( [string] , [string] ) } ) [EOL] env = jinja2 . Environment ( autoescape = True , loader = loader ) [EOL] [EOL] template = env . get_template ( [string] ) [EOL] code_style = None [comment] [EOL] output_text = template . render ( document = document , langs = [ [string] , [string] ] , code_style = code_style , static_url = lambda x : x , ) [EOL] [EOL] output_path = os . path . join ( directory , [string] ) [EOL] if not os . path . exists ( directory ) : [EOL] os . makedirs ( directory ) [EOL] output_file = open ( output_path , [string] ) [EOL] output_file . write ( output_text ) [EOL] output_file . close ( ) [EOL] [EOL] static_dir = os . path . join ( os . path . dirname ( apistar . __file__ ) , [string] ) [EOL] apistar_static_dir = os . path . join ( directory , [string] ) [EOL] if os . path . exists ( apistar_static_dir ) : [EOL] shutil . rmtree ( apistar_static_dir ) [EOL] shutil . copytree ( static_dir , apistar_static_dir ) [EOL] [EOL] print ( f" [string] { output_path }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] make_doc ( directory = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from app import app [EOL] from wsgicors import CORS [EOL] from readit import settings [EOL] from readit . db import db_init [EOL] from readit . sentry import init_sentry [EOL] [EOL] app = CORS ( app , headers = [string] , methods = [string] , origin = [string] , maxage = [string] ) [EOL] db_init ( ) [EOL] if not settings . Server . in_debug : [EOL] init_sentry ( ) [EOL]	0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import backend [EOL] import factory [EOL] from factory import fuzzy [EOL] from factory . faker import faker [EOL] from factory . mongoengine import MongoEngineFactory [EOL] from readit . users . models import User [EOL] from readit . books . models import Book [EOL] [EOL] [EOL] class UserFactory ( MongoEngineFactory ) : [EOL] class Meta : [EOL] model = User [EOL] [EOL] name = factory . Faker ( [string] ) [EOL] surname = factory . Faker ( [string] ) [EOL] avatar = [string] [EOL] external_id = factory . Sequence ( lambda n : f" [string] { n }" ) [EOL] auth_type = fuzzy . FuzzyChoice ( [ x for x in range ( [number] ) ] ) [EOL] [EOL] [EOL] class BookFactory ( MongoEngineFactory ) : [EOL] class Meta : [EOL] model = Book [EOL] [EOL] title = factory . Faker ( [string] ) [EOL] pages = factory . LazyFunction ( lambda : [ text for text in faker . Faker ( ) . text ( ) ] ) [EOL] author = factory . Faker ( [string] ) [EOL] cover = [string] [EOL] page_active = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.tests.stubs_factory.BookFactory.Meta]$ 0 0 0 0 $typing.Type[backend.tests.stubs_factory.UserFactory]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.tests.stubs_factory.UserFactory]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[backend.tests.stubs_factory.UserFactory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.tests.stubs_factory.UserFactory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.tests.stubs_factory.BookFactory.Meta]$ 0 0 0 0 $typing.Type[backend.tests.stubs_factory.BookFactory]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.tests.stubs_factory.BookFactory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.tests.stubs_factory.BookFactory]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from unittest import mock [EOL] [EOL] from app import app [EOL] [EOL] [EOL] def test_create_book_validation_test ( authorized_client ) : [EOL] response = authorized_client . post ( app . reverse_uri ( [string] ) , json = { [string] : [string] } ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_create_book ( authorized_client ) : [EOL] body = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] with mock . patch ( [string] ) as converter_mock : [EOL] converter_mock . return_value . convert . return_value = [ [string] , [string] , [string] ] [EOL] [EOL] response = authorized_client . post ( app . reverse_uri ( [string] ) , json = body ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . json ( ) [EOL] [EOL] [EOL] def test_list_books ( authorized_client , books_factory ) : [EOL] books = books_factory ( [number] ) [EOL] resp = authorized_client . get ( app . reverse_uri ( [string] ) ) [EOL] assert resp . status_code == [number] [EOL] assert len ( resp . json ( ) ) == len ( books ) [EOL] [EOL] [EOL] def test_create_book_invalid_format ( authorized_client ) : [EOL] body = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = authorized_client . post ( app . reverse_uri ( [string] ) , json = body ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . json ( ) [EOL] assert [string] in response . json ( ) [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import tests [EOL] import typing [EOL] from functools import partial [EOL] from typing import Tuple [EOL] [EOL] import mongoengine [EOL] import pytest [EOL] from molten import testing [EOL] [EOL] from app import app [EOL] from readit import components [EOL] from tests . stubs_factory import BookFactory , UserFactory [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def test_db ( ) : [EOL] mongoengine . register_connection ( alias = [string] , host = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def client ( ) : [EOL] return testing . TestClient ( app ) [EOL] [EOL] [EOL] @ pytest . fixture def user ( ) : [EOL] user = UserFactory . create ( ) [EOL] yield user [EOL] user . delete ( ) [EOL] [EOL] [EOL] @ pytest . fixture def book ( user ) : [EOL] book = BookFactory ( owner_id = user . id ) [EOL] yield book [EOL] book . delete ( ) [EOL] [EOL] [EOL] @ pytest . fixture def books_factory ( user ) : [EOL] books = [ ] [EOL] [EOL] def make_books ( amount = [number] ) : [EOL] nonlocal books [EOL] for _ in range ( amount ) : [EOL] book = BookFactory ( owner_id = user . id ) [EOL] books . append ( book ) [EOL] return tuple ( books ) [EOL] [EOL] yield make_books [EOL] [EOL] for book in books : [EOL] book . delete ( ) [EOL] [EOL] [EOL] @ pytest . fixture def authorized_client ( user ) : [EOL] class AuthClient ( testing . TestClient ) : [EOL] pass [EOL] [EOL] def add_auth_header ( req ) : [EOL] req . headers [ [string] ] = components . User ( str ( user . id ) ) . as_token ( ) [EOL] return req [EOL] [EOL] client = AuthClient ( app ) [EOL] client . request = partial ( client . request , auth = add_auth_header ) [EOL] return client [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from itertools import count , takewhile [EOL] [EOL] [EOL] def sliced ( seq , n ) : [EOL] [docstring] [EOL] return takewhile ( bool , ( seq [ i : i + n ] for i in count ( [number] , n ) ) ) [EOL] [EOL] [EOL] class classproperty : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , f ) : [EOL] self . f = f [EOL] [EOL] def __get__ ( self , instance , owner ) : [EOL] return self . f ( owner ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import backend [EOL] import builtins [EOL] import os [EOL] [EOL] [EOL] class DB : [EOL] hostname = os . environ . get ( [string] , [string] ) [EOL] port = int ( os . environ . get ( [string] , [number] ) ) [EOL] username = os . environ . get ( [string] ) [EOL] password = os . environ . get ( [string] ) [EOL] [EOL] [EOL] class Secrets : [EOL] jwt_sign = os . environ . get ( [string] , [string] ) [EOL] vk_app = os . environ . get ( [string] , [string] ) [EOL] google_app = os . environ . get ( [string] , [string] ) [EOL] github_app = os . environ . get ( [string] , [string] ) [EOL] [EOL] [EOL] class Server : [EOL] host = os . environ . get ( [string] , [string] ) [EOL] port = int ( os . environ . get ( [string] , [number] ) ) [EOL] in_debug = os . environ . get ( [string] , [string] ) . lower ( ) == [string] [EOL] frontend_server_url = os . environ . get ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [EOL] import sentry_sdk [EOL] from sentry_sdk . integrations . logging import LoggingIntegration [EOL] [EOL] sentry_logging = LoggingIntegration ( level = logging . INFO , event_level = logging . ERROR ) [EOL] [EOL] [EOL] def init_sentry ( ) : [EOL] sentry_sdk . init ( [string] , integrations = [ sentry_logging ] , ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Dict [EOL] import inspect [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import molten [EOL] import logging [EOL] from inspect import Parameter [EOL] from typing import Optional [EOL] [EOL] import jwt [EOL] from molten import HTTPError , HTTP_401 , HTTP_403 , Header [EOL] [EOL] from readit . settings import Secrets [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class User : [EOL] def __init__ ( self , id_ ) : [EOL] self . id = id_ [EOL] [EOL] @ classmethod def from_token ( cls , token ) : [EOL] data = jwt . decode ( token , key = Secrets . jwt_sign ) [EOL] return cls ( id_ = data [ [string] ] ) [EOL] [EOL] def as_token ( self ) : [EOL] return jwt . encode ( { [string] : self . id } , key = Secrets . jwt_sign ) [EOL] [EOL] [EOL] class UserComponent : [EOL] is_cacheable = True [EOL] is_singleton = False [EOL] [EOL] def can_handle_parameter ( self , parameter ) : [EOL] return parameter . annotation is User [EOL] [EOL] def resolve ( self , authentication ) : [EOL] [docstring] [EOL] if authentication is None : [EOL] raise HTTPError ( HTTP_401 , { [string] : [string] } ) [EOL] [EOL] try : [EOL] return User . from_token ( authentication ) [EOL] except Exception as err : [EOL] LOGGER . error ( f" [string] { err }" ) [EOL] raise HTTPError ( HTTP_403 , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $inspect.Parameter$ 0 0 0 0 $inspect.Parameter$ 0 0 0 0 0 0 0 $User$ 0 0 0 $typing.Optional[molten.Header]$ 0 0 0 0 0 0 $typing.Optional[molten.Header]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[molten.Header]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from molten import Route [EOL] [EOL] from . import views [EOL] [EOL] routes = [ Route ( [string] , views . list_books , [string] ) , Route ( [string] , views . create_book , [string] ) , Route ( [string] , views . get_book , [string] ) , Route ( [string] , views . update_book , [string] ) , Route ( [string] , views . delete_book , [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import builtins [EOL] from typing import List , Optional [EOL] [EOL] from molten import Field , schema [EOL] [EOL] from readit . books . convertor import Converter [EOL] [EOL] [EOL] @ schema class WithID : [EOL] id = Field ( response_only = True ) [EOL] [EOL] [EOL] @ schema class BookNoContent ( WithID ) : [EOL] title = Field ( description = [string] ) [EOL] author = Field ( description = [string] , max_length = [number] , strip_spaces = True ) [EOL] cover = Field ( description = [string] ) [EOL] [EOL] [EOL] @ schema class BookWithFile ( BookNoContent ) : [EOL] file = Field ( description = [string] , request_only = True ) [EOL] format = Field ( description = [string] , request_only = True , choices = Converter . supported_formats , ) [EOL] [EOL] [EOL] @ schema class BookContent ( BookNoContent ) : [EOL] pages = Field ( description = [string] , response_only = True ) [EOL] page_active = Field ( description = [string] , response_only = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Dict , Union [EOL] import typing [EOL] import backend [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import datetime [EOL] from typing import Union [EOL] [EOL] from mongoengine import ( StringField , DateTimeField , ListField , Document , IntField , ReferenceField , ) [EOL] [EOL] from readit . users . models import User [EOL] [EOL] [EOL] class Book ( Document ) : [EOL] created_date = DateTimeField ( default = datetime . datetime . now ) [EOL] [EOL] title = StringField ( max_length = [number] ) [EOL] pages = ListField ( StringField ( ) ) [EOL] author = StringField ( max_length = [number] ) [EOL] cover = StringField ( ) [EOL] page_active = IntField ( default = [number] ) [EOL] owner_id = ReferenceField ( User ) [EOL] [EOL] meta = { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } [EOL] [EOL] @ classmethod def get_user_book ( cls , id_ , owner_id ) : [EOL] return cls . objects ( pk = id_ , owner_id = owner_id ) . first ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.books.models.Book]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[Book,None]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0
from typing import Any , List , Optional [EOL] import backend [EOL] import typing [EOL] import schema [EOL] import readit [EOL] import builtins [EOL] import molten [EOL] import base64 [EOL] from typing import List [EOL] [EOL] from molten import RequestData , http , HTTP_404 [EOL] from molten . errors import HTTPError [EOL] [EOL] from readit . components import User [EOL] from . import schema [EOL] from . convertor import Converter [EOL] from . models import Book [EOL] [EOL] [EOL] def list_books ( user ) : [EOL] books = Book . objects ( owner_id = user . id ) . exclude ( [string] ) . order_by ( [string] ) [EOL] return [ schema . BookNoContent ( id = str ( book . id ) , title = book . title , author = book . author , cover = book . cover ) for book in books ] [EOL] [EOL] [EOL] def get_book ( book_id , user ) : [EOL] book = Book . get_user_book ( book_id , owner_id = user . id ) [EOL] if not book : [EOL] raise HTTPError ( http . HTTP_404 ) [EOL] return schema . BookContent ( id = str ( book . id ) , title = book . title , author = book . author , pages = book . pages , cover = book . cover , page_active = book . page_active , ) [EOL] [EOL] [EOL] def update_book ( book_id , r_data , user ) : [EOL] book = Book . get_user_book ( book_id , owner_id = user . id ) [EOL] if not book : [EOL] raise HTTPError ( http . HTTP_404 ) [EOL] book . update ( pk = book_id , ** r_data ) [EOL] [EOL] [EOL] def create_book ( book_data , user ) : [EOL] pages = Converter ( book_data . format ) . convert ( base64 . b64decode ( book_data . file ) ) [EOL] book = Book ( title = book_data . title , author = book_data . author , pages = pages , cover = book_data . cover , owner_id = user . id , ) [EOL] book . save ( ) [EOL] return schema . WithID ( id = str ( book . id ) ) [EOL] [EOL] [EOL] def delete_book ( book_id , user ) : [EOL] book = Book . get_user_book ( book_id , user . id ) [EOL] if not book : [EOL] raise HTTPError ( HTTP_404 ) [EOL] book . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[schema.BookNoContent]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $schema.BookContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $schema.WithID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , Optional , Any , ClassVar , Dict , Tuple [EOL] import requests [EOL] import typing [EOL] import backend [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] from collections import namedtuple [EOL] import base64 [EOL] import requests [EOL] from enum import IntEnum [EOL] from typing import ClassVar , Dict , Type , Tuple , Optional [EOL] from readit import settings [EOL] from . models import User as UserDB [EOL] [EOL] User = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class AuthTypes ( IntEnum ) : [EOL] vk = [number] [EOL] google = [number] [EOL] github = [number] [EOL] guest = [number] [EOL] [EOL] @ classmethod def options ( cls ) : [EOL] return [ v . name for v in cls ] [EOL] [EOL] [EOL] class AuthClient : [EOL] _clients = { } [EOL] [EOL] def __init__ ( self , service , code , redirect_url ) : [EOL] self . _client = self . _clients [ service ] ( code , redirect_url ) [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] return getattr ( self . _client , item ) [EOL] [EOL] @ classmethod def add_client ( cls , client_type , client ) : [EOL] cls . _clients [ client_type ] = client [EOL] [EOL] [EOL] class AuthClientBase : [EOL] service_type = ... [EOL] [EOL] def __init__ ( self , code , redirect_url ) : [EOL] self . redirect_url = redirect_url [EOL] self . code = code [EOL] self . user_id = ... [EOL] self . token = ... [EOL] self . user = ... [EOL] [EOL] def __init_subclass__ ( cls , ** kwargs ) : [EOL] super ( ) . __init_subclass__ ( ** kwargs ) [EOL] AuthClient . add_client ( cls . service_type , cls ) [EOL] [EOL] [EOL] class VKClient ( AuthClientBase ) : [EOL] service_type = AuthTypes . vk [EOL] api_version = [string] [EOL] [EOL] def __init__ ( self , code , redirect_url ) : [EOL] super ( ) . __init__ ( code , redirect_url ) [EOL] self . user_id , self . token = self . _init_token ( ) [EOL] self . _user = None [EOL] [EOL] def _init_token ( self ) : [EOL] resp = requests . get ( [string] , params = { [string] : [string] , [string] : settings . Secrets . vk_app , [string] : self . redirect_url , [string] : self . code , } , ) [EOL] resp . raise_for_status ( ) [EOL] data = resp . json ( ) [EOL] return str ( data [ [string] ] ) , data [ [string] ] [EOL] [EOL] @ property def user ( self ) : [EOL] if self . _user is None : [EOL] data = requests . get ( [string] , params = { [string] : [string] , [string] : self . token , [string] : self . api_version , } , ) . json ( ) [EOL] user = data [ [string] ] [ [number] ] [EOL] if user [ [string] ] : [EOL] photo = base64 . b64encode ( requests . get ( user [ [string] ] ) . content ) [EOL] else : [EOL] photo = [string] [EOL] self . _user = User ( user [ [string] ] , user [ [string] ] , str ( user [ [string] ] ) , photo ) [EOL] return self . _user [EOL] [EOL] [EOL] class GoogleClient ( AuthClientBase ) : [EOL] service_type = AuthTypes . google [EOL] [EOL] def __init__ ( self , code , redirect_url ) : [EOL] super ( ) . __init__ ( code , redirect_url ) [EOL] self . token = self . _init_token ( ) [EOL] self . user = self . _get_user ( ) [EOL] self . user_id = self . user . id [EOL] [EOL] def _init_token ( self ) : [EOL] resp = requests . post ( [string] , data = { [string] : self . code , [string] : [string] , [string] : settings . Secrets . google_app , [string] : self . redirect_url , [string] : [string] , } , ) [EOL] resp . raise_for_status ( ) [EOL] data = resp . json ( ) [EOL] return data [ [string] ] [EOL] [EOL] def _get_user ( self ) : [EOL] user = requests . get ( [string] , params = { [string] : [string] , [string] : [string] } , headers = { [string] : f" [string] { self . token }" } , ) . json ( ) [EOL] if user [ [string] ] and not user [ [string] ] [ [number] ] . get ( [string] ) : [EOL] photo = base64 . b64encode ( requests . get ( user [ [string] ] [ [number] ] [ [string] ] ) . content ) [EOL] else : [EOL] photo = [string] [EOL] return User ( name = user [ [string] ] [ [number] ] [ [string] ] , surname = user [ [string] ] [ [number] ] [ [string] ] , id = str ( user [ [string] ] [ [number] ] [ [string] ] [ [string] ] [ [string] ] ) , avatar = photo , ) [EOL] [EOL] [EOL] class GithubClient ( AuthClientBase ) : [EOL] service_type = AuthTypes . github [EOL] [EOL] def __init__ ( self , code , redirect_url ) : [EOL] super ( ) . __init__ ( code , redirect_url ) [EOL] self . token = self . _init_token ( ) [EOL] self . user = self . _get_user ( ) [EOL] self . user_id = self . user . id [EOL] [EOL] def _init_token ( self ) : [EOL] response = requests . post ( [string] , params = { [string] : [string] , [string] : settings . Secrets . github_app , [string] : self . code , [string] : self . redirect_url , } , headers = { [string] : [string] } , ) [EOL] response . raise_for_status ( ) [EOL] token = response . json ( ) [ [string] ] [EOL] return token [EOL] [EOL] def _get_user ( self ) : [EOL] response = requests . get ( [string] , headers = { [string] : f" [string] { self . token }" } , ) [EOL] response . raise_for_status ( ) [EOL] user = response . json ( ) [EOL] photo = base64 . b64encode ( requests . get ( user [ [string] ] ) . content ) [EOL] return User ( id = str ( user [ [string] ] ) , name = user [ [string] ] , surname = [string] , avatar = photo ) [EOL] [EOL] [EOL] class GuestClient ( AuthClientBase ) : [EOL] service_type = AuthTypes . guest [EOL] [EOL] def __init__ ( self , code , redirect_url ) : [EOL] super ( ) . __init__ ( code , redirect_url ) [EOL] self . token = [string] [EOL] self . user = self . _get_user ( ) [EOL] self . user_id = self . user . id [EOL] [EOL] @ staticmethod def _get_user ( ) : [EOL] user = UserDB . objects ( auth_type = AuthTypes . guest . value ) . first ( ) [EOL] return User ( name = user . name , surname = [string] , id = str ( user . id ) , avatar = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[AuthTypes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $User$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Type , Dict [EOL] import typing [EOL] import backend [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import datetime [EOL] [EOL] from mongoengine import StringField , DateTimeField , Document , IntField [EOL] [EOL] [EOL] class User ( Document ) : [EOL] created_date = DateTimeField ( default = datetime . datetime . now ) [EOL] [EOL] name = StringField ( max_length = [number] , required = True ) [EOL] surname = StringField ( max_length = [number] ) [EOL] avatar = StringField ( ) [EOL] external_id = StringField ( required = True ) [EOL] auth_type = IntField ( required = True ) [EOL] [EOL] meta = { [string] : [string] , [string] : [string] } [EOL] [EOL] @ classmethod def find_external ( cls , external_id , auth_type ) : [EOL] return cls . objects ( external_id = external_id , auth_type = auth_type ) . first ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.users.models.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.users.models.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.users.models.User]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.users.models.User]$ 0 0 0 0 0 $typing.Type[backend.readit.users.models.User]$ 0 0 0 0 0 0 0 0 $typing.Type[backend.readit.users.models.User]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0
from typing import Any , Optional , Dict , Union [EOL] import backend [EOL] import typing [EOL] import schema [EOL] import readit [EOL] import builtins [EOL] import molten [EOL] from typing import Optional [EOL] from urllib . parse import urlencode [EOL] [EOL] from molten import HTTPError , HTTP_400 , HTTP_404 , Request , QueryParam [EOL] from molten . helpers import redirect [EOL] [EOL] from readit import components , settings [EOL] from readit . users . auth import AuthClient , AuthTypes [EOL] from . import schema [EOL] from . models import User [EOL] [EOL] OAUTH_URLS = { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , } , } [EOL] [EOL] [EOL] def auth_user ( auth_service_name , code , request ) : [EOL] route_url = request . path . split ( [string] ) [ [number] ] [EOL] if not code and auth_service_name != AuthTypes . guest . name : [EOL] [comment] [EOL] try : [EOL] auth_params = OAUTH_URLS [ auth_service_name ] [EOL] except KeyError : [EOL] raise HTTPError ( HTTP_404 ) [EOL] auth_query_params = auth_params [ [string] ] . copy ( ) [EOL] auth_query_params [ [string] ] = route_url [EOL] query = urlencode ( auth_query_params ) [EOL] return redirect ( f"{ auth_params [ [string] ] } [string] { query }" ) [EOL] [EOL] try : [EOL] auth_type = AuthTypes [ auth_service_name ] [EOL] except KeyError : [EOL] raise HTTPError ( HTTP_400 , { [string] : f" [string] { AuthTypes . options ( ) }" } , ) [EOL] [EOL] auth_client = AuthClient ( auth_type , code , route_url ) [EOL] user = User . find_external ( auth_client . user_id , auth_type . value ) [EOL] if not user : [EOL] user = User ( name = auth_client . user . name , surname = auth_client . user . surname , external_id = auth_client . user . id , auth_type = auth_type . value , avatar = auth_client . user . avatar , ) [EOL] user . save ( ) [EOL] token = components . User ( id_ = str ( user . id ) ) . as_token ( ) [EOL] query = urlencode ( { [string] : token . decode ( [string] ) } ) [EOL] return redirect ( f"{ settings . Server . frontend_server_url } [string] { query }" ) [EOL] [EOL] [EOL] def get_user ( user ) : [EOL] user_db = User . objects . with_id ( user . id ) [EOL] return schema . User ( id = str ( user_db . id ) , name = user_db . name , surname = user_db . surname , avatar = user_db . avatar , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $schema.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from molten import schema [EOL] [EOL] [EOL] @ schema class User : [EOL] id = ... [EOL] name = ... [EOL] surname = ... [EOL] avatar = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] from molten import Route [EOL] [EOL] from . import views [EOL] [EOL] routes = [ Route ( [string] , views . auth_user , [string] ) , Route ( [string] , views . get_user , [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from . setup import db_init [EOL]	0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import mongoengine [EOL] [EOL] from readit import settings [EOL] [EOL] [EOL] def db_init ( ) : [EOL] params = { [string] : settings . DB . username , [string] : settings . DB . hostname , [string] : settings . DB . password , [string] : [string] , } [EOL] mongoengine . register_connection ( host = [string] [string] . format ( ** params ) , alias = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0