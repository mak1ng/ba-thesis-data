[comment] [EOL] from typing import Dict , Any , Union , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import spfy [EOL] import abc [EOL] import asyncio [EOL] import subprocess [EOL] from time import sleep [EOL] [EOL] from . import logger [EOL] from . constants import VOLUME_FADE_SECONDS [EOL] [EOL] try : [EOL] import alsaaudio [comment] [EOL] except : [EOL] pass [EOL] [EOL] [EOL] def cap ( volume , _min = [number] , _max = [number] ) : [EOL] return min ( max ( volume , _min ) , _max ) [EOL] [EOL] [EOL] class VolumeControl ( abc . ABC ) : [EOL] @ abc . abstractmethod def unmute ( self ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def mute ( self ) : [EOL] pass [EOL] [EOL] @ abc . abstractproperty def volume ( self ) : [comment] [EOL] pass [EOL] [EOL] @ volume . setter def volume ( self , val ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] return abs ( device_volume - old_volume ) > ( step + [number] ) [EOL] [EOL] def fade ( self , limit = [number] , start = [number] , step = [number] , seconds = VOLUME_FADE_SECONDS , force = False ) : [EOL] try : [EOL] self . unmute ( ) [EOL] delay = seconds / ( ( limit - start ) / step ) [EOL] device_volume = self . volume [EOL] self . volume = start [EOL] for next_volume in range ( start + step , limit + [number] , step ) : [EOL] sleep ( delay ) [EOL] device_volume = self . volume [EOL] old_volume = next_volume - step [EOL] if not force and self . should_stop_fading ( device_volume , old_volume , step ) : [EOL] logger . debug ( [string] , device_volume , old_volume , ) [EOL] break [EOL] [EOL] logger . debug ( [string] , next_volume ) [EOL] self . volume = next_volume [EOL] except Exception as exc : [EOL] logger . exception ( exc ) [EOL] [EOL] [EOL] class SpotifyVolumeControl ( VolumeControl ) : [EOL] def __init__ ( self , client , device = None ) : [EOL] self . spotify = client [EOL] self . device = device [EOL] self . old_volume = None [EOL] [EOL] def mute ( self ) : [EOL] self . old_volume = self . volume [EOL] self . spotify . volume ( [number] , device = self . device ) [EOL] [EOL] def unmute ( self ) : [EOL] if self . old_volume : [EOL] self . volume = self . old_volume [EOL] else : [EOL] self . volume = [number] [EOL] [EOL] def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] is_playing = self . spotify . current_playback ( ) . is_playing [EOL] logger . debug ( [string] , is_playing ) [EOL] return ( super ( ) . should_stop_fading ( device_volume , old_volume , step ) or not is_playing ) [EOL] [EOL] @ property def volume ( self ) : [EOL] return int ( self . spotify . get_device ( device = self . device ) . volume_percent or [number] ) + [number] [EOL] [EOL] @ volume . setter def volume ( self , val ) : [EOL] self . spotify . volume ( cap ( val ) , device = self . device ) [EOL] [EOL] [EOL] class SpotifyVolumeControlAsync ( VolumeControl ) : [EOL] def __init__ ( self , client , device = None ) : [EOL] self . spotify = client [EOL] self . device = device [EOL] self . old_volume = None [EOL] [EOL] async def mute ( self ) : [EOL] self . old_volume = await self . volume ( ) [EOL] await self . spotify . volume ( [number] , device = self . device ) [EOL] [EOL] async def unmute ( self ) : [EOL] if self . old_volume : [EOL] await self . set_volume ( self . old_volume ) [EOL] else : [EOL] await self . set_volume ( [number] ) [EOL] [EOL] async def is_playing ( self ) : [EOL] playback = await self . spotify . current_playback ( ) [EOL] return playback and playback . is_playing [EOL] [EOL] async def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] is_playing = await self . is_playing ( ) [EOL] logger . debug ( [string] , is_playing ) [EOL] return ( super ( ) . should_stop_fading ( device_volume , old_volume , step ) or not is_playing ) [EOL] [EOL] async def volume ( self ) : [comment] [EOL] device = await self . spotify . get_device ( device = self . device ) [EOL] return int ( device . volume_percent or [number] ) [EOL] [EOL] async def set_volume ( self , val , fade = False , fade_seconds = [number] ) : [EOL] vol = cap ( val ) [EOL] if not fade : [EOL] await self . spotify . volume ( vol , device = self . device ) [EOL] else : [EOL] current_volume = await self . volume ( ) [EOL] step = - [number] if vol < current_volume else [number] [EOL] await self . fade ( limit = vol , start = current_volume + step , step = step , seconds = fade_seconds ) [EOL] return vol [EOL] [EOL] async def force_fade ( self , limit , step , delay ) : [EOL] def fade_done ( vol ) : [EOL] if step > [number] : [EOL] return vol >= limit [EOL] return vol <= limit [EOL] [EOL] device_volume = await self . volume ( ) [EOL] while not fade_done ( device_volume ) and ( await self . is_playing ( ) ) : [EOL] next_volume = device_volume + step [EOL] logger . debug ( [string] , next_volume ) [EOL] await self . set_volume ( next_volume ) [EOL] await asyncio . sleep ( delay ) [EOL] device_volume = await self . volume ( ) [EOL] [EOL] async def fade ( self , limit = [number] , start = [number] , step = [number] , seconds = VOLUME_FADE_SECONDS , force = False ) : [EOL] limit = cap ( limit ) [EOL] delay = seconds / ( ( limit - start ) / step ) [EOL] await self . set_volume ( start ) [EOL] [EOL] if force : [EOL] await self . force_fade ( limit , step , delay ) [EOL] else : [EOL] device_volume = await self . volume ( ) [EOL] for next_volume in range ( start + step , limit + step , step ) : [EOL] await asyncio . sleep ( delay ) [EOL] device_volume = await self . volume ( ) [EOL] old_volume = next_volume - step [EOL] should_stop_fading = await self . should_stop_fading ( device_volume , old_volume , step ) [EOL] if should_stop_fading : [EOL] logger . debug ( [string] , device_volume , old_volume , ) [EOL] break [EOL] [EOL] logger . debug ( [string] , next_volume ) [EOL] await self . set_volume ( next_volume ) [EOL] [EOL] device_volume = await self . volume ( ) [EOL] if device_volume <= abs ( step ) : [EOL] await self . spotify . pause_playback ( ) [EOL] [EOL] [EOL] class AlsaVolumeControl ( VolumeControl ) : [EOL] def __init__ ( self , mixer_name , device = None ) : [EOL] if isinstance ( device , str ) : [EOL] kwargs = dict ( device = device ) [EOL] elif isinstance ( device , int ) : [EOL] kwargs = dict ( cardindex = device ) [EOL] else : [EOL] kwargs = dict ( ) [EOL] self . mixer_name = mixer_name [EOL] self . device = device [EOL] self . mixer = alsaaudio . Mixer ( mixer_name , ** kwargs ) [EOL] [EOL] def mute ( self ) : [EOL] self . mixer . setmute ( [number] ) [EOL] [EOL] def unmute ( self ) : [EOL] self . mixer . setmute ( [number] ) [EOL] [EOL] def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] is_mute = self . mixer . getmute ( ) [ [number] ] [EOL] logger . debug ( [string] , is_mute ) [EOL] return super ( ) . should_stop_fading ( device_volume , old_volume , step ) or is_mute [EOL] [EOL] @ property def volume ( self ) : [EOL] vol = self . mixer . getvolume ( ) [EOL] return sum ( vol ) // len ( vol ) [EOL] [EOL] @ volume . setter def volume ( self , val ) : [EOL] self . mixer . setvolume ( max ( val , [number] ) ) [EOL] [EOL] [EOL] class ApplescriptVolumeControl ( VolumeControl ) : [EOL] def __init__ ( self , device = None ) : [EOL] self . device = device [EOL] self . old_volume = None [EOL] [EOL] def fade ( self , limit = [number] , start = [number] , step = [number] , seconds = VOLUME_FADE_SECONDS , force = False ) : [EOL] if self . device : [EOL] self . switch_audio_device ( self . device ) [EOL] super ( ) . fade ( limit , start , step , seconds , force ) [EOL] [EOL] @ staticmethod def osascript ( cmd ) : [EOL] cmd = f" [string] { cmd } [string] " [EOL] result = subprocess . check_output ( cmd , shell = True ) . decode ( ) . strip ( ) [EOL] logger . debug ( [string] , cmd ) [EOL] logger . debug ( [string] , result ) [EOL] return result [EOL] [EOL] @ staticmethod def switch_audio_device ( device ) : [EOL] logger . debug ( [string] , device ) [EOL] subprocess . call ( f' [string] { device } [string] ' , shell = True ) [EOL] [EOL] def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] is_playing = ( self . osascript ( [string] ) == [string] ) [EOL] logger . debug ( [string] , is_playing ) [EOL] return ( super ( ) . should_stop_fading ( device_volume , old_volume , step ) or not is_playing ) [EOL] [EOL] def spotify_mute ( self ) : [EOL] self . old_volume = self . spotify_volume [EOL] self . osascript ( [string] ) [EOL] [EOL] def spotify_unmute ( self ) : [EOL] if self . old_volume : [EOL] self . spotify_volume = self . old_volume [EOL] else : [EOL] self . spotify_volume = [number] [EOL] [EOL] def mute ( self ) : [EOL] self . osascript ( [string] ) [EOL] [EOL] def unmute ( self ) : [EOL] self . osascript ( [string] ) [EOL] [EOL] @ property def spotify_volume ( self ) : [EOL] return int ( self . osascript ( [string] ) ) + [number] [EOL] [EOL] @ spotify_volume . setter def spotify_volume ( self , val ) : [EOL] self . osascript ( f' [string] { max ( val , [number] ) }' ) [EOL] [EOL] @ property def system_volume ( self ) : [EOL] return int ( self . osascript ( [string] ) ) [EOL] [EOL] @ system_volume . setter def system_volume ( self , val ) : [EOL] self . osascript ( f" [string] { max ( val , [number] ) }" ) [EOL] [EOL] @ property def volume ( self ) : [EOL] return self . system_volume [EOL] [EOL] @ volume . setter def volume ( self , val ) : [EOL] self . old_volume = self . volume [EOL] self . system_volume = val [EOL] self . spotify_volume = val // [number] [EOL] [EOL] [EOL] class LinuxVolumeControl ( AlsaVolumeControl ) : [EOL] def __init__ ( self , spotify_client , alsa_mixer_name , spotify_device = None , alsa_device = None ) : [EOL] super ( ) . __init__ ( alsa_mixer_name , device = alsa_device ) [EOL] self . spotify_volume_control = SpotifyVolumeControl ( spotify_client , spotify_device ) [EOL] [EOL] def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] return super ( ) . should_stop_fading ( device_volume , old_volume , step ) or self . spotify_should_stop_fading ( device_volume , old_volume , step ) [EOL] [EOL] def spotify_should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] return self . spotify_volume_control . should_stop_fading ( device_volume , old_volume , step ) [EOL] [EOL] [EOL] class LinuxVolumeControlAsync ( AlsaVolumeControl ) : [EOL] def __init__ ( self , spotify_client , alsa_mixer_name , spotify_device = None , alsa_device = None ) : [EOL] super ( ) . __init__ ( alsa_mixer_name , device = alsa_device ) [EOL] self . spotify_volume_control = SpotifyVolumeControlAsync ( spotify_client , spotify_device ) [EOL] [EOL] async def should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] return super ( ) . should_stop_fading ( device_volume , old_volume , step ) or await self . spotify_should_stop_fading ( device_volume , old_volume , step ) [EOL] [EOL] async def spotify_should_stop_fading ( self , device_volume , old_volume , step ) : [EOL] return await self . spotify_volume_control . should_stop_fading ( device_volume , old_volume , step ) [EOL] [EOL] async def fade ( self , limit = [number] , start = [number] , step = [number] , seconds = VOLUME_FADE_SECONDS , force = False ) : [EOL] try : [EOL] self . unmute ( ) [EOL] delay = seconds / ( ( limit - start ) / step ) [EOL] device_volume = self . volume [EOL] self . volume = start [EOL] for next_volume in range ( start + step , limit + [number] , step ) : [EOL] sleep ( delay ) [EOL] device_volume = self . volume [EOL] old_volume = next_volume - step [EOL] should_stop_fading = await self . should_stop_fading ( device_volume , old_volume , step ) [EOL] if not force and should_stop_fading : [EOL] logger . debug ( [string] , device_volume , old_volume , ) [EOL] break [EOL] [EOL] logger . debug ( [string] , next_volume ) [EOL] self . volume = next_volume [EOL] except Exception as exc : [EOL] logger . exception ( exc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[-1],typing_extensions.Literal]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Union[typing_extensions.Literal[-1],typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal[-1],typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal[-1],typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControlAsync$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import pandas [EOL] import inspect [EOL] from typing import Dict , List [EOL] from itertools import chain , repeat [EOL] [EOL] import pandas as pd [EOL] [EOL] from . constants import AudioFeature , AudioFeatureRange [EOL] [EOL] MAX_KEY = AudioFeatureRange . KEY . value [ - [number] ] [EOL] MAX_LOUDNESS = AudioFeatureRange . LOUDNESS . value [ [number] ] [EOL] MAX_POPULARITY = AudioFeatureRange . POPULARITY . value [ - [number] ] [EOL] [EOL] [EOL] def normalize_features ( features , track_ids ) : [EOL] [docstring] [EOL] [comment] [EOL] data = pd . DataFrame ( features , dtype = [string] , index = pd . Index ( track_ids ) ) [EOL] if AudioFeature . TEMPO . value in data : [EOL] data . tempo /= data . tempo . max ( ) [EOL] if AudioFeature . DURATION_MS . value in data : [EOL] data . duration_ms /= data . duration_ms . max ( ) [EOL] if AudioFeature . TIME_SIGNATURE . value in data : [EOL] data . time_signature /= data . time_signature . max ( ) [EOL] if AudioFeature . KEY . value in data : [EOL] data . key /= MAX_KEY [EOL] if AudioFeature . LOUDNESS . value in data : [EOL] data . loudness = [number] - data . loudness / MAX_LOUDNESS [EOL] if AudioFeature . POPULARITY . value in data : [EOL] data . popularity /= MAX_POPULARITY [EOL] return data [EOL] [EOL] [EOL] def ncycles ( iterable , n ) : [EOL] [docstring] [EOL] return chain . from_iterable ( repeat ( tuple ( iterable ) , n ) ) [EOL] [EOL] [EOL] def function_trace ( ) : [EOL] return [string] . join ( f . function for f in reversed ( inspect . stack ( ) [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] __version__ = [string] [EOL] [EOL] import pathlib [comment] [EOL] [EOL] root = pathlib . Path ( __file__ ) . parent [comment] [EOL] APP_NAME = [string] [EOL] [EOL] import os [comment] [EOL] [EOL] import kick [comment] [EOL] [EOL] kick . start ( APP_NAME . lower ( ) ) [comment] [EOL] [EOL] from kick import config , logger [comment] [EOL] [EOL] Unsplash = None [EOL] if config . unsplash . auth . client_id : [EOL] from unsplash import Auth , Api [EOL] [EOL] auth = Auth ( ** config . unsplash . auth ) [EOL] Unsplash = Api ( auth ) [EOL] from . client import SpotifyClient [EOL] from . constants import * [EOL] from . exceptions import * [EOL] from . result import SpotifyResult [EOL] from . wrapper import Spotify [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] import fire [EOL] from pony . orm import db_session [EOL] [EOL] from . import config , logger [EOL] from . client import SpotifyClient [EOL] from . constants import AuthFlow [EOL] from . mixins import PlayerMixin , RecommenderMixin [EOL] [EOL] [EOL] class Spotify ( SpotifyClient , PlayerMixin , RecommenderMixin ) : [EOL] [docstring] [EOL] [EOL] cli = False [EOL] [EOL] def __init__ ( self , * args , email = None , username = None , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . email = email or config . auth . email [EOL] self . username = username or config . auth . username [EOL] [EOL] def auth ( self , email = config . auth . email , username = config . auth . username , server = False ) : [EOL] if self . cli and not self . is_authenticated : [EOL] if server : [EOL] self . authenticate ( flow = AuthFlow . CLIENT_CREDENTIALS ) [EOL] else : [EOL] try : [EOL] self . authenticate ( email = email , username = username ) [EOL] except Exception as exc : [EOL] logger . exception ( exc ) [EOL] return self [EOL] [EOL] def __dir__ ( self ) : [EOL] names = super ( ) . __dir__ ( ) [EOL] names = [ name for name in names if not name . startswith ( [string] ) and name != [string] ] [EOL] return names [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] try : [EOL] Spotify . cli = True [EOL] with db_session : [EOL] fire . Fire ( Spotify ) [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import addict [EOL] [EOL] from . import config [EOL] [EOL] POSTGRES = config . database . connection . provider == [string] [EOL] [EOL] [EOL] SQL = addict . Dict ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] SQL_DEFAULT = addict . Dict ( { [string] : [string] if POSTGRES else None , [string] : [string] if POSTGRES else None , [string] : [string] if POSTGRES else None , [string] : [string] if POSTGRES else [string] , [string] : [string] if POSTGRES else [string] , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as _np [EOL] from cached_property import cached_property [EOL] [EOL] [EOL] class frange : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , start , stop , step ) : [EOL] [docstring] [EOL] self . slice = slice ( start , stop , step ) [EOL] [EOL] @ property def start ( self ) : [EOL] return self . slice . start [EOL] [EOL] @ property def step ( self ) : [EOL] return self . slice . step [EOL] [EOL] @ property def stop ( self ) : [EOL] return self . slice . stop [EOL] [EOL] @ cached_property def array ( self ) : [EOL] return self . get_array ( ) [EOL] [EOL] @ cached_property def generator ( self ) : [EOL] return self . get_generator ( ) [EOL] [EOL] def __getitem__ ( self , idx ) : [EOL] if idx == - [number] : [EOL] return self . stop - self . step [EOL] [EOL] if idx == [number] : [EOL] return self . start [EOL] [EOL] return self . array [ idx ] [EOL] [EOL] def get_generator ( self ) : [EOL] [docstring] [EOL] return drange ( self . start , self . stop , self . step ) [EOL] [EOL] def get_array ( self ) : [EOL] [docstring] [EOL] return _np . arange ( self . start , self . stop , self . step ) [EOL] [EOL] def __len__ ( self ) : [EOL] return self . array . size [EOL] [EOL] def __iter__ ( self ) : [EOL] return self . generator [EOL] [EOL] [EOL] def drange ( start , stop , step ) : [EOL] [docstring] [EOL] x = start [EOL] if step > [number] : [EOL] while x + step <= stop : [comment] [EOL] yield x [EOL] [EOL] x += step [EOL] elif step < [number] : [EOL] while x + step >= stop : [comment] [EOL] yield x [EOL] [EOL] x += step [EOL] else : [EOL] raise ZeroDivisionError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.slice$ 0 $builtins.slice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Dict , Iterator , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] import spfy [EOL] from datetime import datetime [EOL] from functools import lru_cache , partialmethod [EOL] from itertools import chain [EOL] from operator import attrgetter [EOL] from time import sleep [EOL] [EOL] import ujson as json [EOL] from first import first [EOL] [EOL] from . import logger [EOL] from . cache import AudioFeatures , Playlist , db , db_session , select [EOL] from . constants import ( API , DEVICE_ID_RE , MANELISTI , PLAYLIST_URI_RE , AudioFeature , TimeRange , ) [EOL] from . exceptions import ( SpotifyAuthException , SpotifyDeviceUnavailableException , SpotifyException , SpotifyForbiddenException , SpotifyRateLimitException , ) [EOL] from . mixins import AuthMixin , EmailMixin [EOL] from . result import SpotifyResult [EOL] [EOL] [EOL] class SpotifyClient ( AuthMixin , EmailMixin ) : [EOL] def __init__ ( self , * args , proxies = None , requests_timeout = None , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . proxies = proxies [EOL] self . requests_timeout = requests_timeout [EOL] [EOL] @ db_session def _increment_api_call_count ( self ) : [EOL] try : [EOL] user = self . user [EOL] except Exception : [EOL] logger . warning ( [string] , self . user_id ) [EOL] else : [EOL] user . api_calls += [number] [EOL] user . last_usage_at = datetime . utcnow ( ) [EOL] [EOL] @ staticmethod def _check_response ( response ) : [EOL] try : [EOL] response . raise_for_status ( ) [EOL] except : [EOL] exception_params = SpotifyClient . get_exception_params ( response ) [EOL] if response . status_code == [number] or ( response . status_code >= [number] and response . status_code < [number] ) : [EOL] raise SpotifyRateLimitException ( retry_after = int ( response . headers . get ( [string] , [number] ) ) , ** exception_params , ) [EOL] [EOL] if response . status_code == [number] : [EOL] raise SpotifyForbiddenException ( ** exception_params ) [EOL] [EOL] raise SpotifyException ( ** exception_params ) [EOL] [EOL] @ staticmethod def get_exception_params ( response ) : [EOL] return { [string] : response . status_code , [string] : response . url , [string] : response . headers , [string] : response . text , } [EOL] [EOL] def _internal_call ( self , method , url , payload , params , headers = None , retries = [number] , check_202 = False ) : [EOL] logger . debug ( url ) [EOL] if payload and not isinstance ( payload , ( bytes , str ) ) : [EOL] payload = json . dumps ( payload ) [EOL] r = self . session . request ( method , url , proxies = self . proxies , timeout = self . requests_timeout , headers = { [string] : [string] , ** ( headers or { } ) } , data = payload , params = { k : v for k , v in params . items ( ) if v is not None } , client_id = self . client_id , client_secret = self . client_secret , ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] , method , r . url ) [EOL] if payload and not isinstance ( payload , bytes ) : [EOL] logger . debug ( [string] , payload ) [EOL] [EOL] if check_202 and r . status_code == [number] : [EOL] if retries > [number] : [EOL] logger . warning ( [string] ) [EOL] sleep ( [number] ) [EOL] return self . _internal_call ( method , url , payload , params , headers , retries = retries - [number] ) [EOL] [EOL] exception_params = self . get_exception_params ( r ) [EOL] raise SpotifyDeviceUnavailableException ( ** exception_params ) [EOL] [EOL] try : [EOL] self . _check_response ( r ) [EOL] except SpotifyRateLimitException as exc : [EOL] logger . warning ( [string] , exc . retry_after ) [EOL] sleep ( exc . retry_after ) [EOL] return self . _internal_call ( method , url , payload , params ) [EOL] [EOL] if self . user_id : [EOL] self . _increment_api_call_count ( ) [EOL] if r . text and r . text != [string] : [EOL] results = r . json ( ) [EOL] logger . debug ( [string] , r . text ) [EOL] return SpotifyResult ( results , _client = self ) [EOL] [EOL] return None [EOL] [EOL] def _api_call ( self , method , url , args = None , payload = None , headers = None , ** kwargs ) : [EOL] if not self . is_authenticated : [EOL] raise SpotifyAuthException [EOL] [EOL] retries = kwargs . pop ( [string] , [number] ) [EOL] check_202 = kwargs . pop ( [string] , False ) [EOL] if args : [EOL] kwargs . update ( args ) [EOL] [EOL] if [string] in kwargs : [EOL] try : [EOL] kwargs [ [string] ] = self . get_device_id ( kwargs [ [string] ] ) [EOL] except ValueError as e : [EOL] logger . exception ( e ) [EOL] [EOL] if not url . startswith ( [string] ) : [EOL] url = API . PREFIX . value + url [EOL] return self . _internal_call ( method , url , payload , kwargs , headers , retries , check_202 ) [EOL] [EOL] def _get ( self , url , args = None , payload = None , ** kwargs ) : [EOL] return self . _api_call ( [string] , url , args , payload , ** kwargs ) [EOL] [EOL] def _post ( self , url , args = None , payload = None , ** kwargs ) : [EOL] return self . _api_call ( [string] , url , args , payload , ** kwargs ) [EOL] [EOL] def _delete ( self , url , args = None , payload = None , ** kwargs ) : [EOL] return self . _api_call ( [string] , url , args , payload , ** kwargs ) [EOL] [EOL] def _put ( self , url , args = None , payload = None , ** kwargs ) : [EOL] return self . _api_call ( [string] , url , args , payload , ** kwargs ) [EOL] [EOL] def previous ( self , result , ** kwargs ) : [EOL] [docstring] [EOL] if result [ [string] ] : [EOL] return self . _get ( result [ [string] ] , ** kwargs ) [EOL] [EOL] return None [EOL] [EOL] def track ( self , track_id , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_track_id ( track_id ) [EOL] [comment] [EOL] return self . _get ( API . TRACK . value . format ( id = _id ) , ** kwargs ) [EOL] [EOL] def tracks ( self , tracks , market = [string] , ** kwargs ) : [EOL] [docstring] [EOL] track_list = map ( self . _get_track_id , tracks ) [EOL] return self . _get ( API . TRACKS . value , ids = [string] . join ( track_list ) , market = market , ** kwargs ) [EOL] [EOL] def artist ( self , artist_id , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_artist_id ( artist_id ) [EOL] [comment] [EOL] return self . _get ( API . ARTIST . value . format ( id = _id ) , ** kwargs ) [EOL] [EOL] def artists ( self , artists , ** kwargs ) : [EOL] [docstring] [EOL] artist_list = map ( self . _get_artist_id , artists ) [EOL] return self . _get ( API . ARTISTS . value , ids = [string] . join ( artist_list ) , ** kwargs ) [EOL] [EOL] def artist_albums ( self , artist_id , album_type = None , country = None , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_artist_id ( artist_id ) [EOL] return self . _get ( API . ARTIST_ALBUMS . value . format ( id = _id ) , album_type = album_type , country = country , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def artist_top_tracks ( self , artist_id , country = [string] , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_artist_id ( artist_id ) [EOL] [comment] [EOL] return self . _get ( API . ARTIST_TOP_TRACKS . value . format ( id = _id ) , country = country , ** kwargs ) [EOL] [EOL] @ lru_cache ( maxsize = [number] ) def artist_related_artists ( self , artist_id , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_artist_id ( artist_id ) [EOL] [comment] [EOL] return self . _get ( API . ARTIST_RELATED_ARTISTS . value . format ( id = _id ) , ** kwargs ) [EOL] [EOL] def album ( self , album_id , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_album_id ( album_id ) [EOL] [comment] [EOL] return self . _get ( API . ALBUM . value . format ( id = _id ) , ** kwargs ) [EOL] [EOL] def album_tracks ( self , album_id , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_album_id ( album_id ) [EOL] [comment] [EOL] return self . _get ( API . ALBUM_TRACKS . value . format ( id = _id ) , limit = limit , offset = offset , ** kwargs ) [EOL] [EOL] def albums ( self , albums , ** kwargs ) : [EOL] [docstring] [EOL] album_list = map ( self . _get_album_id , albums ) [EOL] return self . _get ( API . ALBUMS . value , ids = [string] . join ( album_list ) , ** kwargs ) [EOL] [EOL] def search ( self , url , q , limit = [number] , offset = [number] , market = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( url , q = q , limit = limit , offset = offset , market = market , ** kwargs ) [EOL] [EOL] def search_track ( self , track , limit = [number] , offset = [number] , market = [string] , ** kwargs ) : [EOL] return self . search ( API . SEARCH_TRACK . value , track , limit = limit , offset = offset , market = market , ** kwargs , ) [EOL] [EOL] def search_album ( self , album , limit = [number] , offset = [number] , market = [string] , ** kwargs ) : [EOL] return self . search ( API . SEARCH_ALBUM . value , album , limit = limit , offset = offset , market = market , ** kwargs , ) [EOL] [EOL] def search_artist ( self , artist , limit = [number] , offset = [number] , market = [string] , ** kwargs ) : [EOL] return self . search ( API . SEARCH_ARTIST . value , artist , limit = limit , offset = offset , market = market , ** kwargs , ) [EOL] [EOL] def search_playlist ( self , playlist , limit = [number] , offset = [number] , market = [string] , ** kwargs ) : [EOL] return self . search ( API . SEARCH_PLAYLIST . value , playlist , limit = limit , offset = offset , market = market , ** kwargs , ) [EOL] [EOL] def profile ( self , user , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _get ( API . USER . value . format ( user_id = user ) , ** kwargs ) [EOL] [EOL] def current_user_playlists ( self , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . MY_PLAYLISTS . value , limit = limit , offset = offset , ** kwargs ) [EOL] [EOL] def user_playlists ( self , user , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _get ( API . PLAYLISTS . value . format ( user_id = user ) , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def user_playlist ( self , user , playlist_id = None , fields = None , market = [string] , ** kwargs ) : [EOL] [docstring] [EOL] if playlist_id is None : [EOL] return self . _get ( [string] % (user) , fields = fields , ** kwargs ) [EOL] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] [comment] [EOL] return self . _get ( API . PLAYLIST . value . format ( user_id = user , playlist_id = _id ) , fields = fields , market = market , ** kwargs , ) [EOL] [EOL] def user_playlist_tracks ( self , user , playlist_id = None , fields = None , limit = [number] , offset = [number] , market = [string] , ** kwargs , ) : [EOL] [docstring] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] [comment] [EOL] return self . _get ( API . PLAYLIST_TRACKS . value . format ( user_id = user , playlist_id = _id ) , limit = limit , offset = offset , fields = fields , market = market , ** kwargs , ) [EOL] [EOL] def user_playlist_create ( self , user , name , public = True , description = [string] , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] data = { [string] : name , [string] : public , [string] : description } [EOL] return self . _post ( API . PLAYLISTS . value . format ( user_id = user ) , payload = data , ** kwargs ) [EOL] [EOL] def user_playlist_upload_cover_image ( self , user , playlist_id , image , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _put ( API . PLAYLIST_IMAGES . value . format ( user_id = user , playlist_id = playlist_id ) , payload = image , headers = { [string] : [string] } , ** kwargs , ) [EOL] [EOL] def user_playlist_change_details ( self , user , playlist_id , name = None , public = None , collaborative = None , description = None , ** kwargs , ) : [EOL] [docstring] [EOL] data = { } [EOL] if isinstance ( name , str ) : [EOL] data [ [string] ] = name [EOL] if isinstance ( public , bool ) : [EOL] data [ [string] ] = public [EOL] if isinstance ( collaborative , bool ) : [EOL] data [ [string] ] = collaborative [EOL] if isinstance ( collaborative , str ) : [EOL] data [ [string] ] = description [EOL] [comment] [EOL] return self . _put ( API . PLAYLIST . value . format ( user_id = user , playlist_id = playlist_id ) , payload = data , ** kwargs , ) [EOL] [EOL] def user_playlist_unfollow ( self , user , playlist_id , ** kwargs ) : [EOL] [docstring] [EOL] return self . _delete ( [string] % ( user , playlist_id ) , ** kwargs ) [EOL] [EOL] def user_playlist_add_tracks ( self , user , playlist_id , tracks , position = None , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] [comment] [EOL] url = API . PLAYLIST_TRACKS . value . format ( user_id = user , playlist_id = _id ) [EOL] track_uris = list ( map ( self . _get_track_uri , tracks ) ) [EOL] if len ( track_uris ) <= [number] : [EOL] return self . _post ( url , payload = { [string] : track_uris } , position = position , ** kwargs ) [EOL] [EOL] batches = [ { [string] : track_uris [ i : i + [number] ] } for i in range ( [number] , len ( track_uris ) , [number] ) ] [EOL] results = [ self . _post ( url , payload = t , position = ( None if position is None else i * [number] + position ) , ** kwargs , ) for i , t in enumerate ( batches ) ] [EOL] return results [EOL] [EOL] def user_playlist_replace_tracks ( self , user , playlist_id , tracks , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] [comment] [EOL] url = API . PLAYLIST_TRACKS . value . format ( user_id = user , playlist_id = _id ) [EOL] first_100_tracks , rest_tracks = tracks [ : [number] ] , tracks [ [number] : ] [EOL] track_uris = list ( map ( self . _get_track_uri , first_100_tracks ) ) [EOL] replaced = self . _put ( url , payload = { [string] : track_uris } , ** kwargs ) [EOL] if not rest_tracks : [EOL] return replaced [EOL] [EOL] added = self . user_playlist_add_tracks ( user , playlist_id , rest_tracks ) [EOL] if isinstance ( added , list ) : [EOL] return [ replaced , * added ] [EOL] [EOL] return [ replaced , added ] [EOL] [EOL] def user_playlist_reorder_tracks ( self , user , playlist_id , range_start , insert_before , range_length = [number] , snapshot_id = None , ** kwargs , ) : [EOL] [docstring] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] payload = { [string] : range_start , [string] : range_length , [string] : insert_before , } [EOL] if snapshot_id : [EOL] payload [ [string] ] = snapshot_id [EOL] [comment] [EOL] return self . _put ( API . PLAYLIST_TRACKS . value . format ( user_id = user , playlist_id = _id ) , payload = payload , ** kwargs , ) [EOL] [EOL] def user_playlist_remove_all_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] track_uris = map ( self . _get_track_uri , tracks ) [EOL] payload = { [string] : [ { [string] : track } for track in track_uris ] } [EOL] if snapshot_id : [EOL] payload [ [string] ] = snapshot_id [EOL] [comment] [EOL] return self . _delete ( API . PLAYLIST_TRACKS . value . format ( user_id = user , playlist_id = _id ) , payload = payload , ** kwargs , ) [EOL] [EOL] def user_playlist_remove_specific_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_playlist_id ( playlist_id ) [EOL] ftracks = [ ] [EOL] for tr in tracks : [EOL] ftracks . append ( { [string] : self . _get_uri ( [string] , tr [ [string] ] ) , [string] : tr [ [string] ] } ) [EOL] payload = { [string] : ftracks } [EOL] if snapshot_id : [EOL] payload [ [string] ] = snapshot_id [EOL] [comment] [EOL] return self . _delete ( API . PLAYLIST_TRACKS . value . format ( user_id = user , playlist_id = _id ) , payload = payload , ** kwargs , ) [EOL] [EOL] def user_playlist_follow_playlist ( self , playlist_owner_id , playlist_id , ** kwargs ) : [EOL] [docstring] [EOL] return self . _put ( API . PLAYLIST_FOLLOWERS . value . format ( owner_id = playlist_owner_id , playlist_id = playlist_id ) , ** kwargs , ) [EOL] [EOL] def user_playlist_is_following ( self , playlist_owner_id , playlist_id , user_ids , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . PLAYLIST_FOLLOWERS_CONTAINS . value . format ( user_id = playlist_owner_id , playlist_id = playlist_id ) , ids = [string] . join ( user_ids ) , ** kwargs , ) [EOL] [EOL] def me ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . ME . value , ** kwargs ) [EOL] [EOL] def current_user ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . me ( ** kwargs ) [EOL] [EOL] def current_user_saved_albums ( self , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . MY_ALBUMS . value , limit = limit , offset = offset , ** kwargs ) [EOL] [EOL] def current_user_saved_tracks ( self , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . MY_TRACKS . value , limit = limit , offset = offset , ** kwargs ) [EOL] [EOL] def current_user_followed_artists ( self , limit = [number] , after = None , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . MY_FOLLOWING . value , type = [string] , limit = limit , after = after , ** kwargs ) [EOL] [EOL] def user_follow_artists ( self , ids = None , ** kwargs ) : [EOL] [docstring] [EOL] return self . _put ( API . MY_FOLLOWING . value , type = [string] , ids = [string] . join ( ids or [ ] ) , ** kwargs ) [EOL] [EOL] def user_follow_users ( self , ids = None , ** kwargs ) : [EOL] [docstring] [EOL] return self . _put ( API . MY_FOLLOWING . value , type = [string] , ids = [string] . join ( ids or [ ] ) , ** kwargs ) [EOL] [EOL] def current_user_saved_tracks_delete ( self , tracks = None , ** kwargs ) : [EOL] [docstring] [EOL] track_list = [ ] [EOL] if tracks is not None : [EOL] track_list = map ( self . _get_track_id , tracks ) [EOL] return self . _delete ( API . MY_TRACKS . value , ids = [string] . join ( track_list ) , ** kwargs ) [EOL] [EOL] def current_user_saved_tracks_contains ( self , tracks = None , ** kwargs ) : [EOL] [docstring] [EOL] track_list = [ ] [EOL] if tracks is not None : [EOL] track_list = map ( self . _get_track_id , tracks ) [EOL] return self . _get ( API . MY_TRACKS_CONTAINS . value , [string] . join ( track_list ) , ** kwargs ) [EOL] [EOL] def current_user_saved_tracks_add ( self , tracks = None , ** kwargs ) : [EOL] [docstring] [EOL] track_list = [ ] [EOL] if tracks is not None : [EOL] track_list = map ( self . _get_track_id , tracks ) [EOL] return self . _put ( API . MY_TRACKS . value , ids = [string] . join ( track_list ) , ** kwargs ) [EOL] [EOL] def current_user_top_artists ( self , limit = [number] , offset = [number] , time_range = TimeRange . MEDIUM_TERM , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . MY_TOP . value . format ( type = [string] ) , time_range = TimeRange ( time_range ) . value , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def current_user_top_tracks ( self , limit = [number] , offset = [number] , time_range = TimeRange . MEDIUM_TERM , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . MY_TOP . value . format ( type = [string] ) , time_range = TimeRange ( time_range ) . value , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def current_user_saved_albums_add ( self , albums = None , ** kwargs ) : [EOL] [docstring] [EOL] album_list = map ( self . _get_album_id , albums or [ ] ) [EOL] return self . _put ( API . MY_ALBUMS . value , ids = [string] . join ( album_list ) , ** kwargs ) [EOL] [EOL] def featured_playlists ( self , locale = None , country = None , timestamp = None , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . FEATURED_PLAYLISTS . value , locale = locale , country = country , timestamp = timestamp , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def new_releases ( self , country = None , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . NEW_RELEASES . value , country = country , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def categories ( self , country = None , locale = None , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . CATEGORIES . value , country = country , locale = locale , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] def category_playlists ( self , category_id = None , country = None , limit = [number] , offset = [number] , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _get ( API . CATEGORY_PLAYLISTS . value . format ( id = category_id ) , country = country , limit = limit , offset = offset , ** kwargs , ) [EOL] [EOL] [comment] [EOL] def recommendations ( self , seed_artists = None , seed_genres = None , seed_tracks = None , limit = [number] , country = [string] , filter_manele = True , ** kwargs , ) : [EOL] [docstring] [EOL] params = dict ( limit = limit ) [EOL] if seed_artists : [EOL] params [ [string] ] = [string] . join ( map ( self . _get_artist_id , seed_artists ) ) [EOL] if seed_genres : [EOL] params [ [string] ] = [string] . join ( seed_genres ) [EOL] if seed_tracks : [EOL] params [ [string] ] = [string] . join ( map ( self . _get_track_id , seed_tracks ) ) [EOL] if country : [EOL] params [ [string] ] = country [EOL] for attribute in list ( AudioFeature ) : [EOL] for prefix in [ [string] , [string] , [string] ] : [EOL] param = prefix + attribute . value [EOL] if param in kwargs : [EOL] params [ param ] = kwargs . pop ( param ) [EOL] [EOL] if not filter_manele : [EOL] return self . _get ( API . RECOMMENDATIONS . value , ** params , ** kwargs ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] result = self . _get ( API . RECOMMENDATIONS . value , ** params , ** kwargs ) [EOL] tracks = [ t for t in result . tracks if not any ( [string] in ( a . genres or [ ] ) or a . id in MANELISTI for a in t . artists ) ] [EOL] if tracks : [EOL] result . tracks = tracks [EOL] return result [EOL] return self . _get ( API . RECOMMENDATIONS . value , ** params , ** kwargs ) [EOL] [EOL] def recommendation_genre_seeds ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . RECOMMENDATIONS_GENRES . value , ** kwargs ) [EOL] [EOL] def audio_analysis ( self , track = None , ** kwargs ) : [EOL] [docstring] [EOL] _id = self . _get_track_id ( track ) [EOL] [comment] [EOL] return self . _get ( API . AUDIO_ANALYSIS . value . format ( id = _id ) , ** kwargs ) [EOL] [EOL] def audio_features ( self , track = None , tracks = None , with_cache = True , ** kwargs ) : [EOL] [docstring] [EOL] if track : [EOL] _id = self . _get_track_id ( track ) [EOL] [comment] [EOL] return self . _get ( API . AUDIO_FEATURES_SINGLE . value . format ( id = _id ) , ** kwargs ) [EOL] [EOL] tracks = list ( map ( self . _get_track_id , tracks or [ ] ) ) [EOL] cached_tracks = [ ] [EOL] if with_cache : [EOL] with db_session : [EOL] cached_tracks = select ( a for a in AudioFeatures if a . id in tracks ) [ : ] [EOL] tracks = list ( set ( tracks ) - { a . id for a in cached_tracks } ) [EOL] batches = [ tracks [ i : i + [number] ] for i in range ( [number] , len ( tracks ) , [number] ) ] [EOL] audio_features = [ self . _get ( API . AUDIO_FEATURES_MULTIPLE . value , ids = [string] . join ( t ) , ** kwargs ) for t in batches ] [EOL] with db_session : [EOL] audio_features = [ AudioFeatures . from_dict ( t ) for t in chain . from_iterable ( audio_features ) ] + cached_tracks [EOL] return audio_features [EOL] [EOL] def devices ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . DEVICES . value , check_202 = True , ** kwargs ) [EOL] [EOL] def get_device_id ( self , device = None ) : [EOL] if isinstance ( device , ( str , bytes ) ) and DEVICE_ID_RE . match ( device ) : [EOL] return device [EOL] [EOL] return self . get_device ( device ) . id [EOL] [EOL] def get_device ( self , device = None , only_active = True ) : [EOL] [docstring] [EOL] devices = self . devices ( ) . devices [EOL] device_names = [string] . join ( [ d . name for d in devices ] ) [EOL] device_name_or_id = device [EOL] if not device_name_or_id : [EOL] if only_active : [EOL] device = first ( devices , key = attrgetter ( [string] ) ) [EOL] if not device : [EOL] raise ValueError ( f""" [string] { device_names }""" ) [EOL] else : [EOL] device = first ( devices , key = attrgetter ( [string] ) ) or first ( devices ) [EOL] else : [EOL] device = first ( devices , key = lambda d : device_name_or_id in ( d . name , d . id ) ) [EOL] if not device : [EOL] raise ValueError ( f""" [string] { device_name_or_id } [string] { device_names }""" ) [EOL] [EOL] return device [EOL] [EOL] def current_playback ( self , market = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . PLAYER . value , market = market , ** kwargs ) [EOL] [EOL] def current_user_recently_played ( self , limit = [number] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . RECENTLY_PLAYED . value , limit = limit , ** kwargs ) [EOL] [EOL] def currently_playing ( self , market = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get ( API . CURRENTLY_PLAYING . value , market = market , check_202 = True , ** kwargs ) [EOL] [EOL] def transfer_playback ( self , device , force_play = True , ** kwargs ) : [EOL] [docstring] [EOL] device_id = self . get_device_id ( device ) [EOL] data = { [string] : [ device_id ] , [string] : force_play } [EOL] return self . _put ( API . PLAYER . value , payload = data , check_202 = True , ** kwargs ) [EOL] [EOL] def start_playback ( self , device = None , artist = None , album = None , playlist = None , tracks = None , offset = None , ** kwargs , ) : [EOL] [docstring] [EOL] data = { } [EOL] if playlist : [EOL] data [ [string] ] = self . _get_playlist_uri ( playlist ) [EOL] elif album : [EOL] data [ [string] ] = self . _get_album_uri ( album ) [EOL] elif artist : [EOL] data [ [string] ] = self . _get_artist_uri ( artist ) [EOL] elif tracks : [EOL] data [ [string] ] = list ( map ( self . _get_track_uri , tracks ) ) [EOL] if isinstance ( offset , int ) : [EOL] data [ [string] ] = dict ( position = offset ) [EOL] elif isinstance ( offset , str ) : [EOL] data [ [string] ] = dict ( uri = offset ) [EOL] return self . _put ( API . PLAY . value , device_id = device , payload = data , check_202 = True , ** kwargs ) [EOL] [EOL] def pause_playback ( self , device = None , ** kwargs ) : [EOL] [docstring] [EOL] return self . _put ( API . PAUSE . value , device_id = device , check_202 = True , ** kwargs ) [EOL] [EOL] def next_track ( self , device = None , ** kwargs ) : [EOL] [docstring] [EOL] return self . _post ( API . NEXT . value , device_id = device , check_202 = True , ** kwargs ) [EOL] [EOL] def previous_track ( self , device = None , ** kwargs ) : [EOL] [docstring] [EOL] return self . _post ( API . PREVIOUS . value , device_id = device , check_202 = True , ** kwargs ) [EOL] [EOL] def seek_track ( self , position_ms , device = None , ** kwargs ) : [EOL] [docstring] [EOL] if not isinstance ( position_ms , int ) : [EOL] logger . warning ( [string] ) [EOL] return None [EOL] [EOL] return self . _put ( API . SEEK . value , position_ms = position_ms , device_id = device , check_202 = True , ** kwargs , ) [EOL] [EOL] def repeat ( self , state , device = None , ** kwargs ) : [EOL] [docstring] [EOL] if state not in [ [string] , [string] , [string] ] : [EOL] logger . warning ( [string] ) [EOL] return [EOL] [EOL] self . _put ( API . REPEAT . value , state = state , device_id = device , check_202 = True , ** kwargs ) [EOL] [EOL] def volume ( self , volume_percent = None , device = None , ** kwargs ) : [EOL] [docstring] [EOL] device = self . get_device ( device ) [EOL] if volume_percent is None : [EOL] return device . volume_percent [EOL] [EOL] assert [number] <= volume_percent <= [number] [EOL] return self . _put ( API . VOLUME . value , volume_percent = volume_percent , device_id = device . id , check_202 = True , ** kwargs , ) [EOL] [EOL] def shuffle ( self , state , device = None , ** kwargs ) : [EOL] [docstring] [EOL] if not isinstance ( state , bool ) : [EOL] logger . warning ( [string] ) [EOL] return [EOL] [EOL] state = str ( state ) . lower ( ) [EOL] self . _put ( API . SHUFFLE . value , state = state , device_id = device , check_202 = True , ** kwargs ) [EOL] [EOL] @ staticmethod def _get_id ( _type , result ) : [EOL] if isinstance ( result , str ) : [EOL] fields = result . split ( [string] ) [EOL] if len ( fields ) >= [number] : [EOL] if _type != fields [ - [number] ] : [EOL] logger . warning ( [string] , _type , fields [ - [number] ] , result , ) [EOL] return fields [ - [number] ] [EOL] [EOL] fields = result . split ( [string] ) [EOL] if len ( fields ) >= [number] : [EOL] itype = fields [ - [number] ] [EOL] if _type != itype : [EOL] logger . warning ( [string] , _type , itype , result , ) [EOL] return fields [ - [number] ] [EOL] [EOL] elif isinstance ( result , ( SpotifyResult , db . Entity ) ) : [EOL] return result . id [EOL] [EOL] elif isinstance ( result , dict ) : [EOL] return result [ [string] ] [EOL] [EOL] return result [EOL] [EOL] _get_track_id = partialmethod ( _get_id , [string] ) [EOL] _get_artist_id = partialmethod ( _get_id , [string] ) [EOL] _get_album_id = partialmethod ( _get_id , [string] ) [EOL] _get_playlist_id = partialmethod ( _get_id , [string] ) [EOL] [EOL] def _get_uri ( self , _type , result ) : [EOL] return [string] + _type + [string] + self . _get_id ( _type , result ) [EOL] [EOL] def _get_playlist_uri ( self , playlist , user = None ) : [EOL] if isinstance ( playlist , ( str , bytes ) ) and PLAYLIST_URI_RE . match ( playlist ) : [EOL] return playlist [EOL] [EOL] if isinstance ( playlist , Playlist ) : [EOL] return playlist . uri [EOL] [EOL] if user is not None : [EOL] return f' [string] { self . _get_id ( [string] , user ) } [string] { self . _get_id ( [string] , playlist ) }' [EOL] [EOL] try : [EOL] if [string] in playlist : [EOL] return playlist [ [string] ] [EOL] [EOL] except : [EOL] pass [EOL] [EOL] return None [EOL] [EOL] _get_track_uri = partialmethod ( _get_uri , [string] ) [EOL] _get_artist_uri = partialmethod ( _get_uri , [string] ) [EOL] _get_album_uri = partialmethod ( _get_uri , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ujson as json [EOL] [EOL] [EOL] class SpotifyException ( Exception ) : [EOL] def __init__ ( self , * args , status_code = None , headers = None , text = None , url = None , ** kwargs ) : [comment] [EOL] super ( ) . __init__ ( ) [EOL] self . http_status_code = status_code [EOL] self . headers = headers or { } [EOL] if text and text != [string] : [EOL] try : [EOL] response = json . loads ( text ) [EOL] self . msg = f'{ url } [string] { response [ [string] ] [ [string] ] }' [EOL] except : [EOL] self . msg = f"{ url } [string] " [EOL] else : [EOL] self . msg = f"{ url } [string] " [EOL] [EOL] def __str__ ( self ) : [EOL] return f""" [string] { self . http_status_code } [string] { self . msg }""" [EOL] [EOL] [EOL] class SpotifyRateLimitException ( SpotifyException ) : [EOL] def __init__ ( self , * args , retry_after = [number] , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . retry_after = retry_after [EOL] [EOL] [EOL] class SpotifyForbiddenException ( SpotifyException ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class SpotifyDeviceUnavailableException ( SpotifyException ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class SpotifyCredentialsException ( Exception ) : [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class SpotifyAuthException ( Exception ) : [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class NoDatabaseConnection ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import OrderedDict , Any [EOL] import typing [EOL] import collections [EOL] import functools [EOL] from collections import OrderedDict [EOL] [EOL] from . db import * [EOL] [EOL] [EOL] def async_lru ( maxsize = [number] ) : [EOL] cache = OrderedDict ( ) [EOL] [EOL] def decorator ( fn ) : [EOL] @ functools . wraps ( fn ) async def memoizer ( * args , ** kwargs ) : [EOL] key = str ( ( args , kwargs ) ) [EOL] try : [EOL] cache [ key ] = cache . pop ( key ) [EOL] except KeyError : [EOL] if len ( cache ) >= maxsize : [EOL] cache . popitem ( last = False ) [EOL] cache [ key ] = await fn ( * args , ** kwargs ) [EOL] return cache [ key ] [EOL] [EOL] return memoizer [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import asyncio [EOL] import typing [EOL] from . . import * [comment] [EOL] [EOL] [comment] [EOL] import asyncio [EOL] from itertools import islice [EOL] [EOL] [EOL] class LimitedAsCompletedError ( Exception ) : [EOL] def __init__ ( self , * args , original_exc = None , remaining_futures = None , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . original_exc = original_exc [EOL] self . remaining_futures = remaining_futures [EOL] [EOL] [EOL] def should_ignore_exception ( exc , ignore_exceptions ) : [EOL] return ignore_exceptions is True or ( isinstance ( ignore_exceptions , ( tuple , Exception ) ) [EOL] and isinstance ( exc , ignore_exceptions ) ) [EOL] [EOL] [EOL] async def limited_as_completed ( coros , limit , ignore_exceptions = False ) : [EOL] [docstring] [EOL] futures = [ asyncio . ensure_future ( c ) for c in islice ( coros , [number] , limit ) ] [EOL] [EOL] async def first_to_finish ( ignore_exceptions = False ) : [EOL] while True : [EOL] await asyncio . sleep ( [number] ) [EOL] for f in futures : [EOL] if f . done ( ) : [EOL] futures . remove ( f ) [EOL] try : [EOL] newf = next ( coros ) [EOL] futures . append ( asyncio . ensure_future ( newf ) ) [EOL] except StopIteration : [EOL] pass [EOL] try : [EOL] return f . result ( ) [EOL] except Exception as exc : [EOL] if should_ignore_exception ( exc , ignore_exceptions ) : [EOL] logger . warning ( [string] ) [EOL] logger . exception ( exc ) [EOL] return None [EOL] raise LimitedAsCompletedError ( * exc . args , original_exc = exc , remaining_futures = futures ) [EOL] [EOL] while futures : [EOL] yield await first_to_finish ( ignore_exceptions = ignore_exceptions ) [EOL] [EOL] [EOL] from . client import SpotifyClient [comment] [EOL] from . result import SpotifyResult [comment] [EOL] from . wrapper import Spotify [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Type , List [EOL] import typing [EOL] import spfy [EOL] import fire [EOL] [EOL] from . . import config , logger [EOL] from . . constants import AuthFlow [EOL] from . . mixins . asynch import PlayerMixin , RecommenderMixin [EOL] from . client import SpotifyClient [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Spotify ( SpotifyClient , PlayerMixin , RecommenderMixin ) : [EOL] [docstring] [EOL] [EOL] cli = False [EOL] loop = None [EOL] [EOL] def __init__ ( self , * args , email = None , username = None , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . email = email or config . auth . email [EOL] self . username = username or config . auth . username [EOL] [EOL] def __dir__ ( self ) : [EOL] names = super ( ) . __dir__ ( ) [EOL] names = [ name for name in names if not name . startswith ( [string] ) and name != [string] ] [EOL] return names [EOL] [EOL] async def auth ( self , email = config . auth . email , username = config . auth . username , server = False ) : [EOL] if self . cli and not self . is_authenticated : [EOL] if server : [EOL] await self . authenticate ( flow = AuthFlow . CLIENT_CREDENTIALS ) [EOL] else : [EOL] try : [EOL] await self . authenticate ( email = email , username = username ) [EOL] except Exception as exc : [EOL] logger . exception ( exc ) [EOL] return self [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] [EOL] try : [EOL] import uvloop [EOL] [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] except ImportError : [EOL] pass [EOL] try : [EOL] Spotify . cli = True [EOL] Spotify . loop = asyncio . get_event_loop ( ) [EOL] spotify = Spotify ( ) [EOL] fire . Fire ( spotify ) [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] finally : [EOL] if spotify . session and not Spotify . loop . is_running ( ) : [EOL] Spotify . loop . run_until_complete ( spotify . session . close ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , Any , Set [EOL] import typing [EOL] import urllib [EOL] import spfy [EOL] import random [EOL] from urllib . parse import parse_qs , urlparse , urlunparse [EOL] [EOL] import addict [EOL] from cached_property import cached_property [EOL] [EOL] from . import limited_as_completed [EOL] from . . import config [EOL] from . . constants import API [EOL] [EOL] LOCAL_ATTRIBUTES = { [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] class Playable : [EOL] def __init__ ( self , result ) : [EOL] self . result = result [EOL] self . client = self . result . _client [EOL] [EOL] async def play ( self , device = None , index = None ) : [EOL] return await self . result . _put_with_params ( dict ( device_id = device , payload = self . get_data ( index ) ) , url = API . PLAY . value ) [EOL] [EOL] def get_data ( self , index = None ) : [EOL] data = { } [EOL] if [string] in self . result or [string] in self . result : [EOL] data [ [string] ] = list ( map ( self . client . _get_track_uri , self . result ) ) [EOL] return data [EOL] [EOL] item = self . result [ index ] if index is not None else random . choice ( self . result ) [EOL] if [string] in self . result : [EOL] data [ [string] ] = self . client . _get_playlist_uri ( item ) [EOL] elif [string] in self . result : [EOL] data [ [string] ] = self . client . _get_artist_uri ( item ) [EOL] elif [string] in self . result : [EOL] data [ [string] ] = self . client . _get_album_uri ( item ) [EOL] elif [string] in self . result : [EOL] data [ [string] ] = self . client . _get_uri ( item . type , item ) [EOL] elif self . result . type and self . result . type in { [string] , [string] , [string] } : [EOL] data [ [string] ] = self . client . _get_uri ( self . result . type , self . result ) [EOL] elif item . type == [string] : [EOL] data [ [string] ] = list ( map ( self . client . _get_track_uri , self . result ) ) [EOL] return data [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SpotifyResultIterator : [EOL] def __init__ ( self , result , limit = None , ignore_exceptions = False ) : [EOL] self . result = result [EOL] self . limit = limit [EOL] self . params_list = self . result . get_next_params_list ( limit ) [EOL] self . requests = ( self . result . _get_with_params ( params ) for params in self . params_list ) [EOL] self . responses = limited_as_completed ( self . requests , config . http . concurrent_connections , ignore_exceptions = ignore_exceptions , ) [EOL] [EOL] def __aiter__ ( self ) : [EOL] return self . iterate ( ) [EOL] [EOL] async def iterate ( self ) : [EOL] for item in self . result : [EOL] yield item [EOL] [EOL] [comment] [EOL] async for responses in self . responses : [EOL] if responses is None : [EOL] continue [EOL] for response in responses : [EOL] yield response [EOL] [EOL] [EOL] class SpotifyResult ( addict . Dict ) : [EOL] ITER_KEYS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . _next_result = None [EOL] self . _playable = Playable ( self ) [EOL] [EOL] def __iter__ ( self ) : [EOL] for key in self . ITER_KEYS : [EOL] if key in self : [EOL] if [string] in self [ key ] : [EOL] return iter ( self [ key ] [ [string] ] ) [EOL] [EOL] return iter ( self [ key ] ) [EOL] [EOL] return super ( ) . __iter__ ( ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] if isinstance ( item , int ) : [EOL] for key in self . ITER_KEYS : [EOL] if key in self : [EOL] if [string] in self [ key ] : [EOL] return iter ( self [ key ] [ [string] ] [ item ] ) [EOL] [EOL] return iter ( self [ key ] [ item ] ) [EOL] [EOL] return super ( ) . __getitem__ ( item ) [EOL] [EOL] @ classmethod def _hook ( cls , item ) : [EOL] if isinstance ( item , dict ) : [EOL] return addict . Dict ( item ) [EOL] [EOL] if isinstance ( item , ( list , tuple ) ) : [EOL] return type ( item ) ( cls . _hook ( elem ) for elem in item ) [EOL] [EOL] return item [EOL] [EOL] def items ( self ) : [EOL] return filter ( lambda i : i [ [number] ] not in LOCAL_ATTRIBUTES , super ( ) . items ( ) ) [EOL] [EOL] def keys ( self ) : [EOL] return super ( ) . keys ( ) - LOCAL_ATTRIBUTES [EOL] [EOL] def values ( self ) : [EOL] return [ v for k , v in self . items ( ) ] [EOL] [EOL] async def play ( self , device = None , index = None ) : [EOL] return await self . _playable . play ( device , index ) [EOL] [EOL] @ cached_property def base_url ( self ) : [EOL] return urlunparse ( [ * urlparse ( self . href ) [ : [number] ] , [string] , [string] , [string] ] ) [EOL] [EOL] async def _get_with_params ( self , params , url = None ) : [EOL] return await self . _client . _get ( url or self . base_url , ** params ) [EOL] [EOL] async def _put_with_params ( self , params , url = None ) : [EOL] return await self . _client . _put ( url or self . base_url , ** params ) [EOL] [EOL] def get_next_params_list ( self , limit = None ) : [EOL] if self [ [string] ] and self [ [string] ] : [EOL] max_limit = limit or [number] [EOL] url = urlparse ( self [ [string] ] ) [EOL] params = { k : v [ [number] ] for k , v in parse_qs ( url . query ) . items ( ) } [EOL] limit = int ( params . pop ( [string] , [number] ) ) [EOL] offset = int ( params . pop ( [string] , [number] ) ) [EOL] return [ { ** params , [string] : max_limit , [string] : off } for off in range ( offset + limit , self . total , max_limit ) ] [EOL] [EOL] return [ ] [EOL] [EOL] async def all ( self , limit = None ) : [EOL] [comment] [EOL] return [ item async for item in self . iterall ( limit ) ] [EOL] [EOL] async def next ( self ) : [EOL] if self . _next_result : [EOL] return self . _next_result [EOL] [EOL] if self [ [string] ] : [EOL] return await self . _client . _get ( self [ [string] ] ) [EOL] [EOL] return None [EOL] [EOL] def iterall ( self , limit = None , ignore_exceptions = False ) : [EOL] return SpotifyResultIterator ( self , limit = limit , ignore_exceptions = ignore_exceptions ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.asynch.result.Playable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import spfy [EOL] import random [EOL] import sys [EOL] import threading [EOL] from collections import OrderedDict [EOL] [EOL] from cached_property import cached_property [EOL] from first import first [EOL] [EOL] from . . import config [EOL] from . . cache import Playlist , db_session [EOL] from . . constants import ItemType , TimeRange , VolumeBackend [EOL] from . . volume import ( AlsaVolumeControl , ApplescriptVolumeControl , LinuxVolumeControl , SpotifyVolumeControl , ) [EOL] [EOL] [EOL] class PlayerMixin : [EOL] def __init__ ( self , * args , device = None , alsa_device = None , alsa_mixer = None , speaker = None , ** kwargs , ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . device = device or config . player . device [EOL] self . alsa_device = alsa_device or config . player . alsa . device [EOL] self . alsa_mixer = alsa_mixer or config . player . alsa . mixer [EOL] self . speaker = speaker or config . player . speaker [EOL] [EOL] @ cached_property def _optimal_backend ( self ) : [EOL] return first ( self . _backends . values ( ) ) [EOL] [EOL] @ cached_property def _backends ( self ) : [EOL] return OrderedDict ( { VolumeBackend . APPLESCRIPT : self . _applescript_volume_control , VolumeBackend . LINUX : self . _linux_volume_control , VolumeBackend . ALSA : self . _alsa_volume_control , VolumeBackend . SPOTIFY : self . _spotify_volume_control , } ) [EOL] [EOL] @ cached_property def _applescript_volume_control ( self ) : [EOL] try : [EOL] [comment] [EOL] if sys . platform != [string] : [EOL] return None [EOL] [EOL] return ApplescriptVolumeControl ( self . speaker ) [EOL] [EOL] except : [EOL] return None [EOL] [EOL] @ cached_property def _linux_volume_control ( self ) : [EOL] try : [EOL] [comment] [EOL] if sys . platform != [string] : [EOL] return None [EOL] [EOL] return LinuxVolumeControl ( self , self . alsa_mixer , spotify_device = self . device , alsa_device = self . alsa_device , ) [EOL] [EOL] except : [EOL] return None [EOL] [EOL] @ cached_property def _alsa_volume_control ( self ) : [EOL] try : [EOL] [comment] [EOL] if sys . platform != [string] : [EOL] return None [EOL] [EOL] return AlsaVolumeControl ( self . alsa_mixer , device = self . alsa_device ) [EOL] [EOL] except : [EOL] return None [EOL] [EOL] @ cached_property def _spotify_volume_control ( self ) : [EOL] return SpotifyVolumeControl ( self , device = self . device ) [EOL] [EOL] def backend ( self , backend = None , device = None ) : [EOL] if not backend : [EOL] return self . _optimal_backend [EOL] [EOL] volume_backend = self . _backends [ VolumeBackend ( backend ) ] [EOL] if not volume_backend : [EOL] raise ValueError ( f" [string] { volume_backend } [string] " ) [EOL] [EOL] if ( isinstance ( volume_backend , SpotifyVolumeControl ) [EOL] and device [EOL] and device != self . device ) : [EOL] volume_backend = SpotifyVolumeControl ( self , device = device ) [EOL] return volume_backend [EOL] [EOL] def change_volume ( self , by = [number] , to = None , backend = None , device = None ) : [EOL] volume_backend = self . backend ( backend , device = device ) [EOL] if to is not None : [EOL] volume = to [EOL] else : [EOL] volume = volume_backend . volume [EOL] volume_backend . volume = volume + by [EOL] return volume [EOL] [EOL] def volume_up ( self , backend = None ) : [EOL] return self . change_volume ( by = + [number] , backend = backend ) [EOL] [EOL] def volume_down ( self , backend = None ) : [EOL] return self . change_volume ( by = - [number] , backend = backend ) [EOL] [EOL] def fade_up ( self , ** kwargs ) : [EOL] self . fade ( ** { ** config . volume . fade . up , ** kwargs } ) [EOL] [EOL] def fade_down ( self , ** kwargs ) : [EOL] self . fade ( ** { ** config . volume . fade . down , ** kwargs } ) [EOL] [EOL] [comment] [EOL] [EOL] def fade ( self , limit = [number] , start = [number] , step = [number] , seconds = [number] , force = False , backend = None , spotify_volume = [number] , device = None , ) : [EOL] volume_backend = self . backend ( backend , device = device ) [EOL] if not isinstance ( volume_backend , SpotifyVolumeControl ) : [EOL] self . change_volume ( to = spotify_volume , backend = VolumeBackend . SPOTIFY , device = device ) [EOL] self . change_volume ( to = start , backend = backend , device = device ) [EOL] kwargs = dict ( limit = int ( limit ) , start = int ( start ) , step = int ( step ) , seconds = int ( seconds ) , force = bool ( force ) , ) [EOL] threading . Thread ( target = volume_backend . fade , kwargs = kwargs ) . start ( ) [EOL] [EOL] @ db_session def play_recommended_tracks ( self , time_range = TimeRange . LONG_TERM , device = None , ** kwargs ) : [EOL] fade_args = kwargs . get ( [string] ) or { k [ [number] : ] : v for k , v in kwargs . items ( ) if k . startswith ( [string] ) } [EOL] recommendation_args = kwargs . get ( [string] ) or { k [ [number] : ] : v for k , v in kwargs . items ( ) if k . startswith ( [string] ) } [EOL] recommendation_args [ [string] ] = time_range [EOL] tracks = self . recommend_by_top_artists ( ** recommendation_args ) [EOL] self . fade_up ( device = device , ** fade_args ) [EOL] result = self . start_playback ( tracks = tracks , device = device ) [EOL] return { [string] : True , [string] : device , [string] : tracks , [string] : result } [EOL] [EOL] @ db_session def play_recommended_genre ( self , time_range = TimeRange . LONG_TERM , device = None , ** kwargs ) : [EOL] fade_args = kwargs . get ( [string] ) or { k [ [number] : ] : v for k , v in kwargs . items ( ) if k . startswith ( [string] ) } [EOL] popularity = random . choice ( list ( Playlist . Popularity ) [ : [number] ] ) [EOL] genre = ( self . top_genres ( time_range = time_range ) . select ( ) . without_distinct ( ) . random ( [number] ) [ [number] ] ) [EOL] playlist = self . genre_playlist ( genre . name , popularity ) [EOL] while not playlist : [EOL] playlist = self . genre_playlist ( genre . name , popularity ) [EOL] self . fade_up ( device = device , ** fade_args ) [EOL] result = playlist . play ( self , device = device ) [EOL] return { [string] : True , [string] : device , [string] : playlist . to_dict ( ) , [string] : result , } [EOL] [EOL] @ db_session def play ( self , time_range = TimeRange . LONG_TERM , device = None , item_type = None , ** kwargs ) : [EOL] item_type = item_type or random . choice ( [ ItemType . TRACKS , ItemType . PLAYLIST ] ) [EOL] if item_type == ItemType . TRACKS : [EOL] return self . play_recommended_tracks ( time_range , device , ** kwargs ) [EOL] [EOL] if item_type == ItemType . PLAYLIST : [EOL] return self . play_recommended_genre ( time_range , device , ** kwargs ) [EOL] [EOL] return { [string] : False } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 0 0 0 $spfy.volume.SpotifyVolumeControl$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spfy.cache.db.Playlist.Popularity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $spfy.cache.db.Playlist.Popularity$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $spfy.cache.db.Playlist.Popularity$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import itertools [EOL] import typing [EOL] import random [EOL] import time [EOL] from datetime import date , timedelta [EOL] from itertools import chain [EOL] [EOL] from pony . orm import get [EOL] from pony . orm . core import CacheIndexError [EOL] [EOL] from . . import logger [EOL] from . . cache import Artist , Genre , Playlist , db_session , select [EOL] from . . constants import TimeRange [EOL] from . . util import normalize_features [EOL] [EOL] [EOL] class RecommenderMixin : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] @ db_session def fetch_playlists ( self ) : [EOL] fetched_ids = set ( select ( p . id for p in Playlist ) ) [EOL] results = chain ( self . user_playlists ( [string] ) . all ( ) , self . user_playlists ( [string] ) . all ( ) , ) [EOL] for playlist in results : [EOL] logger . info ( [string] , playlist . name ) [EOL] if playlist . id not in fetched_ids : [EOL] Playlist . from_dict ( playlist ) [EOL] fetched_ids . add ( playlist . id ) [EOL] [EOL] @ db_session def fetch_user_top ( self , time_range ) : [EOL] self . user . top_artists . clear ( ) [EOL] for artist in self . current_user_top_artists ( limit = [number] , time_range = time_range ) . iterall ( ) : [EOL] if self . is_disliked_artist ( artist ) : [EOL] continue [EOL] [EOL] if Artist . exists ( id = artist . id ) : [EOL] self . user . top_artists . add ( Artist [ artist . id ] ) [EOL] else : [EOL] try : [EOL] artist = Artist . from_dict ( artist ) [EOL] except CacheIndexError : [EOL] artist = Artist [ artist . id ] [EOL] self . user . top_artists . add ( artist ) [EOL] self . user . top_genres = ( self . user . top_artists . genres . distinct ( ) . keys ( ) - self . user . disliked_genres ) [EOL] if self . user . top_expires_at is None : [EOL] self . user . top_expires_at = { } [EOL] self . user . top_expires_at [ TimeRange ( time_range ) . value ] = time . mktime ( ( date . today ( ) + timedelta ( days = [number] ) ) . timetuple ( ) ) [EOL] [EOL] @ db_session def genre_playlist ( self , genre , popularity = Playlist . Popularity . SOUND ) : [comment] [EOL] if not Playlist . exists ( ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] return Playlist . get ( genre = genre , popularity = Playlist . Popularity ( popularity ) . value ) [EOL] [EOL] @ db_session def top_artists ( self , time_range = TimeRange . SHORT_TERM ) : [EOL] if self . user . top_expired ( time_range ) : [EOL] self . fetch_user_top ( time_range ) [EOL] return self . user . top_artists [EOL] [EOL] @ db_session def top_genres ( self , time_range = TimeRange . SHORT_TERM ) : [EOL] if self . user . top_expired ( time_range ) : [EOL] self . fetch_user_top ( time_range ) [EOL] return self . user . top_genres [EOL] [EOL] def order_by ( self , features , tracks ) : [EOL] audio_features = self . audio_features ( tracks = tracks ) [EOL] track_ids = [ a . id for a in audio_features ] [EOL] audio_features = [ a . to_dict ( list ( features . keys ( ) ) ) for a in audio_features ] [EOL] audio_features = normalize_features ( audio_features , track_ids ) [EOL] for feature , direction in features . items ( ) : [EOL] audio_features [ feature ] *= direction [EOL] audio_features [ [string] ] = audio_features . sum ( axis = [number] ) [EOL] return audio_features . sort_values ( [string] ) . index . tolist ( ) [EOL] [EOL] def fill_with_related_artists ( self , artists , limit = [number] ) : [EOL] tries = [number] [EOL] if len ( artists ) >= limit : [EOL] return artists [EOL] [EOL] artist_set = set ( artists ) [EOL] artist_list = list ( artists ) [EOL] while len ( artist_set ) < limit and tries : [EOL] tries -= [number] [EOL] related_artists = { a . id for a in self . artist_related_artists ( random . choice ( artist_list ) ) if self . is_not_disliked_artist ( a ) } [EOL] related_artists_limit = min ( random . randint ( [number] , limit - len ( artist_set ) ) , len ( related_artists ) ) [EOL] artist_set |= set ( random . sample ( related_artists , related_artists_limit ) ) [EOL] return artist_set [EOL] [EOL] @ db_session def recommend_by_top_artists ( self , artist_limit = [number] , track_limit = [number] , use_related = True , features_order = None , time_range = TimeRange . SHORT_TERM , ** kwargs , ) : [EOL] [docstring] [EOL] artists = ( self . top_artists ( time_range = time_range ) . select ( ) . without_distinct ( ) . random ( artist_limit ) ) [EOL] if use_related : [EOL] artists = self . fill_with_related_artists ( [ a . id for a in artists ] ) [EOL] tracks = self . recommendations ( seed_artists = artists , limit = track_limit , ** kwargs ) [EOL] tracks = list ( filter ( self . is_not_disliked_track , tracks ) ) [EOL] if features_order : [EOL] tracks = self . order_by ( features_order , tracks ) [EOL] return tracks [EOL] [EOL] @ db_session def is_disliked_artist ( self , artist ) : [EOL] return artist . id in set ( self . user . disliked_artists . id . distinct ( ) . keys ( ) ) or bool ( set ( artist . genres or [ ] ) & set ( self . user . disliked_genres ) ) [EOL] [EOL] @ db_session def is_not_disliked_artist ( self , artist ) : [EOL] return not self . is_disliked_artist ( artist ) [EOL] [EOL] @ db_session def is_not_disliked_track ( self , track ) : [EOL] return all ( self . is_not_disliked_artist ( a ) for a in track . artists ) [EOL] [EOL] @ db_session def disliked_artists ( self ) : [EOL] return list ( self . user . disliked_artists ) [EOL] [EOL] @ db_session def disliked_genres ( self ) : [EOL] return list ( self . user . disliked_genres ) [EOL] [EOL] @ db_session def dislike_artist ( self , artist ) : [EOL] if isinstance ( artist , str ) : [EOL] [comment] [EOL] artist = get ( a for a in Artist if a . id == artist or a . name == artist ) [EOL] elif isinstance ( artist , dict ) : [EOL] artist = Artist . get ( artist . id ) or Artist . from_dict ( artist ) [EOL] self . user . dislike ( artist = artist ) [EOL] [EOL] @ db_session def dislike_genre ( self , genre ) : [EOL] if isinstance ( genre , str ) : [EOL] genre = genre . lower ( ) [EOL] genre = Genre . get ( name = genre ) or Genre ( name = genre ) [EOL] self . user . dislike ( genre = genre ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.chain[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.chain[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $typing.set$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.set$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.set$ 0 $builtins.int$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] from mailer import Mailer , Message [EOL] [EOL] from . . import config , logger , root [EOL] [EOL] LOGIN_HTML = root / [string] / [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class EmailMixin : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] @ staticmethod def send_auth_email ( email , auth_url ) : [EOL] logger . info ( [string] , auth_url ) [EOL] mailer = Mailer ( ** config . email ) [EOL] [comment] [EOL] html_content = LOGIN_HTML . read_text ( ) . replace ( [string] , auth_url ) [EOL] message = Message ( From = config . email . usr or email , To = email , charset = [string] ) [EOL] message . Subject = [string] [EOL] message . Html = html_content [EOL] message . Body = f" [string] { auth_url }" [EOL] mailer . send ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0
from . auth import AuthMixin [comment] [EOL] from . email import EmailMixin [comment] [EOL] from . player import PlayerMixin [comment] [EOL] from . recommender import RecommenderMixin [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from inspect import isawaitable [EOL] [EOL] import aiohttp [EOL] from oauthlib . common import generate_token , urldecode [EOL] from oauthlib . oauth2 . rfc6749 . errors import TokenExpiredError [EOL] [EOL] from oauthlib . oauth2 import ( WebApplicationClient , InsecureTransportError , is_secure_transport , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TokenUpdated ( Warning ) : [EOL] def __init__ ( self , token ) : [EOL] super ( TokenUpdated , self ) . __init__ ( ) [EOL] self . token = token [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class OAuth2Session ( aiohttp . ClientSession ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , client_id = None , client = None , auto_refresh_url = None , auto_refresh_kwargs = None , scope = None , redirect_uri = None , token = None , state = None , token_updater = None , ** kwargs , ) : [EOL] [docstring] [EOL] super ( OAuth2Session , self ) . __init__ ( ** kwargs ) [EOL] self . _client = client or WebApplicationClient ( client_id , token = token ) [EOL] self . token = token or { } [EOL] self . scope = scope [EOL] self . redirect_uri = redirect_uri [EOL] self . state = state or generate_token [EOL] self . _state = state [EOL] self . auto_refresh_url = auto_refresh_url [EOL] self . auto_refresh_kwargs = auto_refresh_kwargs or { } [EOL] self . token_updater = token_updater [EOL] [comment] [EOL] [comment] [EOL] self . compliance_hook = { [string] : set ( ) , [string] : set ( ) , [string] : set ( ) , } [EOL] [EOL] def new_state ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _state = self . state ( ) [EOL] log . debug ( [string] , self . _state ) [EOL] except TypeError : [EOL] self . _state = self . state [EOL] log . debug ( [string] , self . _state ) [EOL] return self . _state [EOL] [EOL] @ property def client_id ( self ) : [EOL] return getattr ( self . _client , [string] , None ) [EOL] [EOL] @ client_id . setter def client_id ( self , value ) : [EOL] self . _client . client_id = value [EOL] [EOL] @ client_id . deleter def client_id ( self ) : [EOL] del self . _client . client_id [EOL] [EOL] @ property def token ( self ) : [EOL] return getattr ( self . _client , [string] , None ) [EOL] [EOL] @ token . setter def token ( self , value ) : [EOL] self . _client . token = value [EOL] self . _client . _populate_attributes ( value ) [EOL] [EOL] @ property def access_token ( self ) : [EOL] return getattr ( self . _client , [string] , None ) [EOL] [EOL] @ access_token . setter def access_token ( self , value ) : [EOL] self . _client . access_token = value [EOL] [EOL] @ access_token . deleter def access_token ( self ) : [EOL] del self . _client . access_token [EOL] [EOL] @ property def authorized ( self ) : [EOL] [docstring] [EOL] return bool ( self . access_token ) [EOL] [EOL] def authorization_url ( self , url , state = None , ** kwargs ) : [EOL] [docstring] [EOL] state = state or self . new_state ( ) [EOL] return ( self . _client . prepare_request_uri ( url , redirect_uri = self . redirect_uri , scope = self . scope , state = state , ** kwargs , ) , state , ) [EOL] [EOL] [comment] [EOL] [EOL] async def fetch_token ( self , token_url , code = None , authorization_response = None , body = [string] , auth = None , username = None , password = None , method = [string] , timeout = None , headers = None , verify_ssl = True , proxy = None , ** kwargs , ) : [EOL] [docstring] [EOL] if not is_secure_transport ( token_url ) : [EOL] raise InsecureTransportError ( ) [EOL] [EOL] if not code and authorization_response : [EOL] self . _client . parse_request_uri_response ( authorization_response , state = self . _state ) [EOL] code = self . _client . code [EOL] elif not code and isinstance ( self . _client , WebApplicationClient ) : [EOL] code = self . _client . code [EOL] if not code : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] body = self . _client . prepare_request_body ( code = code , body = body , redirect_uri = self . redirect_uri , username = username , password = password , ** kwargs , ) [EOL] client_id = kwargs . get ( [string] , [string] ) [EOL] if auth is None : [EOL] if client_id : [EOL] log . debug ( [string] , client_id , ) [EOL] client_secret = kwargs . get ( [string] , [string] ) [EOL] client_secret = client_secret if client_secret is not None else [string] [EOL] auth = aiohttp . BasicAuth ( client_id , client_secret ) [EOL] elif username : [EOL] if password is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] log . debug ( [string] ) [EOL] auth = aiohttp . BasicAuth ( username , password ) [EOL] headers = headers or { [string] : [string] , [string] : [string] , } [EOL] self . token = { } [EOL] if method . upper ( ) == [string] : [EOL] req = self . post ( token_url , data = dict ( urldecode ( body ) ) , timeout = timeout , headers = headers , auth = auth , verify_ssl = verify_ssl , proxy = proxy , ) [EOL] log . debug ( [string] , body ) [EOL] elif method . upper ( ) == [string] : [EOL] [comment] [EOL] req = self . get ( token_url , params = dict ( urldecode ( body ) ) , timeout = timeout , headers = headers , auth = auth , verify_ssl = verify_ssl , proxy = proxy , ) [EOL] log . debug ( [string] , body ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] async with req as resp : [EOL] text = await resp . text ( ) [EOL] log . debug ( [string] , resp . status ) [EOL] log . debug ( [string] , resp . request_info . headers ) [EOL] log . debug ( [string] , resp . headers , text ) [EOL] log . debug ( [string] , len ( self . compliance_hook [ [string] ] ) , ) [EOL] for hook in self . compliance_hook [ [string] ] : [EOL] log . debug ( [string] , hook ) [EOL] resp = hook ( resp ) [EOL] self . _client . parse_request_body_response ( text , scope = self . scope ) [EOL] self . token = self . _client . token [EOL] log . debug ( [string] , self . token ) [EOL] return self . token [EOL] [EOL] def token_from_fragment ( self , authorization_response ) : [EOL] [docstring] [EOL] self . _client . parse_request_uri_response ( authorization_response , state = self . _state ) [EOL] self . token = self . _client . token [EOL] return self . token [EOL] [EOL] async def refresh_token ( self , token_url , refresh_token = None , body = [string] , auth = None , timeout = None , headers = None , verify_ssl = True , proxy = None , ** kwargs , ) : [EOL] [docstring] [EOL] if not token_url : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not is_secure_transport ( token_url ) : [EOL] raise InsecureTransportError ( ) [EOL] [EOL] refresh_token = refresh_token or self . token . get ( [string] ) [EOL] log . debug ( [string] , self . auto_refresh_kwargs ) [EOL] kwargs . update ( self . auto_refresh_kwargs ) [EOL] body = self . _client . prepare_refresh_body ( body = body , refresh_token = refresh_token , scope = self . scope , ** kwargs ) [EOL] log . debug ( [string] , body ) [EOL] if headers is None : [EOL] headers = { [string] : [string] , [string] : ( [string] ) , } [EOL] async with self . post ( token_url , data = dict ( urldecode ( body ) ) , auth = auth , timeout = timeout , headers = headers , verify_ssl = verify_ssl , withhold_token = True , proxy = proxy , ) as resp : [EOL] text = await resp . text ( ) [EOL] log . debug ( [string] , resp . status ) [EOL] log . debug ( [string] , resp . headers , text ) [EOL] log . debug ( [string] , len ( self . compliance_hook [ [string] ] ) , ) [EOL] for hook in self . compliance_hook [ [string] ] : [EOL] log . debug ( [string] , hook ) [EOL] resp = hook ( resp ) [EOL] self . token = self . _client . parse_request_body_response ( text , scope = self . scope ) [EOL] if [string] not in self . token : [EOL] log . debug ( [string] ) [EOL] self . token [ [string] ] = refresh_token [EOL] return self . token [EOL] [EOL] [comment] [EOL] [EOL] async def _request ( self , method , url , data = None , headers = None , withhold_token = False , client_id = None , client_secret = None , ** kwargs , ) : [EOL] [docstring] [EOL] if not is_secure_transport ( url ) : [EOL] raise InsecureTransportError ( ) [EOL] [EOL] if self . token and not withhold_token : [EOL] log . debug ( [string] , len ( self . compliance_hook [ [string] ] ) , ) [EOL] for hook in self . compliance_hook [ [string] ] : [EOL] log . debug ( [string] , hook ) [EOL] url , headers , data = hook ( url , headers , data ) [EOL] log . debug ( [string] , self . token ) [EOL] try : [EOL] url , headers , data = self . _client . add_token ( url , http_method = method , body = data , headers = headers ) [EOL] [comment] [EOL] except TokenExpiredError : [EOL] if self . auto_refresh_url : [EOL] log . debug ( [string] , self . auto_refresh_url , ) [EOL] [comment] [EOL] auth = kwargs . pop ( [string] , None ) [EOL] if client_id and client_secret and ( auth is None ) : [EOL] log . debug ( [string] , client_id , ) [EOL] auth = aiohttp . BasicAuth ( client_id , client_secret ) [EOL] token = await self . refresh_token ( self . auto_refresh_url , auth = auth , ** kwargs ) [EOL] if self . token_updater : [EOL] log . debug ( [string] , token , self . token_updater ) [EOL] res = self . token_updater ( token ) [EOL] if isawaitable ( res ) : [EOL] await res [EOL] url , headers , data = self . _client . add_token ( url , http_method = method , body = data , headers = headers ) [EOL] else : [EOL] raise TokenUpdated ( token ) [EOL] [EOL] else : [EOL] raise [EOL] [EOL] log . debug ( [string] , url , method ) [EOL] log . debug ( [string] , headers , data ) [EOL] log . debug ( [string] , kwargs ) [EOL] return await super ( OAuth2Session , self ) . _request ( method , url , headers = headers , data = data , ** kwargs ) [EOL] [EOL] def register_compliance_hook ( self , hook_type , hook ) : [EOL] [docstring] [EOL] if hook_type not in self . compliance_hook : [EOL] raise ValueError ( f" [string] { hook_type } [string] { self . compliance_hook } [string] " ) [EOL] [EOL] self . compliance_hook [ hook_type ] . add ( hook ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0