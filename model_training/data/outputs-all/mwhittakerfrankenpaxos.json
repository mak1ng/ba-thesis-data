from typing import Dict , List [EOL] import typing [EOL] import benchmarks [EOL] from . import cluster [EOL] from . import host [EOL] import unittest [EOL] [EOL] [EOL] class ClusterTest ( unittest . TestCase ) : [EOL] def test_good_configuration ( self ) : [EOL] json = [string] [EOL] c = cluster . Cluster . from_json_string ( json , lambda a : host . FakeHost ( a ) ) [EOL] f1 = c . f ( [number] ) [EOL] self . assertEqual ( f1 [ [string] ] , [ host . FakeHost ( [string] ) , host . FakeHost ( [string] ) ] ) [EOL] self . assertEqual ( f1 [ [string] ] , [ host . FakeHost ( [string] ) , host . FakeHost ( [string] ) , host . FakeHost ( [string] ) ] ) [EOL] f2 = c . f ( [number] ) [EOL] self . assertEqual ( f2 [ [string] ] , [ host . FakeHost ( [string] ) , host . FakeHost ( [string] ) , host . FakeHost ( [string] ) ] ) [EOL] self . assertEqual ( f2 [ [string] ] , [ host . FakeHost ( [string] ) , host . FakeHost ( [string] ) , host . FakeHost ( [string] ) , host . FakeHost ( [string] ) , host . FakeHost ( [string] ) ] ) [EOL] [EOL] def _test_bad_f ( self ) : [EOL] json = [string] [EOL] c = cluster . Cluster . from_json_string ( json , lambda a : host . FakeHost ( a ) ) [EOL] [EOL] def test_bad_f ( self ) : [EOL] self . assertRaises ( ValueError , self . _test_bad_f ) [EOL] [EOL] def _test_bad_addresses ( self ) : [EOL] json = [string] [EOL] c = cluster . Cluster . from_json_string ( json , lambda a : host . FakeHost ( a ) ) [EOL] [EOL] def test_bad_addresses ( self ) : [EOL] self . assertRaises ( ValueError , self . _test_bad_addresses ) [EOL] [EOL] def _test_bad_address ( self ) : [EOL] json = [string] [EOL] c = cluster . Cluster . from_json_string ( json , lambda a : host . FakeHost ( a ) ) [EOL] [EOL] def test_bad_address ( self ) : [EOL] self . assertRaises ( ValueError , self . _test_bad_address ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $benchmarks.cluster.Cluster$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[benchmarks.host.Host]]$ 0 $benchmarks.cluster.Cluster$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[benchmarks.host.Host]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[benchmarks.host.Host]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[benchmarks.host.Host]]$ 0 $benchmarks.cluster.Cluster$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[benchmarks.host.Host]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[benchmarks.host.Host]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $benchmarks.cluster.Cluster$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $benchmarks.cluster.Cluster$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $benchmarks.cluster.Cluster$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import proto_util [EOL] from . import proto_util [EOL] from typing import NamedTuple , Union [EOL] [EOL] [EOL] class StringWorkload ( NamedTuple ) : [EOL] size_mean = ... [EOL] size_std = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . size_mean , [string] : self . size_std , } } [EOL] [EOL] [EOL] class UniformSingleKeyWorkload ( NamedTuple ) : [EOL] num_keys = ... [EOL] size_mean = ... [EOL] size_std = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . num_keys , [string] : self . size_mean , [string] : self . size_std , } } [EOL] [EOL] [EOL] class BernoulliSingleKeyWorkload ( NamedTuple ) : [EOL] conflict_rate = ... [EOL] size_mean = ... [EOL] size_std = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . conflict_rate , [string] : self . size_mean , [string] : self . size_std , } } [EOL] [EOL] [EOL] Workload = Union [ StringWorkload , UniformSingleKeyWorkload , BernoulliSingleKeyWorkload ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import builtins [EOL] from . import pd_util [EOL] from typing import Tuple [EOL] import argparse [EOL] import os [EOL] import pandas as pd [EOL] [EOL] [EOL] def get_benchmark_parser ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] , [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , choices = [ [string] , [string] , [string] , [string] , [string] ] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] def get_plot_parser ( default_output_filename ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = default_output_filename , help = [string] ) [EOL] return parser [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import matplotlib [EOL] import argparse [EOL] import pandas [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] [EOL] from . import pd_util [EOL] import argparse [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] [EOL] [EOL] def plot_latency ( ax , latency_ms ) : [EOL] ax . plot_date ( latency_ms . index , latency_ms . rolling ( [string] ) . median ( ) , label = [string] , fmt = [string] ) [EOL] ax . plot_date ( latency_ms . index , latency_ms . rolling ( [string] ) . quantile ( [number] ) , label = [string] , fmt = [string] ) [EOL] ax . plot_date ( latency_ms . index , latency_ms . rolling ( [string] ) . quantile ( [number] ) , label = [string] , fmt = [string] ) [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] [EOL] [EOL] def plot_throughput ( ax , start , stop ) : [EOL] [comment] [EOL] ax . plot_date ( pd_util . throughput ( start , [number] , trim = True ) . index , pd_util . throughput ( start , [number] , trim = True ) , label = [string] , fmt = [string] ) [EOL] ax . plot_date ( pd_util . throughput ( stop , [number] , trim = True ) . index , pd_util . throughput ( stop , [number] , trim = True ) , label = [string] , fmt = [string] , alpha = [number] ) [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] df = pd . read_csv ( args . data_csv , parse_dates = [ [string] , [string] ] ) [EOL] df . index = df [ [string] ] [EOL] [EOL] [comment] [EOL] start_time = df [ [string] ] . iloc [ [number] ] [EOL] new_start_time = start_time + pd . DateOffset ( seconds = args . drop ) [EOL] df = df [ df [ [string] ] >= new_start_time ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] num_plots = [number] [EOL] fig , ax = plt . subplots ( num_plots , [number] , figsize = ( [number] , num_plots * [number] ) ) [EOL] plot_latency ( ax [ [number] ] , df [ [string] ] / [number] ) [EOL] plot_throughput ( ax [ [number] ] , df [ [string] ] , df [ [string] ] ) [EOL] for axes in ax : [EOL] axes . grid ( ) [EOL] axes . legend ( loc = [string] ) [EOL] for label in axes . get_xticklabels ( ) : [EOL] label . set_ha ( [string] ) [EOL] label . set_rotation ( [number] ) [EOL] fig . set_tight_layout ( True ) [EOL] fig . savefig ( args . output ) [EOL] print ( f' [string] { args . output } [string] ' ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from pandas . plotting import register_matplotlib_converters [EOL] register_matplotlib_converters ( ) [EOL] main ( get_parser ( ) . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import paramiko [EOL] import benchmarks [EOL] from . import proc [EOL] import os [EOL] import paramiko [EOL] import unittest [EOL] [EOL] [EOL] class ParamikoProcTest ( unittest . TestCase ) : [EOL] def _client ( self ) : [EOL] client = paramiko . SSHClient ( ) [EOL] client . set_missing_host_key_policy ( paramiko . client . AutoAddPolicy ) [EOL] home = os . path . expanduser ( [string] ) [EOL] client . connect ( [string] , key_filename = f'{ home } [string] ' ) [EOL] return client [EOL] [EOL] def test_wait ( self ) : [EOL] p = proc . ParamikoProc ( client = self . _client ( ) , args = [string] , stdout = [string] , stderr = [string] ) [EOL] self . assertEqual ( p . wait ( ) , [number] ) [EOL] [EOL] [comment] [EOL] def test_kill ( self ) : [EOL] p = proc . ParamikoProc ( client = self . _client ( ) , args = [ [string] , [string] ] , stdout = [string] , stderr = [string] ) [EOL] p . kill ( ) [EOL] [EOL] [comment] [EOL] def test_double_kill ( self ) : [EOL] p = proc . ParamikoProc ( client = self . _client ( ) , args = [ [string] , [string] ] , stdout = [string] , stderr = [string] ) [EOL] p . kill ( ) [EOL] p . kill ( ) [EOL] [EOL] [comment] [EOL] def test_pid ( self ) : [EOL] p = proc . ParamikoProc ( client = self . _client ( ) , args = [ [string] , [string] ] , stdout = [string] , stderr = [string] ) [EOL] p . pid ( ) [EOL] p . kill ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.SSHClient$ 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 $benchmarks.proc.ParamikoProc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import proto_util [EOL] import builtins [EOL] from . import proto_util [EOL] from . import workload [EOL] from typing import NamedTuple , Union [EOL] [EOL] [EOL] class UniformReadWriteWorkload ( NamedTuple ) : [EOL] num_keys = ... [EOL] read_fraction = ... [EOL] write_size_mean = ... [EOL] write_size_std = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . num_keys , [string] : self . read_fraction , [string] : self . write_size_mean , [string] : self . write_size_std , } } [EOL] [EOL] [EOL] class UniformMultiKeyReadWriteWorkload ( NamedTuple ) : [EOL] num_keys = ... [EOL] num_operations = ... [EOL] read_fraction = ... [EOL] write_size_mean = ... [EOL] write_size_std = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . num_keys , [string] : self . num_operations , [string] : self . read_fraction , [string] : self . write_size_mean , [string] : self . write_size_std , } } [EOL] [EOL] [EOL] class WriteOnlyStringWorkload ( NamedTuple ) : [EOL] workload = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . workload , } } [EOL] [EOL] [EOL] class WriteOnlyUniformSingleKeyWorkload ( NamedTuple ) : [EOL] workload = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . workload , } } [EOL] [EOL] class WriteOnlyBernoulliSingleKeyWorkload ( NamedTuple ) : [EOL] workload = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . workload , } } [EOL] [EOL] [EOL] ReadWriteWorkload = Union [ UniformReadWriteWorkload , UniformMultiKeyReadWriteWorkload , WriteOnlyStringWorkload , WriteOnlyUniformSingleKeyWorkload , WriteOnlyBernoulliSingleKeyWorkload ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WriteOnlyStringWorkload.workload.StringWorkload$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WriteOnlyUniformSingleKeyWorkload.workload.UniformSingleKeyWorkload$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WriteOnlyBernoulliSingleKeyWorkload.workload.BernoulliSingleKeyWorkload$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterable , Optional , List , IO , Sequence , Any , TypeVar , Dict , Union , Tuple , Collection [EOL] import builtins [EOL] import proc [EOL] import _csv [EOL] import benchmarks [EOL] import pandas [EOL] import typing [EOL] import contextlib [EOL] import host [EOL] import datetime [EOL] from . import host [EOL] from . import pd_util [EOL] from . import proc [EOL] from . import util [EOL] from typing import ( Any , Collection , Dict , Generic , Iterable , IO , List , NamedTuple , Optional , Sequence , Tuple , TypeVar , Union ) [EOL] import colorful [EOL] import contextlib [EOL] import csv [EOL] import datetime [EOL] import datetime [EOL] import json [EOL] import os [EOL] import pandas as pd [EOL] import queue [EOL] import random [EOL] import string [EOL] import subprocess [EOL] import threading [EOL] [EOL] [EOL] def _random_string ( n ) : [EOL] return [string] . join ( random . choice ( string . ascii_uppercase ) for _ in range ( n ) ) [EOL] [EOL] [EOL] def _now_string ( ) : [EOL] return str ( datetime . datetime . now ( ) ) . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def _pretty_now_string ( ) : [EOL] return datetime . datetime . now ( ) . strftime ( [string] ) [EOL] [EOL] [EOL] class _Reaped ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , proc , returncode_file ) : [EOL] self . proc = proc [EOL] self . returncode_file = returncode_file [EOL] [EOL] def __enter__ ( self ) : [EOL] return self . proc [EOL] [EOL] def __exit__ ( self , cls , exn , traceback ) : [EOL] self . proc . kill ( ) [EOL] returncode = self . proc . wait ( ) [EOL] with open ( self . returncode_file , [string] ) as f : [EOL] f . write ( str ( returncode ) + [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class SuiteDirectory ( object ) : [EOL] def __init__ ( self , path , name = None ) : [EOL] assert os . path . exists ( path ) [EOL] [EOL] self . benchmark_dir_id = [number] [EOL] [EOL] name_suffix = ( [string] + name ) if name else [string] [EOL] self . path = os . path . join ( os . path . abspath ( path ) , _now_string ( ) + [string] + _random_string ( [number] ) + name_suffix ) [EOL] assert not os . path . exists ( self . path ) [EOL] os . makedirs ( self . path ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . path } [string] ' [EOL] [EOL] def __enter__ ( self ) : [EOL] self . write_string ( [string] , str ( datetime . datetime . now ( ) ) ) [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . write_string ( [string] , str ( datetime . datetime . now ( ) ) ) [EOL] [EOL] def abspath ( self , filename ) : [EOL] return os . path . join ( self . path , filename ) [EOL] [EOL] def create_file ( self , filename ) : [EOL] return open ( self . abspath ( filename ) , [string] ) [EOL] [EOL] def write_string ( self , filename , s ) : [EOL] with self . create_file ( filename ) as f : [EOL] f . write ( s + [string] ) [EOL] return self . abspath ( filename ) [EOL] [EOL] def write_dict ( self , filename , d ) : [EOL] self . write_string ( filename , json . dumps ( d , indent = [number] , default = str ) ) [EOL] return self . abspath ( filename ) [EOL] [EOL] def benchmark_directory ( self , name = None ) : [EOL] benchmark_dir_id = self . benchmark_dir_id [EOL] self . benchmark_dir_id += [number] [EOL] name_suffix = ( [string] + name ) if name else [string] [EOL] path = os . path . join ( self . path , [string] . format ( benchmark_dir_id , name_suffix ) ) [EOL] return BenchmarkDirectory ( path ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class BenchmarkDirectory ( object ) : [EOL] def __init__ ( self , path ) : [EOL] assert not os . path . exists ( path ) [EOL] self . path = os . path . abspath ( path ) [EOL] os . makedirs ( self . path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . process_stack = contextlib . ExitStack ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . pids = dict ( ) [EOL] [EOL] [comment] [EOL] self . logfile = self . create_file ( [string] ) [EOL] [EOL] [comment] [EOL] self . exited = False [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . path } [string] ' [EOL] [EOL] def __enter__ ( self ) : [EOL] self . process_stack . __enter__ ( ) [EOL] self . write_string ( [string] , str ( datetime . datetime . now ( ) ) ) [EOL] return self [EOL] [EOL] def __exit__ ( self , cls , exn , trace ) : [EOL] if self . exited : [EOL] return [EOL] [EOL] self . process_stack . __exit__ ( cls , exn , trace ) [EOL] self . exited = True [EOL] self . write_dict ( [string] , { f'{ ip } [string] { pid }' : label for ( ( ip , pid ) , label ) in self . pids . items ( ) } ) [EOL] self . write_string ( [string] , str ( datetime . datetime . now ( ) ) ) [EOL] [EOL] def abspath ( self , filename ) : [EOL] return os . path . join ( self . path , filename ) [EOL] [EOL] def create_file ( self , filename ) : [EOL] return open ( self . abspath ( filename ) , [string] ) [EOL] [EOL] def write_string ( self , filename , s ) : [EOL] with self . create_file ( filename ) as f : [EOL] f . write ( s + [string] ) [EOL] return self . abspath ( filename ) [EOL] [EOL] def write_dict ( self , filename , d ) : [EOL] self . write_string ( filename , json . dumps ( d , indent = [number] , default = str ) ) [EOL] return self . abspath ( filename ) [EOL] [EOL] def log ( self , s ) : [EOL] self . logfile . write ( f' [string] { _pretty_now_string ( ) } [string] { s } [string] ' ) [EOL] self . logfile . flush ( ) [EOL] [EOL] def popen ( self , host , label , cmd ) : [EOL] [docstring] [EOL] proc = host . popen ( cmd , stdout = self . abspath ( f'{ label } [string] ' ) , stderr = self . abspath ( f'{ label } [string] ' ) ) [EOL] self . write_string ( f'{ label } [string] ' , proc . cmd ( ) ) [EOL] self . process_stack . enter_context ( _Reaped ( proc , self . abspath ( f'{ label } [string] ' ) ) ) [EOL] pid = proc . pid ( ) [EOL] if pid : [EOL] self . pids [ ( host . ip ( ) , pid ) ] = label [EOL] return proc [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] Input = TypeVar ( [string] ) [EOL] Output = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Suite ( Generic [ Input , Output ] ) : [EOL] [comment] [EOL] [comment] [EOL] def args ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def inputs ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def summary ( self , input , output ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def run_benchmark ( self , bench , args , input ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def run_suite ( self , suite_dir ) : [EOL] print ( f' [string] { suite_dir . path } [string] ' ) [EOL] [EOL] [comment] [EOL] args = self . args ( ) [EOL] inputs = self . inputs ( ) [EOL] assert len ( inputs ) > [number] , inputs [EOL] [EOL] [comment] [EOL] suite_dir . write_dict ( [string] , args ) [EOL] suite_dir . write_string ( [string] , [string] . join ( str ( i ) for i in inputs ) ) [EOL] [EOL] [comment] [EOL] results_file = suite_dir . create_file ( [string] ) [EOL] results_writer = csv . writer ( results_file ) [EOL] [EOL] suite_start_time = datetime . datetime . now ( ) [EOL] for ( i , input ) in enumerate ( inputs , [number] ) : [EOL] bench_start_time = datetime . datetime . now ( ) [EOL] with suite_dir . benchmark_directory ( ) as bench : [EOL] [comment] [EOL] bench . write_string ( [string] , str ( input ) ) [EOL] bench . write_dict ( [string] , util . tuple_to_dict ( input ) ) [EOL] output = self . run_benchmark ( bench , args , input ) [EOL] [EOL] [comment] [EOL] if i == [number] : [EOL] results_writer . writerow ( util . flatten_tuple_fields ( input ) + util . flatten_tuple_fields ( output ) ) [EOL] [EOL] [comment] [EOL] row = util . flatten_tuple ( input ) + util . flatten_tuple ( output ) [EOL] results_writer . writerow ( [ str ( x ) for x in row ] ) [EOL] results_file . flush ( ) [EOL] [EOL] [comment] [EOL] colorful . use_style ( [string] ) [EOL] [EOL] [comment] [EOL] n = len ( inputs ) [EOL] percent = ( i / n ) * [number] [EOL] info = f'{ colorful . bold } [string] { i : [string] } [string] { n : [string] }{ colorful . reset } [string] ' [EOL] info += f'{ percent : [string] } [string] ' [EOL] [EOL] [comment] [EOL] [comment] [EOL] current_time = datetime . datetime . now ( ) [EOL] bench_duration = current_time - bench_start_time [EOL] suite_duration = current_time - suite_start_time [EOL] duration_per_iteration = suite_duration / i [EOL] remaining_duration = ( n - i ) * duration_per_iteration [EOL] [EOL] def round_delta ( d ) : [EOL] return datetime . timedelta ( seconds = int ( d . total_seconds ( ) ) ) [EOL] [EOL] info += f'{ colorful . blue ( round_delta ( bench_duration ) ) } [string] ' [EOL] info += f'{ colorful . green ( round_delta ( suite_duration ) ) } [string] ' [EOL] info += f'{ colorful . magenta ( round_delta ( remaining_duration ) ) } [string] ' [EOL] [EOL] [comment] [EOL] info += f'{ colorful . lightGray ( self . summary ( input , output ) ) }' [EOL] print ( info ) [EOL] [EOL] [EOL] class LatencyOutput ( NamedTuple ) : [EOL] mean_ms = ... [EOL] median_ms = ... [EOL] min_ms = ... [EOL] max_ms = ... [EOL] p90_ms = ... [EOL] p95_ms = ... [EOL] p99_ms = ... [EOL] [EOL] [EOL] class ThroughputOutput ( NamedTuple ) : [EOL] mean = ... [EOL] median = ... [EOL] min = ... [EOL] max = ... [EOL] p90 = ... [EOL] p95 = ... [EOL] p99 = ... [EOL] [EOL] [EOL] class RecorderOutput ( NamedTuple ) : [EOL] latency = ... [EOL] start_throughput_1s = ... [EOL] [EOL] [EOL] def _latency ( s ) : [EOL] return LatencyOutput ( mean_ms = s . mean ( ) , median_ms = s . median ( ) , min_ms = s . min ( ) , max_ms = s . max ( ) , p90_ms = s . quantile ( [number] ) , p95_ms = s . quantile ( [number] ) , p99_ms = s . quantile ( [number] ) , ) [EOL] [EOL] [EOL] def _throughput ( s ) : [EOL] return ThroughputOutput ( mean = s . mean ( ) , median = s . median ( ) , min = s . min ( ) , max = s . max ( ) , p90 = s . quantile ( [number] ) , p95 = s . quantile ( [number] ) , p99 = s . quantile ( [number] ) , ) [EOL] [EOL] [EOL] def _wrangle_recorder_data ( bench , filenames , drop_prefix , save_data = True ) : [EOL] bench . log ( [string] ) [EOL] for filename in filenames : [EOL] bench . log ( f' [string] { filename }' ) [EOL] df = pd_util . read_csvs ( filenames , parse_dates = [ [string] , [string] ] ) [EOL] bench . log ( [string] ) [EOL] [EOL] bench . log ( [string] ) [EOL] df = df . set_index ( [string] ) [EOL] bench . log ( [string] ) [EOL] [EOL] bench . log ( [string] ) [EOL] df = df . sort_index ( [number] ) [EOL] bench . log ( [string] ) [EOL] [EOL] if save_data : [EOL] save_data_filename = bench . abspath ( [string] ) [EOL] bench . log ( f' [string] { save_data_filename } [string] ' ) [EOL] df . to_csv ( save_data_filename ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for filename in filenames : [EOL] bench . log ( f' [string] { filename } [string] ' ) [EOL] os . remove ( filename ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] if save_data : [EOL] bench . log ( [string] ) [EOL] subprocess . call ( [ [string] , bench . abspath ( [string] ) ] ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] start_time = df . index [ [number] ] [EOL] new_start_time = ( start_time + pd . DateOffset ( seconds = drop_prefix . total_seconds ( ) ) ) [EOL] bench . log ( [string] ) [EOL] df = df [ df . index >= new_start_time ] [EOL] bench . log ( [string] ) [EOL] [EOL] return df [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def parse_recorder_data ( bench , filenames , drop_prefix , save_data = True ) : [EOL] df = _wrangle_recorder_data ( bench , filenames , drop_prefix , save_data ) [EOL] return RecorderOutput ( latency = _latency ( df [ [string] ] / [number] ) , start_throughput_1s = _throughput ( pd_util . throughput ( df . index , [number] ) ) , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def parse_labeled_recorder_data ( bench , filenames , drop_prefix , save_data = True ) : [EOL] df = _wrangle_recorder_data ( bench , filenames , drop_prefix , save_data ) [EOL] [EOL] [comment] [EOL] outputs = dict ( ) [EOL] for label in df [ [string] ] . unique ( ) : [EOL] bench . log ( f' [string] { label } [string] ' ) [EOL] ldf = df [ df [ [string] ] == label ] [EOL] [EOL] bench . log ( f' [string] ' ) [EOL] latency = _latency ( ldf [ [string] ] / [number] ) [EOL] bench . log ( f' [string] ' ) [EOL] [EOL] bench . log ( f' [string] ' ) [EOL] start_throughput_1s = _throughput ( pd_util . weighted_throughput ( ldf [ [string] ] , [number] ) ) [EOL] bench . log ( f' [string] ' ) [EOL] [EOL] outputs [ label ] = RecorderOutput ( latency = latency , start_throughput_1s = start_throughput_1s , ) [EOL] bench . log ( f' [string] { label } [string] ' ) [EOL] [EOL] return outputs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.datetime$ 0 0 0 $datetime.timedelta$ 0 $datetime.datetime$ 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $LatencyOutput$ 0 0 0 $ThroughputOutput$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] from . import benchmark [EOL] from . import pd_util [EOL] from typing import Any , Dict , List , NamedTuple , Tuple [EOL] import os [EOL] import subprocess [EOL] [EOL] [EOL] def flatten_tuple_fields ( t , prefixes = None ) : [EOL] [docstring] [EOL] return _flatten_tuple_fields ( t , [ ] ) [EOL] [EOL] [EOL] def flatten_tuple ( t ) : [EOL] [docstring] [EOL] values = [ ] [EOL] for x in t : [EOL] if isinstance ( x , tuple ) : [EOL] values += flatten_tuple ( x ) [EOL] else : [EOL] values . append ( x ) [EOL] return values [EOL] [EOL] [EOL] def tuple_to_dict ( t ) : [EOL] [docstring] [EOL] d = { } [EOL] for ( field , x ) in zip ( t . _fields , t ) : [EOL] if _is_namedtuple_instance ( x ) : [EOL] d [ field ] = tuple_to_dict ( x ) [EOL] else : [EOL] d [ field ] = x [EOL] return d [EOL] [EOL] [EOL] [comment] [EOL] def _is_namedtuple_instance ( x ) : [EOL] b = type ( x ) . __bases__ [EOL] if len ( b ) != [number] or b [ [number] ] != tuple : [EOL] return False [EOL] [EOL] f = getattr ( type ( x ) , [string] , None ) [EOL] if not isinstance ( f , tuple ) : [EOL] return False [EOL] [EOL] return all ( type ( n ) == str for n in f ) [EOL] [EOL] [EOL] def _flatten_tuple_fields ( t , prefixes ) : [EOL] fields = [ ] [EOL] for ( field , x ) in zip ( t . _fields , t ) : [EOL] if _is_namedtuple_instance ( x ) : [EOL] fields += _flatten_tuple_fields ( x , prefixes + [ field ] ) [EOL] else : [EOL] fields . append ( [string] . join ( prefixes + [ field ] ) ) [EOL] return fields [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Callable [EOL] import typing [EOL] import builtins [EOL] import host [EOL] import benchmarks [EOL] from . import host [EOL] from typing import Any , Callable , Dict , List [EOL] import json [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class _RemoteHostCache : [EOL] def __init__ ( self , connect ) : [EOL] self . _connect = connect [EOL] self . _hosts = dict ( ) [EOL] [EOL] def connect ( self , address ) : [EOL] if address in self . _hosts : [EOL] return self . _hosts [ address ] [EOL] else : [EOL] host = self . _connect ( address ) [EOL] self . _hosts [ address ] = host [EOL] return host [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class Cluster : [EOL] @ staticmethod def _sanitize_json ( data ) : [EOL] sanitized = dict ( ) [EOL] for ( f , cluster ) in data . items ( ) : [EOL] if not isinstance ( cluster , dict ) : [EOL] raise ValueError ( f' [string] { cluster } [string] { f } [string] ' f' [string] ' ) [EOL] [EOL] sanitized [ int ( f ) ] = dict ( ) [EOL] for ( role , addresses ) in cluster . items ( ) : [EOL] if not isinstance ( addresses , list ) : [EOL] raise ValueError ( f' [string] { addresses } [string] { role } [string] ' f'{ cluster } [string] { f } [string] ' ) [EOL] [EOL] for ( i , address ) in enumerate ( addresses ) : [EOL] if not isinstance ( address , str ) : [EOL] raise ValueError ( f' [string] { i } [string] { address } [string] { role } [string] ' f'{ cluster } [string] { f } [string] ' ) [EOL] [EOL] sanitized [ int ( f ) ] [ role ] = addresses [EOL] [EOL] return sanitized [EOL] [EOL] @ staticmethod def from_json_file ( filename , connect ) : [EOL] with open ( filename , [string] ) as f : [EOL] cluster = Cluster . _sanitize_json ( json . load ( f ) ) [EOL] return Cluster ( cluster , connect ) [EOL] [EOL] @ staticmethod def from_json_string ( json_string , connect ) : [EOL] cluster = Cluster . _sanitize_json ( json . loads ( json_string ) ) [EOL] return Cluster ( cluster , connect ) [EOL] [EOL] @ staticmethod def from_dict ( cluster , connect ) : [EOL] return Cluster ( cluster , connect ) [EOL] [EOL] def __init__ ( self , cluster , connect ) : [EOL] self . _cache = _RemoteHostCache ( connect ) [EOL] self . _cluster = cluster [EOL] [EOL] def f ( self , x ) : [EOL] return { role : [ self . _cache . connect ( a ) for a in addresses ] for ( role , addresses ) in self . _cluster [ x ] . items ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 0 $typing.Callable[[builtins.str],benchmarks.host.Host]$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 $typing.Dict[builtins.str,host.Host]$ 0 0 0 0 0 0 0 $host.Host$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $benchmarks.host.Host$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $benchmarks.host.Host$ 0 0 $benchmarks.host.Host$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 $'Cluster'$ 0 $builtins.str$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 0 0 $'Cluster'$ 0 $builtins.str$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 0 0 $'Cluster'$ 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 0 $benchmarks.cluster._RemoteHostCache$ 0 0 0 $typing.Callable[[builtins.str],host.Host]$ 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.List[host.Host]]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0
from typing import Optional [EOL] import benchmark [EOL] import builtins [EOL] import proc [EOL] import benchmarks [EOL] import typing [EOL] import host [EOL] from . import benchmark [EOL] from . import host [EOL] from . import proc [EOL] from typing import Optional [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class JavaPerfProc ( proc . Proc ) : [EOL] def __init__ ( self , bench , host , proc , label ) : [EOL] self . _bench = bench [EOL] self . _host = host [EOL] self . _proc = proc [EOL] self . _label = label [EOL] self . _killed = False [EOL] [EOL] [comment] [EOL] pid = proc . pid ( ) [EOL] if pid is None : [EOL] self . _perf_record = None [EOL] else : [EOL] self . _perf_record = bench . popen ( host = host , label = f'{ label } [string] ' , cmd = [ [string] , [string] , [string] , [string] , bench . abspath ( f' [string] { pid } [string] ' ) , [string] , str ( proc . pid ( ) ) , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def cmd ( self ) : [EOL] return self . _proc . cmd ( ) [EOL] [EOL] def pid ( self ) : [EOL] return self . _proc . pid ( ) [EOL] [EOL] def wait ( self ) : [EOL] return self . _proc . wait ( ) [EOL] [EOL] def kill ( self ) : [EOL] [comment] [EOL] if self . _killed : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . _perf_record is None : [EOL] self . _proc . kill ( ) [EOL] self . _killed = True [EOL] return [EOL] [EOL] self . _perf_record . kill ( ) [EOL] self . _bench . popen ( host = self . _host , label = f'{ self . _label } [string] ' , cmd = [ [string] , str ( self . _proc . pid ( ) ) ] ) . wait ( ) [EOL] self . _bench . popen ( host = self . _host , label = f'{ self . _label } [string] ' , cmd = [ [string] , [string] , f' [string] { self . _proc . pid ( ) } [string] ' , self . _bench . abspath ( f' [string] { self . _proc . pid ( ) } [string] ' ) ] ) . wait ( ) [EOL] self . _proc . kill ( ) [EOL] self . _killed = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 $host.Host$ 0 $proc.Proc$ 0 $builtins.str$ 0 0 0 0 0 $benchmarks.benchmark.BenchmarkDirectory$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 $benchmarks.host.Host$ 0 $host.Host$ 0 0 0 $benchmarks.proc.Proc$ 0 $proc.Proc$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $proc.Proc$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $host.Host$ 0 $host.Host$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $proc.Proc$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import List , Any , Dict , Tuple , FrozenSet [EOL] import typing [EOL] import builtins [EOL] import requests [EOL] import pandas [EOL] from typing import Dict , FrozenSet , List , Tuple [EOL] import json [EOL] import pandas as pd [EOL] import requests [EOL] import subprocess [EOL] import time [EOL] [EOL] [EOL] [comment] [EOL] def prometheus_config ( scrape_interval_ms , jobs ) : [EOL] [docstring] [EOL] return { [string] : { [string] : f'{ scrape_interval_ms } [string] ' } , [string] : [ { [string] : job_name , [string] : [ { [string] : addressses } ] , } for ( job_name , addressses ) in jobs . items ( ) ] , } [EOL] [EOL] [EOL] class PrometheusQueryer : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def __init__ ( self , tsdb_path , popen = subprocess . Popen ) : [EOL] [comment] [EOL] empty_prometheus_config = [string] [EOL] with open ( empty_prometheus_config , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] [comment] [EOL] self . address = [string] [EOL] cmd = [ [string] , f' [string] { empty_prometheus_config }' , f' [string] { tsdb_path }' , f' [string] { self . address }' , ] [EOL] self . proc = popen ( cmd ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , cls , exn , traceback ) : [EOL] self . proc . terminate ( ) [EOL] [EOL] def query ( self , q ) : [EOL] [docstring] [EOL] num_retries = [number] [EOL] for i in range ( num_retries - [number] ) : [EOL] try : [EOL] return self . _query_once ( q ) [EOL] except ( ConnectionRefusedError , requests . exceptions . ConnectionError , ValueError ) : [EOL] time . sleep ( i * [number] ) [EOL] return self . _query_once ( q ) [EOL] [EOL] def _query_once ( self , q ) : [EOL] [docstring] [EOL] r = requests . get ( f' [string] { self . address } [string] ' , params = { [string] : q , [string] : [string] } ) [EOL] if r . status_code == [number] : [EOL] [comment] [EOL] raise ValueError ( f' [string] { q } [string] ' ) [EOL] if r . json ( ) [ [string] ] == [string] : [EOL] pass [EOL] elif r . json ( ) [ [string] ] == [string] : [EOL] raise ValueError ( f' [string] { q } [string] ' + f'{ r . json ( ) [ [string] ] } [string] ' ) [EOL] else : [EOL] raise ValueError ( f' [string] { r . json ( ) [ [string] ] }' ) [EOL] [EOL] series = { } [EOL] for stream in r . json ( ) [ [string] ] [ [string] ] : [EOL] if r . json ( ) [ [string] ] [ [string] ] == [string] : [EOL] values = stream [ [string] ] [EOL] else : [EOL] values = [ stream [ [string] ] ] [EOL] [EOL] timestamps = [ t for [ t , x ] in values ] [EOL] timestamps = ( pd . to_datetime ( timestamps , unit = [string] , origin = [string] ) . tz_localize ( [string] ) ) [EOL] values = [ x for [ t , x ] in values ] [EOL] s = pd . Series ( values , index = timestamps ) [EOL] series [ frozenset ( stream [ [string] ] . items ( ) ) ] = s [EOL] [EOL] return pd . DataFrame ( series ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $'PrometheusQueryer'$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.FrozenSet[typing.Tuple[builtins.str,builtins.str]],pandas.Series]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.FrozenSet[typing.Tuple[builtins.str,builtins.str]],pandas.Series]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.FrozenSet[typing.Tuple[builtins.str,builtins.str]],pandas.Series]$ 0 0
from typing import Iterable , Any , List [EOL] import typing [EOL] import builtins [EOL] import pandas [EOL] from typing import Iterable , List [EOL] import numpy as np [EOL] import pandas as pd [EOL] [EOL] [EOL] def read_csvs ( filenames , ** kwargs ) : [EOL] [docstring] [EOL] dfs = [ ] [EOL] for filename in filenames : [EOL] dfs . append ( pd . read_csv ( filename , header = [number] , ** kwargs ) ) [EOL] return pd . concat ( dfs , ignore_index = True ) [EOL] [EOL] [EOL] def outliers ( s , n ) : [EOL] [docstring] [EOL] mu = s . mean ( ) [EOL] sigma = s . std ( ) [EOL] return np . abs ( s - mu ) >= ( n * sigma ) [EOL] [EOL] [EOL] def throughput ( s , window_size_ms , trim = False ) : [EOL] [docstring] [EOL] s = pd . Series ( [number] , index = s . sort_values ( ) ) [EOL] throughput = ( s . rolling ( f'{ window_size_ms } [string] ' ) . count ( ) / ( window_size_ms / [number] ) ) [EOL] if trim : [EOL] t = ( throughput . index [ [number] ] + pd . DateOffset ( microseconds = window_size_ms * [number] ) ) [EOL] return throughput [ throughput . index >= t ] [EOL] else : [EOL] [comment] [EOL] start_time = throughput . index [ [number] ] [EOL] offset = pd . DateOffset ( microseconds = window_size_ms * [number] ) [EOL] for i , ( index , row ) in enumerate ( s . iteritems ( ) , start = [number] ) : [EOL] if i < [number] : [EOL] continue [EOL] if index > start_time + offset : [EOL] return throughput [ [number] : ] [EOL] throughput [ index ] = i / ( index - start_time ) . total_seconds ( ) [EOL] return throughput [ [number] : ] [EOL] [EOL] [EOL] def weighted_throughput ( s , window_size_ms ) : [EOL] [docstring] [EOL] window_size_s = window_size_ms / [number] [EOL] window_size_us = window_size_ms * [number] [EOL] [EOL] s = s . sort_index ( ) [EOL] throughput = s . rolling ( f'{ window_size_ms } [string] ' ) . sum ( ) / window_size_s [EOL] t = throughput . index [ [number] ] + pd . DateOffset ( microseconds = window_size_us ) [EOL] return throughput [ throughput . index >= t ] [EOL] [EOL] [EOL] def rate ( s , window_size_ms ) : [EOL] [docstring] [EOL] def _dxdt ( s ) : [EOL] dx = s . iloc [ - [number] ] - s . iloc [ [number] ] [EOL] dt = ( s . index [ - [number] ] - s . index [ [number] ] ) . total_seconds ( ) [EOL] return dx / dt [EOL] [EOL] [comment] [EOL] [comment] [EOL] return ( s . sort_index ( [number] ) . rolling ( f'{ window_size_ms } [string] ' , min_periods = [number] ) . apply ( _dxdt , raw = False ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.Series$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.Series$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.Series$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.Series$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict , Union , Tuple , Type [EOL] import typing [EOL] import builtins [EOL] from enum import Enum [EOL] from typing import Any , Dict , List , NamedTuple , Tuple , Union [EOL] [EOL] [comment] [EOL] Scalar = Union [ str , int , float , Enum ] [EOL] [EOL] [comment] [EOL] Value = Union [ Scalar , List [ Scalar ] , Any ] [EOL] [EOL] [comment] [EOL] Message = Dict [ str , Any ] [EOL] [EOL] [EOL] def message_to_pbtext ( d , indent = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] flattened = [ ] [EOL] for ( k , v ) in d . items ( ) : [EOL] if isinstance ( v , list ) : [EOL] flattened += [ ( k , x ) for x in v ] [EOL] else : [EOL] flattened . append ( ( k , v ) ) [EOL] [EOL] strings = [ ] [EOL] for ( k , v ) in flattened : [EOL] if isinstance ( v , str ) : [EOL] strings . append ( f'{ k } [string] { v } [string] ' ) [EOL] elif isinstance ( v , int ) : [EOL] strings . append ( f'{ k } [string] { v }' ) [EOL] elif isinstance ( v , float ) : [EOL] strings . append ( f'{ k } [string] { v }' ) [EOL] elif isinstance ( v , Enum ) : [EOL] strings . append ( f'{ k } [string] { v . name }' ) [EOL] else : [EOL] [comment] [EOL] substring = _indent ( message_to_pbtext ( v , indent + [number] ) , indent + [number] ) [EOL] strings . append ( f'{ k } [string] { substring } [string] ' ) [EOL] return [string] . join ( strings ) [EOL] [EOL] [EOL] def _indent ( s , n ) : [EOL] padding = [string] * n [EOL] return padding + s . replace ( [string] , [string] + padding ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import proto_util [EOL] import builtins [EOL] from . . import proto_util [EOL] from typing import List , NamedTuple , Union [EOL] [EOL] [EOL] class DoNothing ( NamedTuple ) : [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : dict ( ) } [EOL] [EOL] [EOL] class RepeatedLeaderReconfiguration ( NamedTuple ) : [EOL] acceptors = ... [EOL] delay_ms = ... [EOL] period_ms = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . acceptors , [string] : self . delay_ms , [string] : self . period_ms , } } [EOL] [EOL] [EOL] class LeaderReconfiguration ( NamedTuple ) : [EOL] reconfiguration_warmup_delay_ms = ... [EOL] reconfiguration_warmup_period_ms = ... [EOL] reconfiguration_warmup_num = ... [EOL] reconfiguration_delay_ms = ... [EOL] reconfiguration_period_ms = ... [EOL] reconfiguration_num = ... [EOL] failure_delay_ms = ... [EOL] recover_delay_ms = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . reconfiguration_warmup_delay_ms , [string] : self . reconfiguration_warmup_period_ms , [string] : self . reconfiguration_warmup_num , [string] : self . reconfiguration_delay_ms , [string] : self . reconfiguration_period_ms , [string] : self . reconfiguration_num , [string] : self . failure_delay_ms , [string] : self . recover_delay_ms , } } [EOL] [EOL] [EOL] class MatchmakerReconfiguration ( NamedTuple ) : [EOL] reconfiguration_warmup_delay_ms = ... [EOL] reconfiguration_warmup_period_ms = ... [EOL] reconfiguration_warmup_num = ... [EOL] matchmaker_reconfiguration_delay_ms = ... [EOL] matchmaker_reconfiguration_period_ms = ... [EOL] matchmaker_reconfiguration_num = ... [EOL] failure_delay_ms = ... [EOL] recover_delay_ms = ... [EOL] reconfigure_delay_ms = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . reconfiguration_warmup_delay_ms , [string] : self . reconfiguration_warmup_period_ms , [string] : self . reconfiguration_warmup_num , [string] : self . matchmaker_reconfiguration_delay_ms , [string] : self . matchmaker_reconfiguration_period_ms , [string] : self . matchmaker_reconfiguration_num , [string] : self . failure_delay_ms , [string] : self . recover_delay_ms , [string] : self . reconfigure_delay_ms , } } [EOL] [EOL] [EOL] class LeaderFailure ( NamedTuple ) : [EOL] leader_change_warmup_delay_ms = ... [EOL] leader_change_warmup_period_ms = ... [EOL] leader_change_warmup_num = ... [EOL] failure_delay_ms = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . leader_change_warmup_delay_ms , [string] : self . leader_change_warmup_period_ms , [string] : self . leader_change_warmup_num , [string] : self . failure_delay_ms , } } [EOL] [EOL] [EOL] class Chaos ( NamedTuple ) : [EOL] leader_change_warmup_delay_ms = ... [EOL] leader_change_warmup_period_ms = ... [EOL] leader_change_warmup_num = ... [EOL] reconfiguration_warmup_delay_ms = ... [EOL] reconfiguration_warmup_period_ms = ... [EOL] reconfiguration_warmup_num = ... [EOL] matchmaker_reconfiguration_warmup_delay_ms = ... [EOL] matchmaker_reconfiguration_warmup_period_ms = ... [EOL] matchmaker_reconfiguration_warmup_num = ... [EOL] leader_failure_delay_ms = ... [EOL] acceptor_failure_delay_ms = ... [EOL] matchmaker_failure_delay_ms = ... [EOL] acceptor_recover_delay_ms = ... [EOL] matchmaker_recover_delay_ms = ... [EOL] [comment] [EOL] name = [string] [EOL] [EOL] def to_proto ( self ) : [EOL] return { [string] : { [string] : self . leader_change_warmup_delay_ms , [string] : self . leader_change_warmup_period_ms , [string] : self . leader_change_warmup_num , [string] : self . reconfiguration_warmup_delay_ms , [string] : self . reconfiguration_warmup_period_ms , [string] : self . reconfiguration_warmup_num , [string] : self . matchmaker_reconfiguration_warmup_delay_ms , [string] : self . matchmaker_reconfiguration_warmup_period_ms , [string] : self . matchmaker_reconfiguration_warmup_num , [string] : self . leader_failure_delay_ms , [string] : self . acceptor_failure_delay_ms , [string] : self . matchmaker_failure_delay_ms , [string] : self . acceptor_recover_delay_ms , [string] : self . matchmaker_recover_delay_ms , } } [EOL] [EOL] [EOL] DriverWorkload = Union [ DoNothing , RepeatedLeaderReconfiguration , LeaderReconfiguration , MatchmakerReconfiguration , LeaderFailure , Chaos ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import datetime [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def plot_latency_throughput ( df , ax , label ) : [EOL] grouped = df . groupby ( [string] ) [EOL] for ( name , group ) in grouped : [EOL] print ( f' [string] { name }' ) [EOL] print ( group [ [ [string] , [string] ] ] ) [EOL] throughput = grouped [ [string] ] . mean ( ) . sort_index ( ) [EOL] latency = grouped [ [string] ] . mean ( ) . sort_index ( ) [EOL] print ( f' [string] { throughput } [string] ' ) [EOL] print ( f' [string] { latency } [string] ' ) [EOL] print ( ) [EOL] ax . plot ( throughput , latency , [string] , label = label , linewidth = [number] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] df = add_num_clients ( pd . read_csv ( args . results ) ) [EOL] vanilla_df = add_num_clients ( pd . read_csv ( args . vanilla_results ) ) [EOL] [EOL] [comment] [EOL] for d in [ df , vanilla_df ] : [EOL] d [ [string] ] = d [ [string] ] [EOL] d [ [string] ] = d [ [string] ] [EOL] ack = df [ [string] ] [EOL] f1 = df [ [string] ] [EOL] [EOL] [comment] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] plot_latency_throughput ( df [ ( ack == False ) & ( f1 == False ) ] , ax , [string] ) [EOL] plot_latency_throughput ( df [ f1 == True ] , ax , [string] ) [EOL] plot_latency_throughput ( df [ ack == True ] , ax , [string] ) [EOL] plot_latency_throughput ( vanilla_df , ax , [string] ) [EOL] [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] ax . legend ( loc = [string] ) [EOL] ax . grid ( ) [EOL] fig . savefig ( args . output , bbox_inches = [string] ) [EOL] print ( f' [string] { args . output } [string] ' ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import datetime [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def plot_latency_throughput ( df , ax , label , style ) : [EOL] def outlier_throughput ( g ) : [EOL] cutoff = [number] * g [ [string] ] . max ( ) [EOL] return g [ g [ [string] ] >= cutoff ] [ [string] ] . mean ( ) [EOL] [EOL] def outlier_throughput_std ( g ) : [EOL] cutoff = [number] * g [ [string] ] . max ( ) [EOL] return g [ g [ [string] ] >= cutoff ] [ [string] ] . std ( ) [EOL] [EOL] def outlier_latency ( g ) : [EOL] cutoff = [number] * g [ [string] ] . min ( ) [EOL] return g [ g [ [string] ] <= cutoff ] [ [string] ] . mean ( ) [EOL] [EOL] grouped = df . groupby ( [string] ) [EOL] for ( name , group ) in grouped : [EOL] print ( f' [string] { name }' ) [EOL] print ( group [ [ [string] , [string] ] ] ) [EOL] throughput = grouped . apply ( outlier_throughput ) . sort_index ( ) [EOL] latency = grouped . apply ( outlier_latency ) . sort_index ( ) [EOL] throughput_std = grouped . apply ( outlier_throughput_std ) . sort_index ( ) [EOL] print ( f' [string] { throughput } [string] ' ) [EOL] print ( f' [string] { latency } [string] ' ) [EOL] print ( ) [EOL] line = ax . plot ( throughput , latency , style , label = label , linewidth = [number] ) [ [number] ] [EOL] ax . fill_betweenx ( latency , throughput - throughput_std , throughput + throughput_std , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] thrifty_df = add_num_clients ( pd . read_csv ( args . thrifty_results ) ) [EOL] non_thrifty_df = add_num_clients ( pd . read_csv ( args . non_thrifty_results ) ) [EOL] [EOL] [comment] [EOL] for df in [ thrifty_df , non_thrifty_df ] : [EOL] df [ [string] ] = df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] [EOL] [EOL] [comment] [EOL] thrifty_df = thrifty_df [ thrifty_df [ [string] ] <= [number] ] [EOL] non_thrifty_df = non_thrifty_df [ non_thrifty_df [ [string] ] <= [number] ] [EOL] [EOL] [comment] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] plot_latency_throughput ( thrifty_df , ax , [string] , [string] ) [EOL] plot_latency_throughput ( non_thrifty_df , ax , [string] , [string] ) [EOL] [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] ax . grid ( ) [EOL] ax . legend ( ) [EOL] fig . savefig ( args . output , bbox_inches = [string] ) [EOL] print ( f' [string] { args . output } [string] ' ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Tuple , Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import itertools [EOL] import datetime [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from . . . import pd_util [EOL] from typing import Any , List , Tuple [EOL] import argparse [EOL] import datetime [EOL] import itertools [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] MARKERS = itertools . cycle ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def read_data ( file , drop_head , drop_tail , nudge ) : [EOL] [comment] [EOL] df = pd . read_csv ( file , parse_dates = [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] start_time = df [ [string] ] . iloc [ [number] ] [EOL] end_time = df [ [string] ] . iloc [ - [number] ] [EOL] new_start_time = start_time + pd . DateOffset ( seconds = drop_head ) + nudge [EOL] new_end_time = end_time - pd . DateOffset ( seconds = drop_tail ) [EOL] df = df [ df [ [string] ] >= new_start_time ] [EOL] df = df [ df [ [string] ] <= new_end_time ] [EOL] [EOL] [comment] [EOL] df [ [string] ] = pd . Timestamp ( [number] ) + ( df [ [string] ] - new_start_time ) [EOL] df . index = df [ [string] ] [EOL] [EOL] return ( df , new_start_time ) [EOL] [EOL] [EOL] def split ( df ) : [EOL] for i in range ( len ( df ) ) : [EOL] if i == [number] : [EOL] continue [EOL] [EOL] if df . iloc [ i ] [ [string] ] - df . iloc [ i - [number] ] [ [string] ] > pd . Timedelta ( [string] ) : [EOL] return df . iloc [ : i ] , df [ i : ] [EOL] [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def plot_throughput ( ax , n , before , after , sample_every , marker ) : [EOL] tput_before = pd_util . throughput ( before , [number] , trim = True ) [ : : sample_every ] [EOL] line = ax . plot_date ( tput_before . index , tput_before , fmt = [string] , marker = marker , markevery = [number] ) [ [number] ] [EOL] tput_after = pd_util . throughput ( after , [number] , trim = False ) [ : : sample_every ] [EOL] line = ax . plot_date ( tput_after . index , tput_after , fmt = [string] , marker = marker , markevery = [number] , color = line . get_color ( ) ) [EOL] [EOL] [EOL] def plot_latency ( ax , n , before , after , sample_every , marker ) : [EOL] median_before = before . rolling ( [string] ) . median ( ) [EOL] p95_before = before . rolling ( [string] ) . quantile ( [number] ) [EOL] line = ax . plot_date ( before . index [ : : sample_every ] , median_before [ : : sample_every ] , label = [string] , fmt = [string] , marker = marker , markevery = [number] ) [ [number] ] [EOL] ax . fill_between ( before . index [ : : sample_every ] , median_before [ : : sample_every ] , p95_before [ : : sample_every ] , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] median_after = after . rolling ( [string] ) . median ( ) [EOL] p95_after = after . rolling ( [string] ) . quantile ( [number] ) [EOL] label = [string] if n == [number] else f'{ n } [string] ' [EOL] ax . plot_date ( after . index [ : : sample_every ] , median_after [ : : sample_every ] , label = label , color = line . get_color ( ) , fmt = [string] , marker = marker , markevery = [number] ) [EOL] ax . fill_between ( after . index [ : : sample_every ] , median_after [ : : sample_every ] , p95_after [ : : sample_every ] , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] [EOL] def plot ( n1 , n4 , n8 , output_filename , start_time , sample_every ) : [EOL] [comment] [EOL] num_plots = [number] [EOL] fig , ax = plt . subplots ( num_plots , [number] , figsize = ( [number] , num_plots * [number] * [number] ) , sharex = True ) [EOL] [EOL] [comment] [EOL] n1_before , n1_after = split ( n1 ) [EOL] print ( [string] ) [EOL] n4_before , n4_after = split ( n4 ) [EOL] print ( [string] ) [EOL] n8_before , n8_after = split ( n8 ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] plot_latency ( ax [ [number] ] , [number] , n1_before [ [string] ] / [number] , n1_after [ [string] ] / [number] , sample_every , next ( MARKERS ) ) [EOL] plot_latency ( ax [ [number] ] , [number] , n4_before [ [string] ] / [number] , n4_after [ [string] ] / [number] , sample_every , next ( MARKERS ) ) [EOL] plot_latency ( ax [ [number] ] , [number] , n8_before [ [string] ] / [number] , n8_after [ [string] ] / [number] , sample_every , next ( MARKERS ) ) [EOL] ax [ [number] ] . set_ylim ( [ [number] , [number] ] ) [EOL] [EOL] plot_throughput ( ax [ [number] ] , [number] , n1_before [ [string] ] , n1_after [ [string] ] , sample_every , next ( MARKERS ) ) [EOL] plot_throughput ( ax [ [number] ] , [number] , n4_before [ [string] ] , n4_after [ [string] ] , sample_every , next ( MARKERS ) ) [EOL] plot_throughput ( ax [ [number] ] , [number] , n8_before [ [string] ] , n8_after [ [string] ] , sample_every , next ( MARKERS ) ) [EOL] [EOL] [comment] [EOL] for axes in ax : [EOL] axes . grid ( ) [EOL] [comment] [EOL] axes . xaxis . set_major_formatter ( matplotlib . dates . DateFormatter ( [string] ) ) [EOL] for label in axes . get_xticklabels ( ) : [EOL] label . set_ha ( [string] ) [EOL] label . set_rotation ( - [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] origin = datetime . datetime ( [number] , [number] , [number] , second = [number] ) [EOL] naive_start_time = start_time . to_pydatetime ( ) . replace ( tzinfo = None ) [EOL] failure = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] leader_recover = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] acceptor_recover = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] matchmaker_recover = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] [EOL] for axes in ax : [EOL] axes . axvline ( x = origin + ( failure - naive_start_time ) , color = [string] , ls = [string] ) [EOL] axes . axvline ( x = origin + ( leader_recover - naive_start_time ) , color = [string] ) [EOL] axes . axvline ( x = origin + ( acceptor_recover - naive_start_time ) , color = [string] ) [EOL] axes . axvline ( x = origin + ( matchmaker_recover - naive_start_time ) , color = [string] ) [EOL] [EOL] [comment] [EOL] handles , labels = ax [ [number] ] . get_legend_handles_labels ( ) [EOL] legend = fig . legend ( handles , labels , bbox_to_anchor = ( [number] , [number] ) , loc = [string] , ncol = [number] ) [EOL] [EOL] [comment] [EOL] ax [ [number] ] . set_xlabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] fig . set_tight_layout ( True ) [EOL] fig . savefig ( output_filename , bbox_extra_artists = ( legend , ) , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ( n1 , start_time ) = read_data ( args . n1 , args . drop_head , args . drop_tail , nudge = datetime . timedelta ( seconds = [number] ) ) [EOL] ( n4 , _ ) = read_data ( args . n4 , args . drop_head , args . drop_tail , nudge = datetime . timedelta ( milliseconds = [number] ) ) [EOL] ( n8 , _ ) = read_data ( args . n8 , args . drop_head , args . drop_tail , nudge = datetime . timedelta ( milliseconds = [number] ) ) [EOL] [EOL] [comment] [EOL] plot ( n1 = n1 , n4 = n4 , n8 = n8 , output_filename = args . output , start_time = start_time , sample_every = args . sample_every , ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pandas.DataFrame,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pandas.DataFrame,pandas.DataFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import Tuple , Dict , Any , List [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import datetime [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from . . . import pd_util [EOL] from typing import Any , List , Tuple [EOL] import argparse [EOL] import datetime [EOL] import itertools [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def read_data ( file , drop_head , drop_tail ) : [EOL] [comment] [EOL] df = pd . read_csv ( file , parse_dates = [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] start_time = df [ [string] ] . iloc [ [number] ] [EOL] end_time = df [ [string] ] . iloc [ - [number] ] [EOL] new_start_time = start_time + pd . DateOffset ( seconds = drop_head ) [EOL] new_end_time = end_time - pd . DateOffset ( seconds = drop_tail ) [EOL] df = df [ df [ [string] ] >= new_start_time ] [EOL] df = df [ df [ [string] ] <= new_end_time ] [EOL] [EOL] [comment] [EOL] df [ [string] ] = pd . Timestamp ( [number] ) + ( df [ [string] ] - new_start_time ) [EOL] df . index = df [ [string] ] [EOL] [EOL] return ( df , new_start_time ) [EOL] [EOL] [EOL] def plot_throughput ( ax , label , color , s , sample_every ) : [EOL] tput = pd_util . throughput ( s , [number] , trim = True ) [ : : sample_every ] [EOL] ax . plot_date ( tput . index , tput , fmt = [string] , color = color , markevery = [number] , label = [string] ) [EOL] [EOL] [EOL] def plot_latency ( ax , label , color , s , sample_every ) : [EOL] median = s . rolling ( [string] ) . median ( ) [EOL] max_latency = s . rolling ( [string] ) . max ( ) [EOL] [EOL] [comment] [EOL] line = ax . plot_date ( s . index [ : : sample_every ] , median [ : : sample_every ] , fmt = [string] , color = color , markevery = [number] , label = label ) [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] ax . fill_between ( s . index [ : : sample_every ] , median [ : : sample_every ] , max_latency [ : : sample_every ] , color = line . get_color ( ) ) [EOL] [EOL] [EOL] def plot ( baseline , gc , phase1 , matchmaking , output_filename , start_time , sample_every ) : [EOL] [comment] [EOL] num_rows = [number] [EOL] num_columns = [number] [EOL] fig , ax = plt . subplots ( num_rows , num_columns , figsize = ( num_columns * [number] * [number] , num_rows * [number] * [number] ) , sharex = True , sharey = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] origin = datetime . datetime ( [number] , [number] , [number] , second = [number] ) [EOL] naive_start_time = start_time . to_pydatetime ( ) . replace ( tzinfo = None ) [EOL] reconfigurations = [ datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , ] [EOL] [EOL] for row in ax : [EOL] for axes in row : [EOL] for t in reconfigurations : [EOL] axes . axvline ( x = origin + ( t - naive_start_time ) , color = [string] , alpha = [number] ) [EOL] [EOL] [comment] [EOL] plot_latency ( ax [ [number] ] [ [number] ] , [string] , [string] , baseline [ [string] ] / [number] , sample_every ) [EOL] plot_latency ( ax [ [number] ] [ [number] ] , [string] , [string] , gc [ [string] ] / [number] , sample_every ) [EOL] plot_latency ( ax [ [number] ] [ [number] ] , [string] , [string] , phase1 [ [string] ] / [number] , sample_every ) [EOL] plot_latency ( ax [ [number] ] [ [number] ] , [string] , [string] , matchmaking [ [string] ] / [number] , sample_every ) [EOL] plot_throughput ( ax [ [number] ] [ [number] ] , [string] , [string] , baseline [ [string] ] , sample_every ) [EOL] plot_throughput ( ax [ [number] ] [ [number] ] , [string] , [string] , gc [ [string] ] , sample_every ) [EOL] plot_throughput ( ax [ [number] ] [ [number] ] , [string] , [string] , phase1 [ [string] ] , sample_every ) [EOL] plot_throughput ( ax [ [number] ] [ [number] ] , [string] , [string] , matchmaking [ [string] ] , sample_every ) [EOL] [EOL] [comment] [EOL] for row in ax : [EOL] for axes in row : [EOL] axes . grid ( ) [EOL] [comment] [EOL] axes . xaxis . set_major_formatter ( matplotlib . dates . DateFormatter ( [string] ) ) [EOL] for label in axes . get_xticklabels ( ) : [EOL] [comment] [EOL] label . set_ha ( [string] ) [EOL] label . set_rotation ( - [number] ) [EOL] [EOL] [comment] [EOL] ax [ [number] ] [ [number] ] . set_title ( [string] ) [EOL] ax [ [number] ] [ [number] ] . set_title ( [string] ) [EOL] ax [ [number] ] [ [number] ] . set_title ( [string] ) [EOL] ax [ [number] ] [ [number] ] . set_title ( [string] ) [EOL] [EOL] [comment] [EOL] for axes in ax [ [number] ] : [EOL] axes . set_xlabel ( [string] ) [EOL] ax [ [number] ] [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] [ [number] ] . set_ylabel ( [string] ) [EOL] fig . set_tight_layout ( True ) [EOL] [comment] [EOL] [comment] [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] [comment] [EOL] ( baseline , start_time ) = read_data ( args . baseline , args . drop_head , args . drop_tail + [number] ) [EOL] ( gc , _ ) = read_data ( args . gc , args . drop_head , args . drop_tail ) [EOL] ( phase1 , _ ) = read_data ( args . phase1 , args . drop_head , args . drop_tail ) [EOL] ( matchmaking , _ ) = read_data ( args . matchmaking , args . drop_head , args . drop_tail ) [EOL] [EOL] plot ( baseline = baseline , gc = gc , phase1 = phase1 , matchmaking = matchmaking , output_filename = args . output , start_time = start_time , sample_every = args . sample_every , ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pandas.DataFrame,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Dict , Any , List [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import datetime [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from . . . import pd_util [EOL] from typing import Any , List , Tuple [EOL] import argparse [EOL] import datetime [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def read_data ( file , drop_head , drop_tail ) : [EOL] [comment] [EOL] df = pd . read_csv ( file , parse_dates = [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] start_time = df [ [string] ] . iloc [ [number] ] [EOL] end_time = df [ [string] ] . iloc [ - [number] ] [EOL] new_start_time = start_time + pd . DateOffset ( seconds = drop_head ) [EOL] new_end_time = end_time - pd . DateOffset ( seconds = drop_tail ) [EOL] df = df [ df [ [string] ] >= new_start_time ] [EOL] df = df [ df [ [string] ] <= new_end_time ] [EOL] [EOL] [comment] [EOL] df [ [string] ] = pd . Timestamp ( [number] ) + ( df [ [string] ] - new_start_time ) [EOL] df . index = df [ [string] ] [EOL] [EOL] return ( df , new_start_time ) [EOL] [EOL] [EOL] def plot_throughput ( ax , s , sample_every ) : [EOL] tput = pd_util . throughput ( s , [number] , trim = True ) [ : : sample_every ] [EOL] ax . plot_date ( tput . index , tput , fmt = [string] , label = [string] ) [EOL] [EOL] [EOL] def plot_latency ( ax , s , sample_every ) : [EOL] median = s . rolling ( [string] ) . median ( ) [EOL] p95 = s . rolling ( [string] ) . quantile ( [number] ) [EOL] line = ax . plot_date ( s . index [ : : sample_every ] , median [ : : sample_every ] , label = [string] , fmt = [string] ) [ [number] ] [EOL] ax . fill_between ( s . index [ : : sample_every ] , median [ : : sample_every ] , p95 [ : : sample_every ] , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] [EOL] def plot ( df , output_filename , start_time , sample_every ) : [EOL] [comment] [EOL] num_plots = [number] [EOL] fig , ax = plt . subplots ( num_plots , [number] , figsize = ( [number] , num_plots * [number] * [number] ) , sharex = True ) [EOL] [EOL] [comment] [EOL] plot_latency ( ax [ [number] ] , df [ [string] ] / [number] , sample_every ) [EOL] plot_throughput ( ax [ [number] ] , df [ [string] ] , sample_every ) [EOL] [EOL] [comment] [EOL] for axes in ax : [EOL] axes . grid ( ) [EOL] [comment] [EOL] axes . xaxis . set_major_formatter ( matplotlib . dates . DateFormatter ( [string] ) ) [EOL] for label in axes . get_xticklabels ( ) : [EOL] label . set_ha ( [string] ) [EOL] label . set_rotation ( - [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] origin = datetime . datetime ( [number] , [number] , [number] , second = [number] ) [EOL] naive_start_time = start_time . to_pydatetime ( ) . replace ( tzinfo = None ) [EOL] reconfigurations = [ datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , ] [EOL] failure = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] recover = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] [EOL] for axes in ax : [EOL] for t in reconfigurations : [EOL] axes . axvline ( x = origin + ( t - naive_start_time ) , color = [string] ) [EOL] axes . axvline ( x = origin + ( failure - naive_start_time ) , color = [string] , ls = [string] ) [EOL] axes . axvline ( x = origin + ( recover - naive_start_time ) , color = [string] ) [EOL] [EOL] [comment] [EOL] ax [ [number] ] . set_xlabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] fig . set_tight_layout ( True ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] [comment] [EOL] ( df , start_time ) = read_data ( args . f1n100 , args . drop_head , args . drop_tail ) [EOL] [EOL] [comment] [EOL] plot ( df = df , output_filename = args . output , start_time = start_time , sample_every = args . sample_every ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pandas.DataFrame,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Tuple , Dict , Any , List [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import itertools [EOL] import matplotlib [EOL] import datetime [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from . . . import pd_util [EOL] from typing import Any , List , Tuple [EOL] import argparse [EOL] import datetime [EOL] import itertools [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] MARKERS = itertools . cycle ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def read_data ( file , drop_head , drop_tail ) : [EOL] [comment] [EOL] df = pd . read_csv ( file , parse_dates = [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] start_time = df [ [string] ] . iloc [ [number] ] [EOL] end_time = df [ [string] ] . iloc [ - [number] ] [EOL] new_start_time = start_time + pd . DateOffset ( seconds = drop_head ) [EOL] new_end_time = end_time - pd . DateOffset ( seconds = drop_tail ) [EOL] df = df [ df [ [string] ] >= new_start_time ] [EOL] df = df [ df [ [string] ] <= new_end_time ] [EOL] [EOL] [comment] [EOL] df [ [string] ] = pd . Timestamp ( [number] ) + ( df [ [string] ] - new_start_time ) [EOL] df . index = df [ [string] ] [EOL] [EOL] return ( df , new_start_time ) [EOL] [EOL] [EOL] def plot_throughput ( ax , n , s , sample_every , marker ) : [EOL] tput = pd_util . throughput ( s , [number] , trim = True ) [ : : sample_every ] [EOL] ax . plot_date ( tput . index , tput , fmt = [string] , marker = marker , markevery = [number] , label = f'{ n } [string] ' ) [EOL] [EOL] [EOL] def plot_latency ( ax , n , s , sample_every , marker ) : [EOL] median = s . rolling ( [string] ) . median ( ) [EOL] p95 = s . rolling ( [string] ) . quantile ( [number] ) [EOL] label = [string] if n == [number] else f'{ n } [string] ' [EOL] line = ax . plot_date ( s . index [ : : sample_every ] , median [ : : sample_every ] , label = label , fmt = [string] , marker = marker , markevery = [number] ) [ [number] ] [EOL] ax . fill_between ( s . index [ : : sample_every ] , median [ : : sample_every ] , p95 [ : : sample_every ] , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] [EOL] def plot ( n1 , n4 , n8 , output_filename , start_time , sample_every ) : [EOL] [comment] [EOL] num_plots = [number] [EOL] fig , ax = plt . subplots ( num_plots , [number] , figsize = ( [number] , num_plots * [number] * [number] ) , sharex = True ) [EOL] [EOL] [comment] [EOL] plot_latency ( ax [ [number] ] , [number] , n1 [ [string] ] / [number] , sample_every , next ( MARKERS ) ) [EOL] plot_latency ( ax [ [number] ] , [number] , n4 [ [string] ] / [number] , sample_every , next ( MARKERS ) ) [EOL] plot_latency ( ax [ [number] ] , [number] , n8 [ [string] ] / [number] , sample_every , next ( MARKERS ) ) [EOL] plot_throughput ( ax [ [number] ] , [number] , n1 [ [string] ] , sample_every , next ( MARKERS ) ) [EOL] plot_throughput ( ax [ [number] ] , [number] , n4 [ [string] ] , sample_every , next ( MARKERS ) ) [EOL] plot_throughput ( ax [ [number] ] , [number] , n8 [ [string] ] , sample_every , next ( MARKERS ) ) [EOL] [EOL] [comment] [EOL] for axes in ax : [EOL] axes . grid ( ) [EOL] [comment] [EOL] axes . xaxis . set_major_formatter ( matplotlib . dates . DateFormatter ( [string] ) ) [EOL] for label in axes . get_xticklabels ( ) : [EOL] label . set_ha ( [string] ) [EOL] label . set_rotation ( - [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] origin = datetime . datetime ( [number] , [number] , [number] , second = [number] ) [EOL] naive_start_time = start_time . to_pydatetime ( ) . replace ( tzinfo = None ) [EOL] reconfigurations = [ datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) , ] [EOL] failure = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] recover = datetime . datetime ( [number] , [number] , [number] , hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] [EOL] for axes in ax : [EOL] for t in reconfigurations : [EOL] axes . axvline ( x = origin + ( t - naive_start_time ) , color = [string] ) [EOL] axes . axvline ( x = origin + ( failure - naive_start_time ) , color = [string] , ls = [string] ) [EOL] axes . axvline ( x = origin + ( recover - naive_start_time ) , color = [string] ) [EOL] [EOL] [comment] [EOL] handles , labels = ax [ [number] ] . get_legend_handles_labels ( ) [EOL] legend = fig . legend ( handles , labels , bbox_to_anchor = ( [number] , [number] ) , loc = [string] , ncol = [number] ) [EOL] [EOL] [comment] [EOL] ax [ [number] ] . set_xlabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] fig . set_tight_layout ( True ) [EOL] fig . savefig ( output_filename , bbox_extra_artists = ( legend , ) , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] [comment] [EOL] ( f1n1 , start_time ) = read_data ( args . f1n1 , args . drop_head , args . drop_tail ) [EOL] ( f1n4 , _ ) = read_data ( args . f1n4 , args . drop_head , args . drop_tail + [number] ) [EOL] ( f1n8 , _ ) = read_data ( args . f1n8 , args . drop_head , args . drop_tail ) [EOL] [EOL] [comment] [EOL] plot ( n1 = f1n1 , n4 = f1n4 , n8 = f1n8 , output_filename = args . output , start_time = start_time , sample_every = args . sample_every , ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pandas.DataFrame,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import datetime [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def plot_latency_throughput ( df , ax ) : [EOL] def outlier_throughput ( g ) : [EOL] cutoff = [number] * g [ [string] ] . max ( ) [EOL] return g [ g [ [string] ] >= cutoff ] [ [string] ] . mean ( ) [EOL] [EOL] def outlier_throughput_std ( g ) : [EOL] cutoff = [number] * g [ [string] ] . max ( ) [EOL] return g [ g [ [string] ] >= cutoff ] [ [string] ] . std ( ) [EOL] [EOL] def outlier_latency ( g ) : [EOL] cutoff = [number] * g [ [string] ] . min ( ) [EOL] return g [ g [ [string] ] <= cutoff ] [ [string] ] . mean ( ) [EOL] [EOL] grouped = df . groupby ( [string] ) [EOL] for ( name , group ) in grouped : [EOL] print ( f' [string] { name }' ) [EOL] print ( group [ [ [string] , [string] ] ] ) [EOL] throughput = grouped . apply ( outlier_throughput ) . sort_index ( ) [EOL] latency = grouped . apply ( outlier_latency ) . sort_index ( ) [EOL] throughput_std = grouped . apply ( outlier_throughput_std ) . sort_index ( ) [EOL] print ( f' [string] { throughput } [string] ' ) [EOL] print ( f' [string] { latency } [string] ' ) [EOL] print ( ) [EOL] line = ax . plot ( throughput , latency , [string] , linewidth = [number] ) [ [number] ] [EOL] ax . fill_betweenx ( latency , throughput - throughput_std , throughput + throughput_std , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] df = add_num_clients ( pd . read_csv ( args . results ) ) [EOL] [EOL] [comment] [EOL] df [ [string] ] = df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] [EOL] [EOL] [comment] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] plot_latency_throughput ( df , ax ) [EOL] [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] ax . grid ( ) [EOL] fig . savefig ( args . output , bbox_inches = [string] ) [EOL] print ( f' [string] { args . output } [string] ' ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
	0
from typing import Dict , Any , List [EOL] import argparse [EOL] import benchmark [EOL] import proc [EOL] import builtins [EOL] import benchmarks [EOL] import multipaxos [EOL] import typing [EOL] from . . import benchmark [EOL] from . . import cluster [EOL] from . . import host [EOL] from . . import parser_util [EOL] from . . import pd_util [EOL] from . . import perf_util [EOL] from . . import proc [EOL] from . . import prometheus [EOL] from . . import proto_util [EOL] from . . import util [EOL] from . . import workload [EOL] from . . multipaxos import multipaxos [EOL] from . . workload import Workload [EOL] from typing import Any , Callable , Collection , Dict , List , NamedTuple , Optional [EOL] import argparse [EOL] import csv [EOL] import datetime [EOL] import enum [EOL] import enum [EOL] import itertools [EOL] import os [EOL] import pandas as pd [EOL] import paramiko [EOL] import subprocess [EOL] import time [EOL] import tqdm [EOL] import yaml [EOL] [EOL] [EOL] [comment] [EOL] class SuperMultiPaxosSuite ( benchmark . Suite [ multipaxos . Input , multipaxos . Output ] ) : [EOL] def run_benchmark ( self , bench , args , input ) : [EOL] net = multipaxos . MultiPaxosNet ( args [ [string] ] , args [ [string] ] , input ) [EOL] return self . _run_benchmark ( bench , args , input , net ) [EOL] [EOL] def _run_benchmark ( self , bench , args , input , net ) : [EOL] [comment] [EOL] config = net . config ( ) [EOL] config_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( config_filename , proto_util . message_to_pbtext ( config ) ) [EOL] bench . log ( [string] ) [EOL] [EOL] def java ( heap_size ) : [EOL] cmd = [ [string] , f' [string] { heap_size }' , f' [string] { heap_size }' ] [EOL] if input . monitored : [EOL] cmd += [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] return cmd [EOL] [EOL] [comment] [EOL] assert ( len ( net . placement ( ) . batchers ) == [number] or len ( net . placement ( ) . leaders ) == len ( net . placement ( ) . batchers ) ) [EOL] assert len ( net . placement ( ) . leaders ) == len ( net . placement ( ) . proxy_leaders ) [EOL] assert len ( net . placement ( ) . acceptors ) == [number] [EOL] assert len ( net . placement ( ) . leaders ) == len ( net . placement ( ) . acceptors [ [number] ] ) [EOL] assert len ( net . placement ( ) . leaders ) == len ( net . placement ( ) . replicas ) [EOL] assert len ( net . placement ( ) . leaders ) == len ( net . placement ( ) . proxy_replicas ) [EOL] [EOL] super_node_procs = [ ] [EOL] for ( i , leader ) in enumerate ( net . placement ( ) . leaders ) : [EOL] cmd = java ( input . leader_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . leader_log_level , [string] , leader . host . ip ( ) , [string] , str ( leader . port + [number] ) if input . monitored else [string] , [string] , [string] . format ( input . leader_options . resend_phase1as_period . total_seconds ( ) ) , [string] , str ( input . leader_options . flush_phase2as_every_n ) , [string] , [string] . format ( input . leader_options . election_options . ping_period . total_seconds ( ) ) , [string] , [string] . format ( input . leader_options . election_options . no_ping_timeout_min . total_seconds ( ) ) , [string] , [string] . format ( input . leader_options . election_options . no_ping_timeout_max . total_seconds ( ) ) , [string] , str ( input . proxy_leader_options . flush_phase2as_every_n ) , [string] , str ( input . replica_options . log_grow_size ) , [string] , str ( input . replica_options . unsafe_dont_use_client_table ) , [string] , str ( input . replica_options . send_chosen_watermark_every_n_entries ) , [string] , [string] . format ( input . replica_options . recover_log_entry_min_period . total_seconds ( ) ) , [string] , [string] . format ( input . replica_options . recover_log_entry_max_period . total_seconds ( ) ) , [string] , str ( input . replica_options . unsafe_dont_recover ) , [string] , str ( input . proxy_replica_options . flush_every_n ) , ] [EOL] if len ( net . placement ( ) . batchers ) != [number] : [EOL] cmd += [ [string] , str ( input . batcher_options . batch_size ) , ] [EOL] [EOL] p = bench . popen ( host = leader . host , label = f' [string] { i }' , cmd = cmd ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , leader . host , p , f' [string] { i }' ) [EOL] super_node_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if input . monitored : [EOL] prometheus_config = prometheus . prometheus_config ( int ( input . prometheus_scrape_interval . total_seconds ( ) * [number] ) , { [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . clients ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . batchers ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . leaders ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . proxy_leaders ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for group in net . placement ( ) . acceptors for e in group ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . replicas ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . proxy_replicas ] , } ) [EOL] bench . write_string ( [string] , yaml . dump ( prometheus_config ) ) [EOL] prometheus_server = bench . popen ( host = net . placement ( ) . clients [ [number] ] . host , label = [string] , cmd = [ [string] , f' [string] { bench . abspath ( [string] ) }' , f' [string] { bench . abspath ( [string] ) }' , ] , ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] time . sleep ( input . client_lag . total_seconds ( ) ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] workload_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( workload_filename , proto_util . message_to_pbtext ( input . workload . to_proto ( ) ) ) [EOL] [EOL] client_procs = [ ] [EOL] for ( i , client ) in enumerate ( net . placement ( ) . clients ) : [EOL] p = bench . popen ( host = client . host , label = f' [string] { i }' , cmd = [ [string] , [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , client . host . ip ( ) , [string] , str ( client . port ) , [string] , config_filename , [string] , input . client_log_level , [string] , client . host . ip ( ) , [string] , str ( client . port + [number] ) if input . monitored else [string] , [string] , f'{ input . warmup_duration . total_seconds ( ) } [string] ' , [string] , f'{ input . warmup_timeout . total_seconds ( ) } [string] ' , [string] , f'{ input . warmup_sleep . total_seconds ( ) } [string] ' , [string] , f'{ input . num_warmup_clients_per_proc }' , [string] , f'{ input . duration . total_seconds ( ) } [string] ' , [string] , f'{ input . timeout . total_seconds ( ) } [string] ' , [string] , f'{ input . num_clients_per_proc }' , [string] , f'{ workload_filename }' , [string] , bench . abspath ( f' [string] { i }' ) , [string] , [string] . format ( input . client_options . resend_client_request_period . total_seconds ( ) ) , ] ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , client . host , p , f' [string] { i }' ) [EOL] client_procs . append ( p ) [EOL] bench . log ( f' [string] { input . duration } [string] ' ) [EOL] [EOL] [comment] [EOL] for p in client_procs : [EOL] p . wait ( ) [EOL] for p in super_node_procs : [EOL] p . kill ( ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] client_csvs = [ bench . abspath ( f' [string] { i } [string] ' ) for i in range ( input . num_client_procs ) ] [EOL] return benchmark . parse_recorder_data ( bench , client_csvs , drop_prefix = datetime . timedelta ( seconds = [number] ) ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] return parser_util . get_benchmark_parser ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.Output$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $multipaxos.multipaxos.multipaxos.Input$ 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 $multipaxos.multipaxos.Output$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $multipaxos.multipaxos.multipaxos.Input$ 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $benchmarks.proc.Proc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $typing.List[proc.Proc]$ 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $typing.List[proc.Proc]$ 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multipaxos.multipaxos.multipaxos.Input$ 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import itertools [EOL] import typing [EOL] import matplotlib [EOL] import pandas [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import datetime [EOL] import itertools [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] ALPHA = [number] [EOL] MARKERS = itertools . cycle ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] VERBOSE = False [EOL] [EOL] [EOL] def vprint ( * args ) : [EOL] if VERBOSE : [EOL] print ( * args ) [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def plot_throughput ( df , ax , n , label ) : [EOL] def outlier_throughput ( g ) : [EOL] cutoff = [number] * g [ [string] ] . max ( ) [EOL] return g [ g [ [string] ] >= cutoff ] [ [string] ] . mean ( ) / [number] [EOL] [EOL] def outlier_throughput_std ( g ) : [EOL] cutoff = [number] * g [ [string] ] . max ( ) [EOL] return g [ g [ [string] ] >= cutoff ] [ [string] ] . std ( ) / [number] [EOL] [EOL] [comment] [EOL] grouped = df . groupby ( [string] ) [EOL] vprint ( f' [string] { label }' ) [EOL] for ( name , group ) in grouped : [EOL] vprint ( f' [string] { name }' ) [EOL] vprint ( group [ [ [string] , [string] ] ] ) [EOL] throughput = grouped . apply ( outlier_throughput ) . sort_index ( ) [EOL] std = grouped . apply ( outlier_throughput_std ) . sort_index ( ) [EOL] vprint ( f' [string] { throughput }' ) [EOL] vprint ( f' [string] { std }' ) [EOL] vprint ( ) [EOL] line = ax . plot ( throughput . index , throughput , [string] , marker = next ( MARKERS ) , label = label , linewidth = [number] ) [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] ax . fill_between ( throughput . index , throughput - std , throughput + std , color = line . get_color ( ) , alpha = [number] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] global VERBOSE [EOL] VERBOSE = args . verbose [EOL] [EOL] df = add_num_clients ( pd . read_csv ( args . results ) ) [EOL] [EOL] [comment] [EOL] def replace_with_zero ( df , label ) : [EOL] df [ label ] = df [ label ] . apply ( lambda x : x if x > [number] else [number] ) [EOL] replace_with_zero ( df , [string] ) [EOL] replace_with_zero ( df , [string] ) [EOL] replace_with_zero ( df , [string] ) [EOL] replace_with_zero ( df , [string] ) [EOL] [EOL] [comment] [EOL] df [ [string] ] = ( df [ [string] ] + df [ [string] ] ) [EOL] df [ [string] ] = ( df [ [string] ] + df [ [string] ] ) [EOL] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] plot_throughput ( df [ df [ [string] ] == [number] ] , ax , [number] , [string] ) [EOL] plot_throughput ( df [ df [ [string] ] == [number] ] , ax , [number] , [string] ) [EOL] plot_throughput ( df [ df [ [string] ] == [number] ] , ax , [number] , [string] ) [EOL] [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] ax . legend ( loc = [string] ) [EOL] ax . grid ( ) [EOL] fig . savefig ( args . output , bbox_inches = [string] ) [EOL] print ( f' [string] { args . output } [string] ' ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import Dict , List [EOL] import typing [EOL] import argparse [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] import argparse [EOL] import matplotlib . pyplot as plt [EOL] import os . path [EOL] [EOL] [EOL] def plot_throughput_vs_num_replicas ( args ) : [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] * [number] , [number] ) ) [EOL] [EOL] for fw in [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] : [EOL] fr = [number] - fw [EOL] ns = list ( range ( [number] , [number] ) ) [EOL] throughputs = [ ( n * args . alpha ) / ( n * fw + fr ) for n in ns ] [EOL] write_throughputs = [ fw * t for t in throughputs ] [EOL] read_throughputs = [ fr * t for t in throughputs ] [EOL] ax [ [number] ] . plot ( ns , throughputs , [string] , label = f'{ int ( fw * [number] ) } [string] ' ) [EOL] ax [ [number] ] . plot ( ns , write_throughputs , [string] ) [EOL] ax [ [number] ] . plot ( ns , read_throughputs , [string] ) [EOL] [EOL] for a in ax : [EOL] a . set_xlabel ( [string] ) [EOL] a . grid ( ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . legend ( loc = [string] ) [EOL] output_filename = os . path . join ( args . output_dir , [string] ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def plot_throughput_vs_write_ratio ( args ) : [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] * [number] , [number] ) ) [EOL] [EOL] fws = [ i / [number] for i in range ( [number] , [number] , [number] ) ] + [ [number] ] [EOL] frs = [ [number] - fw for fw in fws ] [EOL] for n in [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] : [EOL] throughputs = [ ( n * args . alpha ) / ( n * fw + fr ) for ( fw , fr ) in zip ( fws , frs ) ] [EOL] write_throughputs = [ fw * t for ( fw , t ) in zip ( fws , throughputs ) ] [EOL] read_throughputs = [ fr * t for ( fr , t ) in zip ( frs , throughputs ) ] [EOL] ax [ [number] ] . plot ( frs , throughputs , [string] , label = f'{ n } [string] ' ) [EOL] ax [ [number] ] . plot ( frs , write_throughputs , [string] ) [EOL] ax [ [number] ] . plot ( frs , read_throughputs , [string] ) [EOL] [EOL] fws = [ i / [number] for i in range ( [number] , [number] , [number] ) ] + [ [number] ] [EOL] frs = [ [number] - fw for fw in fws ] [EOL] throughputs = [ args . alpha / fw for fw in fws ] [EOL] write_throughputs = [ fw * t for ( fw , t ) in zip ( fws , throughputs ) ] [EOL] read_throughputs = [ fr * t for ( fr , t ) in zip ( frs , throughputs ) ] [EOL] ax [ [number] ] . plot ( frs , throughputs , [string] , label = [string] ) [EOL] ax [ [number] ] . plot ( frs , write_throughputs , [string] ) [EOL] ax [ [number] ] . plot ( frs , read_throughputs , [string] ) [EOL] [EOL] for a in ax : [EOL] a . set_xlabel ( [string] ) [EOL] a . grid ( ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . legend ( loc = [string] ) [EOL] output_filename = os . path . join ( args . output_dir , [string] ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def plot_nice_throughput_vs_num_replicas ( args ) : [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] * [number] ) ) [EOL] [EOL] for alpha_w in [ f * args . alpha for f in [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ] : [EOL] ns = list ( range ( [number] , [number] ) ) [EOL] throughputs = [ alpha_w + n * ( args . alpha - alpha_w ) for n in ns ] [EOL] write_throughputs = [ alpha_w ] * len ( throughputs ) [EOL] read_throughputs = [ t - alpha_w for t in throughputs ] [EOL] frs = [ r / ( r + w ) for ( r , w ) in zip ( read_throughputs , write_throughputs ) ] [EOL] ax [ [number] ] . plot ( ns , throughputs , [string] , label = f'{ int ( alpha_w ) } [string] ' ) [EOL] ax [ [number] ] . plot ( ns , frs , [string] ) [EOL] [EOL] for a in ax : [EOL] a . set_xlabel ( [string] ) [EOL] a . grid ( ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . legend ( loc = [string] ) [EOL] output_filename = os . path . join ( args . output_dir , [string] ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def plot_nice_throughput_vs_writes ( args ) : [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] [EOL] alpha_ws = [ args . alpha * i / [number] for i in range ( [number] , [number] ) ] [EOL] for n in [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] : [EOL] throughputs = [ w + n * ( args . alpha - w ) for w in alpha_ws ] [EOL] read_throughputs = [ t - w for ( t , w ) in zip ( throughputs , alpha_ws ) ] [EOL] ax . plot ( alpha_ws , throughputs , [string] , label = f'{ n } [string] ' ) [EOL] [EOL] ax . set_xlabel ( [string] ) [EOL] ax . grid ( ) [EOL] ax . set_ylabel ( [string] ) [EOL] ax . legend ( loc = [string] ) [EOL] output_filename = os . path . join ( args . output_dir , [string] ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] plot_throughput_vs_num_replicas ( args ) [EOL] plot_throughput_vs_write_ratio ( args ) [EOL] plot_nice_throughput_vs_num_replicas ( args ) [EOL] plot_nice_throughput_vs_writes ( args ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import datetime [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def plot_latency_throughput ( df , ax , latency_name , label ) : [EOL] grouped = df . groupby ( [string] ) [EOL] throughput = grouped [ [string] ] . mean ( ) . sort_index ( ) [EOL] latency = grouped [ latency_name ] . mean ( ) . sort_index ( ) [EOL] ax . plot ( throughput , latency , [string] , label = label , linewidth = [number] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def main ( args ) : [EOL] df = add_num_clients ( pd . read_csv ( args . results ) ) [EOL] [EOL] [comment] [EOL] df [ [string] ] = df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] [EOL] df [ [string] ] = df [ [string] ] [EOL] [EOL] [comment] [EOL] num_plots = [number] [EOL] fig , ax = plt . subplots ( num_plots , [number] , figsize = ( [number] , num_plots * [number] ) ) [EOL] for alpha in df [ [string] ] . unique ( ) : [EOL] plot_latency_throughput ( df [ df [ [string] ] == alpha ] , ax [ [number] ] , [string] , f' [string] { alpha }' ) [EOL] plot_latency_throughput ( df [ df [ [string] ] == alpha ] , ax [ [number] ] , [string] , f' [string] { alpha }' ) [EOL] [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] ax [ [number] ] . set_ylabel ( [string] ) [EOL] for a in ax : [EOL] a . set_title ( [string] ) [EOL] a . set_xlabel ( [string] ) [EOL] a . legend ( loc = [string] ) [EOL] a . grid ( ) [EOL] fig . savefig ( args . output , bbox_inches = [string] ) [EOL] print ( f' [string] { args . output } [string] ' ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Iterator , List , Any , Dict , Type [EOL] import argparse [EOL] import benchmark [EOL] import builtins [EOL] import proc [EOL] import benchmarks [EOL] import typing [EOL] import proto_util [EOL] import host [EOL] import cluster [EOL] import VanillaMenciusNet [EOL] import paramiko [EOL] import datetime [EOL] from . . import benchmark [EOL] from . . import cluster [EOL] from . . import host [EOL] from . . import parser_util [EOL] from . . import pd_util [EOL] from . . import perf_util [EOL] from . . import proc [EOL] from . . import prometheus [EOL] from . . import proto_util [EOL] from . . import util [EOL] from . . import workload [EOL] from typing import Any , Callable , Collection , Dict , List , NamedTuple , Optional [EOL] import argparse [EOL] import csv [EOL] import datetime [EOL] import enum [EOL] import enum [EOL] import itertools [EOL] import os [EOL] import pandas as pd [EOL] import paramiko [EOL] import subprocess [EOL] import time [EOL] import tqdm [EOL] import yaml [EOL] [EOL] [EOL] [comment] [EOL] class ClientOptions ( NamedTuple ) : [EOL] resend_client_request_period = datetime . timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] class HeartbeatOptions ( NamedTuple ) : [EOL] fail_period = datetime . timedelta ( seconds = [number] ) [EOL] success_period = datetime . timedelta ( seconds = [number] ) [EOL] num_retries = [number] [EOL] network_delay_alpha = [number] [EOL] [EOL] [EOL] class ServerOptions ( NamedTuple ) : [EOL] beta = [number] [EOL] resend_phase1as_period = datetime . timedelta ( seconds = [number] ) [EOL] flush_skip_slots_period = datetime . timedelta ( milliseconds = [number] ) [EOL] revoke_min_period = datetime . timedelta ( seconds = [number] ) [EOL] revoke_max_period = datetime . timedelta ( seconds = [number] ) [EOL] log_grow_size = [number] [EOL] heartbeat_options = HeartbeatOptions ( ) [EOL] [EOL] [EOL] class Input ( NamedTuple ) : [EOL] [comment] [EOL] f = ... [EOL] num_client_procs = ... [EOL] num_warmup_clients_per_proc = ... [EOL] num_clients_per_proc = ... [EOL] num_servers = ... [EOL] client_jvm_heap_size = ... [EOL] server_jvm_heap_size = ... [EOL] [EOL] [comment] [EOL] measurement_group_size = ... [EOL] warmup_duration = ... [EOL] warmup_timeout = ... [EOL] warmup_sleep = ... [EOL] duration = ... [EOL] timeout = ... [EOL] client_lag = ... [EOL] state_machine = ... [EOL] workload = ... [EOL] profiled = ... [EOL] monitored = ... [EOL] prometheus_scrape_interval = ... [EOL] [EOL] [comment] [EOL] server_options = ... [EOL] server_log_level = ... [EOL] [EOL] [comment] [EOL] client_options = ... [EOL] client_log_level = ... [EOL] [EOL] [EOL] class VanillaMenciusOutput ( NamedTuple ) : [EOL] output = ... [EOL] [EOL] [EOL] Output = VanillaMenciusOutput [EOL] [EOL] [EOL] [comment] [EOL] class VanillaMenciusNet : [EOL] def __init__ ( self , cluster , input ) : [EOL] self . _cluster = cluster . f ( input . f ) [EOL] self . _input = input [EOL] [EOL] class Placement ( NamedTuple ) : [EOL] clients = ... [EOL] servers = ... [EOL] heartbeats = ... [EOL] [EOL] def placement ( self ) : [EOL] ports = itertools . count ( [number] , [number] ) [EOL] [EOL] def portify ( hosts ) : [EOL] return [ host . Endpoint ( h , next ( ports ) ) for h in hosts ] [EOL] [EOL] def cycle_take_n ( n , hosts ) : [EOL] return list ( itertools . islice ( itertools . cycle ( hosts ) , n ) ) [EOL] [EOL] return self . Placement ( clients = portify ( cycle_take_n ( self . _input . num_client_procs , self . _cluster [ [string] ] ) ) , servers = portify ( cycle_take_n ( self . _input . num_servers , self . _cluster [ [string] ] ) ) , heartbeats = portify ( cycle_take_n ( self . _input . num_servers , self . _cluster [ [string] ] ) ) , ) [EOL] [EOL] def config ( self ) : [EOL] return { [string] : self . _input . f , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . servers ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . heartbeats ] , } [EOL] [EOL] [EOL] [comment] [EOL] class VanillaMenciusSuite ( benchmark . Suite [ Input , Output ] ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _cluster = cluster . Cluster . from_json_file ( self . args ( ) [ [string] ] , self . _connect ) [EOL] [EOL] def _connect ( self , address ) : [EOL] client = paramiko . SSHClient ( ) [EOL] client . set_missing_host_key_policy ( paramiko . client . AutoAddPolicy ) [EOL] if self . args ( ) [ [string] ] : [EOL] client . connect ( address , key_filename = self . args ( ) [ [string] ] ) [EOL] else : [EOL] client . connect ( address ) [EOL] return host . RemoteHost ( client ) [EOL] [EOL] def run_benchmark ( self , bench , args , input ) : [EOL] def java ( heap_size ) : [EOL] cmd = [ [string] , f' [string] { heap_size }' , f' [string] { heap_size }' ] [EOL] if input . monitored : [EOL] cmd += [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] return cmd [EOL] [EOL] [comment] [EOL] net = VanillaMenciusNet ( self . _cluster , input ) [EOL] config = net . config ( ) [EOL] config_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( config_filename , proto_util . message_to_pbtext ( config ) ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] server_procs = [ ] [EOL] for ( i , server ) in enumerate ( net . placement ( ) . servers ) : [EOL] p = bench . popen ( host = server . host , label = f' [string] { i }' , cmd = java ( input . server_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . server_log_level , [string] , input . state_machine , [string] , server . host . ip ( ) , [string] , str ( server . port + [number] ) if input . monitored else [string] , [string] , str ( input . server_options . beta ) , [string] , [string] . format ( input . server_options . resend_phase1as_period . total_seconds ( ) ) , [string] , [string] . format ( input . server_options . flush_skip_slots_period . total_seconds ( ) ) , [string] , [string] . format ( input . server_options . revoke_min_period . total_seconds ( ) ) , [string] , [string] . format ( input . server_options . revoke_max_period . total_seconds ( ) ) , [string] , str ( input . server_options . log_grow_size ) , [string] , [string] . format ( input . server_options . heartbeat_options . fail_period . total_seconds ( ) ) , [string] , [string] . format ( input . server_options . heartbeat_options . success_period . total_seconds ( ) ) , [string] , str ( input . server_options . heartbeat_options . num_retries ) , [string] , str ( input . server_options . heartbeat_options . network_delay_alpha ) , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , server . host , p , f' [string] { i }' ) [EOL] server_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] if input . monitored : [EOL] prometheus_config = prometheus . prometheus_config ( int ( input . prometheus_scrape_interval . total_seconds ( ) * [number] ) , { [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . clients ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . servers ] , } ) [EOL] bench . write_string ( [string] , yaml . dump ( prometheus_config ) ) [EOL] prometheus_server = bench . popen ( host = net . placement ( ) . clients [ [number] ] . host , label = [string] , cmd = [ [string] , f' [string] { bench . abspath ( [string] ) }' , f' [string] { bench . abspath ( [string] ) }' , ] , ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] time . sleep ( input . client_lag . total_seconds ( ) ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] workload_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( workload_filename , proto_util . message_to_pbtext ( input . workload . to_proto ( ) ) ) [EOL] [EOL] client_procs = [ ] [EOL] for ( i , client ) in enumerate ( net . placement ( ) . clients ) : [EOL] p = bench . popen ( host = client . host , label = f' [string] { i }' , cmd = java ( input . client_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , client . host . ip ( ) , [string] , str ( client . port ) , [string] , config_filename , [string] , input . client_log_level , [string] , client . host . ip ( ) , [string] , str ( client . port + [number] ) if input . monitored else [string] , [string] , f'{ input . measurement_group_size }' , [string] , f'{ input . warmup_duration . total_seconds ( ) } [string] ' , [string] , f'{ input . warmup_timeout . total_seconds ( ) } [string] ' , [string] , f'{ input . warmup_sleep . total_seconds ( ) } [string] ' , [string] , f'{ input . num_warmup_clients_per_proc }' , [string] , f'{ input . duration . total_seconds ( ) } [string] ' , [string] , f'{ input . timeout . total_seconds ( ) } [string] ' , [string] , f'{ input . num_clients_per_proc }' , [string] , bench . abspath ( f' [string] { i }' ) , [string] , f'{ workload_filename }' , [string] , [string] . format ( input . client_options . resend_client_request_period . total_seconds ( ) ) , ] ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , client . host , p , f' [string] { i }' ) [EOL] client_procs . append ( p ) [EOL] bench . log ( f' [string] { input . duration } [string] ' ) [EOL] [EOL] [comment] [EOL] for p in client_procs : [EOL] p . wait ( ) [EOL] for p in server_procs : [EOL] p . kill ( ) [EOL] if input . monitored : [EOL] prometheus_server . kill ( ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] client_csvs = [ bench . abspath ( f' [string] { i } [string] ' ) for i in range ( input . num_client_procs ) ] [EOL] [EOL] labeled_data = benchmark . parse_labeled_recorder_data ( bench , client_csvs , drop_prefix = datetime . timedelta ( seconds = [number] ) , save_data = False ) [EOL] output = labeled_data [ [string] ] [EOL] return VanillaMenciusOutput ( output = output ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] return parser_util . get_benchmark_parser ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $HeartbeatOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $builtins.str$ 0 0 0 $Input.workload.Workload$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 $ServerOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ClientOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $benchmark.RecorderOutput$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $cluster.Cluster$ 0 $Input$ 0 0 0 0 0 0 0 $cluster.Cluster$ 0 0 0 $Input$ 0 0 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.Input$ 0 $Input$ 0 0 0 0 0 0 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 0 0 $VanillaMenciusNet.Placement$ 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[host.Endpoint]$ 0 $typing.List[host.Host]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[host.Host]$ 0 0 0 0 $typing.List[host.Host]$ 0 $builtins.int$ 0 $typing.List[host.Host]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[host.Host]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $host.Host$ 0 0 0 $builtins.str$ 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 $Output$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $Input$ 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 0 0 0 0 0 0 $Input$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $benchmarks.proc.Proc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.vanillamencius.vanillamencius.VanillaMenciusNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $typing.List[proc.Proc]$ 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $typing.List[proc.Proc]$ 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.proc.Proc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.benchmark.RecorderOutput$ 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 0 0 0 0 0 $benchmarks.benchmark.RecorderOutput$ 0 $benchmarks.benchmark.RecorderOutput$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0
	0
	0
import typing [EOL] from typing import Collection [EOL] import builtins [EOL] import benchmarks [EOL] from . multipaxos import * [EOL] [EOL] [EOL] def rf ( num_writers , num_clients ) : [EOL] return int ( ( [number] - ( num_writers / num_clients ) ) * [number] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] class E4ScaleReplicaMultiPaxosSuite ( MultiPaxosSuite ) : [EOL] def args ( self ) : [EOL] return vars ( args ) [EOL] [EOL] def inputs ( self ) : [EOL] return ( [ Input ( f = [number] , num_client_procs = num_client_procs , num_warmup_clients_per_proc = num_clients_per_proc , num_clients_per_proc = num_clients_per_proc , num_batchers = [number] , num_read_batchers = [number] , num_leaders = [number] , num_proxy_leaders = num_proxy_leaders , num_acceptor_groups = num_acceptor_groups , num_replicas = num_replicas , num_proxy_replicas = [number] , distribution_scheme = DistributionScheme . HASH , client_jvm_heap_size = [string] , batcher_jvm_heap_size = [string] , read_batcher_jvm_heap_size = [string] , leader_jvm_heap_size = [string] , proxy_leader_jvm_heap_size = [string] , acceptor_jvm_heap_size = [string] , replica_jvm_heap_size = [string] , proxy_replica_jvm_heap_size = [string] , measurement_group_size = measurement_group_size , warmup_duration = datetime . timedelta ( seconds = [number] ) , warmup_timeout = datetime . timedelta ( seconds = [number] ) , warmup_sleep = datetime . timedelta ( seconds = [number] ) , duration = datetime . timedelta ( seconds = [number] ) , timeout = datetime . timedelta ( seconds = [number] ) , client_lag = datetime . timedelta ( seconds = [number] ) , state_machine = [string] , predetermined_read_fraction = predetermined_read_fraction , workload_label = workload_label , workload = read_write_workload . UniformReadWriteWorkload ( num_keys = [number] , read_fraction = [number] , write_size_mean = [number] , write_size_std = [number] ) , read_workload = read_write_workload . UniformReadWriteWorkload ( num_keys = [number] , read_fraction = [number] , write_size_mean = [number] , write_size_std = [number] ) , write_workload = read_write_workload . UniformReadWriteWorkload ( num_keys = [number] , read_fraction = [number] , write_size_mean = [number] , write_size_std = [number] ) , read_consistency = [string] , profiled = args . profile , monitored = args . monitor , prometheus_scrape_interval = datetime . timedelta ( milliseconds = [number] ) , batcher_options = BatcherOptions ( ) , batcher_log_level = args . log_level , read_batcher_options = ReadBatcherOptions ( ) , read_batcher_log_level = args . log_level , leader_options = LeaderOptions ( resend_phase1as_period = datetime . timedelta ( seconds = [number] ) , flush_phase2as_every_n = [number] , noop_flush_period = noop_flush_period , election_options = ElectionOptions ( ping_period = datetime . timedelta ( seconds = [number] ) , no_ping_timeout_min = datetime . timedelta ( seconds = [number] ) , no_ping_timeout_max = datetime . timedelta ( seconds = [number] ) , ) , ) , leader_log_level = args . log_level , proxy_leader_options = ProxyLeaderOptions ( ) , proxy_leader_log_level = args . log_level , acceptor_options = AcceptorOptions ( ) , acceptor_log_level = args . log_level , replica_options = ReplicaOptions ( log_grow_size = [number] , unsafe_dont_use_client_table = False , send_chosen_watermark_every_n_entries = [number] , recover_log_entry_min_period = datetime . timedelta ( seconds = [number] ) , recover_log_entry_max_period = datetime . timedelta ( seconds = [number] ) , unsafe_dont_recover = False , ) , replica_log_level = args . log_level , proxy_replica_options = ProxyReplicaOptions ( batch_flush = True , ) , proxy_replica_log_level = args . log_level , client_options = ClientOptions ( resend_client_request_period = datetime . timedelta ( seconds = [number] ) , resend_max_slot_requests_period = datetime . timedelta ( seconds = [number] ) , resend_read_request_period = datetime . timedelta ( seconds = [number] ) , resend_sequential_read_request_period = datetime . timedelta ( seconds = [number] ) , resend_eventual_read_request_period = datetime . timedelta ( seconds = [number] ) , unsafe_read_at_first_slot = False , unsafe_read_at_i = False , flush_writes_every_n = [number] , flush_reads_every_n = [number] , ) , client_log_level = args . log_level , ) for ( label , predetermined_read_fraction , num_replicas , num_client_procs , num_clients_per_proc ) in [ ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] * [number] ) , [number] , [number] * [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] ) , [number] , [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] ) , [number] , [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] ) , [number] , [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] ) , [number] , [number] , [number] ) , ( [string] , rf ( [number] , [number] * [number] ) , [number] , [number] , [number] ) , ] for workload_label in [ label ] for num_proxy_leaders in [ [number] ] for num_acceptor_groups in [ [number] ] for noop_flush_period in [ datetime . timedelta ( milliseconds = [number] ) ] for measurement_group_size in [ [number] ] ] * [number] ) [ : ] [EOL] [EOL] def summary ( self , input , output ) : [EOL] return str ( { [string] : input . workload_label , [string] : input . predetermined_read_fraction , [string] : input . num_replicas , [string] : input . num_client_procs , [string] : input . num_clients_per_proc , [string] : f'{ output . write_output . latency . median_ms : [string] }' , [string] : f'{ output . write_output . start_throughput_1s . p90 : [string] }' , [string] : f'{ output . read_output . latency . median_ms : [string] }' , [string] : f'{ output . read_output . start_throughput_1s . p90 : [string] }' , } ) [EOL] [EOL] suite = E4ScaleReplicaMultiPaxosSuite ( ) [EOL] with benchmark . SuiteDirectory ( args . suite_directory , [string] ) as dir : [EOL] suite . run_suite ( dir ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( get_parser ( ) . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Collection[Input]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 $Output$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 $Input$ 0 0 0 0 0 $Input$ 0 0 0 0 0 $Input$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 $Output$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Output$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Output$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Output$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Iterator , List , Any , Dict , Type [EOL] import argparse [EOL] import benchmark [EOL] import proc [EOL] import builtins [EOL] import benchmarks [EOL] import typing [EOL] import proto_util [EOL] import host [EOL] import MultiPaxosNet [EOL] import cluster [EOL] import paramiko [EOL] import datetime [EOL] from . . import benchmark [EOL] from . . import cluster [EOL] from . . import host [EOL] from . . import parser_util [EOL] from . . import pd_util [EOL] from . . import perf_util [EOL] from . . import proc [EOL] from . . import prometheus [EOL] from . . import proto_util [EOL] from . . import read_write_workload [EOL] from . . import util [EOL] from typing import Any , Callable , Collection , Dict , List , NamedTuple , Optional [EOL] import argparse [EOL] import csv [EOL] import datetime [EOL] import enum [EOL] import enum [EOL] import itertools [EOL] import os [EOL] import pandas as pd [EOL] import paramiko [EOL] import subprocess [EOL] import time [EOL] import tqdm [EOL] import yaml [EOL] [EOL] [EOL] [comment] [EOL] class DistributionScheme ( enum . Enum ) : [EOL] HASH = [string] [EOL] COLOCATED = [string] [EOL] [EOL] [EOL] class ClientOptions ( NamedTuple ) : [EOL] resend_client_request_period = datetime . timedelta ( seconds = [number] ) [EOL] resend_max_slot_requests_period = datetime . timedelta ( seconds = [number] ) [EOL] resend_read_request_period = datetime . timedelta ( seconds = [number] ) [EOL] resend_sequential_read_request_period = datetime . timedelta ( seconds = [number] ) [EOL] resend_eventual_read_request_period = datetime . timedelta ( seconds = [number] ) [EOL] unsafe_read_at_first_slot = False [EOL] unsafe_read_at_i = False [EOL] flush_writes_every_n = [number] [EOL] flush_reads_every_n = [number] [EOL] [EOL] [EOL] class BatcherOptions ( NamedTuple ) : [EOL] batch_size = [number] [EOL] [EOL] [EOL] class ReadBatcherOptions ( NamedTuple ) : [EOL] read_batching_scheme = [string] [EOL] unsafe_read_at_first_slot = False [EOL] unsafe_read_at_i = False [EOL] [EOL] [EOL] class ElectionOptions ( NamedTuple ) : [EOL] ping_period = datetime . timedelta ( seconds = [number] ) [EOL] no_ping_timeout_min = datetime . timedelta ( seconds = [number] ) [EOL] no_ping_timeout_max = datetime . timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] class LeaderOptions ( NamedTuple ) : [EOL] resend_phase1as_period = datetime . timedelta ( seconds = [number] ) [EOL] flush_phase2as_every_n = [number] [EOL] noop_flush_period = datetime . timedelta ( seconds = [number] ) [EOL] election_options = ElectionOptions ( ) [EOL] [EOL] [EOL] class ProxyLeaderOptions ( NamedTuple ) : [EOL] flush_phase2as_every_n = [number] [EOL] [EOL] [EOL] class AcceptorOptions ( NamedTuple ) : [EOL] pass [EOL] [EOL] [EOL] class ReplicaOptions ( NamedTuple ) : [EOL] log_grow_size = [number] [EOL] unsafe_dont_use_client_table = False [EOL] send_chosen_watermark_every_n_entries = [number] [EOL] recover_log_entry_min_period = datetime . timedelta ( seconds = [number] ) [EOL] recover_log_entry_max_period = datetime . timedelta ( seconds = [number] ) [EOL] unsafe_dont_recover = False [EOL] [EOL] [EOL] class ProxyReplicaOptions ( NamedTuple ) : [EOL] flush_every_n = [number] [EOL] batch_flush = False [EOL] [EOL] [EOL] class Input ( NamedTuple ) : [EOL] [comment] [EOL] f = ... [EOL] num_client_procs = ... [EOL] num_warmup_clients_per_proc = ... [EOL] num_clients_per_proc = ... [EOL] num_batchers = ... [EOL] num_read_batchers = ... [EOL] num_leaders = ... [EOL] num_proxy_leaders = ... [EOL] num_acceptor_groups = ... [EOL] num_replicas = ... [EOL] num_proxy_replicas = ... [EOL] distribution_scheme = ... [EOL] client_jvm_heap_size = ... [EOL] batcher_jvm_heap_size = ... [EOL] read_batcher_jvm_heap_size = ... [EOL] leader_jvm_heap_size = ... [EOL] proxy_leader_jvm_heap_size = ... [EOL] acceptor_jvm_heap_size = ... [EOL] replica_jvm_heap_size = ... [EOL] proxy_replica_jvm_heap_size = ... [EOL] [EOL] [comment] [EOL] measurement_group_size = ... [EOL] warmup_duration = ... [EOL] warmup_timeout = ... [EOL] warmup_sleep = ... [EOL] duration = ... [EOL] timeout = ... [EOL] client_lag = ... [EOL] state_machine = ... [EOL] predetermined_read_fraction = ... [EOL] workload_label = ... [EOL] workload = ... [EOL] read_workload = ... [EOL] write_workload = ... [EOL] read_consistency = ... [comment] [EOL] profiled = ... [EOL] monitored = ... [EOL] prometheus_scrape_interval = ... [EOL] [EOL] [comment] [EOL] batcher_options = ... [EOL] batcher_log_level = ... [EOL] [EOL] [comment] [EOL] read_batcher_options = ... [EOL] read_batcher_log_level = ... [EOL] [EOL] [comment] [EOL] leader_options = ... [EOL] leader_log_level = ... [EOL] [EOL] [comment] [EOL] proxy_leader_options = ... [EOL] proxy_leader_log_level = ... [EOL] [EOL] [comment] [EOL] acceptor_options = ... [EOL] acceptor_log_level = ... [EOL] [EOL] [comment] [EOL] replica_options = ... [EOL] replica_log_level = ... [EOL] [EOL] [comment] [EOL] proxy_replica_options = ... [EOL] proxy_replica_log_level = ... [EOL] [EOL] [comment] [EOL] client_options = ... [EOL] client_log_level = ... [EOL] [EOL] [EOL] class MultiPaxosOutput ( NamedTuple ) : [EOL] read_output = ... [EOL] write_output = ... [EOL] [EOL] [EOL] Output = MultiPaxosOutput [EOL] [EOL] [EOL] [comment] [EOL] class MultiPaxosNet : [EOL] def __init__ ( self , cluster , input ) : [EOL] self . _cluster = cluster . f ( input . f ) [EOL] self . _input = input [EOL] [EOL] class Placement ( NamedTuple ) : [EOL] clients = ... [EOL] batchers = ... [EOL] read_batchers = ... [EOL] leaders = ... [EOL] leader_elections = ... [EOL] proxy_leaders = ... [EOL] acceptors = ... [EOL] replicas = ... [EOL] proxy_replicas = ... [EOL] [EOL] def placement ( self ) : [EOL] ports = itertools . count ( [number] , [number] ) [EOL] [EOL] def portify ( hosts ) : [EOL] return [ host . Endpoint ( h , next ( ports ) ) for h in hosts ] [EOL] [EOL] def cycle_take_n ( n , hosts ) : [EOL] return list ( itertools . islice ( itertools . cycle ( hosts ) , n ) ) [EOL] [EOL] def chunks ( xs , n ) : [EOL] [comment] [EOL] result = [ ] [EOL] for i in range ( [number] , len ( xs ) , n ) : [EOL] result . append ( xs [ i : i + n ] ) [EOL] return result [EOL] [EOL] n = [number] * self . _input . f + [number] [EOL] return self . Placement ( clients = portify ( cycle_take_n ( self . _input . num_client_procs , self . _cluster [ [string] ] ) ) , batchers = portify ( cycle_take_n ( self . _input . num_batchers , self . _cluster [ [string] ] ) ) , read_batchers = portify ( cycle_take_n ( self . _input . num_read_batchers , self . _cluster [ [string] ] ) ) , leaders = portify ( cycle_take_n ( self . _input . num_leaders , self . _cluster [ [string] ] ) ) , leader_elections = portify ( cycle_take_n ( self . _input . num_leaders , self . _cluster [ [string] ] ) ) , proxy_leaders = portify ( cycle_take_n ( self . _input . num_proxy_leaders , self . _cluster [ [string] ] ) ) , acceptors = chunks ( portify ( cycle_take_n ( self . _input . num_acceptor_groups * n , self . _cluster [ [string] ] ) ) , n ) , replicas = portify ( cycle_take_n ( self . _input . num_replicas , self . _cluster [ [string] ] ) ) , proxy_replicas = portify ( cycle_take_n ( self . _input . num_proxy_replicas , self . _cluster [ [string] ] ) ) , ) [EOL] [EOL] def config ( self ) : [EOL] return { [string] : self . _input . f , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . batchers ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . read_batchers ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . leaders ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . leader_elections ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . proxy_leaders ] , [string] : [ { [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in group ] } for group in self . placement ( ) . acceptors ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . replicas ] , [string] : [ { [string] : e . host . ip ( ) , [string] : e . port } for e in self . placement ( ) . proxy_replicas ] , [string] : self . _input . distribution_scheme , } [EOL] [EOL] [EOL] [comment] [EOL] class MultiPaxosSuite ( benchmark . Suite [ Input , Output ] ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _cluster = cluster . Cluster . from_json_file ( self . args ( ) [ [string] ] , self . _connect ) [EOL] [EOL] def _connect ( self , address ) : [EOL] client = paramiko . SSHClient ( ) [EOL] client . set_missing_host_key_policy ( paramiko . client . AutoAddPolicy ) [EOL] if self . args ( ) [ [string] ] : [EOL] client . connect ( address , key_filename = self . args ( ) [ [string] ] ) [EOL] else : [EOL] client . connect ( address ) [EOL] return host . RemoteHost ( client ) [EOL] [EOL] def run_benchmark ( self , bench , args , input ) : [EOL] def java ( heap_size ) : [EOL] cmd = [ [string] , f' [string] { heap_size }' , f' [string] { heap_size }' ] [EOL] if input . monitored : [EOL] cmd += [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] return cmd [EOL] [EOL] [comment] [EOL] net = MultiPaxosNet ( self . _cluster , input ) [EOL] config = net . config ( ) [EOL] config_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( config_filename , proto_util . message_to_pbtext ( config ) ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] acceptor_procs = [ ] [EOL] for ( group_index , group ) in enumerate ( net . placement ( ) . acceptors ) : [EOL] for ( i , acceptor ) in enumerate ( group ) : [EOL] p = bench . popen ( host = acceptor . host , label = f' [string] { group_index } [string] { i }' , cmd = java ( input . acceptor_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( group_index ) , [string] , str ( i ) , [string] , config_filename , [string] , input . acceptor_log_level , [string] , acceptor . host . ip ( ) , [string] , str ( acceptor . port + [number] ) if input . monitored else [string] , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , acceptor . host , p , f' [string] { group_index } [string] { i }' ) [EOL] acceptor_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] batcher_procs = [ ] [EOL] for ( i , batcher ) in enumerate ( net . placement ( ) . batchers ) : [EOL] p = bench . popen ( host = batcher . host , label = f' [string] { i }' , cmd = java ( input . batcher_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . batcher_log_level , [string] , batcher . host . ip ( ) , [string] , str ( batcher . port + [number] ) if input . monitored else [string] , [string] , str ( input . batcher_options . batch_size ) , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , batcher . host , p , f' [string] { i }' ) [EOL] batcher_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] read_batcher_procs = [ ] [EOL] for ( i , read_batcher ) in enumerate ( net . placement ( ) . read_batchers ) : [EOL] p = bench . popen ( host = read_batcher . host , label = f' [string] { i }' , cmd = java ( input . read_batcher_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . read_batcher_log_level , [string] , read_batcher . host . ip ( ) , [string] , str ( read_batcher . port + [number] ) if input . monitored else [string] , [string] , f'{ input . read_batcher_options . read_batching_scheme }' , [string] , f'{ input . read_batcher_options . unsafe_read_at_first_slot }' , [string] , f'{ input . read_batcher_options . unsafe_read_at_i }' , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , read_batcher . host , p , f' [string] { i }' ) [EOL] read_batcher_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] proxy_leader_procs = [ ] [EOL] for ( i , proxy_leader ) in enumerate ( net . placement ( ) . proxy_leaders ) : [EOL] p = bench . popen ( host = proxy_leader . host , label = f' [string] { i }' , cmd = java ( input . proxy_leader_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . proxy_leader_log_level , [string] , proxy_leader . host . ip ( ) , [string] , str ( proxy_leader . port + [number] ) if input . monitored else [string] , [string] , str ( input . proxy_leader_options . flush_phase2as_every_n ) , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , proxy_leader . host , p , f' [string] { i }' ) [EOL] proxy_leader_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] replica_procs = [ ] [EOL] for ( i , replica ) in enumerate ( net . placement ( ) . replicas ) : [EOL] p = bench . popen ( host = replica . host , label = f' [string] { i }' , cmd = java ( input . replica_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . replica_log_level , [string] , input . state_machine , [string] , replica . host . ip ( ) , [string] , str ( replica . port + [number] ) if input . monitored else [string] , [string] , str ( input . replica_options . log_grow_size ) , [string] , str ( input . replica_options . unsafe_dont_use_client_table ) , [string] , str ( input . replica_options . send_chosen_watermark_every_n_entries ) , [string] , [string] . format ( input . replica_options . recover_log_entry_min_period . total_seconds ( ) ) , [string] , [string] . format ( input . replica_options . recover_log_entry_max_period . total_seconds ( ) ) , [string] , str ( input . replica_options . unsafe_dont_recover ) , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , replica . host , p , f' [string] { i }' ) [EOL] replica_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] proxy_replica_procs = [ ] [EOL] for ( i , proxy_replica ) in enumerate ( net . placement ( ) . proxy_replicas ) : [EOL] p = bench . popen ( host = proxy_replica . host , label = f' [string] { i }' , cmd = java ( input . proxy_replica_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . proxy_replica_log_level , [string] , proxy_replica . host . ip ( ) , [string] , str ( proxy_replica . port + [number] ) if input . monitored else [string] , [string] , str ( input . proxy_replica_options . flush_every_n ) , [string] , str ( input . proxy_replica_options . batch_flush ) , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , proxy_replica . host , p , f' [string] { i }' ) [EOL] proxy_replica_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] leader_procs = [ ] [EOL] for ( i , leader ) in enumerate ( net . placement ( ) . leaders ) : [EOL] p = bench . popen ( host = leader . host , label = f' [string] { i }' , cmd = java ( input . leader_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , str ( i ) , [string] , config_filename , [string] , input . leader_log_level , [string] , leader . host . ip ( ) , [string] , str ( leader . port + [number] ) if input . monitored else [string] , [string] , [string] . format ( input . leader_options . resend_phase1as_period . total_seconds ( ) ) , [string] , str ( input . leader_options . flush_phase2as_every_n ) , [string] , [string] . format ( input . leader_options . noop_flush_period . total_seconds ( ) ) , [string] , [string] . format ( input . leader_options . election_options . ping_period . total_seconds ( ) ) , [string] , [string] . format ( input . leader_options . election_options . no_ping_timeout_min . total_seconds ( ) ) , [string] , [string] . format ( input . leader_options . election_options . no_ping_timeout_max . total_seconds ( ) ) , ] , ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , leader . host , p , f' [string] { i }' ) [EOL] leader_procs . append ( p ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] if input . monitored : [EOL] prometheus_config = prometheus . prometheus_config ( int ( input . prometheus_scrape_interval . total_seconds ( ) * [number] ) , { [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . clients ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . batchers ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . read_batchers ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . leaders ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . proxy_leaders ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for group in net . placement ( ) . acceptors for e in group ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . replicas ] , [string] : [ f'{ e . host . ip ( ) } [string] { e . port + [number] }' for e in net . placement ( ) . proxy_replicas ] , } ) [EOL] bench . write_string ( [string] , yaml . dump ( prometheus_config ) ) [EOL] prometheus_server = bench . popen ( host = net . placement ( ) . clients [ [number] ] . host , label = [string] , cmd = [ [string] , f' [string] { bench . abspath ( [string] ) }' , f' [string] { bench . abspath ( [string] ) }' , ] , ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] time . sleep ( input . client_lag . total_seconds ( ) ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] workload_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( workload_filename , proto_util . message_to_pbtext ( input . workload . to_proto ( ) ) ) [EOL] read_workload_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( read_workload_filename , proto_util . message_to_pbtext ( input . read_workload . to_proto ( ) ) ) [EOL] write_workload_filename = bench . abspath ( [string] ) [EOL] bench . write_string ( write_workload_filename , proto_util . message_to_pbtext ( input . write_workload . to_proto ( ) ) ) [EOL] [EOL] client_procs = [ ] [EOL] for ( i , client ) in enumerate ( net . placement ( ) . clients ) : [EOL] p = bench . popen ( host = client . host , label = f' [string] { i }' , cmd = java ( input . client_jvm_heap_size ) + [ [string] , os . path . abspath ( args [ [string] ] ) , [string] , [string] , client . host . ip ( ) , [string] , str ( client . port ) , [string] , config_filename , [string] , input . client_log_level , [string] , client . host . ip ( ) , [string] , str ( client . port + [number] ) if input . monitored else [string] , [string] , f'{ input . measurement_group_size }' , [string] , f'{ input . warmup_duration . total_seconds ( ) } [string] ' , [string] , f'{ input . warmup_timeout . total_seconds ( ) } [string] ' , [string] , f'{ input . warmup_sleep . total_seconds ( ) } [string] ' , [string] , f'{ input . num_warmup_clients_per_proc }' , [string] , f'{ input . duration . total_seconds ( ) } [string] ' , [string] , f'{ input . timeout . total_seconds ( ) } [string] ' , [string] , f'{ input . num_clients_per_proc }' , [string] , bench . abspath ( f' [string] { i }' ) , [string] , f'{ input . read_consistency }' , [string] , f'{ input . predetermined_read_fraction }' , [string] , f'{ workload_filename }' , [string] , f'{ read_workload_filename }' , [string] , f'{ write_workload_filename }' , [string] , [string] . format ( input . client_options . resend_client_request_period . total_seconds ( ) ) , [string] , [string] . format ( input . client_options . resend_max_slot_requests_period . total_seconds ( ) ) , [string] , [string] . format ( input . client_options . resend_read_request_period . total_seconds ( ) ) , [string] , [string] . format ( input . client_options . resend_sequential_read_request_period . total_seconds ( ) ) , [string] , [string] . format ( input . client_options . resend_eventual_read_request_period . total_seconds ( ) ) , [string] , f'{ input . client_options . unsafe_read_at_first_slot }' , [string] , f'{ input . client_options . unsafe_read_at_i }' , [string] , f'{ input . client_options . flush_writes_every_n }' , [string] , f'{ input . client_options . flush_reads_every_n }' , ] ) [EOL] if input . profiled : [EOL] p = perf_util . JavaPerfProc ( bench , client . host , p , f' [string] { i }' ) [EOL] client_procs . append ( p ) [EOL] bench . log ( f' [string] { input . duration } [string] ' ) [EOL] [EOL] [comment] [EOL] for p in client_procs : [EOL] p . wait ( ) [EOL] for p in ( batcher_procs + read_batcher_procs + leader_procs + proxy_leader_procs + acceptor_procs + replica_procs + proxy_replica_procs ) : [EOL] p . kill ( ) [EOL] if input . monitored : [EOL] prometheus_server . kill ( ) [EOL] bench . log ( [string] ) [EOL] [EOL] [comment] [EOL] client_csvs = [ bench . abspath ( f' [string] { i } [string] ' ) for i in range ( input . num_client_procs ) ] [EOL] [EOL] dummy_latency = benchmark . LatencyOutput ( mean_ms = - [number] , median_ms = - [number] , min_ms = - [number] , max_ms = - [number] , p90_ms = - [number] , p95_ms = - [number] , p99_ms = - [number] , ) [EOL] dummy_throughput = benchmark . ThroughputOutput ( mean = - [number] , median = - [number] , min = - [number] , max = - [number] , p90 = - [number] , p95 = - [number] , p99 = - [number] , ) [EOL] dummy_output = benchmark . RecorderOutput ( latency = dummy_latency , start_throughput_1s = dummy_throughput , ) [EOL] [EOL] labeled_data = benchmark . parse_labeled_recorder_data ( bench , client_csvs , drop_prefix = datetime . timedelta ( seconds = [number] ) , save_data = False ) [EOL] read_output = ( labeled_data [ [string] ] [EOL] if [string] in labeled_data [EOL] else dummy_output ) [EOL] write_output = ( labeled_data [ [string] ] [EOL] if [string] in labeled_data [EOL] else dummy_output ) [EOL] return MultiPaxosOutput ( read_output = read_output , write_output = write_output ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] return parser_util . get_benchmark_parser ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $ElectionOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $DistributionScheme$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $read_write_workload.ReadWriteWorkload$ 0 0 0 $read_write_workload.ReadWriteWorkload$ 0 0 0 $read_write_workload.ReadWriteWorkload$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 $BatcherOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ReadBatcherOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $LeaderOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ProxyLeaderOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $AcceptorOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ReplicaOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ProxyReplicaOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ClientOptions$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $benchmark.RecorderOutput$ 0 0 0 $benchmark.RecorderOutput$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $cluster.Cluster$ 0 $Input$ 0 0 0 0 0 0 0 $cluster.Cluster$ 0 0 0 $Input$ 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.Input$ 0 $Input$ 0 0 0 0 0 0 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[typing.List[host.Endpoint]]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 $typing.List[host.Endpoint]$ 0 0 0 0 0 $MultiPaxosNet.Placement$ 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[host.Endpoint]$ 0 $typing.List[host.Host]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[host.Host]$ 0 0 0 0 $typing.List[host.Host]$ 0 $builtins.int$ 0 $typing.List[host.Host]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[host.Host]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $proto_util.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $host.Host$ 0 0 0 $builtins.str$ 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 $Output$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $Input$ 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 $Input$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $benchmarks.proc.Proc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 $builtins.str$ 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.multipaxos.multipaxos.MultiPaxosNet$ 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 0 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 $typing.List[proc.Proc]$ 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 $typing.List[proc.Proc]$ 0 $typing.List[proc.Proc]$ 0 $typing.List[proc.Proc]$ 0 $typing.List[proc.Proc]$ 0 $typing.List[proc.Proc]$ 0 $typing.List[proc.Proc]$ 0 $typing.List[proc.Proc]$ 0 0 0 $benchmarks.perf_util.JavaPerfProc$ 0 0 0 0 0 0 $Input$ 0 0 0 0 $benchmarks.proc.Proc$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $benchmark.BenchmarkDirectory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Input$ 0 0 0 0 0 0 $benchmarks.benchmark.LatencyOutput$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.benchmark.ThroughputOutput$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.benchmark.RecorderOutput$ 0 0 0 0 0 0 0 $benchmarks.benchmark.LatencyOutput$ 0 0 0 $benchmarks.benchmark.ThroughputOutput$ 0 0 0 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 0 0 0 $benchmark.BenchmarkDirectory$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $benchmarks.benchmark.RecorderOutput$ 0 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 $benchmarks.benchmark.RecorderOutput$ 0 0 $benchmarks.benchmark.RecorderOutput$ 0 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,benchmarks.benchmark.RecorderOutput]$ 0 0 $benchmarks.benchmark.RecorderOutput$ 0 0 0 0 0 $benchmarks.benchmark.RecorderOutput$ 0 $benchmarks.benchmark.RecorderOutput$ 0 $benchmarks.benchmark.RecorderOutput$ 0 $benchmarks.benchmark.RecorderOutput$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any , List [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] import pandas [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def avg_latency ( df ) : [EOL] return df [ [string] ] . agg ( np . mean ) [EOL] [EOL] [EOL] def std_latency ( df ) : [EOL] return df [ [string] ] . agg ( np . std ) [EOL] [EOL] [EOL] def avg_tput ( df ) : [EOL] return df [ [string] ] . agg ( np . mean ) [EOL] [EOL] [EOL] def std_tput ( df ) : [EOL] return df [ [string] ] . agg ( np . std ) [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def barchart ( output_filename , labels , data , yerr , color ) : [EOL] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] x_pos = range ( len ( data ) ) [EOL] ax . bar ( x_pos , data , yerr = yerr , align = [string] , capsize = [number] , color = color ) [EOL] ax . set_xticks ( x_pos ) [EOL] ax . set_xticklabels ( labels , rotation = - [number] , ha = [string] ) [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] unbatched_super_df = add_num_clients ( pd . read_csv ( args . unbatched_coupled_multipaxos_results ) ) [EOL] unbatched_df = add_num_clients ( pd . read_csv ( args . unbatched_multipaxos_results ) ) [EOL] batched_super_df = add_num_clients ( pd . read_csv ( args . batched_coupled_multipaxos_results ) ) [EOL] batched_df = add_num_clients ( pd . read_csv ( args . batched_multipaxos_results ) ) [EOL] [EOL] [comment] [EOL] unbatched_super_df = unbatched_super_df [ unbatched_super_df [ [string] ] == [number] ] [EOL] unbatched_df = unbatched_df [ unbatched_df [ [string] ] == [number] ] [EOL] batched_super_df = batched_super_df [ batched_super_df [ [string] ] == [number] ] [EOL] batched_df = batched_df [ batched_df [ [string] ] == [number] ] [EOL] [EOL] barchart ( output_filename = args . output_unbatched_throughput , labels = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , data = [ avg_tput ( unbatched_super_df ) , avg_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , avg_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , avg_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , avg_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , avg_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , avg_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , avg_tput ( unbatched_df [ ( unbatched_df [ [string] ] == [number] ) & ( unbatched_df [ [string] ] == [number] ) ] ) , avg_tput ( unbatched_df [ ( unbatched_df [ [string] ] == [number] ) & ( unbatched_df [ [string] ] == [number] ) ] ) , ] , yerr = [ std_tput ( unbatched_super_df ) , std_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , std_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , std_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , std_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , std_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , std_tput ( unbatched_df [ unbatched_df [ [string] ] == [number] ] ) , std_tput ( unbatched_df [ ( unbatched_df [ [string] ] == [number] ) & ( unbatched_df [ [string] ] == [number] ) ] ) , std_tput ( unbatched_df [ ( unbatched_df [ [string] ] == [number] ) & ( unbatched_df [ [string] ] == [number] ) ] ) , ] , color = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] barchart ( output_filename = args . output_batched_throughput , labels = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , data = [ avg_tput ( batched_super_df ) , avg_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , avg_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , avg_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , avg_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , avg_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , ] , yerr = [ std_tput ( batched_super_df ) , std_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , std_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , std_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , std_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , std_tput ( batched_df [ batched_df [ [string] ] == [number] ] ) , ] , color = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import argparse [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import matplotlib [EOL] import matplotlib [EOL] matplotlib . use ( [string] ) [EOL] font = { [string] : [number] } [EOL] matplotlib . rc ( [string] , ** font ) [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] import os [EOL] import pandas as pd [EOL] import re [EOL] [EOL] [EOL] def add_num_clients ( df ) : [EOL] df [ [string] ] = df [ [string] ] * df [ [string] ] [EOL] return df [EOL] [EOL] [EOL] def plot_latency_throughput ( df , ax , marker , label ) : [EOL] grouped = df . groupby ( [string] ) [EOL] throughput = grouped [ [string] ] . agg ( np . mean ) . sort_index ( ) [EOL] latency = grouped [ [string] ] . agg ( np . mean ) . sort_index ( ) [EOL] print ( throughput ) [EOL] print ( latency ) [EOL] ax . plot ( throughput / [number] , latency , marker , label = label , linewidth = [number] ) [EOL] [EOL] [EOL] def make_figure ( output_filename , coupled_df , mencius_df , unreplicated_df ) : [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] plot_latency_throughput ( coupled_df , ax , [string] , [string] ) [EOL] print ( [string] ) [EOL] plot_latency_throughput ( mencius_df , ax , [string] , [string] ) [EOL] print ( [string] ) [EOL] plot_latency_throughput ( unreplicated_df , ax , [string] , [string] ) [EOL] [EOL] ax . set_title ( [string] ) [EOL] ax . set_xlabel ( [string] ) [EOL] ax . set_ylabel ( [string] ) [EOL] ax . legend ( loc = [string] ) [EOL] ax . grid ( ) [EOL] fig . savefig ( output_filename , bbox_inches = [string] ) [EOL] print ( f' [string] { output_filename } [string] ' ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] unbatched_coupled_df = add_num_clients ( pd . read_csv ( args . unbatched_coupled_mencius_results ) ) [EOL] unbatched_mencius_df = add_num_clients ( pd . read_csv ( args . unbatched_mencius_results ) ) [EOL] unbatched_unreplicated_df = add_num_clients ( pd . read_csv ( args . unbatched_unreplicated_results ) ) [EOL] batched_coupled_df = add_num_clients ( pd . read_csv ( args . batched_coupled_mencius_results ) ) [EOL] batched_mencius_df = add_num_clients ( pd . read_csv ( args . batched_mencius_results ) ) [EOL] batched_unreplicated_df = add_num_clients ( pd . read_csv ( args . batched_unreplicated_results ) ) [EOL] [EOL] make_figure ( args . output_unbatched , unbatched_coupled_df , unbatched_mencius_df , unbatched_unreplicated_df , ) [EOL] [EOL] make_figure ( args . output_batched , batched_coupled_df , batched_mencius_df , batched_unreplicated_df , ) [EOL] [EOL] [EOL] def get_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = get_parser ( ) [EOL] main ( parser . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import socket [EOL] import time [EOL] [EOL] def main ( args ) : [EOL] with socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) as s : [EOL] s . connect ( ( args . host , args . port ) ) [EOL] durations_micros = [ ] [EOL] for _ in range ( args . n ) : [EOL] start = time . time ( ) [EOL] s . sendall ( [string] ) [EOL] s . recv ( [number] ) [EOL] stop = time . time ( ) [EOL] durations_micros . append ( ( stop - start ) * [number] * [number] ) [EOL] for d in durations_micros : [EOL] print ( d ) [EOL] [EOL] def arg_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] return parser [EOL] [EOL] if __name__ == [string] : [EOL] main ( arg_parser ( ) . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import argparse [EOL] import socket [EOL] import argparse [EOL] import socket [EOL] [EOL] def handle_client ( s ) : [EOL] while True : [EOL] data = s . recv ( [number] ) [EOL] if not data : [EOL] return [EOL] s . sendall ( data ) [EOL] [EOL] def main ( args ) : [EOL] with socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) as s : [EOL] s . bind ( ( args . host , args . port ) ) [EOL] s . listen ( ) [EOL] print ( f' [string] { args . host } [string] { args . port } [string] ' ) [EOL] [EOL] while True : [EOL] conn , addr = s . accept ( ) [EOL] print ( f' [string] { addr } [string] ' ) [EOL] with conn : [EOL] handle_client ( conn ) [EOL] [EOL] def arg_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] return parser [EOL] [EOL] if __name__ == [string] : [EOL] main ( arg_parser ( ) . parse_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0