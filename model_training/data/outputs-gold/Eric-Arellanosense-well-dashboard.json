from typing import List , Any [EOL] import typing [EOL] import src [EOL] import flask [EOL] import builtins [EOL] import json [EOL] from textwrap import dedent [EOL] from typing import List [EOL] [EOL] from flask import Flask , request , send_from_directory , abort [EOL] [EOL] from src import parser [EOL] from src . mock import mock_time_series [EOL] [EOL] app = Flask ( __name__ , static_folder = [string] , template_folder = [string] ) [EOL] app . url_map . strict_slashes = False [EOL] [EOL] [EOL] @ app . route ( [string] ) def render_react ( ) : [EOL] return send_from_directory ( [string] , [string] ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def render_react_asset ( path ) : [EOL] return send_from_directory ( [string] , path ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def api_test ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] ) def metric_summaries ( community ) : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] @ app . route ( [string] ) def time_series ( community ) : [EOL] result = mock_time_series [ [string] ] [EOL] return return_json ( result ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def time_series_post ( ) : [EOL] req_data = request . get_json ( ) [EOL] community_name = req_data [ [string] ] [ [string] ] [EOL] datapoints = req_data [ [string] ] [ [string] ] [EOL] day_aggregates = parser . parse_datapoint_set ( datapoints ) [EOL] [comment] [EOL] [comment] [EOL] return _generate_report ( community_name , day_aggregates ) [EOL] [EOL] [EOL] def _generate_report ( community_name , day_aggregates ) : [EOL] report = dedent ( f''' [string] { community_name } [string] ''' ) [EOL] for day in day_aggregates : [EOL] report += dedent ( f''' [string] { day [ [string] ] } [string] { day [ [string] ] / day [ [string] ] } [string] { day [ [string] ] } [string] { day [ [string] ] / day [ [string] ] } [string] { day [ [string] ] } [string] { day [ [string] ] / day [ [string] ] } [string] ''' ) [EOL] return dedent ( report ) [EOL] [EOL] [EOL] def return_json ( result ) : [EOL] if result is None : [EOL] abort ( [number] ) [EOL] else : [EOL] return json . dumps ( result ) , [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Dict [EOL] import typing [EOL] mock_time_series = { [string] : [string] , [string] : { [string] : [string] , [string] : [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [string] : [ [ [number] , [number] ] ] , [string] : [ [ [number] , [number] ] ] , [string] : { [string] : [number] , [string] : - [number] } } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.float],typing.List[typing.List[builtins.float]],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , List , Any , Dict [EOL] import typing [EOL] import pandas [EOL] from typing import List , Dict [EOL] [EOL] import pandas [EOL] import numpy [EOL] [EOL] Datapoint = Dict [ str , float ] [EOL] DailyConditions = Dict [ str , float ] [EOL] [EOL] [EOL] def parse_datapoint_set ( datapoints ) : [EOL] data_frame = _convert_to_pandas ( datapoints ) [EOL] grouped = _group_by_day ( data_frame ) [EOL] aggregated = _get_count_and_sum_per_day ( grouped ) [EOL] sorted_ = _round_and_sort ( aggregated ) [EOL] return _parse_into_daily_conditions ( sorted_ ) [EOL] [EOL] [EOL] def _convert_to_pandas ( datapoints ) : [EOL] raw_dates = [ d [ [string] ] for d in datapoints ] [EOL] dates = pandas . to_datetime ( raw_dates , unit = [string] ) [EOL] return pandas . DataFrame ( datapoints , index = dates , columns = [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def _group_by_day ( data_frame ) : [EOL] return data_frame . groupby ( pandas . Grouper ( freq = [string] ) ) [EOL] [EOL] [EOL] def _get_count_and_sum_per_day ( groups ) : [EOL] count = groups . count ( ) [EOL] count . columns = [ [string] , [string] , [string] ] [EOL] sum_ = groups . sum ( ) [EOL] sum_ . columns = [ [string] , [string] , [string] ] [EOL] return count . join ( sum_ , how = [string] ) [EOL] [EOL] [EOL] def _round_and_sort ( aggregated ) : [EOL] sorted_ = aggregated . sort_index ( axis = [number] ) [EOL] rounded = sorted_ . round ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] rounded [ [string] ] = rounded [ [string] ] . apply ( numpy . int ) [comment] [EOL] rounded [ [string] ] = rounded [ [string] ] . apply ( numpy . int ) [EOL] rounded [ [string] ] = rounded [ [string] ] . apply ( numpy . int ) [EOL] return rounded [EOL] [EOL] [EOL] def _parse_into_daily_conditions ( aggregated ) : [EOL] results = aggregated . to_dict ( orient = [string] ) [EOL] day_indexes = list ( results ) [EOL] daily_conditions = [ ] [EOL] for day in day_indexes : [EOL] day_values = results [ day ] [EOL] daily_condition = { [string] : day . date ( ) , [string] : day_values [ [string] ] , [string] : day_values [ [string] ] , [string] : day_values [ [string] ] , [string] : day_values [ [string] ] , [string] : day_values [ [string] ] , [string] : day_values [ [string] ] , } [EOL] daily_conditions . append ( daily_condition ) [EOL] return daily_conditions [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DailyConditions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Any , Dict [EOL] import typing [EOL] import unittest [EOL] [EOL] import numpy [EOL] [EOL] import src . parser as parser [EOL] [EOL] [EOL] class TestParser ( unittest . TestCase ) : [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . datapoints = [ { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] , [string] : [number] } ] [EOL] cls . data_frame = parser . _convert_to_pandas ( cls . datapoints ) [EOL] cls . group = parser . _group_by_day ( cls . data_frame ) [EOL] cls . aggregated = parser . _get_count_and_sum_per_day ( cls . group ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_convert_to_pandas ( self ) : [EOL] expected = { [string] : { [number] : [number] , [number] : [number] } , [string] : { [number] : [number] , [number] : [number] } , [string] : { [number] : [number] , [number] : numpy . NaN } , [string] : { [number] : [number] , [number] : numpy . NaN } } [EOL] data = self . datapoints [ : [number] ] [EOL] result = parser . _convert_to_pandas ( data ) [EOL] self . assertDictEqual ( result . to_dict ( ) , expected ) [EOL] [EOL] def test_split_days ( self ) : [EOL] result = parser . _group_by_day ( self . data_frame ) . count ( ) [EOL] day1 = result . loc [ [string] ] [EOL] day2 = result . loc [ [string] ] [EOL] self . assertEqual ( len ( result ) , [number] ) [EOL] self . assertEqual ( day1 [ [string] ] . item ( ) , [number] ) [EOL] self . assertEqual ( day2 [ [string] ] . item ( ) , [number] ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_get_count_and_sum_by_day ( self ) : [EOL] result = parser . _get_count_and_sum_per_day ( self . group ) [EOL] [EOL] def test_parse_into_daily_conditions ( self ) : [EOL] result = parser . _parse_into_daily_conditions ( self . aggregated ) [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,unknown]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
	0
	0
[comment] [EOL] [EOL] import scripts [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] [comment] [EOL] sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . realpath ( __file__ ) ) ) ) [EOL] [EOL] from scripts . utils import venv , sys_calls , command_line_args [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = command_line_args . create_parser ( command_map ) [EOL] args = parser . parse_args ( ) [EOL] check_prereqs_installed ( ) [EOL] command_line_args . execute_command ( args , command_map ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def check_prereqs_installed ( ) : [EOL] [docstring] [EOL] command_line_args . check_prereqs_installed ( ) [EOL] sys_calls . check_prereqs_installed ( ) [EOL] venv . check_prereqs_installed ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def check_types ( ) : [EOL] [docstring] [EOL] venv . activate ( ) [EOL] sys_calls . run ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def test ( ) : [EOL] [docstring] [EOL] sys_calls . run_python ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] command_map = command_line_args . CommandMap ( { [string] : test , [string] : check_types , } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $scripts.utils.command_line_args.CommandMap$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $scripts.utils.command_line_args.CommandMap$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $scripts.utils.command_line_args.CommandMap$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] import os [EOL] import sys [EOL] [EOL] [comment] [EOL] sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . realpath ( __file__ ) ) ) ) [EOL] [EOL] from scripts . utils import heroku , git [EOL] [EOL] [EOL] def main ( ) : [EOL] check_prereqs_installed ( ) [EOL] check_remote_added ( ) [EOL] check_logged_in ( ) [EOL] resolve_git_issues ( ) [EOL] deploy ( ) [EOL] [EOL] [EOL] def check_prereqs_installed ( ) : [EOL] [docstring] [EOL] heroku . check_prereqs_installed ( ) [EOL] git . check_prereqs_installed ( ) [EOL] [EOL] [EOL] def check_remote_added ( ) : [EOL] [docstring] [EOL] if not git . is_remote_added ( [string] ) : [EOL] git . add_remote ( [string] , [string] ) [EOL] [EOL] [EOL] def check_logged_in ( ) : [EOL] [docstring] [EOL] if not heroku . is_logged_in ( ) : [EOL] raise SystemExit ( [string] [string] ) [EOL] [EOL] [EOL] def resolve_git_issues ( ) : [EOL] [docstring] [EOL] if not git . is_on_branch ( [string] ) : [EOL] git . checkout ( [string] ) [EOL] if not git . is_clean_local ( ) : [EOL] raise SystemExit ( [string] ) [EOL] git . fast_forward ( [string] , [string] ) [EOL] git . fast_forward ( [string] , [string] ) [EOL] [EOL] [EOL] def deploy ( ) : [EOL] [docstring] [EOL] git . push ( [string] , [string] ) [EOL] git . push ( [string] , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , List , Any , Dict , Literal [EOL] import subprocess [EOL] import typing [EOL] import typing_extensions [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] import subprocess [EOL] from typing import Dict , List , Tuple , Union [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def check_prereqs_installed ( ) : [EOL] [docstring] [EOL] pass [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def is_windows_environment ( ) : [EOL] [docstring] [EOL] return os . name == [string] [EOL] [EOL] [EOL] def determine_python_executable ( ) : [EOL] [docstring] [EOL] if is_windows_environment ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] Command = Union [ List [ str ] , str ] [EOL] [EOL] [EOL] def _modify_for_windows ( command , kwargs ) : [EOL] [docstring] [EOL] if is_windows_environment ( ) : [EOL] windows_command = [string] . join ( command ) [EOL] windows_kwargs = dict ( kwargs , shell = True ) [EOL] return windows_command , windows_kwargs [EOL] return command , kwargs [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def run ( command , ** kwargs ) : [EOL] [docstring] [EOL] new_command , new_kwargs = _modify_for_windows ( command , kwargs ) [EOL] return subprocess . run ( new_command , ** new_kwargs ) [EOL] [EOL] [EOL] def run_detached ( command , ** kwargs ) : [EOL] [docstring] [EOL] new_command , new_kwargs = _modify_for_windows ( command , kwargs ) [EOL] subprocess . Popen ( new_command , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , ** new_kwargs ) [EOL] [EOL] [EOL] def run_as_shell ( command , ** kwargs ) : [EOL] [docstring] [EOL] return subprocess . run ( command , shell = True , ** kwargs ) [EOL] [EOL] [EOL] def run_python ( command , ** kwargs ) : [EOL] [docstring] [EOL] python = determine_python_executable ( ) [EOL] new_command , new_kwargs = _modify_for_windows ( [ python ] + command , kwargs ) [EOL] return subprocess . run ( new_command , ** new_kwargs ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def get_stdout ( command , ** kwargs ) : [EOL] [docstring] [EOL] new_command , new_kwargs = _modify_for_windows ( command , kwargs ) [EOL] return subprocess . run ( new_command , stdout = subprocess . PIPE , encoding = [string] , ** new_kwargs ) . stdout . strip ( ) [EOL] [EOL] [EOL] def get_stdout_as_shell ( command , ** kwargs ) : [EOL] [docstring] [EOL] return subprocess . run ( command , shell = True , stdout = subprocess . PIPE , encoding = [string] , ** kwargs ) . stdout . strip ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Command,typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Any [EOL] import subprocess [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] import subprocess [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] from scripts . utils import sys_calls [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def check_prereqs_installed ( ) : [EOL] [docstring] [EOL] sys_calls . check_prereqs_installed ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] File = str [EOL] [EOL] [EOL] def do_exist ( files ) : [EOL] [docstring] [EOL] return all ( Path ( file ) . exists ( ) for file in files ) [EOL] [EOL] [EOL] def remove ( files ) : [EOL] [docstring] [EOL] sys_calls . run ( [ [string] , [string] ] + files ) [EOL] [EOL] [EOL] def source ( * , file , path ) : [EOL] [docstring] [EOL] if sys_calls . is_windows_environment ( ) : [EOL] command = [ [string] , [string] , f'{ file } [string] ' ] [EOL] else : [EOL] command = [ [string] , [string] , f' [string] { file } [string] ' ] [EOL] process = subprocess . Popen ( command , stdout = subprocess . PIPE , cwd = path ) [EOL] for line in process . stdout : [EOL] ( key , _ , value ) = line . decode ( [string] ) . strip ( ) . partition ( [string] ) [EOL] os . environ [ key ] = value [EOL] process . communicate ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Dict [EOL] import typing [EOL] import argparse [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import argparse [EOL] from typing import Callable , Dict , NewType [EOL] [EOL] CommandMap = NewType ( [string] , Dict [ str , Callable [ ... , None ] ] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def check_prereqs_installed ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def create_parser ( command_map , * , accept_target_environment = False ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = __doc__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter ) [EOL] parser . add_argument ( [string] , default = [string] , nargs = [string] , choices = command_map . keys ( ) ) [EOL] parser . add_argument ( [string] , default = [string] , nargs = [string] , help = [string] ) [EOL] if accept_target_environment : [EOL] parser . add_argument ( [string] , [string] , default = [string] , nargs = [string] , choices = [ [string] , [string] , [string] , [string] ] ) [EOL] return parser [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def execute_command ( args , command_map ) : [EOL] [docstring] [EOL] func = command_map [ args . command ] [EOL] [comment] [EOL] passed_arguments = vars ( args ) [EOL] [comment] [EOL] additional_arguments = { k : v for k , v in passed_arguments . items ( ) if v } [EOL] [comment] [EOL] del additional_arguments [ [string] ] [EOL] [comment] [EOL] func ( ** additional_arguments ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0