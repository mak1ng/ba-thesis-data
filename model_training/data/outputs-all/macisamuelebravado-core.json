[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from six import iteritems [EOL] [EOL] [EOL] def test_security_definition_property_extraction ( security_dict , security_spec ) : [EOL] security_definitions = security_dict [ [string] ] [EOL] for security_name , security_spec_dict in iteritems ( security_definitions ) : [EOL] security_object = security_spec . security_definitions [ security_name ] [EOL] for key , value in iteritems ( security_spec_dict ) : [EOL] assert getattr ( security_object , key if key != [string] else [string] ) == value [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [ { [string] : [ ] } , { [string] : [ ] } ] ) , ( [string] , [string] , [ { [string] : [ ] } ] ) , ( [string] , [string] , [ { [string] : [ ] , [string] : [ ] } , { [string] : [ ] } ] ) , ( [string] , [string] , [ { [string] : [ [string] ] } ] ) , ( [string] , [string] , [ ] ) , ] , ) def test_security_scopes ( security_spec , resource , operation , expected_scopes ) : [EOL] def _get_operation ( ) : [EOL] return security_spec . resources [ resource ] . operations [ operation ] [EOL] [EOL] assert [ security_requirement . security_scopes for security_requirement in _get_operation ( ) . security_requirements ] == expected_scopes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import mock [EOL] import os [EOL] from copy import deepcopy [EOL] from itertools import chain [EOL] [EOL] import pytest [EOL] import simplejson as json [EOL] import yaml [EOL] from mock import Mock [EOL] from six import iteritems [EOL] from six import iterkeys [EOL] from six . moves . urllib import parse as urlparse [EOL] from six . moves . urllib . request import pathname2url [EOL] from six . moves . urllib . request import url2pathname [EOL] from swagger_spec_validator . common import SwaggerValidationWarning [EOL] [EOL] from bravado_core . spec import CONFIG_DEFAULTS [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] @ pytest . fixture def mock_spec ( ) : [EOL] m = Mock ( spec = Spec ) [EOL] m . config = deepcopy ( CONFIG_DEFAULTS ) [EOL] return m [EOL] [EOL] [EOL] @ pytest . fixture def empty_swagger_spec ( ) : [EOL] return Spec ( spec_dict = { } ) [EOL] [EOL] [EOL] def _read_json ( json_path ) : [EOL] with open ( json_path ) as f : [EOL] return json . loads ( f . read ( ) ) [EOL] [EOL] [EOL] def _read_yaml ( json_path ) : [EOL] with open ( json_path ) as f : [EOL] return yaml . safe_load ( f ) [EOL] [EOL] [EOL] def get_url ( absolute_path ) : [EOL] return urlparse . urljoin ( [string] , pathname2url ( absolute_path ) ) [EOL] [EOL] [EOL] def get_url_path ( absolute_url ) : [EOL] return url2pathname ( urlparse . urlparse ( absolute_url ) . path ) [EOL] [EOL] [EOL] @ pytest . fixture def my_dir ( ) : [EOL] return os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] @ pytest . fixture def minimal_swagger_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def minimal_swagger_dict ( minimal_swagger_abspath ) : [EOL] [docstring] [EOL] return _read_json ( minimal_swagger_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def minimal_swagger_spec ( minimal_swagger_dict , minimal_swagger_abspath ) : [EOL] return Spec . from_dict ( minimal_swagger_dict , origin_url = get_url ( minimal_swagger_abspath ) ) [EOL] [EOL] [EOL] @ pytest . fixture def composition_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def composition_dict ( composition_abspath ) : [EOL] return _read_json ( composition_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ { [string] : True } , { [string] : False } , ] , ) def composition_spec ( request , composition_dict , composition_abspath ) : [EOL] return Spec . from_dict ( composition_dict , origin_url = get_url ( composition_abspath ) , config = request . param ) [EOL] [EOL] [EOL] @ pytest . fixture def multi_file_recursive_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def multi_file_recursive_dict ( multi_file_recursive_abspath ) : [EOL] return _read_yaml ( multi_file_recursive_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def multi_file_recursive_spec ( multi_file_recursive_dict , multi_file_recursive_abspath ) : [EOL] return Spec . from_dict ( multi_file_recursive_dict , origin_url = get_url ( multi_file_recursive_abspath ) ) [EOL] [EOL] [EOL] @ pytest . fixture def flattened_multi_file_recursive_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def flattened_multi_file_recursive_dict ( flattened_multi_file_recursive_abspath ) : [EOL] return _read_json ( flattened_multi_file_recursive_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def petstore_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def petstore_dict ( petstore_abspath ) : [EOL] return _read_json ( petstore_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def petstore_spec ( petstore_dict , petstore_abspath ) : [EOL] return Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] [EOL] [EOL] @ pytest . fixture def getPetByIdPetstoreOperation ( petstore_spec ) : [EOL] return petstore_spec . resources [ [string] ] . operations [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def polymorphic_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def polymorphic_dict ( polymorphic_abspath ) : [EOL] return _read_json ( polymorphic_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def polymorphic_spec ( polymorphic_dict ) : [EOL] return Spec . from_dict ( polymorphic_dict ) [EOL] [EOL] [EOL] @ pytest . fixture def security_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def security_dict ( security_abspath ) : [EOL] return _read_json ( security_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def security_spec ( security_dict ) : [EOL] return Spec . from_dict ( security_dict ) [EOL] [EOL] [EOL] @ pytest . fixture def multi_file_with_no_xmodel_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def multi_file_with_no_xmodel_dict ( multi_file_with_no_xmodel_abspath ) : [EOL] return _read_json ( multi_file_with_no_xmodel_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def multi_file_with_no_xmodel_spec ( multi_file_with_no_xmodel_dict , multi_file_with_no_xmodel_abspath ) : [EOL] return Spec . from_dict ( multi_file_with_no_xmodel_dict , origin_url = get_url ( multi_file_with_no_xmodel_abspath ) ) [EOL] [EOL] [EOL] @ pytest . fixture def flattened_multi_file_with_no_xmodel_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def flattened_multi_file_with_no_xmodel_dict ( flattened_multi_file_with_no_xmodel_abspath ) : [EOL] return _read_json ( flattened_multi_file_with_no_xmodel_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def simple_crossfer_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def simple_crossfer_dict ( simple_crossfer_abspath ) : [EOL] return _read_json ( simple_crossfer_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def simple_crossfer_spec ( simple_crossfer_dict , simple_crossfer_abspath ) : [EOL] return Spec . from_dict ( simple_crossfer_dict , origin_url = get_url ( simple_crossfer_abspath ) ) [EOL] [EOL] [EOL] @ pytest . fixture def specs_with_none_in_ref_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def specs_with_none_in_ref_dict ( specs_with_none_in_ref_abspath ) : [EOL] return _read_json ( specs_with_none_in_ref_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def specs_with_none_in_ref_spec ( specs_with_none_in_ref_dict , specs_with_none_in_ref_abspath ) : [EOL] with pytest . warns ( SwaggerValidationWarning ) : [EOL] return Spec . from_dict ( specs_with_none_in_ref_dict , origin_url = get_url ( specs_with_none_in_ref_abspath ) ) [EOL] [EOL] [EOL] @ pytest . fixture def flattened_specs_with_none_in_ref_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def flattened_specs_with_none_in_ref_dict ( flattened_specs_with_none_in_ref_abspath ) : [EOL] return _read_json ( flattened_specs_with_none_in_ref_abspath ) [EOL] [EOL] [EOL] @ pytest . fixture def node_spec ( ) : [EOL] [docstring] [EOL] return { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } , [string] : [ [string] ] , } [EOL] [EOL] [EOL] @ pytest . fixture def recursive_swagger_spec ( minimal_swagger_dict , node_spec ) : [EOL] [docstring] [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = node_spec [EOL] return Spec ( minimal_swagger_dict ) [EOL] [EOL] [EOL] def check_object_deepcopy ( obj ) : [EOL] [docstring] [EOL] [EOL] obj_copy = deepcopy ( obj ) [EOL] [EOL] assert isinstance ( obj_copy , obj . __class__ ) [EOL] assert obj . is_equal ( obj_copy ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert id ( obj ) != id ( obj_copy ) [EOL] attributes_with_same_id = { attr_name : getattr ( obj_copy , attr_name , None ) for attr_name in set ( chain ( iterkeys ( obj . __dict__ ) , iterkeys ( obj_copy . __dict__ ) , ) , ) if id ( getattr ( obj , attr_name , None ) ) == id ( getattr ( obj_copy , attr_name , None ) ) } [EOL] assert not any ( not isinstance ( attr_value , ( type ( None ) , str , tuple ) ) for attr_name , attr_value in iteritems ( attributes_with_same_id ) ) [EOL] [EOL] return obj_copy [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from bravado_core . schema import collapsed_properties [EOL] [EOL] [EOL] def test_simple ( user_type , user_kwargs ) : [EOL] user = user_type ( ** user_kwargs ) [EOL] assert user . firstName == [string] [EOL] assert user . userStatus == [number] [EOL] assert user . id == [number] [EOL] assert user . lastName is None [EOL] assert user . email is None [EOL] assert user . password is None [EOL] [EOL] [EOL] def test_init_from_dict ( user_type , user_kwargs ) : [EOL] user = user_type . _from_dict ( user_kwargs ) [EOL] assert user . firstName == [string] [EOL] assert user . userStatus == [number] [EOL] assert user . id == [number] [EOL] assert user . lastName is None [EOL] assert user . email is None [EOL] assert user . password is None [EOL] [EOL] [EOL] def test_empty_kwargs ( user_type ) : [EOL] user = user_type ( ) [EOL] assert user . firstName is None [EOL] assert user . userStatus is None [EOL] assert user . id is None [EOL] assert user . lastName is None [EOL] assert user . email is None [EOL] assert user . password is None [EOL] [EOL] [EOL] def test_additionalProperties_defaults_to_true_when_not_present ( user_type , user_kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] user_kwargs [ [string] ] = [string] [EOL] user = user_type ( ** user_kwargs ) [EOL] assert user . foo == [string] [EOL] assert [string] in dir ( user ) [EOL] [EOL] [EOL] def test_additionalProperties_true ( definitions_spec , user_type , user_kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] user_type . _model_spec [ [string] ] = True [EOL] user_kwargs [ [string] ] = [string] [comment] [EOL] user = user_type ( ** user_kwargs ) [EOL] assert user . foo == [string] [EOL] assert [string] in dir ( user ) [EOL] assert set ( user ) == set ( definitions_spec [ [string] ] [ [string] ] . keys ( ) ) . union ( { [string] } ) [EOL] [EOL] [EOL] def test_additionalProperties_false ( user_type , user_kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] user_type . _model_spec [ [string] ] = False [EOL] user_kwargs [ [string] ] = [string] [comment] [EOL] with pytest . raises ( AttributeError ) as excinfo : [EOL] user_type ( ** user_kwargs ) [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] def test_allOf ( cat_swagger_spec , cat_type , cat_kwargs ) : [EOL] cat = cat_type ( ** cat_kwargs ) [EOL] assert cat . id == [number] [EOL] assert cat . category == { [string] : [number] , [string] : [string] } [EOL] assert cat . name == [string] [EOL] assert cat . photoUrls == [ [string] , [string] ] [EOL] assert cat . tags == [ { [string] : [number] , [string] : [string] } ] [EOL] assert cat . neutered is True [EOL] assert set ( cat ) == set ( collapsed_properties ( cat_swagger_spec . spec_dict [ [string] ] [ [string] ] , cat_swagger_spec , ) . keys ( ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] import six [EOL] [EOL] [EOL] def test_success ( user ) : [EOL] expected = [string] [comment] [EOL] assert expected == repr ( user ) [EOL] [EOL] [EOL] def test_allOf ( cat , cat_spec , cat_swagger_spec ) : [EOL] expected = [string] [comment] [EOL] assert expected == repr ( cat ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( six . PY3 , reason = [string] ) def test_unicode_py2 ( user ) : [EOL] user . firstName = [string] [EOL] expected = [string] [comment] [EOL] assert expected == repr ( user ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( six . PY2 , reason = [string] ) def test_unicode_py3 ( user ) : [EOL] user . firstName = [string] [EOL] expected = [string] [comment] [EOL] assert expected == repr ( user ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [EOL] def test_true ( user ) : [EOL] assert user == user [EOL] [EOL] [EOL] def test_false ( user , tag_model ) : [EOL] assert not user == tag_model [EOL] [EOL] [EOL] def test_false_because_not_model ( user ) : [EOL] string = [string] [EOL] assert user != string [EOL] assert string != user [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] import pytest [EOL] from six import iteritems [EOL] [EOL] SECURITY_DEFINITIONS = { [string] : { [string] : { [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , } , } , } [EOL] SECURITY_OBJECTS = { [string] : [ { [string] : [ ] } ] , [string] : [ { [string] : [ ] } ] , [string] : [ { [string] : [ ] } ] , } [EOL] [EOL] [EOL] @ pytest . fixture def definitions_spec ( ) : [EOL] return { [string] : { [string] : [string] , [string] : [ [string] ] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , } , } [EOL] [EOL] [EOL] @ pytest . fixture def _paths_spec ( ) : [EOL] [comment] [EOL] return { [string] : { [string] : { [string] : [ [string] , ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : { [string] : [string] , } , [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , } , } , } , [string] : { [string] : [string] , } , } , } , } , } [EOL] [EOL] [EOL] @ pytest . fixture ( params = SECURITY_OBJECTS . keys ( ) , ) def specs_with_security_obj_in_op_and_security_specs ( request , _paths_spec , definitions_spec , ) : [EOL] security_object = SECURITY_OBJECTS [ request . param ] [EOL] [EOL] for path , path_item in iteritems ( _paths_spec ) : [EOL] for http_method in path_item . keys ( ) : [EOL] path_item [ http_method ] [ [string] ] = security_object [EOL] [EOL] return { [string] : _paths_spec , [string] : definitions_spec , [string] : SECURITY_DEFINITIONS [ request . param ] , } [EOL] [EOL] [EOL] @ pytest . fixture def specs_with_security_obj_in_op_and_no_security_specs ( specs_with_security_obj_in_op_and_security_specs , ) : [EOL] del specs_with_security_obj_in_op_and_security_specs [ [string] ] [EOL] return specs_with_security_obj_in_op_and_security_specs [EOL] [EOL] [EOL] @ pytest . fixture ( params = SECURITY_OBJECTS . keys ( ) , ) def specs_with_security_obj_in_root_and_security_specs ( request , _paths_spec , definitions_spec , ) : [EOL] return { [string] : _paths_spec , [string] : definitions_spec , [string] : SECURITY_OBJECTS [ request . param ] , [string] : SECURITY_DEFINITIONS [ request . param ] , } [EOL] [EOL] [EOL] @ pytest . fixture def specs_with_security_obj_in_root_and_no_security_specs ( specs_with_security_obj_in_root_and_security_specs , ) : [EOL] del specs_with_security_obj_in_root_and_security_specs [ [string] ] [comment] [EOL] return specs_with_security_obj_in_root_and_security_specs [EOL] [EOL] [EOL] @ pytest . fixture def specs_with_security_obj_in_root_and_empty_security_spec ( specs_with_security_obj_in_root_and_security_specs , ) : [EOL] path_spec = specs_with_security_obj_in_root_and_security_specs [ [string] ] [EOL] for path , path_item in iteritems ( path_spec ) : [EOL] for http_method in path_item . keys ( ) : [EOL] path_item [ http_method ] [ [string] ] = [ ] [EOL] [EOL] return specs_with_security_obj_in_root_and_security_specs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] __author__ = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import mock [EOL] import pytest [EOL] from mock import Mock [EOL] from six import iteritems [EOL] [EOL] from bravado_core . exception import SwaggerSchemaError [EOL] from bravado_core . exception import SwaggerSecurityValidationError [EOL] from bravado_core . request import IncomingRequest [EOL] from bravado_core . request import unmarshal_request [EOL] from bravado_core . resource import build_resources [EOL] from bravado_core . spec import Spec [EOL] from tests . operation . conftest import SECURITY_DEFINITIONS [EOL] from tests . operation . conftest import SECURITY_OBJECTS [EOL] [EOL] [EOL] def test_security_object_and_definition_constants ( ) : [EOL] [docstring] [EOL] assert SECURITY_OBJECTS . keys ( ) == SECURITY_DEFINITIONS . keys ( ) [EOL] [EOL] [EOL] def test_op_with_security_in_op_without_security_defs ( specs_with_security_obj_in_op_and_no_security_specs ) : [EOL] with pytest . raises ( SwaggerSchemaError ) : [EOL] build_resources ( Spec ( specs_with_security_obj_in_op_and_no_security_specs , ) , ) [EOL] [EOL] [EOL] def test_op_with_security_in_root_without_security_defs ( specs_with_security_obj_in_root_and_no_security_specs ) : [EOL] with pytest . raises ( SwaggerSchemaError ) : [EOL] build_resources ( Spec ( specs_with_security_obj_in_root_and_no_security_specs , ) , ) [EOL] [EOL] [EOL] def _validate_resources ( resources , security_definitions_spec ) : [EOL] resource = resources . get ( [string] ) [EOL] assert resource is not None [EOL] for security_option , security_obj in iteritems ( security_definitions_spec ) : [EOL] operation = getattr ( resource , [string] ) [EOL] assert operation is not None [EOL] assert len ( operation . security_requirements ) == len ( security_definitions_spec ) [EOL] assert operation . security_requirements [ [number] ] . security_definitions [EOL] if security_option == [string] : [EOL] assert len ( operation . params ) == [number] [EOL] assert security_obj [ [string] ] in operation . params [EOL] assert len ( operation . security_parameters ) == [number] [EOL] else : [EOL] assert len ( operation . params ) == [number] [EOL] assert len ( operation . security_parameters ) == [number] [EOL] [EOL] [EOL] def test_op_with_security_in_op_with_security_defs ( specs_with_security_obj_in_op_and_security_specs ) : [EOL] security_definitions_spec = specs_with_security_obj_in_op_and_security_specs [ [string] ] [EOL] _validate_resources ( resources = build_resources ( Spec ( specs_with_security_obj_in_op_and_security_specs , ) , ) , security_definitions_spec = security_definitions_spec , ) [EOL] [EOL] [EOL] def test_op_with_security_in_root_with_security_defs ( specs_with_security_obj_in_root_and_security_specs ) : [EOL] security_definitions_spec = specs_with_security_obj_in_root_and_security_specs [ [string] ] [comment] [EOL] _validate_resources ( resources = build_resources ( Spec ( specs_with_security_obj_in_root_and_security_specs , ) , ) , security_definitions_spec = security_definitions_spec , ) [EOL] [EOL] [EOL] def test_op_with_security_in_root_with_empty_security_spec ( specs_with_security_obj_in_root_and_empty_security_spec ) : [EOL] resources = build_resources ( Spec ( specs_with_security_obj_in_root_and_empty_security_spec , ) , ) [EOL] [EOL] resource = resources . get ( [string] ) [EOL] assert resource is not None [EOL] [EOL] operation = getattr ( resource , [string] ) [EOL] assert operation is not None [EOL] assert len ( operation . security_requirements ) == [number] [EOL] [EOL] [EOL] def test_correct_request_with_apiKey_security ( getPetByIdPetstoreOperation ) : [EOL] request = Mock ( spec = IncomingRequest , path = { [string] : [string] } , headers = { [string] : [string] } , ) [EOL] unmarshal_request ( request , getPetByIdPetstoreOperation ) [EOL] [EOL] [EOL] def test_wrong_request_with_apiKey_security ( getPetByIdPetstoreOperation ) : [EOL] request = Mock ( spec = IncomingRequest , path = { [string] : [string] } , headers = { } , ) [EOL] with pytest . raises ( SwaggerSecurityValidationError ) : [EOL] unmarshal_request ( request , getPetByIdPetstoreOperation ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , ( ( [string] , ) , ( [string] , ) ) ) , ( [string] , [string] , ( ( [string] , ) , ) ) , ( [string] , [string] , ( ( [string] , [string] , ) , ( [string] , ) ) ) , ( [string] , [string] , ( ( [string] , ) , ) ) , ( [string] , [string] , ( ) ) , ] , ) def test_security_parameters_selection ( security_spec , resource , operation , expected_combinations ) : [EOL] op = security_spec . resources [ resource ] . operations [ operation ] [EOL] assert set ( map ( tuple , op . acceptable_security_definition_combinations ) ) == set ( expected_combinations ) [EOL] [EOL] [EOL] def test_security_parameter_cannot_override_path_or_operation_parameter ( security_dict ) : [EOL] security_dict [ [string] ] [ [string] ] [ [string] ] [ [string] ] = [ { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] with pytest . raises ( SwaggerSchemaError ) : [EOL] Spec . from_dict ( security_dict ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , { } , { [string] : [string] } , False ) , ( [string] , [string] , { } , { [string] : [string] , [string] : [string] } , True ) , ( [string] , [string] , { [string] : [string] } , { } , False ) , ( [string] , [string] , { } , { } , True ) , ( [string] , [string] , { } , { [string] : [string] } , True ) , ( [string] , [string] , { } , { [string] : [string] , [string] : [string] } , False ) , ( [string] , [string] , { [string] : [string] } , { } , False ) , ( [string] , [string] , { } , { [string] : [string] } , True ) , ( [string] , [string] , { [string] : [string] } , { [string] : [string] , [string] : [string] } , True ) , ] , ) def test_only_one_security_definition_in_use_at_time ( security_spec , resource , operation , query , headers , expect_to_raise , ) : [EOL] request = Mock ( spec = IncomingRequest , headers = headers , query = query , ) [EOL] [EOL] op = security_spec . resources [ resource ] . operations [ operation ] [EOL] raised_exception = None [EOL] try : [EOL] unmarshal_request ( request , op ) [EOL] except SwaggerSecurityValidationError as e : [EOL] raised_exception = e [EOL] [EOL] assert bool ( raised_exception is not None ) is expect_to_raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from bravado_core . spec import Spec [EOL] from tests . conftest import get_url [EOL] [EOL] [EOL] def test_equality_of_the_same_object_returns_True ( getPetByIdPetstoreOperation ) : [EOL] assert getPetByIdPetstoreOperation . is_equal ( getPetByIdPetstoreOperation ) [EOL] [EOL] [EOL] def test_equality_of_different_instances_returns_True_if_the_specs_are_the_same ( getPetByIdPetstoreOperation , petstore_dict , petstore_abspath , ) : [EOL] other_petstore_spec = Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] other_getPetByIdPetstoreOperation = other_petstore_spec . resources [ [string] ] . operations [ [string] ] [EOL] assert getPetByIdPetstoreOperation . is_equal ( other_getPetByIdPetstoreOperation ) [EOL] [EOL] [EOL] def test_equality_of_different_instances_returns_False_if_the_specs_are_the_different ( petstore_spec , getPetByIdPetstoreOperation ) : [EOL] assert not getPetByIdPetstoreOperation . is_equal ( petstore_spec . resources [ [string] ] . operations [ [string] ] ) [EOL] [EOL] [EOL] def test_equality_of_different_instances_returns_False_if_different_types ( getPetByIdPetstoreOperation ) : [EOL] assert not getPetByIdPetstoreOperation . is_equal ( None ) [EOL] [EOL] [EOL] def test_operation_hashability ( getPetByIdPetstoreOperation ) : [EOL] [comment] [EOL] [comment] [EOL] hash ( getPetByIdPetstoreOperation ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_equality_honors_ignore_swagger_spec_parameters ( getPetByIdPetstoreOperation , petstore_dict , petstore_abspath , ignore_swagger_spec , ) : [EOL] other_petstore_spec = Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] other_getPetByIdPetstoreOperation = other_petstore_spec . resources [ [string] ] . operations [ [string] ] [EOL] other_getPetByIdPetstoreOperation . swagger_spec = None [EOL] assert getPetByIdPetstoreOperation . is_equal ( other_getPetByIdPetstoreOperation , ignore_swagger_spec = ignore_swagger_spec , ) is ignore_swagger_spec [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] from bravado_core . operation import build_params [EOL] from bravado_core . operation import Operation [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] def test_no_params ( minimal_swagger_dict ) : [EOL] op_spec = { [string] : [string] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] [EOL] [EOL] def test_op_param_only ( minimal_swagger_dict ) : [EOL] op_spec = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] assert [string] in params [EOL] [EOL] [EOL] def test_path_param_only ( minimal_swagger_dict ) : [EOL] op_spec = { [string] : [string] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] assert [string] in params [EOL] [EOL] [EOL] def test_path_param_and_op_param ( minimal_swagger_dict ) : [EOL] op_spec = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , } , ] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , [string] : [ { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } , ] , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] assert [string] in params [EOL] assert [string] in params [EOL] [EOL] [EOL] def test_op_param_overrides_path_param ( minimal_swagger_dict ) : [EOL] [comment] [EOL] op_spec = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , } , ] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , [string] : [ { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } , ] , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] assert [string] in params [EOL] assert params [ [string] ] . required [EOL] [EOL] [EOL] def test_path_param_and_op_param_refs ( minimal_swagger_dict ) : [EOL] [comment] [EOL] [comment] [EOL] parameters = { [string] : { [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } , } [EOL] op_spec = { [string] : [string] , [string] : [ { [string] : [string] } , ] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , [string] : [ { [string] : [string] } , ] , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] minimal_swagger_dict [ [string] ] = parameters [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] assert [string] in params [EOL] assert [string] in params [EOL] [EOL] [EOL] def test_sanitized_param ( minimal_swagger_dict ) : [EOL] op_spec = { [string] : [string] , [string] : { [string] : { } , } , } [EOL] path_spec = { [string] : op_spec , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = path_spec [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] op = Operation ( swagger_spec , [string] , [string] , op_spec ) [EOL] params = build_params ( op ) [EOL] assert len ( params ) == [number] [EOL] assert [ p for p in params ] == [ [string] ] [EOL] assert [string] in params [EOL] assert params [ [string] ] is params [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] import datetime [EOL] [EOL] import pytest [EOL] from dateutil . tz import tzutc [EOL] [EOL] from bravado_core . exception import SwaggerMappingError [EOL] from bravado_core . spec import Spec [EOL] from bravado_core . unmarshal import unmarshal_model [EOL] [EOL] [EOL] @ pytest . fixture def pet_dict ( ) : [EOL] return { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : { [string] : [number] , [string] : [string] , } , [string] : [ { [string] : [number] , [string] : [string] , } , { [string] : [number] , [string] : [string] , } , ] , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , None , ) , ) def test_definitions_with_ref ( composition_spec , releaseDate ) : [EOL] PongClone = composition_spec . definitions [ [string] ] [EOL] pong_clone_spec = composition_spec . spec_dict [ [string] ] [ [string] ] [EOL] pong_clone_dict = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] if releaseDate : [EOL] pong_clone_dict [ [string] ] = releaseDate [EOL] [EOL] pong_clone = unmarshal_model ( composition_spec , pong_clone_spec , pong_clone_dict , ) [EOL] [EOL] assert isinstance ( pong_clone , PongClone ) [EOL] assert [string] == pong_clone . pang [EOL] assert [string] == pong_clone . additionalFeature [EOL] assert [string] == pong_clone . gameSystem [EOL] if releaseDate or composition_spec . config [ [string] ] : [EOL] assert hasattr ( pong_clone , [string] ) is True [EOL] assert releaseDate == pong_clone . releaseDate [EOL] else : [EOL] assert hasattr ( pong_clone , [string] ) is False [EOL] [EOL] [EOL] def test_pet ( petstore_dict , pet_dict ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] Pet = petstore_spec . definitions [ [string] ] [EOL] Category = petstore_spec . definitions [ [string] ] [EOL] Tag = petstore_spec . definitions [ [string] ] [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] [EOL] pet = unmarshal_model ( petstore_spec , pet_spec , pet_dict ) [EOL] [EOL] assert isinstance ( pet , Pet ) [EOL] assert [number] == pet . id [EOL] assert [string] == pet . name [EOL] assert [string] == pet . status [EOL] assert [ [string] , [string] ] == pet . photoUrls [EOL] assert isinstance ( pet . category , Category ) [EOL] assert [number] == pet . category . id [EOL] assert [string] == pet . category . name [EOL] assert isinstance ( pet . tags , list ) [EOL] assert [number] == len ( pet . tags ) [EOL] assert isinstance ( pet . tags [ [number] ] , Tag ) [EOL] assert [number] == pet . tags [ [number] ] . id [EOL] assert [string] == pet . tags [ [number] ] . name [EOL] assert isinstance ( pet . tags [ [number] ] , Tag ) [EOL] assert [number] == pet . tags [ [number] ] . id [EOL] assert [string] == pet . tags [ [number] ] . name [EOL] [EOL] [EOL] def test_Nones_are_reintroduced_for_declared_properties_that_are_not_present ( petstore_dict , pet_dict ) : [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] Pet = petstore_spec . definitions [ [string] ] [EOL] Tag = petstore_spec . definitions [ [string] ] [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] del pet_dict [ [string] ] [EOL] del pet_dict [ [string] ] [EOL] [EOL] pet = unmarshal_model ( petstore_spec , pet_spec , pet_dict ) [EOL] [EOL] assert isinstance ( pet , Pet ) [EOL] assert [number] == pet . id [EOL] assert [string] == pet . name [EOL] assert pet . status is None [EOL] assert [ [string] , [string] ] == pet . photoUrls [EOL] assert pet . category is None [EOL] assert isinstance ( pet . tags , list ) [EOL] assert [number] == len ( pet . tags ) [EOL] assert isinstance ( pet . tags [ [number] ] , Tag ) [EOL] assert [number] == pet . tags [ [number] ] . id [EOL] assert [string] == pet . tags [ [number] ] . name [EOL] assert isinstance ( pet . tags [ [number] ] , Tag ) [EOL] assert [number] == pet . tags [ [number] ] . id [EOL] assert [string] == pet . tags [ [number] ] . name [EOL] [EOL] [EOL] def test_value_is_not_dict_like_raises_error ( petstore_dict ) : [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] [EOL] with pytest . raises ( SwaggerMappingError ) as excinfo : [EOL] unmarshal_model ( petstore_spec , pet_spec , [string] ) [EOL] [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] @ pytest . mark . filterwarnings ( [string] ) def test_nullable_object_properties ( petstore_dict , pet_dict ) : [EOL] pet_spec_dict = petstore_dict [ [string] ] [ [string] ] [EOL] pet_spec_dict [ [string] ] . append ( [string] ) [EOL] pet_spec_dict [ [string] ] [ [string] ] [ [string] ] = True [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] Pet = petstore_spec . definitions [ [string] ] [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] pet_dict [ [string] ] = None [EOL] [EOL] pet = unmarshal_model ( petstore_spec , pet_spec , pet_dict ) [EOL] [EOL] assert isinstance ( pet , Pet ) [EOL] assert pet . category is None [EOL] [EOL] [EOL] def test_non_nullable_object_properties ( petstore_dict , pet_dict ) : [EOL] pet_spec_dict = petstore_dict [ [string] ] [ [string] ] [EOL] pet_spec_dict [ [string] ] . append ( [string] ) [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] pet_dict [ [string] ] = None [EOL] [EOL] with pytest . raises ( SwaggerMappingError ) : [EOL] unmarshal_model ( petstore_spec , pet_spec , pet_dict ) [EOL] [EOL] [EOL] def test_nullable_array_properties ( petstore_dict , pet_dict ) : [EOL] pet_spec_dict = petstore_dict [ [string] ] [ [string] ] [EOL] pet_spec_dict [ [string] ] [ [string] ] [ [string] ] = True [EOL] pet_spec_dict [ [string] ] . append ( [string] ) [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] Pet = petstore_spec . definitions [ [string] ] [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] pet_dict [ [string] ] = None [EOL] [EOL] pet = unmarshal_model ( petstore_spec , pet_spec , pet_dict ) [EOL] [EOL] assert isinstance ( pet , Pet ) [EOL] assert pet . tags is None [EOL] [EOL] [EOL] def test_non_nullable_array_properties ( petstore_dict , pet_dict ) : [EOL] pet_spec_dict = petstore_dict [ [string] ] [ [string] ] [EOL] pet_spec_dict [ [string] ] . append ( [string] ) [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] pet_spec = petstore_spec . spec_dict [ [string] ] [ [string] ] [EOL] pet_dict [ [string] ] = None [EOL] [EOL] with pytest . raises ( SwaggerMappingError ) : [EOL] unmarshal_model ( petstore_spec , pet_spec , pet_dict ) [EOL] [EOL] [EOL] def test_unmarshal_model_with_none_model_type ( petstore_spec ) : [EOL] model_spec = { [string] : [string] } [EOL] [EOL] with pytest . raises ( SwaggerMappingError ) as excinfo : [EOL] unmarshal_model ( petstore_spec , model_spec , { } ) [EOL] [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] def test_unmarshal_model_polymorphic_specs ( polymorphic_spec ) : [EOL] list_of_pets_dict = { [string] : [number] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , ] , } [EOL] pet_list = unmarshal_model ( swagger_spec = polymorphic_spec , model_spec = polymorphic_spec . spec_dict [ [string] ] [ [string] ] , model_value = list_of_pets_dict , ) [EOL] [EOL] assert isinstance ( pet_list , polymorphic_spec . definitions [ [string] ] ) [EOL] [EOL] assert pet_list . number_of_pets == list_of_pets_dict [ [string] ] [EOL] assert len ( pet_list . list ) == len ( list_of_pets_dict [ [string] ] ) [EOL] [EOL] for list_item_model , list_item_dict in zip ( pet_list . list , list_of_pets_dict [ [string] ] ) : [EOL] assert isinstance ( list_item_model , polymorphic_spec . definitions [ list_item_dict [ [string] ] ] ) [EOL] assert list_item_model . _marshal ( ) == list_item_dict [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , { } , { [string] : None } , ) , ( None , { [string] : [string] } , { [string] : datetime . datetime ( [number] , [number] , [number] , tzinfo = tzutc ( ) ) } , ) , ( { } , { [string] : [string] , [string] : [string] } , { [string] : datetime . datetime ( [number] , [number] , [number] , tzinfo = tzutc ( ) ) , [string] : [string] } , ) , ( True , { [string] : [string] , [string] : [string] } , { [string] : datetime . datetime ( [number] , [number] , [number] , tzinfo = tzutc ( ) ) , [string] : [string] } , ) , ( False , { [string] : [string] , [string] : [string] } , { [string] : datetime . datetime ( [number] , [number] , [number] , tzinfo = tzutc ( ) ) , [string] : [string] } , ) , ( { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : datetime . datetime ( [number] , [number] , [number] , tzinfo = tzutc ( ) ) , [string] : datetime . date ( [number] , [number] , [number] ) } , ) , ] , ) def test_unmarshal_model_with_additional_properties ( minimal_swagger_dict , additionalProperties , value , expected ) : [EOL] MyModel_spec = { [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , [string] : [string] , [string] : [string] , } [EOL] if additionalProperties is not None : [EOL] MyModel_spec [ [string] ] = additionalProperties [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = MyModel_spec [EOL] spec = Spec . from_dict ( minimal_swagger_dict ) [EOL] assert unmarshal_model ( spec , MyModel_spec , value ) . _as_dict ( ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] import pytest [EOL] [EOL] from bravado_core . param import Param [EOL] from bravado_core . resource import build_resources [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] spec_dict = { [string] : { } } [EOL] spec = Spec ( spec_dict ) [EOL] assert { } == build_resources ( spec ) [EOL] [EOL] [EOL] def test_resource_with_a_single_operation_associated_by_tag ( paths_spec ) : [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] assert [number] == len ( resources ) [EOL] assert resources [ [string] ] . findPetsByStatus [EOL] [EOL] [EOL] def test_resource_with_sanitized_tag ( paths_spec ) : [EOL] paths_spec [ [string] ] [ [string] ] [ [string] ] [ [number] ] = [string] [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] assert [number] == len ( resources ) [EOL] assert [string] in resources [EOL] assert [string] in resources [EOL] assert resources [ [string] ] is resources [ [string] ] [EOL] [EOL] [EOL] def test_resource_with_a_single_operation_associated_by_path_name ( paths_spec ) : [EOL] [comment] [EOL] paths_spec [ [string] ] = paths_spec [ [string] ] [EOL] del paths_spec [ [string] ] [EOL] [EOL] [comment] [EOL] del paths_spec [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] assert [number] == len ( resources ) [EOL] assert resources [ [string] ] . findPetsByStatus [EOL] [EOL] [EOL] def test_resource__associated_by_sanitized_path_name ( paths_spec ) : [EOL] [comment] [EOL] paths_spec [ [string] ] = paths_spec [ [string] ] [EOL] del paths_spec [ [string] ] [EOL] [EOL] [comment] [EOL] del paths_spec [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] assert [number] == len ( resources ) [EOL] assert [string] in resources [EOL] assert [string] in resources [EOL] assert resources [ [string] ] is resources [ [string] ] [EOL] [EOL] [EOL] def test_many_resources_with_the_same_operation_cuz_multiple_tags ( paths_spec ) : [EOL] tags = [ [string] , [string] , [string] , [string] , [string] ] [EOL] paths_spec [ [string] ] [ [string] ] [ [string] ] = tags [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] assert len ( tags ) == len ( resources ) [EOL] for tag in tags : [EOL] assert resources [ tag ] . findPetsByStatus [EOL] [EOL] [EOL] def test_get_undefined_operation ( paths_spec ) : [EOL] paths_spec [ [string] ] [ [string] ] [ [string] ] = [ [string] ] [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] resource = resources [ [string] ] [EOL] with pytest . raises ( AttributeError ) as excinfo : [EOL] resource . undefined_operation [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] def test_resource_with_shared_parameters ( paths_spec ) : [EOL] [comment] [EOL] shared_parameter = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } [EOL] paths_spec [ [string] ] [ [string] ] = [ shared_parameter ] [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] [comment] [EOL] assert isinstance ( resources [ [string] ] . findPetsByStatus . params [ [string] ] , Param , ) [EOL] [EOL] [EOL] def test_resource_with_vendor_extension ( paths_spec ) : [EOL] [docstring] [EOL] paths_spec [ [string] ] [ [string] ] = [string] [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] assert [number] == len ( resources ) [EOL] assert resources [ [string] ] . findPetsByStatus [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] , ) def test_refs ( minimal_swagger_dict , paths_spec , pet_spec , internally_dereference_refs ) : [EOL] minimal_swagger_dict [ [string] ] = paths_spec [EOL] minimal_swagger_dict [ [string] ] = { [string] : pet_spec } [EOL] swagger_spec = Spec ( spec_dict = minimal_swagger_dict , origin_url = [string] , config = { [string] : internally_dereference_refs } , ) [EOL] resources = build_resources ( swagger_spec ) [EOL] assert len ( resources ) == [number] [EOL] assert [string] in resources [EOL] [EOL] [EOL] def test_get_operations ( paths_spec ) : [EOL] spec_dict = { [string] : paths_spec } [EOL] resources = build_resources ( Spec ( spec_dict ) ) [EOL] resource = resources [ [string] ] [EOL] assert list ( dir ( resource ) ) == [ paths_spec [ [string] ] [ [string] ] [ [string] ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] import pytest [EOL] [EOL] from tests . conftest import check_object_deepcopy [EOL] [EOL] [EOL] @ pytest . fixture def pet_resource ( petstore_spec ) : [EOL] return petstore_spec . resources [ [string] ] [EOL] [EOL] [EOL] def test_resource_instance_is_deep_copyable ( pet_resource ) : [EOL] check_object_deepcopy ( pet_resource ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture def pet_spec ( ) : [EOL] [comment] [EOL] return { [string] : { [string] : { [string] : [string] , } , } , [string] : [ [string] , ] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def paths_spec ( ) : [EOL] [comment] [EOL] return { [string] : { [string] : { [string] : [ [string] , ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : { [string] : [string] , } , [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , } , } , } , [string] : { [string] : [string] , } , } , } , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] from bravado_core . marshal import marshal_schema_object [EOL] [EOL] [EOL] def test_small_objects ( benchmark , perf_petstore_spec , findByStatusReponseSchema , small_pets ) : [EOL] small_pets_models = [ perf_petstore_spec . definitions [ [string] ] . _unmarshal ( value ) for value in small_pets ] [EOL] benchmark ( marshal_schema_object , perf_petstore_spec , findByStatusReponseSchema , small_pets_models , ) [EOL] [EOL] [EOL] def test_large_objects ( benchmark , perf_petstore_spec , findByStatusReponseSchema , large_pets ) : [EOL] large_pets_models = [ perf_petstore_spec . definitions [ [string] ] . _unmarshal ( value ) for value in large_pets ] [EOL] benchmark ( marshal_schema_object , perf_petstore_spec , findByStatusReponseSchema , large_pets_models , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import uuid [EOL] [EOL] import pytest [EOL] [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [number] , [number] , [number] ] , ) def number_of_objects ( request ) : [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture def small_pets ( number_of_objects ) : [EOL] pets = [ ] [EOL] for i in range ( number_of_objects ) : [EOL] pets . append ( { [string] : str ( uuid . uuid4 ( ) ) , [string] : [ str ( uuid . uuid4 ( ) ) ] , } ) [EOL] return pets [EOL] [EOL] [EOL] @ pytest . fixture def large_pets ( number_of_objects ) : [EOL] pets = [ ] [EOL] for i in range ( number_of_objects ) : [EOL] pets . append ( { [string] : i + [number] , [string] : str ( uuid . uuid4 ( ) ) , [string] : [string] , [string] : [ [string] , [string] ] , [string] : { [string] : [number] , [string] : [string] , } , [string] : [ { [string] : [number] , [string] : [string] , } , { [string] : [number] , [string] : [string] , } , ] , } ) [EOL] return pets [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ True , False ] , ids = [ [string] , [string] ] , ) def perf_petstore_spec ( request , petstore_spec ) : [EOL] return Spec . from_dict ( spec_dict = petstore_spec . spec_dict , origin_url = petstore_spec . origin_url , config = dict ( petstore_spec . config , internally_dereference_refs = request . param ) , ) [EOL] [EOL] [EOL] @ pytest . fixture def findByStatusReponseSchema ( perf_petstore_spec ) : [EOL] parts = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] result = perf_petstore_spec . _internal_spec_dict [EOL] for part in parts : [EOL] result = perf_petstore_spec . deref ( result [ part ] ) [EOL] return result [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ True , False ] , ids = [ [string] , [string] ] , ) def petstore_op ( request , perf_petstore_spec ) : [EOL] op = perf_petstore_spec . resources [ [string] ] . findPetsByStatus [EOL] op . swagger_spec . config [ [string] ] = request . param [EOL] return op [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from bravado_core . exception import SwaggerSchemaError [EOL] from bravado_core . spec import build_api_serving_url [EOL] [EOL] [EOL] @ pytest . fixture def origin_url ( ) : [EOL] return [string] [EOL] [EOL] [EOL] def test_no_overrides ( origin_url ) : [EOL] spec = { } [EOL] assert [string] == build_api_serving_url ( spec , origin_url ) [EOL] [EOL] [EOL] def test_override_host ( origin_url ) : [EOL] spec = { [string] : [string] } [EOL] api_serving_url = build_api_serving_url ( spec , origin_url ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_override_basepath ( origin_url ) : [EOL] spec = { [string] : [string] } [EOL] api_serving_url = build_api_serving_url ( spec , origin_url ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_True ( ) : [EOL] api_serving_url = build_api_serving_url ( { } , use_spec_url_for_base_path = True , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_True_when_basePath_present ( ) : [EOL] api_serving_url = build_api_serving_url ( { [string] : [string] } , use_spec_url_for_base_path = True , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_True_when_origin_url_present ( origin_url ) : [EOL] api_serving_url = build_api_serving_url ( { } , origin_url , use_spec_url_for_base_path = True , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_True_when_basePath_and_origin_url_present ( origin_url ) : [EOL] api_serving_url = build_api_serving_url ( { [string] : [string] } , origin_url , use_spec_url_for_base_path = True , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_False ( ) : [EOL] api_serving_url = build_api_serving_url ( { } , use_spec_url_for_base_path = False , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_False_when_basePath_present ( ) : [EOL] api_serving_url = build_api_serving_url ( { [string] : [string] } , use_spec_url_for_base_path = False , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_False_when_origin_url_present ( origin_url ) : [EOL] api_serving_url = build_api_serving_url ( { } , origin_url , use_spec_url_for_base_path = False , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_use_spec_url_False_when_basePath_and_origin_url_present ( origin_url ) : [EOL] api_serving_url = build_api_serving_url ( { [string] : [string] } , origin_url , use_spec_url_for_base_path = True , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_override_scheme ( origin_url ) : [EOL] spec = { [string] : [ [string] ] } [EOL] api_serving_url = build_api_serving_url ( spec , origin_url ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_override_scheme_multiple_schemes ( origin_url ) : [EOL] spec = { [string] : [ [string] , [string] ] } [EOL] api_serving_url = build_api_serving_url ( spec , origin_url ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_pick_preferred_scheme ( origin_url ) : [EOL] spec = { [string] : [ [string] , [string] ] } [EOL] api_serving_url = build_api_serving_url ( spec , origin_url , preferred_scheme = [string] , ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_pick_origin_scheme_when_preferred_scheme_none ( origin_url ) : [EOL] spec = { [string] : [ [string] , [string] ] } [EOL] api_serving_url = build_api_serving_url ( spec , origin_url ) [EOL] assert [string] == api_serving_url [EOL] [EOL] [EOL] def test_preferred_scheme_not_available ( origin_url ) : [EOL] spec = { [string] : [ [string] ] } [EOL] with pytest . raises ( SwaggerSchemaError ) as excinfo : [EOL] build_api_serving_url ( spec , origin_url , preferred_scheme = [string] ) [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] def test_origin_url_None ( ) : [EOL] assert [string] == build_api_serving_url ( { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import mock [EOL] import pytest [EOL] from six . moves . cPickle import dumps [EOL] from six . moves . cPickle import loads [EOL] [EOL] from bravado_core . spec import Spec [EOL] from tests . conftest import get_url [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_ensure_spec_is_pickleable ( petstore_dict , petstore_abspath , internally_dereference_refs , validate_swagger_spec ) : [EOL] spec = Spec . from_dict ( spec_dict = petstore_dict , origin_url = get_url ( petstore_abspath ) , config = { [string] : validate_swagger_spec , [string] : internally_dereference_refs , } , ) [EOL] assert spec . is_equal ( loads ( dumps ( spec ) ) ) [EOL] [EOL] [EOL] def test_ensure_warning_presence_in_case_of_version_mismatch ( petstore_spec ) : [EOL] with mock . patch ( [string] , [string] ) : [EOL] petstore_pickle = dumps ( petstore_spec ) [EOL] [EOL] with pytest . warns ( UserWarning , match = [string] ) : [EOL] restored_petstore_spec = loads ( petstore_pickle ) [EOL] assert petstore_spec . is_equal ( restored_petstore_spec ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from tests . conftest import check_object_deepcopy [EOL] [EOL] [EOL] def test_spec_instance_is_deep_copyable ( petstore_spec ) : [EOL] check_object_deepcopy ( petstore_spec ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import copy [EOL] import functools [EOL] import os [EOL] [EOL] import mock [EOL] import pytest [EOL] from six . moves . urllib . parse import urlparse [EOL] from swagger_spec_validator import validator20 [EOL] [EOL] from bravado_core import spec [EOL] from bravado_core . spec import CONFIG_DEFAULTS [EOL] from bravado_core . spec import Spec [EOL] from bravado_core . spec_flattening import _marshal_uri [EOL] from bravado_core . spec_flattening import _SpecFlattener [EOL] from tests . conftest import _read_json [EOL] from tests . conftest import get_url [EOL] [EOL] [EOL] def _spec_flattener ( swagger_spec ) : [EOL] return _SpecFlattener ( swagger_spec = swagger_spec , marshal_uri_function = functools . partial ( _marshal_uri , origin_uri = None , ) , ) [EOL] [EOL] [EOL] @ pytest . fixture def spec_flattener ( minimal_swagger_spec ) : [EOL] return _spec_flattener ( minimal_swagger_spec ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_no_warning_for_clashed_uris ( mock_warnings , spec_flattener ) : [EOL] spec_flattener . warn_if_uri_clash_on_same_marshaled_representation ( { } ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_warning_for_clashed_uris ( mock_warnings , spec_flattener ) : [EOL] clashing_uris = [ [string] , [string] ] [EOL] marshaled_uri = [string] [EOL] spec_flattener . marshal_uri_function = functools . partial ( lambda * args , ** kwargs : marshaled_uri , origin_uri = None , ) [EOL] [EOL] spec_flattener . warn_if_uri_clash_on_same_marshaled_representation ( uri_schema_mappings = { urlparse ( uri ) : mock . Mock ( ) for uri in clashing_uris } , ) [EOL] [EOL] mock_warnings . warn . assert_called_once_with ( message = [string] . format ( [string] . join ( sorted ( clashing_uris ) ) , marshaled_uri ) , category = Warning , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , ] , ) def test_marshal_url_exceptions ( target ) : [EOL] with pytest . raises ( ValueError ) as excinfo : [EOL] _marshal_uri ( target_uri = urlparse ( target ) , origin_uri = None , ) [EOL] [EOL] assert [string] . format ( target = target ) in str ( excinfo . value ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ) def test_marshal_url_no_origin_uri ( target , expected_marshaled_uri ) : [EOL] marshaled_uri = _marshal_uri ( target_uri = urlparse ( target ) , origin_uri = None , ) [EOL] assert marshaled_uri == expected_marshaled_uri [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ) def test_marshal_url ( target , expected_marshaled_uri ) : [EOL] origin_url = [string] [EOL] marshaled_uri = _marshal_uri ( target_uri = urlparse ( target ) , origin_uri = urlparse ( origin_url ) , ) [EOL] assert marshaled_uri == expected_marshaled_uri [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_flattened_spec_warns_if_configured_to_not_validate_swagger_specs ( mock_log , minimal_swagger_dict , ) : [EOL] petstore_spec = Spec . from_dict ( minimal_swagger_dict , [string] , config = dict ( CONFIG_DEFAULTS , validate_swagger_spec = False ) ) [EOL] assert petstore_spec . flattened_spec == minimal_swagger_dict [EOL] mock_log . warning . assert_called_once_with ( [string] [string] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] , ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , wraps = spec . flattened_spec ) def test_flattened_spec_warning_if_no_origin_url ( wrap_flattened_spec , mock_build_http_handlers , mock_warnings , petstore_spec , has_origin_url , ) : [EOL] if not has_origin_url : [EOL] petstore_spec . origin_url = None [EOL] [EOL] petstore_spec . flattened_spec [EOL] wrap_flattened_spec . assert_called_once_with ( swagger_spec = petstore_spec ) [EOL] [EOL] if has_origin_url : [EOL] assert not mock_warnings . warn . called [EOL] else : [EOL] mock_warnings . warn . assert_called_once_with ( message = [string] [string] , category = Warning , ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_flattened_spec_cached_result ( mock_flattened_spec , mock_build_http_handlers , mock_warnings , petstore_spec ) : [EOL] petstore_spec . flattened_spec [EOL] petstore_spec . flattened_spec [EOL] assert mock_flattened_spec . call_count == [number] [EOL] [EOL] [EOL] def test_flattened_spec_provide_valid_specs ( flattened_multi_file_recursive_dict , multi_file_recursive_spec , ) : [EOL] flattened_spec = multi_file_recursive_spec . flattened_spec [EOL] validator20 . validate_spec ( spec_dict = copy . deepcopy ( flattened_spec ) , spec_url = [string] , http_handlers = { } , ) [EOL] assert flattened_spec == flattened_multi_file_recursive_dict [EOL] [EOL] [EOL] def test_flattened_specs_with_no_xmodel_tags ( multi_file_with_no_xmodel_spec , flattened_multi_file_with_no_xmodel_dict ) : [EOL] flattened_spec = multi_file_with_no_xmodel_spec . flattened_spec [EOL] validator20 . validate_spec ( spec_dict = copy . deepcopy ( flattened_spec ) , spec_url = [string] , http_handlers = { } , ) [EOL] assert flattened_spec == flattened_multi_file_with_no_xmodel_dict [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ { [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , } , { [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , } , ] , [ { [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , } , { [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , } , ] , [ { [string] : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } , } , } , { [string] : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } , } , } , ] , [ { [string] : { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , [string] : [string] , } , } , } , { [string] : { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , [string] : [string] , } , } , } , ] , [ { [string] : { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , [string] : [string] , } , } , } , { [string] : { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , [string] : [string] , } , } , } , ] , ] , ) def test_rename_definition_references ( spec_flattener , spec_dict , expected_spec_dict ) : [EOL] assert spec_flattener . rename_definition_references ( spec_dict ) == expected_spec_dict [EOL] [EOL] [EOL] def test_referenced_and_discovered_models_are_not_lost_after_flattening ( simple_crossfer_spec ) : [EOL] assert simple_crossfer_spec . flattened_spec [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_specs_with_none_in_ref_spec ( specs_with_none_in_ref_spec , flattened_specs_with_none_in_ref_dict ) : [EOL] assert specs_with_none_in_ref_spec . flattened_spec == flattened_specs_with_none_in_ref_dict [EOL] [EOL] [EOL] def test_include_root_definition ( minimal_swagger_dict , minimal_swagger_abspath ) : [EOL] minimal_swagger_dict [ [string] ] = { [string] : { [string] : [string] , } , } [EOL] spec_flattener = _spec_flattener ( Spec . from_dict ( minimal_swagger_dict , origin_url = get_url ( minimal_swagger_abspath ) ) ) [EOL] [EOL] spec_flattener . include_root_definition ( ) [EOL] [EOL] fragment_uri = [string] . format ( get_url ( minimal_swagger_abspath ) ) [EOL] assert spec_flattener . known_mappings [ [string] ] == { urlparse ( fragment_uri ) : minimal_swagger_dict [ [string] ] [ [string] ] , } [EOL] [EOL] [EOL] def test_include_discriminated_models ( minimal_swagger_dict , minimal_swagger_abspath ) : [EOL] minimal_swagger_dict [ [string] ] = { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] } , } , [string] : [string] , [string] : [ [string] ] , } , [string] : { [string] : [ { [string] : [string] } , { [string] : { [string] : { [string] : [string] } , } , } , ] , } , } [EOL] spec_flattener = _spec_flattener ( Spec . from_dict ( minimal_swagger_dict , origin_url = get_url ( minimal_swagger_abspath ) ) ) [EOL] [EOL] base_fragment_uri = [string] . format ( get_url ( minimal_swagger_abspath ) ) [EOL] spec_flattener . known_mappings [ [string] ] = { urlparse ( base_fragment_uri ) : minimal_swagger_dict [ [string] ] [ [string] ] , } [EOL] [EOL] spec_flattener . include_discriminated_models ( ) [EOL] [EOL] not_used_extend_base_fragment_uri = [string] . format ( get_url ( minimal_swagger_abspath ) ) [EOL] [EOL] assert spec_flattener . known_mappings [ [string] ] == { urlparse ( base_fragment_uri ) : minimal_swagger_dict [ [string] ] [ [string] ] , urlparse ( not_used_extend_base_fragment_uri ) : { [string] : [ mock . ANY , minimal_swagger_dict [ [string] ] [ [string] ] [ [string] ] [ [number] ] , ] , [string] : [string] , } , } [EOL] [EOL] [EOL] @ pytest . fixture def models_referenced_by_polymorphic_models_abspath ( my_dir ) : [EOL] return os . path . join ( os . path . dirname ( my_dir ) , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def models_referenced_by_polymorphic_models_dict ( models_referenced_by_polymorphic_models_abspath ) : [EOL] return _read_json ( models_referenced_by_polymorphic_models_abspath ) [EOL] [EOL] [EOL] def test_include_discriminated_models_does_recursively_add_new_models ( models_referenced_by_polymorphic_models_abspath , models_referenced_by_polymorphic_models_dict , ) : [EOL] spec = Spec . from_dict ( models_referenced_by_polymorphic_models_dict , origin_url = get_url ( models_referenced_by_polymorphic_models_abspath ) , config = { [string] : True } , ) [EOL] assert set ( spec . definitions ) == { [string] , [string] , [string] , [string] , [string] , [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from bravado_core . spec import Spec [EOL] from tests . conftest import get_url [EOL] [EOL] [EOL] def test_equality_of_the_same_object_returns_True ( petstore_spec ) : [EOL] assert petstore_spec . is_equal ( petstore_spec ) [EOL] [EOL] [EOL] def test_equality_of_different_instances_returns_True_if_the_specs_are_the_same ( petstore_spec , petstore_dict , petstore_abspath ) : [EOL] other_petstore_spec_instance = Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] assert petstore_spec . is_equal ( other_petstore_spec_instance ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , [number] ] ) def test_equality_of_different_instances_returns_False_if_attributes_are_not_matching ( petstore_spec , petstore_dict , petstore_abspath , attribute_value , ) : [EOL] other_petstore_spec_instance = Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] setattr ( other_petstore_spec_instance , [string] , attribute_value ) [EOL] assert not petstore_spec . is_equal ( other_petstore_spec_instance ) [EOL] [EOL] [EOL] def test_equality_of_different_instances_returns_False_if_the_specs_are_the_different ( petstore_spec , polymorphic_spec ) : [EOL] assert not petstore_spec . is_equal ( polymorphic_spec ) [EOL] [EOL] [EOL] def test_spec_hashability ( petstore_spec ) : [EOL] [comment] [EOL] [comment] [EOL] hash ( petstore_spec ) [EOL] [EOL] [EOL] def test_equality_checks_for_definitions ( petstore_spec , petstore_dict , petstore_abspath ) : [EOL] petstore_dict [ [string] ] [ [string] ] = { [string] : [string] } [EOL] other_petstore_spec_instance = Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] assert not petstore_spec . is_equal ( other_petstore_spec_instance ) [EOL] [EOL] [EOL] def test_equality_checks_for_resources ( petstore_spec , petstore_dict , petstore_abspath ) : [EOL] petstore_dict [ [string] ] [ [string] ] = { [string] : { [string] : { [string] : { [string] : [string] } , } , } , } [EOL] other_petstore_spec_instance = Spec . from_dict ( petstore_dict , origin_url = get_url ( petstore_abspath ) ) [EOL] assert not petstore_spec . is_equal ( other_petstore_spec_instance ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False ] ) def test_equality_of_specs_with_recursive_definition ( minimal_swagger_dict , minimal_swagger_abspath , internally_dereference_refs ) : [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = { [string] : [string] , [string] : { [string] : { [string] : [string] , } , } , } [EOL] [EOL] def new_spec ( ) : [EOL] return Spec . from_dict ( spec_dict = minimal_swagger_dict , origin_url = get_url ( minimal_swagger_abspath ) , config = { [string] : internally_dereference_refs } , ) [EOL] [EOL] assert new_spec ( ) . is_equal ( new_spec ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { [string] : [ ] } , { [string] : { [string] : None } } , { [string] : [ ] } , { [string] : { [string] : Exception } } , ] , ) def test_equality_early_exit ( minimal_swagger_dict , minimal_swagger_abspath , __dict__ , ) : [EOL] [comment] [EOL] minimal_swagger_dict [ [string] ] = { [string] : { [string] : [string] } } [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = { [string] : { [string] : { [string] : { [string] : [string] } , } , [string] : [ [string] ] , } , } [EOL] spec = Spec . from_dict ( minimal_swagger_dict , origin_url = get_url ( minimal_swagger_abspath ) ) [EOL] other_spec = Spec . from_dict ( minimal_swagger_dict , origin_url = get_url ( minimal_swagger_abspath ) ) [EOL] other_spec . __dict__ . update ( __dict__ ) [EOL] assert not spec . is_equal ( other_spec ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] def test_found_with_no_basepath ( petstore_dict ) : [EOL] del petstore_dict [ [string] ] [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] op = petstore_spec . get_op_for_request ( [string] , [string] ) [EOL] assert op == petstore_spec . resources [ [string] ] . operations [ [string] ] [EOL] [EOL] [EOL] def test_not_found_with_no_basepath ( petstore_dict ) : [EOL] del petstore_dict [ [string] ] [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] op = petstore_spec . get_op_for_request ( [string] , [string] ) [EOL] assert op is None [EOL] [EOL] [EOL] def test_found_with_basepath ( petstore_spec , getPetByIdPetstoreOperation ) : [EOL] op = petstore_spec . get_op_for_request ( [string] , [string] ) [EOL] assert op == getPetByIdPetstoreOperation [EOL] [EOL] [EOL] def test_found_with_basepath_containing_trailing_slash ( petstore_dict ) : [EOL] petstore_dict [ [string] ] = [string] [EOL] petstore_spec = Spec . from_dict ( petstore_dict ) [EOL] op = petstore_spec . get_op_for_request ( [string] , [string] ) [EOL] assert op == petstore_spec . resources [ [string] ] . operations [ [string] ] [EOL] [EOL] [EOL] def test_not_found_with_basepath ( petstore_spec ) : [EOL] op = petstore_spec . get_op_for_request ( [string] , [string] ) [EOL] assert op is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List , Union [EOL] import mock [EOL] import typing [EOL] import datetime [EOL] [EOL] import pytest [EOL] from mock import Mock [EOL] from mock import patch [EOL] [EOL] from bravado_core . operation import Operation [EOL] from bravado_core . param import Param [EOL] from bravado_core . param import unmarshal_param [EOL] from bravado_core . request import IncomingRequest [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] @ pytest . fixture def string_param_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def array_param_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , } , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def int_array_param_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def param_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture def boolean_param_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def test_path_string ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , path = { [string] : [string] } ) [EOL] assert [number] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_query_string ( empty_swagger_spec , string_param_spec ) : [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , string_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { [string] : [string] } ) [EOL] assert [string] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_optional_query_string_with_default ( empty_swagger_spec , string_param_spec ) : [EOL] string_param_spec [ [string] ] = False [EOL] string_param_spec [ [string] ] = [string] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , string_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { } ) [EOL] assert [string] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_optional_query_string_with_no_default_and_value_is_None ( empty_swagger_spec , string_param_spec ) : [EOL] string_param_spec [ [string] ] = False [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , string_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { } ) [EOL] assert unmarshal_param ( param , request ) is None [EOL] [EOL] [EOL] def test_optional_query_string_enum_with_no_default_and_value_is_None ( empty_swagger_spec , string_param_spec ) : [EOL] string_param_spec [ [string] ] = False [EOL] string_param_spec [ [string] ] = [ [string] , [string] ] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , string_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { } ) [EOL] assert unmarshal_param ( param , request ) is None [EOL] [EOL] [EOL] def test_query_array ( empty_swagger_spec , array_param_spec ) : [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , array_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { [string] : [ [string] , [string] , [string] ] } , ) [EOL] assert [ [string] , [string] , [string] ] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_optional_query_array_with_no_default ( empty_swagger_spec , array_param_spec ) : [EOL] array_param_spec [ [string] ] = False [EOL] [comment] [EOL] [comment] [EOL] array_param_spec [ [string] ] = [string] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , array_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { } ) [EOL] assert unmarshal_param ( param , request ) is None [EOL] [EOL] [EOL] def test_optional_query_array_with_default ( empty_swagger_spec , array_param_spec ) : [EOL] array_param_spec [ [string] ] = False [EOL] array_param_spec [ [string] ] = [ [string] , [string] ] [EOL] array_param_spec . pop ( [string] ) [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , array_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { } ) [EOL] assert [ [string] , [string] ] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_optional_query_array_with_default_empty ( empty_swagger_spec , array_param_spec ) : [EOL] array_param_spec [ [string] ] = False [EOL] array_param_spec [ [string] ] = [ ] [EOL] array_param_spec . pop ( [string] ) [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , array_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { } ) [EOL] assert [ ] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ [string] , [string] , [string] ] , [ [number] , [number] , [number] ] ) , ( [string] , [ [number] ] ) , ( None , None ) , ] , ) def test_query_int_array ( test_input , expected , empty_swagger_spec , int_array_param_spec ) : [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , int_array_param_spec , ) [EOL] request = Mock ( spec = IncomingRequest , query = { [string] : test_input } , ) [EOL] assert expected == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_query_string_boolean_values ( empty_swagger_spec , boolean_param_spec ) : [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , boolean_param_spec ) [EOL] request = Mock ( spec = IncomingRequest , query = { [string] : True } ) [EOL] assert True is unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_header_string ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = [string] [EOL] del param_spec [ [string] ] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , headers = { [string] : [string] } ) [EOL] assert [string] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_optional_header_string_with_default ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = False [EOL] param_spec [ [string] ] = [string] [EOL] del param_spec [ [string] ] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , headers = { } ) [EOL] assert [string] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_formData_integer ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , form = { [string] : [string] } ) [EOL] assert [number] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_optional_formData_integer_with_default ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = False [EOL] param_spec [ [string] ] = [number] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , form = { } ) [EOL] assert [number] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_formData_file ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = [string] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation , consumes = [ [string] ] ) , param_spec , ) [EOL] request = Mock ( spec = IncomingRequest , files = { [string] : [string] } , ) [EOL] assert [string] == unmarshal_param ( param , request ) [EOL] [EOL] [EOL] def test_body ( empty_swagger_spec , param_spec ) : [EOL] param_spec [ [string] ] = [string] [EOL] param_spec [ [string] ] = { [string] : [string] , } [EOL] del param_spec [ [string] ] [EOL] del param_spec [ [string] ] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , json = Mock ( return_value = [number] ) ) [EOL] value = unmarshal_param ( param , request ) [EOL] assert [number] == value [EOL] [EOL] [EOL] def assert_validate_call_count ( expected_call_count , config , petstore_dict ) : [EOL] with patch ( [string] ) as m_validate : [EOL] petstore_spec = Spec . from_dict ( petstore_dict , config = config ) [EOL] request = Mock ( spec = IncomingRequest , path = { [string] : [number] } ) [EOL] op = petstore_spec . resources [ [string] ] . operations [ [string] ] [EOL] param = op . params [ [string] ] [EOL] unmarshal_param ( param , request ) [EOL] assert expected_call_count == m_validate . call_count [EOL] [EOL] [EOL] def test_dont_validate_requests ( petstore_dict ) : [EOL] assert_validate_call_count ( [number] , { [string] : False } , petstore_dict ) [EOL] [EOL] [EOL] def test_validate_requests ( petstore_dict ) : [EOL] assert_validate_call_count ( [number] , { [string] : True } , petstore_dict ) [EOL] [EOL] [EOL] def test_ref ( minimal_swagger_dict , array_param_spec ) : [EOL] ref_spec = { [string] : [string] } [EOL] minimal_swagger_dict [ [string] ] = { [string] : array_param_spec , } [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] param = Param ( swagger_spec , Mock ( spec = Operation ) , ref_spec ) [EOL] value = [ [string] , [string] , [string] ] [EOL] request = Mock ( spec = IncomingRequest , query = { [string] : value } ) [EOL] result = unmarshal_param ( param , request ) [EOL] assert [ [string] , [string] , [string] ] == result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , None ) , ( { [string] : [string] } , { [string] : datetime . date ( [number] , [number] , [number] ) } ) , ] , ) def test_body_parameter_not_present_not_required ( empty_swagger_spec , body , expected_value ) : [EOL] param_spec = { [string] : [string] , [string] : [string] , [string] : False , [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , [string] : [ [string] , ] , } , } [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] request = Mock ( spec = IncomingRequest , json = Mock ( return_value = body ) ) [EOL] value = unmarshal_param ( param , request ) [EOL] assert expected_value == value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , Union [EOL] import typing [EOL] import json [EOL] [EOL] from bravado_core . param import stringify_body [EOL] [EOL] [EOL] def test_stringify_body_converts_dict_to_str ( ) : [EOL] body = { [string] : [string] , [string] : [number] } [EOL] body_str = stringify_body ( body ) [EOL] assert body == json . loads ( body_str ) [EOL] [EOL] [EOL] def test_stringify_body_ignores_data_if_already_str ( ) : [EOL] assert [string] == stringify_body ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , Union [EOL] import typing [EOL] import pytest [EOL] from mock import Mock [EOL] [EOL] from bravado_core . exception import SwaggerMappingError [EOL] from bravado_core . operation import Operation [EOL] from bravado_core . param import get_param_type_spec [EOL] from bravado_core . param import Param [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] @ pytest . fixture def body_param_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : { [string] : [string] , } , } [EOL] [EOL] [EOL] def test_location_is_body ( empty_swagger_spec , body_param_spec ) : [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , body_param_spec ) [EOL] assert body_param_spec [ [string] ] == get_param_type_spec ( param ) [EOL] [EOL] [EOL] def test_location_is_not_body ( empty_swagger_spec ) : [EOL] for location in ( [string] , [string] , [string] , [string] , ) : [EOL] param_spec = { [string] : [string] , [string] : location , [string] : [string] , [string] : True , [string] : [string] , } [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , param_spec ) [EOL] assert param_spec == get_param_type_spec ( param ) [EOL] [EOL] [EOL] def test_location_invalid ( empty_swagger_spec , body_param_spec ) : [EOL] body_param_spec [ [string] ] = [string] [EOL] param = Param ( empty_swagger_spec , Mock ( spec = Operation ) , body_param_spec ) [EOL] [EOL] with pytest . raises ( SwaggerMappingError ) as excinfo : [EOL] get_param_type_spec ( param ) [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] def test_ref ( minimal_swagger_dict , body_param_spec ) : [EOL] minimal_swagger_dict [ [string] ] = { [string] : body_param_spec , } [EOL] param_ref_spec = { [string] : [string] } [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] param = Param ( swagger_spec , Mock ( spec = Operation ) , param_ref_spec ) [EOL] assert { [string] : [string] } == get_param_type_spec ( param ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List , Tuple [EOL] import typing [EOL] import mock [EOL] import pytest [EOL] from mock import Mock [EOL] [EOL] from bravado_core . exception import SwaggerMappingError [EOL] from bravado_core . operation import Operation [EOL] from bravado_core . param import add_file [EOL] from bravado_core . param import Param [EOL] [EOL] [EOL] def test_single_file ( empty_swagger_spec ) : [EOL] request = { } [EOL] file_contents = [string] [EOL] op = Mock ( spec = Operation , consumes = [ [string] ] ) [EOL] param_spec = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] param = Param ( empty_swagger_spec , op , param_spec ) [EOL] add_file ( param , file_contents , request ) [EOL] expected_request = { [string] : [ ( [string] , ( [string] , [string] ) ) ] , } [EOL] assert expected_request == request [EOL] [EOL] [EOL] def test_single_named_file ( empty_swagger_spec ) : [EOL] request = { } [EOL] file_name = [string] [EOL] file_contents = [string] [EOL] op = Mock ( spec = Operation , consumes = [ [string] ] ) [EOL] param_spec = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] param = Param ( empty_swagger_spec , op , param_spec ) [EOL] add_file ( param , ( file_name , file_contents ) , request ) [EOL] expected_request = { [string] : [ ( [string] , ( file_name , [string] ) ) ] , } [EOL] assert expected_request == request [EOL] [EOL] [EOL] def test_multiple_files ( empty_swagger_spec ) : [EOL] request = { } [EOL] file1_contents = [string] [EOL] file2_contents = [string] [EOL] op = Mock ( spec = Operation , consumes = [ [string] ] ) [EOL] param1_spec = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] param2_spec = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] param1 = Param ( empty_swagger_spec , op , param1_spec ) [EOL] param2 = Param ( empty_swagger_spec , op , param2_spec ) [EOL] add_file ( param1 , file1_contents , request ) [EOL] add_file ( param2 , file2_contents , request ) [EOL] expected_request = { [string] : [ ( [string] , ( [string] , [string] ) ) , ( [string] , ( [string] , [string] ) ) , ] , } [EOL] assert expected_request == request [EOL] [EOL] [EOL] def test_mime_type_not_found_in_consumes ( empty_swagger_spec ) : [EOL] request = { } [EOL] file_contents = [string] [EOL] op = Mock ( spec = Operation , operation_id = [string] , consumes = [ ] ) [EOL] param_spec = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] param = Param ( empty_swagger_spec , op , param_spec ) [EOL] with pytest . raises ( SwaggerMappingError ) as excinfo : [EOL] add_file ( param , file_contents , request ) [EOL] assert [string] in str ( excinfo . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] @ pytest . fixture def empty_swagger_spec ( ) : [EOL] return Spec ( spec_dict = { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] import pytest [EOL] [EOL] from bravado_core . docstring import create_param_docstring [EOL] [EOL] [EOL] def test_param_with_no_default_value ( param_spec ) : [EOL] del param_spec [ [string] ] [EOL] expected = [string] [string] [EOL] assert expected == create_param_docstring ( param_spec ) [EOL] [EOL] [EOL] def test_param_with_default_value ( param_spec ) : [EOL] expected = [string] [string] [EOL] assert expected == create_param_docstring ( param_spec ) [EOL] [EOL] [EOL] def test_param_with_no_description ( param_spec ) : [EOL] del param_spec [ [string] ] [EOL] expected = [string] [string] [string] [EOL] assert expected == create_param_docstring ( param_spec ) [EOL] [EOL] [EOL] def test_param_required_true ( param_spec ) : [EOL] param_spec [ [string] ] = True [EOL] expected = [string] [string] [EOL] assert expected == create_param_docstring ( param_spec ) [EOL] [EOL] [EOL] def test_param_required_false ( param_spec ) : [EOL] param_spec [ [string] ] = False [EOL] expected = [string] [string] [EOL] assert expected == create_param_docstring ( param_spec ) [EOL] [EOL] [EOL] @ pytest . fixture def param_in_body_spec ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : { [string] : [string] , } , } [EOL] [EOL] [EOL] def test_param_in_body ( param_in_body_spec ) : [EOL] expected = [string] [string] [string] [EOL] assert expected == create_param_docstring ( param_in_body_spec ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from bravado_core . docstring import create_operation_docstring [EOL] from bravado_core . operation import Operation [EOL] [EOL] [EOL] def test_simple ( op_spec , empty_swagger_spec ) : [EOL] expected = [string] [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL] [EOL] [EOL] def test_no_parameters ( op_spec , empty_swagger_spec ) : [EOL] del op_spec [ [string] ] [EOL] expected = [string] [string] [string] [string] [string] [string] [EOL] [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL] [EOL] [EOL] def test_deprecated ( op_spec , empty_swagger_spec ) : [EOL] expected = [string] [string] [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] op_spec [ [string] ] = True [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL] [EOL] [EOL] def test_no_summary ( op_spec , empty_swagger_spec ) : [EOL] expected = [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] del op_spec [ [string] ] [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL] [EOL] [EOL] def test_no_description ( op_spec , empty_swagger_spec ) : [EOL] expected = [string] [string] [string] [string] [string] [string] [EOL] [EOL] del op_spec [ [string] ] [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL] [EOL] [EOL] def test_notype ( op_spec , empty_swagger_spec ) : [EOL] del op_spec [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] expected = [string] [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL] [EOL] [EOL] def test_unicode ( op_spec , empty_swagger_spec ) : [EOL] [comment] [EOL] op_spec [ [string] ] = [string] [EOL] op_spec [ [string] ] = [string] [EOL] op_spec [ [string] ] [ [number] ] [ [string] ] = [string] [EOL] op_spec [ [string] ] [ [number] ] [ [string] ] = [string] [EOL] op_spec [ [string] ] [ [number] ] [ [string] ] = [string] [EOL] op_spec [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] op_spec [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] [EOL] expected = [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] op = Operation ( empty_swagger_spec , [string] , [string] , op_spec ) [EOL] assert expected == create_operation_docstring ( op ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] __author__ = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any , Set [EOL] import typing [EOL] from bravado_core . schema import collapsed_required [EOL] [EOL] [EOL] def test_allOf ( users_spec , users_swagger_spec ) : [EOL] [docstring] [EOL] superuser_spec = users_spec [ [string] ] [EOL] required = collapsed_required ( superuser_spec , users_swagger_spec ) [EOL] assert required == { [string] , [string] , [string] , [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from bravado_core . schema import is_required [EOL] from bravado_core . spec import Spec [EOL] [EOL] [EOL] @ pytest . fixture def required_true ( ) : [EOL] return { [string] : [string] , [string] : True } [EOL] [EOL] [EOL] @ pytest . fixture def required_false ( ) : [EOL] return { [string] : [string] , [string] : False } [EOL] [EOL] [EOL] def test_true ( minimal_swagger_spec , required_true ) : [EOL] assert is_required ( minimal_swagger_spec , required_true ) [EOL] [EOL] [EOL] def test_false ( minimal_swagger_spec , required_false ) : [EOL] assert not is_required ( minimal_swagger_spec , required_false ) [EOL] [EOL] [EOL] def test_defaults_to_false ( minimal_swagger_spec ) : [EOL] assert not is_required ( minimal_swagger_spec , { [string] : [string] } ) [EOL] [EOL] [EOL] def test_ref_true ( minimal_swagger_dict , required_true ) : [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = required_true [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] assert is_required ( swagger_spec , { [string] : [string] } ) [EOL] [EOL] [EOL] def test_ref_false ( minimal_swagger_dict , required_false ) : [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = required_false [EOL] swagger_spec = Spec ( minimal_swagger_dict ) [EOL] assert not is_required ( swagger_spec , { [string] : [string] } ) [EOL] [EOL] [EOL] def test_ref_default_to_false ( minimal_swagger_dict ) : [EOL] minimal_swagger_dict [ [string] ] [ [string] ] = { [string] : [string] } [EOL] swagger_spec = Spec . from_dict ( minimal_swagger_dict ) [EOL] assert not is_required ( swagger_spec , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , Union [EOL] import typing [EOL] from bravado_core . schema import collapsed_properties [EOL] [EOL] [EOL] def test_allOf ( users_spec , users_swagger_spec ) : [EOL] [docstring] [EOL] superuser_spec = users_spec [ [string] ] [EOL] props = collapsed_properties ( superuser_spec , users_swagger_spec ) [EOL] [EOL] expected_props = { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : { [string] : [string] } , [string] : [string] } , } [EOL] assert props == expected_props [EOL] [EOL] [EOL] def test_recursive_ref ( node_spec , recursive_swagger_spec ) : [EOL] props = collapsed_properties ( node_spec , recursive_swagger_spec ) [EOL] [EOL] expected_props = { [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , } [EOL] assert props == expected_props [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] __author__ = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[comment] [EOL] version = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from six import iteritems [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def operation_docstring_wrapper ( operation ) : [EOL] [docstring] [EOL] def wrapper ( ** kwargs ) : [EOL] return operation ( ** kwargs ) [EOL] [EOL] [comment] [EOL] wrapper . __doc__ = create_operation_docstring ( operation ) [EOL] wrapper . __name__ = str ( operation . operation_id ) [EOL] return wrapper [EOL] [EOL] [EOL] def create_operation_docstring ( op ) : [EOL] [docstring] [EOL] [comment] [EOL] log . debug ( [string] , op . operation_id ) [EOL] s = [string] [EOL] op_spec = op . op_spec [EOL] is_deprecated = op_spec . get ( [string] , False ) [EOL] if is_deprecated : [EOL] s += [string] [EOL] [EOL] summary = op_spec . get ( [string] ) [EOL] if summary : [EOL] s += [string] . format ( op . http_method . upper ( ) , summary ) [EOL] [EOL] desc = op_spec . get ( [string] ) [EOL] if desc : [EOL] s += [string] . format ( desc ) [EOL] [EOL] [comment] [EOL] for param_spec in op_spec . get ( [string] , [ ] ) : [EOL] s += create_param_docstring ( param_spec ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] responses = op_spec . get ( [string] ) [EOL] for http_status_code , response_spec in iter ( sorted ( iteritems ( responses ) ) ) : [EOL] response_desc = response_spec . get ( [string] ) [EOL] s += [string] . format ( http_status_code , response_desc ) [EOL] schema_spec = response_spec . get ( [string] ) [EOL] if schema_spec : [EOL] s += [string] . format ( formatted_type ( schema_spec ) ) [EOL] return s [EOL] [EOL] [EOL] def create_param_docstring ( param_spec ) : [EOL] [docstring] [EOL] name = param_spec . get ( [string] ) [EOL] desc = param_spec . get ( [string] , [string] ) [EOL] desc = desc if desc else [string] [EOL] default_value = param_spec . get ( [string] ) [EOL] location = param_spec . get ( [string] ) [EOL] required = param_spec . get ( [string] , False ) [EOL] [EOL] s = [string] . format ( name , desc ) [EOL] if default_value is not None : [EOL] s += [string] . format ( default_value ) [EOL] if not required : [EOL] s += [string] [EOL] s += [string] [EOL] [EOL] if location == [string] : [EOL] param_type = formatted_type ( param_spec . get ( [string] ) ) [EOL] else : [EOL] param_type = param_spec . get ( [string] ) [EOL] s += [string] . format ( name , param_type ) [EOL] [EOL] [comment] [EOL] return s [EOL] [EOL] [EOL] def formatted_type ( spec ) : [EOL] [docstring] [EOL] obj_type = spec . get ( [string] ) [EOL] obj_format = spec . get ( [string] ) [EOL] ref = spec . get ( [string] ) [EOL] if obj_format and obj_type : [EOL] return [string] . format ( obj_type , obj_format ) [EOL] elif obj_type == [string] : [EOL] return [string] . format ( obj_type , formatted_type ( spec [ [string] ] ) ) [EOL] elif ref : [EOL] return ref [EOL] elif obj_type : [EOL] return obj_type [EOL] else : [comment] [EOL] [comment] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , Set , Tuple [EOL] import typing [EOL] import copy [EOL] [EOL] import typing [EOL] from six import iteritems [EOL] from six import string_types [EOL] [EOL] from bravado_core . _compat import Mapping [EOL] from bravado_core . exception import SwaggerMappingError [EOL] [EOL] [EOL] if getattr ( typing , [string] , False ) : [EOL] from bravado_core . spec import Spec [EOL] from bravado_core . _compat_typing import JSONDict [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] SWAGGER_PRIMITIVES = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] def has_default ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return [string] in swagger_spec . deref ( schema_object_spec ) [EOL] [EOL] [EOL] def get_default ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return swagger_spec . deref ( schema_object_spec ) . get ( [string] ) [EOL] [EOL] [EOL] def is_required ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return swagger_spec . deref ( schema_object_spec ) . get ( [string] , False ) [EOL] [EOL] [EOL] def has_format ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return [string] in swagger_spec . deref ( schema_object_spec ) [EOL] [EOL] [EOL] def get_format ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return swagger_spec . deref ( schema_object_spec ) . get ( [string] ) [EOL] [EOL] [EOL] def is_param_spec ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return [string] in swagger_spec . deref ( schema_object_spec ) [EOL] [EOL] [EOL] def is_prop_nullable ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] return swagger_spec . deref ( schema_object_spec ) . get ( [string] , False ) [EOL] [EOL] [EOL] def is_ref ( spec ) : [EOL] [comment] [EOL] [docstring] [EOL] try : [EOL] return [string] in spec and is_dict_like ( spec ) and isinstance ( spec [ [string] ] , string_types ) [EOL] except TypeError : [EOL] return False [EOL] [EOL] [EOL] def is_dict_like ( spec ) : [EOL] [comment] [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return isinstance ( spec , ( dict , Mapping ) ) [EOL] [EOL] [EOL] def is_list_like ( spec ) : [EOL] [comment] [EOL] [docstring] [EOL] return isinstance ( spec , ( list , tuple ) ) [EOL] [EOL] [EOL] def get_spec_for_prop ( swagger_spec , object_spec , object_value , prop_name , properties = None , ) : [EOL] [comment] [EOL] [docstring] [EOL] deref = swagger_spec . deref [EOL] [EOL] if properties is None : [EOL] properties = collapsed_properties ( deref ( object_spec ) , swagger_spec ) [EOL] prop_spec = properties . get ( prop_name ) [EOL] [EOL] [comment] [EOL] if prop_spec is not None : [EOL] result_spec = deref ( prop_spec ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in prop_spec and [string] not in result_spec : [EOL] result_spec = copy . deepcopy ( result_spec ) [EOL] result_spec [ [string] ] = prop_spec [ [string] ] [EOL] return result_spec [EOL] [EOL] additional_props = deref ( object_spec ) . get ( [string] , True ) [EOL] [EOL] if isinstance ( additional_props , bool ) : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] [EOL] additional_props = deref ( additional_props ) [EOL] if is_dict_like ( additional_props ) : [EOL] [comment] [EOL] return additional_props [EOL] [EOL] raise SwaggerMappingError ( [string] [string] . format ( object_spec , object_value ) , ) [EOL] [EOL] [EOL] def handle_null_value ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] [docstring] [EOL] if has_default ( swagger_spec , schema_object_spec ) : [EOL] return get_default ( swagger_spec , schema_object_spec ) [EOL] [EOL] if is_prop_nullable ( swagger_spec , schema_object_spec ) : [EOL] return None [EOL] [EOL] raise SwaggerMappingError ( [string] . format ( schema_object_spec ) , ) [EOL] [EOL] [EOL] def collapsed_properties ( model_spec , swagger_spec ) : [EOL] [comment] [EOL] [docstring] [EOL] [EOL] properties = { } [EOL] [EOL] [comment] [EOL] if [string] in model_spec : [EOL] for attr , attr_spec in iteritems ( model_spec [ [string] ] ) : [EOL] properties [ attr ] = attr_spec [EOL] [EOL] [comment] [EOL] if [string] in model_spec : [EOL] deref = swagger_spec . deref [EOL] for item_spec in model_spec [ [string] ] : [EOL] item_spec = deref ( item_spec ) [EOL] more_properties = collapsed_properties ( item_spec , swagger_spec ) [EOL] properties . update ( more_properties ) [EOL] [EOL] return properties [EOL] [EOL] [EOL] def collapsed_required ( model_spec , swagger_spec ) : [EOL] [comment] [EOL] [docstring] [EOL] required = set ( model_spec . get ( [string] , [ ] ) ) [EOL] [EOL] if [string] in model_spec : [EOL] deref = swagger_spec . deref [EOL] for item_spec in model_spec [ [string] ] : [EOL] item_spec = deref ( item_spec ) [EOL] required . update ( collapsed_required ( item_spec , swagger_spec ) ) [EOL] [EOL] return required [EOL] [EOL] [EOL] def get_type_from_schema ( swagger_spec , schema_object_spec ) : [EOL] [comment] [EOL] try : [EOL] return schema_object_spec [ [string] ] [EOL] except KeyError : [EOL] if swagger_spec . config [ [string] ] or [string] in schema_object_spec : [EOL] return [string] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Any , Dict , Type , TypeVar [EOL] import bravado_core [EOL] import typing [EOL] [docstring] [EOL] from __future__ import unicode_literals [EOL] [EOL] import base64 [EOL] import functools [EOL] [EOL] import dateutil . parser [EOL] import pytz [EOL] import six [EOL] import typing [EOL] [EOL] from bravado_core import schema [EOL] from bravado_core . exception import SwaggerMappingError [EOL] [EOL] [EOL] if getattr ( typing , [string] , False ) : [EOL] from bravado_core . _compat_typing import JSONDict [EOL] from bravado_core . _compat_typing import MarshalingMethod [comment] [EOL] from bravado_core . _compat_typing import UnmarshalingMethod [comment] [EOL] from bravado_core . spec import Spec [EOL] [EOL] T = typing . TypeVar ( [string] ) [EOL] [EOL] [EOL] if six . PY3 : [EOL] long = int [EOL] [EOL] [EOL] def NO_OP ( x ) : [comment] [EOL] [comment] [EOL] return x [EOL] [EOL] [EOL] def to_wire ( swagger_spec , primitive_spec , value , ) : [EOL] [comment] [EOL] [docstring] [EOL] if value is None or not schema . has_format ( swagger_spec , primitive_spec ) : [EOL] return value [EOL] format_name = schema . get_format ( swagger_spec , primitive_spec ) [EOL] formatter = swagger_spec . get_format ( format_name ) [EOL] [EOL] try : [EOL] return formatter . to_wire ( value ) if formatter else value [EOL] except Exception as e : [EOL] raise SwaggerMappingError ( [string] . format ( value , primitive_spec [ [string] ] , [string] . format ( primitive_spec [ [string] ] ) if [string] in primitive_spec else [string] , ) , e , ) [EOL] [EOL] [EOL] def to_python ( swagger_spec , primitive_spec , value , ) : [EOL] [comment] [EOL] [docstring] [EOL] if value is None or not schema . has_format ( swagger_spec , primitive_spec ) : [EOL] return value [EOL] format_name = schema . get_format ( swagger_spec , primitive_spec ) [EOL] formatter = swagger_spec . get_format ( format_name ) [EOL] return formatter . to_python ( value ) if formatter else value [EOL] [EOL] [EOL] class SwaggerFormat ( typing . NamedTuple ( [string] , [ ( [string] , typing . Text ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , typing . Callable [ [ typing . Any ] , typing . Any ] ) , ( [string] , typing . Text ) , ] , ) , ) : [EOL] [docstring] [EOL] [EOL] [EOL] def return_true_wrapper ( validate_func ) : [EOL] [comment] [EOL] [docstring] [EOL] @ functools . wraps ( validate_func ) def wrapper ( validatable_primitive ) : [EOL] [comment] [EOL] validate_func ( validatable_primitive ) [EOL] return True [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] BASE64_BYTE_FORMAT = SwaggerFormat ( format = [string] , to_wire = lambda b : six . ensure_str ( base64 . b64encode ( b ) , encoding = str ( [string] ) ) , to_python = lambda s : base64 . b64decode ( six . ensure_binary ( s , encoding = str ( [string] ) ) ) , validate = NO_OP , description = [string] , ) [EOL] [EOL] DEFAULT_FORMATS = { [string] : SwaggerFormat ( format = [string] , to_wire = lambda b : b if isinstance ( b , str ) else str ( b ) , to_python = lambda s : s if isinstance ( s , str ) else str ( s ) , validate = NO_OP , description = [string] , ) , [string] : SwaggerFormat ( format = [string] , to_wire = lambda d : d . isoformat ( ) , to_python = lambda d : dateutil . parser . parse ( d ) . date ( ) , validate = NO_OP , description = [string] , ) , [string] : SwaggerFormat ( format = [string] , to_wire = lambda d : d if isinstance ( d , float ) else float ( d ) , to_python = lambda d : d if isinstance ( d , float ) else float ( d ) , validate = NO_OP , description = [string] , ) , [string] : SwaggerFormat ( format = [string] , to_wire = lambda dt : ( dt if dt . tzinfo else pytz . utc . localize ( dt ) ) . isoformat ( ) , to_python = lambda dt : dateutil . parser . parse ( dt ) , validate = NO_OP , description = ( [string] ) , ) , [string] : SwaggerFormat ( format = [string] , to_wire = lambda f : f if isinstance ( f , float ) else float ( f ) , to_python = lambda f : f if isinstance ( f , float ) else float ( f ) , validate = NO_OP , description = [string] , ) , [string] : SwaggerFormat ( format = [string] , to_wire = lambda i : i if isinstance ( i , int ) else int ( i ) , to_python = lambda i : i if isinstance ( i , int ) else int ( i ) , validate = NO_OP , description = [string] , ) , [string] : SwaggerFormat ( format = [string] , to_wire = lambda i : i if isinstance ( i , long ) else long ( i ) , to_python = lambda i : i if isinstance ( i , long ) else long ( i ) , validate = NO_OP , description = [string] , ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bravado_core.formatter.SwaggerFormat$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,bravado_core.formatter.SwaggerFormat]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.int]$ 0 0 $typing.Type[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.int]$ 0 0 $typing.Type[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] APP_JSON = [string] [EOL] APP_MSGPACK = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import typing [EOL] [EOL] from bravado_core import schema [EOL] from bravado_core . _compat import wraps [EOL] from bravado_core . exception import SwaggerMappingError [EOL] from bravado_core . util import memoize_by_id [EOL] from bravado_core . util import RecursiveCallException [EOL] [EOL] [EOL] if getattr ( typing , [string] , False ) : [EOL] from bravado_core . spec import Spec [EOL] from bravado_core . _compat_typing import JSONDict [EOL] from bravado_core . _compat_typing import FuncType [EOL] [EOL] [EOL] @ memoize_by_id def handle_null_value ( swagger_spec , object_schema , is_nullable = False , is_marshaling_operation = False ) : [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] default_value = schema . get_default ( swagger_spec , object_schema ) [EOL] is_nullable = is_nullable or schema . is_prop_nullable ( swagger_spec , object_schema ) [EOL] [EOL] def external_wrapper ( func ) : [EOL] [comment] [EOL] @ wraps ( func ) def wrapper ( value ) : [EOL] [comment] [EOL] if value is None : [EOL] value = default_value [EOL] [EOL] if value is None : [EOL] if is_nullable : [EOL] return None [EOL] else : [EOL] raise SwaggerMappingError ( [string] . format ( object_schema ) , ) [EOL] elif is_marshaling_operation : [EOL] return value [EOL] return func ( value ) [EOL] [EOL] return wrapper [EOL] [EOL] return external_wrapper [EOL] [EOL] [EOL] def wrap_recursive_call_exception ( func ) : [EOL] [comment] [EOL] [docstring] [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] [comment] [EOL] try : [EOL] return func ( * args , ** kwargs ) [EOL] except RecursiveCallException : [EOL] return lambda * new_args , ** new_kawrgs : func ( * args , ** kwargs ) ( * new_args , ** new_kawrgs ) [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import TypeVar [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] import six [EOL] import typing [EOL] [EOL] from bravado_core . exception import SwaggerSchemaError [EOL] [EOL] if getattr ( typing , [string] , False ) : [EOL] from bravado_core . _compat_typing import JSONDict [EOL] from bravado_core . security_definition import SecurityDefinition [EOL] from bravado_core . spec import Spec [EOL] [EOL] T = typing . TypeVar ( [string] ) [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class SecurityRequirement ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , swagger_spec , security_requirement_spec ) : [EOL] [comment] [EOL] self . swagger_spec = swagger_spec [EOL] self . security_requirement_spec = swagger_spec . deref ( security_requirement_spec ) [EOL] for security_definition in six . iterkeys ( security_requirement_spec ) : [EOL] if security_definition not in self . swagger_spec . security_definitions : [EOL] raise SwaggerSchemaError ( [string] . format ( swagger_path = [string] , security = security_definition , ) , ) [EOL] [EOL] @ property def security_definitions ( self ) : [EOL] [comment] [EOL] return { security_name : self . swagger_spec . security_definitions [ security_name ] for security_name in six . iterkeys ( self . security_requirement_spec ) } [EOL] [EOL] @ property def security_scopes ( self ) : [EOL] [comment] [EOL] return { security_name : self . security_requirement_spec [ security_name ] for security_name in six . iterkeys ( self . security_requirement_spec ) } [EOL] [EOL] @ property def parameters_representation_dict ( self ) : [EOL] [comment] [EOL] return [ definition . parameter_representation_dict for definition in six . itervalues ( self . security_definitions ) if definition . parameter_representation_dict ] [EOL] [EOL] def __iter__ ( self ) : [EOL] [comment] [EOL] return six . itervalues ( self . security_definitions ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0