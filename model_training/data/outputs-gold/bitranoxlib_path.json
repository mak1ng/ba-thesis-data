[comment] [EOL] from typing import Union , Any , List [EOL] import builtins [EOL] import ctypes [EOL] import typing [EOL] import logging [EOL] import pathlib [EOL] import binascii [EOL] import ctypes [EOL] import getpass [EOL] import importlib [EOL] import importlib . util [EOL] import logging [EOL] import os [EOL] import pathlib [EOL] import subprocess [EOL] from typing import List , Union [EOL] [EOL] [comment] [EOL] import lib_platform [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def log_and_raise_if_path_does_not_exist ( path ) : [EOL] [docstring] [EOL] if not path . exists ( ) : [EOL] s_error = [string] . format ( path = path ) [EOL] logger . error ( s_error ) [EOL] raise FileNotFoundError ( s_error ) [EOL] [EOL] [EOL] def log_and_raise_if_not_isdir ( path_dir ) : [EOL] [docstring] [EOL] [EOL] if not path_dir . is_dir ( ) : [EOL] s_error = [string] . format ( path_dir = path_dir ) [EOL] logger . error ( s_error ) [EOL] raise NotADirectoryError ( s_error ) [EOL] [EOL] [EOL] def log_and_raise_if_target_directory_within_source_directory ( path_source_dir , path_target_dir ) : [EOL] [docstring] [EOL] if is_target_directory_within_source_directory ( path_source_dir , path_target_dir ) : [EOL] s_error = [string] . format ( path_target_dir , path_source_dir ) [EOL] logger . error ( s_error ) [EOL] raise FileExistsError ( s_error ) [EOL] [EOL] [EOL] def is_target_directory_within_source_directory ( path_source_dir , path_target_dir ) : [EOL] s_source_dir = str ( path_source_dir . resolve ( ) ) + [string] [EOL] s_target_dir = str ( path_target_dir . resolve ( ) ) + [string] [EOL] if s_target_dir . startswith ( s_source_dir ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def log_and_raise_if_not_isfile ( path_file ) : [EOL] [docstring] [EOL] if not path_file . is_file ( ) : [EOL] s_error = [string] . format ( path_file = path_file ) [EOL] logger . error ( s_error ) [EOL] raise FileNotFoundError ( s_error ) [EOL] [EOL] [EOL] def path_join_posix ( path , * paths ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] path = str ( path ) [comment] [EOL] ls_paths = [ ] [EOL] for s_path in paths : [EOL] s_path = s_path . replace ( [string] , [string] ) [EOL] s_path = s_path . lstrip ( [string] ) [EOL] ls_paths . append ( s_path ) [EOL] [EOL] is_windows_unc = is_windows_network_unc ( path ) [EOL] path = os . path . normpath ( path ) [EOL] path = strip_and_replace_backslashes ( path ) [EOL] ret_path = os . path . join ( path , * ls_paths ) [EOL] ret_path = os . path . normpath ( ret_path ) [EOL] ret_path = strip_and_replace_backslashes ( ret_path ) [EOL] if is_windows_unc : [EOL] ret_path = [string] + ret_path . lstrip ( [string] ) [EOL] return ret_path [EOL] [EOL] [EOL] def path_remove_trailing_slashes ( path ) : [EOL] [docstring] [EOL] path = strip_and_replace_backslashes ( path ) [EOL] path = path . rstrip ( [string] ) [EOL] return path [EOL] [EOL] [EOL] def get_basename_without_extension ( path_file ) : [EOL] [docstring] [EOL] basename = path_file . stem [EOL] return basename [EOL] [EOL] [EOL] def strip_and_replace_backslashes ( path ) : [EOL] [docstring] [EOL] path = path . strip ( ) . replace ( [string] , [string] ) [EOL] return path [EOL] [EOL] [EOL] def get_current_dir ( ) : [EOL] [docstring] [EOL] return pathlib . Path . cwd ( ) . resolve ( ) [EOL] [EOL] [EOL] def get_current_dir_and_change_to_home ( ) : [EOL] current_path = get_current_dir ( ) [EOL] os . chdir ( str ( pathlib . Path . home ( ) ) ) [EOL] return current_path [EOL] [EOL] [EOL] def is_windows_network_unc ( path ) : [EOL] [docstring] [EOL] path = strip_and_replace_backslashes ( path ) [EOL] if path . startswith ( [string] ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def substract_windows_drive_letter ( path ) : [EOL] [docstring] [EOL] path = strip_and_replace_backslashes ( path ) [EOL] if path_starts_with_windows_drive_letter ( path ) : [EOL] path = path [ [number] : ] [EOL] return path [EOL] [EOL] [EOL] def path_starts_with_windows_drive_letter ( path ) : [EOL] [docstring] [EOL] path = strip_and_replace_backslashes ( path ) [EOL] if path [ [number] : ] . startswith ( [string] ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def chdir ( path ) : [EOL] os . chdir ( str ( path ) ) [EOL] [EOL] [EOL] def get_l_path_sub_directories ( path_base_directory ) : [EOL] [docstring] [EOL] log_and_raise_if_not_isdir ( path_base_directory ) [EOL] path_base_directory . resolve ( ) [EOL] [EOL] try : [EOL] l_sub_directories = next ( os . walk ( str ( path_base_directory ) ) ) [ [number] ] [EOL] l_path_sub_directories = [ pathlib . Path ( str ( subdir ) ) for subdir in l_sub_directories ] [EOL] return l_path_sub_directories [EOL] except StopIteration : [EOL] return [ ] [EOL] [EOL] [EOL] def get_windows_system_drive_letter ( ) : [EOL] [docstring] [EOL] kernel32 = ctypes . windll . kernel32 [comment] [EOL] windows_directory = ctypes . create_unicode_buffer ( [number] ) [EOL] if kernel32 . GetWindowsDirectoryW ( windows_directory , [number] ) == [number] : [EOL] raise RuntimeError ( [string] ) [EOL] windows_drive = os . path . splitdrive ( windows_directory . value ) [ [number] ] . lower ( ) [EOL] return windows_drive [EOL] [EOL] [EOL] def has_subdirs ( path_dir ) : [EOL] [EOL] [docstring] [EOL] [EOL] if len ( get_l_path_sub_directories ( path_dir ) ) > [number] : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def is_directory_empty ( path_directory ) : [EOL] [docstring] [EOL] log_and_raise_if_not_isdir ( path_directory ) [EOL] is_empty = not any ( path_directory . iterdir ( ) ) [EOL] return is_empty [EOL] [EOL] [EOL] def is_directory_writable ( directory ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] [comment] [EOL] [comment] [EOL] temp_file = binascii . hexlify ( os . urandom ( [number] ) ) . decode ( ) [EOL] temp_path = path_join_posix ( directory , temp_file ) [EOL] if not os . path . exists ( temp_path ) : [EOL] break [EOL] [EOL] pathlib . Path ( temp_path ) . touch ( ) [EOL] os . remove ( temp_path ) [EOL] return True [EOL] [EOL] except Exception : [EOL] pass [EOL] return False [EOL] [EOL] [EOL] def get_test_directory_path ( module_name , test_directory_name = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] path_origin_directory = pathlib . Path ( str ( importlib . util . find_spec ( module_name ) . origin ) ) . parent [comment] [EOL] path_origin_resolved_directory = path_origin_directory . resolve ( ) [EOL] [comment] [EOL] root_directory = pathlib . Path ( [string] ) [EOL] while True : [EOL] if ( path_origin_resolved_directory / test_directory_name ) . is_dir ( ) : [EOL] break [EOL] if path_origin_resolved_directory == root_directory : [EOL] raise FileNotFoundError ( [string] . format ( test_directory_name = test_directory_name ) ) [EOL] path_origin_resolved_directory = path_origin_resolved_directory . parent [EOL] path_to_test_directory = path_origin_resolved_directory / test_directory_name [EOL] return path_to_test_directory [EOL] [EOL] [EOL] def make_test_directory_and_subdirs_fully_accessible_by_current_user ( path_directory_name ) : [EOL] [docstring] [EOL] if lib_platform . is_platform_linux : [EOL] path_directory_name = str ( path_directory_name ) [EOL] subprocess . run ( [ [string] , [string] , [string] , getpass . getuser ( ) + [string] + getpass . getuser ( ) , path_directory_name ] , check = True ) [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , path_directory_name ] , check = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0