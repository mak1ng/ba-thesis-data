[comment] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] requirements = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] setup_requirements = [ [string] , [string] , [string] ] [EOL] [EOL] test_requirements = [ [string] , [string] , [string] ] [EOL] [EOL] with open ( [string] ) as infile : [EOL] long_description = infile . read ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( where = [string] , include = [ [string] ] ) , package_dir = { [string] : [string] } , package_data = { [string] : [ [string] ] } , include_package_data = True , install_requires = requirements , python_requires = [string] , zip_safe = False , keywords = [string] , entry_points = { [string] : [ [string] ] } , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , test_suite = [string] , tests_require = test_requirements , setup_requires = setup_requirements , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0
from typing import Any , Callable , List , Sequence , Optional , Dict [EOL] import builtins [EOL] import typing [EOL] import models [EOL] import base [EOL] import logging [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] import logging [EOL] from typing import Callable , Dict , List , Optional , Sequence , Tuple , Union [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . models import TrainCollection [EOL] from . session import HexpySession [EOL] [EOL] DateOrDates = Union [ Tuple [ str , str ] , Sequence [ Tuple [ str , str ] ] ] [EOL] MonitorOrMonitors = Union [ Sequence [ int ] , int ] [EOL] MetricOrMetrics = Union [ Sequence [ str ] , str ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class MonitorAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + [string] [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] , [string] , [string] , [string] , ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] self . METRICS = { [string] : self . volume , [string] : self . word_cloud , [string] : self . sentiment_and_categories , [string] : self . top_sources , [string] : self . interest_affinities , } [EOL] [EOL] def _aggregate_metrics ( self , monitor_id , date , metrics ) : [EOL] if isinstance ( metrics , list ) : [EOL] return { metric : self . METRICS [ metric ] ( monitor_id , date [ [number] ] , date [ [number] ] ) for metric in metrics } [EOL] elif metrics in self . METRICS : [EOL] metric = str ( metrics ) [EOL] return { metric : self . METRICS [ metric ] ( monitor_id , date [ [number] ] , date [ [number] ] ) } [EOL] else : [EOL] raise ValueError ( f" [string] { self . METRICS . keys ( ) }" ) [EOL] [EOL] def _aggregate_dates ( self , monitor_id , dates , metrics ) : [EOL] if not ( isinstance ( dates , list ) or isinstance ( dates , tuple ) ) : [EOL] raise ValueError ( [string] ) [EOL] elif isinstance ( dates [ [number] ] , list ) or isinstance ( dates [ [number] ] , tuple ) : [EOL] return [ { [string] : date [ [number] ] , [string] : date [ [number] ] , [string] : self . _aggregate_metrics ( monitor_id , date , metrics ) , } for date in dates ] [EOL] else : [EOL] return [ { [string] : dates [ [number] ] , [string] : dates [ [number] ] , [string] : self . _aggregate_metrics ( monitor_id , dates , metrics ) , } ] [EOL] [EOL] def aggregate ( self , monitor_ids , dates , metrics , ) : [EOL] [docstring] [EOL] if isinstance ( monitor_ids , list ) : [EOL] return [ { [string] : monitor_id , [string] : self . _aggregate_dates ( monitor_id , dates , metrics ) , } for monitor_id in monitor_ids ] [EOL] [EOL] elif isinstance ( monitor_ids , int ) : [EOL] return [ { [string] : monitor_ids , [string] : self . _aggregate_dates ( monitor_ids , dates , metrics ) , } ] [EOL] [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def details ( self , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id } ) ) [EOL] [EOL] def audit ( self , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id } ) ) [EOL] [EOL] def word_cloud ( self , monitor_id , start , end , filter_string = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : filter_string , } , ) ) [EOL] [EOL] def training_posts ( self , monitor_id , category = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : category } , ) ) [EOL] [EOL] def train_monitor ( self , monitor_id , items ) : [EOL] [docstring] [EOL] [EOL] if len ( items ) > [number] : [EOL] logger . info ( [string] ) [EOL] return self . batch_train ( monitor_id = monitor_id , items = items ) [EOL] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + [string] , params = { [string] : monitor_id } , json = { [string] : monitor_id , [string] : items [ [number] ] . categoryid , [string] : items . dict ( ) , } , ) ) [EOL] [EOL] def batch_train ( self , monitor_id , items ) : [EOL] [docstring] [EOL] [EOL] batch_responses = { } [EOL] for batch_num , batch in enumerate ( [ items [ i : i + [number] ] for i in range ( [number] , len ( items ) , [number] ) ] ) : [EOL] response = self . train_monitor ( monitor_id = monitor_id , items = batch ) [EOL] logger . info ( f" [string] { batch_num }" ) [EOL] batch_responses [ f" [string] { batch_num }" ] = response [EOL] return batch_responses [EOL] [EOL] def interest_affinities ( self , monitor_id , start , end , daily = False , document_source = None , ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : daily , [string] : document_source , } , ) ) [EOL] [EOL] def topics ( self , monitor_id , start , end , filter_string = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : filter_string , } , ) ) [EOL] [EOL] def topic_waves ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def top_sources ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def image_results ( self , monitor_id , start , end , object_type = [string] , top = [number] , ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : object_type , [string] : top , } , ) ) [EOL] [EOL] def volume ( self , monitor_id , start , end , group_by = [string] ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : group_by , } , ) ) [EOL] [EOL] def dayandtime ( self , monitor_id , start , end , aggregate_by_day = False , use_local_time = False , ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : aggregate_by_day , [string] : use_local_time , } , ) ) [EOL] [EOL] def sentiment_and_categories ( self , monitor_id , start , end , hide_excluded = False ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : hide_excluded , } , ) ) [EOL] [EOL] def posts ( self , monitor_id , start , end , filter_string = None , extend_limit = False , full_contents = False , geotagged = False , ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : filter_string , [string] : extend_limit , [string] : full_contents , [string] : geotagged , } , ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def age ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def ethnicity ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def gender ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def cities ( self , monitor_id , start , end , country ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : country , } , ) ) [EOL] [EOL] def states ( self , monitor_id , start , end , country ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end , [string] : country , } , ) ) [EOL] [EOL] def countries ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def twitter_authors ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def twitter_metrics ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def twitter_followers ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def twitter_sent_posts ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def twitter_engagement ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def facebook_admin_posts ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def facebook_likes ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def facebook_activity ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def instagram_top_hashtags ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def instagram_followers ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def instagram_sent_media ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL] [EOL] def instagram_activity ( self , monitor_id , start , end ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : end } , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Callable[...,base.JSONDict]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $typing.Sequence[builtins.str]$ 0 $MetricOrMetrics$ 0 0 0 0 0 0 $MetricOrMetrics$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 $typing.Sequence[builtins.str]$ 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $MetricOrMetrics$ 0 0 0 $MetricOrMetrics$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $MetricOrMetrics$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 $typing.Sequence[builtins.str]$ 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[base.JSONDict]$ 0 0 0 $builtins.int$ 0 $DateOrDates$ 0 $MetricOrMetrics$ 0 0 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $MetricOrMetrics$ 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 $DateOrDates$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $DateOrDates$ 0 $MetricOrMetrics$ 0 0 0 0 0 0 0 $typing.List[base.JSONDict]$ 0 0 0 $MonitorOrMonitors$ 0 $DateOrDates$ 0 $MetricOrMetrics$ 0 0 0 0 0 0 0 0 0 $MonitorOrMonitors$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DateOrDates$ 0 $MetricOrMetrics$ 0 0 0 0 0 0 $MonitorOrMonitors$ 0 0 0 0 0 0 $MonitorOrMonitors$ 0 0 0 0 0 0 0 0 0 0 $MonitorOrMonitors$ 0 0 0 0 0 0 0 $MonitorOrMonitors$ 0 $DateOrDates$ 0 $MetricOrMetrics$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $models.TrainCollection$ 0 0 0 0 0 0 0 0 0 $models.TrainCollection$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $models.TrainCollection$ 0 $models.TrainCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $models.TrainCollection$ 0 0 0 0 0 0 0 0 $models.TrainCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $models.TrainCollection$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $models.TrainCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $models.TrainCollection$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $models.TrainCollection$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import base [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] from typing import Any , Dict , List [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . session import HexpySession [EOL] [EOL] [EOL] class RealtimeAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + [string] [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def cashtags ( self , monitor_id , start = None , top = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : top } , ) ) [EOL] [EOL] def hashtags ( self , monitor_id , start = None , top = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : top } , ) ) [EOL] [EOL] def list ( self , team_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : team_id } ) ) [EOL] [EOL] def configure ( self , monitor_id , data ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + [string] , params = { [string] : monitor_id } , json = data ) ) [EOL] [EOL] def enable ( self , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id } ) ) [EOL] [EOL] def disbale ( self , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id } ) ) [EOL] [EOL] def detail ( self , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id } ) ) [EOL] [EOL] def retweets ( self , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id } ) ) [EOL] [EOL] def full_retweets ( self , monitor_id , start ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start } , ) ) [EOL] [EOL] def social_guids ( self , monitor_id , doc_type , start = None , received_after = None , maxresults = None , ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : received_after , [string] : doc_type , [string] : maxresults , } , ) ) [EOL] [EOL] def tweets ( self , monitor_id , start = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start } ) ) [EOL] [EOL] def full_tweets ( self , monitor_id , start = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start } ) ) [EOL] [EOL] def volume ( self , monitor_id , start = None , doc_type = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : doc_type } , ) ) [EOL] [EOL] def volume_by_sentiment ( self , monitor_id , start , doc_type ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : doc_type } , ) ) [EOL] [EOL] def volume_by_emotion ( self , monitor_id , start , doc_type ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : monitor_id , [string] : start , [string] : doc_type } , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0
import builtins [EOL] import base [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . session import HexpySession [EOL] [EOL] [EOL] class StreamsAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + [string] [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def posts ( self , stream_id , count = [number] ) : [EOL] [docstring] [EOL] if count > [number] : [EOL] count = [number] [EOL] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + f" [string] { stream_id } [string] " , params = { [string] : count } ) ) [EOL] [EOL] def stream_list ( self , team_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : team_id } ) ) [EOL] [EOL] def create_stream ( self , team_id , name ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE , json = { [string] : team_id , [string] : name } ) ) [EOL] [EOL] def delete_stream ( self , stream_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . delete ( self . TEMPLATE + f" [string] { stream_id }" ) ) [EOL] [EOL] def add_monitor_to_stream ( self , stream_id , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + f" [string] { stream_id } [string] { monitor_id }" ) ) [EOL] [EOL] def remove_monitor_from_stream ( self , stream_id , monitor_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . delete ( self . TEMPLATE + f" [string] { stream_id } [string] { monitor_id }" ) ) [EOL] [EOL] def update_stream ( self , stream_id , name ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + f" [string] { stream_id }" , json = { [string] : name } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
import session [EOL] import builtins [EOL] import base [EOL] import models [EOL] [docstring] [EOL] [EOL] import inspect [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . models import AnalysisRequest [EOL] from . session import HexpySession [EOL] [EOL] [EOL] class AnalysisAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + [string] [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def analysis_request ( self , request ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE , json = request ) ) [EOL] [EOL] def results ( self , request_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + f" [string] { request_id }" ) ) [EOL] [EOL] def image_analysis ( self , url ) : [EOL] [docstring] [EOL] [EOL] return handle_response ( self . session . get ( self . TEMPLATE . split ( [string] ) [ [number] ] + [string] , params = { [string] : url } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $models.AnalysisRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $models.AnalysisRequest$ 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import base [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] from typing import Any , Dict [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . session import HexpySession [EOL] [EOL] [EOL] class CustomAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session , endpoint ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + endpoint [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def get ( self , url_params = [string] , params = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + url_params , params = params ) ) [EOL] [EOL] def post ( self , url_params = [string] , params = None , data = None , ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + url_params , params = params , json = data ) ) [EOL] [EOL] def delete ( self , url_params = [string] , params = None ) : [EOL] [docstring] [EOL] return handle_response ( self . session . delete ( self . TEMPLATE + url_params , params = params ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0
import builtins [EOL] import base [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . session import HexpySession [EOL] [EOL] [EOL] class ActivityAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + [string] [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def monitor_creation ( self , organization_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : organization_id } ) ) [EOL] [EOL] def social_sites ( self , organization_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : organization_id } ) ) [EOL] [EOL] def user_activity ( self , organization_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : organization_id } ) ) [EOL] [EOL] def user_invitations ( self , organization_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : organization_id } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import models [EOL] import base [EOL] import logging [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] import logging [EOL] from typing import List [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . models import UploadCollection [EOL] from . session import HexpySession [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ContentUploadAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT + [string] [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] , [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def upload ( self , document_type , items , request_usage = True ) : [EOL] [docstring] [EOL] if len ( items ) > [number] : [EOL] logger . info ( [string] ) [EOL] return self . batch_upload ( document_type = document_type , items = items , request_usage = request_usage ) [EOL] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + [string] , params = { [string] : document_type } , json = { [string] : items . dict ( skip_defaults = True ) } , ) ) [EOL] [EOL] def batch_upload ( self , document_type , items , request_usage = True ) : [EOL] [docstring] [EOL] batch_responses = { } [EOL] for batch_num , batch in enumerate ( [ items [ i : i + [number] ] for i in range ( [number] , len ( items ) , [number] ) ] ) : [EOL] response = self . upload ( document_type , batch , request_usage ) [EOL] logger . info ( f" [string] { batch_num }" ) [EOL] batch_responses [ f" [string] { batch_num }" ] = response [EOL] return batch_responses [EOL] [EOL] def delete_content_batch ( self , document_type , batch ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + [string] , params = { [string] : document_type , [string] : batch } , ) ) [EOL] [EOL] def delete_content_items ( self , document_type , items ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + [string] , params = { [string] : document_type } , json = items , ) ) [EOL] [EOL] def delete_content_source ( self , document_type , remove_results ) : [EOL] [docstring] [EOL] return handle_response ( self . session . delete ( self . TEMPLATE + [string] , params = { [string] : document_type , [string] : remove_results } , ) ) [EOL] [EOL] def create_content_source ( self , content_type ) : [EOL] [docstring] [EOL] return handle_response ( self . session . post ( self . TEMPLATE + [string] , json = content_type ) ) [EOL] [EOL] def list_content_sources ( self , team_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : team_id } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $models.UploadCollection$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $models.UploadCollection$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $models.UploadCollection$ 0 $models.UploadCollection$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $models.UploadCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $models.UploadCollection$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $models.UploadCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $models.UploadCollection$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $typing.List[base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[base.JSONDict]$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
import builtins [EOL] import base [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] from . session import HexpySession [EOL] [EOL] [EOL] class MetadataAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session ) : [EOL] self . session = session . session [EOL] self . TEMPLATE = session . ROOT [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name not in [ [string] ] : [EOL] setattr ( self , name , rate_limited ( fn , session . MAX_CALLS , session . ONE_MINUTE ) ) [EOL] [EOL] def team_list ( self ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] ) ) [EOL] [EOL] def monitor_list ( self , team_id ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : team_id } ) ) [EOL] [EOL] def geography ( self ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] ) ) [EOL] [EOL] def states ( self , country ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : country } ) ) [EOL] [EOL] def cities ( self , country ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] , params = { [string] : country } ) ) [EOL] [EOL] def countries ( self ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] ) ) [EOL] [EOL] def image_classes ( self ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] ) ) [EOL] [EOL] def api_documentation ( self ) : [EOL] [docstring] [EOL] return handle_response ( self . session . get ( self . TEMPLATE + [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __version__ = [string] [EOL] [EOL] from . activity import ActivityAPI [EOL] from . analysis import AnalysisAPI [EOL] from . content_upload import ContentUploadAPI [EOL] from . custom import CustomAPI [EOL] from . metadata import MetadataAPI [EOL] from . monitor import MonitorAPI [EOL] from . project import Project [EOL] from . realtime import RealtimeAPI [EOL] from . session import HexpySession [EOL] from . streams import StreamsAPI [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Callable , Deque , Dict [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import threading [EOL] import logging [EOL] [docstring] [EOL] [EOL] import functools [EOL] import logging [EOL] import threading [EOL] import time [EOL] from collections import deque [EOL] from typing import Any , Callable , Deque , Dict [EOL] [EOL] from requests . models import Response [EOL] [EOL] JSONDict = Dict [ str , Any ] [EOL] [EOL] [EOL] def rate_limited ( func , max_calls , period ) : [EOL] [docstring] [EOL] calls = deque ( ) [EOL] [EOL] [comment] [EOL] lock = threading . RLock ( ) [EOL] logger = logging . getLogger ( func . __name__ ) [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] [docstring] [EOL] with lock : [EOL] if len ( calls ) >= max_calls : [EOL] until = time . time ( ) + period - ( calls [ - [number] ] - calls [ [number] ] ) [EOL] sleeptime = until - time . time ( ) [EOL] if sleeptime > [number] : [EOL] logger . info ( f" [string] { round ( sleeptime + [number] ) } [string] " ) [EOL] time . sleep ( sleeptime + [number] ) [EOL] while len ( calls ) > [number] : [EOL] calls . popleft ( ) [EOL] calls . append ( time . time ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] while ( calls [ - [number] ] - calls [ [number] ] ) >= period : [EOL] calls . popleft ( ) [EOL] [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def handle_response ( response ) : [EOL] [docstring] [EOL] [EOL] if not response . ok : [EOL] raise ValueError ( f" [string] { response . text }" ) [EOL] elif ( [string] in response . json ( ) ) and response . json ( ) [ [string] ] == [string] : [EOL] raise ValueError ( f" [string] { response . text }" ) [EOL] return response . json ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import Project [EOL] from typing import Any , AbstractSet , Callable , Union , Dict , Optional , Type [EOL] import builtins [EOL] import inspect [EOL] import typing [EOL] import src [EOL] import models [EOL] import base [EOL] import session [EOL] [docstring] [EOL] [EOL] import inspect [EOL] from enum import Enum [EOL] from functools import partial , wraps [EOL] from typing import Any , Callable , List , Optional , Union [EOL] [EOL] import pendulum [EOL] from pydantic import BaseModel , Extra , validator [EOL] [EOL] from . base import JSONDict [EOL] from . models import GenderEnum [EOL] from . monitor import MonitorAPI [EOL] from . session import HexpySession [EOL] [EOL] [EOL] def substitute_default ( func , monitor_id , start , end ) : [EOL] [docstring] [EOL] [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] [docstring] [EOL] return func ( monitor_id = monitor_id , start = start , end = end , * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] class MonitorTypeEnum ( str , Enum ) : [EOL] [docstring] [EOL] [EOL] BUZZ = [string] [EOL] OPINION = [string] [EOL] SOCIAL = [string] [EOL] [EOL] [EOL] class Project ( BaseModel ) : [EOL] [docstring] [EOL] [EOL] id = ... [EOL] name = ... [EOL] description = ... [EOL] type = ... [EOL] enabled = ... [EOL] resultsStart = ... [EOL] resultsEnd = ... [EOL] keywords = ... [EOL] languages = ... [EOL] geolocations = ... [EOL] gender = None [EOL] sources = ... [EOL] timezone = ... [EOL] teamName = ... [EOL] tags = ... [EOL] subfilters = ... [EOL] categories = ... [EOL] emotions = ... [EOL] session = ... [EOL] [EOL] class Config : [EOL] extra = Extra . allow [EOL] arbitrary_types_allowed = True [EOL] [EOL] @ validator ( [string] , pre = True ) def validate_empty_gender ( cls , value ) : [EOL] [docstring] [EOL] if value : [EOL] return value [EOL] else : [EOL] return None [EOL] [EOL] @ classmethod def get_from_monitor_id ( cls , session , monitor_id ) : [EOL] [docstring] [EOL] client = MonitorAPI ( session ) [EOL] details = client . details ( monitor_id ) [EOL] details [ [string] ] = session [EOL] [EOL] return cls ( ** details ) [EOL] [EOL] def __init__ ( self , ** data ) : [EOL] super ( ) . __init__ ( ** data ) [EOL] client = MonitorAPI ( self . session ) [EOL] self . days = [ day . to_date_string ( ) for day in pendulum . period ( self . resultsStart , self . resultsEnd ) . range ( [string] ) ] [EOL] [EOL] for name , fn in inspect . getmembers ( client , inspect . isfunction ) : [EOL] [EOL] args_spec = inspect . signature ( fn ) [EOL] args = args_spec . parameters . keys ( ) [EOL] if [string] in args and [string] in args and [string] in args : [EOL] if name != [string] : [EOL] setattr ( self , name , substitute_default ( fn , monitor_id = self . id , start = self . days [ [number] ] , end = self . days [ - [number] ] , ) , ) [EOL] else : [EOL] setattr ( self , [string] + name , substitute_default ( fn , monitor_id = self . id , start = self . days [ [number] ] , end = self . days [ - [number] ] , ) , ) [EOL] elif [string] in args : [EOL] setattr ( self , name , partial ( fn , monitor_id = self . id ) ) [EOL] [EOL] else : [EOL] setattr ( self , name , fn ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . days ) [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return f" [string] { self . name } [string] { self . resultsStart } [string] { self . resultsEnd } [string] " [EOL] [EOL] def __iter__ ( self ) : [comment] [EOL] for day in self . days : [EOL] yield day [EOL] [EOL] def __getitem__ ( self , index ) : [comment] [EOL] days = self . days [ index ] [EOL] return days [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $MonitorTypeEnum$ 0 0 0 $builtins.bool$ 0 0 0 $pendulum.DateTime$ 0 0 0 $pendulum.DateTime$ 0 0 0 $builtins.str$ 0 0 0 $base.JSONDict$ 0 0 0 $base.JSONDict$ 0 0 0 $typing.Optional[models.GenderEnum]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[base.JSONDict]$ 0 0 0 $typing.List[base.JSONDict]$ 0 0 0 $typing.List[base.JSONDict]$ 0 0 0 $session.HexpySession$ 0 0 0 0 0 0 0 0 $typing.Type[src.hexpy.project.Project.Config]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,None]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $"Project"$ 0 0 0 $Project.session.HexpySession$ 0 $builtins.int$ 0 0 0 0 0 $src.hexpy.monitor.MonitorAPI$ 0 0 0 $Project.session.HexpySession$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $src.hexpy.monitor.MonitorAPI$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.int$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $Project.session.HexpySession$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $src.hexpy.monitor.MonitorAPI$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.hexpy.monitor.MonitorAPI$ 0 0 0 0 0 0 0 0 $inspect.Signature$ 0 0 0 0 0 0 0 0 $typing.AbstractSet[builtins.str]$ 0 $inspect.Signature$ 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0
from typing import Type , Any , Dict [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import src [EOL] import pathlib [EOL] import base [EOL] import logging [EOL] [docstring] [EOL] [EOL] import inspect [EOL] import json [EOL] import logging [EOL] from getpass import getpass [EOL] from pathlib import Path [EOL] [EOL] import requests [EOL] [EOL] from . base import JSONDict , handle_response , rate_limited [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class HexpySession : [EOL] [docstring] [EOL] [EOL] TOKEN_FILE = Path . home ( ) / [string] / [string] [EOL] [EOL] ROOT = [string] [EOL] [EOL] ONE_MINUTE = [number] [EOL] MAX_CALLS = [number] [EOL] [EOL] def __init__ ( self , token ) : [EOL] for name , fn in inspect . getmembers ( self , inspect . ismethod ) : [EOL] if name == [string] : [EOL] setattr ( self , name , rate_limited ( fn , self . MAX_CALLS , self . ONE_MINUTE ) ) [EOL] [EOL] self . auth = { [string] : token } [EOL] self . session = requests . Session ( ) [EOL] self . session . params = self . auth [EOL] [EOL] @ classmethod def _get_token ( cls , username , password , no_expiration = False , force = False , ) : [EOL] [docstring] [EOL] return handle_response ( requests . Session ( ) . get ( cls . ROOT + [string] , params = { [string] : username , [string] : password , [string] : str ( no_expiration ) . lower ( ) , [string] : str ( force ) . lower ( ) , } , ) ) [EOL] [EOL] def save_token ( self , path = None ) : [EOL] [docstring] [EOL] if not path : [EOL] token_path = self . TOKEN_FILE [EOL] else : [EOL] token_path = Path ( path ) [EOL] if not token_path . exists ( ) : [EOL] parent = token_path . parent [EOL] if not parent . exists ( ) : [EOL] token_path . parent . mkdir ( ) [EOL] with open ( token_path , [string] ) as outfile : [EOL] json . dump ( self . auth , outfile , indent = [number] ) [EOL] [EOL] @ classmethod def login ( cls , username , password = None , no_expiration = False , force = False , ) : [EOL] [docstring] [EOL] if password is None : [EOL] password = getpass ( prompt = [string] ) [EOL] [EOL] auth = cls . _get_token ( username , password , no_expiration , force ) [EOL] return cls ( auth [ [string] ] ) [EOL] [EOL] @ classmethod def load_auth_from_file ( cls , path = None ) : [EOL] [docstring] [EOL] try : [EOL] if not path : [EOL] cred_path = cls . TOKEN_FILE [EOL] else : [EOL] cred_path = Path ( path ) [EOL] with open ( cred_path ) as infile : [EOL] auth = json . load ( infile ) [EOL] logger . info ( f" [string] { json . dumps ( auth ) }" ) [EOL] return cls ( token = auth [ [string] ] ) [EOL] except IOError : [EOL] raise IOError ( f" [string] { cred_path } [string] " ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] self . session . close ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] [docstring] [EOL] return self [EOL] [EOL] def __exit__ ( self ) : [EOL] [docstring] [EOL] self . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.JSONDict$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"HexpySession"$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $"HexpySession"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"HexpySession"$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import pandas [EOL] import builtins [EOL] import typing [EOL] import hexpy [EOL] [docstring] [EOL] [EOL] import json [EOL] from typing import List [EOL] [EOL] import pandas as pd [EOL] import pytest [EOL] from pandas . io . json import json_normalize [EOL] [EOL] from hexpy import HexpySession [EOL] from hexpy . base import JSONDict [EOL] [EOL] [EOL] @ pytest . fixture def upload_items ( ) : [EOL] [docstring] [EOL] return [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] [EOL] @ pytest . fixture def upload_dataframe ( upload_items ) : [EOL] [docstring] [EOL] return json_normalize ( upload_items ) [EOL] [EOL] [EOL] @ pytest . fixture def duplicate_items ( upload_items ) : [EOL] [docstring] [EOL] upload_items [ [number] ] [ [string] ] = upload_items [ [number] ] [ [string] ] [EOL] [EOL] return upload_items [EOL] [EOL] [EOL] @ pytest . fixture def train_items ( ) : [EOL] [docstring] [EOL] return [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , ] [EOL] [EOL] [EOL] @ pytest . fixture def train_dataframe ( train_items ) : [EOL] [docstring] [EOL] return pd . DataFrame . from_records ( train_items ) [EOL] [EOL] [EOL] @ pytest . fixture def fake_session ( ) : [EOL] [docstring] [EOL] return HexpySession ( token = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def posts_json ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] posts = json . load ( infile ) [EOL] [EOL] return posts [EOL] [EOL] [EOL] @ pytest . fixture def posts_df ( ) : [EOL] [docstring] [EOL] df = pd . read_csv ( [string] ) [EOL] return df [EOL] [EOL] [EOL] @ pytest . fixture def json_documentation ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] return json . load ( infile ) [EOL] [EOL] [EOL] @ pytest . fixture def markdown_documentation ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] return infile . read ( ) [EOL] [EOL] [EOL] @ pytest . fixture def geography_json ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] return json . load ( infile ) [EOL] [EOL] [EOL] @ pytest . fixture def results_json ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] return json . load ( infile ) [EOL] [EOL] [EOL] @ pytest . fixture def monitor_details_json ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] return json . load ( infile ) [EOL] [EOL] [EOL] @ pytest . fixture def analysis_request_dict ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as infile : [EOL] return json . load ( infile ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[hexpy.base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[hexpy.base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[hexpy.base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.HexpySession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Callable [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import _pytest [EOL] import hexpy [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] from typing import Callable [EOL] [EOL] import pytest [EOL] import requests [EOL] import responses [EOL] from _pytest . capture import CaptureFixture [EOL] [EOL] from hexpy . base import JSONDict , handle_response , rate_limited [EOL] [EOL] [EOL] @ responses . activate def test_response_error_code ( ) : [EOL] [docstring] [EOL] [EOL] responses . add ( responses . GET , [string] , json = { [string] : [string] } , status = [number] , ) [EOL] [EOL] response = requests . get ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as e : [EOL] handle_response ( response ) [EOL] assert e . value . args [ [number] ] == [string] [EOL] [EOL] [EOL] @ responses . activate def test_response_error_status ( ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , [string] , json = { [string] : [string] } , status = [number] , ) [EOL] [EOL] response = requests . get ( [string] ) [EOL] assert response . ok [EOL] [EOL] with pytest . raises ( ValueError ) as e : [EOL] handle_response ( response ) [EOL] assert e . value . args [ [number] ] == [string] [EOL] [EOL] [EOL] @ responses . activate def test_response_status_ok ( ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , [string] , json = { [string] : [string] } , status = [number] , ) [EOL] [EOL] response = requests . get ( [string] ) [EOL] results = handle_response ( response ) [EOL] [EOL] assert results == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . fixture def base_func ( ) : [EOL] [docstring] [EOL] [EOL] def some_function ( message = [string] ) : [EOL] [docstring] [EOL] return { [string] : message } [EOL] [EOL] return some_function [EOL] [EOL] [EOL] def test_rate_limiting ( caplog , base_func ) : [EOL] [docstring] [EOL] [EOL] modified_func = rate_limited ( base_func , max_calls = [number] , period = [number] ) [EOL] [EOL] with caplog . at_level ( logging . INFO ) : [EOL] for _ in range ( [number] ) : [EOL] modified_func ( ) [EOL] [EOL] assert caplog . records [ [number] ] . msg == [string] [EOL] [EOL] [EOL] def test_rate_limiting_window ( caplog , base_func ) : [EOL] [docstring] [EOL] [EOL] modified_func = rate_limited ( base_func , max_calls = [number] , period = [number] ) [EOL] [EOL] with caplog . at_level ( logging . INFO ) : [EOL] for _ in range ( [number] ) : [EOL] modified_func ( ) [EOL] time . sleep ( [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],hexpy.base.JSONDict]$ 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import click [EOL] import builtins [EOL] import typing [EOL] import pandas [EOL] import pathlib [EOL] import _pytest [EOL] import hexpy [EOL] [docstring] [EOL] [EOL] import json [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] import pandas as pd [EOL] import pytest [EOL] import responses [EOL] from _pytest . monkeypatch import MonkeyPatch [EOL] from click . testing import CliRunner [EOL] from pydantic import ValidationError [EOL] [EOL] from hexpy import HexpySession , hexpy [EOL] from hexpy . base import JSONDict [EOL] from hexpy . hexpy import cli , docs_to_text , helpful_validation_error , posts_json_to_df [EOL] from hexpy . models import UploadCollection [EOL] [EOL] [EOL] def fake_login ( force = False , expiration = True ) : [EOL] [docstring] [EOL] return HexpySession ( token = [string] ) [EOL] [EOL] [EOL] def test_cli_help ( ) : [EOL] [docstring] [EOL] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] ] ) [EOL] assert ( result . output == [string] ) [EOL] [EOL] [EOL] def test_posts_json_to_df ( posts_json , posts_df ) : [EOL] [docstring] [EOL] df = posts_json_to_df ( posts_json , images = True ) [EOL] assert df . equals ( posts_df [ df . columns ] ) [EOL] [EOL] [EOL] def test_format_documentation ( json_documentation , markdown_documentation ) : [EOL] [docstring] [EOL] docs = docs_to_text ( json_documentation , mode = [string] ) [EOL] assert markdown_documentation == docs [EOL] [EOL] [EOL] @ responses . activate def test_export ( posts_json , monkeypatch ) : [EOL] [docstring] [EOL] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = { [string] : posts_json } , status = [number] , ) [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = { [string] : [string] , [string] : [string] , [string] : [string] } , status = [number] , ) [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] , [string] , [string] , [string] ] ) [EOL] assert result . output . strip ( ) == [string] . join ( [ json . dumps ( x ) for x in posts_json ] ) [EOL] [EOL] [EOL] @ responses . activate def test_api_documentation ( json_documentation , monkeypatch ) : [EOL] [docstring] [EOL] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = json_documentation , status = [number] , ) [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] ] ) [EOL] assert result . output . strip ( ) == json . dumps ( json_documentation ) [EOL] [EOL] [EOL] @ responses . activate def test_metadata_geography ( geography_json , monkeypatch ) : [EOL] [docstring] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = geography_json , status = [number] , ) [EOL] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] , [string] ] ) [EOL] assert result . output . strip ( ) == json . dumps ( geography_json ) [EOL] [EOL] [EOL] @ responses . activate def test_stream ( posts_json , monkeypatch ) : [EOL] [docstring] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = { [string] : posts_json , [string] : [number] } , status = [number] , ) [EOL] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] , [string] , [string] , [string] ] ) [EOL] assert result . output . strip ( ) == [string] . join ( [ json . dumps ( x ) for x in posts_json ] ) [EOL] [EOL] [EOL] @ responses . activate def test_upload ( upload_dataframe , monkeypatch , tmp_path ) : [EOL] [docstring] [EOL] [EOL] tmp_file = tmp_path / [string] [EOL] [EOL] upload_dataframe . to_csv ( tmp_file , index = False ) [EOL] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . POST , HexpySession . ROOT + [string] , json = { [string] : [string] } , status = [number] , ) [EOL] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] , [string] , [string] , str ( tmp_file ) ] ) [EOL] assert result . output . strip ( ) == json . dumps ( { [string] : [string] } , indent = [number] ) [EOL] [EOL] [EOL] @ responses . activate def test_train ( train_dataframe , monkeypatch , tmp_path ) : [EOL] [docstring] [EOL] tmp_file = tmp_path / [string] [EOL] [EOL] train_dataframe . to_csv ( tmp_file , index = False ) [EOL] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . POST , HexpySession . ROOT + [string] , json = { [string] : [string] } , status = [number] , ) [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = { [string] : [ { [string] : [string] , [string] : [number] } ] , [string] : [string] , } , status = [number] , ) [EOL] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] , str ( tmp_file ) , [string] ] ) [EOL] assert ( result . output . strip ( ) == [string] ) [EOL] [EOL] [EOL] @ responses . activate def test_results ( results_json , monkeypatch ) : [EOL] [docstring] [EOL] monkeypatch . setattr ( hexpy , [string] , fake_login ) [EOL] [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = results_json [ [string] ] [ [string] ] , status = [number] , ) [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = results_json [ [string] ] [ [string] ] , status = [number] , ) [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = { [string] : results_json [ [string] ] , [string] : results_json [ [string] ] , } , status = [number] , ) [EOL] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli , [ [string] , [string] , [string] , [string] ] ) [EOL] assert result . output . strip ( ) == json . dumps ( results_json ) [EOL] [EOL] [EOL] def test_helpful_error_item ( upload_items ) : [EOL] [docstring] [EOL] del upload_items [ [number] ] [ [string] ] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] collection = UploadCollection ( items = upload_items ) [comment] [EOL] [EOL] result = helpful_validation_error ( e . value . errors ( ) ) [EOL] [EOL] assert ( result == [string] ) [EOL] [EOL] [EOL] def test_helpful_error_collection ( duplicate_items ) : [EOL] [docstring] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] collection = UploadCollection ( items = duplicate_items ) [comment] [EOL] [EOL] result = helpful_validation_error ( e . value . errors ( ) ) [EOL] [EOL] assert ( result == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.hexpy.HexpySession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import pandas [EOL] import typing [EOL] import _pytest [EOL] import hexpy [EOL] [docstring] [EOL] import logging [EOL] from typing import List [EOL] [EOL] import pandas as pd [EOL] import pendulum [EOL] import pytest [EOL] import responses [EOL] from _pytest . capture import CaptureFixture [EOL] from pydantic import ValidationError [EOL] [EOL] from hexpy import ContentUploadAPI , HexpySession , MonitorAPI , Project [EOL] from hexpy . base import JSONDict [EOL] from hexpy . models import ( AnalysisRequest , TrainCollection , TrainItem , UploadCollection , UploadItem , ) [EOL] [EOL] [EOL] def test_correct_upload_item ( upload_items ) : [EOL] [docstring] [EOL] validated = UploadItem ( ** upload_items [ [number] ] ) [EOL] assert validated . dict ( ) == upload_items [ [number] ] [EOL] [EOL] [EOL] def test_upload_from_df ( upload_items , upload_dataframe ) : [EOL] [docstring] [EOL] [EOL] validated = UploadCollection . from_dataframe ( upload_dataframe ) [EOL] assert validated . dict ( ) == upload_items [EOL] [EOL] [EOL] def test_upload_to_df ( upload_dataframe ) : [EOL] [docstring] [EOL] validated = UploadCollection . from_dataframe ( upload_dataframe ) [EOL] assert upload_dataframe . equals ( validated . to_dataframe ( ) [ upload_dataframe . columns ] ) [EOL] [EOL] [EOL] def test_upload_iteration ( upload_items ) : [EOL] [docstring] [EOL] validated = UploadCollection ( items = upload_items ) [EOL] for i , item in zip ( range ( len ( validated ) ) , validated ) : [EOL] assert validated [ i ] == item [EOL] [EOL] [EOL] @ pytest . fixture def invalid_item ( upload_items ) : [EOL] [docstring] [EOL] altered = upload_items [ [number] ] [EOL] altered [ [string] ] = [string] [EOL] altered [ [string] ] = [string] [EOL] altered [ [string] ] = [string] [EOL] return altered [EOL] [EOL] [EOL] def test_wrong_upload_item ( invalid_item ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid = UploadItem ( ** invalid_item ) [comment] [EOL] assert e . value . errors ( ) == [ { [string] : { [string] : [number] } , [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] [EOL] @ pytest . fixture def only_url_item ( upload_items ) : [EOL] [docstring] [EOL] altered = upload_items [ [number] ] [EOL] del altered [ [string] ] [EOL] return altered [EOL] [EOL] [EOL] def test_only_url ( only_url_item ) : [EOL] [docstring] [EOL] validated = UploadItem ( ** only_url_item ) [EOL] assert validated . dict ( ) == only_url_item [EOL] [EOL] [EOL] @ pytest . fixture def only_guid_item ( upload_items ) : [EOL] [docstring] [EOL] altered = upload_items [ [number] ] [EOL] del altered [ [string] ] [EOL] return altered [EOL] [EOL] [EOL] def test_only_guid ( only_guid_item ) : [EOL] [docstring] [EOL] validated = UploadItem ( ** only_guid_item ) [EOL] assert validated . dict ( ) == only_guid_item [EOL] [EOL] [EOL] @ pytest . fixture def no_url_or_guid_item ( upload_items ) : [EOL] [docstring] [EOL] altered = upload_items [ [number] ] [EOL] altered [ [string] ] = None [EOL] altered [ [string] ] = None [EOL] return altered [EOL] [EOL] [EOL] def test_missing_url_and_guid ( no_url_or_guid_item ) : [EOL] [docstring] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid = UploadItem ( ** no_url_or_guid_item ) [comment] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] @ pytest . fixture def too_many_custom_fields ( upload_items ) : [EOL] [docstring] [EOL] altered = upload_items [ [number] ] [EOL] altered [ [string] ] = { str ( x ) : str ( x ) for x in range ( [number] ) } [EOL] return altered [EOL] [EOL] [EOL] def test_too_many_custom_fields ( too_many_custom_fields ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid = UploadItem ( ** too_many_custom_fields ) [comment] [EOL] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] @ pytest . fixture def long_custom_fields ( upload_items ) : [EOL] [docstring] [EOL] altered = upload_items [ [number] ] [EOL] altered [ [string] ] = { [string] : [string] * [number] } [EOL] return altered [EOL] [EOL] [EOL] def test_long_custom_fields ( long_custom_fields ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid = UploadItem ( ** long_custom_fields ) [comment] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] def test_detect_duplicate_upload_items ( duplicate_items ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid_collection = UploadCollection ( items = duplicate_items ) [comment] [EOL] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] def test_unique_upload_items ( upload_items ) : [EOL] [docstring] [EOL] validated = UploadCollection ( items = upload_items ) [EOL] assert validated . dict ( ) == upload_items [EOL] [EOL] [EOL] def test_correct_train_item ( train_items ) : [EOL] [docstring] [EOL] validated = TrainItem ( ** train_items [ [number] ] ) [EOL] assert validated . dict ( ) == train_items [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture def invalid_train_item ( train_items ) : [EOL] [docstring] [EOL] altered = train_items [ [number] ] [EOL] altered [ [string] ] = [string] [EOL] altered [ [string] ] = [string] [EOL] altered [ [string] ] = [string] [EOL] altered [ [string] ] = None [EOL] return altered [EOL] [EOL] [EOL] def test_wrong_train_item ( invalid_train_item ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid = TrainItem ( ** invalid_train_item ) [comment] [EOL] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , { [string] : { [string] : [number] } , [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] [EOL] @ pytest . fixture def duplicate_train_items ( train_items ) : [EOL] [docstring] [EOL] train_items [ [number] ] [ [string] ] = train_items [ [number] ] [ [string] ] [EOL] return train_items [EOL] [EOL] [EOL] def test_detect_duplicate_train_items ( duplicate_train_items ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid_collection = TrainCollection ( items = duplicate_train_items ) [comment] [EOL] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] @ pytest . fixture def mixed_train_items ( train_items ) : [EOL] [docstring] [EOL] train_items [ [number] ] [ [string] ] = [number] [EOL] return train_items [EOL] [EOL] [EOL] def test_mulitple_category_id ( mixed_train_items ) : [EOL] [docstring] [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid_collection = TrainCollection ( items = mixed_train_items ) [comment] [EOL] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] def test_train_from_df ( train_dataframe , train_items ) : [EOL] [docstring] [EOL] [EOL] validated = TrainCollection . from_dataframe ( train_dataframe ) [EOL] assert validated == TrainCollection ( items = train_items ) [EOL] [EOL] [EOL] def test_train_to_df ( train_dataframe , train_items ) : [EOL] [docstring] [EOL] [EOL] validated = TrainCollection ( items = train_items ) [EOL] assert train_dataframe . equals ( validated . to_dataframe ( ) [ train_dataframe . columns ] ) [EOL] [EOL] [EOL] def test_train_iteration ( train_items ) : [EOL] [docstring] [EOL] validated = TrainCollection ( items = train_items ) [EOL] for i , item in zip ( range ( len ( validated ) ) , validated ) : [EOL] assert validated [ i ] == item [EOL] [EOL] [EOL] def test_train_slice ( train_items ) : [EOL] [docstring] [EOL] validated = TrainCollection ( items = train_items ) [EOL] [EOL] assert validated [ [number] : [number] ] == validated [EOL] [EOL] [EOL] def test_unique_train_items ( train_items ) : [EOL] [docstring] [EOL] validated = TrainCollection ( items = train_items ) [EOL] assert validated . dict ( ) == train_items [EOL] [EOL] [EOL] @ pytest . fixture def large_upload_collection ( upload_items ) : [EOL] [docstring] [EOL] items = [ ] [EOL] [EOL] item = upload_items [ [number] ] [EOL] for i in range ( [number] ) : [EOL] copy = item . copy ( ) [EOL] copy [ [string] ] = copy [ [string] ] . replace ( [string] , f" [string] { i }" ) [EOL] items . append ( copy ) [EOL] [EOL] collection = UploadCollection ( items = items ) [EOL] return collection [EOL] [EOL] [EOL] @ responses . activate def test_batch_upload ( large_upload_collection , fake_session , caplog , ) : [EOL] [docstring] [EOL] responses . add ( responses . POST , HexpySession . ROOT + [string] , json = { } , status = [number] ) [EOL] [EOL] client = ContentUploadAPI ( fake_session ) [EOL] [EOL] with caplog . at_level ( logging . INFO ) : [EOL] response = client . upload ( document_type = [number] , items = large_upload_collection , request_usage = True ) [EOL] [EOL] assert ( caplog . records [ [number] ] . msg == [string] ) [EOL] [EOL] assert response == { [string] : { } , [string] : { } , [string] : { } , [string] : { } } [EOL] [EOL] [EOL] @ pytest . fixture def large_train_collection ( train_items ) : [EOL] [docstring] [EOL] items = [ ] [EOL] [EOL] item = train_items [ [number] ] [EOL] for i in range ( [number] ) : [EOL] copy = item . copy ( ) [EOL] copy [ [string] ] = copy [ [string] ] . replace ( [string] , f" [string] { i }" ) [EOL] items . append ( copy ) [EOL] [EOL] collection = TrainCollection ( items = items ) [EOL] return collection [EOL] [EOL] [EOL] @ responses . activate def test_batch_train ( large_train_collection , fake_session , caplog , ) : [EOL] [docstring] [EOL] responses . add ( responses . POST , HexpySession . ROOT + [string] , json = { } , status = [number] ) [EOL] [EOL] client = MonitorAPI ( fake_session ) [EOL] [EOL] with caplog . at_level ( logging . INFO ) : [EOL] response = client . train_monitor ( monitor_id = [number] , items = large_train_collection ) [EOL] [EOL] assert ( caplog . records [ [number] ] . msg == [string] ) [EOL] [EOL] assert response == { [string] : { } , [string] : { } , [string] : { } } [EOL] [EOL] [EOL] @ responses . activate def test_project ( fake_session , monitor_details_json ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , HexpySession . ROOT + [string] , json = monitor_details_json , status = [number] , ) [EOL] project = Project . get_from_monitor_id ( fake_session , [number] ) [EOL] [EOL] assert len ( project ) == [number] [EOL] assert len ( [ day for day in project ] ) == [number] [EOL] assert len ( [ day for day in project [ : [number] ] ] ) == [number] [EOL] [EOL] [EOL] def test_valid_analysis_request ( analysis_request_dict ) : [EOL] [docstring] [EOL] [EOL] request = AnalysisRequest ( ** analysis_request_dict ) [EOL] [EOL] assert request . dict ( ) == analysis_request_dict [EOL] [EOL] [EOL] @ pytest . fixture def invalid_request_range ( analysis_request_dict ) : [EOL] [EOL] end = pendulum . parse ( analysis_request_dict [ [string] ] ) [EOL] new_date = end . add ( days = [number] ) [EOL] analysis_request_dict [ [string] ] = new_date . to_iso8601_string ( ) [EOL] return analysis_request_dict [EOL] [EOL] [EOL] def test_invalid_analysis_date_range ( invalid_request_range ) : [EOL] [EOL] with pytest . raises ( ValidationError ) as e : [EOL] invalid_request = AnalysisRequest ( ** invalid_request_range ) [comment] [EOL] [EOL] assert e . value . errors ( ) == [ { [string] : ( [string] , ) , [string] : [string] , [string] : [string] , } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[hexpy.base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[hexpy.base.JSONDict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.models.UploadCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.models.TrainCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexpy.base.JSONDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import responses [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] import responses [EOL] [EOL] from hexpy import HexpySession [EOL] [EOL] [EOL] @ pytest . fixture def mocked_authenticate ( ) : [EOL] [docstring] [EOL] with responses . RequestsMock ( ) as rsps : [EOL] [EOL] rsps . add ( responses . GET , HexpySession . ROOT + [string] , json = { [string] : [string] } , status = [number] , ) [EOL] yield rsps [EOL] [EOL] [EOL] def test_login ( mocked_authenticate ) : [EOL] [docstring] [EOL] session = HexpySession . login ( username = [string] , password = [string] ) [EOL] [EOL] assert session . auth == { [string] : [string] } [EOL] [EOL] [EOL] def test_load_auth ( tmp_path ) : [EOL] [docstring] [EOL] HexpySession . TOKEN_FILE = tmp_path / [string] / [string] [EOL] [EOL] directory = tmp_path / [string] [EOL] [EOL] directory . mkdir ( ) [EOL] [EOL] token_file = directory / [string] [EOL] [EOL] with open ( token_file , [string] ) as outfile : [EOL] json . dump ( { [string] : [string] } , outfile ) [EOL] [EOL] session = HexpySession . load_auth_from_file ( ) [EOL] session2 = HexpySession . load_auth_from_file ( str ( token_file ) ) [EOL] [EOL] assert session . auth == { [string] : [string] } [EOL] assert session2 . auth == session . auth [EOL] [EOL] [EOL] def test_save_token ( mocked_authenticate , tmp_path ) : [EOL] [docstring] [EOL] HexpySession . TOKEN_FILE = tmp_path / [string] / [string] [EOL] session = HexpySession . login ( username = [string] , password = [string] ) [EOL] [EOL] session . save_token ( ) [EOL] [EOL] with open ( tmp_path / [string] / [string] ) as infile : [EOL] auth = json . load ( infile ) [EOL] [EOL] assert auth == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0