[comment] [EOL] from typing import List , Optional , Match , Any [EOL] import pathlib [EOL] import typing [EOL] import re [EOL] import sys [EOL] [EOL] from setuptools import setup [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] sys . exit ( [string] ) [EOL] [EOL] from pathlib import Path [comment] [EOL] [EOL] [EOL] def get_version ( string ) : [EOL] [docstring] [EOL] flags = re . S [EOL] pattern = [string] [EOL] match = re . match ( pattern = pattern , string = string , flags = flags ) [EOL] [EOL] if match : [EOL] return match . group ( [number] ) [EOL] [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] here = Path ( __name__ ) . cwd ( ) [EOL] readme = ( here / [string] ) . read_text ( ) [EOL] version = get_version ( ( here / [string] ) . read_text ( ) ) [EOL] [EOL] [comment] [EOL] install_reqs = [ [string] , ] [EOL] test_reqs = [ [string] , [string] , [string] , [string] , ] [EOL] docs_reqs = [ [string] , [string] , ] [EOL] dev_reqs = test_reqs + docs_reqs [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , long_description = readme , author = [string] , author_email = [string] , url = [string] , install_requires = install_reqs , license = [string] , py_modules = [ [string] ] , keywords = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , test_suite = [string] , tests_require = test_reqs , python_requires = [string] , extras_require = { [string] : dev_reqs , [string] : docs_reqs , [string] : test_reqs , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Type , DefaultDict , Union , Any , List , Callable , NoReturn , Tuple , Dict , Optional [EOL] import inspect [EOL] import builtins [EOL] import layabout [EOL] import logging [EOL] import slackclient [EOL] import typing [EOL] import os [EOL] import time [EOL] import random [EOL] import logging [EOL] import warnings [EOL] from typing import ( Any , Callable , DefaultDict , List , NoReturn , Optional , Tuple , Union , ) [EOL] from inspect import signature , Signature [EOL] from functools import singledispatch [EOL] from collections import defaultdict [EOL] [EOL] from slackclient import SlackClient [EOL] [EOL] warnings . warn ( ( [string] [string] [string] ) , category = DeprecationWarning , stacklevel = [number] , ) [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL] [EOL] [comment] [EOL] _Handlers = DefaultDict [ str , List [ Tuple [ Callable , dict ] ] ] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class LayaboutError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class MissingToken ( LayaboutError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FailedConnection ( LayaboutError , ConnectionError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class EnvVar ( str ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Token ( str ) : [EOL] [docstring] [EOL] [EOL] [EOL] class _SlackClientWrapper : [EOL] [docstring] [EOL] def __init__ ( self , slack , retries , backoff ) : [EOL] self . inner = slack [EOL] self . retries = retries [EOL] self . backoff = backoff [EOL] [EOL] [comment] [EOL] self . connect_with_retry ( ) [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] self . inner . rtm_connect ( ) [EOL] [EOL] def is_connected ( self ) : [EOL] [docstring] [EOL] return getattr ( self . inner . server . websocket , [string] , False ) [EOL] [EOL] def connect_with_retry ( self ) : [EOL] [docstring] [EOL] if self . is_connected ( ) : [EOL] log . debug ( [string] ) [EOL] return [EOL] [EOL] for retry in range ( [number] , self . retries + [number] ) : [EOL] self . connect ( ) [EOL] if self . is_connected ( ) : [EOL] log . debug ( [string] ) [EOL] return [EOL] else : [EOL] interval = self . backoff ( retry ) [EOL] log . debug ( [string] , interval ) [EOL] time . sleep ( interval ) [EOL] [EOL] raise FailedConnection ( [string] ) [EOL] [EOL] def fetch_events ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . inner . rtm_read ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] except TimeoutError : [EOL] log . debug ( [string] [string] ) [EOL] self . connect_with_retry ( ) [EOL] return [ ] [EOL] [EOL] [EOL] class Layabout : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . _env_var = EnvVar ( [string] ) [EOL] self . _slack = None [EOL] self . _handlers = defaultdict ( list ) [EOL] [EOL] def handle ( self , type , * , kwargs = None ) : [EOL] [docstring] [EOL] def decorator ( fn ) : [EOL] [comment] [EOL] sig = signature ( fn ) [EOL] num_params = len ( sig . parameters ) [EOL] if num_params < [number] : [EOL] raise TypeError ( _format_parameter_error_message ( fn . __name__ , sig , num_params ) ) [EOL] [EOL] [comment] [EOL] self . _handlers [ type ] . append ( ( fn , kwargs or { } ) ) [EOL] return fn [EOL] [EOL] return decorator [EOL] [EOL] def _ensure_slack ( self , connector , retries , backoff ) : [EOL] [docstring] [EOL] connector = self . _env_var if connector is None else connector [EOL] slack = _create_slack ( connector ) [EOL] self . _slack = _SlackClientWrapper ( slack = slack , retries = retries , backoff = backoff ) [EOL] [EOL] def run ( self , * , connector = None , interval = [number] , retries = [number] , backoff = None , until = None ) : [EOL] [docstring] [EOL] backoff = backoff or _truncated_exponential [EOL] until = until or _forever [EOL] [EOL] self . _ensure_slack ( connector = connector , retries = retries , backoff = backoff ) [EOL] assert self . _slack is not None [EOL] [EOL] while True : [EOL] events = self . _slack . fetch_events ( ) [EOL] [EOL] if not until ( events ) : [EOL] log . debug ( [string] ) [EOL] break [EOL] [EOL] [comment] [EOL] for event in events : [EOL] type_ = event . get ( [string] , [string] ) [EOL] for handler in self . _handlers [ type_ ] + self . _handlers [ [string] ] : [EOL] fn , kwargs = handler [EOL] fn ( self . _slack . inner , event , ** kwargs ) [EOL] [EOL] [comment] [EOL] time . sleep ( interval ) [EOL] [EOL] [EOL] def _format_parameter_error_message ( name , sig , num_params ) : [EOL] [docstring] [EOL] if num_params == [number] : [EOL] plural = [string] [EOL] missing = [number] [EOL] arguments = [string] [EOL] else : [EOL] plural = [string] [EOL] missing = [number] [EOL] arguments = [string] [EOL] [EOL] return ( f"{ name }{ sig } [string] { missing } [string] " f" [string] { plural } [string] { arguments }" ) [EOL] [EOL] [EOL] @ singledispatch def _create_slack ( connector ) : [EOL] [docstring] [EOL] raise TypeError ( f" [string] { type ( connector ) }" ) [EOL] [EOL] [EOL] @ _create_slack . register ( str ) def _create_slack_with_string ( string ) : [EOL] [docstring] [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] @ _create_slack . register ( EnvVar ) def _create_slack_with_env_var ( env_var ) : [EOL] [docstring] [EOL] token = os . getenv ( env_var ) [EOL] if token : [EOL] return SlackClient ( token = token ) [EOL] raise MissingToken ( f" [string] { env_var }" ) [EOL] [EOL] [EOL] @ _create_slack . register ( Token ) def _create_slack_with_token ( token ) : [EOL] [docstring] [EOL] if token != Token ( [string] ) : [EOL] return SlackClient ( token = token ) [EOL] raise MissingToken ( [string] ) [EOL] [EOL] [EOL] @ _create_slack . register ( SlackClient ) def _create_slack_with_slack_client ( slack ) : [EOL] [docstring] [EOL] return slack [EOL] [EOL] [EOL] def _forever ( events ) : [comment] [EOL] [docstring] [EOL] return True [EOL] [EOL] [EOL] def _truncated_exponential ( retry ) : [EOL] [docstring] [EOL] return ( min ( ( ( [number] ** retry ) + random . randrange ( [number] ) ) , [number] ) / [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.float]$ 0 0 0 $typing.Callable[[typing.List],builtins.bool]$ 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.float]$ 0 $typing.Callable[[builtins.int],builtins.float]$ 0 0 0 $typing.Callable[[typing.List],builtins.bool]$ 0 $typing.Callable[[typing.List],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.float]$ 0 $typing.Callable[[builtins.int],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.List],builtins.bool]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , py_modules = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import layabout [EOL] import sys [EOL] [EOL] from pprint import pformat [EOL] from layabout import Layabout , MissingToken [EOL] [EOL] app = Layabout ( ) [EOL] [EOL] [EOL] @ app . handle ( [string] ) def print_all ( slack , event ) : [EOL] [docstring] [EOL] print ( f" [string] { pformat ( event ) } [string] " ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] try : [EOL] app . run ( ) [EOL] except MissingToken : [EOL] sys . exit ( [string] [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , py_modules = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Any [EOL] import layabout [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] from layabout import Layabout [EOL] from slackclient import SlackClient [EOL] [EOL] app = Layabout ( ) [EOL] [EOL] [EOL] @ app . handle ( [string] ) def someone_is_typing ( slack , event ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def channel_to_id ( slack , channel ) : [EOL] [docstring] [EOL] channels = slack . api_call ( [string] ) . get ( [string] ) or [ ] [EOL] groups = slack . api_call ( [string] ) . get ( [string] ) or [ ] [EOL] [EOL] if not channels and not groups : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] ids = [ c [ [string] ] for c in channels + groups if c [ [string] ] == channel ] [EOL] [EOL] if not ids : [EOL] raise ValueError ( f" [string] { channel }" ) [EOL] [EOL] return ids [ [number] ] [EOL] [EOL] [EOL] def send_message ( slack ) : [EOL] [docstring] [EOL] channel = input ( [string] ) [EOL] message = input ( [string] ) [EOL] channel_id = channel_to_id ( slack , channel ) [EOL] [EOL] print ( f" [string] { channel } [string] { channel_id } [string] " ) [EOL] slack . rtm_send_message ( channel_id , message ) [EOL] [EOL] [EOL] def main ( ) : [EOL] env_var = [string] [EOL] token = os . getenv ( env_var ) [EOL] [EOL] if not token : [EOL] sys . exit ( f" [string] { env_var } [string] " [string] [string] ) [EOL] [EOL] slack = SlackClient ( token = token ) [EOL] [EOL] if not slack . rtm_connect ( ) : [EOL] sys . exit ( [string] ) [EOL] [EOL] [comment] [EOL] send_message ( slack ) [EOL] [EOL] print ( [string] ) [EOL] [comment] [EOL] app . run ( connector = slack ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , py_modules = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import layabout [EOL] import typing [EOL] import sys [EOL] [EOL] from pprint import pformat [EOL] [EOL] from layabout import Layabout , MissingToken [EOL] [EOL] app = Layabout ( ) [EOL] [EOL] [EOL] def channel_to_id ( slack , channel ) : [EOL] [docstring] [EOL] channels = slack . api_call ( [string] ) . get ( [string] ) or [ ] [EOL] groups = slack . api_call ( [string] ) . get ( [string] ) or [ ] [EOL] [EOL] if not channels and not groups : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] ids = [ c [ [string] ] for c in channels + groups if c [ [string] ] == channel ] [EOL] [EOL] if not ids : [EOL] raise ValueError ( f" [string] { channel }" ) [EOL] [EOL] return ids [ [number] ] [EOL] [EOL] [EOL] def main ( ) : [EOL] channel_name = input ( [string] ) [EOL] print ( f" [string] { channel_name } [string] " ) [EOL] [EOL] @ app . handle ( [string] ) def debug ( slack , event ) : [EOL] [docstring] [EOL] debug_channel = channel_to_id ( slack , channel_name ) [EOL] if event . get ( [string] ) == debug_channel : [EOL] print ( f" [string] { channel_name } [string] { pformat ( event ) } [string] " ) [EOL] try : [EOL] app . run ( ) [EOL] except MissingToken : [EOL] sys . exit ( [string] [string] [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import layabout [EOL] import sys [EOL] [EOL] from layabout import Layabout , MissingToken [EOL] [EOL] app = Layabout ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] magic = input ( [string] ) [EOL] print ( f' [string] { magic } [string] ' ) [EOL] [EOL] def someone_says_the_magic_word ( events ) : [EOL] [docstring] [EOL] for event in events : [EOL] if magic in event . get ( [string] , [string] ) : [EOL] [comment] [EOL] return False [EOL] [EOL] [comment] [EOL] return True [EOL] [EOL] [comment] [EOL] try : [EOL] app . run ( until = someone_says_the_magic_word ) [EOL] except MissingToken : [EOL] sys . exit ( [string] [string] [string] ) [EOL] [EOL] print ( f' [string] { magic } [string] ' ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $layabout.Layabout$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , py_modules = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , OrderedDict , Tuple , Dict , List [EOL] import datetime [EOL] import typing [EOL] import collections [EOL] import sys [EOL] import datetime as dt [EOL] from collections import OrderedDict [EOL] from pathlib import Path [EOL] sys . path . insert ( [number] , str ( Path ( [string] ) . resolve ( ) ) ) [EOL] [EOL] import layabout [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] changelog_mtime = Path ( [string] ) . stat ( ) . st_mtime [EOL] copyright_year = dt . datetime . utcfromtimestamp ( changelog_mtime ) [EOL] homepage = [string] [EOL] [EOL] project = [string] [EOL] author = [string] [EOL] copyright = f'{ copyright_year : [string] } [string] { homepage } [string] { author } [string] ' [EOL] [EOL] [comment] [EOL] version = [string] . join ( layabout . __version__ . split ( [string] ) [ [number] : [number] ] ) [EOL] [comment] [EOL] release = layabout . __version__ [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , } [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] html_show_sourcelink = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme_options = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : OrderedDict ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_sidebars = { [string] : [ [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , ] , } [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] todo_include_todos = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $datetime.datetime$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[collections.OrderedDict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0