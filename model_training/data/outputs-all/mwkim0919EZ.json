[comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import colorama [EOL] from bs4 import BeautifulSoup [EOL] from tabulate import tabulate [EOL] [EOL] import pom_xml_parser [EOL] [EOL] colorama . init ( autoreset = True ) [EOL] [EOL] COVERAGE_INDEX_MAP = { [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] } [EOL] [EOL] [EOL] def run ( pom_file , jacoco_file ) : [EOL] [docstring] [EOL] with open ( jacoco_file , [string] ) as jacoco_file : [EOL] jacoco_string = jacoco_file . read ( ) [EOL] parser = BeautifulSoup ( jacoco_string , [string] ) [EOL] [EOL] complexity_coverage_info = fetch_coverage_info ( parser , [string] ) [EOL] line_coverage_info = fetch_coverage_info ( parser , [string] ) [EOL] method_coverage_info = fetch_coverage_info ( parser , [string] ) [EOL] class_coverage_info = fetch_coverage_info ( parser , [string] ) [EOL] coverage_info_array = [ complexity_coverage_info , line_coverage_info , method_coverage_info , class_coverage_info ] [EOL] coverage_map = map_coverage_info ( coverage_info_array ) [EOL] [EOL] tabulate_print = tabulate ( coverage_info_array , headers = [ [string] , [string] , [string] , [string] ] ) [EOL] print ( colorama . Fore . GREEN + tabulate_print ) [EOL] [EOL] coverage_type , min_coverage = pom_xml_parser . run ( pom_file ) [EOL] [EOL] coverage_greater_than_min , actual_coverage = is_coverage_greater_than_min ( coverage_map , coverage_type , float ( min_coverage ) ) [EOL] [EOL] if not coverage_greater_than_min : [EOL] raise AssertionError ( colorama . Fore . RED + [string] + str ( actual_coverage ) + [string] + min_coverage ) [EOL] [EOL] [EOL] def fetch_coverage_info ( parser , coverage_type ) : [EOL] [docstring] [EOL] if coverage_type not in COVERAGE_INDEX_MAP . keys ( ) : [EOL] raise ValueError ( [string] ) [EOL] missed = float ( list ( parser . tfoot . tr . children ) [ COVERAGE_INDEX_MAP [ coverage_type ] [ [number] ] ] . string ) [EOL] total = float ( list ( parser . tfoot . tr . children ) [ COVERAGE_INDEX_MAP [ coverage_type ] [ [number] ] ] . string ) [EOL] coverage = round ( ( total - missed ) / total * [number] , [number] ) [EOL] return [ coverage_type , str ( missed ) , str ( total ) , str ( coverage ) ] [EOL] [EOL] [EOL] def is_coverage_greater_than_min ( coverage_map , coverage_type , expected_coverage ) : [EOL] [docstring] [EOL] coverage_type = coverage_type . lower ( ) [EOL] actual_coverage = [number] [EOL] if coverage_type == [string] : [EOL] actual_coverage = float ( coverage_map [ [string] ] [ [number] ] ) [EOL] elif coverage_type == [string] : [EOL] actual_coverage = float ( coverage_map [ [string] ] [ [number] ] ) [EOL] elif coverage_type == [string] : [EOL] actual_coverage = float ( coverage_map [ [string] ] [ [number] ] ) [EOL] elif coverage_type == [string] : [EOL] actual_coverage = float ( coverage_map [ [string] ] [ [number] ] ) [EOL] [EOL] return actual_coverage >= expected_coverage , actual_coverage [EOL] [EOL] [EOL] def map_coverage_info ( coverage_info_array ) : [EOL] [docstring] [EOL] return { [string] : coverage_info_array [ [number] ] , [string] : coverage_info_array [ [number] ] , [string] : coverage_info_array [ [number] ] , [string] : coverage_info_array [ [number] ] } [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] run ( args . pomfile , args . jacocofile ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import argparse [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import colorama [EOL] import subprocess [EOL] [EOL] colorama . init ( autoreset = True ) [EOL] [EOL] [EOL] def build ( branch , force ) : [EOL] [docstring] [EOL] print ( colorama . Fore . YELLOW + [string] ) [EOL] cmd = [string] [EOL] print ( colorama . Fore . YELLOW + [string] + cmd ) [EOL] try : [EOL] subprocess . check_call ( cmd . split ( ) ) [EOL] print ( colorama . Fore . GREEN + [string] ) [EOL] try : [EOL] git_cmd = [string] + branch [EOL] if force : [EOL] git_cmd += [string] [EOL] print ( colorama . Fore . YELLOW + [string] + git_cmd ) [EOL] subprocess . check_call ( git_cmd . split ( ) ) [EOL] print ( colorama . Fore . GREEN + [string] ) [EOL] except subprocess . CalledProcessError : [EOL] print ( colorama . Fore . RED + [string] ) [EOL] except subprocess . CalledProcessError : [EOL] print ( colorama . Fore . RED + [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = False , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] build ( args . branch , args . force ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import argparse [EOL] import builtins [EOL] import xml [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import colorama [EOL] import xml . etree . ElementTree as ET [EOL] [EOL] MAVEN_APACHE_URL = [string] [EOL] [EOL] [EOL] def run ( file ) : [EOL] [docstring] [EOL] xml_tree = ET . parse ( file ) [EOL] coverage_type = xml_tree . find ( MAVEN_APACHE_URL + [string] ) . text [EOL] min_coverage = str ( float ( xml_tree . find ( MAVEN_APACHE_URL + [string] ) . text ) * [number] ) [EOL] print ( colorama . Fore . RED + [string] + coverage_type + [string] ) [EOL] print ( colorama . Fore . RED + [string] + min_coverage + [string] ) [EOL] return coverage_type , min_coverage [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] run ( args . file ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0