from typing import Dict , Any [EOL] import typing [EOL] import svg3d [EOL] import numpy , svg3d , pyrr , math [EOL] [EOL] [EOL] def get_octahedron_faces ( ) : [EOL] f = math . sqrt ( [number] ) / [number] [EOL] verts = numpy . float32 ( [ ( [number] , - [number] , [number] ) , ( - f , [number] , f ) , ( f , [number] , f ) , ( f , [number] , - f ) , ( - f , [number] , - f ) , ( [number] , [number] , [number] ) ] ) [EOL] triangles = numpy . int32 ( [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ] ) [EOL] return [number] * verts [ triangles ] [EOL] [EOL] [EOL] def generate_svg ( filename ) : [EOL] view = pyrr . matrix44 . create_look_at ( eye = [ [number] , [number] , [number] ] , target = [ [number] , [number] , [number] ] , up = [ [number] , [number] , [number] ] ) [EOL] projection = pyrr . matrix44 . create_perspective_projection ( fovy = [number] , aspect = [number] , near = [number] , far = [number] ) [EOL] camera = svg3d . Camera ( view , projection ) [EOL] [EOL] style = dict ( fill = [string] , fill_opacity = [string] , stroke = [string] , stroke_linejoin = [string] , stroke_width = [string] , ) [EOL] [EOL] mesh = svg3d . Mesh ( get_octahedron_faces ( ) , style = style ) [EOL] view = svg3d . View ( camera , svg3d . Scene ( [ mesh ] ) ) [EOL] svg3d . Engine ( [ view ] ) . render ( filename ) [EOL] [EOL] [EOL] generate_svg ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Generator , Any [EOL] import typing [EOL] import builtins [EOL] import numpy as np [EOL] import pyrr [EOL] [EOL] from math import * [EOL] [EOL] quaternion = pyrr . quaternion [EOL] [EOL] def octasphere ( ndivisions , radius , width = [number] , height = [number] , depth = [number] ) : [EOL] [docstring] [EOL] r2 = [number] * radius [EOL] width = max ( width , r2 ) [EOL] height = max ( height , r2 ) [EOL] depth = max ( depth , r2 ) [EOL] n = [number] ** ndivisions + [number] [EOL] num_verts = n * ( n + [number] ) // [number] [EOL] verts = np . empty ( ( num_verts , [number] ) ) [EOL] j = [number] [EOL] for i in range ( n ) : [EOL] theta = pi * [number] * i / ( n - [number] ) [EOL] point_a = [ [number] , sin ( theta ) , cos ( theta ) ] [EOL] point_b = [ cos ( theta ) , sin ( theta ) , [number] ] [EOL] num_segments = n - [number] - i [EOL] j = compute_geodesic ( verts , j , point_a , point_b , num_segments ) [EOL] assert len ( verts ) == num_verts [EOL] verts = verts * radius [EOL] [EOL] num_faces = ( n - [number] ) * ( n - [number] ) + n - [number] [EOL] faces = np . empty ( ( num_faces , [number] ) , dtype = np . int32 ) [EOL] f , j0 = [number] , [number] [EOL] for col_index in range ( n - [number] ) : [EOL] col_height = n - [number] - col_index [EOL] j1 = j0 + [number] [EOL] j2 = j0 + col_height + [number] [EOL] j3 = j0 + col_height + [number] [EOL] for row in range ( col_height - [number] ) : [EOL] faces [ f + [number] ] = [ j0 + row , j1 + row , j2 + row ] [EOL] faces [ f + [number] ] = [ j2 + row , j1 + row , j3 + row ] [EOL] f = f + [number] [EOL] row = col_height - [number] [EOL] faces [ f ] = [ j0 + row , j1 + row , j2 + row ] [EOL] f = f + [number] [EOL] j0 = j2 [EOL] [EOL] euler_angles = np . float32 ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , ] ) * pi * [number] [EOL] quats = ( quaternion . create_from_eulers ( e ) for e in euler_angles ) [EOL] [EOL] offset , combined_verts , combined_faces = [number] , [ ] , [ ] [EOL] for quat in quats : [EOL] rotated_verts = [ quaternion . apply_to_vector ( quat , v ) for v in verts ] [EOL] rotated_faces = faces + offset [EOL] combined_verts . append ( rotated_verts ) [EOL] combined_faces . append ( rotated_faces ) [EOL] offset = offset + len ( verts ) [EOL] [EOL] verts = np . vstack ( combined_verts ) [EOL] [EOL] tx = ( width - r2 ) / [number] [EOL] ty = ( height - r2 ) / [number] [EOL] tz = ( depth - r2 ) / [number] [EOL] translation = np . float32 ( [ tx , ty , tz ] ) [EOL] [EOL] if np . any ( translation ) : [EOL] translation = np . float32 ( [ [ + [number] , + [number] , + [number] ] , [ + [number] , + [number] , - [number] ] , [ - [number] , + [number] , - [number] ] , [ - [number] , + [number] , + [number] ] , [ + [number] , - [number] , + [number] ] , [ - [number] , - [number] , + [number] ] , [ - [number] , - [number] , - [number] ] , [ + [number] , - [number] , - [number] ] , ] ) * translation [EOL] for i in range ( [number] , len ( verts ) , num_verts ) : [EOL] verts [ i : i + num_verts ] += translation [ i // num_verts ] [EOL] connectors = add_connectors ( ndivisions , radius , width , height , depth ) [EOL] if radius == [number] : [EOL] assert len ( connectors ) // [number] == [number] [EOL] combined_faces = connectors [EOL] else : [EOL] combined_faces . append ( connectors ) [EOL] [EOL] return verts , np . vstack ( combined_faces ) [EOL] [EOL] def add_connectors ( ndivisions , radius , width , height , depth ) : [EOL] r2 = [number] * radius [EOL] width = max ( width , r2 ) [EOL] height = max ( height , r2 ) [EOL] depth = max ( depth , r2 ) [EOL] n = [number] ** ndivisions + [number] [EOL] num_verts = n * ( n + [number] ) // [number] [EOL] tx = ( width - r2 ) / [number] [EOL] ty = ( height - r2 ) / [number] [EOL] tz = ( depth - r2 ) / [number] [EOL] [EOL] boundaries = get_boundary_indices ( ndivisions ) [EOL] assert len ( boundaries ) == [number] [EOL] connectors = [ ] [EOL] [EOL] def connect ( a , b , c , d ) : [EOL] [comment] [EOL] [comment] [EOL] connectors . append ( [ a , b , c ] ) [EOL] connectors . append ( [ c , d , a ] ) [EOL] [EOL] if radius > [number] : [EOL] [comment] [EOL] for patch in range ( [number] ) : [EOL] if patch % [number] == [number] and tz == [number] : continue [EOL] if patch % [number] == [number] and tx == [number] : continue [EOL] next_patch = ( patch + [number] ) % [number] [EOL] boundary_a = boundaries [ [number] ] + num_verts * patch [EOL] boundary_b = boundaries [ [number] ] + num_verts * next_patch [EOL] for i in range ( n - [number] ) : [EOL] a = boundary_a [ i ] [EOL] b = boundary_b [ i ] [EOL] c = boundary_a [ i + [number] ] [EOL] d = boundary_b [ i + [number] ] [EOL] connect ( a , b , d , c ) [EOL] [comment] [EOL] for patch in range ( [number] , [number] ) : [EOL] if patch % [number] == [number] and tx == [number] : continue [EOL] if patch % [number] == [number] and tz == [number] : continue [EOL] next_patch = [number] + ( patch + [number] ) % [number] [EOL] boundary_a = boundaries [ [number] ] + num_verts * patch [EOL] boundary_b = boundaries [ [number] ] + num_verts * next_patch [EOL] for i in range ( n - [number] ) : [EOL] a = boundary_a [ i ] [EOL] b = boundary_b [ i ] [EOL] c = boundary_a [ i + [number] ] [EOL] d = boundary_b [ i + [number] ] [EOL] connect ( d , b , a , c ) [EOL] [comment] [EOL] if ty > [number] : [EOL] for patch in range ( [number] ) : [EOL] next_patch = [number] + ( [number] - patch ) % [number] [EOL] boundary_a = boundaries [ [number] ] + num_verts * patch [EOL] boundary_b = boundaries [ [number] ] + num_verts * next_patch [EOL] for i in range ( n - [number] ) : [EOL] a = boundary_a [ i ] [EOL] b = boundary_b [ n - [number] - i ] [EOL] c = boundary_a [ i + [number] ] [EOL] d = boundary_b [ n - [number] - i - [number] ] [EOL] connect ( a , b , d , c ) [EOL] [EOL] if tx > [number] or ty > [number] : [EOL] [comment] [EOL] a = boundaries [ [number] ] [ - [number] ] [EOL] b = a + num_verts [EOL] c = b + num_verts [EOL] d = c + num_verts [EOL] connect ( a , b , c , d ) [EOL] [comment] [EOL] a = boundaries [ [number] ] [ [number] ] + num_verts * [number] [EOL] b = a + num_verts [EOL] c = b + num_verts [EOL] d = c + num_verts [EOL] connect ( a , b , c , d ) [EOL] [EOL] [comment] [EOL] sides = [ ] [EOL] if ty > [number] : sides = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] for i , j in sides : [EOL] patch_index = i [EOL] patch = patch_index // [number] [EOL] next_patch = [number] + ( [number] - patch ) % [number] [EOL] boundary_a = boundaries [ [number] ] + num_verts * patch [EOL] boundary_b = boundaries [ [number] ] + num_verts * next_patch [EOL] if patch_index % [number] == [number] : [EOL] a , b = boundary_a [ [number] ] , boundary_b [ n - [number] ] [EOL] else : [EOL] a , b = boundary_a [ n - [number] ] , boundary_b [ [number] ] [EOL] patch_index = j [EOL] patch = patch_index // [number] [EOL] next_patch = [number] + ( [number] - patch ) % [number] [EOL] boundary_a = boundaries [ [number] ] + num_verts * patch [EOL] boundary_b = boundaries [ [number] ] + num_verts * next_patch [EOL] if patch_index % [number] == [number] : [EOL] c , d = boundary_a [ [number] ] , boundary_b [ n - [number] ] [EOL] else : [EOL] c , d = boundary_a [ n - [number] ] , boundary_b [ [number] ] [EOL] connect ( a , b , d , c ) [EOL] [EOL] return connectors [EOL] [EOL] [EOL] def compute_geodesic ( dst , index , point_a , point_b , num_segments ) : [EOL] [docstring] [EOL] angle_between_endpoints = acos ( np . dot ( point_a , point_b ) ) [EOL] rotation_axis = np . cross ( point_a , point_b ) [EOL] dst [ index ] = point_a [EOL] index = index + [number] [EOL] if num_segments == [number] : [EOL] return index [EOL] dtheta = angle_between_endpoints / num_segments [EOL] for point_index in range ( [number] , num_segments ) : [EOL] theta = point_index * dtheta [EOL] q = quaternion . create_from_axis_rotation ( rotation_axis , theta ) [EOL] dst [ index ] = quaternion . apply_to_vector ( q , point_a ) [EOL] index = index + [number] [EOL] dst [ index ] = point_b [EOL] return index + [number] [EOL] [EOL] [EOL] def get_boundary_indices ( ndivisions ) : [EOL] [docstring] [EOL] n = [number] ** ndivisions + [number] [EOL] boundaries = np . empty ( ( [number] , n ) , np . int32 ) [EOL] a , b , c , j0 = [number] , [number] , [number] , [number] [EOL] for col_index in range ( n - [number] ) : [EOL] col_height = n - [number] - col_index [EOL] j1 = j0 + [number] [EOL] boundaries [ [number] ] [ a ] = j0 [EOL] a = a + [number] [EOL] for row in range ( col_height - [number] ) : [EOL] if col_height == n - [number] : [EOL] boundaries [ [number] ] [ c ] = j0 + row [EOL] c = c + [number] [EOL] row = col_height - [number] [EOL] if col_height == n - [number] : [EOL] boundaries [ [number] ] [ c ] = j0 + row [EOL] c = c + [number] [EOL] boundaries [ [number] ] [ c ] = j1 + row [EOL] c = c + [number] [EOL] boundaries [ [number] ] [ b ] = j1 + row [EOL] b = b + [number] [EOL] j0 = j0 + col_height + [number] [EOL] boundaries [ [number] ] [ a ] = j0 + row [EOL] boundaries [ [number] ] [ b ] = j0 + row [EOL] return boundaries [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , List , Any [EOL] import typing [EOL] from parent_folder import svg3d [EOL] import pyrr [EOL] import numpy as np [EOL] import svgwrite . utils [EOL] [EOL] from math import * [EOL] [EOL] sign = np . sign [EOL] create_ortho = pyrr . matrix44 . create_orthogonal_projection [EOL] create_perspective = pyrr . matrix44 . create_perspective_projection [EOL] create_lookat = pyrr . matrix44 . create_look_at [EOL] quaternion = pyrr . quaternion [EOL] [EOL] [EOL] def main ( ) : [EOL] create_octahedron_pair ( [string] ) [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def create_octahedron_pair ( filename ) : [EOL] vp = svg3d . Viewport . from_aspect ( [number] ) [EOL] projection = create_perspective ( fovy = [number] , aspect = [number] , near = [number] , far = [number] ) [EOL] view = create_lookat ( eye = [ [number] , [number] , [number] ] , target = [ [number] , [number] , [number] ] , up = [ [number] , [number] , [number] ] ) [EOL] camera = svg3d . Camera ( view , projection ) [EOL] [EOL] scene = svg3d . Scene ( [ ] ) [EOL] [EOL] faces = octahedron ( ) [EOL] def backface_shader ( face_index , winding ) : [EOL] if winding >= [number] : return None [EOL] return dict ( fill = [string] , fill_opacity = [string] , stroke = [string] , stroke_linejoin = [string] , stroke_width = [string] , stroke_dasharray = [string] , ) [EOL] def frontface_shader ( face_index , winding ) : [EOL] if winding < [number] : return None [EOL] return dict ( fill = [string] , fill_opacity = [string] , stroke = [string] , stroke_linejoin = [string] , stroke_width = [string] , ) [EOL] faces += np . array ( [ - [number] , [number] , [number] ] ) [EOL] scene . add_mesh ( svg3d . Mesh ( [number] * faces , backface_shader ) ) [EOL] scene . add_mesh ( svg3d . Mesh ( [number] * faces , frontface_shader ) ) [EOL] [EOL] faces2 = hexahedron ( ) * [number] [EOL] def backface_shader2 ( face_index , winding ) : [EOL] if winding >= [number] : return None [EOL] return dict ( fill = [string] , fill_opacity = [string] , stroke = [string] , stroke_linejoin = [string] , stroke_width = [string] , stroke_dasharray = [string] , ) [EOL] def frontface_shader2 ( face_index , winding ) : [EOL] if winding < [number] : return None [EOL] return dict ( fill = [string] , fill_opacity = [string] , stroke = [string] , stroke_linejoin = [string] , stroke_width = [string] , ) [EOL] [EOL] q = quaternion . create_from_eulers ( [ [number] , pi * [number] , [number] ] ) [EOL] for f in faces2 : [EOL] for v in f : [EOL] v [ : ] = quaternion . apply_to_vector ( q , v ) [EOL] [EOL] faces2 += np . array ( [ [number] , [number] , [number] ] ) [EOL] scene . add_mesh ( svg3d . Mesh ( faces2 , backface_shader2 ) ) [EOL] scene . add_mesh ( svg3d . Mesh ( faces2 , frontface_shader2 ) ) [EOL] [EOL] e = svg3d . Engine ( [ svg3d . View ( camera , scene , vp ) ] ) [EOL] e . render ( filename , ( [number] , [number] ) ) [EOL] [EOL] [EOL] def subdivide ( verts , faces ) : [EOL] [docstring] [EOL] triangles = len ( faces ) [EOL] for faceIndex in range ( triangles ) : [EOL] [EOL] [comment] [EOL] face = faces [ faceIndex ] [EOL] a , b , c = np . float32 ( [ verts [ vertIndex ] for vertIndex in face ] ) [EOL] verts . append ( pyrr . vector . normalize ( a + b ) ) [EOL] verts . append ( pyrr . vector . normalize ( b + c ) ) [EOL] verts . append ( pyrr . vector . normalize ( a + c ) ) [EOL] [EOL] [comment] [EOL] i = len ( verts ) - [number] [EOL] j , k = i + [number] , i + [number] [EOL] faces . append ( ( i , j , k ) ) [EOL] faces . append ( ( face [ [number] ] , i , k ) ) [EOL] faces . append ( ( i , face [ [number] ] , j ) ) [EOL] faces [ faceIndex ] = ( k , j , face [ [number] ] ) [EOL] [EOL] return verts , faces [EOL] [EOL] [EOL] def hexahedron ( ) : [EOL] verts = np . float32 ( [ [ ( - [number] , + [number] , - [number] ) , ( + [number] , + [number] , - [number] ) , ( + [number] , - [number] , - [number] ) , ( - [number] , - [number] , - [number] ) ] , [ ( - [number] , + [number] , + [number] ) , ( + [number] , + [number] , + [number] ) , ( + [number] , - [number] , + [number] ) , ( - [number] , - [number] , + [number] ) ] , [ ( - [number] , - [number] , + [number] ) , ( + [number] , - [number] , + [number] ) , ( + [number] , - [number] , - [number] ) , ( - [number] , - [number] , - [number] ) ] , [ ( - [number] , + [number] , + [number] ) , ( + [number] , + [number] , + [number] ) , ( + [number] , + [number] , - [number] ) , ( - [number] , + [number] , - [number] ) ] , [ ( - [number] , - [number] , + [number] ) , ( - [number] , + [number] , + [number] ) , ( - [number] , + [number] , - [number] ) , ( - [number] , - [number] , - [number] ) ] , [ ( + [number] , - [number] , + [number] ) , ( + [number] , + [number] , + [number] ) , ( + [number] , + [number] , - [number] ) , ( + [number] , - [number] , - [number] ) ] , ] ) [EOL] faces = np . float32 ( [ verts [ [number] ] , verts [ [number] ] , verts [ [number] ] , verts [ [number] ] , verts [ [number] ] , verts [ [number] ] ] ) [EOL] faces [ [number] ] = list ( reversed ( verts [ [number] ] ) ) [EOL] faces [ [number] ] = list ( reversed ( verts [ [number] ] ) ) [EOL] faces [ [number] ] = list ( reversed ( verts [ [number] ] ) ) [EOL] return faces [EOL] [EOL] [EOL] def octahedron ( ) : [EOL] [docstring] [EOL] f = sqrt ( [number] ) / [number] [EOL] verts = np . float32 ( [ ( [number] , - [number] , [number] ) , ( - f , [number] , f ) , ( f , [number] , f ) , ( f , [number] , - f ) , ( - f , [number] , - f ) , ( [number] , [number] , [number] ) ] ) [EOL] faces = np . int32 ( [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ] ) [EOL] return verts [ faces ] [EOL] [EOL] [EOL] def icosahedron ( ) : [EOL] [docstring] [EOL] faces = [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ] [EOL] verts = [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( - [number] , [number] , [number] ) , ( - [number] , - [number] , [number] ) , ( [number] , - [number] , [number] ) , ( [number] , [number] , - [number] ) , ( - [number] , [number] , - [number] ) , ( - [number] , [number] , - [number] ) , ( - [number] , - [number] , - [number] ) , ( [number] , - [number] , - [number] ) , ( [number] , [number] , - [number] ) , ] [EOL] return verts , faces [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0