from pathlib import Path [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = ( Path ( __file__ ) . parent / [string] ) . read_text ( ) , url = [string] , author = [string] , author_email = [string] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , ] , packages = find_packages ( ) , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , entry_points = { [string] : [ [string] , [string] , ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__title__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import List , Tuple , Optional [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import re [EOL] from dataclasses import dataclass [EOL] from functools import total_ordering [EOL] from typing import List , Tuple [EOL] [EOL] import dateutil . tz [EOL] [EOL] default_tz = dateutil . tz . gettz ( [string] ) [EOL] [EOL] [EOL] @ total_ordering @ dataclass class Item : [EOL] datetime_ = ... [EOL] text = ... [EOL] provider = ... [EOL] subprovider = ... [EOL] all_day = False [EOL] [EOL] @ classmethod def normalized ( cls , datetime_ , * args , ** kwargs ) : [EOL] if not datetime_ . tzinfo : [EOL] datetime_ = datetime_ . replace ( tzinfo = default_tz ) [EOL] return cls ( datetime_ , * args , ** kwargs ) [EOL] [EOL] @ property def date ( self ) : [EOL] return self . datetime_ . astimezone ( ) . date ( ) [EOL] [EOL] @ property def clean_text ( self ) : [EOL] return re . sub ( [string] , [string] , self . text ) . strip ( ) [EOL] [EOL] @ property def formatted_datetime ( self ) : [EOL] if self . all_day : [EOL] return self . datetime_ . date ( ) . isoformat ( ) [EOL] return self . datetime_ . isoformat ( ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . datetime_ < other . datetime_ [EOL] [EOL] def astuple ( self ) : [EOL] return ( self . formatted_datetime , self . provider , self . subprovider , self . clean_text , ) [EOL] [EOL] @ classmethod def from_tuple ( cls , row ) : [EOL] formatted_datetime , provider , subprovider , text = row [EOL] datetime_ = datetime . datetime . fromisoformat ( formatted_datetime ) [EOL] return cls . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = subprovider , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.tzinfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $'Item'$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 $typing.Optional[datetime.tzinfo]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Item'$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import subprocess [EOL] import builtins [EOL] import typing [EOL] import subprocess [EOL] from typing import List [EOL] [EOL] [EOL] def run_shell_cmd ( cmd , ** kwargs ) : [EOL] completed_process = subprocess . run ( cmd , stdout = subprocess . PIPE , check = True , universal_newlines = True , ** kwargs , ) [EOL] return completed_process . stdout [EOL] [EOL] [EOL] def lookup_secret ( key , val ) : [EOL] return run_shell_cmd ( [ [string] , [string] , key , val ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from automatic_diary . cli import main [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List , Dict , Optional , Any , Generator , Tuple , Iterator , Iterable [EOL] import logging [EOL] import _csv [EOL] import datetime [EOL] import argparse [EOL] import _importlib_modulespec [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] import csv [EOL] import dataclasses [EOL] import datetime [EOL] import importlib [EOL] import json [EOL] import logging [EOL] import os . path [EOL] import random [EOL] import string [EOL] import sys [EOL] import unicodedata [EOL] from typing import Iterable , Iterator , List , Optional , Set , Tuple [EOL] [EOL] from automatic_diary import __title__ [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] dir_ = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def _obfuscate_char ( char ) : [EOL] category = unicodedata . category ( char ) [EOL] if category == [string] : [EOL] return random . choice ( string . ascii_uppercase ) [EOL] if category == [string] : [EOL] return random . choice ( string . ascii_lowercase ) [EOL] if category == [string] : [EOL] return random . choice ( string . digits ) [EOL] return char [EOL] [EOL] [EOL] def obfuscate ( s ) : [EOL] return [string] . join ( _obfuscate_char ( char ) for char in s ) [EOL] [EOL] [EOL] def load_configs ( path , only_providers = None ) : [EOL] with open ( path ) as f : [EOL] config_json = json . load ( f ) [EOL] for config_json_item in config_json : [EOL] provider = config_json_item [ [string] ] [EOL] config = config_json_item [ [string] ] [EOL] if not only_providers or provider in only_providers : [EOL] yield provider , config [EOL] [EOL] [EOL] def call_providers ( configs , no_cache ) : [EOL] for provider , config in configs : [EOL] name = f' [string] { provider } [string] ' [EOL] try : [EOL] logger . info ( [string] , name ) [EOL] module = importlib . import_module ( name ) [EOL] except ModuleNotFoundError : [EOL] logger . error ( [string] , provider ) [EOL] continue [EOL] yield from module . main ( config , no_cache ) [comment] [EOL] [EOL] [EOL] def write_csv ( items , path ) : [EOL] now = datetime . datetime . now ( ) . astimezone ( ) [EOL] with open ( path , [string] ) as f : [EOL] writer = csv . writer ( f , lineterminator = [string] ) [EOL] encountered_item_tuples = set ( ) [EOL] for item in sorted ( items ) : [EOL] if item . datetime_ > now : [EOL] break [EOL] item_tuple = item . astuple ( ) [EOL] if item_tuple not in encountered_item_tuples : [EOL] writer . writerow ( item_tuple ) [EOL] encountered_item_tuples . add ( item_tuple ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( description = __title__ ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = ( [string] [string] [string] ) , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] args = parser . parse_args ( ) [EOL] if args . verbose : [EOL] logging . basicConfig ( stream = sys . stdout , level = logging . INFO , format = [string] ) [EOL] configs = load_configs ( args . config_path , args . provider ) [EOL] items = call_providers ( configs , args . no_cache ) [EOL] if args . obfuscate : [EOL] items = ( dataclasses . replace ( item , text = obfuscate ( item . text ) ) for item in items ) [EOL] write_csv ( items , args . output_csv_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,builtins.dict]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import tempfile [EOL] from unittest import TestCase [EOL] [EOL] from PyOrgMode import PyOrgMode [EOL] [EOL] from automatic_diary . model import Item [EOL] from automatic_diary . providers . orgmodelist . main import parse_orgmode_list [EOL] [EOL] [EOL] def create_org ( content ) : [EOL] with tempfile . NamedTemporaryFile ( ) as f : [EOL] f . write ( content ) [EOL] f . flush ( ) [EOL] org = PyOrgMode . OrgDataStructure ( ) [EOL] org . load_from_file ( f . name ) [EOL] return org [EOL] [EOL] [EOL] class TestOrgmode ( TestCase ) : [EOL] def test_parse_orgmode_list ( self ) : [EOL] org = create_org ( [string] ) [EOL] subprovider = [string] [EOL] result = list ( parse_orgmode_list ( org , subprovider ) ) [EOL] expected = [ Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = False , ) , ] [EOL] self . assertListEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[automatic_diary.model.Item]$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.List[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[automatic_diary.model.Item]$ 0 $typing.List[automatic_diary.model.Item]$ 0 0
import datetime [EOL] import datetime [EOL] from unittest import TestCase [EOL] [EOL] import dateutil . tz [EOL] from ddt import data , ddt , unpack [EOL] [EOL] from automatic_diary . providers . facebook . main import parse_datetime [EOL] [EOL] [EOL] @ ddt class TestFacebook ( TestCase ) : [EOL] @ data ( ( [string] , datetime . datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = dateutil . tz . gettz ( [string] ) ) , ) , ( [string] , datetime . datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = dateutil . tz . gettz ( [string] ) ) , ) , ) @ unpack def test_parse_datetime ( self , s , expected ) : [EOL] result = parse_datetime ( s ) [EOL] self . assertEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0
from unittest import TestCase [EOL] [EOL] from ddt import data , ddt , unpack [EOL] [EOL] from automatic_diary . providers . csfd . main import parse_username [EOL] [EOL] [EOL] @ ddt class TestCSFD ( TestCase ) : [EOL] @ data ( ( [string] , [string] ) , ( [string] , [string] ) , ) @ unpack def test_parse_date_time ( self , url , expected ) : [EOL] result = parse_username ( url ) [EOL] self . assertEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
import unicodedata [EOL] from unittest import TestCase [EOL] [EOL] from automatic_diary . cli import obfuscate [EOL] [EOL] [EOL] class TestCLI ( TestCase ) : [EOL] def test_obfuscate ( self ) : [EOL] source = [string] [EOL] result = obfuscate ( source ) [EOL] self . assertNotEqual ( source , result ) [EOL] self . assertEqual ( len ( source ) , len ( result ) ) [EOL] for source_char , result_char in zip ( source , result ) : [EOL] self . assertEqual ( unicodedata . category ( source_char ) , unicodedata . category ( result_char ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import automatic_diary [EOL] import typing [EOL] import io [EOL] import datetime [EOL] import io [EOL] from unittest import TestCase [EOL] [EOL] from automatic_diary . model import Item [EOL] from automatic_diary . providers . txt . main import parse_txt [EOL] [EOL] [EOL] class TestTxt ( TestCase ) : [EOL] def test_parse_txt ( self ) : [EOL] f = io . StringIO ( [string] ) [EOL] subprovider = [string] [EOL] result = list ( parse_txt ( f , subprovider ) ) [EOL] expected = [ Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , Item . normalized ( datetime_ = datetime . datetime ( [number] , [number] , [number] ) , text = [string] , provider = [string] , subprovider = subprovider , all_day = True , ) , ] [EOL] self . assertListEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[automatic_diary.model.Item]$ 0 0 0 0 0 $io.StringIO$ 0 $builtins.str$ 0 0 0 $typing.List[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[automatic_diary.model.Item]$ 0 $typing.List[automatic_diary.model.Item]$ 0 0
	0
	0
	0
from typing import List , Any , IO , Iterator , Optional , Pattern [EOL] import logging [EOL] import datetime [EOL] import pathlib [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import re [EOL] from pathlib import Path [EOL] from typing import IO , Iterator , List , Optional [EOL] [EOL] from more_itertools import peekable [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] regex_heading = re . compile ( [string] ) [EOL] [EOL] [EOL] def parse_orgmode ( f , subprovider ) : [EOL] current_datetime = None [EOL] current_paragraph = [ ] [EOL] lines = peekable ( f ) [EOL] for line in lines : [EOL] line_clean = line . strip ( ) [EOL] if line_clean : [EOL] m = regex_heading . match ( line_clean ) [EOL] [comment] [EOL] if m : [EOL] date_str = m . group ( [string] ) [EOL] current_datetime = datetime . datetime . strptime ( date_str , [string] ) [EOL] [comment] [EOL] elif current_datetime : [EOL] current_paragraph . append ( line_clean ) [EOL] [comment] [EOL] if not line_clean or not lines : [EOL] if current_datetime and current_paragraph : [EOL] yield Item . normalized ( datetime_ = current_datetime , text = [string] . join ( current_paragraph ) , provider = provider , subprovider = subprovider , all_day = True , ) [EOL] current_paragraph . clear ( ) [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = Path ( config [ [string] ] ) [EOL] subprovider = path . name [EOL] logger . info ( [string] , path ) [EOL] with path . open ( ) as f : [EOL] yield from parse_orgmode ( f , subprovider ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Optional , Pattern , Iterator [EOL] import logging [EOL] import datetime [EOL] import pathlib [EOL] import builtins [EOL] import automatic_diary [EOL] import typing [EOL] import PyOrgMode [EOL] import logging [EOL] import re [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] import dateparser [EOL] from PyOrgMode import PyOrgMode [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] regex_item = re . compile ( [string] ) [EOL] [EOL] [EOL] class OrgModeError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def parse_orgmode_list ( org , subprovider ) : [EOL] for str_or_node in org . root . content : [EOL] if isinstance ( str_or_node , PyOrgMode . OrgNode . Element ) : [EOL] raise OrgModeError ( [string] ) [EOL] if str_or_node == [string] or str_or_node . startswith ( [string] ) : [EOL] continue [EOL] m = regex_item . search ( str_or_node ) [EOL] if not m : [EOL] raise OrgModeError ( f' [string] { str_or_node } [string] ' ) [EOL] text = m . group ( [string] ) [EOL] datetime_ = dateparser . parse ( m . group ( [string] ) ) [EOL] all_day = not any ( ( datetime_ . hour , datetime_ . minute , datetime_ . second ) ) [EOL] yield Item . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = subprovider , all_day = all_day , ) [EOL] [EOL] [EOL] def read_org ( path ) : [EOL] org = PyOrgMode . OrgDataStructure ( ) [EOL] org . load_from_file ( path ) [EOL] return org [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = Path ( config [ [string] ] ) [EOL] subprovider = path . name [EOL] logger . info ( [string] , path ) [EOL] org = read_org ( path ) [EOL] yield from parse_orgmode_list ( org , subprovider ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PyOrgMode.PyOrgMode.PyOrgMode.OrgDataStructure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Iterator [EOL] import logging [EOL] import datetime [EOL] import pathlib [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import json [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] [EOL] def _parse_tweets_file ( path ) : [EOL] with path . open ( ) as f : [EOL] f . readline ( ) [comment] [EOL] tweets_data = json . load ( f ) [EOL] for tweet_data in tweets_data : [EOL] datetime_ = datetime . datetime . strptime ( tweet_data [ [string] ] , [string] ) [EOL] text = tweet_data [ [string] ] [EOL] screen_name = tweet_data [ [string] ] [ [string] ] [EOL] yield Item . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = screen_name , ) [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = Path ( config [ [string] ] ) [EOL] logger . info ( [string] , path ) [EOL] for tweets_file_path in ( path / [string] / [string] / [string] ) . glob ( [string] ) : [EOL] yield from _parse_tweets_file ( tweets_file_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Tuple , Optional , Iterator [EOL] import logging [EOL] import datetime [EOL] import email [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import email [EOL] import email . header [EOL] import email . utils [EOL] import glob [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Iterator , Union [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] THeader = Union [ str , email . header . Header , None ] [EOL] [EOL] [EOL] def _decode_header ( header ) : [EOL] if not header : [EOL] return [string] [EOL] first_charset = email . header . decode_header ( header ) [ [number] ] [EOL] header_bytes , _ = first_charset [EOL] if isinstance ( header_bytes , str ) : [EOL] return header_bytes [EOL] return header_bytes . decode ( errors = [string] ) [EOL] [EOL] [EOL] def _parse_address ( header ) : [EOL] if not header : [EOL] return [string] [EOL] header_str = str ( header ) [EOL] name , address = email . utils . parseaddr ( header_str ) [EOL] if name : [EOL] return _decode_header ( name ) [EOL] return address [EOL] [EOL] [EOL] def _parse_date ( header ) : [EOL] header_str = str ( header ) [EOL] return email . utils . parsedate_to_datetime ( header_str ) [EOL] [EOL] [EOL] def _format_text ( from_ , to_ , subject , sent ) : [EOL] if sent : [EOL] return f' [string] { to_ } [string] { subject }' . strip ( ) [EOL] return f' [string] { from_ } [string] { subject }' . strip ( ) [EOL] [EOL] [EOL] def _read_messages ( pathname , sent ) : [EOL] for path in glob . glob ( pathname ) : [EOL] logger . info ( [string] , path ) [EOL] with open ( path , [string] ) as f : [EOL] email_message = email . message_from_binary_file ( f ) [EOL] if not email_message [ [string] ] : [EOL] logger . warning ( [string] , path ) [EOL] continue [EOL] datetime_ = _parse_date ( email_message [ [string] ] ) [EOL] text = _format_text ( _parse_address ( email_message [ [string] ] ) , _parse_address ( email_message [ [string] ] ) , _decode_header ( email_message [ [string] ] ) , sent , ) [EOL] yield Item . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = pathname , ) [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] yield from _read_messages ( config [ [string] ] , sent = False ) [EOL] yield from _read_messages ( config [ [string] ] , sent = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Iterable , Iterator [EOL] import logging [EOL] import datetime [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import os [EOL] import subprocess [EOL] from pathlib import Path [EOL] from typing import Iterable , Iterator [EOL] [EOL] from automatic_diary . model import Item [EOL] from automatic_diary . shell import run_shell_cmd [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] [EOL] def _find_git_repos ( base_path ) : [EOL] if not os . path . isdir ( base_path ) : [EOL] logger . warn ( f' [string] { base_path } [string] ' ) [EOL] return [EOL] for entry in os . scandir ( base_path ) : [EOL] if entry . name == [string] : [EOL] yield base_path [EOL] if not entry . name . startswith ( [string] ) and entry . is_dir ( ) : [EOL] yield from _find_git_repos ( entry . path ) [EOL] [EOL] [EOL] def _call_git_log ( repo_path , author ) : [EOL] return run_shell_cmd ( [ [string] , [string] , [string] , f' [string] { author }' , [string] , [string] , ] , cwd = repo_path , ) [EOL] [EOL] [EOL] def _read_git_logs ( repo_paths , author ) : [EOL] for repo_path in repo_paths : [EOL] logger . info ( [string] , repo_path ) [EOL] repo_name = os . path . basename ( repo_path ) [EOL] try : [EOL] log = _call_git_log ( repo_path , author ) [EOL] except subprocess . CalledProcessError : [EOL] continue [EOL] for log_line in log . splitlines ( ) : [EOL] formatted_datetime_ , text = log_line . split ( [string] , maxsplit = [number] ) [EOL] datetime_ = datetime . datetime . fromisoformat ( formatted_datetime_ ) [EOL] yield Item . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = repo_name , ) [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] base_path = config [ [string] ] [EOL] author = config [ [string] ] [EOL] repo_paths = _find_git_repos ( base_path ) [EOL] return _read_git_logs ( repo_paths , author ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Iterable , Iterator [EOL] import logging [EOL] import pathlib [EOL] import builtins [EOL] import automatic_diary [EOL] import caldav [EOL] import typing [EOL] import io [EOL] import io [EOL] import itertools [EOL] import logging [EOL] import os [EOL] from pathlib import Path [EOL] from typing import Iterable , Iterator , List [EOL] [EOL] import caldav [EOL] [EOL] from automatic_diary . model import Item [EOL] from automatic_diary . providers . icalendar . main import parse_calendar [EOL] from automatic_diary . shell import lookup_secret [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] [EOL] def _read_events_data_from_cache ( cache_dir , no_cache ) : [EOL] if no_cache : [EOL] return [EOL] if cache_dir . is_dir ( ) : [EOL] logger . info ( f' [string] { cache_dir }' ) [EOL] for cache_file in os . scandir ( cache_dir ) : [EOL] if cache_file . is_file ( ) : [EOL] yield Path ( cache_file . path ) . read_text ( ) [EOL] [EOL] [EOL] def _write_events_to_cache ( events , cache_dir ) : [EOL] logger . info ( f' [string] { cache_dir }' ) [EOL] cache_dir . mkdir ( parents = True , exist_ok = True ) [EOL] for event in events : [EOL] _ , event_id = event . url . rsplit ( [string] , maxsplit = [number] ) [EOL] cache_file = cache_dir / event_id [EOL] cache_file . write_text ( event . data ) [EOL] [EOL] [EOL] def _download_events ( url , username , password , cache_dir , no_cache ) : [EOL] events_data = list ( _read_events_data_from_cache ( cache_dir , no_cache ) ) [EOL] if events_data : [EOL] return events_data [EOL] logger . info ( [string] , url ) [EOL] client = caldav . DAVClient ( url , username = username , password = password ) [EOL] logger . info ( [string] ) [EOL] principal = client . principal ( ) [EOL] events = list ( itertools . chain . from_iterable ( calendar . events ( ) for calendar in principal . calendars ( ) ) ) [EOL] _write_events_to_cache ( events , cache_dir ) [EOL] return [ event . data for event in events ] [EOL] [EOL] [EOL] def _parse_events ( events_data , subprovider ) : [EOL] for event_data in events_data : [EOL] lines = io . StringIO ( event_data ) [EOL] for event in parse_calendar ( lines ) : [EOL] yield Item . normalized ( datetime_ = event . begin , text = event . name , provider = provider , subprovider = subprovider , all_day = event . all_day , ) [EOL] [EOL] [EOL] def main ( config , no_cache , * args , ** kwargs ) : [EOL] url = config [ [string] ] [EOL] username = config [ [string] ] [EOL] password = lookup_secret ( config [ [string] ] , config [ [string] ] ) [EOL] cache_dir = Path ( config [ [string] ] ) [EOL] events_data = _download_events ( url , username , password , cache_dir , no_cache ) [EOL] return _parse_events ( events_data , subprovider = url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Iterator , Pattern [EOL] import logging [EOL] import datetime [EOL] import pathlib [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import re [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] regex_line = re . compile ( [string] [string] ) [EOL] regex_threshold = re . compile ( [string] ) [EOL] regex_due = re . compile ( [string] ) [EOL] [EOL] [EOL] def _clean_text ( s ) : [EOL] s = regex_threshold . sub ( [string] , s ) [EOL] s = regex_due . sub ( [string] , s ) [EOL] return s [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = Path ( config [ [string] ] ) [EOL] subprovider = path . name [EOL] logger . info ( [string] , path ) [EOL] with path . open ( ) as f : [EOL] for line in f : [EOL] m = regex_line . match ( line ) [EOL] if not m : [EOL] continue [EOL] datetime_ = datetime . datetime ( int ( m . group ( [string] ) ) , int ( m . group ( [string] ) ) , int ( m . group ( [string] ) ) ) [EOL] text = _clean_text ( m . group ( [string] ) ) [EOL] yield Item . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = subprovider , all_day = True , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Optional , Any , Iterator , Match , Iterable [EOL] import logging [EOL] import requests [EOL] import bs4 [EOL] import datetime [EOL] import pathlib [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import re [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from typing import Iterable , Iterator [EOL] [EOL] import requests [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] HEADERS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ dataclass class Film : [EOL] title = ... [EOL] datetime_ = ... [EOL] [EOL] [EOL] def _download_ratings_page ( profile_url , cache_dir , no_cache , page_no = [number] ) : [EOL] cache_file = cache_dir / f'{ page_no : [string] } [string] ' [EOL] if not no_cache and cache_file . is_file ( ) : [EOL] logger . info ( f' [string] { cache_file }' ) [EOL] return cache_file . read_text ( ) [EOL] page_url = f'{ profile_url } [string] { page_no } [string] ' [EOL] logger . info ( f' [string] { page_url }' ) [EOL] r = requests . get ( page_url , headers = HEADERS ) [EOL] html = r . text [EOL] logger . info ( f' [string] { cache_file }' ) [EOL] cache_file . parent . mkdir ( parents = True , exist_ok = True ) [EOL] cache_file . write_text ( html ) [EOL] return html [EOL] [EOL] [EOL] def _download_all_ratings_pages ( profile_url , cache_dir , no_cache ) : [EOL] html = _download_ratings_page ( profile_url , cache_dir , no_cache ) [EOL] soup = BeautifulSoup ( html , [string] ) [EOL] page_links = soup . select ( [string] ) [EOL] page_num_links = [ node for node in page_links if not node . get ( [string] ) ] [EOL] last_page_num_link = page_num_links [ - [number] ] [EOL] last_page_num = int ( last_page_num_link . string ) [EOL] logger . info ( [string] , last_page_num ) [EOL] yield soup [EOL] for page_no in range ( [number] , last_page_num + [number] ) : [EOL] html = _download_ratings_page ( profile_url , cache_dir , no_cache , page_no ) [EOL] soup = BeautifulSoup ( html , [string] ) [EOL] yield soup [EOL] [EOL] [EOL] def _parse_ratings_page ( soup ) : [EOL] for tr in soup . select ( [string] ) : [EOL] title = tr . find ( class_ = [string] ) . string [EOL] datetime_ = datetime . datetime . strptime ( tr . find_all ( [string] ) [ - [number] ] . string , [string] ) [EOL] logger . info ( [string] , title , datetime_ . date ( ) ) [EOL] yield Film ( title = title , datetime_ = datetime_ ) [EOL] [EOL] [EOL] def _parse_ratings_pages ( soups , subprovider ) : [EOL] for soup in soups : [EOL] for film in _parse_ratings_page ( soup ) : [EOL] yield Item . normalized ( datetime_ = film . datetime_ , text = film . title , provider = provider , subprovider = subprovider , all_day = True , ) [EOL] [EOL] [EOL] def parse_username ( url ) : [EOL] m = re . search ( [string] , url ) [EOL] if not m : [EOL] raise ValueError ( [string] ) [EOL] return m . group ( [number] ) [EOL] [EOL] [EOL] def main ( config , no_cache , * args , ** kwargs ) : [EOL] profile_url = config [ [string] ] [EOL] cache_dir = Path ( config [ [string] ] ) [EOL] username = parse_username ( profile_url ) [EOL] pages = _download_all_ratings_pages ( profile_url , cache_dir , no_cache ) [EOL] return _parse_ratings_pages ( pages , subprovider = username ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[bs4.BeautifulSoup]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[Film]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Any , IO , Iterator , Optional , Pattern [EOL] import logging [EOL] import datetime [EOL] import pathlib [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import re [EOL] from pathlib import Path [EOL] from typing import IO , Iterator , List , Optional [EOL] [EOL] from more_itertools import peekable [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] regex_heading = re . compile ( [string] ) [EOL] regex_content = re . compile ( [string] ) [EOL] [EOL] [EOL] def parse_txt ( f , subprovider , indent_spaces = [number] , sep = [string] , max_indent = [number] , sep_after_max_indent = [string] , ) : [EOL] current_datetime = None [EOL] stack = [ ] [EOL] lines = peekable ( f ) [EOL] for line in lines : [EOL] line_clean = line . rstrip ( ) [EOL] if not line_clean : [EOL] continue [EOL] [comment] [EOL] m = regex_heading . match ( line_clean ) [EOL] if m : [EOL] if stack : [EOL] if not current_datetime : [EOL] raise ValueError ( [string] ) [EOL] text = sep . join ( stack ) [EOL] yield Item . normalized ( datetime_ = current_datetime , text = text , provider = provider , subprovider = subprovider , all_day = True , ) [EOL] stack . clear ( ) [EOL] date_str = m . group ( [string] ) [EOL] current_datetime = datetime . datetime . strptime ( date_str , [string] ) [EOL] [comment] [EOL] elif not current_datetime : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] else : [EOL] m = regex_content . match ( line_clean ) [EOL] if not m : [EOL] raise ValueError ( f' [string] { line_clean } [string] ' ) [EOL] indent_len = len ( m . group ( [string] ) ) [EOL] if indent_len % indent_spaces != [number] : [EOL] raise ValueError ( f' [string] { indent_spaces } [string] ' f' [string] { line_clean } [string] ' ) [EOL] indent_size = indent_len / indent_spaces [EOL] raw_text = m . group ( [string] ) [EOL] if indent_size > max_indent : [EOL] indent_size = max_indent [EOL] stack [ - [number] ] = sep_after_max_indent . join ( [ stack [ - [number] ] , raw_text ] ) [EOL] continue [EOL] if indent_size <= len ( stack ) : [EOL] text = sep . join ( stack ) [EOL] yield Item . normalized ( datetime_ = current_datetime , text = text , provider = provider , subprovider = subprovider , all_day = True , ) [EOL] if indent_size < len ( stack ) : [EOL] stack . pop ( ) [EOL] stack . pop ( ) [EOL] stack . append ( raw_text ) [EOL] if not lines and stack : [EOL] text = sep . join ( stack ) [EOL] yield Item . normalized ( datetime_ = current_datetime , text = text , provider = provider , subprovider = subprovider , all_day = True , ) [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = Path ( config [ [string] ] ) [EOL] subprovider = path . name [EOL] logger . info ( [string] , path ) [EOL] with path . open ( ) as f : [EOL] yield from parse_txt ( f , subprovider ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Iterator , Pattern [EOL] import logging [EOL] import bs4 [EOL] import datetime [EOL] import automatic_diary [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import re [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] import dateparser [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] [EOL] @ dataclass class Status : [EOL] datetime_ = ... [EOL] text = ... [EOL] [EOL] [EOL] filter_regex = re . compile ( [string] . join ( [ [string] , [string] , [string] , ] ) ) [EOL] [EOL] [EOL] def parse_datetime ( s ) : [EOL] s = re . sub ( [string] , [string] , s ) [EOL] s = re . sub ( [string] , [string] , s ) [comment] [EOL] s = re . sub ( [string] , [string] , s ) [comment] [EOL] datetime_ = dateparser . parse ( s ) [EOL] logger . info ( [string] , s , datetime_ ) [EOL] return datetime_ [EOL] [EOL] [EOL] def _parse_timeline_page ( soup ) : [EOL] for p in soup . find_all ( [string] ) : [EOL] comment_el = p . find ( class_ = [string] ) [EOL] if not comment_el : [EOL] continue [EOL] text = comment_el . string [EOL] if not text or filter_regex . search ( str ( p . contents [ [number] ] ) ) : [EOL] logger . warn ( [string] , text ) [EOL] continue [EOL] formatted_datetime = p . find ( class_ = [string] ) . string [EOL] datetime_ = parse_datetime ( formatted_datetime ) [EOL] logger . info ( [string] , datetime_ , text ) [EOL] yield Status ( datetime_ = datetime_ , text = text ) [EOL] [EOL] [EOL] def _read_html ( path ) : [EOL] with open ( path ) as f : [EOL] html = f . read ( ) [EOL] soup = BeautifulSoup ( html , [string] ) [EOL] return soup [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = config [ [string] ] [EOL] username = config [ [string] ] [EOL] logger . info ( [string] , path ) [EOL] soup = _read_html ( path ) [EOL] for status in _parse_timeline_page ( soup ) : [EOL] yield Item . normalized ( datetime_ = status . datetime_ , text = status . text , provider = provider , subprovider = username , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[Status]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Iterator [EOL] import logging [EOL] import datetime [EOL] import pathlib [EOL] import csv [EOL] import builtins [EOL] import automatic_diary [EOL] import typing [EOL] import csv [EOL] import datetime [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] import pystache [EOL] [EOL] from automatic_diary . model import Item [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] provider = Path ( __file__ ) . parent . name [EOL] [EOL] [EOL] def main ( config , * args , ** kwargs ) : [EOL] path = Path ( config [ [string] ] ) [EOL] subprovider = path . name [EOL] logger . info ( [string] , path ) [EOL] renderer = pystache . Renderer ( escape = lambda u : u ) [EOL] date_source_tmpl = pystache . parse ( config [ [string] ] ) [EOL] text_source_tmpl = pystache . parse ( config [ [string] ] ) [EOL] with path . open ( ) as f : [EOL] reader = csv . DictReader ( f ) [EOL] for row in reader : [EOL] text = renderer . render ( text_source_tmpl , row ) [EOL] datetime_ = datetime . datetime . strptime ( renderer . render ( date_source_tmpl , row ) , config [ [string] ] ) [EOL] yield Item . normalized ( datetime_ = datetime_ , text = text , provider = provider , subprovider = subprovider , all_day = True , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[automatic_diary.model.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0