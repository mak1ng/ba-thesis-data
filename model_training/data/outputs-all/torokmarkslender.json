from setuptools import setup [EOL] [EOL] from os import path [EOL] this_directory = path . abspath ( path . dirname ( __file__ ) ) [EOL] with open ( path . join ( this_directory , [string] ) , encoding = [string] ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , url = [string] , author = [string] , license = [string] , packages = [ [string] ] , test_suite = [string] , tests_require = [ [string] , [string] ] , python_requires = [string] , entry_points = { [string] : [ [string] ] , } , classifiers = [ [string] , [string] , ] , project_urls = { [string] : [string] , [string] : [string] , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from slender import List , Set [EOL] [EOL] def main ( ) : [EOL] a = List ( [ [number] , [number] , [number] , [number] , [number] ] ) . delete_if ( lambda x : x % [number] == [number] ) . map ( lambda x : x * [number] ) . chain ( [ [string] , [string] ] ) . each_with_index ( ) . to_list ( ) [EOL] [EOL] print ( a ) [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from . list import List [EOL] from . set import Set [EOL] from . dictionary import Dictionary [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , List , Any [EOL] import typing [EOL] import re [EOL] import copy [EOL] import random [EOL] import types [EOL] [EOL] class List : [EOL] def __init__ ( self , a = [ ] ) : [EOL] [docstring] [EOL] if isinstance ( a , list ) : [EOL] self . __array = copy . deepcopy ( a ) [EOL] elif isinstance ( a , List ) : [EOL] self . __array = copy . deepcopy ( a . to_list ( ) ) [EOL] elif isinstance ( a , set ) : [EOL] self . __array = list ( copy . deepcopy ( a ) ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] return self . __array [ key ] [EOL] [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [docstring] [EOL] self . __array [ key ] = value [EOL] [EOL] [EOL] def __and__ ( self , other ) : [EOL] [docstring] [EOL] if isinstance ( other , List ) : [EOL] other = other . to_list ( ) [EOL] if isinstance ( other , list ) : [EOL] s_other = set ( other ) [EOL] return List ( [ item for item in self if item in s_other ] ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def __add__ ( self , other ) : [EOL] return self . concat ( other ) [EOL] [EOL] [EOL] def __mul__ ( self , scalar ) : [EOL] if isinstance ( scalar , int ) : [EOL] return List ( self . __array * scalar ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return self . difference ( other ) [EOL] [EOL] [EOL] def __lshift__ ( self , obj ) : [EOL] return self . append ( obj ) [EOL] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , List ) : [EOL] return self . __array == other . to_list ( ) [EOL] else : [EOL] return False [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . __array ) [EOL] [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . __array ) [EOL] [EOL] [EOL] def all ( self , callback ) : [EOL] [docstring] [EOL] if isinstance ( callback , re . Pattern ) : [EOL] for item in self : [EOL] if isinstance ( item , str ) : [EOL] if not re . match ( callback , item ) : [EOL] return False [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] else : [EOL] return True [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] return all ( list ( map ( callback , self ) ) ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] def any ( self , callback ) : [EOL] [docstring] [EOL] if isinstance ( callback , re . Pattern ) : [EOL] for item in self : [EOL] if isinstance ( item , str ) : [EOL] if re . match ( callback , item ) : [EOL] return True [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] else : [EOL] return False [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] return any ( list ( map ( callback , self ) ) ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] def append ( self , obj ) : [EOL] [docstring] [EOL] a = copy . deepcopy ( self . __array ) [EOL] a . append ( obj ) [EOL] return List ( a ) [EOL] [EOL] [EOL] def chain ( self , other ) : [EOL] [docstring] [EOL] a = [ x for x in self ] [EOL] if other is None and not isinstance ( other , list ) and not isinstance ( other , List ) : [EOL] raise TypeError [EOL] for item in other : [EOL] a . append ( item ) [EOL] return List ( a ) [EOL] [EOL] [EOL] def chunk ( self , callback ) : [EOL] [docstring] [EOL] a = [ ] [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] for item in self : [EOL] if len ( a ) > [number] and callback ( item ) == a [ len ( a ) - [number] ] [ [number] ] : [EOL] a [ len ( a ) - [number] ] [ [number] ] . append ( item ) [EOL] else : [EOL] a . append ( [ callback ( item ) , [ item ] ] ) [EOL] else : [EOL] raise TypeError [EOL] return List ( a ) [EOL] [EOL] [EOL] def chunk_while ( self , callback ) : [EOL] [docstring] [EOL] a = [ [ self . __array [ [number] ] ] ] if len ( self ) > [number] else [ [ ] ] [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] for i in range ( [number] , len ( self . __array ) ) : [EOL] if callback ( self . __array [ i - [number] ] , self . __array [ i ] ) : [EOL] a [ len ( a ) - [number] ] . append ( self . __array [ i ] ) [EOL] else : [EOL] a . append ( [ self . __array [ i ] ] ) [EOL] else : [EOL] raise TypeError [EOL] return List ( a ) [EOL] [EOL] [EOL] def compact ( self ) : [EOL] [docstring] [EOL] return List ( [ item for item in self if item is not None ] ) [EOL] [EOL] [EOL] def concat ( self , other ) : [EOL] [docstring] [EOL] if other is not None and ( not isinstance ( other , list ) and not isinstance ( other , List ) ) : [EOL] raise TypeError [EOL] if isinstance ( other , List ) : [EOL] other = other . to_list ( ) [EOL] a = self . __array [EOL] if other is not None : [EOL] a . extend ( other ) [EOL] return List ( a ) [EOL] [EOL] [EOL] def count ( self , callback = None ) : [EOL] [docstring] [EOL] if callback is None : [EOL] return len ( self . __array ) [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] return sum ( [number] for item in self if callback ( item ) ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] def cycle ( self , num = - [number] , callback = None ) : [EOL] [docstring] [EOL] _counter = [number] [EOL] while True : [EOL] if _counter == num * len ( self . __array ) : [EOL] break [EOL] else : [EOL] _counter += [number] [EOL] value = self . __array [ ( _counter - [number] ) % len ( self . __array ) ] [EOL] if callback is not None : [EOL] yield callback ( value ) [EOL] else : [EOL] yield value [EOL] [EOL] [EOL] def delete ( self , obj ) : [EOL] [docstring] [EOL] return List ( [ item for item in self if item != obj ] ) [EOL] [EOL] [EOL] def delete_at ( self , idx ) : [EOL] [docstring] [EOL] arr = copy . deepcopy ( self . __array ) [EOL] if isinstance ( idx , int ) : [EOL] del arr [ idx ] [EOL] return List ( arr ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def delete_if ( self , callback ) : [EOL] [docstring] [EOL] return self . reject ( callback ) [EOL] [EOL] [EOL] def difference ( self , other ) : [EOL] [docstring] [EOL] if other is not None and not isinstance ( other , list ) and not isinstance ( other , List ) : [EOL] raise TypeError [EOL] if isinstance ( other , List ) : [EOL] other = other . to_list ( ) [EOL] return List ( [ item for item in self . __array if item not in other ] ) [EOL] [EOL] [EOL] def drop ( self , n ) : [EOL] [docstring] [EOL] if isinstance ( n , int ) and n > [number] : [EOL] return List ( self . __array [ n : ] ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def drop_while ( self , callback ) : [EOL] [docstring] [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] arr = [ ] [EOL] for i in range ( [number] , len ( self . __array ) ) : [EOL] if not callback ( self . __array [ i ] ) : [EOL] arr = self . __array [ i : ] [EOL] break [EOL] return List ( arr ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def each_cons ( self , n ) : [EOL] [docstring] [EOL] if isinstance ( n , int ) and [number] < n and n <= len ( self . __array ) : [EOL] return List ( [ self . __array [ i : i + n ] for i in range ( len ( self . __array ) - n + [number] ) ] ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def each_slice ( self , n , callback = None ) : [EOL] [docstring] [EOL] if not isinstance ( n , int ) or n < [number] or ( callback is not None and not isinstance ( callback , types . LambdaType ) ) : [EOL] raise TypeError [EOL] ret = [ ] [EOL] arr = [ ] [EOL] for item in self : [EOL] arr . append ( item ) [EOL] if len ( arr ) >= n : [EOL] if callback is not None : [EOL] ret . append ( list ( map ( callback , arr ) ) ) [EOL] else : [EOL] ret . append ( arr ) [EOL] arr = [ ] [EOL] if arr : [EOL] if callback is not None : [EOL] ret . append ( list ( map ( callback , arr ) ) ) [EOL] else : [EOL] ret . append ( arr ) [EOL] return List ( ret ) [EOL] [EOL] [EOL] def each_with_index ( self , callback = None , start = [number] ) : [EOL] [docstring] [EOL] arr = [ ] [EOL] for idx , val in enumerate ( self . __array [ start : ] ) : [EOL] if callback is None : [EOL] arr . append ( [ idx + start , val ] ) [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] arr . append ( callback ( idx + start , val ) ) [EOL] else : [EOL] raise TypeError [EOL] return List ( arr ) [EOL] [EOL] [EOL] def each_with_object ( self , callback = None , object = None ) : [EOL] [docstring] [EOL] if callback is not None and not isinstance ( callback , types . LambdaType ) : [EOL] raise TypeError [EOL] [EOL] arr = [ ] [EOL] for item in self : [EOL] if callback is not None : [EOL] arr . append ( [ item , copy . deepcopy ( callback ( item , object ) ) ] ) [EOL] else : [EOL] arr . append ( [ item , object ] ) [EOL] return List ( arr ) [EOL] [EOL] [EOL] def empty ( self ) : [EOL] [docstring] [EOL] return len ( self . __array ) == [number] [EOL] [EOL] [EOL] def find ( self , callback , default = None ) : [EOL] [docstring] [EOL] for i in self : [EOL] if callback ( i ) : [EOL] return i [EOL] else : [EOL] if default is not None : [EOL] return default [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def find_all ( self , callback = None ) : [EOL] [docstring] [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] return List ( [ item for item in self if callback ( item ) ] ) [EOL] elif callback is None : [EOL] return List ( [ item for item in self ] ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def find_index ( self , callback ) : [EOL] [docstring] [EOL] arr = [ ] [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] arr = [ idx for idx , val in enumerate ( self ) if callback ( val ) ] [EOL] return arr [ [number] ] if len ( arr ) > [number] else None [EOL] [EOL] [EOL] def find_rindex ( self , callback ) : [EOL] [docstring] [EOL] arr = copy . deepcopy ( self . __array ) [EOL] arr . reverse ( ) [EOL] ret = List ( arr ) . find_index ( callback ) [EOL] return len ( self ) - [number] - ret if ret is not None else None [EOL] [EOL] [EOL] def first ( self , num = None ) : [EOL] [docstring] [EOL] if num is not None : [EOL] if isinstance ( num , int ) : [EOL] return self . __array [ : num ] [EOL] else : [EOL] raise TypeError [EOL] else : [EOL] return self . __array [ [number] ] if len ( self . __array ) > [number] else None [EOL] [EOL] [EOL] def first_while ( self , callback ) : [EOL] [docstring] [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] arr = [ ] [EOL] for item in self : [EOL] if callback ( item ) : [EOL] arr . append ( item ) [EOL] else : [EOL] break [EOL] return List ( arr ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def flat_map ( self , callback = None ) : [EOL] [docstring] [EOL] arr = list ( map ( callback , self ) ) if callback is not None else copy . deepcopy ( self . __array ) [EOL] ret = [ ] [EOL] for i in arr : [EOL] if isinstance ( i , list ) : [EOL] ret . extend ( i ) [EOL] else : [EOL] ret . append ( i ) [EOL] return List ( ret ) [EOL] [EOL] [EOL] def grep ( self , pattern , callback = None ) : [EOL] [docstring] [EOL] arr = [ ] [EOL] if isinstance ( pattern , re . Pattern ) or isinstance ( pattern , str ) : [EOL] arr = [ item for item in self if re . search ( pattern , item ) ] [EOL] else : [EOL] raise TypeError [EOL] [EOL] if callback is not None and isinstance ( callback , types . LambdaType ) : [EOL] arr = list ( map ( callback , arr ) ) [EOL] return List ( arr ) [EOL] [EOL] def grep_v ( self , pattern , callback = None ) : [EOL] [docstring] [EOL] arr = [ ] [EOL] if isinstance ( pattern , re . Pattern ) or isinstance ( pattern , str ) : [EOL] arr = [ item for item in self if not re . search ( pattern , item ) ] [EOL] else : [EOL] raise TypeError [EOL] if callback is not None and isinstance ( callback , types . LambdaType ) : [EOL] arr = list ( map ( callback , arr ) ) [EOL] return List ( arr ) [EOL] [EOL] def group_by ( self , callback ) : [EOL] [docstring] [EOL] if not isinstance ( callback , types . LambdaType ) : [EOL] raise TypeError [EOL] d = { } [EOL] for item in self : [EOL] k = callback ( item ) [EOL] if k in d : [EOL] d [ k ] . append ( item ) [EOL] else : [EOL] d [ k ] = [ item ] [EOL] return d [EOL] [EOL] [EOL] def include ( self , value ) : [EOL] [docstring] [EOL] return value in self [EOL] [EOL] [EOL] def join ( self , separator = None ) : [EOL] [docstring] [EOL] if separator is None : [EOL] return [string] . join ( list ( map ( lambda x : str ( x ) , self . __array ) ) ) [EOL] elif isinstance ( separator , str ) : [EOL] return separator . join ( list ( map ( lambda x : str ( x ) , self . __array ) ) ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def keep_if ( self , callback ) : [EOL] [docstring] [EOL] return self . find_all ( callback ) [EOL] [EOL] [EOL] def map ( self , callback = None ) : [EOL] [docstring] [EOL] if callback is None : [EOL] return List ( self . __array ) [EOL] else : [EOL] return List ( list ( map ( callback , self ) ) ) [EOL] [EOL] [EOL] def max ( self , callback = None ) : [EOL] [docstring] [EOL] if len ( self . __array ) == [number] : [EOL] return None [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] return max ( self . __array , key = callback ) [EOL] elif callback is None : [EOL] return max ( self . __array ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def max_n ( self , num , callback = None ) : [EOL] [docstring] [EOL] if len ( self . __array ) == [number] : [EOL] return List ( [ ] ) [EOL] if isinstance ( num , int ) : [EOL] if callback is None : [EOL] arr = sorted ( self . __array ) [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] arr = sorted ( self . __array , key = callback ) [EOL] else : [EOL] raise TypeError [EOL] return List ( arr [ - num : ] ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def min ( self , callback = None ) : [EOL] [docstring] [EOL] if not len ( self . __array ) : [EOL] return None [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] return min ( self . __array , key = callback ) [EOL] elif callback is None : [EOL] return min ( self . __array ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def min_n ( self , num , callback = None ) : [EOL] [docstring] [EOL] if not len ( self . __array ) : [EOL] return List ( [ ] ) [EOL] if isinstance ( num , int ) : [EOL] if callback is None : [EOL] return List ( sorted ( self . __array ) [ : num ] ) [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] return List ( sorted ( self . __array , key = callback ) [ : num ] ) [EOL] else : [EOL] raise TypeError [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def none ( self , callback = None ) : [EOL] [docstring] [EOL] if callback is None : [EOL] for item in self : [EOL] if item : [EOL] return False [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] for item in self : [EOL] if callback ( item ) : [EOL] return False [EOL] else : [EOL] raise TypeError [EOL] return True [EOL] [EOL] [EOL] def one ( self , callback = None ) : [EOL] [docstring] [EOL] counter = [number] [EOL] if callback is None : [EOL] for item in self : [EOL] if item : [EOL] counter += [number] [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] for item in self : [EOL] if callback ( item ) : [EOL] counter += [number] [EOL] else : [EOL] raise TypeError [EOL] return counter == [number] [EOL] [EOL] [EOL] def partition ( self , callback = None ) : [EOL] [docstring] [EOL] arr = [ [ ] , [ ] ] [EOL] if callback is None : [EOL] for item in self : [EOL] if item : [EOL] arr [ [number] ] . append ( item ) [EOL] else : [EOL] arr [ [number] ] . append ( item ) [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] for item in self : [EOL] if callback ( item ) : [EOL] arr [ [number] ] . append ( item ) [EOL] else : [EOL] arr [ [number] ] . append ( item ) [EOL] else : [EOL] raise TypeError [EOL] return List ( arr ) [EOL] [EOL] [EOL] def reduce ( self , callback , init = None ) : [EOL] [docstring] [EOL] if len ( self . __array ) == [number] : [EOL] return None [EOL] if isinstance ( callback , types . LambdaType ) : [EOL] if init is not None : [EOL] memo = init [EOL] arr = self . __array [EOL] else : [EOL] memo = self . __array [ [number] ] [EOL] arr = self . __array [ [number] : ] [EOL] for item in arr : [EOL] memo = callback ( memo , item ) [EOL] return memo [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def reject ( self , callback = None ) : [EOL] [docstring] [EOL] arr = [ ] [EOL] if callback is None : [EOL] arr = [ item for item in self if not item ] [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] arr = [ item for item in self if not callback ( item ) ] [EOL] else : [EOL] raise TypeError [EOL] return List ( arr ) [EOL] [EOL] [EOL] def reverse ( self ) : [EOL] [docstring] [EOL] arr = copy . deepcopy ( self . __array ) [EOL] arr . reverse ( ) [EOL] return List ( arr ) [EOL] [EOL] [EOL] def rotate ( self , num ) : [EOL] [docstring] [EOL] if isinstance ( num , int ) : [EOL] num = num % len ( self ) [EOL] return List ( self . __array [ - num : ] + self . __array [ : - num ] ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def select ( self , callback ) : [EOL] [docstring] [EOL] return self . find_all ( callback ) [EOL] [EOL] [EOL] def shuffle ( self ) : [EOL] [docstring] [EOL] arr = copy . deepcopy ( self . __array ) [EOL] random . shuffle ( arr ) [EOL] return List ( arr ) [EOL] [EOL] [EOL] def sort ( self , callback = None ) : [EOL] [docstring] [EOL] if callback is None or isinstance ( callback , types . LambdaType ) : [EOL] return List ( sorted ( self . __array , key = callback ) ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def to_list ( self ) : [EOL] [docstring] [EOL] return copy . deepcopy ( self . __array ) [EOL] [EOL] [EOL] def unique ( self , callback = None ) : [EOL] [docstring] [EOL] if callback is None : [EOL] return List ( list ( set ( self . __array ) ) ) [EOL] elif isinstance ( callback , types . LambdaType ) : [EOL] d = { } [EOL] for item in self . __array : [EOL] d [ callback ( item ) ] = item [EOL] return List ( list ( d . values ( ) ) ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] def zip ( self , other ) : [EOL] [docstring] [EOL] if isinstance ( other , list ) or isinstance ( other , List ) : [EOL] l = max ( len ( self . __array ) , len ( other ) ) [EOL] arr = [ ] [EOL] for i in range ( [number] , l ) : [EOL] a = self . __array [ i ] if i < len ( self . __array ) else None [EOL] b = other [ i ] if i < len ( other ) else None [EOL] arr . append ( [ a , b ] ) [EOL] return List ( arr ) [EOL] else : [EOL] raise TypeError [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestLen ( TestCase ) : [EOL] [EOL] def test_len_if_not_empty ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( len ( e ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_len_if_empty ( self ) : [EOL] e = Set ( ) [EOL] expect ( len ( e ) ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestKeepIf ( TestCase ) : [EOL] [EOL] def test_keep_if_if_self_is_empty ( self ) : [EOL] e = Set ( ) [EOL] expect ( e . keep_if ( lambda x : x % [number] == [number] ) ) . to ( equal ( Set ( ) ) ) [EOL] [EOL] def test_keep_if_if_no_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . keep_if ( lambda x : x > [number] ) ) . to ( equal ( Set ( ) ) ) [EOL] [EOL] def test_keep_if_if_all_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] expect ( e . keep_if ( lambda x : x >= [number] ) ) . to ( equal ( Set ( { [number] , [number] , [number] , [number] , [number] } ) ) ) [EOL] [EOL] def test_keep_if_if_partial_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . keep_if ( lambda x : x % [number] == [number] ) ) . to ( equal ( Set ( { [number] , [number] } ) ) ) [EOL] [EOL] def test_keep_if_lambda_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . keep_if ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestEq ( TestCase ) : [EOL] [EOL] def test_eq_other_not_equal ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( e == o ) . to ( be_false ) [EOL] [EOL] def test_eq_other_not_equal_both_enhanced_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e == o ) . to ( be_false ) [EOL] [EOL] def test_eq_other_greater_len ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( e == o ) . to ( be_false ) [EOL] [EOL] def test_eq_other_is_equal ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] } [EOL] expect ( e == o ) . to ( be_false ) [EOL] [EOL] def test_eq_other_is_equal_with_enhanced_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e == o ) . to ( be_true ) [EOL] [EOL] def test_eq_other_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e == [number] ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestDelete ( TestCase ) : [EOL] [EOL] def test_delete_if_set_contains_element ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . delete ( [number] ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] } ) ) [EOL] [EOL] def test_delete_if_set_not_contains_element ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( lambda : e . delete ( [number] ) ) . to ( raise_error ( KeyError ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import Set [EOL] [EOL] class TestAnd ( TestCase ) : [EOL] [EOL] def test_and_other_with_inersection ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( ( e & o ) . to_set ( ) ) . to ( equal ( { [number] , [number] } ) ) [EOL] [EOL] [EOL] def test_and_other_without_intersection ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( ( e & { [number] , [number] , [number] } ) . to_set ( ) ) . to ( equal ( set ( ) ) ) [EOL] [EOL] [EOL] def test_and_other_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e & None ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestDivide ( TestCase ) : [EOL] [EOL] def test_divide_lambda_creates_subsets ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] , [number] , [number] , [number] } ) [EOL] expect ( e . divide ( lambda i , j : abs ( i - j ) == [number] ) . to_set ( ) ) . to ( equal ( { Set ( { [number] } ) , Set ( { [number] , [number] } ) , Set ( { [number] } ) , Set ( { [number] , [number] , [number] } ) } ) ) [EOL] [EOL] def test_divide_lambda_creates_single_element_subsets ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] print ( e . divide ( lambda i , j : abs ( i - j ) == [number] ) ) [EOL] expect ( e . divide ( lambda i , j : abs ( i - j ) == [number] ) . to_set ( ) ) . to ( equal ( { Set ( { [number] } ) , Set ( { [number] } ) , Set ( { [number] } ) , Set ( { [number] } ) , Set ( { [number] } ) } ) ) [EOL] [EOL] def test_divide_if_set_is_empty ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . divide ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import Set [EOL] [EOL] class TestUnion ( TestCase ) : [EOL] [EOL] def test_union_other_with_common_values ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . union ( o ) ) . to ( equal ( Set ( { [number] , [number] , [number] , [number] } ) ) ) [EOL] [EOL] [EOL] def test_union_other_without_common_values ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e . union ( o ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] , [number] , [number] , [number] } ) ) [EOL] [EOL] [EOL] def test_union_other_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . union ( None ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestIsdisjoint ( TestCase ) : [EOL] [EOL] def test_isdisjoint_if_have_intersection ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . isdisjoint ( { [number] , [number] , [number] } ) ) . to ( be_false ) [EOL] [EOL] def test_isdisjoint_if_disjoint ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . isdisjoint ( Set ( { [number] , [number] , [number] } ) ) ) . to ( be_true ) [EOL] [EOL] def test_isdisjoint_if_param_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e . isdisjoint ( [string] ) ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestDifference ( TestCase ) : [EOL] [EOL] def test_difference_if_other_subset_of_self_enhanced_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] } ) [EOL] expect ( e . difference ( o ) . to_set ( ) ) . to ( equal ( { [number] , [number] } ) ) [EOL] [EOL] def test_difference_if_other_equivalent_to_self ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( e . difference ( o ) . to_set ( ) ) . to ( equal ( set ( ) ) ) [EOL] [EOL] def test_difference_if_set_is_empty ( self ) : [EOL] e = Set ( ) [EOL] o = { [number] , [number] } [EOL] expect ( e . difference ( o ) . to_set ( ) ) . to ( equal ( set ( ) ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import Set [EOL] [EOL] class TestIntersection ( TestCase ) : [EOL] [EOL] def test_intersection_other_with_inersection ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( e . intersection ( o ) . to_set ( ) ) . to ( equal ( { [number] , [number] } ) ) [EOL] [EOL] [EOL] def test_intersection_other_without_intersection ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e . intersection ( o ) . to_set ( ) ) . to ( equal ( set ( ) ) ) [EOL] [EOL] [EOL] def test_intersection_other_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . intersection ( None ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestIssubset ( TestCase ) : [EOL] [EOL] def test_issubset_self_is_subset_of_other_set ( self ) : [EOL] e = Set ( { [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( e . issubset ( o ) ) . to ( be_true ) [EOL] [EOL] def test_issubset_self_is_not_subset_of_other_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = { [number] , [number] , [number] , [number] } [EOL] expect ( e . issubset ( o ) ) . to ( be_false ) [EOL] [EOL] def test_issubset_self_is_subset_of_other_enhanced_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] expect ( e . issubset ( o ) ) . to ( be_true ) [EOL] [EOL] def test_issubset_self_is_not_subset_of_other_enhanced_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] o = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . issubset ( o ) ) . to ( be_false ) [EOL] [EOL] def test_issubset_other_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . issubset ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestInclude ( TestCase ) : [EOL] [EOL] def test_include_if_self_contains_element ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( e . include ( [number] ) ) . to ( be_true ) [EOL] [EOL] def test_include_if_self_not_contains_elements ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . include ( [number] ) ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestFlatten ( TestCase ) : [EOL] [EOL] def test_flatten_if_unflatten_set ( self ) : [EOL] e = Set ( { frozenset ( { [number] } ) , frozenset ( { [number] , [number] } ) , [number] , frozenset ( { [number] , [number] , [number] , [number] } ) } ) [EOL] expect ( e . flatten ( ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] , [number] , [number] , [number] , [number] } ) ) [EOL] [EOL] def test_flatten_flat_set ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . flatten ( ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] , [number] } ) ) [EOL] [EOL] def test_flatten_if_subset_is_enhanced_set ( self ) : [EOL] e = Set ( { Set ( { [number] , [number] , [number] } ) , frozenset ( { [number] , [number] , [number] } ) , [number] , Set ( { [number] , [number] , [number] } ) } ) [EOL] expect ( e . flatten ( ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] , [number] , [number] , [number] } ) ) [EOL] [EOL] def test_flatten_empty_set ( self ) : [EOL] e = Set ( ) [EOL] expect ( e . flatten ( ) . to_set ( ) ) . to ( equal ( set ( ) ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestMap ( TestCase ) : [EOL] [EOL] def test_map_if_self_is_empty ( self ) : [EOL] e = Set ( ) [EOL] expect ( e . map ( lambda x : x % [number] == [number] ) ) . to ( equal ( Set ( ) ) ) [EOL] [EOL] def test_map_with_aritmethic ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . map ( lambda x : x * [number] ) ) . to ( equal ( Set ( { [number] , [number] , [number] , [number] } ) ) ) [EOL] [EOL] def test_map_with_bool ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] expect ( e . map ( lambda x : x >= [number] ) ) . to ( equal ( Set ( { False , True } ) ) ) [EOL] [EOL] def test_map_lambda_is_different ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . map ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestSelect ( TestCase ) : [EOL] [EOL] def test_select_if_self_is_empty ( self ) : [EOL] e = Set [ int ] ( ) [EOL] expect ( e . select ( lambda x : x % [number] == [number] ) ) . to ( equal ( Set [ int ] ( ) ) ) [EOL] [EOL] def test_select_if_no_match ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . select ( lambda x : x > [number] ) ) . to ( equal ( Set [ int ] ( ) ) ) [EOL] [EOL] def test_select_if_all_match ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] expect ( e . select ( lambda x : x >= [number] ) ) . to ( equal ( Set [ int ] ( { [number] , [number] , [number] , [number] , [number] } ) ) ) [EOL] [EOL] def test_select_if_partial_match ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . select ( lambda x : x % [number] == [number] ) ) . to ( equal ( Set [ int ] ( { [number] , [number] } ) ) ) [EOL] [EOL] def test_select_lambda_is_different ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . select ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestLt ( TestCase ) : [EOL] [EOL] def test_lt_self_is_not_proper_subset_of_other_enhanced_set ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] o = Set [ int ] ( { [number] , [number] , [number] , [number] , [number] } ) [EOL] expect ( e < o ) . to ( be_false ) [EOL] [EOL] def test_lt_self_is_not_subset_of_other_enhanced_set ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] , [number] } ) [EOL] o = Set [ int ] ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e < o ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestEmpty ( TestCase ) : [EOL] [EOL] def test_empty_if_self_is_empty ( self ) : [EOL] e = Set ( ) [EOL] expect ( e . empty ( ) ) . to ( be_true ) [EOL] [EOL] def test_empty_if_self_is_not_empty ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . empty ( ) ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestReject ( TestCase ) : [EOL] [EOL] def test_reject_if_lambda_find_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . reject ( lambda x : x % [number] == [number] ) . to_set ( ) ) . to ( equal ( { [number] , [number] } ) ) [EOL] [EOL] def test_reject_if_lambda_finds_no_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . reject ( lambda x : x > [number] ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] , [number] } ) ) [EOL] [EOL] def test_reject_if_set_is_empty ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . reject ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import Set [EOL] [EOL] class TestOr ( TestCase ) : [EOL] [EOL] def test_or_other_with_common_values ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] , [number] } ) [EOL] o = Set [ int ] ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e | o ) . to ( equal ( Set [ int ] ( { [number] , [number] , [number] , [number] } ) ) ) [EOL] [EOL] def test_or_other_without_common_values ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] } ) [EOL] o = Set [ int ] ( { [number] , [number] , [number] } ) [EOL] expect ( e | o ) . to ( equal ( Set [ int ] ( { [number] , [number] , [number] , [number] , [number] , [number] } ) ) ) [EOL] [EOL] def test_or_other_is_different ( self ) : [EOL] e = Set [ int ] ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e | None ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestDeleteIf ( TestCase ) : [EOL] [EOL] def test_delete_if_if_lambda_find_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . delete_if ( lambda x : x % [number] == [number] ) . to_set ( ) ) . to ( equal ( { [number] , [number] } ) ) [EOL] [EOL] def test_delete_if_if_lambda_finds_no_match ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( e . delete_if ( lambda x : x > [number] ) . to_set ( ) ) . to ( equal ( { [number] , [number] , [number] , [number] } ) ) [EOL] [EOL] def test_delete_if_if_set_is_empty ( self ) : [EOL] e = Set ( { [number] , [number] , [number] } ) [EOL] expect ( lambda : e . delete_if ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_false , be_true [EOL] [EOL] from slender import Set [EOL] [EOL] class TestStr ( TestCase ) : [EOL] [EOL] def test_str_if_self_is_empty ( self ) : [EOL] e = Set ( ) [EOL] expect ( str ( e ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_str_if_self_contains_elements ( self ) : [EOL] e = Set ( { [number] , [number] , [number] , [number] } ) [EOL] expect ( str ( e ) ) . to ( equal ( [string] ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.set.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestKeepIf ( TestCase ) : [EOL] [EOL] def test_keep_if_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . keep_if ( lambda k , v : k ) ) . to ( be_empty ) [EOL] [EOL] def test_keep_if_if_dictionary_contains_elements_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . keep_if ( lambda k , v : v % [number] == [number] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_keep_if_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . keep_if ( lambda k , v : v > [number] ) ) . to ( be_empty ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestEachKey ( TestCase ) : [EOL] [EOL] def test_each_key_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . each_key ( lambda k : k + [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { } ) ) ) [EOL] [EOL] def test_each_key_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . each_key ( lambda k : k + [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_each_key_if_dictionary_contains_elements_and_key_will_be_the_same ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . each_key ( lambda k : [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] } ) ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestSlice ( TestCase ) : [EOL] [EOL] def test_slice_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . slice ( [string] ) ) . to ( be_empty ) [EOL] [EOL] def test_slice_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . slice ( [string] ) ) . to ( be_empty ) [EOL] [EOL] def test_slice_if_dictionary_contains_elements_and_all_keys_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . slice ( [string] , [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_slice_if_dictionary_contains_elements_and_some_key_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . slice ( [string] , [string] , [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestDeleteIf ( TestCase ) : [EOL] [EOL] def test_delete_if_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . delete_if ( lambda k , v : k == [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { } ) ) ) [EOL] [EOL] def test_delete_if_if_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . delete_if ( lambda k , v : k == [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_delete_if_if_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . delete_if ( lambda k , v : k == [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestSize ( TestCase ) : [EOL] [EOL] def test_size_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . size ( ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_size_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . size ( ) ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestAssoc ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . key = [string] [EOL] [EOL] def test_assoc_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . assoc ( self . key ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_assoc_if_dictionary_contains_element_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . assoc ( [string] ) ) . to ( equal ( [ [string] , [number] ] ) ) [EOL] [EOL] def test_assoc_if_dictionary_contains_element_and_not_find_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . assoc ( [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestEq ( TestCase ) : [EOL] [EOL] def test_eq_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] d2 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 == d2 ) . to ( be_true ) [EOL] [EOL] def test_eq_if_dictionary_has_different_length ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 == d2 ) . to ( be_false ) [EOL] [EOL] def test_eq_if_dictionary_contains_different_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 == d2 ) . to ( be_false ) [EOL] [EOL] def test_eq_if_dictionary_contains_same_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 == d2 ) . to ( be_true ) [EOL] [EOL] def test_eq_if_param_is_different ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 == [ [number] , [number] , [number] ] ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestHasValue ( TestCase ) : [EOL] [EOL] def test_has_value_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . has_value ( [number] ) ) . to ( be_false ) [EOL] [EOL] def test_has_value_if_dictionary_contains_elements_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . has_value ( [number] ) ) . to ( be_true ) [EOL] [EOL] def test_has_value_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . has_value ( [number] ) ) . to ( be_false ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestHasKey ( TestCase ) : [EOL] [EOL] def test_has_key_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . has_key ( [string] ) ) . to ( be_false ) [EOL] [EOL] def test_has_key_if_dictionary_contains_elements_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . has_key ( [string] ) ) . to ( be_true ) [EOL] [EOL] def test_has_key_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . has_key ( [string] ) ) . to ( be_false ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestAny ( TestCase ) : [EOL] [EOL] def test_any_if_dictionary_is_empty_and_callback_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . any ( callback = lambda x : len ( x ) < [number] ) ) . to ( be_false ) [EOL] [EOL] def test_any_if_dictionary_contains_element_and_callback_given_find_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . any ( callback = lambda k , v : k == [string] ) ) . to ( be_true ) [EOL] [EOL] def test_any_if_dictionary_contains_element_and_callback_given_not_find_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . any ( callback = lambda k , v : v % [number] == [number] ) ) . to ( be_false ) [EOL] [EOL] def test_any_if_callback_is_none ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( lambda : d1 . any ( None ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestEach ( TestCase ) : [EOL] [EOL] def test_each_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . each ( lambda k , v : k + v ) ) . to ( equal ( Dictionary [ str , int ] ( { } ) ) ) [EOL] [EOL] def test_each_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . each ( lambda k , v : k + str ( v ) ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [string] , [string] : [string] , [string] : [string] } ) ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestLe ( TestCase ) : [EOL] [EOL] def test_le_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] d2 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 <= d2 ) . to ( be_true ) [EOL] [EOL] def test_le_if_dictionary_is_less ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 <= d2 ) . to ( be_true ) [EOL] [EOL] def test_lt_if_dictionary_values_differ ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 <= d2 ) . to ( be_false ) [EOL] [EOL] def test_le_if_both_are_equal ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 <= d2 ) . to ( be_true ) [EOL] [EOL] def test_le_if_they_overlap ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 <= d2 ) . to ( be_false ) [EOL] [EOL] def test_le_is_greater_or_equal ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 <= d2 ) . to ( be_false ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestLen ( TestCase ) : [EOL] [EOL] def test_len_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( len ( d1 ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_len_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( len ( d1 ) ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestEmpty ( TestCase ) : [EOL] [EOL] def test_empty_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . empty ( ) ) . to ( be_true ) [EOL] [EOL] def test_empty_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . empty ( ) ) . to ( be_false ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestEachValue ( TestCase ) : [EOL] [EOL] def test_each_value_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . each_value ( lambda v : v + [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { } ) ) ) [EOL] [EOL] def test_each_value_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . each_value ( lambda v : v + [number] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_each_value_if_dictionary_contains_elements_and_value_will_be_the_same ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . each_value ( lambda v : [string] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [string] , [string] : [string] , [string] : [string] } ) ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestGet ( TestCase ) : [EOL] [EOL] def test_get_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . get ( [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_get_if_dictionary_is_empty_and_callback_is_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . get ( [string] , lambda k : k + [string] ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_get_if_dictionary_contains_elements_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . get ( [string] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_get_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . get ( [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_get_if_dictionary_contains_elements_and_not_finds_match_and_callback_is_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . get ( [string] , lambda k : [string] ) ) . to ( equal ( [string] ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestSelect ( TestCase ) : [EOL] [EOL] def test_select_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . select ( lambda k , v : k ) ) . to ( be_empty ) [EOL] [EOL] def test_select_if_dictionary_contains_elements_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . select ( lambda k , v : v % [number] == [number] ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_select_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . select ( lambda k , v : v > [number] ) ) . to ( be_empty ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestGetValues ( TestCase ) : [EOL] [EOL] def test_get_values_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( lambda : d1 . get_values ( [string] , [string] ) ) . to ( raise_error ( KeyError ) ) [EOL] [EOL] def test_get_values_if_dictionary_is_empty_and_callback_is_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . get_values ( [string] , [string] , callback = lambda k : k . upper ( ) ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_get_values_if_dictionary_contains_elements_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . get_values ( [string] , [string] ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_get_values_if_dictionary_contains_elements_and_not_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( lambda : d1 . get_values ( [string] , [string] ) ) . to ( raise_error ( KeyError ) ) [EOL] [EOL] def test_get_values_if_dictionary_contains_elements_and_not_finds_match_and_callback_is_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . get_values ( [string] , [string] , callback = lambda k : k . upper ( ) ) ) . to ( equal ( [ [number] , [string] ] ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestDefault ( TestCase ) : [EOL] [EOL] def test_default_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] d1 . default ( [string] ) [EOL] expect ( d1 [ [string] ] ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_default_if_dictionary_not_contains_none_element ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d1 . default ( [string] ) [EOL] expect ( d1 [ [string] ] ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_default_if_dictionary_contains_none_element ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] d1 . default ( [string] ) [EOL] expect ( d1 [ [string] ] ) . to ( equal ( [number] ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestToList ( TestCase ) : [EOL] [EOL] def test_to_list_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . to_list ( ) ) . to ( be_empty ) [EOL] [EOL] def test_to_list_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . to_list ( ) ) . to ( equal ( [ [ [string] , [number] ] , [ [string] , [number] ] , [ [string] , [number] ] , [ [string] , [number] ] ] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestMerge ( TestCase ) : [EOL] [EOL] def test_merge_if_both_dictionaries_are_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] d2 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . merge ( d2 ) ) . to ( be_empty ) [EOL] [EOL] def test_merge_if_dictionary_is_empty_and_param_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . merge ( d2 ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_merge_if_dictionary_is_not_emtpy_and_param_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . merge ( d2 ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_merge_if_both_dictionaries_contain_different_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . merge ( d2 ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_merge_if_both_dictionaries_contain_same_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . merge ( d2 ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_merge_if_both_dictionaries_contain_same_elements_and_callback_is_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . merge ( d2 , lambda k , ov , nv : ov + nv ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_merge_if_param_is_dict_and_both_contain_same_elements_and_callback_is_given ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] d2 = { [string] : [number] , [string] : [number] } [EOL] expect ( d1 . merge ( d2 , lambda k , ov , nv : ov + nv ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_merge_if_parameter_type_is_different ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( lambda : d1 . merge ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] from slender . command_line import main [EOL] [EOL] class TestInit ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . l = Dictionary [ str , int ] ( ) [EOL] [EOL] def test_dictionary_is_not_none ( self ) : [EOL] expect ( self . l ) . not_to ( equal ( None ) ) [EOL] [EOL] def test_dictionary_init_accepts_builtin_dict ( self ) : [EOL] d = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( d ) . not_to ( equal ( None ) ) [EOL] [EOL] def test_dictionary_init_accepts_dictionary ( self ) : [EOL] d = Dictionary [ str , int ] ( Dictionary [ str , int ] ( ) ) [EOL] expect ( d ) . not_to ( equal ( None ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestContain ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . key = [string] [EOL] [EOL] def test_contain_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( self . key in d1 ) . to ( be_false ) [EOL] [EOL] def test_contain_if_dictionary_not_contains_key ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] } ) [EOL] expect ( self . key in d1 ) . to ( be_false ) [EOL] [EOL] def test_contain_if_dictionary_contains_key ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( self . key in d1 ) . to ( be_true ) [EOL] [EOL] def test_contain_if_negate ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] } ) [EOL] expect ( self . key not in d1 ) . to ( be_true ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestCompact ( TestCase ) : [EOL] [EOL] def test_compact_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . compact ( ) ) . to ( equal ( Dictionary [ str , int ] ( { } ) ) ) [EOL] [EOL] def test_compact_if_dictionary_not_contains_none_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . compact ( ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) ) ) [EOL] [EOL] def test_compact_if_dictionary_contains_none_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : None , [string] : [number] , [string] : None } ) [EOL] expect ( d1 . compact ( ) ) . to ( equal ( Dictionary [ str , int ] ( { [string] : [number] } ) ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestDig ( TestCase ) : [EOL] [EOL] def test_dig_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . dig ( [string] , [string] , [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_dig_if_keys_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . dig ( ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_dig_if_dictionary_contains_element ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : { [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } , [string] : [number] } ) [EOL] expect ( d1 . dig ( [string] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_dig_if_dictionary_contains_embedded_dictionary_with_keys_path ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : { [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } , [string] : [number] } ) [EOL] expect ( d1 . dig ( [string] , [string] , [string] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_dig_if_dictionary_not_contains_key ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : { [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } , [string] : [number] } ) [EOL] expect ( d1 . dig ( [string] , [string] , [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_dig_if_dictionary_contains_embedded_dictionary_intermediate_key_is_none ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : { [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } , [string] : [number] } ) [EOL] expect ( d1 . dig ( [string] , [string] , [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_dig_if_dictionary_embedded_key_is_not_dictionary ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : { [string] : [number] , [string] : [ ] } , [string] : [number] } ) [EOL] expect ( d1 . dig ( [string] , [string] , [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestToDict ( TestCase ) : [EOL] [EOL] def test_to_dict_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . to_dict ( ) ) . to ( be_empty ) [EOL] [EOL] def test_to_dict_if_dictionary_contains_elements ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . to_dict ( ) ) . to ( equal ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import Dictionary [EOL] [EOL] class TestDelete ( TestCase ) : [EOL] [EOL] def test_delete_if_dictionary_is_empty ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { } ) [EOL] expect ( d1 . delete ( [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_delete_if_dictionary_contains_element_and_finds_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . delete ( [string] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_delete_if_dictionary_contains_element_and_not_find_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . delete ( [string] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_delete_if_dictionary_contains_element_and_callback_is_given_and_not_find_match ( self ) : [EOL] d1 = Dictionary [ str , int ] ( { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] expect ( d1 . delete ( [string] , callback = lambda x : x + [string] ) ) . to ( equal ( [string] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.dictionary.Dictionary[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestDrop ( TestCase ) : [EOL] [EOL] def test_drop_if_param_greater_than_length_returns_empty ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . drop ( [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_drop_if_param_is_between_zero_and_length_returns_part ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . drop ( [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_drop_if_param_is_less_than_zero_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . drop ( - [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_drop_if_param_is_different_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . drop ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestLen ( TestCase ) : [EOL] [EOL] def test_len_if_list_is_not_empty ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( len ( e ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_len_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( len ( e ) ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestKeepIf ( TestCase ) : [EOL] [EOL] def test_keep_if_if_func_is_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . keep_if ( None ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_keep_if_if_func_is_valid ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . keep_if ( lambda item : item > [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_keep_if_if_func_is_invalid_for_all_items ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . keep_if ( lambda item : item > [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_keep_if_if_func_is_different ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . keep_if ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestAppend ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_append_if_other_is_none ( self ) : [EOL] expect ( self . l . append ( None ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , None ] ) ) [EOL] [EOL] def test_append_if_other_is_not_none ( self ) : [EOL] expect ( self . l . append ( [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [ [number] , [number] ] ] ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestChunkWhile ( TestCase ) : [EOL] [EOL] def test_chunk_while_one_by_one ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . chunk_while ( lambda i , j : i + [number] == j ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) ) [EOL] [EOL] def test_chunk_while_non_decreasing ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . chunk_while ( lambda i , j : i <= j ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] ] ] ) ) [EOL] [EOL] def test_chunk_while_adjacent_evens_odds ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . chunk_while ( lambda i , j : i % [number] == j % [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) ) [EOL] [EOL] def test_chunk_while_if_param_is_not_lambda ( self ) : [EOL] e = List ( [ [number] , [number] ] ) [EOL] expect ( lambda : e . chunk_while ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestIter ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_iter_if_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] it = iter ( e ) [EOL] expect ( lambda : next ( it ) ) . to ( raise_error ( StopIteration ) ) [EOL] [EOL] def test_iter_if_non_empty ( self ) : [EOL] it = iter ( self . e ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestAnd ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_and_if_other_is_none ( self ) : [EOL] expect ( lambda : self . l & None ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_and_if_other_is_empty ( self ) : [EOL] expect ( ( self . l & [ ] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_and_if_other_is_non_empty ( self ) : [EOL] o = List ( [ [number] , [number] ] ) [EOL] expect ( ( self . l & o ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_and_if_self_is_empty ( self ) : [EOL] l = List ( ) [EOL] o = List ( [ [string] , [string] ] ) [EOL] expect ( ( l & o ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_and_if_self_and_other_are_disjoint ( self ) : [EOL] l = List ( [ [number] , [number] , [number] ] ) [EOL] o = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( ( l & o ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_and_if_other_is_different ( self ) : [EOL] l = List ( ) [EOL] o = [string] [EOL] expect ( lambda : l & o ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $slender.list.List$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestMaxN ( TestCase ) : [EOL] [EOL] def test_max_n_if_list_of_numbers ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . max_n ( [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_max_n_if_list_of_string ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . max_n ( [number] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_max_n_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . max_n ( [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_max_n_if_list_is_empty_with_lambda ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . max_n ( [number] , lambda x : len ( x ) ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_max_n_if_compare_with_lambda_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . max_n ( [number] , lambda x : len ( x ) ) . to_list ( ) ) . to ( equal ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_max_n_if_compare_with_lambda_div ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . max_n ( [number] , lambda x : x % [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_max_n_if_num_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . max_n ( [string] , lambda x : len ( x ) ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_max_n_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . max_n ( [number] , [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestPartition ( TestCase ) : [EOL] [EOL] def test_partition_if_lambda_is_none ( self ) : [EOL] e = List ( [ None , [number] , [number] , [ ] , [number] , [number] , [number] , [string] , [number] ] ) [EOL] expect ( e . partition ( ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] , [number] , [number] , [number] ] , [ None , [number] , [ ] , [string] ] ] ) ) [EOL] [EOL] def test_partition_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . partition ( lambda x : x == [number] ) . to_list ( ) ) . to ( equal ( [ [ ] , [ ] ] ) ) [EOL] [EOL] def test_partition_if_lambda_is_valid_greater_than ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . partition ( lambda x : x > [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] def test_partition_if_lambda_is_valid_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . partition ( lambda x : len ( x ) > [number] ) . to_list ( ) ) . to ( equal ( [ [ [string] ] , [ [string] , [string] , [string] , [string] ] ] ) ) [EOL] [EOL] def test_partition_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . partition ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestMinN ( TestCase ) : [EOL] [EOL] def test_min_n_if_list_of_numbers ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . min_n ( [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_min_n_if_list_of_string ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . min_n ( [number] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_min_n_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . min_n ( [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_min_n_if_list_is_empty_with_lambda ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . min_n ( [number] , lambda x : len ( x ) ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_min_n_if_compare_with_lambda_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . min_n ( [number] , lambda x : len ( x ) ) . to_list ( ) ) . to ( equal ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_min_n_if_compare_with_lambda_div ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . min_n ( [number] , lambda x : x % [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_min_n_if_num_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . min_n ( [string] , lambda x : len ( x ) ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_min_n_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . min_n ( [number] , [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import slender [EOL] import re [EOL] [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestUnique ( TestCase ) : [EOL] [EOL] def test_unique_if_lambda_is_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] act = e . unique ( ) . to_list ( ) [EOL] expect ( sorted ( act ) ) . to ( equal ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_unique_if_lambda_is_not_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] act = e . unique ( lambda x : x [ [number] ] ) . to_list ( ) [EOL] expect ( act ) . to ( equal ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_unique_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . unique ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFindRindex ( TestCase ) : [EOL] [EOL] def test_find_rindex_if_param_is_in_range ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_rindex ( lambda x : x == [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_find_rindex_if_param_is_the_first_item_in_the_list ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_rindex ( lambda x : x <= [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_find_rindex_if_param_is_out_of_range ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_rindex ( lambda x : x == [number] ) [EOL] expect ( act ) . to ( equal ( None ) ) [EOL] [EOL] def test_find_rindex_if_param_is_lambda_with_match ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_rindex ( lambda item : item > [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestReduce ( TestCase ) : [EOL] [EOL] def test_reduce_if_init_is_not_given_and_concat ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . reduce ( lambda memo , s : memo + s ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_reduce_if_init_is_not_given_and_add_up ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . reduce ( lambda sum , x : sum + x ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_reduce_if_init_is_given_and_concat ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . reduce ( lambda memo , s : memo + s , [string] ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_reduce_if_init_is_given_and_add_up ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . reduce ( lambda sum , x : sum + x , [number] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_reduce_if_array_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . reduce ( lambda sum , x : sum + x , [number] ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_reduce_if_callback_is_different ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . reduce ( [number] , [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestCycle ( TestCase ) : [EOL] [EOL] def test_cycle_if_param_and_func_not_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] ] ) [EOL] it = e . cycle ( [number] , lambda x : x . upper ( ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [string] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [string] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [string] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [string] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [string] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_cycle_if_func_is_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] it = e . cycle ( [number] ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_cycle_if_lambda ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] it = e . cycle ( callback = lambda i : i % [number] == [number] ) [EOL] expect ( next ( it ) ) . to ( equal ( False ) ) [EOL] expect ( next ( it ) ) . to ( equal ( True ) ) [EOL] expect ( next ( it ) ) . to ( equal ( True ) ) [EOL] expect ( next ( it ) ) . to ( equal ( True ) ) [EOL] [EOL] def test_cycle_if_no_params ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] it = e . cycle ( ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] expect ( next ( it ) ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestConcat ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_concat_if_other_is_empty ( self ) : [EOL] expect ( self . l . concat ( [ ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_concat_if_other_is_non_empty ( self ) : [EOL] o = List ( [ [string] , [string] ] ) [EOL] expect ( self . l . concat ( o ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [string] , [string] ] ) ) [EOL] [EOL] def test_concat_if_self_is_empty ( self ) : [EOL] l = List ( ) [EOL] o = List ( [ [string] , [string] ] ) [EOL] expect ( l . concat ( o ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_concat_if_other_is_different ( self ) : [EOL] l = List ( ) [EOL] o = [string] [EOL] expect ( lambda : l . concat ( o ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestSort ( TestCase ) : [EOL] [EOL] def test_sort_if_lambda_is_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . sort ( ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_sort_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . sort ( lambda x : len ( x ) ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_sort_if_lambda_is_valid_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . sort ( lambda x : len ( x ) ) . to_list ( ) ) . to ( equal ( [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_sort_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . sort ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestChain ( TestCase ) : [EOL] [EOL] def test_chain_if_other_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . chain ( [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_chain_if_other_non_empty ( self ) : [EOL] e = List ( [ [string] , [string] ] ) [EOL] expect ( e . chain ( [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] , [number] , [number] ] ) ) [EOL] [EOL] def test_chain_if_other_is_none ( self ) : [EOL] e = List ( [ [number] , [number] ] ) [EOL] expect ( lambda : e . chain ( None ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_chain_if_other_is_not_iterable ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( lambda : e . chain ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFlatMap ( TestCase ) : [EOL] [EOL] def test_flat_map_if_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . flat_map ( ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_flat_map_if_none_with_sublists ( self ) : [EOL] e = List ( [ [ [number] , [number] ] , [number] , [ [number] , [number] , [number] ] ] ) [EOL] expect ( e . flat_map ( ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_flat_map_if_lambda ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] act = e . flat_map ( lambda i : [ i , - i ] if isinstance ( i , int ) else [ i , None ] ) . to_list ( ) [EOL] expect ( act ) . to ( equal ( [ [number] , - [number] , [number] , - [number] , [number] , - [number] , [number] , - [number] ] ) ) [EOL] [EOL] def test_flat_map_if_lambda_is_given_mixed_list ( self ) : [EOL] e = List ( [ [ [number] ] , [number] , [number] , [number] ] ) [EOL] act = e . flat_map ( lambda i : [ i , - i ] if isinstance ( i , int ) else [ i , None ] ) . to_list ( ) [EOL] expect ( act ) . to ( equal ( [ [ [number] ] , None , [number] , - [number] , [number] , - [number] , [number] , - [number] ] ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestEachWithIndex ( TestCase ) : [EOL] [EOL] def test_each_with_index_if_param_is_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_index ( ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] def test_each_with_index_if_param_is_const ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_index ( start = [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] def test_each_with_index_if_param_is_none_and_func_is_not_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_index ( callback = lambda index , item : [ index , item * index ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] def test_each_with_index_if_param_is_const_and_func_is_not_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_index ( start = [number] , callback = lambda index , item : [ index , item * index ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] def test_each_with_index_if_param_is_const_func_is_different ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . each_with_index ( start = [number] , callback = [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import slender [EOL] import re [EOL] [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFirstWhile ( TestCase ) : [EOL] [EOL] def test_first_while_if_lambda_finds_matching ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] act = e . first_while ( lambda x : len ( x ) < [number] ) . to_list ( ) [EOL] expect ( act ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_first_while_if_lambda_is_not_matching ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] act = e . first_while ( lambda x : len ( x ) < [number] ) . to_list ( ) [EOL] expect ( act ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_first_while_if_lambda_finds_all_matching ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] act = e . first_while ( lambda x : len ( x ) > [number] ) . to_list ( ) [EOL] expect ( act ) . to ( equal ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_first_while_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . first_while ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestMap ( TestCase ) : [EOL] [EOL] def test_map_if_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . map ( ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_map_if_lambda ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . map ( lambda i : i + [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestChunk ( TestCase ) : [EOL] [EOL] def test_chunk ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . chunk ( lambda x : x % [number] == [number] ) . to_list ( ) ) . to ( equal ( [ [ False , [ [number] , [number] ] ] , [ True , [ [number] ] ] , [ False , [ [number] , [number] , [number] ] ] , [ True , [ [number] , [number] ] ] , [ False , [ [number] , [number] , [number] ] ] ] ) ) [EOL] [EOL] def test_chunk_if_param_is_not_lambda ( self ) : [EOL] e = List ( [ [number] , [number] ] ) [EOL] expect ( lambda : e . chunk ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase , skip [EOL] from expects import * [EOL] [EOL] from slender import List [EOL] from slender . command_line import main [EOL] [EOL] class TestInit ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . l = List ( ) [EOL] [EOL] def test_list_is_not_none ( self ) : [EOL] expect ( self . l ) . not_to ( equal ( None ) ) [EOL] [EOL] @ skip ( [string] ) def test_basic ( self ) : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal [EOL] [EOL] from slender import List [EOL] [EOL] class TestSetitem ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_support_indexing_set_raise_error_if_index_out_of_array ( self ) : [EOL] try : [EOL] self . l [ [number] ] = [number] [EOL] except IndexError as e : [EOL] expect ( isinstance ( e , IndexError ) ) . to ( equal ( True ) ) [EOL] [EOL] def test_support_indexing_set ( self ) : [EOL] self . l [ [number] ] = [number] [EOL] expect ( self . l [ [number] ] ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestCount ( TestCase ) : [EOL] [EOL] def test_count_if_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . count ( ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_count_if_item ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . count ( lambda i : i == [number] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_count_if_lambda ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] act = e . count ( lambda i : i % [number] == [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_count_if_param_is_string ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . count ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestInclude ( TestCase ) : [EOL] [EOL] def test_include_if_value_in_array ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . include ( [string] ) ) . to ( be_true ) [EOL] [EOL] def test_include_if_value_not_in_array ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . include ( [string] ) ) . to ( be_false ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestDelete ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_delete_if_obj_is_found_multiple_times ( self ) : [EOL] expect ( self . l . delete ( [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_delete_if_obj_is_not_found ( self ) : [EOL] expect ( self . l . delete ( [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_delete_if_self_is_empty ( self ) : [EOL] l = List ( ) [EOL] expect ( l . delete ( [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestGrep ( TestCase ) : [EOL] [EOL] def test_grep_if_param_regex_string_and_func_is_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep ( [string] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_grep_if_param_regex_object_and_func_is_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep ( re . compile ( [string] ) ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_grep_if_param_regex_object_and_func_is_lambda ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep ( re . compile ( [string] ) , lambda x : x * [number] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_grep_if_param_not_matching ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep ( re . compile ( [string] ) ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_grep_if_param_is_non_regex_object_nor_string ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( lambda : e . grep ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestDeleteIf ( TestCase ) : [EOL] [EOL] def test_delete_if_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . delete_if ( lambda x : x == [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_delete_if_if_lambda_is_valid_greater_than ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . delete_if ( lambda x : x > [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_delete_if_if_lambda_is_valid_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . delete_if ( lambda x : len ( x ) > [number] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_delete_if_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . delete_if ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestMax ( TestCase ) : [EOL] [EOL] def test_max_if_list_of_numbers ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . max ( ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_max_if_list_of_string ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . max ( ) ) . to ( equal ( [string] ) ) [EOL] [EOL] [EOL] def test_max_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . max ( ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_max_if_list_is_empty_with_lambda ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . max ( lambda x : len ( x ) ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_max_if_compare_with_lambda_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . max ( lambda x : len ( x ) ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_max_if_compare_with_lambda_div ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . max ( lambda x : x % [number] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_max_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . max ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFindIndex ( TestCase ) : [EOL] [EOL] def test_find_index_if_param_is_in_range ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_index ( lambda x : x == [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_find_index_if_param_is_out_of_range ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_index ( lambda x : x == [number] ) [EOL] expect ( act ) . to ( equal ( None ) ) [EOL] [EOL] def test_find_index_if_param_is_lambda_with_match ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find_index ( lambda item : item > [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import List , Any [EOL] import typing [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestGroupBy ( TestCase ) : [EOL] [EOL] def test_group_by_if_param_is_lambda ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] act = e . group_by ( lambda x : len ( x ) ) [EOL] expect ( act [ [number] ] . sort ( ) ) . to ( equal ( [ [string] , [string] ] . sort ( ) ) ) [EOL] expect ( act [ [number] ] . sort ( ) ) . to ( equal ( [ [string] , [string] ] . sort ( ) ) ) [EOL] expect ( act [ [number] ] . sort ( ) ) . to ( equal ( [ [string] , [string] ] . sort ( ) ) ) [EOL] expect ( act [ [number] ] . sort ( ) ) . to ( equal ( [ [string] ] . sort ( ) ) ) [EOL] [EOL] def test_group_by_if_param_is_lambda_create_one_key ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] act = e . group_by ( lambda x : [string] in x ) [EOL] expect ( act . get ( True ) . sort ( ) ) . to ( equal ( [ [string] , [string] , [string] , [string] ] . sort ( ) ) ) [EOL] expect ( act . get ( False ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_group_by_if_param_is_non_regex_object_nor_string ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . group_by ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestGrepV ( TestCase ) : [EOL] [EOL] def test_grep_v_if_param_regex_string_and_func_is_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep_v ( [string] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_grep_v_if_param_regex_object_and_func_is_none ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep_v ( re . compile ( [string] ) ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_grep_v_if_param_regex_object_and_func_is_lambda ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep_v ( re . compile ( [string] ) , lambda x : x * [number] ) . to_list ( ) ) . to ( equal ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_grep_v_if_param_not_matching ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . grep_v ( re . compile ( [string] ) ) . to_list ( ) ) . to ( equal ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] [EOL] def test_grep_v_if_param_is_non_regex_object_nor_string ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( lambda : e . grep_v ( [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestDeleteAt ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_delete_at_if_index_in_range ( self ) : [EOL] expect ( self . l . delete_at ( [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_delete_at_if_index_out_of_range ( self ) : [EOL] expect ( lambda : self . l . delete_at ( [number] ) ) . to ( raise_error ( IndexError ) ) [EOL] [EOL] def test_delete_at_if_self_is_empty ( self ) : [EOL] l = List ( ) [EOL] expect ( lambda : l . delete_at ( [number] ) ) . to ( raise_error ( IndexError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestNone ( TestCase ) : [EOL] [EOL] def test_none_if_none_of_them_are_falsy ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . none ( ) ) . to ( be_false ) [EOL] [EOL] def test_none_if_not_all_of_them_are_falsy ( self ) : [EOL] e = List ( [ False , None , [string] , [string] ] ) [EOL] expect ( e . none ( ) ) . to ( be_false ) [EOL] [EOL] def test_none_if_all_of_them_are_falsy ( self ) : [EOL] e = List ( [ None , [string] , None , [number] , False , [ ] , None ] ) [EOL] expect ( e . none ( ) ) . to ( be_true ) [EOL] [EOL] def test_none_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . none ( ) ) . to ( be_true ) [EOL] [EOL] def test_none_if_lambda_is_true_on_all ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . none ( lambda x : len ( x ) > [number] ) ) . to ( be_false ) [EOL] [EOL] def test_none_if_lambda_is_true_on_some ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . none ( lambda x : len ( x ) > [number] ) ) . to ( be_false ) [EOL] [EOL] def test_none_if_lambda_is_false_on_all ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . none ( lambda x : len ( x ) > [number] ) ) . to ( be_true ) [EOL] [EOL] def test_none_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . none ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestLShift ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_lshift_if_other_is_none ( self ) : [EOL] expect ( ( self . l << None ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , None ] ) ) [EOL] [EOL] def test_lshift_if_other_is_not_none ( self ) : [EOL] expect ( ( self . l << [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [ [number] , [number] ] ] ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , contain [EOL] [EOL] from slender import List [EOL] [EOL] class TestShuffle ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_shuffle_if_self_empty ( self ) : [EOL] l = List ( ) [EOL] expect ( l . shuffle ( ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_append_if_self_not_empty ( self ) : [EOL] l = List ( [ [number] , [number] , [number] ] ) [EOL] act = l . shuffle ( ) . to_list ( ) [EOL] expect ( act ) . to ( contain ( [number] ) ) [EOL] expect ( act ) . to ( contain ( [number] ) ) [EOL] expect ( act ) . to ( contain ( [number] ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestDropWhile ( TestCase ) : [EOL] [EOL] def test_drop_while_if_param_is_lambda_and_finds_match ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . drop_while ( lambda x : x < [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_drop_while_if_param_is_lambda_and_no_match ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . drop_while ( lambda x : x < [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_drop_while_if_param_is_different_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . drop_while ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestEachSlice ( TestCase ) : [EOL] [EOL] def test_each_slice_if_param_greater_than_length ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_slice ( [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] [EOL] def test_each_slice_if_param_is_equal_to_length ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_slice ( [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] [EOL] def test_each_slice_if_param_is_less_length ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_slice ( [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] , [number] ] , [ [number] ] ] ) ) [EOL] [EOL] def test_each_slice_if_param_is_less_than_zero_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . each_slice ( - [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_each_slice_if_func_is_valid ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . each_slice ( [number] , lambda i : i * [number] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] ] ] ) ) [EOL] [EOL] def test_each_slice_if_param_is_different_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . each_slice ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_each_slice_if_param_is_int_and_func_is_different_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . each_slice ( [number] , [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFirst ( TestCase ) : [EOL] [EOL] def test_first_if_param_is_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . first ( ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_first_if_param_is_in_range ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . first ( [number] ) [EOL] expect ( act ) . to ( equal ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_first_if_param_is_out_of_range ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . first ( [number] ) [EOL] expect ( act ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_first_if_array_is_empty_and_param_is_none ( self ) : [EOL] e = List ( [ ] ) [EOL] act = e . first ( ) [EOL] expect ( act ) . to ( equal ( None ) ) [EOL] [EOL] def test_first_if_array_is_empty_and_param_is_greater_than_zero ( self ) : [EOL] e = List ( [ ] ) [EOL] act = e . first ( [number] ) [EOL] expect ( act ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_first_if_param_is_non_int ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( lambda : e . first ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestZip ( TestCase ) : [EOL] [EOL] def test_zip_if_other_is_empty ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( e . zip ( [ ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , None ] , [ [number] , None ] , [ [number] , None ] ] ) ) [EOL] [EOL] def test_zip_if_other_len_is_equal ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( e . zip ( [ [number] , [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] def test_zip_if_other_is_longer ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( e . zip ( [ [number] , [number] , [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ None , [number] ] ] ) ) [EOL] [EOL] def test_zip_if_other_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . zip ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestOne ( TestCase ) : [EOL] [EOL] def test_one_if_all_of_them_are_truthy ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . one ( ) ) . to ( be_false ) [EOL] [EOL] def test_one_if_more_than_one_is_truthy ( self ) : [EOL] e = List ( [ False , None , [string] , [string] ] ) [EOL] expect ( e . one ( ) ) . to ( be_false ) [EOL] [EOL] def test_one_if_only_one_is_truthy ( self ) : [EOL] e = List ( [ None , [string] , None , [number] , False , [ [string] ] , None ] ) [EOL] expect ( e . one ( ) ) . to ( be_true ) [EOL] [EOL] def test_one_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . one ( ) ) . to ( be_false ) [EOL] [EOL] def test_one_if_lambda_is_true_on_all ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . one ( lambda x : len ( x ) > [number] ) ) . to ( be_false ) [EOL] [EOL] def test_one_if_lambda_is_true_only_one ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . one ( lambda x : len ( x ) > [number] ) ) . to ( be_true ) [EOL] [EOL] def test_one_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . one ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFindAll ( TestCase ) : [EOL] [EOL] def test_find_all_if_func_is_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . find_all ( ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_find_all_if_func_is_valid ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . find_all ( lambda item : item > [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_find_all_if_func_is_invalid_for_all_items ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . find_all ( lambda item : item > [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_find_all_if_func_is_different ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . find_all ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] import re [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestMin ( TestCase ) : [EOL] [EOL] def test_min_if_list_of_numbers ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . min ( ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_min_if_list_of_string ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . min ( ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_min_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . min ( ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_min_if_list_is_empty_with_lambda ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . min ( lambda x : len ( x ) ) ) . to ( equal ( None ) ) [EOL] [EOL] def test_min_if_compare_with_lambda_len ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( e . min ( lambda x : len ( x ) ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_min_if_compare_with_lambda_div ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . min ( lambda x : x % [number] ) ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_min_if_lambda_is_different ( self ) : [EOL] e = List ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] expect ( lambda : e . min ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestDifference ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_difference_if_other_is_none ( self ) : [EOL] expect ( lambda : self . l . difference ( None ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_difference_if_other_has_intersection ( self ) : [EOL] expect ( self . l . difference ( [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_difference_if_other_is_disjoint ( self ) : [EOL] expect ( self . l . difference ( [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_difference_if_other_is_different ( self ) : [EOL] o = [string] [EOL] expect ( lambda : self . l . difference ( o ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestReverse ( TestCase ) : [EOL] [EOL] def test_reverse_if_list_is_not_empty ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . reverse ( ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_reverse_if_list_is_empty ( self ) : [EOL] e = List ( [ ] ) [EOL] expect ( e . reverse ( ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_reverse_if_list_contains_lists ( self ) : [EOL] e = List ( [ [ [number] , [number] ] , [ [string] , [string] ] , None , [ None , [ [number] , [number] , [string] ] ] ] ) [EOL] expect ( e . reverse ( ) . to_list ( ) ) . to ( equal ( [ [ None , [ [number] , [number] , [string] ] ] , None , [ [string] , [string] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestSelect ( TestCase ) : [EOL] [EOL] def test_select_if_func_is_valid ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . select ( lambda item : item > [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_select_if_func_is_invalid_for_all_items ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( e . select ( lambda item : item > [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_select_if_func_is_different ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . select ( [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal [EOL] [EOL] from slender import List [EOL] [EOL] class TestGetitem ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_support_indexing_get ( self ) : [EOL] expect ( self . l [ [number] ] ) . to ( equal ( [number] ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from unittest import TestCase [EOL] from expects import expect , equal , be_true , be_false [EOL] [EOL] from slender import List [EOL] [EOL] class TestEmpty ( TestCase ) : [EOL] [EOL] def test_empty_if_list_is_empty ( self ) : [EOL] expect ( List ( [ ] ) . empty ( ) ) . to ( be_true ) [EOL] [EOL] def test_empty_if_list_is_not_empty ( self ) : [EOL] expect ( List ( [ [number] , [number] , [number] ] ) . empty ( ) ) . to ( be_false ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestJoin ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_join_if_separator_is_none ( self ) : [EOL] expect ( self . l . join ( None ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_join_if_separator_is_emtpy_str ( self ) : [EOL] expect ( self . l . join ( [string] ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_join_if_separator_is_str ( self ) : [EOL] expect ( self . l . join ( [string] ) ) . to ( equal ( [string] ) ) [EOL] [EOL] def test_join_if_separator_is_different ( self ) : [EOL] o = [number] [EOL] expect ( lambda : self . l . join ( o ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestEachWithObject ( TestCase ) : [EOL] [EOL] def test_each_with_object_if_param_is_array ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_object ( object = [ ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [ ] ] , [ [number] , [ ] ] , [ [number] , [ ] ] ] ) ) [EOL] [EOL] def test_each_with_object_if_param_is_string ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_object ( object = [string] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [string] ] , [ [number] , [string] ] , [ [number] , [string] ] ] ) ) [EOL] [EOL] def test_each_with_object_if_param_is_array_and_func_is_not_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] ] ) [EOL] expect ( e . each_with_object ( object = [ ] , callback = lambda item , obj : ( obj . append ( item ) , obj ) [ - [number] ] ) . to_list ( ) ) . to ( equal ( [ [ [number] , [ [number] ] ] , [ [number] , [ [number] , [number] ] ] , [ [number] , [ [number] , [number] , [number] ] ] ] ) ) [EOL] [EOL] def test_each_with_object_if_func_is_different ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . each_with_object ( object = [ ] , callback = - [number] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestSub ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_sub_if_other_is_none ( self ) : [EOL] expect ( lambda : self . l - None ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_sub_if_other_has_intersection ( self ) : [EOL] expect ( ( self . l - [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] ] ) ) [EOL] [EOL] def test_sub_if_other_is_disjoint ( self ) : [EOL] expect ( ( self . l - [ [number] , [number] ] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_sub_if_other_is_different ( self ) : [EOL] o = [string] [EOL] expect ( lambda : self . l - o ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestMul ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . l = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_mul_if_other_is_none ( self ) : [EOL] expect ( lambda : self . l * None ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] def test_mul_if_scalar_is_positive ( self ) : [EOL] expect ( ( self . l * [number] ) . to_list ( ) ) . to ( equal ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_mul_if_scalar_is_negative ( self ) : [EOL] expect ( ( self . l * - [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_mul_if_scalar_is_zero ( self ) : [EOL] expect ( ( self . l * [number] ) . to_list ( ) ) . to ( equal ( [ ] ) ) [EOL] [EOL] def test_mul_if_other_is_different ( self ) : [EOL] o = [string] [EOL] expect ( lambda : self . l * o ) . to ( raise_error ( TypeError ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import slender [EOL] from unittest import TestCase [EOL] from expects import expect , equal , raise_error [EOL] [EOL] from slender import List [EOL] [EOL] class TestFind ( TestCase ) : [EOL] [EOL] [EOL] def test_find_if_default_none_and_func_not_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find ( lambda x : x % [number] == [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_find_if_default_and_func_not_none ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find ( default = [number] , callback = lambda x : x == [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_find_if_default_applied_func_results_no_match ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] act = e . find ( default = [number] , callback = lambda x : x == [number] ) [EOL] expect ( act ) . to ( equal ( [number] ) ) [EOL] [EOL] def test_find_if_func_is_different_raises_error ( self ) : [EOL] e = List ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] expect ( lambda : e . find ( default = [number] , callback = [string] ) ) . to ( raise_error ( TypeError ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $slender.list.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0