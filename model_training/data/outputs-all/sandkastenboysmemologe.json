import os [EOL] import subprocess [EOL] from subprocess import check_output [EOL] [EOL] timeout = [number] [EOL] [EOL] [EOL] def start_bot ( ) : [EOL] try : [EOL] os . system ( [string] ) [EOL] check_output ( [ [string] , [string] ] , timeout = timeout ) [EOL] except subprocess . TimeoutExpired : [EOL] print ( [string] ) [EOL] except subprocess . CalledProcessError as e : [EOL] raise e [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] start_bot ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import sqlalchemy [EOL] import os [EOL] import logging [EOL] from logging import Formatter , Handler , Logger [EOL] [EOL] from sqlalchemy import create_engine , select [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy . ext . declarative . api import DeclarativeMeta [EOL] from sqlalchemy . orm import sessionmaker [EOL] [EOL] from config import config [EOL] [EOL] logger = logging . Logger ( __name__ ) [EOL] handler = logging . StreamHandler ( ) [EOL] handler . setLevel ( logging . DEBUG ) [EOL] format = logging . Formatter ( [string] ) [EOL] handler . setFormatter ( format ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] [EOL] class DataBase : [EOL] def __init__ ( self ) : [EOL] [EOL] if config [ [string] ] == [string] : [EOL] self . engine = create_engine ( [string] + os . path . join ( [string] , [string] ) ) [EOL] else : [comment] [EOL] self . engine = create_engine ( config [ [string] ] ) [EOL] [EOL] self . Session = sessionmaker ( bind = self . engine ) [EOL] self . Base = declarative_base ( ) [EOL] [EOL] self . session = self . Session ( ) [EOL] self . connection = self . session . connection ( ) [EOL] [EOL] def reload ( self ) : [EOL] [EOL] try : [EOL] self . Session = sessionmaker ( bind = self . engine ) [EOL] self . session = self . Session ( ) [EOL] self . connection = self . session . connection ( ) [EOL] except Exception : [EOL] logger . critical ( [string] , exc_info = True ) [EOL] [EOL] def check_mysql_connection ( self ) : [EOL] if config [ [string] ] == [string] : [EOL] try : [EOL] self . connection . scalar ( select ( [ [number] ] ) ) [EOL] return [EOL] except Exception : [EOL] logger . error ( [string] ) [EOL] self . reload ( ) [EOL] [EOL] [EOL] database_handler = DataBase ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Handler$ 0 0 0 0 0 0 0 $logging.Handler$ 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 $logging.Handler$ 0 0 0 $logging.Formatter$ 0 0 $logging.Logger$ 0 0 0 $logging.Handler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.ext.declarative.api.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DataBase$ 0 0 0 0 0
import handler [EOL] from config import config [EOL] from handler . Discord import DiscordAPI [EOL] from handler . Telegram import init_telegram [EOL] from objects import logger [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] if config [ [string] ] : [EOL] init_telegram ( ) [EOL] [EOL] if config [ [string] ] : [EOL] discord = DiscordAPI ( ) [EOL] discord . run ( config [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $handler.Discord.DiscordAPI$ 0 0 0 0 0 $handler.Discord.DiscordAPI$ 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Tuple , Union [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from typing import Dict , List , Tuple , Union [EOL] [EOL] to_load = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] config = { } [EOL] [EOL] [comment] [EOL] for key in to_load : [EOL] if isinstance ( key , tuple ) : [EOL] if key [ [number] ] in os . environ : [EOL] config [ key [ [number] ] ] = os . environ . get ( key [ [number] ] ) [EOL] else : [EOL] config [ key [ [number] ] ] = key [ [number] ] [EOL] elif key in os . environ : [EOL] config [ key ] = os . environ . get ( key ) [EOL] [EOL] [comment] [EOL] config [ [string] ] = ( f" [string] { config [ [string] ] } [string] { config [ [string] ] } [string] " f"{ config [ [string] ] } [string] { config [ [string] ] } [string] { config [ [string] ] }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Union[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Union[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,None]]$ 0 0 0 0 0 0
from typing import Dict [EOL] import configparser [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from configparser import ConfigParser [EOL] from objects import logger [EOL] from typing import Dict [EOL] [EOL] resolve_platform = { [number] : [string] , [number] : [string] } [EOL] [EOL] [EOL] def show_help ( ) : [EOL] return ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] [EOL] def translate ( language = [string] , path = [string] ) : [EOL] translate = ConfigParser ( ) [EOL] lang_file = [string] . format ( path , language ) [EOL] if os . path . isfile ( lang_file ) : [EOL] translate . read ( lang_file ) [EOL] else : [EOL] logger . debug ( [string] , os . getcwd ( ) ) [EOL] raise FileNotFoundError [EOL] logger . debug ( [string] , translate . sections ( ) ) [EOL] logger . debug ( [string] , { section : dict ( translate [ section ] ) for section in translate . sections ( ) } ) [EOL] return translate [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sys [EOL] [EOL] sys . path . append ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterator [EOL] import typing [EOL] import builtins [EOL] import random [EOL] from typing import Iterator , List [EOL] [EOL] from db_models import Association , Memes , Tags [EOL] from func . essentials import prep4post [EOL] from objects import database_handler [EOL] from config import config [EOL] [EOL] [EOL] def strict_search ( tags , amount ) : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def soft_search ( tags , amount ) : [EOL] query_tags = [ ] [EOL] for x in tags : [EOL] query_tags . append ( x . id ) [EOL] [EOL] mem = database_handler . session . query ( Memes ) . filter ( Association . tag_id . in_ ( query_tags ) , Association . meme_id == Memes . id , ) . all ( ) [EOL] if len ( mem ) == [number] : [EOL] return [string] [EOL] send_memes = [ ] [EOL] random . shuffle ( mem ) [EOL] for count in range ( min ( len ( mem ) , amount , config [ [string] ] ) ) : [EOL] if mem [ count ] . id not in send_memes : [EOL] send_memes . append ( mem [ count ] . id ) [EOL] yield prep4post ( mem [ count ] ) [EOL] [EOL] [EOL] def yield_search ( tags , count = [number] ) : [EOL] tag_list = tags . split ( [string] ) [EOL] [EOL] [comment] [EOL] tags_list = database_handler . session . query ( Tags ) . filter ( Tags . tag . in_ ( tag_list ) ) . all ( ) [EOL] [EOL] for meme in soft_search ( tags_list , count ) : [EOL] yield str ( meme ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import discord [EOL] import typing [EOL] import builtins [EOL] from typing import Union [EOL] [EOL] from discord . ext import commands [EOL] from discord . ext . commands . context import Context [EOL] [EOL] from config import config [EOL] from db_models import Memes [EOL] from func . essentials import ( add_meme , categorise_meme , find_link , history , id_to_meme , list_tags , list_users , rate_meme , yield_random_meme , ) [EOL] from func . search import yield_search [EOL] from func . static import show_help , translate [EOL] from objects import database_handler , logger [EOL] [EOL] [EOL] class DiscordAPI ( commands . bot . Bot ) : [EOL] def __init__ ( self ) : [comment] [EOL] super ( ) . __init__ ( command_prefix = config [ [string] ] ) [EOL] self . remove_command ( [string] ) [EOL] self . lang = translate ( ) [EOL] [EOL] @ self . event async def on_ready ( ) : [EOL] logger . info ( [string] , config [ [string] ] ) [EOL] if config [ [string] ] == [string] : [EOL] await self . read_meme_channel ( ) [EOL] [EOL] @ self . command ( pass_context = True ) async def help ( ctx ) : [EOL] await ctx . send ( show_help ( ) ) [EOL] [EOL] @ self . command ( pass_context = True ) async def search ( ctx , tags , count = [string] ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] logger . info ( [string] , count , tags ) [EOL] for msg in yield_search ( tags , int ( count ) ) : [EOL] await ctx . send ( msg ) [EOL] [EOL] @ search . error async def search_error ( ctx , error ) : [EOL] if isinstance ( error , commands . MissingRequiredArgument ) : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] else : [EOL] logger . error ( error , exc_info = True ) [EOL] raise error [EOL] [EOL] @ self . command ( name = [string] , pass_context = True ) async def _random ( ctx , count = [string] ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] for msg in yield_random_meme ( int ( count ) ) : [EOL] post = await ctx . send ( msg ) [EOL] await post . add_reaction ( chr ( [number] ) ) [EOL] await post . add_reaction ( chr ( [number] ) ) [EOL] [EOL] @ self . command ( pass_context = True ) async def size ( ctx ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] size = database_handler . session . query ( Memes ) . count ( ) [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] . format ( size ) ) [EOL] [EOL] @ self . command ( pass_context = True ) async def post ( ctx , link , tag ) : [EOL] if [string] in link : [EOL] link = link . split ( [string] ) [ [number] ] [EOL] if len ( link ) >= [number] : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] return [EOL] database_handler . check_mysql_connection ( ) [EOL] add_meme ( link , tag , ctx . message . author . name , [number] , ctx . message . created_at ) [EOL] [EOL] @ post . error async def post_error ( ctx , error ) : [EOL] if isinstance ( error , commands . MissingRequiredArgument ) : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] else : [EOL] logger . error ( error , exc_info = True ) [EOL] raise error [EOL] [EOL] @ self . command ( pass_context = True ) async def category ( ctx , id , tags ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] categorise_meme ( id , tags , ctx . author . name , [number] ) [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] [EOL] @ category . error async def category_error ( ctx , error ) : [EOL] if isinstance ( error , commands . MissingRequiredArgument ) : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] else : [EOL] logger . error ( error , exc_info = True ) [EOL] raise error [EOL] [EOL] @ self . command ( pass_context = True ) async def tags ( ctx ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] tags = list_tags ( ) [EOL] if not tags . isspace ( ) : [EOL] await ctx . send ( [string] . format ( tags ) ) [EOL] else : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] [EOL] @ self . command ( pass_context = True ) async def posters ( ctx ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] users = list_users ( ) [EOL] if users : [EOL] await ctx . send ( users ) [EOL] else : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] [EOL] @ self . command ( pass_context = True ) async def info ( ctx , arg ) : [EOL] if arg . isdigit ( ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] await ctx . send ( history ( int ( arg ) ) ) [EOL] else : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] [EOL] @ info . error async def info_error ( ctx , error ) : [EOL] if isinstance ( error , commands . MissingRequiredArgument ) : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] else : [EOL] logger . error ( error , exc_info = True ) [EOL] raise error [EOL] [EOL] @ self . command ( pass_context = True ) async def idtomeme ( ctx , arg ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] x = await ctx . send ( id_to_meme ( int ( arg ) ) ) [EOL] await x . add_reaction ( chr ( [number] ) ) [EOL] await x . add_reaction ( chr ( [number] ) ) [EOL] [EOL] @ idtomeme . error async def idtomeme_error ( ctx , error ) : [EOL] if isinstance ( error , commands . MissingRequiredArgument ) : [EOL] await ctx . send ( self . lang [ [string] ] [ [string] ] ) [EOL] else : [EOL] logger . error ( error , exc_info = True ) [EOL] raise error [EOL] [EOL] @ self . event async def on_reaction_add ( reaction , user ) : [EOL] if user != self . user : [EOL] logger . debug ( [string] , user . name , user ) [EOL] database_handler . check_mysql_connection ( ) [EOL] msg = reaction . message [EOL] meme_id = int ( msg . content . split ( [string] ) [ [number] ] ) [EOL] [EOL] if str ( reaction ) == chr ( [number] ) : [EOL] rate_meme ( meme_id , [number] , user . name , [number] ) [EOL] elif str ( reaction ) == chr ( [number] ) : [EOL] rate_meme ( meme_id , - [number] , user . name , [number] ) [EOL] [EOL] await msg . channel . send ( self . lang [ [string] ] [ [string] ] . format ( user . name ) ) [EOL] [EOL] async def read_meme_channel ( self ) : [EOL] for channel in self . get_all_channels ( ) : [EOL] if channel . name == [string] or channel . name == [string] : [EOL] await self . process ( channel ) [EOL] [EOL] async def process ( self , channel ) : [EOL] logger . debug ( [string] , channel ) [EOL] async for message in channel . history ( limit = [number] ) : [EOL] link = find_link ( message . content ) [EOL] [EOL] if type ( link ) is str : [EOL] if [string] in link : [EOL] link = link . split ( [string] ) [ [number] ] [EOL] if len ( link ) < [number] : [EOL] logger . info ( [string] , link ) [EOL] add_meme ( link , [string] , message . author . name , [number] , message . created_at ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $discord.ext.commands.context.Context$ 0 0 0 0 0 0 0 0 0 0 $discord.ext.commands.context.Context$ 0 0 0 0 0 0 0 0 0 0 $discord.ext.commands.context.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , List , Union , Tuple [EOL] import typing [EOL] import builtins [EOL] import telegram [EOL] from typing import Callable , List , Tuple , Union [EOL] [EOL] from telegram import InlineKeyboardButton , InlineKeyboardMarkup [EOL] from telegram . bot import Bot [EOL] from telegram . callbackquery import CallbackQuery [EOL] from telegram . ext import CallbackQueryHandler , CommandHandler , Updater [EOL] from telegram . ext . dispatcher import run_async [EOL] from telegram . message import Message [EOL] from telegram . update import Update [EOL] [EOL] from config import config [EOL] from db_models import Memes [EOL] from func . essentials import ( add_meme , categorise_meme , history , id_to_meme , list_tags , list_users , rate_meme , yield_random_meme , ) [EOL] from func . search import yield_search [EOL] from func . static import show_help [EOL] from objects import database_handler , logger [EOL] [EOL] keyboard = [ [ InlineKeyboardButton ( [string] , callback_data = [string] ) ] , [ InlineKeyboardButton ( [string] , callback_data = [string] ) ] , ] [EOL] keyboard_markup = InlineKeyboardMarkup ( keyboard ) [EOL] [EOL] [EOL] def parse_count ( args , position , default = [number] ) : [EOL] count = ... [EOL] if len ( args ) < position + [number] : [EOL] count = default [EOL] elif len ( args ) >= position and args [ position ] . isdigit ( ) : [EOL] count = abs ( int ( args [ [number] ] ) ) [EOL] else : [EOL] return ( [number] , str ( position ) + [string] ) [EOL] return ( count , [string] ) [EOL] [EOL] [EOL] @ run_async def post_meme ( bot , update , args ) : [EOL] message = update . message [EOL] [EOL] if len ( args ) == [number] : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] [EOL] link = args [ [number] ] [EOL] post_tags = [string] [EOL] [EOL] if not len ( args ) == [number] : [EOL] post_tags = args [ [number] ] [EOL] [EOL] database_handler . check_mysql_connection ( ) [EOL] message . reply_text ( add_meme ( link , post_tags , message . from_user . username , [number] , message . date ) ) [EOL] [EOL] [EOL] @ run_async def random ( bot , update , args ) : [EOL] message = update . message [EOL] [EOL] number = parse_count ( args , [number] ) [EOL] if number [ [number] ] : [EOL] message . reply_text ( number [ [number] ] ) [EOL] return [EOL] [EOL] count = number [ [number] ] [EOL] database_handler . check_mysql_connection ( ) [EOL] for msg in yield_random_meme ( count ) : [EOL] message . reply_text ( msg , reply_markup = keyboard_markup ) [EOL] [EOL] [EOL] @ run_async def userhelp ( bot , update , args ) : [EOL] update . message . reply_text ( show_help ( ) , parse_mode = [string] ) [EOL] [EOL] [EOL] @ run_async def _size ( bot , update , args ) : [EOL] database_handler . check_mysql_connection ( ) [EOL] size = database_handler . session . query ( Memes ) . count ( ) [EOL] update . message . reply_text ( [string] . format ( size ) , parse_mode = [string] ) [EOL] [EOL] [EOL] @ run_async def search ( bot , update , args ) : [EOL] message = update . message [EOL] count = ... [EOL] if len ( args ) < [number] : [EOL] count = [number] [EOL] elif args [ [number] ] . isdigit ( ) : [EOL] if int ( args [ [number] ] ) < [number] : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] else : [EOL] count = int ( args [ [number] ] ) [EOL] else : [EOL] count = [number] [EOL] tags = args [ [number] ] [EOL] database_handler . check_mysql_connection ( ) [EOL] logger . info ( [string] . format ( count , tags ) ) [EOL] for msg in yield_search ( tags , count ) : [EOL] message . reply_text ( msg , reply_markup = keyboard_markup ) [EOL] [EOL] [EOL] @ run_async def _tags ( bot , update , args ) : [EOL] message = update . message [EOL] database_handler . check_mysql_connection ( ) [EOL] tags = list_tags ( ) [EOL] if tags . isspace ( ) : [EOL] message . reply_text ( [string] ) [EOL] else : [EOL] message . reply_text ( [string] . format ( tags ) , parse_mode = [string] ) [EOL] [EOL] [EOL] @ run_async def posters ( bot , update , args ) : [EOL] message = update . message [EOL] database_handler . check_mysql_connection ( ) [EOL] users = list_users ( ) [EOL] if users : [EOL] message . reply_text ( users , parse_mode = [string] ) [EOL] else : [EOL] message . reply_text ( [string] ) [EOL] [EOL] [EOL] @ run_async def idtomeme ( bot , update , args ) : [EOL] message = update . message [EOL] [EOL] if len ( args ) == [number] : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] elif not args [ [number] ] . isdigit ( ) : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] database_handler . check_mysql_connection ( ) [EOL] count = int ( args [ [number] ] ) [EOL] message . reply_text ( id_to_meme ( count ) , reply_markup = keyboard_markup ) [EOL] [EOL] [EOL] @ run_async def category ( bot , update , args ) : [EOL] message = update . message [EOL] if len ( args ) < [number] : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] if args [ [number] ] . isdigit ( ) : [EOL] if int ( args [ [number] ] ) < [number] : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] meme_id = int ( args [ [number] ] ) [EOL] tags = args [ [number] ] [EOL] except TypeError : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] else : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] [EOL] database_handler . check_mysql_connection ( ) [EOL] categorise_meme ( meme_id , tags , str ( message . from_user . username ) , [number] ) [EOL] message . reply_text ( [string] ) [EOL] [EOL] [EOL] @ run_async def _info ( bot , update , args ) : [EOL] message = update . message [EOL] if len ( args ) == [number] : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] if args [ [number] ] . isdigit ( ) : [EOL] meme_id = int ( args [ [number] ] ) [EOL] else : [EOL] message . reply_text ( [string] ) [EOL] return [EOL] database_handler . check_mysql_connection ( ) [EOL] text = history ( meme_id ) [EOL] message . reply_text ( text , parse_mode = [string] ) [EOL] [EOL] [EOL] def vote ( message , rating , username ) : [EOL] meme_id = int ( message . split ( [string] ) [ [number] ] ) [EOL] database_handler . check_mysql_connection ( ) [EOL] rate_meme ( meme_id , rating , username , [number] ) [EOL] [EOL] [EOL] @ run_async def upvote ( bot , update ) : [EOL] query = update . callback_query [EOL] database_handler . check_mysql_connection ( ) [EOL] vote ( query . message . text , [number] , query . from_user . username ) [EOL] [EOL] [EOL] @ run_async def downvote ( bot , update ) : [EOL] query = update . callback_query [EOL] database_handler . check_mysql_connection ( ) [EOL] vote ( query . message . text , - [number] , query . from_user . username ) [EOL] [EOL] [EOL] def error_handler ( bot , updater , error ) : [EOL] logger . error ( [string] , exc_info = True ) [EOL] [EOL] [EOL] def init_telegram ( ) : [EOL] [EOL] updater = Updater ( config [ [string] ] ) [EOL] [EOL] commands = [ [ [string] , post_meme ] , [ [string] , random ] , [ [string] , userhelp ] , [ [string] , _size ] , [ [string] , search ] , [ [string] , _tags ] , [ [string] , posters ] , [ [string] , idtomeme ] , [ [string] , category ] , [ [string] , _info ] , ] [EOL] [EOL] for command , function in commands : [EOL] updater . dispatcher . add_handler ( CommandHandler ( command , function , pass_args = True ) ) [EOL] [EOL] updater . dispatcher . add_handler ( CallbackQueryHandler ( upvote , pattern = [string] ) ) [EOL] updater . dispatcher . add_handler ( CallbackQueryHandler ( downvote , pattern = [string] ) ) [EOL] updater . dispatcher . add_error_handler ( error_handler ) [EOL] updater . start_polling ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sys [EOL] [EOL] sys . path . append ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0