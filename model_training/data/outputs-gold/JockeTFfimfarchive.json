[comment] [EOL] from typing import List , Iterable , Tuple [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import os [EOL] from typing import Iterable , List , Tuple [EOL] [EOL] from setuptools import setup [EOL] [EOL] from fimfarchive import __author__ , __license__ , __version__ [EOL] [EOL] [EOL] PACKAGE = [string] [EOL] GITHUB = [string] [EOL] [EOL] [EOL] def to_name ( path ) : [EOL] [docstring] [EOL] return path . replace ( os . path . sep , [string] ) [EOL] [EOL] [EOL] def iter_package_paths ( ) : [EOL] [docstring] [EOL] for dirpath , dirnames , filenames in os . walk ( PACKAGE ) : [EOL] if [string] in filenames : [EOL] yield dirpath [EOL] [EOL] [EOL] def iter_package_names ( ) : [EOL] [docstring] [EOL] for dirpath in iter_package_paths ( ) : [EOL] yield to_name ( dirpath ) [EOL] [EOL] [EOL] def iter_package_data ( ) : [EOL] [docstring] [EOL] for dirpath in iter_package_paths ( ) : [EOL] filenames = [ filename for filename in os . listdir ( dirpath ) if os . path . isfile ( os . path . join ( dirpath , filename ) ) [EOL] and not filename . endswith ( [string] ) ] [EOL] [EOL] if filenames : [EOL] yield to_name ( dirpath ) , filenames [EOL] [EOL] [EOL] setup ( name = [string] , version = __version__ , license = __license__ , author = __author__ , author_email = [string] , url = [string] , download_url = f'{ GITHUB } [string] { __version__ } [string] ' , packages = list ( iter_package_names ( ) ) , package_data = dict ( iter_package_data ( ) ) , install_requires = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from enum import Enum [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class Flavor ( Enum ) : [EOL] [docstring] [EOL] [EOL] def __new__ ( cls , * args ) : [EOL] [docstring] [EOL] value = len ( cls . __members__ ) + [number] [EOL] obj = object . __new__ ( cls ) [EOL] obj . _value_ = value [EOL] return obj [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return [string] . format ( type ( self ) . __name__ , getattr ( self , [string] , None ) , ) [EOL] [EOL] [EOL] class StorySource ( Flavor ) : [EOL] [docstring] [EOL] FIMFICTION = ( ) [EOL] FIMFARCHIVE = ( ) [EOL] [EOL] [EOL] class DataFormat ( Flavor ) : [EOL] [docstring] [EOL] EPUB = ( ) [EOL] FPUB = ( ) [EOL] HTML = ( ) [EOL] JSON = ( ) [EOL] [EOL] [EOL] class MetaFormat ( Flavor ) : [EOL] [docstring] [EOL] ALPHA = ( ) [EOL] BETA = ( ) [EOL] [EOL] [EOL] class MetaPurity ( Flavor ) : [EOL] [docstring] [EOL] CLEAN = ( ) [EOL] DIRTY = ( ) [EOL] [EOL] [EOL] class UpdateStatus ( Flavor ) : [EOL] [docstring] [EOL] CREATED = ( ) [EOL] REVIVED = ( ) [EOL] UPDATED = ( ) [EOL] DELETED = ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , TypeVar , Callable , Tuple , Any , Set , Iterator , Union , Optional [EOL] import builtins [EOL] import fimfarchive [EOL] import typing [EOL] import functools [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] import os [EOL] import shutil [EOL] from functools import partial [EOL] from importlib import import_module [EOL] from importlib_resources import read_binary , read_text [EOL] from pathlib import Path [EOL] from typing import ( cast , Any , Callable , Dict , Iterator , Optional , Set , Tuple , Type , TypeVar , Union , ) [EOL] [EOL] from tqdm import tqdm [EOL] [EOL] from fimfarchive . flavors import Flavor [EOL] from fimfarchive . stories import Story [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] F = TypeVar ( [string] , bound = Flavor ) [EOL] ByteFunc = Callable [ [ bytes ] , bytes ] [EOL] [EOL] [EOL] tqdm = partial ( tqdm , ascii = True , leave = False , smoothing = [number] , ncols = [number] , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] AUTHOR_BLACKLIST = { [number] , } [EOL] [EOL] STORY_BLACKLIST = set ( ) [EOL] STORY_WHITELIST = set ( ) [EOL] [EOL] [EOL] class EmptyMeta ( type ) : [EOL] [docstring] [EOL] [EOL] def __bool__ ( cls ) : [EOL] return False [EOL] [EOL] [EOL] class Empty ( metaclass = EmptyMeta ) : [EOL] [docstring] [EOL] [EOL] def __bool__ ( self ) : [EOL] return False [EOL] [EOL] [EOL] class PersistedDict ( Dict [ str , Any ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , default = dict ( ) ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . path = path [EOL] self . temp = path + [string] [EOL] self . default = default [EOL] self . load ( ) [EOL] [EOL] def load ( self ) : [EOL] [docstring] [EOL] self . clear ( ) [EOL] self . update ( self . default ) [EOL] [EOL] if os . path . exists ( self . path ) : [EOL] with open ( self . path , [string] ) as fobj : [EOL] self . update ( json . load ( fobj ) ) [EOL] [EOL] def save ( self ) : [EOL] [docstring] [EOL] content = json . dumps ( self , indent = [number] , ensure_ascii = False , sort_keys = True , ) [EOL] [EOL] if os . path . exists ( self . path ) : [EOL] shutil . copy ( self . path , self . temp ) [EOL] [EOL] with open ( self . path , [string] ) as fobj : [EOL] fobj . write ( content ) [EOL] [EOL] if os . path . exists ( self . temp ) : [EOL] os . remove ( self . temp ) [EOL] [EOL] [EOL] class JayWalker : [EOL] [docstring] [EOL] [EOL] def walk ( self , data ) : [EOL] [docstring] [EOL] iterator = ... [EOL] [EOL] if isinstance ( data , dict ) : [EOL] iterator = iter ( data . items ( ) ) [EOL] elif isinstance ( data , list ) : [EOL] iterator = enumerate ( data ) [EOL] else : [EOL] return [EOL] [EOL] for key , value in iterator : [EOL] self . handle ( data , key , value ) [EOL] [EOL] def handle ( self , data , key , value ) : [EOL] [docstring] [EOL] self . walk ( value ) [EOL] [EOL] [EOL] def find_compressor ( ) : [EOL] [docstring] [EOL] for compressor in ( [string] , [string] , [string] ) : [EOL] try : [EOL] module = import_module ( compressor ) [EOL] return module . compress , module . decompress [EOL] except ImportError : [EOL] pass [EOL] [EOL] dummy = cast ( ByteFunc , lambda data : data ) [EOL] [EOL] return dummy , dummy [EOL] [EOL] [EOL] def find_flavor ( story , flavor ) : [EOL] [docstring] [EOL] for current in story . flavors : [EOL] if isinstance ( current , flavor ) : [EOL] return current [EOL] [EOL] return None [EOL] [EOL] [EOL] def get_path ( source ) : [EOL] [docstring] [EOL] if source is None : [EOL] return None [EOL] [EOL] return Path ( source ) . resolve ( ) [EOL] [EOL] [EOL] def is_blacklisted ( story ) : [EOL] [docstring] [EOL] story_id = int ( story . meta [ [string] ] ) [EOL] author_id = int ( story . meta [ [string] ] [ [string] ] ) [EOL] [EOL] if story_id in STORY_WHITELIST : [EOL] return False [EOL] elif story_id in STORY_BLACKLIST : [EOL] return True [EOL] elif author_id in AUTHOR_BLACKLIST : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class ResourceLoader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , package , binary = False ) : [EOL] [docstring] [EOL] self . package = package [EOL] self . binary = binary [EOL] [EOL] def __call__ ( self , name , binary = None ) : [EOL] [docstring] [EOL] if binary is None : [EOL] binary = self . binary [EOL] [EOL] if binary : [EOL] return read_binary ( self . package , name ) [EOL] else : [EOL] return read_text ( self . package , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[ByteFunc,ByteFunc]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[F]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import sys [EOL] [EOL] from fimfarchive . commands import RootCommand [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cmd = RootCommand ( ) [EOL] code = cmd ( * sys . argv [ [number] : ] ) [EOL] exit ( code = code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.commands.root.RootCommand$ 0 0 0 0 0 $builtins.int$ 0 $fimfarchive.commands.root.RootCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class FimfarchiveError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidStoryError ( FimfarchiveError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class StorySourceError ( FimfarchiveError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Set , Dict [EOL] import typing [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import blinker [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class Signal ( blinker . Signal ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * spec ) : [EOL] [docstring] [EOL] if [string] in spec : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . spec = ( [string] , * spec ) [EOL] super ( ) . __init__ ( doc = repr ( self ) ) [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] raise ValueError ( [string] . format ( type ( SignalSender ) . __name__ ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( [string] . join ( self . spec ) ) [EOL] [EOL] def send ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if len ( self . spec ) < len ( args ) : [EOL] raise ValueError ( [string] . format ( len ( self . spec ) , len ( args ) ) ) [EOL] [EOL] data = { self . spec [ i ] : v for i , v in enumerate ( args ) } [EOL] duplicates = set ( data . keys ( ) ) . intersection ( kwargs . keys ( ) ) [EOL] [EOL] if duplicates : [EOL] raise ValueError ( [string] . format ( [string] . join ( duplicates ) ) ) [EOL] [EOL] data . update ( kwargs ) [EOL] sender = data . pop ( [string] , None ) [EOL] [EOL] return super ( ) . send ( sender , ** data ) [EOL] [EOL] [EOL] class SignalBinder : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , signal , sender ) : [EOL] [docstring] [EOL] self . signal = signal [EOL] self . sender = sender [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . send ( self . sender , * args , ** kwargs ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . signal , attr ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . signal , self . sender ) [EOL] [EOL] [EOL] class SignalSender : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] for key , source in find_sources ( self ) : [EOL] if not isinstance ( source , SignalBinder ) : [EOL] binding = SignalBinder ( source , self ) [EOL] setattr ( self , key , binding ) [EOL] [EOL] [EOL] class SignalReceiver : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sender ) : [EOL] [docstring] [EOL] self . sender = sender [EOL] [EOL] def __enter__ ( self ) : [EOL] for key , source , target in find_matches ( self . sender , self ) : [EOL] source . connect ( target , sender = self . sender ) [EOL] [EOL] return self [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] for key , source , target in find_matches ( self . sender , self ) : [EOL] source . disconnect ( target , sender = self . sender ) [EOL] [EOL] [EOL] def find_related ( obj ) : [EOL] [docstring] [EOL] for key in dir ( obj ) : [EOL] if key . startswith ( [string] ) : [EOL] yield key , getattr ( obj , key ) [EOL] [EOL] [EOL] def find_sources ( sender ) : [EOL] [docstring] [EOL] for key , value in find_related ( sender ) : [EOL] connect = getattr ( value , [string] , None ) [EOL] disconnect = getattr ( value , [string] , None ) [EOL] [EOL] if callable ( connect ) and callable ( disconnect ) : [EOL] yield key , value [EOL] [EOL] [EOL] def find_targets ( receiver ) : [EOL] [docstring] [EOL] for key , value in find_related ( receiver ) : [EOL] if callable ( value ) : [EOL] yield key , value [EOL] [EOL] [EOL] def find_matches ( sender , receiver ) : [EOL] [docstring] [EOL] sources = dict ( find_sources ( sender ) ) [EOL] targets = dict ( find_targets ( receiver ) ) [EOL] [EOL] for key in sources . keys ( ) & targets . keys ( ) : [EOL] yield key , sources [ key ] , targets [ key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.signals.SignalBinder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.signals.SignalBinder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError [EOL] from fimfarchive . flavors import UpdateStatus [EOL] from fimfarchive . mappers import StoryDateMapper [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class Selector : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , old , new ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class UpdateSelector ( Selector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , date_mapper = None ) : [EOL] [docstring] [EOL] if date_mapper : [EOL] self . date_mapper = date_mapper [EOL] else : [EOL] self . date_mapper = StoryDateMapper ( ) [EOL] [EOL] def filter_empty ( self , story ) : [EOL] [docstring] [EOL] meta = getattr ( story , [string] , None ) [EOL] [EOL] if meta and meta . get ( [string] ) : [EOL] return story [EOL] else : [EOL] return None [EOL] [EOL] def filter_invalid ( self , story ) : [EOL] [docstring] [EOL] try : [EOL] story . meta [EOL] story . data [EOL] except InvalidStoryError : [EOL] return None [EOL] else : [EOL] return story [EOL] [EOL] def filter_unchanged ( self , old , new ) : [EOL] [docstring] [EOL] old_date = self . date_mapper ( old ) [EOL] new_date = self . date_mapper ( new ) [EOL] [EOL] if old_date is None : [EOL] raise ValueError ( [string] ) [EOL] elif new_date is None : [EOL] raise ValueError ( [string] ) [EOL] elif old_date < new_date : [EOL] return new [EOL] else : [EOL] return None [EOL] [EOL] def flavored ( self , story , * flavors ) : [EOL] [docstring] [EOL] story . flavors . update ( flavors ) [EOL] [EOL] return story [EOL] [EOL] def __call__ ( self , old , new ) : [EOL] old = self . filter_empty ( old ) [EOL] new = self . filter_empty ( new ) [EOL] deleted = old and not new [EOL] [EOL] if old : [EOL] old = self . filter_invalid ( old ) [EOL] [EOL] if old and new : [EOL] new = self . filter_unchanged ( old , new ) [EOL] [EOL] if new : [EOL] new = self . filter_invalid ( new ) [EOL] deleted = old and not new [EOL] [EOL] if not old and new : [EOL] return self . flavored ( new , UpdateStatus . CREATED ) [EOL] elif old and not new and not deleted : [EOL] return self . flavored ( old , UpdateStatus . REVIVED ) [EOL] elif old and new : [EOL] return self . flavored ( new , UpdateStatus . UPDATED ) [EOL] elif old and not new and deleted : [EOL] return self . flavored ( old , UpdateStatus . DELETED ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class RefetchSelector ( UpdateSelector ) : [EOL] [docstring] [EOL] [EOL] def filter_unchanged ( self , old , new ) : [EOL] [docstring] [EOL] return new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Any , Tuple , Set , Optional [EOL] import typing [EOL] import fimfarchive [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Callable , Dict , Optional , Set [EOL] [EOL] import arrow [EOL] [EOL] from fimfarchive . flavors import Flavor , UpdateStatus [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import find_flavor [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , ) [EOL] [EOL] [EOL] class Stamper : [EOL] [docstring] [EOL] [EOL] def get_archive ( self , story ) : [EOL] [docstring] [EOL] meta = story . meta [EOL] [EOL] if [string] not in meta : [EOL] meta [ [string] ] = dict ( ) [EOL] [EOL] return meta [ [string] ] [EOL] [EOL] def __call__ ( self , story ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class UpdateStamper ( Stamper ) : [EOL] [docstring] [EOL] spec = { [string] : { UpdateStatus . CREATED , } , [string] : { UpdateStatus . CREATED , UpdateStatus . REVIVED , UpdateStatus . UPDATED , } , [string] : { UpdateStatus . CREATED , UpdateStatus . UPDATED , } , } [EOL] [EOL] def __call__ ( self , story ) : [EOL] [docstring] [EOL] timestamp = arrow . utcnow ( ) . isoformat ( ) [EOL] flavor = find_flavor ( story , UpdateStatus ) [EOL] archive = self . get_archive ( story ) [EOL] [EOL] archive [ [string] ] = timestamp [EOL] [EOL] for key , value in self . spec . items ( ) : [EOL] if flavor in value : [EOL] archive [ key ] = timestamp [EOL] elif key not in archive : [EOL] archive [ key ] = None [EOL] [EOL] [EOL] class FlavorStamper ( Stamper ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mapper ) : [EOL] [docstring] [EOL] self . map = mapper [EOL] [EOL] def __call__ ( self , story ) : [EOL] flavor = self . map ( story ) [EOL] [EOL] if flavor : [EOL] story . flavors . add ( flavor ) [EOL] [EOL] [EOL] class PathStamper ( Stamper ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mapper ) : [EOL] [docstring] [EOL] self . map = mapper [EOL] [EOL] def __call__ ( self , story ) : [EOL] archive = self . get_archive ( story ) [EOL] path = self . map ( story ) [EOL] [EOL] if [string] in archive : [EOL] del archive [ [string] ] [EOL] [EOL] if [string] in story . meta : [EOL] del story . meta [ [string] ] [EOL] [EOL] if path : [EOL] archive [ [string] ] = path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $fimfarchive.stories.Story$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[fimfarchive.flavors.UpdateStatus]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.flavors.UpdateStatus]$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.flavors.UpdateStatus]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[[fimfarchive.stories.Story],typing.Optional[fimfarchive.flavors.Flavor]]$ 0 0 0 0 0 0 0 $typing.Callable[[fimfarchive.stories.Story],typing.Optional[fimfarchive.flavors.Flavor]]$ 0 $typing.Callable[[fimfarchive.stories.Story],typing.Optional[fimfarchive.flavors.Flavor]]$ 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Optional[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $typing.Optional[fimfarchive.flavors.Flavor]$ 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Optional[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[[fimfarchive.stories.Story],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Callable[[fimfarchive.stories.Story],typing.Optional[builtins.str]]$ 0 $typing.Callable[[fimfarchive.stories.Story],typing.Optional[builtins.str]]$ 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] __author__ = [string] [EOL] __copyright__ = [string] [EOL] __license__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Iterable , Tuple , Dict [EOL] import typing [EOL] import builtins [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import TYPE_CHECKING , Any , Dict , Iterable , TypeVar [EOL] [EOL] from fimfarchive . exceptions import StorySourceError [EOL] [EOL] [EOL] if TYPE_CHECKING : [EOL] from fimfarchive . fetchers import Fetcher [EOL] from fimfarchive . flavors import Flavor [EOL] else : [EOL] Fetcher = TypeVar ( [string] ) [EOL] Flavor = TypeVar ( [string] ) [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class Story : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , key , fetcher = None , meta = None , data = None , flavors = ( ) , ) : [EOL] [docstring] [EOL] if fetcher is None and ( data is None or meta is None ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . key = key [EOL] self . fetcher = fetcher [EOL] self . flavors = set ( flavors ) [EOL] self . _meta = meta [EOL] self . _data = data [EOL] [EOL] @ property def is_fetched ( self ) : [EOL] [docstring] [EOL] return self . has_meta and self . has_data [EOL] [EOL] @ property def has_meta ( self ) : [EOL] [docstring] [EOL] return self . _meta is not None [EOL] [EOL] @ property def meta ( self ) : [EOL] [docstring] [EOL] if self . _meta is None and self . fetcher : [EOL] self . _meta = self . fetcher . fetch_meta ( self . key ) [EOL] [EOL] if self . _meta is None : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] return self . _meta [EOL] [EOL] @ property def has_data ( self ) : [EOL] [docstring] [EOL] return self . _data is not None [EOL] [EOL] @ property def data ( self ) : [EOL] [docstring] [EOL] if self . _data is None and self . fetcher : [EOL] self . _data = self . fetcher . fetch_data ( self . key ) [EOL] [EOL] if self . _data is None : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] return self . _data [EOL] [EOL] def merge ( self , ** params ) : [EOL] [docstring] [EOL] kwargs = { k . lstrip ( [string] ) : v for k , v in vars ( self ) . items ( ) } [EOL] kwargs . update ( params ) [EOL] [EOL] return type ( self ) ( ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $fimfarchive.fetchers.base.Fetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.base.Fetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $fimfarchive.fetchers.base.Fetcher$ 0 $fimfarchive.fetchers.base.Fetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $'Story'$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0
from typing import Iterable , Type , Callable , Any , Tuple , Union [EOL] import fimfarchive [EOL] import builtins [EOL] import typing [EOL] import zipfile [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from copy import deepcopy [EOL] from pathlib import Path [EOL] from typing import Callable , Iterable , Tuple , Union [EOL] from zipfile import ZipFile , ZIP_DEFLATED , ZIP_STORED [EOL] [EOL] from fimfarchive . mappers import ( DataFormatMapper , StaticMapper , StoryPathMapper , StorySlugMapper , ) [EOL] from fimfarchive . stampers import FlavorStamper , PathStamper [EOL] from fimfarchive . stories import Story [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , ) [EOL] [EOL] [EOL] PathFunc = Callable [ [ Story ] , Union [ None , Path , str ] ] [EOL] PathSpec = Union [ None , Path , PathFunc , str ] [EOL] [EOL] [EOL] class Writer ( ) : [EOL] [docstring] [EOL] [EOL] def write ( self , story ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback ) : [EOL] self . close ( ) [EOL] [EOL] [EOL] class DirectoryWriter ( Writer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , meta_path = None , data_path = None , overwrite = False , make_dirs = True , ) : [EOL] [docstring] [EOL] self . meta_path = self . get_mapper ( meta_path ) [EOL] self . data_path = self . get_mapper ( data_path ) [EOL] self . overwrite = overwrite [EOL] self . make_dirs = make_dirs [EOL] [EOL] def get_mapper ( self , obj ) : [EOL] [docstring] [EOL] if callable ( obj ) : [EOL] return obj [EOL] elif isinstance ( obj , ( Path , str ) ) : [EOL] return StoryPathMapper ( obj ) [EOL] elif obj is None : [EOL] return StaticMapper ( obj ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] def check_overwrite ( self , path ) : [EOL] [docstring] [EOL] if not self . overwrite and path . exists ( ) : [EOL] raise FileExistsError ( [string] . format ( path ) ) [EOL] [EOL] def check_directory ( self , path ) : [EOL] [docstring] [EOL] parent = path . parent [EOL] [EOL] if parent . is_dir ( ) : [EOL] return [EOL] elif self . make_dirs : [EOL] parent . mkdir ( parents = True ) [EOL] else : [EOL] raise FileNotFoundError ( parent ) [EOL] [EOL] def perform_write ( self , contents , path ) : [EOL] [docstring] [EOL] self . check_overwrite ( path ) [EOL] self . check_directory ( path ) [EOL] [EOL] path . write_bytes ( contents ) [EOL] [EOL] def write_meta ( self , story , path ) : [EOL] [docstring] [EOL] text = json . dumps ( story . meta , indent = [number] , sort_keys = True , ensure_ascii = False , ) [EOL] [EOL] contents = text . encode ( [string] ) [EOL] self . perform_write ( contents , path ) [EOL] [EOL] def write_data ( self , story , path ) : [EOL] [docstring] [EOL] contents = story . data [EOL] self . perform_write ( contents , path ) [EOL] [EOL] def write ( self , story ) : [EOL] meta_target = self . meta_path ( story ) [EOL] data_target = self . data_path ( story ) [EOL] [EOL] if meta_target is not None : [EOL] meta_path = Path ( meta_target ) . resolve ( ) [EOL] self . write_meta ( story , meta_path ) [EOL] [EOL] if data_target is not None : [EOL] data_path = Path ( data_target ) . resolve ( ) [EOL] self . write_data ( story , data_path ) [EOL] [EOL] [EOL] class FimfarchiveWriter ( Writer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , extras = ( ) , ) : [EOL] [docstring] [EOL] archive_path = Path ( path ) . resolve ( False ) [EOL] index_path = archive_path . with_suffix ( [string] ) [EOL] [EOL] if archive_path . suffix != [string] : [EOL] raise ValueError ( f" [string] { archive_path } [string] " ) [EOL] [EOL] if archive_path . exists ( ) : [EOL] raise ValueError ( f" [string] { archive_path } [string] " ) [EOL] [EOL] if index_path . exists ( ) : [EOL] raise ValueError ( f" [string] { index_path } [string] " ) [EOL] [EOL] self . index_path = index_path [EOL] self . archive_path = archive_path [EOL] self . extras = extras [EOL] [EOL] self . stamp_format = FlavorStamper ( DataFormatMapper ( ) ) [EOL] self . stamp_path = PathStamper ( StorySlugMapper ( ) ) [EOL] [EOL] index_path . parent . mkdir ( parents = True , exist_ok = True ) [EOL] archive_path . parent . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] self . index = index_path . open ( [string] , encoding = [string] ) [EOL] self . archive = ZipFile ( archive_path , [string] , ZIP_STORED ) [EOL] [EOL] self . index . write ( [string] ) [EOL] self . open = True [EOL] [EOL] def write ( self , story ) : [EOL] if not self . open : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if story . key != story . meta [ [string] ] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] story = story . merge ( meta = deepcopy ( story . meta ) ) [EOL] [EOL] self . stamp_format ( story ) [EOL] self . stamp_path ( story ) [EOL] [EOL] path = story . meta [ [string] ] [ [string] ] [EOL] meta = json . dumps ( story . meta , ensure_ascii = False , sort_keys = True ) [EOL] line = f' [string] { story . key } [string] { meta } [string] ' [EOL] [EOL] self . index . write ( line ) [EOL] self . archive . writestr ( path , story . data , ZIP_STORED ) [EOL] [EOL] def close ( self ) : [EOL] if not self . open : [EOL] return [EOL] [EOL] self . open = False [EOL] [EOL] if [number] < self . index . tell ( ) : [EOL] self . index . seek ( self . index . tell ( ) - [number] ) [EOL] [EOL] self . index . write ( [string] ) [EOL] self . index . close ( ) [EOL] [EOL] for name , data in self . extras : [EOL] self . archive . writestr ( name , data , ZIP_DEFLATED ) [EOL] [EOL] self . archive . write ( self . index_path , [string] , ZIP_DEFLATED ) [EOL] self . archive . close ( ) [EOL] [EOL] del self . index [EOL] del self . archive [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $PathFunc$ 0 0 0 $PathSpec$ 0 0 0 0 0 0 0 0 $PathSpec$ 0 0 0 0 $PathSpec$ 0 0 0 0 $PathSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 $PathSpec$ 0 0 0 $PathSpec$ 0 0 0 0 0 0 0 $PathSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $builtins.bytes$ 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 $pathlib.Path$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $pathlib.Path$ 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 $pathlib.Path$ 0 0 0 0 0 $builtins.bytes$ 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $pathlib.Path$ 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 $fimfarchive.stories.Story$ 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 $fimfarchive.stories.Story$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[pathlib.Path,builtins.str]$ 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pathlib.Path,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.bytes]]$ 0 $typing.Iterable[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 0 $fimfarchive.stampers.FlavorStamper$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.str$ 0 0 0 $fimfarchive.stories.Story$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Any$ 0 $fimfarchive.stories.Story$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from abc import ABC , abstractmethod [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class Command ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def __call__ ( self , * args ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Type , Dict , Any , Tuple , Iterator , Optional [EOL] import typing [EOL] import argparse [EOL] import fimfarchive [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import os [EOL] import traceback [EOL] from argparse import ArgumentParser , Namespace , FileType [EOL] from os . path import basename [EOL] from typing import Any , Iterable , Iterator , Optional [EOL] [EOL] import arrow [EOL] from jmespath import compile as jmes [EOL] [EOL] from fimfarchive . fetchers import ( Fetcher , FimfarchiveFetcher , Fimfiction2Fetcher , FimfictionFetcher , ) [EOL] from fimfarchive . flavors import UpdateStatus [EOL] from fimfarchive . selectors import Selector , RefetchSelector , UpdateSelector [EOL] from fimfarchive . signals import SignalReceiver [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . tasks import UpdateTask [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] ACCESS_TOKEN_KEY = [string] [EOL] [EOL] [EOL] class StoryFormatter ( Iterable [ str ] ) : [EOL] [docstring] [EOL] attrs = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] paths = { [string] : jmes ( [string] ) , [string] : jmes ( [string] ) , [string] : jmes ( [string] ) , [string] : jmes ( [string] ) , [string] : jmes ( [string] ) , } [EOL] [EOL] def __init__ ( self , story ) : [EOL] [docstring] [EOL] self . story = story [EOL] [EOL] def __getattr__ ( self , key ) : [EOL] [docstring] [EOL] meta = self . story . meta [EOL] path = self . paths . get ( key ) [EOL] [EOL] if path : [EOL] return path . search ( meta ) [EOL] else : [EOL] return meta . get ( key ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] for attr in self . attrs : [EOL] label = attr . capitalize ( ) [EOL] value = getattr ( self , attr ) [EOL] yield f"{ label } [string] { value }" [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return [string] . join ( self ) [EOL] [EOL] @ property def approval ( self ) : [EOL] [docstring] [EOL] likes = self . likes [EOL] dislikes = self . dislikes [EOL] [EOL] try : [EOL] ratio = likes / ( likes + dislikes ) [EOL] except TypeError : [EOL] return None [EOL] except ZeroDivisionError : [EOL] return f"{ [number] : [string] }" [EOL] else : [EOL] return f"{ ratio : [string] }" [EOL] [EOL] @ property def chapters ( self ) : [EOL] [docstring] [EOL] meta = self . story . meta [EOL] chapters = meta . get ( [string] ) [EOL] [EOL] if chapters is None : [EOL] return None [EOL] [EOL] return len ( chapters ) [EOL] [EOL] @ property def action ( self ) : [EOL] [docstring] [EOL] for flavor in self . story . flavors : [EOL] if isinstance ( flavor , UpdateStatus ) : [EOL] return flavor . name . capitalize ( ) [EOL] [EOL] return None [EOL] [EOL] [EOL] class UpdatePrinter ( SignalReceiver ) : [EOL] [docstring] [EOL] [EOL] def on_attempt ( self , sender , key , skips , retries ) : [EOL] [docstring] [EOL] print ( f" [string] { key }" ) [EOL] [EOL] if retries : [EOL] print ( f" [string] { retries }" ) [EOL] else : [EOL] print ( f" [string] { skips }" ) [EOL] [EOL] def on_success ( self , sender , key , story ) : [EOL] [docstring] [EOL] print ( StoryFormatter ( story ) ) [EOL] [EOL] def on_skipped ( self , sender , key , story ) : [EOL] [docstring] [EOL] if story : [EOL] print ( StoryFormatter ( story ) ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] def on_failure ( self , sender , key , error ) : [EOL] [docstring] [EOL] print ( [string] , error ) [EOL] traceback . print_exc ( ) [EOL] [EOL] [EOL] class UpdateCommand ( Command ) : [EOL] [docstring] [EOL] [EOL] @ property def parser ( self ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( prog = [string] , description = self . __doc__ , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , action = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , type = FileType ( [string] ) , required = True , metavar = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , action = [string] , ) [EOL] [EOL] return parser [EOL] [EOL] def configure ( self , opts ) : [EOL] [docstring] [EOL] fimfarchive = ... [EOL] fimfiction = ... [EOL] selector = ... [EOL] [EOL] token = os . environ . get ( ACCESS_TOKEN_KEY ) [EOL] [EOL] if opts . alpha : [EOL] fimfiction = FimfictionFetcher ( ) [EOL] elif token : [EOL] fimfiction = Fimfiction2Fetcher ( token , True , opts . refetch ) [EOL] else : [EOL] exit ( f" [string] { ACCESS_TOKEN_KEY }" ) [EOL] [EOL] if opts . refetch : [EOL] selector = RefetchSelector ( ) [EOL] else : [EOL] selector = UpdateSelector ( ) [EOL] [EOL] print ( f" [string] { arrow . now ( ) }" ) [EOL] print ( f" [string] { basename ( opts . archive . name ) }" ) [EOL] print ( f" [string] { type ( fimfiction ) . __name__ }" ) [EOL] print ( f" [string] { type ( selector ) . __name__ }" ) [EOL] [EOL] fimfarchive = FimfarchiveFetcher ( opts . archive ) [EOL] [EOL] return UpdateTask ( fimfarchive = fimfarchive , fimfiction = fimfiction , selector = selector , ) [EOL] [EOL] def __call__ ( self , * args ) : [EOL] opts = self . parser . parse_args ( args ) [EOL] task = self . configure ( opts ) [EOL] [EOL] with UpdatePrinter ( task ) : [EOL] task . run ( ) [EOL] [EOL] print ( f" [string] { arrow . now ( ) }" ) [EOL] [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.tasks.UpdateTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.tasks.update.UpdateTask$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $fimfarchive.tasks.update.UpdateTask$ 0 0 0 $fimfarchive.tasks.update.UpdateTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Any , Tuple , List [EOL] import builtins [EOL] import base [EOL] import fimfarchive [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Dict , Type [EOL] [EOL] from . base import Command [EOL] from . build import BuildCommand [EOL] from . update import UpdateCommand [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class RootCommand ( Command ) : [EOL] [docstring] [EOL] commands = { [string] : BuildCommand , [string] : UpdateCommand , } [EOL] [EOL] def load ( self , command ) : [EOL] [docstring] [EOL] return self . commands [ command ] ( ) [EOL] [EOL] def doc ( self , command , adjust = [number] , indent = [number] ) : [EOL] [docstring] [EOL] cls = self . load ( command ) [EOL] doc = getattr ( cls , [string] , None ) [EOL] [EOL] if doc : [EOL] doc = str ( doc ) . strip ( ) [EOL] doc = doc . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] description = [ indent * [string] , command . ljust ( adjust ) , str ( doc ) , ] [EOL] [EOL] return [string] . join ( description ) [EOL] [EOL] @ property def usage ( self ) : [EOL] [docstring] [EOL] text = [ [string] , [string] , ] [EOL] [EOL] if not self . commands : [EOL] return [string] . join ( text ) . strip ( ) [EOL] [EOL] commands = sorted ( cmd for cmd in self . commands . keys ( ) ) [EOL] adjust = max ( len ( cmd ) for cmd in commands ) + [number] [EOL] [EOL] text . append ( [string] ) [EOL] for command in commands : [EOL] line = self . doc ( command , adjust ) [EOL] text . extend ( ( line , [string] ) ) [EOL] [EOL] return [string] . join ( text ) . strip ( ) [EOL] [EOL] def __call__ ( self , * args ) : [EOL] try : [EOL] cmd = self . load ( args [ [number] ] ) [EOL] except ( IndexError , KeyError ) : [EOL] exit ( self . usage ) [EOL] else : [EOL] return cmd ( * args [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[base.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $base.Command$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.commands.base.Command$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $fimfarchive.commands.base.Command$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fimfarchive.commands.base.Command$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.commands.base.Command$ 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from . base import Command [EOL] from . build import BuildCommand [EOL] from . root import RootCommand [EOL] from . update import UpdateCommand [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import argparse [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from argparse import ArgumentParser , Namespace , FileType [EOL] [EOL] from fimfarchive . fetchers import DirectoryFetcher , FimfarchiveFetcher [EOL] from fimfarchive . flavors import DataFormat [EOL] from fimfarchive . tasks import BuildTask [EOL] from fimfarchive . utils import tqdm [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class BuildCommand ( Command ) : [EOL] [docstring] [EOL] [EOL] @ property def parser ( self ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( prog = [string] , description = self . __doc__ , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , type = FileType ( [string] ) , required = True , metavar = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , ) [EOL] [EOL] return parser [EOL] [EOL] def configure ( self , opts ) : [EOL] [docstring] [EOL] fimfarchive = FimfarchiveFetcher ( source = opts . archive , ) [EOL] [EOL] directory = DirectoryFetcher ( meta_path = opts . meta , data_path = opts . data , flavors = [ DataFormat . EPUB ] , ) [EOL] [EOL] return BuildTask ( output = opts . output , upcoming = tqdm ( directory ) , previous = fimfarchive , extras = opts . extras , ) [EOL] [EOL] def __call__ ( self , * args ) : [EOL] opts = self . parser . parse_args ( args ) [EOL] task = self . configure ( opts ) [EOL] [EOL] task . run ( ) [EOL] [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 $fimfarchive.tasks.BuildTask$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fimfarchive.fetchers.FimfarchiveFetcher$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $fimfarchive.fetchers.DirectoryFetcher$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $fimfarchive.fetchers.DirectoryFetcher$ 0 0 0 0 $fimfarchive.fetchers.FimfarchiveFetcher$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.tasks.build.BuildTask$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $fimfarchive.tasks.build.BuildTask$ 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Dict [EOL] import typing [EOL] import builtins [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from copy import deepcopy [EOL] from typing import Any , Optional [EOL] [EOL] import arrow [EOL] [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import JayWalker [EOL] [EOL] from . base import Converter [EOL] [EOL] [EOL] class DateNormalizer ( JayWalker ) : [EOL] [docstring] [EOL] [EOL] def handle ( self , data , key , value ) : [EOL] if str ( key ) . startswith ( [string] ) : [EOL] data [ key ] = self . normalize ( value ) [EOL] else : [EOL] self . walk ( value ) [EOL] [EOL] def normalize ( self , value ) : [EOL] [docstring] [EOL] parsed = arrow . get ( value or [number] ) [EOL] [EOL] if parsed . timestamp == [number] : [EOL] return None [EOL] [EOL] return parsed . to ( [string] ) . isoformat ( ) [EOL] [EOL] [EOL] class LocalUtcConverter ( Converter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . normalizer = DateNormalizer ( ) [EOL] [EOL] def __call__ ( self , story ) : [EOL] meta = deepcopy ( story . meta ) [EOL] self . normalizer . walk ( meta ) [EOL] [EOL] return story . merge ( meta = meta ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $fimfarchive.converters.local_utc.DateNormalizer$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0
from typing import Tuple [EOL] import typing [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from abc import ABC , abstractmethod [EOL] [EOL] from fimfarchive . stories import Story [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class Converter ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def __call__ ( self , story ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from . base import Converter [EOL] from . alpha_beta import AlphaBetaConverter [EOL] from . fpub_epub import FpubEpubConverter [EOL] from . json_fpub import JsonFpubConverter [EOL] from . local_utc import LocalUtcConverter [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Set , Union [EOL] import subprocess [EOL] import builtins [EOL] import fimfarchive [EOL] import typing [EOL] import functools [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from functools import partial [EOL] from pathlib import Path [EOL] from shutil import rmtree [EOL] from subprocess import DEVNULL , STDOUT , run [EOL] from tempfile import mkdtemp [EOL] from typing import Union [EOL] [EOL] from fimfarchive . flavors import DataFormat [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import get_path [EOL] [EOL] from . base import Converter [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] SOURCE = [string] [EOL] TARGET = [string] [EOL] TIMEOUT = [number] [EOL] [EOL] PROGRAM = [string] [EOL] ARGUMENTS = ( [string] , ) [EOL] [EOL] proc = partial ( run , stderr = STDOUT , timeout = TIMEOUT , check = True ) [EOL] [EOL] [EOL] def ebook_convert ( data , pipe = DEVNULL ) : [EOL] [docstring] [EOL] parent = Path ( mkdtemp ( ) ) [EOL] source = parent / SOURCE [EOL] target = parent / TARGET [EOL] [EOL] command = ( PROGRAM , str ( source ) , str ( target ) , * ARGUMENTS ) [EOL] [EOL] try : [EOL] source . write_bytes ( data ) [EOL] proc ( command , stdout = pipe ) [EOL] except Exception : [EOL] raise [EOL] else : [EOL] return target . read_bytes ( ) [EOL] finally : [EOL] rmtree ( parent ) [EOL] [EOL] [EOL] class FpubEpubConverter ( Converter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logdir = None ) : [EOL] self . logdir = get_path ( logdir ) [EOL] [EOL] if self . logdir and not self . logdir . is_dir ( ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def __call__ ( self , story ) : [EOL] if DataFormat . FPUB not in story . flavors : [EOL] raise ValueError ( f" [string] { DataFormat . FPUB }" ) [EOL] [EOL] if self . logdir is not None : [EOL] with open ( self . logdir / str ( story . key ) , [string] ) as fobj : [EOL] data = ebook_convert ( story . data , fobj . fileno ( ) ) [EOL] else : [EOL] data = ebook_convert ( story . data ) [EOL] [EOL] flavors = set ( story . flavors ) [EOL] flavors . remove ( DataFormat . FPUB ) [EOL] flavors . add ( DataFormat . EPUB ) [EOL] [EOL] return story . merge ( data = data , flavors = flavors ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 $functools.partial[subprocess.CompletedProcess[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[subprocess.CompletedProcess[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $fimfarchive.stories.Story$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $fimfarchive.stories.Story$ 0 $builtins.bytes$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Set[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0
from typing import Dict , Any , Tuple , Set , Iterator , List [EOL] import jinja2 [EOL] import fimfarchive [EOL] import builtins [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from io import BytesIO [EOL] from typing import Any , Dict , Iterator , Tuple [EOL] from zipfile import ZipFile , ZIP_DEFLATED , ZIP_STORED [EOL] [EOL] from jinja2 import Environment , PackageLoader [EOL] [EOL] from fimfarchive . flavors import DataFormat , MetaFormat [EOL] from fimfarchive . stories import Story [EOL] [EOL] from fimfarchive . fetchers . fimfiction2 import BetaFormatVerifier [EOL] [EOL] from . . base import Converter [EOL] from . . local_utc import LocalUtcConverter [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] MIMETYPE = [string] [EOL] PACKAGE = __package__ . rsplit ( [string] , [number] ) [EOL] [EOL] [EOL] class StoryRenderer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] env = Environment ( autoescape = True , keep_trailing_newline = True , loader = PackageLoader ( * PACKAGE ) , ) [EOL] [EOL] self . container_xml = env . get_template ( [string] ) [EOL] self . chapter_html = env . get_template ( [string] ) [EOL] self . book_opf = env . get_template ( [string] ) [EOL] self . book_ncx = env . get_template ( [string] ) [EOL] [EOL] self . verify_meta = BetaFormatVerifier . from_meta_params ( ) [EOL] self . verify_data = BetaFormatVerifier . from_data_params ( ) [EOL] [EOL] def fix_authors_note_position ( self , data ) : [EOL] [docstring] [EOL] authors_note = data [ [string] ] [EOL] [EOL] if not authors_note or len ( authors_note . strip ( ) ) < [number] : [EOL] data [ [string] ] = None [EOL] [EOL] def fix_local_href_attributes ( self , data ) : [EOL] [docstring] [EOL] source = [string] [EOL] target = [string] [EOL] [EOL] for key in ( [string] , [string] ) : [EOL] data [ key ] = data [ key ] . replace ( source , target ) [EOL] [EOL] def fix_local_src_attributes ( self , data ) : [EOL] [docstring] [EOL] source = [string] [EOL] target = [string] [EOL] [EOL] for key in ( [string] , [string] ) : [EOL] data [ key ] = data [ key ] . replace ( source , target ) [EOL] [EOL] def verify_index ( self , expected , actual ) : [EOL] [docstring] [EOL] if expected != actual : [EOL] raise ValueError ( f" [string] { expected } [string] { actual } [string] " ) [EOL] [EOL] def iter_chapters ( self , story ) : [EOL] [docstring] [EOL] self . verify_meta ( story . meta ) [EOL] [EOL] meta_chapters = story . meta [ [string] ] [EOL] data_chapters = json . loads ( story . data . decode ( ) ) [EOL] zipped = zip ( meta_chapters , data_chapters ) [EOL] [EOL] for index , chapter in enumerate ( zipped , [number] ) : [EOL] meta , data = chapter [EOL] [EOL] self . verify_data ( data ) [EOL] self . verify_index ( index , meta [ [string] ] ) [EOL] self . verify_index ( index , data [ [string] ] ) [EOL] [EOL] yield { ** data , ** meta } [EOL] [EOL] def iter_content ( self , story ) : [EOL] [docstring] [EOL] yield [string] , self . container_xml . render ( ) [EOL] [EOL] for chapter in self . iter_chapters ( story ) : [EOL] number = chapter [ [string] ] [EOL] path = f" [string] { number } [string] " [EOL] [EOL] self . fix_authors_note_position ( chapter ) [EOL] self . fix_local_href_attributes ( chapter ) [EOL] self . fix_local_src_attributes ( chapter ) [EOL] [EOL] yield path , self . chapter_html . render ( chapter ) [EOL] [EOL] yield [string] , self . book_opf . render ( story . meta ) [EOL] yield [string] , self . book_ncx . render ( story . meta ) [EOL] [EOL] def __call__ ( self , story ) : [EOL] [docstring] [EOL] fobj = BytesIO ( ) [EOL] [EOL] with ZipFile ( fobj , [string] ) as archive : [EOL] archive . writestr ( [string] , MIMETYPE , ZIP_STORED ) [EOL] [EOL] for path , data in self . iter_content ( story ) : [EOL] archive . writestr ( path , data , ZIP_DEFLATED ) [EOL] [EOL] return fobj . getvalue ( ) [EOL] [EOL] [EOL] class JsonFpubConverter ( Converter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . render = StoryRenderer ( ) [EOL] self . normalize = LocalUtcConverter ( ) [EOL] [EOL] def __call__ ( self , story ) : [EOL] if DataFormat . JSON not in story . flavors : [EOL] raise ValueError ( f" [string] { DataFormat . JSON }" ) [EOL] [EOL] if MetaFormat . BETA not in story . flavors : [EOL] raise ValueError ( f" [string] { MetaFormat . BETA }" ) [EOL] [EOL] story = self . normalize ( story ) [EOL] data = self . render ( story ) [EOL] [EOL] flavors = set ( story . flavors ) [EOL] flavors . remove ( DataFormat . JSON ) [EOL] flavors . add ( DataFormat . FPUB ) [EOL] [EOL] return story . merge ( data = data , flavors = flavors ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Any$ 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $fimfarchive.converters.json_fpub.StoryRenderer$ 0 0 0 0 0 0 0 $fimfarchive.converters.local_utc.LocalUtcConverter$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 $builtins.bytes$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Set[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0
from typing import Any , Optional , Dict [EOL] import typing [EOL] import fimfarchive [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import os [EOL] import time [EOL] from copy import deepcopy [EOL] from typing import Optional [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError [EOL] from fimfarchive . fetchers import Fetcher [EOL] from fimfarchive . flavors import DataFormat , StorySource , UpdateStatus [EOL] from fimfarchive . mappers import StoryPathMapper [EOL] from fimfarchive . selectors import Selector , UpdateSelector [EOL] from fimfarchive . signals import Signal , SignalSender [EOL] from fimfarchive . stampers import Stamper , UpdateStamper [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import PersistedDict [EOL] from fimfarchive . writers import DirectoryWriter [EOL] [EOL] [EOL] DEFAULT_WORKDIR = [string] [EOL] DEFAULT_RETRIES = [number] [EOL] DEFAULT_SKIPS = [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] SUCCESS_DELAY = [number] [EOL] SKIPPED_DELAY = [number] [EOL] FAILURE_DELAY = [number] [EOL] [EOL] [EOL] class UpdateTask ( SignalSender ) : [EOL] [docstring] [EOL] on_attempt = Signal ( [string] , [string] , [string] ) [EOL] on_success = Signal ( [string] , [string] ) [EOL] on_skipped = Signal ( [string] , [string] ) [EOL] on_failure = Signal ( [string] , [string] ) [EOL] [EOL] state_file = [string] [EOL] state_vars = { [string] : [number] } [EOL] [EOL] def __init__ ( self , fimfarchive , fimfiction , selector = None , stamper = None , workdir = DEFAULT_WORKDIR , retries = DEFAULT_RETRIES , skips = DEFAULT_SKIPS , ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] if selector is None : [EOL] selector = UpdateSelector ( ) [EOL] [EOL] if stamper is None : [EOL] stamper = UpdateStamper ( ) [EOL] [EOL] self . fimfarchive = fimfarchive [EOL] self . fimfiction = fimfiction [EOL] self . select = selector [EOL] self . stamp = stamper [EOL] self . workdir = workdir [EOL] self . retries = retries [EOL] self . skips = skips [EOL] [EOL] os . makedirs ( self . workdir , exist_ok = True ) [EOL] state_path = os . path . join ( self . workdir , self . state_file ) [EOL] self . state = PersistedDict ( state_path , self . state_vars ) [EOL] [EOL] meta_mapper = self . get_mapper ( [string] ) [EOL] skip_mapper = self . get_mapper ( [string] ) [EOL] epub_mapper = self . get_mapper ( [string] ) [EOL] html_mapper = self . get_mapper ( [string] ) [EOL] json_mapper = self . get_mapper ( [string] ) [EOL] [EOL] self . meta_writer = DirectoryWriter ( meta_mapper ) [EOL] self . skip_writer = DirectoryWriter ( skip_mapper ) [EOL] self . epub_writer = DirectoryWriter ( meta_mapper , epub_mapper ) [EOL] self . html_writer = DirectoryWriter ( meta_mapper , html_mapper ) [EOL] self . json_writer = DirectoryWriter ( meta_mapper , json_mapper ) [EOL] [EOL] def get_mapper ( self , subdir ) : [EOL] [docstring] [EOL] directory = os . path . join ( self . workdir , subdir ) [EOL] return StoryPathMapper ( directory ) [EOL] [EOL] def fetch ( self , fetcher , key ) : [EOL] [docstring] [EOL] try : [EOL] return fetcher . fetch ( key ) [EOL] except InvalidStoryError : [EOL] return None [EOL] [EOL] def write ( self , story ) : [EOL] [docstring] [EOL] if StorySource . FIMFARCHIVE in story . flavors : [EOL] self . meta_writer . write ( story ) [EOL] elif DataFormat . HTML in story . flavors : [EOL] self . html_writer . write ( story ) [EOL] elif DataFormat . JSON in story . flavors : [EOL] self . json_writer . write ( story ) [EOL] elif DataFormat . EPUB in story . flavors : [EOL] self . epub_writer . write ( story ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def copy_archive_meta ( self , old , new , ) : [EOL] [docstring] [EOL] if old is None or new is None : [EOL] return [EOL] [EOL] try : [EOL] if [string] in new . meta : [EOL] raise ValueError ( [string] ) [EOL] [EOL] new . meta [ [string] ] = deepcopy ( old . meta [ [string] ] ) [EOL] except ( InvalidStoryError , KeyError ) : [EOL] return [EOL] [EOL] def update ( self , key ) : [EOL] [docstring] [EOL] old = self . fetch ( self . fimfarchive , key ) [EOL] new = self . fetch ( self . fimfiction , key ) [EOL] [EOL] self . copy_archive_meta ( old , new ) [EOL] selected = self . select ( old , new ) [EOL] [EOL] if selected and UpdateStatus . REVIVED in selected . flavors : [EOL] assert new is not None [EOL] selected = selected . merge ( meta = new . meta ) [EOL] [EOL] if selected : [EOL] self . stamp ( selected ) [EOL] self . write ( selected ) [EOL] elif new : [EOL] self . skip_writer . write ( new ) [EOL] elif old : [EOL] self . skip_writer . write ( old ) [EOL] [EOL] return selected [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] retried = [number] [EOL] skipped = [number] [EOL] [EOL] while skipped < self . skips and retried < self . retries : [EOL] key = self . state [ [string] ] [EOL] [EOL] self . on_attempt ( key , skipped , retried ) [EOL] [EOL] try : [EOL] story = self . update ( key ) [EOL] except Exception as e : [EOL] retried += [number] [EOL] self . on_failure ( key , e ) [EOL] time . sleep ( FAILURE_DELAY ) [EOL] else : [EOL] retried = [number] [EOL] self . state [ [string] ] += [number] [EOL] self . state . save ( ) [EOL] [EOL] if story : [EOL] skipped = [number] [EOL] self . on_success ( key , story ) [EOL] time . sleep ( SUCCESS_DELAY ) [EOL] else : [EOL] skipped += [number] [EOL] self . on_skipped ( key , story ) [EOL] time . sleep ( SKIPPED_DELAY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $fimfarchive.utils.PersistedDict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 $fimfarchive.fetchers.Fetcher$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.Fetcher$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0
from typing import Iterable , Any , Tuple , Iterator , Optional [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from pathlib import Path [EOL] from typing import Iterable , Iterator , Optional , Tuple , Union [EOL] [EOL] import arrow [EOL] [EOL] from fimfarchive . converters import LocalUtcConverter [EOL] from fimfarchive . exceptions import InvalidStoryError , StorySourceError [EOL] from fimfarchive . fetchers import Fetcher [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import is_blacklisted [EOL] from fimfarchive . writers import FimfarchiveWriter [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] PathArg = Union [ Path , str ] [EOL] [EOL] [EOL] class BuildTask : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output , upcoming , previous = None , extras = None , ) : [EOL] [docstring] [EOL] self . previous = previous [EOL] self . upcoming = upcoming [EOL] [EOL] self . convert = LocalUtcConverter ( ) [EOL] self . output = self . get_output ( output ) [EOL] self . extras = self . get_extras ( extras ) [EOL] [EOL] def get_output ( self , directory ) : [EOL] [docstring] [EOL] date = arrow . utcnow ( ) . format ( [string] ) [EOL] path = Path ( directory ) . resolve ( True ) [EOL] name = f' [string] { date } [string] ' [EOL] [EOL] return path / name [EOL] [EOL] def get_extras ( self , directory ) : [EOL] [docstring] [EOL] if directory is None : [EOL] return ( ) [EOL] [EOL] for path in Path ( directory ) . iterdir ( ) : [EOL] yield path . name , path . read_bytes ( ) [EOL] [EOL] def revive ( self , story ) : [EOL] [docstring] [EOL] if self . previous is None : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] try : [EOL] revived = self . previous . fetch ( story . key ) [EOL] except InvalidStoryError as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] else : [EOL] return story . merge ( data = revived . data ) [EOL] [EOL] def resolve ( self , story ) : [EOL] [docstring] [EOL] try : [EOL] story . data [EOL] except InvalidStoryError : [EOL] return self . revive ( story ) [EOL] else : [EOL] return story [EOL] [EOL] def generate ( self ) : [EOL] [docstring] [EOL] for story in self . upcoming : [EOL] if is_blacklisted ( story ) : [EOL] continue [EOL] [EOL] converted = self . convert ( story ) [EOL] resolved = self . resolve ( converted ) [EOL] [EOL] yield resolved [EOL] [EOL] def run ( self ) : [EOL] with FimfarchiveWriter ( self . output , self . extras ) as writer : [EOL] for story in self . generate ( ) : [EOL] writer . write ( story ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Iterable[fimfarchive.stories.Story]$ 0 $fimfarchive.fetchers.base.Fetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.base.Fetcher$ 0 $fimfarchive.fetchers.base.Fetcher$ 0 0 0 $typing.Iterable[fimfarchive.stories.Story]$ 0 $typing.Iterable[fimfarchive.stories.Story]$ 0 0 0 0 $fimfarchive.converters.local_utc.LocalUtcConverter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $PathArg$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $PathArg$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 $typing.Optional[PathArg]$ 0 0 0 0 0 0 $typing.Optional[PathArg]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[PathArg]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Iterator[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from . build import BuildTask [EOL] from . update import UpdateTask [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0
from typing import Type , Dict , Callable , Any , Tuple , Iterator , Generator , Union , Optional , IO [EOL] import multiprocessing [EOL] import builtins [EOL] import fimfarchive [EOL] import typing [EOL] import io [EOL] import zipfile [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] import marshal [EOL] from io import BufferedReader [EOL] from multiprocessing import Pool [EOL] from typing import ( cast , Any , Callable , Dict , IO , Iterable , Iterator , Mapping , Optional , Sized , Tuple , Union , ) [EOL] from zipfile import ZipFile , BadZipFile [EOL] [EOL] from jmespath import compile as jmes [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError , StorySourceError [EOL] from fimfarchive . flavors import StorySource , DataFormat , MetaPurity [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import find_compressor [EOL] [EOL] from . base import Fetcher [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] BUFFER_SIZE = [number] [EOL] PATH = jmes ( [string] ) [EOL] [EOL] [EOL] compress , decompress = find_compressor ( ) [EOL] serialize = cast ( Callable [ [ Dict [ str , Any ] ] , bytes ] , marshal . dumps ) [EOL] deserialize = cast ( Callable [ [ bytes ] , Dict [ str , Any ] ] , marshal . loads ) [EOL] [EOL] [EOL] class Index ( Mapping [ int , Dict [ str , Any ] ] ) : [EOL] [docstring] [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] [EOL] def load ( self , source ) : [EOL] [docstring] [EOL] reader = BufferedReader ( source , BUFFER_SIZE ) [comment] [EOL] [EOL] with Pool ( ) as pool : [EOL] parts = ( part for part in reader if [number] < len ( part ) ) [EOL] mapper = pool . imap ( self . parse , parts , [number] ) [EOL] [EOL] for key , value in mapper : [EOL] if key < [number] : [EOL] raise StorySourceError ( value . decode ( ) ) [EOL] else : [EOL] yield key , value [EOL] [EOL] @ staticmethod def parse ( pair ) : [EOL] [docstring] [EOL] try : [EOL] key , meta = pair . split ( [string] , [number] ) [EOL] key = key . strip ( [string] ) [EOL] meta = meta . strip ( [string] ) [EOL] except Exception as e : [EOL] return - [number] , f" [string] { e }" . encode ( ) [EOL] [EOL] if meta [ [number] ] != [number] or meta [ - [number] ] != [number] : [EOL] return - [number] , f" [string] { key !r} [string] " . encode ( ) [EOL] [EOL] try : [EOL] return int ( key ) , serialize ( json . loads ( meta . decode ( ) ) ) [EOL] except UnicodeDecodeError as e : [EOL] return - [number] , f" [string] { e }" . encode ( ) [EOL] except ValueError as e : [EOL] return - [number] , f" [string] { key !r} [string] { e }" . encode ( ) [EOL] [EOL] [EOL] class MemoryIndex ( Index ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , stream ) : [EOL] self . data = { k : compress ( v ) for k , v in self . load ( stream ) } [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return deserialize ( decompress ( self . data [ key ] ) ) [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item in self . data [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . data ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . data ) [EOL] [EOL] def close ( self ) : [EOL] self . data . clear ( ) [EOL] [EOL] [EOL] class FimfarchiveFetcher ( Iterable [ Story ] , Sized , Fetcher ) : [EOL] [docstring] [EOL] prefetch_meta = True [EOL] prefetch_data = False [EOL] [EOL] flavors = frozenset ( ( StorySource . FIMFARCHIVE , DataFormat . EPUB , MetaPurity . CLEAN , ) ) [EOL] [EOL] def __init__ ( self , source ) : [EOL] [docstring] [EOL] self . archive = ... [EOL] self . index = ... [EOL] self . paths = ... [EOL] self . is_open = False [EOL] [EOL] try : [EOL] self . initialize ( source ) [EOL] except Exception : [EOL] self . close ( ) [EOL] raise [EOL] [EOL] def initialize ( self , source ) : [EOL] [docstring] [EOL] try : [EOL] self . archive = ZipFile ( source ) [EOL] except IOError as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] except BadZipFile as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] try : [EOL] with self . archive . open ( [string] ) as fobj : [EOL] self . index = MemoryIndex ( fobj ) [EOL] except KeyError as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] except BadZipFile as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] self . paths = dict ( ) [EOL] self . is_open = True [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] return len ( self . index ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] for key in sorted ( self . index . keys ( ) ) : [EOL] yield self . fetch ( key ) [EOL] [EOL] def validate ( self , key ) : [EOL] [docstring] [EOL] key = int ( key ) [EOL] [EOL] if not self . is_open : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] if key not in self . index : [EOL] raise InvalidStoryError ( f" [string] { key }" ) [EOL] [EOL] return key [EOL] [EOL] def fetch_path ( self , key ) : [EOL] [docstring] [EOL] key = self . validate ( key ) [EOL] path = self . paths . get ( key ) [EOL] [EOL] if path is not None : [EOL] return path [EOL] [EOL] meta = self . fetch_meta ( key ) [EOL] path = PATH . search ( meta ) [EOL] [EOL] if path is not None : [EOL] return path [EOL] [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] def close ( self ) : [EOL] self . is_open = False [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] self . archive . close ( ) [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] self . index . close ( ) [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] self . paths . clear ( ) [EOL] [EOL] def fetch_meta ( self , key ) : [EOL] key = self . validate ( key ) [EOL] meta = self . index [ key ] [EOL] actual = meta . get ( [string] ) [EOL] [EOL] if key != actual : [EOL] raise StorySourceError ( f" [string] { key } [string] { actual }" ) [EOL] [EOL] try : [EOL] archive = meta . get ( [string] , meta ) [EOL] self . paths [ key ] = archive [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] return meta [EOL] [EOL] def fetch_data ( self , key ) : [EOL] key = self . validate ( key ) [EOL] path = self . fetch_path ( key ) [EOL] [EOL] if not path : [EOL] raise StorySourceError ( f" [string] { key } [string] " ) [EOL] [EOL] try : [EOL] data = self . archive . read ( path ) [EOL] except ValueError as e : [EOL] raise StorySourceError ( f" [string] { key } [string] { path }" ) from e [EOL] except BadZipFile as e : [EOL] raise StorySourceError ( f" [string] { key } [string] { path }" ) from e [EOL] [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.str,typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 $Index$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.str,typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 $typing.Union[builtins.str,typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.fimfarchive.Index$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bytes$ 0
import builtins [EOL] from typing import Any , Tuple , Type [EOL] import typing [EOL] import fimfarchive [EOL] import requests [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import requests [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError , StorySourceError [EOL] from fimfarchive . flavors import StorySource , DataFormat , MetaFormat , MetaPurity [EOL] [EOL] from . base import Fetcher [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class FimfictionFetcher ( Fetcher ) : [EOL] [docstring] [EOL] prefetch_meta = True [EOL] prefetch_data = False [EOL] [EOL] data_path = [string] [EOL] meta_path = [string] [EOL] [EOL] flavors = frozenset ( ( StorySource . FIMFICTION , DataFormat . HTML , MetaFormat . ALPHA , MetaPurity . DIRTY , ) ) [EOL] [EOL] def get ( self , url ) : [EOL] [docstring] [EOL] try : [EOL] response = requests . get ( url , timeout = [number] ) [EOL] except OSError as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] if response . status_code == [number] : [EOL] raise InvalidStoryError ( [string] ) [EOL] [EOL] if not response . ok : [EOL] raise StorySourceError ( [string] . format ( response . status_code , response . reason ) ) [EOL] [EOL] return response [EOL] [EOL] def fetch_data ( self , key ) : [EOL] url = self . data_path . format ( key ) [EOL] response = self . get ( url ) [EOL] data = response . content [EOL] [EOL] if len ( data ) == [number] : [EOL] raise InvalidStoryError ( [string] ) [EOL] [EOL] if [string] not in data : [EOL] raise InvalidStoryError ( [string] ) [EOL] [EOL] if not data . endswith ( [string] ) : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] return data [EOL] [EOL] def fetch_meta ( self , key ) : [EOL] url = self . meta_path . format ( key ) [EOL] response = self . get ( url ) [EOL] [EOL] try : [EOL] meta = response . json ( ) [EOL] except ValueError as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] if [string] in meta : [EOL] message = meta [ [string] ] [EOL] [EOL] if message == [string] : [EOL] raise InvalidStoryError ( [string] ) [EOL] else : [EOL] raise StorySourceError ( message ) [EOL] [EOL] if [string] not in meta : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] return meta [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Iterable , Dict , Any , Tuple , Set , Iterator , Union , Optional [EOL] import typing [EOL] import fimfarchive [EOL] import pathlib [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from itertools import chain [EOL] from pathlib import Path [EOL] from typing import Any , Dict , Iterable , Iterator , Optional , Set , Sized , Union [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError , StorySourceError [EOL] from fimfarchive . flavors import Flavor [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import get_path [EOL] [EOL] from . base import Fetcher [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class DirectoryFetcher ( Iterable [ Story ] , Sized , Fetcher ) : [EOL] [docstring] [EOL] prefetch_meta = False [EOL] prefetch_data = False [EOL] [EOL] def __init__ ( self , meta_path = None , data_path = None , flavors = tuple ( ) , ) : [EOL] [docstring] [EOL] self . meta_path = get_path ( meta_path ) [EOL] self . data_path = get_path ( data_path ) [EOL] self . length = None [EOL] self . flavors = frozenset ( flavors ) [EOL] [EOL] def iter_path_keys ( self , path ) : [EOL] [docstring] [EOL] if path is None : [EOL] return [EOL] [EOL] if not path . is_dir ( ) : [EOL] raise StorySourceError ( f" [string] { path }" ) [EOL] [EOL] for item in Path ( path ) . iterdir ( ) : [EOL] if not item . is_file ( ) : [EOL] raise StorySourceError ( f" [string] { item }" ) [EOL] [EOL] if not item . name . isdigit ( ) : [EOL] raise StorySourceError ( f" [string] { item }" ) [EOL] [EOL] yield int ( item . name ) [EOL] [EOL] def list_keys ( self ) : [EOL] [docstring] [EOL] meta_keys = self . iter_path_keys ( self . meta_path ) [EOL] data_keys = self . iter_path_keys ( self . data_path ) [EOL] [EOL] return set ( chain ( meta_keys , data_keys ) ) [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] if self . length is None : [EOL] self . length = len ( self . list_keys ( ) ) [EOL] [EOL] return self . length [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] for key in sorted ( self . list_keys ( ) ) : [EOL] yield self . fetch ( key ) [EOL] [EOL] def read_file ( self , path ) : [EOL] [docstring] [EOL] try : [EOL] return path . read_bytes ( ) [EOL] except FileNotFoundError as e : [EOL] raise InvalidStoryError ( [string] ) from e [EOL] except Exception as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] def fetch_data ( self , key ) : [EOL] if self . data_path is None : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] path = self . data_path / str ( key ) [EOL] raw = self . read_file ( path ) [EOL] [EOL] return raw [EOL] [EOL] def fetch_meta ( self , key ) : [EOL] if self . meta_path is None : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] path = self . meta_path / str ( key ) [EOL] raw = self . read_file ( path ) [EOL] [EOL] return json . loads ( raw . decode ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Iterator[fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0
from typing import Tuple , FrozenSet [EOL] import typing [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import FrozenSet [EOL] [EOL] from fimfarchive . flavors import Flavor [EOL] from fimfarchive . stories import Story [EOL] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] class Fetcher : [EOL] [docstring] [EOL] prefetch_meta = False [EOL] prefetch_data = False [EOL] [EOL] flavors = frozenset ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] [docstring] [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback ) : [EOL] [docstring] [EOL] self . close ( ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def fetch ( self , key , prefetch_meta = None , prefetch_data = None ) : [EOL] [docstring] [EOL] if prefetch_meta is None : [EOL] prefetch_meta = self . prefetch_meta [EOL] [EOL] if prefetch_meta : [EOL] meta = self . fetch_meta ( key ) [EOL] else : [EOL] meta = None [EOL] [EOL] if prefetch_data is None : [EOL] prefetch_data = self . prefetch_data [EOL] [EOL] if prefetch_data : [EOL] data = self . fetch_data ( key ) [EOL] else : [EOL] data = None [EOL] [EOL] return Story ( key , self , meta , data , self . flavors ) [EOL] [EOL] def fetch_data ( self , key ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def fetch_meta ( self , key ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.FrozenSet[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from . base import Fetcher [EOL] from . directory import DirectoryFetcher [EOL] from . fimfarchive import FimfarchiveFetcher [EOL] from . fimfiction import FimfictionFetcher [EOL] from . fimfiction2 import Fimfiction2Fetcher [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Any , Tuple , Set , Iterator , List [EOL] import jsonapi_client [EOL] import typing [EOL] import builtins [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from abc import ABC , abstractmethod [EOL] from collections import OrderedDict , defaultdict [EOL] from copy import deepcopy [EOL] from typing import Any , Dict , Iterator , Optional , Set [EOL] from urllib . parse import urlencode [EOL] [EOL] from jsonapi_client import Filter , Session [EOL] from jsonapi_client . document import Document [EOL] from jsonapi_client . exceptions import DocumentError [EOL] from jsonapi_client . resourceobject import ResourceObject [EOL] [EOL] from fimfarchive import __version__ as VERSION [EOL] from fimfarchive . flavors import DataFormat , MetaFormat , MetaPurity , StorySource [EOL] [EOL] from fimfarchive . exceptions import ( FimfarchiveError , InvalidStoryError , StorySourceError , ) [EOL] [EOL] from . base import Fetcher [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , ) [EOL] [EOL] [EOL] QueryParams = Dict [ str , Set [ str ] ] [EOL] [EOL] [EOL] ROOT = [string] [EOL] AUTHOR = [string] [EOL] CHAPTERS = [string] [EOL] PREQUEL = [string] [EOL] TAGS = [string] [EOL] [EOL] [EOL] DATA_PARAMS = { [string] : { [string] , } , [string] : { [string] , [string] , [string] , [string] , [string] , } , [string] : { [string] , } , } [EOL] [EOL] [EOL] META_PARAMS = { [string] : { [string] , [string] , [string] , } , [string] : { [string] , [string] , [string] , [string] , [string] , [string] , [string] , } , [string] : { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } , [string] : { [string] , [string] , } , [string] : { [string] , [string] , [string] , [string] , [string] , [string] , [string] , } , } [EOL] [EOL] [EOL] class ApiClient : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , token ) : [EOL] [docstring] [EOL] self . token = token [EOL] [EOL] def create_session ( self , token ) : [EOL] [docstring] [EOL] headers = { [string] : [string] , [string] : f' [string] { token }' , [string] : f' [string] { VERSION }' , } [EOL] [EOL] return Session ( server_url = [string] , request_kwargs = { [string] : headers } , ) [EOL] [EOL] def create_filter ( self , params ) : [EOL] [docstring] [EOL] joined = OrderedDict ( ) [EOL] [EOL] for key , value in sorted ( params . items ( ) ) : [EOL] joined [ key ] = [string] . join ( sorted ( value ) ) [EOL] [EOL] return Filter ( urlencode ( joined ) ) [EOL] [EOL] def get ( self , path , params = dict ( ) ) : [EOL] [docstring] [EOL] query = self . create_filter ( params ) [EOL] session = self . create_session ( self . token ) [EOL] [EOL] return session . get ( path , query ) [EOL] [EOL] [EOL] class Requester ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def get_meta ( self , key ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def get_data ( self , key ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SingleRequester ( Requester ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client ) : [EOL] [docstring] [EOL] self . client = client [EOL] [EOL] def error ( self , key , status ) : [EOL] [docstring] [EOL] if status == [number] : [EOL] return InvalidStoryError ( f" [string] { key }" ) [EOL] elif status == [number] : [EOL] return InvalidStoryError ( f" [string] { key }" ) [EOL] else : [EOL] return StorySourceError ( f" [string] { key } [string] { status }" ) [EOL] [EOL] def get ( self , key , path , params ) : [EOL] [docstring] [EOL] try : [EOL] return self . client . get ( path , params ) [EOL] except DocumentError as e : [EOL] raise self . error ( key , e . response . status_code ) from e [EOL] except Exception as e : [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] def get_meta ( self , key ) : [EOL] path = f' [string] { key }' [EOL] response = self . get ( key , path , META_PARAMS ) [EOL] return response . resource [EOL] [EOL] def get_data ( self , key ) : [EOL] path = f' [string] { key } [string] ' [EOL] response = self . get ( key , path , DATA_PARAMS ) [EOL] return response . resources [EOL] [EOL] [EOL] class BulkRequester ( Requester ) : [EOL] [docstring] [EOL] response = ... [EOL] resources = ... [EOL] [EOL] def __init__ ( self , client , bulk_meta = True , bulk_data = True , bulk_size = [number] , ) : [EOL] [docstring] [EOL] self . client = client [EOL] self . bulk_meta = bulk_meta [EOL] self . bulk_data = bulk_data [EOL] self . bulk_size = bulk_size [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] [docstring] [EOL] try : [EOL] super ( ) . __setattr__ ( name , value ) [EOL] finally : [EOL] if name in ( [string] , [string] ) : [EOL] self . reset ( ) [EOL] [EOL] def reset ( self ) : [EOL] [docstring] [EOL] self . response = None [EOL] self . resources = dict ( ) [EOL] [EOL] def create_params ( self ) : [EOL] [docstring] [EOL] params = defaultdict ( set ) [EOL] [EOL] if self . bulk_meta : [EOL] for key , value in META_PARAMS . items ( ) : [EOL] params [ key ] . update ( value ) [EOL] [EOL] if self . bulk_data : [EOL] for key , value in DATA_PARAMS . items ( ) : [EOL] params [ key ] . update ( value ) [EOL] [EOL] return dict ( params ) [EOL] [EOL] def cache ( self , key ) : [EOL] [docstring] [EOL] count = int ( self . bulk_size ) [EOL] lower = key - ( key % count ) [EOL] upper = lower + count [EOL] [EOL] keys = range ( lower , upper ) [EOL] params = self . create_params ( ) [EOL] params [ [string] ] = { str ( len ( keys ) + [number] ) } [EOL] params [ [string] ] = { str ( i ) for i in keys } [EOL] [EOL] self . response = self . client . get ( [string] , params ) [EOL] self . resources = { key : None for key in keys } [EOL] [EOL] for resource in self . response . resources : [EOL] self . resources [ int ( resource . id ) ] = resource [EOL] [EOL] def fetch ( self , key ) : [EOL] [docstring] [EOL] if key not in self . resources : [EOL] try : [EOL] self . cache ( key ) [EOL] except Exception as e : [EOL] self . reset ( ) [EOL] raise StorySourceError ( [string] ) from e [EOL] [EOL] resource = self . resources [ key ] [EOL] [EOL] if resource is None : [EOL] raise InvalidStoryError ( [string] ) [EOL] [EOL] return resource [EOL] [EOL] def get_meta ( self , key ) : [EOL] if not self . bulk_meta : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] return self . fetch ( key ) [EOL] [EOL] def get_data ( self , key ) : [EOL] if not self . bulk_data : [EOL] raise StorySourceError ( [string] ) [EOL] [EOL] return self . fetch ( key ) . chapters [EOL] [EOL] [EOL] class RoutedRequester ( Requester ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , bulk_meta , bulk_data , ) : [EOL] [docstring] [EOL] self . single = SingleRequester ( client ) [EOL] self . bulk = BulkRequester ( client , bulk_meta , bulk_data ) [EOL] [EOL] def get_meta ( self , key ) : [EOL] if self . bulk . bulk_meta : [EOL] return self . bulk . get_meta ( key ) [EOL] else : [EOL] return self . single . get_meta ( key ) [EOL] [EOL] def get_data ( self , key ) : [EOL] if self . bulk . bulk_data : [EOL] return self . bulk . get_data ( key ) [EOL] else : [EOL] return self . single . get_data ( key ) [EOL] [EOL] [EOL] class Documentifier : [EOL] [docstring] [EOL] [EOL] def merge ( self , target , source ) : [EOL] [docstring] [EOL] for key , value in deepcopy ( source ) . items ( ) : [EOL] assert key not in target [EOL] target [ key ] = value [EOL] [EOL] def flatten ( self , resource ) : [EOL] [docstring] [EOL] document = { [string] : int ( resource . id ) , } [EOL] [EOL] self . merge ( document , resource . json [ [string] ] ) [EOL] self . merge ( document , resource . meta . meta ) [EOL] [EOL] return document [EOL] [EOL] def __call__ ( self , resource ) : [EOL] [docstring] [EOL] return self . flatten ( resource ) [EOL] [EOL] [EOL] class MetaDocumentifier ( Documentifier ) : [EOL] [docstring] [EOL] fill = ( [string] , [string] , ) [EOL] [EOL] remove = ( [string] , [string] , [string] , ) [EOL] [EOL] def fill_keys ( self , meta ) : [EOL] [docstring] [EOL] for key in self . fill : [EOL] if key not in meta : [EOL] meta [ key ] = None [EOL] [EOL] def remove_data ( self , meta ) : [EOL] [docstring] [EOL] for chapter in meta [ [string] ] : [EOL] for key in self . remove : [EOL] if key in chapter : [EOL] del chapter [ key ] [EOL] [EOL] def __call__ ( self , resource ) : [EOL] meta = self . flatten ( resource ) [EOL] [EOL] assert AUTHOR not in meta [EOL] meta [ AUTHOR ] = self . flatten ( resource . author ) [EOL] [EOL] assert CHAPTERS not in meta [EOL] chapters = [ self . flatten ( chapter ) for chapter in resource . chapters ] [EOL] chapters . sort ( key = lambda chapter : chapter [ [string] ] ) [EOL] meta [ CHAPTERS ] = chapters [EOL] [EOL] assert PREQUEL not in meta [EOL] prequel = getattr ( resource . relationships , PREQUEL , None ) [EOL] [EOL] if prequel : [EOL] value = prequel . _resource_identifier . id [EOL] meta [ PREQUEL ] = int ( value ) [EOL] else : [EOL] meta [ PREQUEL ] = None [EOL] [EOL] assert TAGS not in meta [EOL] tags = [ self . flatten ( tag ) for tag in resource . tags ] [EOL] tags . sort ( key = lambda tag : ( tag [ [string] ] , tag [ [string] ] ) ) [EOL] meta [ TAGS ] = tags [EOL] [EOL] self . fill_keys ( meta ) [EOL] self . remove_data ( meta ) [EOL] [EOL] return meta [EOL] [EOL] [EOL] class BetaFormatVerifier : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , requirements ) : [EOL] [docstring] [EOL] self . requirements = requirements [EOL] [EOL] @ classmethod def from_params ( cls , params , mapping , ) : [EOL] [docstring] [EOL] requirements = dict ( ) [EOL] [EOL] for key , resource in mapping . items ( ) : [EOL] param = f' [string] { resource } [string] ' [EOL] fields = deepcopy ( params [ param ] ) [EOL] fields . update ( ( [string] , [string] ) ) [EOL] requirements [ key ] = fields [EOL] [EOL] return cls ( requirements ) [EOL] [EOL] @ classmethod def from_meta_params ( cls ) : [EOL] [docstring] [EOL] return cls . from_params ( META_PARAMS , { ROOT : [string] , AUTHOR : [string] , CHAPTERS : [string] , TAGS : [string] , } ) [EOL] [EOL] @ classmethod def from_data_params ( cls ) : [EOL] [docstring] [EOL] return cls . from_params ( DATA_PARAMS , { ROOT : [string] , } ) [EOL] [EOL] def check ( self , key , required , data ) : [EOL] [docstring] [EOL] if isinstance ( data , dict ) : [EOL] data = ( data , ) [EOL] [EOL] for obj in data : [EOL] if obj . keys ( ) < required : [EOL] missing = [string] . join ( required - obj . keys ( ) ) [EOL] message = f" [string] { key } [string] { missing }" [EOL] raise StorySourceError ( message ) [EOL] [EOL] def __call__ ( self , data ) : [EOL] [docstring] [EOL] for key , required in self . requirements . items ( ) : [EOL] if key == ROOT : [EOL] self . check ( key , required , data ) [EOL] else : [EOL] self . check ( key , required , data [ key ] ) [EOL] [EOL] [EOL] class Fimfiction2Fetcher ( Fetcher ) : [EOL] [docstring] [EOL] prefetch_meta = True [EOL] prefetch_data = False [EOL] [EOL] flavors = frozenset ( ( StorySource . FIMFICTION , DataFormat . JSON , MetaFormat . BETA , MetaPurity . DIRTY , ) ) [EOL] [EOL] def __init__ ( self , token , bulk_meta = False , bulk_data = False ) : [EOL] [docstring] [EOL] client = ApiClient ( token ) [EOL] self . extract_meta = MetaDocumentifier ( ) [EOL] self . extract_chapter = Documentifier ( ) [EOL] self . verify_meta = BetaFormatVerifier . from_meta_params ( ) [EOL] self . verify_chapter = BetaFormatVerifier . from_data_params ( ) [EOL] self . requester = RoutedRequester ( client , bulk_meta , bulk_data ) [EOL] [EOL] def fetch_meta ( self , key ) : [EOL] resource = self . requester . get_meta ( int ( key ) ) [EOL] meta = self . extract_meta ( resource ) [EOL] self . verify_meta ( meta ) [EOL] [EOL] return meta [EOL] [EOL] def fetch_data ( self , key ) : [EOL] resource = self . requester . get_data ( int ( key ) ) [EOL] chapters = [ self . extract_chapter ( chapter ) for chapter in resource ] [EOL] [EOL] if not chapters : [EOL] raise InvalidStoryError ( [string] ) [EOL] [EOL] for chapter in chapters : [EOL] self . verify_chapter ( chapter ) [EOL] [EOL] chapters . sort ( key = lambda chapter : chapter [ [string] ] ) [EOL] [EOL] data = json . dumps ( chapters , indent = [number] , ensure_ascii = False , sort_keys = True ) [EOL] [EOL] return data . encode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[jsonapi_client.document.Document]$ 0 0 0 $typing.Dict[builtins.int,typing.Optional[jsonapi_client.resourceobject.ResourceObject]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.fimfiction2.ApiClient$ 0 0 0 $builtins.str$ 0 0 0 0 $fimfarchive.fetchers.fimfiction2.MetaDocumentifier$ 0 0 0 0 0 0 0 $fimfarchive.fetchers.fimfiction2.Documentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.fimfiction2.RoutedRequester$ 0 0 0 $fimfarchive.fetchers.fimfiction2.ApiClient$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from fimfarchive . flavors import Flavor [EOL] [EOL] [EOL] class TestFlavor : [EOL] [docstring] [EOL] [EOL] def assert_flavor ( self , flavor ) : [EOL] [docstring] [EOL] a = flavor . A [EOL] b = flavor . B [EOL] [EOL] assert type ( a ) == flavor [EOL] assert type ( b ) == flavor [EOL] assert a . value == [number] [EOL] assert b . value == [number] [EOL] assert a is flavor . A [EOL] assert b is flavor . B [EOL] assert a is not b [EOL] assert a != b [EOL] assert a in { a } [EOL] assert b not in { a } [EOL] [EOL] def test_flavor_with_empty_values ( self ) : [EOL] [docstring] [EOL] class MyFlavor ( Flavor ) : [EOL] A = ( ) [EOL] B = ( ) [EOL] [EOL] self . assert_flavor ( MyFlavor ) [EOL] [EOL] def test_flavor_with_custom_values ( self ) : [EOL] [docstring] [EOL] class MyFlavor ( Flavor ) : [EOL] A = [number] [EOL] B = ( [number] , [number] ) [EOL] [EOL] def __init__ ( self , one , two = [number] ) : [EOL] self . one = one [EOL] self . two = two [EOL] [EOL] self . assert_flavor ( MyFlavor ) [EOL] [EOL] assert MyFlavor . A . one == [number] [EOL] assert MyFlavor . A . two == [number] [EOL] assert MyFlavor . B . one == [number] [EOL] assert MyFlavor . B . two == [number] [EOL] [EOL] def test_instance_representation ( self ) : [EOL] [docstring] [EOL] class MyFlavor ( Flavor ) : [EOL] A = ( ) [EOL] B = ( ) [EOL] [EOL] template = [string] [EOL] [EOL] assert repr ( MyFlavor . A ) == template . format ( [string] ) [EOL] assert repr ( MyFlavor . B ) == template . format ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import pytest [EOL] [EOL] [EOL] MODULES = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class TestImport : [EOL] [docstring] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , MODULES ) def test_wildcard_import ( self , module ) : [EOL] [docstring] [EOL] template = [string] [EOL] statement = template . format ( module ) [EOL] [EOL] exec ( statement ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from unittest . mock import patch [EOL] from typing import Dict [EOL] [EOL] import arrow [EOL] import pytest [EOL] [EOL] from fimfarchive . flavors import DataFormat , MetaFormat , UpdateStatus [EOL] from fimfarchive . mappers import StaticMapper [EOL] from fimfarchive . stampers import ( Stamper , FlavorStamper , PathStamper , UpdateStamper , ) [EOL] [EOL] [EOL] class TestStamper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def stamper ( self ) : [EOL] [docstring] [EOL] return Stamper ( ) [EOL] [EOL] def test_missing_archive_dict ( self , stamper , story ) : [EOL] [docstring] [EOL] meta = story . meta [EOL] assert [string] not in meta [EOL] [EOL] archive = stamper . get_archive ( story ) [EOL] assert meta [ [string] ] is archive [EOL] [EOL] def test_existing_archive_dict ( self , stamper , story ) : [EOL] [docstring] [EOL] meta = story . meta [EOL] original = dict ( ) [EOL] meta [ [string] ] = original [EOL] archive = stamper . get_archive ( story ) [EOL] [EOL] assert meta [ [string] ] is original [EOL] assert archive is original [EOL] [EOL] [EOL] class TestUpdateStamper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def time ( self ) : [EOL] [docstring] [EOL] stamp = arrow . get ( [number] ) [EOL] [EOL] with patch ( [string] ) as m : [EOL] m . return_value = stamp [EOL] yield stamp . isoformat ( ) [EOL] [EOL] @ pytest . fixture def stamper ( self , time ) : [EOL] [docstring] [EOL] return UpdateStamper ( ) [EOL] [EOL] def test_created_story ( self , stamper , story , time ) : [EOL] [docstring] [EOL] story . flavors . add ( UpdateStatus . CREATED ) [EOL] stamper ( story ) [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] [EOL] def test_updated_story ( self , stamper , story , time ) : [EOL] [docstring] [EOL] story . flavors . add ( UpdateStatus . UPDATED ) [EOL] stamper ( story ) [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] is None [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] [EOL] def test_revived_story ( self , stamper , story , time ) : [EOL] [docstring] [EOL] story . flavors . add ( UpdateStatus . REVIVED ) [EOL] stamper ( story ) [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] is None [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] is None [EOL] [EOL] def test_deleted_story ( self , stamper , story , time ) : [EOL] [docstring] [EOL] story . flavors . add ( UpdateStatus . DELETED ) [EOL] stamper ( story ) [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] is None [EOL] assert archive [ [string] ] is None [EOL] assert archive [ [string] ] is None [EOL] [EOL] def test_created_modification ( self , stamper , story , time ) : [EOL] [docstring] [EOL] story . flavors . add ( UpdateStatus . CREATED ) [EOL] prev = arrow . get ( - [number] ) . isoformat ( ) [EOL] [EOL] story . meta [ [string] ] = { [string] : prev , [string] : prev , [string] : prev , [string] : prev , } [EOL] [EOL] stamper ( story ) [EOL] assert prev != time [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == time [EOL] [EOL] def test_deleted_modification ( self , stamper , story , time ) : [EOL] [docstring] [EOL] story . flavors . add ( UpdateStatus . DELETED ) [EOL] prev = arrow . get ( - [number] ) . isoformat ( ) [EOL] [EOL] story . meta [ [string] ] = { [string] : prev , [string] : prev , [string] : prev , [string] : prev , } [EOL] [EOL] stamper ( story ) [EOL] assert prev != time [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert archive [ [string] ] == time [EOL] assert archive [ [string] ] == prev [EOL] assert archive [ [string] ] == prev [EOL] assert archive [ [string] ] == prev [EOL] [EOL] [EOL] class TestFlavorStamper : [EOL] [docstring] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( None , [string] ) ) def test_ignored_blank_value ( self , story , value ) : [EOL] [docstring] [EOL] stamp = FlavorStamper ( StaticMapper ( value ) ) [EOL] stamp ( story ) [EOL] [EOL] assert value not in story . flavors [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( DataFormat . EPUB , MetaFormat . ALPHA , ) ) def test_stamped_value ( self , story , value ) : [EOL] [docstring] [EOL] stamp = FlavorStamper ( StaticMapper ( value ) ) [EOL] stamp ( story ) [EOL] [EOL] assert value in story . flavors [EOL] [EOL] [EOL] class TestPathStamper : [EOL] [docstring] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( None , [string] ) ) def test_cleared_alpha_path ( self , story , value ) : [EOL] [docstring] [EOL] story = story . merge ( meta = { ** story . meta , [string] : [string] , } ) [EOL] [EOL] meta = story . meta [EOL] assert [string] in meta [EOL] [EOL] stamp = PathStamper ( StaticMapper ( value ) ) [EOL] stamp ( story ) [EOL] [EOL] assert [string] not in meta [EOL] [EOL] def test_cleared_beta_path ( self , story ) : [EOL] [docstring] [EOL] story = story . merge ( meta = { ** story . meta , [string] : { [string] : [string] , } , } ) [EOL] [EOL] archive = story . meta [ [string] ] [EOL] assert [string] in archive [EOL] [EOL] stamp = PathStamper ( StaticMapper ( None ) ) [EOL] stamp ( story ) [EOL] [EOL] assert [string] not in archive [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( None , [string] ) ) def test_ignored_blank_value ( self , story , value ) : [EOL] [docstring] [EOL] stamp = PathStamper ( StaticMapper ( value ) ) [EOL] stamp ( story ) [EOL] [EOL] assert [string] not in story . meta [ [string] ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) def test_stamped_value ( self , story , value ) : [EOL] [docstring] [EOL] stamp = PathStamper ( StaticMapper ( value ) ) [EOL] stamp ( story ) [EOL] [EOL] assert value == story . meta [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.FlavorStamper$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.FlavorStamper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.FlavorStamper$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.FlavorStamper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Literal , Any , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from collections import OrderedDict [EOL] from unittest . mock import patch , Mock [EOL] [EOL] import blinker [EOL] import pytest [EOL] [EOL] from fimfarchive . signals import ( Signal , SignalBinder , SignalSender , SignalReceiver ) [EOL] [EOL] [EOL] @ pytest . fixture def params ( ) : [EOL] [docstring] [EOL] data = ( ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ) [EOL] [EOL] return OrderedDict ( data ) [EOL] [EOL] [EOL] @ pytest . fixture def signal ( params ) : [EOL] [docstring] [EOL] return Signal ( * params . keys ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture def sender ( signal ) : [EOL] [docstring] [EOL] class Sender ( SignalSender ) : [EOL] on_signal = signal [EOL] [EOL] return Sender ( ) [EOL] [EOL] [EOL] @ pytest . fixture def receiver ( sender ) : [EOL] [docstring] [EOL] class Receiver ( SignalReceiver ) : [EOL] on_signal = Mock ( [string] ) [EOL] [EOL] with Receiver ( sender ) as receiver : [EOL] yield receiver [EOL] [EOL] [EOL] @ pytest . fixture def binder ( sender ) : [EOL] [docstring] [EOL] return sender . on_signal [EOL] [EOL] [EOL] class TestSignal : [EOL] [docstring] [EOL] [EOL] def test_reserved_value_names ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] Signal ( [string] ) [EOL] [EOL] def test_send_unbound_signal ( self , params , signal ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] signal ( * params . values ( ) ) [EOL] [EOL] def test_parameter_mapping ( self , params , signal , sender ) : [EOL] [docstring] [EOL] with patch . object ( blinker . Signal , [string] ) as m : [EOL] signal . send ( sender , * params . values ( ) ) [EOL] m . assert_called_once_with ( sender , ** params ) [EOL] [EOL] def test_parameter_overflow ( self , params , signal , sender ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] signal . send ( sender , * params . values ( ) , [string] ) [EOL] [EOL] def test_duplicate_parameter ( self , params , signal , sender ) : [EOL] [docstring] [EOL] duplicate = dict ( tuple ( params . items ( ) ) [ : [number] ] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] signal . send ( sender , * params . values ( ) , ** duplicate ) [EOL] [EOL] [EOL] class TestSignalBinder : [EOL] [docstring] [EOL] [EOL] def test_send ( self , params , sender , binder ) : [EOL] [docstring] [EOL] with patch . object ( Signal , [string] ) as m : [EOL] binder ( * params . values ( ) ) [EOL] m . assert_called_once_with ( sender , * params . values ( ) ) [EOL] [EOL] [EOL] class TestSignalSender : [EOL] [docstring] [EOL] [EOL] def test_bind ( self , signal , sender , binder ) : [EOL] [docstring] [EOL] cls = type ( sender ) [EOL] [EOL] assert isinstance ( cls . on_signal , Signal ) [EOL] assert isinstance ( sender . on_signal , SignalBinder ) [EOL] [EOL] assert signal == cls . on_signal [EOL] assert binder == sender . on_signal [EOL] [EOL] def test_send ( self , params , sender ) : [EOL] [docstring] [EOL] with patch . object ( Signal , [string] ) as m : [EOL] sender . on_signal ( * params . values ( ) ) [EOL] m . assert_called_once_with ( sender , * params . values ( ) ) [EOL] [EOL] [EOL] class TestSignalReceiver : [EOL] [docstring] [EOL] [EOL] def test_connect ( self , signal , receiver ) : [EOL] [docstring] [EOL] assert receiver . on_signal in signal . receivers [EOL] [EOL] def test_send ( self , params , sender , receiver ) : [EOL] [docstring] [EOL] sender . on_signal ( * params . values ( ) ) [EOL] receiver . on_signal . assert_called_once_with ( sender , ** params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . exceptions import FimfarchiveError [EOL] [EOL] [EOL] KEY = [number] [EOL] [EOL] [EOL] class TestStory : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def meta ( self ) : [EOL] [docstring] [EOL] return { [string] : KEY } [EOL] [EOL] @ pytest . fixture def data ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def test_init ( self , fetcher , meta , data ) : [EOL] [docstring] [EOL] story = Story ( KEY , fetcher , meta , data ) [EOL] [EOL] assert story . key == KEY [EOL] assert story . fetcher == fetcher [EOL] assert story . has_meta and story . meta == meta [EOL] assert story . has_data and story . data == data [EOL] [EOL] def test_init_with_fetcher_only ( self , fetcher ) : [EOL] [docstring] [EOL] story = Story ( KEY , fetcher ) [EOL] [EOL] assert story . key == KEY [EOL] assert story . fetcher == fetcher [EOL] [EOL] def test_init_with_meta_and_data_only ( self , meta , data ) : [EOL] [docstring] [EOL] story = Story ( KEY , None , meta , data ) [EOL] [EOL] assert story . key == KEY [EOL] assert story . has_data and story . data == data [EOL] assert story . has_meta and story . meta == meta [EOL] [EOL] def test_init_without_fetcher_nor_meta ( self , data ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] Story ( KEY , None , None , data ) [EOL] [EOL] def test_init_without_fetcher_nor_data ( self , meta ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] Story ( KEY , None , meta , None ) [EOL] [EOL] def test_init_without_fetcher_nor_both ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] Story ( KEY , None ) [EOL] [EOL] def test_fetch_meta_from_fetcher ( self , fetcher , meta , data ) : [EOL] [docstring] [EOL] fetcher . fetch_meta . return_value = meta [EOL] story = Story ( KEY , fetcher , None , data ) [EOL] [EOL] assert not story . has_meta [EOL] fetcher . fetch_meta . assert_not_called ( ) [EOL] assert story . meta == meta [EOL] assert story . has_meta [EOL] assert story . meta == meta [EOL] fetcher . fetch_meta . assert_called_once_with ( KEY ) [EOL] [EOL] def test_fetch_data_from_fetcher ( self , fetcher , meta , data ) : [EOL] [docstring] [EOL] fetcher . fetch_data . return_value = data [EOL] story = Story ( KEY , fetcher , meta , None ) [EOL] [EOL] assert not story . has_data [EOL] fetcher . fetch_data . assert_not_called ( ) [EOL] assert story . data == data [EOL] assert story . has_data [EOL] assert story . data == data [EOL] fetcher . fetch_data . assert_called_once_with ( KEY ) [EOL] [EOL] def test_meta_not_fetched_unless_necessary ( self , fetcher , meta ) : [EOL] [docstring] [EOL] story = Story ( KEY , fetcher , meta , None ) [EOL] [EOL] assert story . has_meta and story . meta == meta [EOL] fetcher . fetch_meta . assert_not_called ( ) [EOL] [EOL] def test_data_not_fetched_unless_necessary ( self , fetcher , data ) : [EOL] [docstring] [EOL] story = Story ( KEY , fetcher , None , data ) [EOL] [EOL] assert story . has_data and story . data == data [EOL] fetcher . fetch_data . assert_not_called ( ) [EOL] [EOL] def test_is_fetched ( self , fetcher , meta , data ) : [EOL] [docstring] [EOL] fetcher . fetch_meta . return_value = meta [EOL] fetcher . fetch_data . return_value = data [EOL] story = Story ( KEY , fetcher ) [EOL] [EOL] assert not story . is_fetched [EOL] assert story . meta == meta [EOL] assert not story . is_fetched [EOL] assert story . data == data [EOL] assert story . is_fetched [EOL] [EOL] def test_raises_fetch_meta_exception ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . fetch_meta . side_effect = FimfarchiveError ( ) [EOL] story = Story ( KEY , fetcher ) [EOL] [EOL] assert not story . has_meta [EOL] [EOL] with pytest . raises ( FimfarchiveError ) : [EOL] story . meta [EOL] [EOL] assert not story . has_meta [EOL] [EOL] def test_raises_fetch_data_exception ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . fetch_data . side_effect = FimfarchiveError ( ) [EOL] story = Story ( KEY , fetcher ) [EOL] [EOL] assert not story . has_data [EOL] [EOL] with pytest . raises ( FimfarchiveError ) : [EOL] story . data [EOL] [EOL] assert not story . has_data [EOL] [EOL] def test_flavors_are_copied ( self , fetcher , flavor ) : [EOL] [docstring] [EOL] flavors = { flavor . A } [EOL] story = Story ( KEY , fetcher , flavors = flavors ) [EOL] story . flavors . remove ( flavor . A ) [EOL] [EOL] assert story . flavors is not flavors [EOL] assert story . flavors == set ( ) [EOL] assert flavors == { flavor . A } [EOL] [EOL] def test_flavors_are_stored_in_set ( self , fetcher , flavor ) : [EOL] [docstring] [EOL] flavors = [ flavor . A ] [EOL] story = Story ( KEY , fetcher , flavors = flavors ) [EOL] [EOL] assert story . flavors is not flavors [EOL] assert story . flavors == { flavor . A } [EOL] assert type ( story . flavors ) == set [EOL] [EOL] def test_merge_without_parameters ( self , story ) : [EOL] [docstring] [EOL] merge = story . merge ( ) [EOL] [EOL] assert merge is not story [EOL] assert merge . data is story . data [EOL] assert merge . meta is story . meta [EOL] [EOL] for k , v in vars ( story ) . items ( ) : [EOL] assert getattr ( merge , k ) == v [EOL] [EOL] def test_merge_with_parameters ( self , story ) : [EOL] [docstring] [EOL] meta = dict ( story . meta ) [EOL] merge = story . merge ( meta = meta ) [EOL] [EOL] assert meta is not story . meta [EOL] assert meta is merge . meta [EOL] [EOL] def test_merge_with_invalid_state ( self , story ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] story . merge ( fetcher = None , meta = None ) [EOL] [EOL] def test_merge_with_invalid_arguments ( self , story ) : [EOL] [docstring] [EOL] with pytest . raises ( TypeError ) : [EOL] story . merge ( alpaca = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.set$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 $typing.set$ 0 $typing.set$ 0 0 $fimfarchive.stories.Story$ 0 $typing.set$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.set$ 0 0 $typing.set$ 0 0 $fimfarchive.stories.Story$ 0 $typing.set$ 0 0 0 0 0 0 $typing.set$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $builtins.int$ 0 0 0 $typing.list$ 0 $typing.list$ 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.list$ 0 0 $typing.list$ 0 0 $fimfarchive.stories.Story$ 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Union , Optional [EOL] import io [EOL] import typing [EOL] import builtins [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import os [EOL] from io import BytesIO [EOL] from pathlib import Path [EOL] from typing import Any , Dict [EOL] from unittest . mock import patch , MagicMock , PropertyMock [EOL] from zipfile import ZipFile [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError [EOL] from fimfarchive . flavors import DataFormat , MetaFormat [EOL] from fimfarchive . mappers import ( DataFormatMapper , MetaFormatMapper , StaticMapper , StoryDateMapper , StoryPathMapper , StorySlugMapper , ) [EOL] from fimfarchive . stories import Story [EOL] [EOL] [EOL] CHAPTERS = [string] [EOL] MODIFIED = [string] [EOL] [EOL] [EOL] class TestStaticMapper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def value ( self ) : [EOL] [docstring] [EOL] return object ( ) [EOL] [EOL] def test_value ( self , story , value ) : [EOL] [docstring] [EOL] mapper = StaticMapper ( value ) [EOL] assert mapper ( story ) is value [EOL] [EOL] [EOL] class TestStoryDateMapper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def mapper ( self ) : [EOL] [docstring] [EOL] return StoryDateMapper ( ) [EOL] [EOL] def merge ( self , story , meta ) : [EOL] [docstring] [EOL] return Story ( key = story . key , fetcher = None , meta = meta , data = story . data , flavors = story . flavors , ) [EOL] [EOL] def test_missing_story ( self , mapper ) : [EOL] [docstring] [EOL] assert mapper ( None ) is None [EOL] [EOL] def test_invalid_story ( self , mapper , story ) : [EOL] [docstring] [EOL] with patch . object ( Story , [string] , new_callable = PropertyMock ) as m : [EOL] m . side_effect = InvalidStoryError [EOL] [EOL] assert mapper ( story ) is None [EOL] assert m . called_once_with ( story ) [EOL] [EOL] def test_empty_meta ( self , mapper , story ) : [EOL] [docstring] [EOL] story = story . merge ( meta = dict ( ) ) [EOL] [EOL] assert mapper ( story ) is None [EOL] [EOL] def test_meta_without_dates ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { CHAPTERS : [ dict ( ) , dict ( ) , dict ( ) , ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) is None [EOL] [EOL] def test_meta_without_chapters ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_none_chapters ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , CHAPTERS : None , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_empty_chapters ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , CHAPTERS : [ ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_only_chapter_dates ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { CHAPTERS : [ { MODIFIED : [number] } , { MODIFIED : [number] } , { MODIFIED : [number] } , ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_only_story_date ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , CHAPTERS : [ dict ( ) , dict ( ) , dict ( ) , ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_latest_chapter_date ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , CHAPTERS : [ { MODIFIED : [number] } , { MODIFIED : [number] } , { MODIFIED : [number] } , ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_latest_story_date ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , CHAPTERS : [ { MODIFIED : [number] } , { MODIFIED : [number] } , { MODIFIED : [number] } , ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] def test_meta_with_both_latest ( self , mapper , story ) : [EOL] [docstring] [EOL] meta = { MODIFIED : [number] , CHAPTERS : [ { MODIFIED : [number] } , { MODIFIED : [number] } , { MODIFIED : [number] } , ] , } [EOL] [EOL] story = story . merge ( meta = meta ) [EOL] [EOL] assert mapper ( story ) . timestamp == [number] [EOL] [EOL] [EOL] class TestStoryPathMapper : [EOL] [docstring] [EOL] [EOL] def test_joins_paths ( self , story ) : [EOL] [docstring] [EOL] directory = os . path . join ( [string] , [string] ) [EOL] path = os . path . join ( directory , str ( story . key ) ) [EOL] [EOL] mapper = StoryPathMapper ( directory ) [EOL] [EOL] assert mapper ( story ) == Path ( path ) [EOL] [EOL] def test_casts_values ( self , tmpdir , story ) : [EOL] [docstring] [EOL] mapper = StoryPathMapper ( [string] ) [EOL] [EOL] story . key = MagicMock ( ) [EOL] story . key . __str__ . return_value = [string] [EOL] [EOL] assert mapper ( story ) == Path ( [string] , [string] ) [EOL] assert story . key . __str__ . called_once_with ( ) [EOL] [EOL] [EOL] class TestStorySlugMapper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def mapper ( self ) : [EOL] [docstring] [EOL] return StorySlugMapper ( ) [EOL] [EOL] @ pytest . fixture def story ( self , story ) : [EOL] [docstring] [EOL] meta = { [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [string] , } , } [EOL] [EOL] return story . merge ( meta = meta , flavors = [ DataFormat . EPUB ] ) [EOL] [EOL] def test_mapping ( self , mapper , story ) : [EOL] [docstring] [EOL] assert mapper ( story ) == [string] [EOL] [EOL] def test_custom_mapping ( self , story ) : [EOL] [docstring] [EOL] mapper = StorySlugMapper ( [string] ) [EOL] [EOL] assert mapper ( story ) == [string] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] * [number] , ( [string] * [number] ) [ : - [number] ] ) , ( [string] * [number] , [string] ) , ( None , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) ) def test_slugify ( self , mapper , text , result ) : [EOL] [docstring] [EOL] assert mapper . slugify ( text ) == result [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [number] , [string] , [string] ) , ( [number] , None , [string] ) , ( [number] , [string] , [string] ) , ) ) def test_join ( self , mapper , key , slug , result ) : [EOL] [docstring] [EOL] assert mapper . join ( key , slug ) == result [EOL] [EOL] def test_join_with_negative_key ( self , mapper ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] mapper . join ( [string] , [string] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) ) def test_group ( self , mapper , slug , result ) : [EOL] [docstring] [EOL] assert mapper . group ( slug ) == result [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { MetaFormat . BETA , DataFormat . EPUB } , [string] ) , ( { DataFormat . EPUB } , [string] ) , ( { DataFormat . HTML } , [string] ) , ( { MetaFormat . BETA } , [string] ) , ( { } , [string] ) , ) ) def test_classify ( self , mapper , story , flavors , result ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = flavors ) [EOL] [EOL] assert mapper . classify ( story ) == result [EOL] [EOL] def test_map_with_long_template ( self , story ) : [EOL] [docstring] [EOL] mapper = StorySlugMapper ( [string] * [number] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] mapper ( story ) [EOL] [EOL] [EOL] class TestMetaFormatMapper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def mapper ( self ) : [EOL] [docstring] [EOL] return MetaFormatMapper ( ) [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] , [string] ] ) def alpha ( self , request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] , [string] ] ) def beta ( self , request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] def merge ( self , story , * keys ) : [EOL] [docstring] [EOL] meta = { key : i for i , key in enumerate ( keys , [number] ) } [EOL] return story . merge ( meta = meta ) [EOL] [EOL] def test_alpha_format ( self , mapper , story , alpha ) : [EOL] [docstring] [EOL] story = self . merge ( story , alpha , [string] ) [EOL] assert mapper ( story ) is MetaFormat . ALPHA [EOL] [EOL] def test_beta_format ( self , mapper , story , beta ) : [EOL] [docstring] [EOL] story = self . merge ( story , beta , [string] ) [EOL] assert mapper ( story ) is MetaFormat . BETA [EOL] [EOL] def test_conflict ( self , mapper , story , alpha , beta ) : [EOL] [docstring] [EOL] story = self . merge ( story , alpha , beta ) [EOL] assert mapper ( story ) is None [EOL] [EOL] def test_existing_flavor ( self , mapper , story , beta ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ MetaFormat . ALPHA ] ) [EOL] story = self . merge ( story , beta , [string] ) [EOL] [EOL] assert mapper ( story ) is MetaFormat . ALPHA [EOL] [EOL] [EOL] class TestDataFormatMapper : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def mapper ( self ) : [EOL] [docstring] [EOL] return DataFormatMapper ( ) [EOL] [EOL] def zip ( self , names ) : [EOL] [docstring] [EOL] data = BytesIO ( ) [EOL] [EOL] with ZipFile ( data , [string] ) as zobj : [EOL] for name in names : [EOL] zobj . writestr ( name , name ) [EOL] [EOL] return data . getvalue ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , ] ) def test_json_mapping ( self , mapper , story , data ) : [EOL] [docstring] [EOL] story = story . merge ( data = data , flavors = [ ] ) [EOL] [EOL] assert DataFormat . JSON is mapper ( story ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , ] ) def test_fpub_mapping ( self , mapper , story , files ) : [EOL] [docstring] [EOL] story = story . merge ( data = self . zip ( files ) , flavors = [ ] ) [EOL] [EOL] assert DataFormat . FPUB is mapper ( story ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , ] ) def test_epub_mapping ( self , mapper , story , files ) : [EOL] [docstring] [EOL] story = story . merge ( data = self . zip ( files ) , flavors = [ ] ) [EOL] [EOL] assert DataFormat . EPUB is mapper ( story ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ DataFormat . EPUB , DataFormat . JSON , ] ) def test_included_mapping ( self , mapper , story , fmt ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ fmt ] ) [EOL] [EOL] assert fmt is mapper ( story ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , ] ) def test_unknown_raw_mapping ( self , mapper , story , data ) : [EOL] [docstring] [EOL] story = story . merge ( data = data , flavors = [ ] ) [EOL] [EOL] assert None is mapper ( story ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ ] , [ [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , ] ) def test_unknown_zip_mapping ( self , mapper , story , files ) : [EOL] [docstring] [EOL] story = story . merge ( data = self . zip ( files ) , flavors = [ ] ) [EOL] [EOL] assert None is mapper ( story ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StaticMapper[typing.Any]$ 0 0 0 0 0 0 0 $fimfarchive.mappers.StaticMapper[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.int]]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.int]]]$ 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.int]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[typing.Any,typing.Any]],builtins.int]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[typing.Any,typing.Any]],builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[typing.Any,typing.Any]],builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.int]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 $builtins.str$ 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StorySlugMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StorySlugMapper$ 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StorySlugMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StorySlugMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StorySlugMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Dict [EOL] import fimfarchive [EOL] import typing [EOL] import io [EOL] import functools [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] import os [EOL] from functools import partial [EOL] from io import BytesIO [EOL] from pathlib import Path [EOL] from zipfile import ZipFile [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . flavors import DataFormat [EOL] from fimfarchive . mappers import StoryPathMapper , StorySlugMapper [EOL] from fimfarchive . stampers import PathStamper [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . writers import DirectoryWriter , FimfarchiveWriter [EOL] [EOL] [EOL] class TestDirectoryWriter : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def mapper ( self , tmpdir ) : [EOL] [docstring] [EOL] return StoryPathMapper ( tmpdir ) [EOL] [EOL] def test_story_meta_is_written ( self , story , mapper ) : [EOL] [docstring] [EOL] writer = DirectoryWriter ( meta_path = mapper ) [EOL] writer . write ( story ) [EOL] [EOL] with open ( mapper ( story ) , [string] ) as fobj : [EOL] assert story . meta == json . load ( fobj ) [EOL] [EOL] def test_story_data_is_written ( self , story , mapper ) : [EOL] [docstring] [EOL] writer = DirectoryWriter ( data_path = mapper ) [EOL] writer . write ( story ) [EOL] [EOL] with open ( mapper ( story ) , [string] ) as fobj : [EOL] assert story . data == fobj . read ( ) [EOL] [EOL] def test_string_paths_become_mappers ( self , tmpdir ) : [EOL] [docstring] [EOL] writer = DirectoryWriter ( meta_path = [string] , data_path = [string] ) [EOL] [EOL] assert isinstance ( writer . meta_path , StoryPathMapper ) [EOL] assert isinstance ( writer . data_path , StoryPathMapper ) [EOL] [EOL] def test_rejects_integer_path ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( TypeError ) : [EOL] DirectoryWriter ( meta_path = [number] ) [comment] [EOL] [EOL] def test_parent_directory_creation ( self , story , tmpdir ) : [EOL] [docstring] [EOL] directory = str ( tmpdir . join ( [string] ) ) [EOL] [EOL] writer = DirectoryWriter ( meta_path = directory ) [EOL] writer . write ( story ) [EOL] [EOL] assert os . path . isdir ( directory ) [EOL] [EOL] def test_disable_directory_creation ( self , story , tmpdir ) : [EOL] [docstring] [EOL] directory = str ( tmpdir . join ( [string] ) ) [EOL] [EOL] writer = DirectoryWriter ( meta_path = directory , make_dirs = False ) [EOL] [EOL] with pytest . raises ( FileNotFoundError ) : [EOL] writer . write ( story ) [EOL] [EOL] def test_refuse_meta_overwrite ( self , story , mapper ) : [EOL] [docstring] [EOL] writer = DirectoryWriter ( meta_path = mapper ) [EOL] [EOL] with open ( mapper ( story ) , [string] ) : [EOL] pass [EOL] [EOL] with pytest . raises ( FileExistsError ) : [EOL] writer . write ( story ) [EOL] [EOL] def test_refuse_data_overwrite ( self , story , mapper ) : [EOL] [docstring] [EOL] writer = DirectoryWriter ( data_path = mapper ) [EOL] [EOL] with open ( mapper ( story ) , [string] ) : [EOL] pass [EOL] [EOL] with pytest . raises ( FileExistsError ) : [EOL] writer . write ( story ) [EOL] [EOL] def test_overwrites_when_enabled ( self , story , tmpdir ) : [EOL] [docstring] [EOL] meta_path = StoryPathMapper ( tmpdir . mkdir ( [string] ) ) [EOL] data_path = StoryPathMapper ( tmpdir . mkdir ( [string] ) ) [EOL] [EOL] writer = DirectoryWriter ( meta_path = meta_path , data_path = data_path , overwrite = True , ) [EOL] [EOL] with open ( meta_path ( story ) , [string] ) : [EOL] pass [EOL] [EOL] with open ( data_path ( story ) , [string] ) : [EOL] pass [EOL] [EOL] writer . write ( story ) [EOL] [EOL] with open ( meta_path ( story ) , [string] ) as meta_stream : [EOL] assert story . meta == json . load ( meta_stream ) [EOL] [EOL] with open ( data_path ( story ) , [string] ) as data_stream : [EOL] assert story . data == data_stream . read ( ) [EOL] [EOL] def test_current_directory_check ( self , story ) : [EOL] [docstring] [EOL] writer = DirectoryWriter ( ) [EOL] writer . check_directory ( Path ( [string] ) ) [EOL] [EOL] [EOL] class TestFimfarchiveWriter : [EOL] [docstring] [EOL] [EOL] def story ( self , key , title , author , name ) : [EOL] [docstring] [EOL] stream = BytesIO ( ) [EOL] [EOL] with ZipFile ( stream , [string] ) as zobj : [EOL] zobj . writestr ( [string] , [string] ) [EOL] [EOL] meta = { [string] : key , [string] : title , [string] : { [string] : author , [string] : name , } , } [EOL] [EOL] return Story ( key = key , fetcher = None , meta = meta , data = stream . getvalue ( ) , flavors = [ DataFormat . EPUB ] , ) [EOL] [EOL] @ pytest . fixture def stories ( self ) : [EOL] [docstring] [EOL] return ( self . story ( [number] , [string] , [number] , [string] ) , self . story ( [number] , [string] , [number] , [string] ) , ) [EOL] [EOL] @ pytest . fixture def extras ( self ) : [EOL] [docstring] [EOL] return ( ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] @ pytest . fixture def archive ( self , tmpdir , stories , extras ) : [EOL] [docstring] [EOL] archive = Path ( tmpdir ) / [string] [EOL] [EOL] with FimfarchiveWriter ( archive , extras ) as writer : [EOL] for story in stories : [EOL] writer . write ( story ) [EOL] [EOL] return ZipFile ( BytesIO ( archive . read_bytes ( ) ) ) [EOL] [EOL] def test_meta ( self , stories , archive ) : [EOL] [docstring] [EOL] stamp = PathStamper ( StorySlugMapper ( ) ) [EOL] [EOL] for story in stories : [EOL] stamp ( story ) [EOL] [EOL] dumps = partial ( json . dumps , ensure_ascii = False , sort_keys = True ) [EOL] first , second = tuple ( dumps ( story . meta ) for story in stories ) [EOL] raw = f' [string] { first } [string] { second } [string] ' [EOL] [EOL] assert json . loads ( archive . read ( [string] ) . decode ( ) ) [EOL] assert raw . encode ( ) == archive . read ( [string] ) [EOL] [EOL] def test_data ( self , stories , archive ) : [EOL] [docstring] [EOL] index = json . loads ( archive . read ( [string] ) . decode ( ) ) [EOL] [EOL] for story in stories : [EOL] data = story . data [EOL] meta = index [ str ( story . key ) ] [EOL] path = meta [ [string] ] [ [string] ] [EOL] [EOL] assert data == archive . read ( path ) [EOL] [EOL] def test_extras ( self , extras , archive ) : [EOL] [docstring] [EOL] for name , data in extras : [EOL] assert data == archive . read ( name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 $typing.Any$ 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 $fimfarchive.mappers.StoryPathMapper$ 0 $fimfarchive.mappers.StoryPathMapper$ 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.mappers.StoryPathMapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 $fimfarchive.writers.DirectoryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stampers.PathStamper$ 0 0 0 0 0 $functools.partial[builtins.str]$ 0 0 0 0 0 $functools.partial[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import tests [EOL] import builtins [EOL] import fimfarchive [EOL] import typing [EOL] import io [EOL] import zipfile [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from io import BytesIO [EOL] from typing import Any , Dict , List [EOL] from unittest . mock import patch , MagicMock [EOL] from zipfile import ZipFile [EOL] [EOL] import arrow [EOL] import pytest [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError , StorySourceError [EOL] from fimfarchive . fetchers import fimfarchive , Fetcher , FimfarchiveFetcher [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import JayWalker [EOL] [EOL] [EOL] VALID_STORY_KEY = [number] [EOL] INVALID_STORY_KEY = [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def data ( ) : [EOL] [docstring] [EOL] path = f'{ __file__ [ : - [number] ] } [string] ' [EOL] [EOL] with open ( path , [string] ) as fobj : [EOL] return json . load ( fobj ) [EOL] [EOL] [EOL] class Redactor ( JayWalker ) : [EOL] [docstring] [EOL] [EOL] def handle ( self , data , key , value ) : [EOL] if str ( key ) . endswith ( [string] ) : [EOL] data [ key ] = [string] [EOL] elif key == [string] : [EOL] data [ key ] = [string] [EOL] else : [EOL] self . walk ( value ) [EOL] [EOL] [EOL] class FimfarchiveFetcherSampler : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , fetcher , * keys ) : [EOL] [docstring] [EOL] self . redactor = Redactor ( ) [EOL] self . stories = [ self . sample ( fetcher , key ) for key in keys ] [EOL] [EOL] def sample ( self , fetcher , key ) : [EOL] [docstring] [EOL] story = fetcher . fetch ( key ) [EOL] story = story . merge ( data = [string] ) [EOL] self . redactor . walk ( story . meta ) [EOL] [EOL] return story [EOL] [EOL] @ property def files ( self ) : [EOL] [docstring] [EOL] files = [ ] [EOL] [EOL] for story in self . stories : [EOL] files . append ( { [string] : story . meta [ [string] ] [ [string] ] , [string] : story . data . decode ( ) , } ) [EOL] [EOL] return files [EOL] [EOL] @ property def about ( self ) : [EOL] [docstring] [EOL] today = arrow . utcnow ( ) [EOL] fmt = [string] [EOL] [EOL] return { [string] : today . shift ( days = - [number] ) . format ( fmt ) , [string] : today . shift ( days = - [number] ) . format ( fmt ) , [string] : today . shift ( days = - [number] ) . format ( fmt ) , } [EOL] [EOL] @ property def index ( self ) : [EOL] [docstring] [EOL] return { story . key : story . meta for story in self . stories } [EOL] [EOL] @ property def archive ( self ) : [EOL] [docstring] [EOL] return { [string] : self . about , [string] : self . files , [string] : self . index , } [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return json . dumps ( { [string] : self . archive } , ensure_ascii = False , sort_keys = True , indent = [number] , ) [EOL] [EOL] [EOL] def serialize ( obj ) : [EOL] [docstring] [EOL] entries = [ ] [EOL] [EOL] for key , value in obj . items ( ) : [EOL] data = json . dumps ( value , sort_keys = True ) [EOL] entries . append ( f' [string] { key } [string] { data }' ) [EOL] [EOL] joined = [string] . join ( entries ) [EOL] output = [string] . join ( ( [string] , joined , [string] , [string] ) ) [EOL] [EOL] return output [EOL] [EOL] [EOL] class PoolMock ( MagicMock ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def imap ( func , iterable , chunksize ) : [EOL] yield from map ( func , iterable ) [EOL] [EOL] [EOL] class TestFimfarchiveFetcher : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def archive ( self , data ) : [EOL] [docstring] [EOL] stream = BytesIO ( ) [EOL] [EOL] zobj = ZipFile ( stream , [string] ) [EOL] archive = data [ [string] ] [EOL] [EOL] for entry in archive [ [string] ] : [EOL] zobj . writestr ( entry [ [string] ] , entry [ [string] ] ) [EOL] [EOL] zobj . writestr ( [string] , [string] ) [EOL] zobj . writestr ( [string] , serialize ( archive [ [string] ] ) ) [EOL] zobj . writestr ( [string] , serialize ( archive [ [string] ] ) ) [EOL] zobj . close ( ) [EOL] [EOL] return stream [EOL] [EOL] @ pytest . fixture def pool ( self ) : [EOL] [docstring] [EOL] with patch . object ( fimfarchive , [string] , PoolMock ) as mock : [EOL] yield mock [EOL] [EOL] @ pytest . fixture ( ) def fetcher ( self , archive , pool ) : [EOL] [docstring] [EOL] with FimfarchiveFetcher ( archive ) as fetcher : [EOL] yield fetcher [EOL] [EOL] def test_closed_fetcher_raises_exception ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . close ( ) [EOL] [EOL] with pytest . raises ( StorySourceError ) : [EOL] fetcher . fetch_meta ( VALID_STORY_KEY ) [EOL] [EOL] def test_fetch_meta_for_valid_story ( self , fetcher ) : [EOL] [docstring] [EOL] meta = fetcher . fetch_meta ( VALID_STORY_KEY ) [EOL] assert meta [ [string] ] == VALID_STORY_KEY [EOL] [EOL] def test_fetch_meta_for_invalid_story ( self , fetcher ) : [EOL] [docstring] [EOL] with pytest . raises ( InvalidStoryError ) : [EOL] fetcher . fetch_meta ( INVALID_STORY_KEY ) [EOL] [EOL] def test_fetch_data_for_valid_story ( self , fetcher ) : [EOL] [docstring] [EOL] data = fetcher . fetch_data ( VALID_STORY_KEY ) [EOL] assert len ( data ) != [number] [EOL] [EOL] def test_fetch_data_for_invalid_story ( self , fetcher ) : [EOL] [docstring] [EOL] with pytest . raises ( InvalidStoryError ) : [EOL] fetcher . fetch_data ( INVALID_STORY_KEY ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) def test_close_when_missing_attribute ( self , fetcher , attr ) : [EOL] [docstring] [EOL] delattr ( fetcher , attr ) [EOL] fetcher . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $fimfarchive.fetchers.Fetcher$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $tests.fetchers.test_fimfarchive.Redactor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.Fetcher$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.fetchers.Fetcher$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $fimfarchive.fetchers.Fetcher$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 $io.BytesIO$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from unittest . mock import MagicMock [EOL] [EOL] [EOL] VALID_STORY_KEY = [number] [EOL] [EOL] [EOL] class TestFetcher : [EOL] [docstring] [EOL] [EOL] def test_fetch_with_prefetch_meta ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . fetch ( VALID_STORY_KEY , prefetch_meta = True ) [EOL] fetcher . fetch_meta . assert_called_once_with ( VALID_STORY_KEY ) [EOL] [EOL] def test_fetch_without_prefetch_meta ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . fetch ( VALID_STORY_KEY , prefetch_meta = False ) [EOL] fetcher . fetch_meta . assert_not_called ( ) [EOL] [EOL] def test_fetch_with_prefetch_data ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . fetch ( VALID_STORY_KEY , prefetch_data = True ) [EOL] fetcher . fetch_data . assert_called_once_with ( VALID_STORY_KEY ) [EOL] [EOL] def test_fetch_without_prefetch_data ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . fetch ( VALID_STORY_KEY , prefetch_data = False ) [EOL] fetcher . fetch_data . assert_not_called ( ) [EOL] [EOL] def test_fetch_with_default_prefetch ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . prefetch_meta = True [EOL] fetcher . prefetch_data = True [EOL] [EOL] fetcher . fetch ( VALID_STORY_KEY ) [EOL] [EOL] fetcher . fetch_meta . assert_called_once_with ( VALID_STORY_KEY ) [EOL] fetcher . fetch_data . assert_called_once_with ( VALID_STORY_KEY ) [EOL] [EOL] def test_fetch_without_default_prefetch ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . prefetch_meta = False [EOL] fetcher . prefetch_data = False [EOL] [EOL] fetcher . fetch ( VALID_STORY_KEY ) [EOL] [EOL] fetcher . fetch_meta . assert_not_called ( ) [EOL] fetcher . fetch_data . assert_not_called ( ) [EOL] [EOL] def test_close_is_called_on_exit ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . close = MagicMock ( method = [string] ) [EOL] [EOL] with fetcher : [EOL] pass [EOL] [EOL] fetcher . close . assert_called_once_with ( ) [EOL] [EOL] def test_empty_flavors_are_passed_to_story ( self , fetcher ) : [EOL] [docstring] [EOL] fetcher . flavors = set ( ) [EOL] story = fetcher . fetch ( VALID_STORY_KEY ) [EOL] assert story . flavors == set ( ) [EOL] [EOL] def test_custom_flavors_are_passed_to_story ( self , fetcher , flavor ) : [EOL] [docstring] [EOL] fetcher . flavors = { flavor . A } [EOL] story = fetcher . fetch ( VALID_STORY_KEY ) [EOL] assert story . flavors == { flavor . A } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union [EOL] import typing [EOL] import tests [EOL] import fimfarchive [EOL] import unittest [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from pathlib import Path [EOL] from unittest . mock import call , patch , MagicMock [EOL] [EOL] import arrow [EOL] import pytest [EOL] [EOL] from fimfarchive . tasks import build , BuildTask [EOL] from fimfarchive . utils import AUTHOR_BLACKLIST [EOL] [EOL] from . conftest import DummyConverer , DummyFetcher [EOL] [EOL] [EOL] BLACKLISTED = sorted ( AUTHOR_BLACKLIST ) [ [number] ] [EOL] [EOL] [EOL] class TestBuildTask : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def previous ( self ) : [EOL] [docstring] [EOL] fetcher = DummyFetcher ( ) [EOL] [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] [EOL] fetcher . add ( key = BLACKLISTED , date = BLACKLISTED ) [EOL] [EOL] return fetcher [EOL] [EOL] @ pytest . fixture def upcoming ( self ) : [EOL] [docstring] [EOL] fetcher = DummyFetcher ( ) [EOL] [EOL] fetcher . add ( key = [number] , date = [number] , data = None ) [EOL] fetcher . add ( key = [number] , date = [number] , data = None ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] [EOL] fetcher . add ( key = BLACKLISTED , date = BLACKLISTED + [number] ) [EOL] [EOL] return fetcher [EOL] [EOL] @ pytest . fixture def result ( self ) : [EOL] [docstring] [EOL] fetcher = DummyFetcher ( ) [EOL] [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] fetcher . add ( key = [number] , date = [number] ) [EOL] [EOL] for story in fetcher : [EOL] story . meta [ [string] ] += [number] [EOL] [EOL] return fetcher [EOL] [EOL] @ pytest . fixture def output ( self , tmp_path ) : [EOL] [docstring] [EOL] output = tmp_path / [string] [EOL] output . mkdir ( ) [EOL] [EOL] return Path ( output ) [EOL] [EOL] @ pytest . fixture def extras_data ( self ) : [EOL] [docstring] [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] @ pytest . fixture def extras_path ( self , tmp_path , extras_data ) : [EOL] [docstring] [EOL] extras = tmp_path / [string] [EOL] extras . mkdir ( ) [EOL] [EOL] for name , data in extras_data : [EOL] path = extras / name [EOL] path . write_bytes ( data ) [EOL] [EOL] return Path ( extras ) [EOL] [EOL] @ pytest . fixture def task ( self , output , upcoming , previous , extras_path ) : [EOL] [docstring] [EOL] task = BuildTask ( output = output , upcoming = upcoming , previous = previous , extras = extras_path , ) [EOL] [EOL] with patch . object ( task , [string] , DummyConverer ( ) ) : [EOL] yield task [EOL] [EOL] def test_path ( self , task , output ) : [EOL] [docstring] [EOL] date = arrow . utcnow ( ) . strftime ( [string] ) [EOL] name = f' [string] { date } [string] ' [EOL] path = output / name [EOL] [EOL] assert path . resolve ( ) == task . output . resolve ( ) [EOL] [EOL] def test_extras ( self , task , extras_data ) : [EOL] [docstring] [EOL] assert extras_data == sorted ( task . extras ) [EOL] [EOL] def test_generate ( self , task , result ) : [EOL] [docstring] [EOL] for actual , expected in zip ( task . generate ( ) , result ) : [EOL] assert expected . meta == actual . meta [EOL] assert expected . data == actual . data [EOL] [EOL] def test_run ( self , task ) : [EOL] [docstring] [EOL] writer = MagicMock ( ) [EOL] [EOL] manager = patch . object ( build , [string] , writer ) [EOL] content = patch . object ( task , [string] , return_value = [ [number] , [number] , [number] ] ) [EOL] [EOL] with manager , content : [EOL] task . run ( ) [EOL] [EOL] assert writer . mock_calls == [ call ( task . output , task . extras ) , call ( ) . __enter__ ( ) , call ( ) . __enter__ ( ) . write ( [number] ) , call ( ) . __enter__ ( ) . write ( [number] ) , call ( ) . __enter__ ( ) . write ( [number] ) , call ( ) . __exit__ ( None , None , None ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tasks.conftest.DummyFetcher$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $fimfarchive.tasks.build.BuildTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.tasks.build.BuildTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.tasks.build.BuildTask$ 0 0 0 0 0 0 0 0 0 0 $fimfarchive.tasks.build.BuildTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $unittest.mock._patch[unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 $unittest.mock._patch[typing.Union[unittest.mock.AsyncMock,unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._patch[unittest.mock.MagicMock]$ 0 $unittest.mock._patch[typing.Union[unittest.mock.AsyncMock,unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import fimfarchive [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from copy import deepcopy [EOL] from typing import Dict [EOL] [EOL] from fimfarchive . exceptions import InvalidStoryError [EOL] from fimfarchive . converters import Converter [EOL] from fimfarchive . fetchers import Fetcher [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import Empty [EOL] [EOL] [EOL] class DummyConverer ( Converter ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , story ) : [EOL] meta = deepcopy ( story . meta ) [EOL] meta [ [string] ] += [number] [EOL] [EOL] return story . merge ( meta = meta ) [EOL] [EOL] [EOL] class DummyFetcher ( Fetcher ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . stories = dict ( ) [EOL] [EOL] def add ( self , key , date , flavors = ( ) , data = Empty ) : [EOL] [docstring] [EOL] meta = { [string] : key , [string] : f' [string] { key }' , [string] : date , [string] : [number] , [string] : { [string] : key , [string] : f' [string] { key }' } , [string] : [ { [string] : key } , ] , } [EOL] [EOL] if data is Empty : [EOL] text = f' [string] { key }' [EOL] data = text . encode ( ) [EOL] [EOL] story = Story ( key = key , fetcher = self , meta = meta , data = data , flavors = flavors , ) [EOL] [EOL] self . stories [ key ] = story [EOL] [EOL] return story [EOL] [EOL] def fetch ( self , key , prefetch_meta = None , prefetch_data = None ) : [EOL] [docstring] [EOL] try : [EOL] return self . stories [ key ] [EOL] except KeyError : [EOL] raise InvalidStoryError ( ) [EOL] [EOL] def fetch_data ( self , key ) : [EOL] [docstring] [EOL] raise InvalidStoryError ( ) [EOL] [EOL] def fetch_meta ( self , key ) : [EOL] [docstring] [EOL] raise InvalidStoryError ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] for key in sorted ( self . stories . keys ( ) ) : [EOL] yield self . stories [ key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,fimfarchive.stories.Story]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from unittest . mock import MagicMock , call , patch [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . exceptions import StorySourceError [EOL] from fimfarchive . flavors import DataFormat , StorySource , UpdateStatus [EOL] from fimfarchive . selectors import RefetchSelector , UpdateSelector [EOL] from fimfarchive . tasks . update import ( UpdateTask , SUCCESS_DELAY , SKIPPED_DELAY , FAILURE_DELAY , ) [EOL] [EOL] from . conftest import DummyFetcher [EOL] [EOL] [EOL] class TestUpdateTask : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def fimfiction ( self ) : [EOL] [docstring] [EOL] return DummyFetcher ( ) [EOL] [EOL] @ pytest . fixture def fimfarchive ( self ) : [EOL] [docstring] [EOL] return DummyFetcher ( ) [EOL] [EOL] @ pytest . fixture def selector ( self ) : [EOL] [docstring] [EOL] return UpdateSelector ( ) [EOL] [EOL] @ pytest . fixture def stamper ( self ) : [EOL] [docstring] [EOL] return MagicMock ( ) [EOL] [EOL] @ pytest . fixture def archive ( self ) : [EOL] [docstring] [EOL] return { [string] : [string] } [EOL] [EOL] @ pytest . fixture def task ( self , fimfarchive , fimfiction , selector , stamper , tmpdir ) : [EOL] [docstring] [EOL] return UpdateTask ( fimfiction = fimfiction , fimfarchive = fimfarchive , selector = selector , stamper = stamper , workdir = str ( tmpdir ) , retries = [number] , skips = [number] , ) [EOL] [EOL] def verify_run ( self , task , delays ) : [EOL] [docstring] [EOL] calls = [ call ( delay ) for delay in delays ] [EOL] [EOL] with patch ( [string] ) as m : [EOL] task . run ( ) [EOL] m . assert_has_calls ( calls ) [EOL] [EOL] def verify_fetch ( self , task , target , status ) : [EOL] [docstring] [EOL] task . write = MagicMock ( side_effect = lambda story : story ) [EOL] [EOL] delays = ( SKIPPED_DELAY , SUCCESS_DELAY , SKIPPED_DELAY , SKIPPED_DELAY , ) [EOL] [EOL] self . verify_run ( task , delays ) [EOL] task . stamp . assert_called_once_with ( target ) [EOL] task . write . assert_called_once_with ( target ) [EOL] assert status in target . flavors [EOL] assert task . state [ [string] ] == [number] [EOL] [EOL] def verify_empty ( self , task , fetcher ) : [EOL] [docstring] [EOL] task . write = MagicMock ( ) [EOL] task . skip_writer . write = MagicMock ( ) [EOL] [EOL] target = fetcher . add ( key = [number] , date = [number] ) [EOL] target . meta [ [string] ] . clear ( ) [EOL] [EOL] delays = ( SKIPPED_DELAY , SKIPPED_DELAY , ) [EOL] [EOL] self . verify_run ( task , delays ) [EOL] task . stamp . assert_not_called ( ) [EOL] task . write . assert_not_called ( ) [EOL] task . skip_writer . write . assert_called_once_with ( target ) [EOL] [EOL] def verify_failure ( self , task , fetcher ) : [EOL] [docstring] [EOL] task . write = MagicMock ( side_effect = lambda story : story ) [EOL] fetcher . fetch = MagicMock ( side_effect = StorySourceError ) [EOL] [EOL] delays = ( FAILURE_DELAY , FAILURE_DELAY , ) [EOL] [EOL] self . verify_run ( task , delays ) [EOL] task . stamp . assert_not_called ( ) [EOL] task . write . assert_not_called ( ) [EOL] [EOL] def test_created_story ( self , task , fimfiction ) : [EOL] [docstring] [EOL] target = fimfiction . add ( key = [number] , date = [number] ) [EOL] [EOL] self . verify_fetch ( task , target , UpdateStatus . CREATED ) [EOL] [EOL] def test_revived_story ( self , task , fimfarchive , fimfiction , archive ) : [EOL] [docstring] [EOL] target = fimfarchive . add ( key = [number] , date = [number] ) [EOL] other = fimfiction . add ( key = [number] , date = [number] ) [EOL] target . meta [ [string] ] = archive [EOL] [EOL] target . merge = MagicMock ( return_value = target ) [EOL] self . verify_fetch ( task , target , UpdateStatus . REVIVED ) [EOL] target . merge . assert_called_once_with ( meta = other . meta ) [EOL] assert other . meta [ [string] ] is not archive [EOL] assert other . meta [ [string] ] == archive [EOL] [EOL] def test_updated_story ( self , task , fimfarchive , fimfiction , archive ) : [EOL] [docstring] [EOL] other = fimfarchive . add ( key = [number] , date = [number] ) [EOL] target = fimfiction . add ( key = [number] , date = [number] ) [EOL] other . meta [ [string] ] = archive [EOL] [EOL] self . verify_fetch ( task , target , UpdateStatus . UPDATED ) [EOL] assert target . meta [ [string] ] is not archive [EOL] assert target . meta [ [string] ] == archive [EOL] [EOL] def test_deleted_story ( self , task , fimfarchive ) : [EOL] [docstring] [EOL] target = fimfarchive . add ( key = [number] , date = [number] ) [EOL] [EOL] self . verify_fetch ( task , target , UpdateStatus . DELETED ) [EOL] [EOL] def test_cleared_story ( self , task , fimfarchive , fimfiction ) : [EOL] [docstring] [EOL] target = fimfarchive . add ( key = [number] , date = [number] ) [EOL] other = fimfiction . add ( key = [number] , date = [number] ) [EOL] other . meta [ [string] ] . clear ( ) [EOL] [EOL] self . verify_fetch ( task , target , UpdateStatus . DELETED ) [EOL] [EOL] def test_empty_fimfiction_story ( self , task , fimfiction ) : [EOL] [docstring] [EOL] self . verify_empty ( task , fimfiction ) [EOL] [EOL] def test_empty_fimfarchive_story ( self , task , fimfarchive ) : [EOL] [docstring] [EOL] self . verify_empty ( task , fimfarchive ) [EOL] [EOL] def test_fimfarchive_failure ( self , task , fimfarchive ) : [EOL] [docstring] [EOL] self . verify_failure ( task , fimfarchive ) [EOL] [EOL] def test_fimfiction_failure ( self , task , fimfiction ) : [EOL] [docstring] [EOL] self . verify_failure ( task , fimfiction ) [EOL] [EOL] def test_write_meta ( self , task , story ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ DataFormat . JSON , StorySource . FIMFARCHIVE , ] ) [EOL] [EOL] task . meta_writer . write = MagicMock ( ) [EOL] task . json_writer . write = MagicMock ( ) [EOL] [EOL] task . write ( story ) [EOL] [EOL] task . meta_writer . write . assert_called_once_with ( story ) [EOL] task . json_writer . write . assert_not_called ( ) [EOL] [EOL] def test_write_epub ( self , task , story ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ DataFormat . EPUB ] ) [EOL] task . epub_writer . write = MagicMock ( ) [EOL] [EOL] task . write ( story ) [EOL] task . epub_writer . write . assert_called_once_with ( story ) [EOL] [EOL] def test_write_html ( self , task , story ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ DataFormat . HTML ] ) [EOL] task . html_writer . write = MagicMock ( ) [EOL] [EOL] task . write ( story ) [EOL] task . html_writer . write . assert_called_once_with ( story ) [EOL] [EOL] def test_write_json ( self , task , story ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ DataFormat . JSON ] ) [EOL] task . json_writer . write = MagicMock ( ) [EOL] [EOL] task . write ( story ) [EOL] task . json_writer . write . assert_called_once_with ( story ) [EOL] [EOL] def test_write_unsupported ( self , task , story ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ DataFormat . FPUB ] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] task . write ( story ) [EOL] [EOL] def test_remote_archive ( self , task , fimfarchive , fimfiction , archive ) : [EOL] [docstring] [EOL] old = fimfarchive . add ( key = [number] , date = [number] ) [EOL] new = fimfiction . add ( key = [number] , date = [number] ) [EOL] new . meta [ [string] ] = archive [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] task . copy_archive_meta ( old , new ) [EOL] [EOL] [EOL] class TestRefetchingUpdateTask ( TestUpdateTask ) : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def selector ( self ) : [EOL] [docstring] [EOL] return RefetchSelector ( ) [EOL] [EOL] def test_revived_story ( self , task , fimfarchive , fimfiction ) : [EOL] [docstring] [EOL] fimfarchive . add ( key = [number] , date = [number] ) [EOL] target = fimfiction . add ( key = [number] , date = [number] ) [EOL] [EOL] self . verify_fetch ( task , target , UpdateStatus . UPDATED ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import List , Any , Dict , Iterator [EOL] import tests [EOL] import builtins [EOL] import fimfarchive [EOL] import typing [EOL] import io [EOL] import zipfile [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from copy import deepcopy [EOL] from io import BytesIO [EOL] from typing import Any , Dict , Iterator , List [EOL] from zipfile import ZipFile [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . converters import JsonFpubConverter [EOL] from fimfarchive . fetchers import Fimfiction2Fetcher [EOL] from fimfarchive . flavors import DataFormat , MetaFormat [EOL] from fimfarchive . stories import Story [EOL] from fimfarchive . utils import JayWalker [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def data ( ) : [EOL] [docstring] [EOL] path = f'{ __file__ [ : - [number] ] } [string] ' [EOL] [EOL] with open ( path , [string] ) as fobj : [EOL] return json . load ( fobj ) [EOL] [EOL] [EOL] class Redactor ( JayWalker ) : [EOL] [docstring] [EOL] [EOL] def handle ( self , data , key , value ) : [EOL] if str ( key ) . endswith ( [string] ) : [EOL] data [ key ] = [string] [EOL] elif key == [string] : [EOL] data [ key ] = [string] [EOL] else : [EOL] self . walk ( value ) [EOL] [EOL] [EOL] class JsonFpubConverterSampler : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , token , * keys ) : [EOL] [docstring] [EOL] self . keys = sorted ( int ( key ) for key in keys ) [EOL] self . fetcher = Fimfiction2Fetcher ( token ) [EOL] self . convert = JsonFpubConverter ( ) [EOL] self . redactor = Redactor ( ) [EOL] [EOL] def sample ( self , key ) : [EOL] [docstring] [EOL] story = self . fetcher . fetch ( key ) [EOL] redacted = self . redact ( story ) [EOL] converted = self . convert ( redacted ) [EOL] [EOL] return { [string] : int ( key ) , [string] : redacted . meta , [string] : json . loads ( redacted . data . decode ( ) ) , [string] : self . extract ( converted . data ) , } [EOL] [EOL] def redact ( self , story ) : [EOL] [docstring] [EOL] meta = deepcopy ( story . meta ) [EOL] data = json . loads ( story . data . decode ( ) ) [EOL] [EOL] self . redactor . walk ( meta ) [EOL] self . redactor . walk ( data ) [EOL] [EOL] raw_data = json . dumps ( data ) . encode ( ) [EOL] [EOL] return story . merge ( meta = meta , data = raw_data ) [EOL] [EOL] def extract ( self , data ) : [EOL] [docstring] [EOL] output = [ ] [EOL] zobj = ZipFile ( BytesIO ( data ) ) [EOL] [EOL] for info in zobj . infolist ( ) : [EOL] output . append ( { [string] : info . filename , [string] : zobj . read ( info ) . decode ( ) , } ) [EOL] [EOL] return output [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] for key in self . keys : [EOL] yield self . sample ( key ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return json . dumps ( obj = { [string] : list ( self ) } , ensure_ascii = False , sort_keys = True , indent = [number] , ) [EOL] [EOL] [EOL] class TestJsonFpubConverter : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def converter ( self ) : [EOL] [docstring] [EOL] return JsonFpubConverter ( ) [EOL] [EOL] @ pytest . fixture ( params = range ( [number] ) ) def pair ( self , request , data ) : [EOL] [docstring] [EOL] return data [ [string] ] [ request . param ] [EOL] [EOL] @ pytest . fixture def json_story ( self , pair ) : [EOL] [docstring] [EOL] return Story ( key = pair [ [string] ] , meta = deepcopy ( pair [ [string] ] ) , data = json . dumps ( pair [ [string] ] ) . encode ( ) , flavors = { MetaFormat . BETA , DataFormat . JSON } , ) [EOL] [EOL] @ pytest . fixture def fpub_story ( self , pair ) : [EOL] [docstring] [EOL] stream = BytesIO ( ) [EOL] [EOL] with ZipFile ( stream , [string] ) as zobj : [EOL] for info in pair [ [string] ] : [EOL] zobj . writestr ( info [ [string] ] , info [ [string] ] ) [EOL] [EOL] return Story ( key = pair [ [string] ] , meta = deepcopy ( pair [ [string] ] ) , data = stream . getvalue ( ) , flavors = { MetaFormat . BETA , DataFormat . FPUB } , ) [EOL] [EOL] def test_conversion ( self , converter , json_story , fpub_story ) : [EOL] [docstring] [EOL] converted = converter ( json_story ) [EOL] [EOL] exp = ZipFile ( BytesIO ( fpub_story . data ) ) [EOL] act = ZipFile ( BytesIO ( converted . data ) ) [EOL] [EOL] for einfo , ainfo in zip ( exp . infolist ( ) , act . infolist ( ) ) : [EOL] assert einfo . filename == ainfo . filename [EOL] assert exp . read ( einfo ) == act . read ( ainfo ) [EOL] [EOL] def test_mimetype ( self , converter , json_story ) : [EOL] [docstring] [EOL] converted = converter ( json_story ) [EOL] [EOL] zobj = ZipFile ( BytesIO ( converted . data ) ) [EOL] info = zobj . infolist ( ) [ [number] ] [EOL] read = zobj . read ( info ) . decode ( ) [EOL] [EOL] assert [number] == info . compress_type [EOL] assert [string] == info . filename [EOL] assert [string] == read [EOL] [EOL] def test_immutablilty ( self , converter , json_story ) : [EOL] [docstring] [EOL] clone = deepcopy ( json_story ) [EOL] converter ( json_story ) [EOL] [EOL] for attr in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] assert getattr ( clone , attr ) == getattr ( json_story , attr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.fetchers.fimfiction2.Fimfiction2Fetcher$ 0 0 0 $builtins.str$ 0 0 0 0 $fimfarchive.converters.json_fpub.JsonFpubConverter$ 0 0 0 0 0 0 0 $tests.converters.test_json_fpub.Redactor$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Any$ 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Iterator[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $zipfile.ZipInfo$ 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $zipfile.ZipFile$ 0 $builtins.str$ 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 $zipfile.ZipInfo$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] import pytest [EOL] from copy import deepcopy [EOL] [EOL] from fimfarchive . converters import LocalUtcConverter [EOL] [EOL] [EOL] class TestLocalUtcConverter : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture ( params = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , None ) , ( [string] , None ) , ( None , None ) , ] ) def date_pair ( self , request ) : [EOL] [docstring] [EOL] local , utc = request . param [EOL] [EOL] return local , utc [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) def meta_pair ( self , request , date_pair ) : [EOL] [docstring] [EOL] template = request . param [EOL] local_date , utc_date = date_pair [EOL] [EOL] local_value = json . dumps ( local_date ) [EOL] local_json = template . replace ( [string] , local_value ) [EOL] local_meta = json . loads ( local_json ) [EOL] [EOL] utc_value = json . dumps ( utc_date ) [EOL] utc_json = template . replace ( [string] , utc_value ) [EOL] utc_meta = json . loads ( utc_json ) [EOL] [EOL] return local_meta , utc_meta [EOL] [EOL] @ pytest . fixture def converter ( self ) : [EOL] [docstring] [EOL] return LocalUtcConverter ( ) [EOL] [EOL] def test_conversion ( self , converter , story , meta_pair ) : [EOL] [docstring] [EOL] local_meta , utc_meta = meta_pair [EOL] [EOL] local_story = story . merge ( meta = local_meta ) [EOL] utc_story = story . merge ( meta = utc_meta ) [EOL] [EOL] clone = deepcopy ( local_story ) [EOL] converted = converter ( local_story ) [EOL] [EOL] assert clone . meta == local_story . meta [EOL] assert utc_story . meta == converted . meta [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] import fimfarchive [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from os import urandom , write [EOL] from pathlib import Path [EOL] from subprocess import DEVNULL [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . converters import fpub_epub , FpubEpubConverter [EOL] from fimfarchive . flavors import DataFormat [EOL] [EOL] [EOL] class TestFpubEpubConverter : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def fpub ( self ) : [EOL] [docstring] [EOL] return urandom ( [number] ) [EOL] [EOL] @ pytest . fixture def epub ( self ) : [EOL] [docstring] [EOL] return urandom ( [number] ) [EOL] [EOL] @ pytest . fixture def log ( self ) : [EOL] [docstring] [EOL] return urandom ( [number] ) [EOL] [EOL] @ pytest . fixture def calibre ( self , fpub , epub , log ) : [EOL] [docstring] [EOL] def function ( * args , ** kwargs ) : [EOL] source = Path ( args [ [number] ] [ [number] ] ) [EOL] target = Path ( args [ [number] ] [ [number] ] ) [EOL] stdout = kwargs [ [string] ] [EOL] [EOL] if [number] <= stdout : [EOL] write ( stdout , log ) [EOL] [EOL] if fpub == source . read_bytes ( ) : [EOL] target . write_bytes ( epub ) [EOL] [EOL] return function [EOL] [EOL] @ pytest . fixture def proc ( self , calibre ) : [EOL] [docstring] [EOL] with patch . object ( fpub_epub , [string] ) as mock : [EOL] mock . side_effect = calibre [EOL] yield mock [EOL] [EOL] @ pytest . fixture def story ( self , story , fpub ) : [EOL] [docstring] [EOL] return story . merge ( data = fpub , flavors = [ DataFormat . FPUB ] ) [EOL] [EOL] def verify_call ( self , call , pipe ) : [EOL] [docstring] [EOL] name , args , kwargs = call [EOL] program , source , target , cover = args [ [number] ] [EOL] stdout = kwargs [ [string] ] [EOL] [EOL] assert [number] == len ( args ) [EOL] assert [number] == len ( kwargs ) [EOL] [EOL] assert [string] == program [EOL] assert [string] == Path ( source ) . name [EOL] assert [string] == Path ( target ) . name [EOL] assert [string] == cover [EOL] [EOL] assert pipe is ( DEVNULL != stdout ) [EOL] [EOL] def test_without_log ( self , story , fpub , epub , proc ) : [EOL] [docstring] [EOL] convert = FpubEpubConverter ( ) [EOL] output = convert ( story ) [EOL] calls = proc . mock_calls [EOL] [EOL] assert [number] == len ( calls ) [EOL] assert fpub == story . data [EOL] assert epub == output . data [EOL] [EOL] self . verify_call ( calls [ [number] ] , False ) [EOL] [EOL] def test_with_log ( self , tmpdir , story , fpub , epub , log , proc ) : [EOL] [docstring] [EOL] tmppath = Path ( str ( tmpdir ) ) [EOL] convert = FpubEpubConverter ( tmppath ) [EOL] logfile = tmppath / str ( story . key ) [EOL] output = convert ( story ) [EOL] calls = proc . mock_calls [EOL] [EOL] assert [number] == len ( calls ) [EOL] assert fpub == story . data [EOL] assert epub == output . data [EOL] assert log == logfile . read_bytes ( ) [EOL] [EOL] self . verify_call ( calls [ [number] ] , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.converters.fpub_epub.FpubEpubConverter$ 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $fimfarchive.converters.fpub_epub.FpubEpubConverter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $fimfarchive.converters.fpub_epub.FpubEpubConverter$ 0 0 0 $pathlib.Path$ 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 $fimfarchive.converters.fpub_epub.FpubEpubConverter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fimfarchive.stories.Story$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import json [EOL] from copy import deepcopy [EOL] from typing import Any , Dict [EOL] [EOL] import arrow [EOL] import pytest [EOL] [EOL] from fimfarchive . converters import AlphaBetaConverter [EOL] from fimfarchive . flavors import MetaFormat [EOL] [EOL] [EOL] def to_null ( data , * keys ) : [EOL] [docstring] [EOL] for key in keys : [EOL] data [ key ] = None [EOL] [EOL] [EOL] def to_utc ( data , * keys ) : [EOL] [docstring] [EOL] for key in keys : [EOL] value = data . get ( key ) [EOL] [EOL] if value is None : [EOL] continue [EOL] [EOL] time = arrow . get ( value ) . to ( [string] ) [EOL] data [ key ] = time . isoformat ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def data ( ) : [EOL] [docstring] [EOL] path = f'{ __file__ [ : - [number] ] } [string] ' [EOL] [EOL] with open ( path , [string] ) as fobj : [EOL] return json . load ( fobj ) [EOL] [EOL] [EOL] class TestAlphaBetaConverter : [EOL] [docstring] [EOL] [EOL] @ pytest . fixture def converter ( self ) : [EOL] [docstring] [EOL] return AlphaBetaConverter ( ) [EOL] [EOL] @ pytest . fixture ( params = range ( [number] ) ) def pair ( self , request , data ) : [EOL] [docstring] [EOL] return data [ [string] ] [ request . param ] [EOL] [EOL] @ pytest . fixture def alpha ( self , pair ) : [EOL] [docstring] [EOL] return deepcopy ( pair [ [string] ] ) [EOL] [EOL] @ pytest . fixture def beta ( self , pair ) : [EOL] [docstring] [EOL] return deepcopy ( pair [ [string] ] ) [EOL] [EOL] @ pytest . fixture def expected ( self , beta ) : [EOL] [docstring] [EOL] data = deepcopy ( beta ) [EOL] [EOL] data [ [string] ] = { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , } [EOL] [EOL] to_null ( data , [string] , [string] ) [EOL] to_utc ( data , [string] , [string] ) [EOL] [EOL] to_null ( data [ [string] ] , * ( [string] , [string] , [string] , [string] , [string] , [string] , ) ) [EOL] [EOL] for chapter in data [ [string] ] : [EOL] to_null ( chapter , [string] ) [EOL] to_utc ( chapter , [string] ) [EOL] [EOL] data [ [string] ] = [ tag for tag in data [ [string] ] if tag [ [string] ] in { [string] , [string] , [string] } ] [EOL] [EOL] return data [EOL] [EOL] def test_conversion ( self , converter , story , expected , alpha ) : [EOL] [docstring] [EOL] story = story . merge ( flavors = [ MetaFormat . ALPHA ] , meta = alpha ) [EOL] converted = converter ( story ) [EOL] [EOL] assert MetaFormat . BETA in converted . flavors [EOL] assert expected == converted . meta [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0
[docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , Dict [EOL] import typing [EOL] import fimfarchive [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from textwrap import dedent [EOL] from typing import Any , Dict , Set [EOL] [EOL] from fimfarchive . flavors import Flavor , MetaPurity , UpdateStatus [EOL] from fimfarchive . commands . update import StoryFormatter [EOL] [EOL] [EOL] class TestStoryFormatter ( ) : [EOL] [docstring] [EOL] [EOL] def assert_formatted_equals ( self , expected , story ) : [EOL] [docstring] [EOL] formatted = str ( StoryFormatter ( story ) ) [EOL] dedented = dedent ( expected ) . strip ( ) [EOL] [EOL] assert dedented == formatted [EOL] [EOL] def test_empty_meta ( self , story ) : [EOL] [docstring] [EOL] flavors = set ( ) [EOL] meta = dict ( ) [EOL] [EOL] expected = [string] [EOL] [EOL] story = story . merge ( meta = meta , flavors = flavors ) [EOL] self . assert_formatted_equals ( expected , story ) [EOL] [EOL] def test_old_meta ( self , story ) : [EOL] [docstring] [EOL] flavors = { UpdateStatus . CREATED , } [EOL] [EOL] meta = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ [number] ] , } [EOL] [EOL] expected = [string] [EOL] [EOL] story = story . merge ( meta = meta , flavors = flavors ) [EOL] self . assert_formatted_equals ( expected , story ) [EOL] [EOL] def test_new_meta ( self , story ) : [EOL] [docstring] [EOL] flavors = { UpdateStatus . CREATED , } [EOL] [EOL] meta = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ [number] ] , } [EOL] [EOL] expected = [string] [EOL] [EOL] story = story . merge ( meta = meta , flavors = flavors ) [EOL] self . assert_formatted_equals ( expected , story ) [EOL] [EOL] def test_edge_meta ( self , story ) : [EOL] [docstring] [EOL] flavors = { MetaPurity . DIRTY , } [EOL] [EOL] meta = { [string] : None , [string] : { } , [string] : { } , [string] : [number] , [string] : [number] , [string] : [number] , [string] : ( ) , } [EOL] [EOL] expected = [string] [EOL] [EOL] story = story . merge ( meta = meta , flavors = flavors ) [EOL] self . assert_formatted_equals ( expected , story ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 $typing.Set[fimfarchive.flavors.Flavor]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from unittest . mock import MagicMock , PropertyMock [EOL] [EOL] import pytest [EOL] [EOL] from fimfarchive . commands import Command , RootCommand [EOL] [EOL] [EOL] @ pytest . fixture def success ( ) : [EOL] [docstring] [EOL] class cls ( Command ) : [EOL] [docstring] [EOL] __call__ = MagicMock ( return_value = [number] ) [EOL] [EOL] return cls ( ) [EOL] [EOL] [EOL] @ pytest . fixture def failure ( ) : [EOL] [docstring] [EOL] class cls ( Command ) : [EOL] [docstring] [EOL] __call__ = MagicMock ( return_value = [number] ) [EOL] [EOL] return cls ( ) [EOL] [EOL] [EOL] @ pytest . fixture def root ( success , failure ) : [EOL] [docstring] [EOL] class cls ( RootCommand ) : [EOL] [docstring] [EOL] commands = { [string] : type ( success ) , [string] : type ( failure ) , } [EOL] [EOL] return cls ( ) [EOL] [EOL] [EOL] @ pytest . fixture def args ( ) : [EOL] [docstring] [EOL] return [ object ( ) for i in range ( [number] ) ] [EOL] [EOL] [EOL] class TestRootCommanad ( ) : [EOL] [docstring] [EOL] [EOL] def mock_usage ( self , cmd ) : [EOL] [docstring] [EOL] usage = PropertyMock ( ) [EOL] type ( cmd ) . usage = usage [EOL] return usage [EOL] [EOL] def test_root_usage ( self , root ) : [EOL] [docstring] [EOL] doc = root . usage [EOL] assert [string] in doc [EOL] assert [string] in doc [EOL] assert [string] not in doc [EOL] [EOL] def test_root_usage_without_commands ( self , root ) : [EOL] [docstring] [EOL] type ( root ) . commands = dict ( ) [EOL] assert root . usage . strip ( ) [EOL] [EOL] def test_root_call_without_args ( self , root , success , failure ) : [EOL] [docstring] [EOL] usage = self . mock_usage ( root ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] root ( ) [EOL] [EOL] usage . assert_called_once_with ( ) [EOL] success . __call__ . assert_not_called ( ) [EOL] failure . __call__ . assert_not_called ( ) [EOL] [EOL] def test_root_call_with_args ( self , root , success , failure , args ) : [EOL] [docstring] [EOL] usage = self . mock_usage ( root ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] root ( * args ) [EOL] [EOL] usage . assert_called_once_with ( ) [EOL] success . __call__ . assert_not_called ( ) [EOL] failure . __call__ . assert_not_called ( ) [EOL] [EOL] def test_success_usage ( self , root ) : [EOL] [docstring] [EOL] doc = root . doc ( [string] , adjust = [number] , indent = [number] ) [EOL] assert [string] == doc [EOL] [EOL] def test_success_call_without_args ( self , root , success , failure ) : [EOL] [docstring] [EOL] usage = self . mock_usage ( root ) [EOL] code = root ( [string] ) [EOL] success . __call__ . assert_called_once_with ( ) [EOL] failure . __call__ . assert_not_called ( ) [EOL] usage . assert_not_called ( ) [EOL] assert code == [number] [EOL] [EOL] def test_success_call_with_args ( self , root , success , failure , args ) : [EOL] [docstring] [EOL] usage = self . mock_usage ( root ) [EOL] code = root ( [string] , * args ) [EOL] success . __call__ . assert_called_once_with ( * args ) [EOL] failure . __call__ . assert_not_called ( ) [EOL] usage . assert_not_called ( ) [EOL] assert code == [number] [EOL] [EOL] def test_failure_usage ( self , root ) : [EOL] [docstring] [EOL] doc = root . doc ( [string] , adjust = [number] , indent = [number] ) [EOL] assert [string] == doc [EOL] [EOL] def test_failure_call_without_args ( self , root , success , failure ) : [EOL] [docstring] [EOL] usage = self . mock_usage ( root ) [EOL] code = root ( [string] ) [EOL] success . __call__ . assert_not_called ( ) [EOL] failure . __call__ . assert_called_once_with ( ) [EOL] usage . assert_not_called ( ) [EOL] assert code == [number] [EOL] [EOL] def test_failure_call_with_args ( self , root , success , failure , args ) : [EOL] [docstring] [EOL] usage = self . mock_usage ( root ) [EOL] code = root ( [string] , * args ) [EOL] success . __call__ . assert_not_called ( ) [EOL] failure . __call__ . assert_called_once_with ( * args ) [EOL] usage . assert_not_called ( ) [EOL] assert code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0