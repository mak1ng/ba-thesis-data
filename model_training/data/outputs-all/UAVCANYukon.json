[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from src . devserv . mock_server import ServerSentEvent [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] ) ] ) def test_serverevent ( event ) : [EOL] sse = ServerSentEvent ( [string] , event ) [EOL] assert sse . event == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Set [EOL] import pathlib [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] import src [EOL] [docstring] [EOL] [EOL] import errno [EOL] import os [EOL] import pathlib [EOL] import sys [EOL] import tempfile [EOL] from subprocess import call , STDOUT [EOL] from asyncio import Task , all_tasks , gather , get_event_loop , sleep [EOL] [EOL] import pyuavcan [EOL] import pyuavcan . transport . udp [EOL] [EOL] dsdl_generated_dir = pathlib . Path ( tempfile . gettempdir ( ) , [string] , f' [string] { pyuavcan . __version__ }' ) [EOL] dsdl_generated_dir . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] sys . path . insert ( [number] , str ( dsdl_generated_dir ) ) [EOL] [EOL] [comment] [EOL] print ( [string] , file = sys . stderr ) [EOL] print ( [string] , dsdl_generated_dir , file = sys . stderr ) [EOL] pyuavcan . dsdl . generate_package ( root_namespace_directory = os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) , output_directory = dsdl_generated_dir , ) [EOL] [EOL] try : [EOL] import pyuavcan . application [EOL] import uavcan . node [comment] [EOL] import uavcan . diagnostic [comment] [EOL] except ( ImportError , AttributeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] class DemoApplication : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] try : [EOL] self . _transport = pyuavcan . transport . udp . UDPTransport ( [string] ) [EOL] except OSError as ex : [EOL] if ( hasattr ( errno , [string] ) and ex . errno == errno . EADDRNOTAVAIL ) : [EOL] sys . stderr . write ( [string] ) [EOL] [EOL] [comment] [EOL] call ( [string] , shell = True , stderr = STDOUT ) [EOL] [EOL] try : [EOL] self . _transport = pyuavcan . transport . udp . UDPTransport ( [string] ) [EOL] except OSError as ex : [EOL] raise Exception ( ex ) [EOL] else : [EOL] raise [EOL] [EOL] assert self . _transport . local_node_id == [number] [EOL] [EOL] self . _node_info = uavcan . node . GetInfo_1_0 . Response ( protocol_version = uavcan . node . Version_1_0 ( * pyuavcan . UAVCAN_SPECIFICATION_VERSION ) , software_version = uavcan . node . Version_1_0 ( major = [number] , minor = [number] ) , name = [string] , ) [EOL] [EOL] self . _presentation = pyuavcan . presentation . Presentation ( self . _transport ) [EOL] self . _node = pyuavcan . application . Node ( self . _presentation , self . _node_info ) [EOL] self . _node . heartbeat_publisher . mode = uavcan . node . Heartbeat_1_0 . MODE_OPERATIONAL [EOL] self . _node . heartbeat_publisher . health = uavcan . node . Heartbeat_1_0 . HEALTH_NOMINAL [EOL] self . _node . heartbeat_publisher . vendor_specific_status_code = os . getpid ( ) & ( [number] ** min ( pyuavcan . dsdl . get_model ( uavcan . node . Heartbeat_1_0 ) [ [string] ] . data_type . bit_length_set ) - [number] ) [EOL] [EOL] self . _pub_diagnostic_record = self . _node . presentation . make_publisher_with_fixed_subject_id ( uavcan . diagnostic . Record_1_0 ) [EOL] self . _pub_diagnostic_record . priority = pyuavcan . transport . Priority . OPTIONAL [EOL] self . _pub_diagnostic_record . send_timeout = [number] [EOL] [EOL] self . _node . start ( ) [EOL] [EOL] @ property def node_started ( self ) : [EOL] return self . _node . _started [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] app = DemoApplication ( ) [EOL] [EOL] if app . node_started : [EOL] sys . stdout . write ( [string] ) [EOL] [EOL] app_tasks = all_tasks ( ) [EOL] [EOL] async def list_tasks_periodically ( ) : [EOL] [docstring] [EOL] import re [EOL] [EOL] def repr_task ( t ) : [EOL] try : [EOL] out , = re . findall ( [string] , str ( t ) ) [EOL] except ValueError : [EOL] out = str ( t ) [EOL] return out [EOL] [EOL] while True : [EOL] print ( [string] + [string] . join ( map ( repr_task , app_tasks ) ) , file = sys . stderr ) [EOL] await sleep ( [number] ) [EOL] [EOL] get_event_loop ( ) . create_task ( list_tasks_periodically ( ) ) [EOL] await gather ( * app_tasks ) [EOL] return [number] [EOL] else : [EOL] sys . stderr . write ( [string] ) [EOL] return [number] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] get_event_loop ( ) . run_until_complete ( main ( ) ) [EOL] get_event_loop ( ) . close ( ) [EOL] except ( KeyboardInterrupt , SystemExit ) : [EOL] sys . stdout . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Dict , Any , Union , AsyncGenerator , Tuple , Callable [EOL] import sched [EOL] import logging [EOL] import quart [EOL] import typing [EOL] import argparse [EOL] import threading [EOL] import builtins [EOL] import src [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import asyncio [EOL] import coloredlogs [EOL] import json [EOL] import logging [EOL] import os [EOL] import quart [EOL] import quart_cors [EOL] import sched [EOL] import sys [EOL] import threading [EOL] import time [EOL] import typing [EOL] [EOL] [EOL] DIR_PATH = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] [EOL] [EOL] def rename ( newname ) : [EOL] [docstring] [EOL] def decorator ( f ) : [EOL] f . __name__ = newname [EOL] return f [EOL] return decorator [EOL] [EOL] [EOL] class ServerSentEvent : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data = [string] , event = [string] ) : [EOL] self . data = data [EOL] self . event = event [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] message = f" [string] { json . dumps ( self . data ) }" [EOL] if self . event is not None : [EOL] message = f"{ message } [string] { self . event }" [EOL] message = f"{ message } [string] " [EOL] return message . encode ( [string] ) [EOL] [EOL] [EOL] class MockLoader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sys_descr , sess_descr ) : [EOL] self . _api_prefix = [string] [EOL] self . _sys_descr = sys_descr [EOL] self . _sess_descr = sess_descr [EOL] [EOL] self . _app = quart . Quart ( __name__ , static_folder = [string] , template_folder = [string] ) [EOL] self . _app = quart_cors . cors ( self . _app ) [EOL] self . _session_timer_start = time . time ( ) [EOL] self . _session_scheduler = sched . scheduler ( time . time , time . sleep ) [EOL] self . _event = ServerSentEvent ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . load_mock_system_description ( ) [EOL] self . load_mock_session_description ( ) [EOL] [EOL] @ property def api_prefix ( self ) : [EOL] return self . _api_prefix [EOL] [EOL] @ property def app ( self ) : [EOL] return self . _app [EOL] [EOL] @ property def sys_descr ( self ) : [EOL] return self . _sys_descr [EOL] [EOL] @ property def sess_descr ( self ) : [EOL] return self . _sess_descr [EOL] [EOL] @ property def session_timer_start ( self ) : [EOL] return self . _session_timer_start [EOL] [EOL] @ property def session_scheduler ( self ) : [EOL] return self . _session_scheduler [EOL] [EOL] @ property def event ( self ) : [EOL] return self . _event [EOL] [EOL] @ event . setter def event ( self , event ) : [EOL] self . _event = event [EOL] [EOL] def load_mock_system_description ( self ) : [EOL] [docstring] [EOL] with open ( os . path . join ( DIR_PATH , self . sys_descr + [string] ) ) as json_file : [EOL] data = json . load ( json_file ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in data : [EOL] self . mock_response ( self . api_prefix + [string] , [string] , data [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in data : [EOL] if data [ [string] ] [ [string] ] : [EOL] [comment] [EOL] self . mock_response ( self . api_prefix + [string] , [string] , data [ [string] ] [ [string] ] ) [EOL] [EOL] for nodes in data [ [string] ] [ [string] ] : [EOL] self . handle_nodes_detail ( data , nodes ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if data [ [string] ] [ [string] ] : [EOL] self . mock_response ( self . api_prefix + [string] , [string] , data [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if data [ [string] ] [ [string] ] : [EOL] self . mock_response ( self . api_prefix + [string] , [string] , data [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in data : [EOL] self . mock_response ( self . api_prefix + [string] , [string] , data [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in data : [EOL] self . mock_response ( self . api_prefix + [string] , [string] , data [ [string] ] ) [EOL] [EOL] def handle_nodes_detail ( self , data , nodes ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . mock_response ( self . api_prefix + [string] + str ( nodes [ [string] ] ) , [string] + str ( nodes [ [string] ] ) + [string] , data [ [string] ] [ [string] ] [ nodes [ [string] ] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in nodes : [EOL] self . mock_response ( self . api_prefix + [string] + str ( nodes [ [string] ] ) + [string] , [string] + str ( nodes [ [string] ] ) + [string] , data [ [string] ] [ [string] ] [ nodes [ [string] ] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in nodes : [EOL] self . mock_response ( self . api_prefix + [string] + str ( nodes [ [string] ] ) + [string] , [string] + str ( nodes [ [string] ] ) + [string] , data [ [string] ] [ [string] ] [ nodes [ [string] ] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in nodes : [EOL] self . mock_response ( self . api_prefix + [string] + str ( nodes [ [string] ] ) + [string] , [string] + str ( nodes [ [string] ] ) + [string] , data [ [string] ] [ [string] ] [ nodes [ [string] ] ] [ [string] ] ) [EOL] [EOL] def mock_response ( self , route , func_name , data ) : [EOL] [docstring] [EOL] @ self . app . route ( route ) @ rename ( func_name ) async def func ( ) : [EOL] response = json . dumps ( data ) [EOL] if response : [EOL] return ( response , [number] ) [EOL] else : [EOL] return ( [string] , [number] ) [EOL] [EOL] def load_mock_session_description ( self ) : [EOL] [docstring] [EOL] with open ( os . path . join ( DIR_PATH , self . sess_descr + [string] ) ) as json_file : [EOL] description = json . load ( json_file ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] event_scheduler_th = threading . Thread ( target = self . event_scheduler , args = ( description , ) ) [EOL] event_scheduler_th . daemon = True [EOL] event_scheduler_th . start ( ) [EOL] [EOL] @ self . app . route ( self . api_prefix + [string] ) async def sse_node_update ( ) : [EOL] [docstring] [EOL] async def send_event ( rate ) : [EOL] while True : [EOL] await asyncio . sleep ( [number] / rate ) [EOL] yield self . event . encode ( ) [EOL] [EOL] return quart . Response ( send_event ( [number] ) , mimetype = [string] ) [EOL] [EOL] def event_scheduler ( self , description ) : [EOL] [docstring] [EOL] if [string] in description : [EOL] for event in description [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] session_start = [number] [EOL] if event [ [string] ] : [EOL] session_start = event [ [string] ] [EOL] [EOL] [comment] [EOL] if event [ [string] ] : [EOL] for idx , node in enumerate ( event [ [string] ] ) : [EOL] node_event = event [ [string] ] [ node ] [EOL] [EOL] self . schedule_node_status_update_events ( node , node_event ) [EOL] self . schedule_publishers_events ( node , node_event ) [EOL] self . schedule_subscribers_events ( node , node_event ) [EOL] [EOL] [comment] [EOL] while True : [EOL] if ( ( time . time ( ) - self . _session_timer_start ) >= session_start ) : [EOL] logger . info ( [string] ) [EOL] self . session_scheduler . run ( ) [EOL] break [EOL] [EOL] def schedule_node_status_update_events ( self , node , node_event ) : [EOL] [docstring] [EOL] if [string] in node_event : [EOL] status_event = node_event [ [string] ] [EOL] [EOL] data = { [string] : int ( node ) , [string] : status_event [ [string] ] , [string] : [number] } [EOL] [EOL] [comment] [EOL] if [string] in status_event and status_event [ [string] ] : [EOL] self . session_scheduler . enter ( status_event [ [string] ] , [number] , self . sse_builder , ( data , [string] , ) ) [EOL] [EOL] [comment] [EOL] if [string] in status_event and status_event [ [string] ] : [EOL] data [ [string] ] = [number] [EOL] [EOL] self . session_scheduler . enter ( status_event [ [string] ] , [number] , self . sse_builder , ( data , [string] , ) ) [EOL] [EOL] def schedule_publishers_events ( self , node , node_event ) : [EOL] [docstring] [EOL] [EOL] if [string] in node_event : [EOL] data = { [string] : int ( node ) , [string] : [ ] } [EOL] [EOL] for idx2 , pub in enumerate ( node_event [ [string] ] ) : [EOL] assert isinstance ( data [ [string] ] , list ) [EOL] [EOL] data [ [string] ] . append ( pub ) [EOL] data [ [string] ] [ idx2 ] . update ( { [string] : [number] } ) [EOL] [EOL] [comment] [EOL] if [string] in pub and pub [ [string] ] : [EOL] self . session_scheduler . enter ( pub [ [string] ] , [number] , self . sse_builder , ( data , [string] , ) ) [EOL] [EOL] [comment] [EOL] if [string] in pub and pub [ [string] ] : [EOL] data [ [string] ] [ idx2 ] . update ( { [string] : [number] } ) [EOL] [EOL] self . session_scheduler . enter ( pub [ [string] ] , [number] , self . sse_builder , ( data , [string] , ) ) [EOL] [EOL] def schedule_subscribers_events ( self , node , node_event ) : [EOL] [docstring] [EOL] if [string] in node_event : [EOL] data = { [string] : int ( node ) , [string] : [ ] } [EOL] [EOL] for idx2 , sub in enumerate ( node_event [ [string] ] ) : [EOL] assert isinstance ( data [ [string] ] , list ) [EOL] [EOL] data [ [string] ] . append ( sub ) [EOL] data [ [string] ] [ idx2 ] . update ( { [string] : [number] } ) [EOL] [EOL] [comment] [EOL] if [string] in sub and sub [ [string] ] : [EOL] self . session_scheduler . enter ( sub [ [string] ] , [number] , self . sse_builder , ( data , [string] , ) ) [EOL] [EOL] [comment] [EOL] if [string] in sub and sub [ [string] ] : [EOL] self . session_scheduler . enter ( sub [ [string] ] , [number] , self . sse_builder , ( data , [string] , ) ) [EOL] [EOL] def sse_builder ( self , data , event_type ) : [EOL] [docstring] [EOL] self . event = ServerSentEvent ( data = data , event = event_type ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logger = logging . getLogger ( __name__ ) [EOL] coloredlogs . install ( level = [string] , logger = logger ) [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , dest = [string] , type = str , help = [string] [string] , default = [string] ) [EOL] parser . add_argument ( [string] , [string] , dest = [string] , type = str , help = [string] [string] , default = [string] ) [EOL] [EOL] [comment] [EOL] args = parser . parse_args ( ) [EOL] [EOL] mock_backend = MockLoader ( args . sysdesc_file , args . sessdesc_file ) [EOL] [EOL] try : [EOL] mock_backend . app . run ( port = [number] ) [EOL] except ( KeyboardInterrupt , SystemExit ) : [EOL] logger . info ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $src.yukon.backend.src.devserv.mock_server.ServerSentEvent$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $src.yukon.backend.src.devserv.mock_server.ServerSentEvent$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] from asyncio import get_event_loop [EOL] [EOL] from quart import Quart , render_template [EOL] from quart_cors import cors [EOL] [EOL] [comment] [EOL] from controllers . nodes import Monitor [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] backend = Quart ( __name__ , static_folder = [string] , template_folder = [string] ) [EOL] [EOL] [comment] [EOL] backend = cors ( backend ) [EOL] [EOL] [comment] [EOL] monitor = Monitor ( ) [EOL] [EOL] [comment] [EOL] backend . register_blueprint ( monitor . nodes_controller , url_prefix = [string] ) [EOL] [EOL] [comment] [EOL] @ backend . route ( [string] , defaults = { [string] : [string] } ) @ backend . route ( [string] ) async def catch_all ( path ) : [EOL] return await render_template ( [string] ) [EOL] [EOL] await backend . run_task ( port = [number] ) [EOL] return [number] [EOL] [EOL] if __name__ == [string] : [EOL] sys . stdout . write ( [string] ) [EOL] try : [EOL] get_event_loop ( ) . run_until_complete ( main ( ) ) [EOL] get_event_loop ( ) . close ( ) [EOL] except ( KeyboardInterrupt , SystemExit ) : [EOL] sys . stdout . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __version__ = [string] [EOL] [EOL] __license__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Dict , Any , Optional , Awaitable , Tuple [EOL] import pathlib [EOL] import uavcan [EOL] import quart [EOL] import typing [EOL] import pyuavcan [EOL] import builtins [EOL] import src [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import pathlib [EOL] import sys [EOL] import tempfile [EOL] from typing import Any , Awaitable , Optional , Tuple [EOL] [EOL] import pyuavcan [EOL] import pyuavcan . transport . udp [EOL] from quart import Blueprint , Response , jsonify , request [EOL] [EOL] dsdl_generated_dir = pathlib . Path ( tempfile . gettempdir ( ) , [string] , f' [string] { pyuavcan . __version__ }' ) [EOL] dsdl_generated_dir . mkdir ( parents = True , exist_ok = True ) [EOL] sys . path . insert ( [number] , str ( dsdl_generated_dir ) ) [EOL] [EOL] try : [EOL] import pyuavcan . application [comment] [EOL] import uavcan . node [comment] [EOL] import uavcan . node . Version_1_0 [comment] [EOL] import uavcan . node . Heartbeat_1_0 [comment] [EOL] except ( ImportError , AttributeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] class Controller : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_list = list ( ) , nodeid_list = list ( ) ) : [EOL] [comment] [EOL] self . _nodes_controller = Blueprint ( [string] , __name__ ) [EOL] [EOL] [comment] [EOL] self . _node_list = node_list [EOL] self . _nodeid_list = nodeid_list [EOL] [EOL] [comment] [EOL] self . _node_health_code = { uavcan . node . Heartbeat_1_0 . HEALTH_NOMINAL : [string] , uavcan . node . Heartbeat_1_0 . HEALTH_ADVISORY : [string] , uavcan . node . Heartbeat_1_0 . HEALTH_CAUTION : [string] , uavcan . node . Heartbeat_1_0 . HEALTH_WARNING : [string] } [EOL] [EOL] [comment] [EOL] self . _node_mode_code = { uavcan . node . Heartbeat_1_0 . MODE_OPERATIONAL : [string] , uavcan . node . Heartbeat_1_0 . MODE_INITIALIZATION : [string] , uavcan . node . Heartbeat_1_0 . MODE_MAINTENANCE : [string] , uavcan . node . Heartbeat_1_0 . MODE_SOFTWARE_UPDATE : [string] , uavcan . node . Heartbeat_1_0 . MODE_OFFLINE : [string] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ self . nodes_controller . route ( [string] , methods = [ [string] ] ) async def list_of_nodes ( ) : [EOL] [docstring] [EOL] return jsonify ( [ e . __dict__ for e in self . get_node_list_ref ( ) ] ) [EOL] [EOL] @ self . nodes_controller . route ( [string] , methods = [ [string] ] ) async def node_parameter_list ( nodeId ) : [EOL] [comment] [EOL] mock_responses = [ NodeParameters ( [string] , [string] , True , False , None , None ) , NodeParameters ( [string] , [string] , [number] , [number] , [number] , [number] ) ] [EOL] [EOL] return jsonify ( [ e . __dict__ for e in mock_responses ] ) [EOL] [EOL] @ self . nodes_controller . route ( [string] , methods = [ [string] ] ) async def node_parameter_update ( nodeId , param ) : [EOL] body = await request . get_json ( ) [EOL] return body [ [string] ] , [number] [EOL] [EOL] @ self . nodes_controller . route ( [string] , methods = [ [string] ] ) async def node_details ( nodeId ) : [EOL] [comment] [EOL] mock_responses = [ NodeDetails ( [string] , nodeId , [string] , [string] , [number] , [number] , [string] , [string] , [string] , [string] , [string] ) ] [EOL] [EOL] return jsonify ( [ e . __dict__ for e in mock_responses ] ) [EOL] [EOL] @ self . nodes_controller . route ( [string] , methods = [ [string] ] ) async def node_shutdown ( nodeId ) : [EOL] return [string] , [number] [EOL] [EOL] @ self . nodes_controller . route ( [string] , methods = [ [string] ] ) async def node_firmware_update ( nodeId , param ) : [EOL] body = await request . get_json ( ) [EOL] return body [ [string] ] , [number] [EOL] [EOL] @ property def nodes_controller ( self ) : [EOL] return self . _nodes_controller [EOL] [EOL] def get_node_list_ref ( self ) : [EOL] return self . _node_list [EOL] [EOL] def get_nodeid_list_ref ( self ) : [EOL] return self . _nodeid_list [EOL] [EOL] def health_to_text ( self , health_code ) : [EOL] return self . _node_health_code . get ( health_code ) [EOL] [EOL] def mode_to_text ( self , mode_code ) : [EOL] return self . _node_mode_code . get ( mode_code ) [EOL] [EOL] [EOL] class NodeInfo : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , id , health , mode , uptime , vendor_code ) : [EOL] self . __dict__ = { [string] : name , [string] : id , [string] : health , [string] : mode , [string] : uptime , [string] : vendor_code } [EOL] [EOL] [EOL] class NodeParameters : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , type_ , value , default , min = None , max = None ) : [EOL] self . __dict__ = { [string] : name , [string] : type_ . lower ( ) , [string] : value . lower ( ) if value is str else value , [string] : default , [string] : min , [string] : max } [EOL] [EOL] [EOL] class NodeDetails : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , id , health , mode , uptime , vendor_code , software_version , crc , hardware_version , uid , authenticity ) : [EOL] self . __dict_ = { [string] : name , [string] : id , [string] : health , [string] : mode , [string] : uptime , [string] : vendor_code , [string] : software_version , [string] : crc , [string] : hardware_version , [string] : uid , [string] : authenticity } [EOL] [EOL] [EOL] class Monitor ( Controller ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] transport = pyuavcan . transport . udp . UDPTransport ( [string] ) [EOL] [EOL] assert transport . local_node_id == [number] [EOL] [EOL] node_info = uavcan . node . GetInfo_1_0 . Response ( protocol_version = uavcan . node . Version_1_0 ( * pyuavcan . UAVCAN_SPECIFICATION_VERSION ) , software_version = uavcan . node . Version_1_0 ( major = [number] , minor = [number] ) , name = [string] , ) [EOL] [EOL] presentation = pyuavcan . presentation . Presentation ( transport ) [EOL] self . _node = pyuavcan . application . Node ( presentation , node_info ) [EOL] [EOL] [comment] [EOL] self . _sub_heartbeat = self . _node . presentation . make_subscriber ( uavcan . node . Heartbeat_1_0 , [number] ) [EOL] [EOL] self . _sub_heartbeat . receive_in_background ( self . _handle_heartbeat ) [EOL] self . _monitor_task = self . _monitor_run ( ) [EOL] [EOL] async def _monitor_run ( self ) : [EOL] self . _node . start ( ) [EOL] return await asyncio . gather ( * asyncio . Task . all_tasks ( ) ) [EOL] [EOL] async def _handle_heartbeat ( self , msg , metadata ) : [EOL] node_info = NodeInfo ( [string] , metadata . source_node_id , super ( ) . health_to_text ( msg . health ) , super ( ) . mode_to_text ( msg . mode ) , msg . uptime , msg . vendor_specific_status_code ) [EOL] if metadata . source_node_id not in super ( ) . get_nodeid_list_ref ( ) : [EOL] super ( ) . get_nodeid_list_ref ( ) . append ( node_info . __dict__ [ [string] ] ) [EOL] super ( ) . get_node_list_ref ( ) . append ( node_info ) [EOL] else : [EOL] super ( ) . get_node_list_ref ( ) [ super ( ) . get_nodeid_list_ref ( ) . index ( node_info . __dict__ [ [string] ] ) ] = node_info [EOL] [EOL] @ property def monitor_started ( self ) : [EOL] return self . _node . _started [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.list$ 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.list$ 0 0 0 $typing.List[typing.Any]$ 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $quart.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $quart.Response$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[src.yukon.backend.src.api.controllers.nodes.NodeParameters]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.yukon.backend.src.api.controllers.nodes.NodeParameters]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[quart.Response,builtins.int]$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $quart.Response$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[src.yukon.backend.src.api.controllers.nodes.NodeDetails]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.yukon.backend.src.api.controllers.nodes.NodeDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[quart.Response,builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[quart.Response,builtins.int]$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $quart.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $uavcan.node.Heartbeat_1_0$ 0 $pyuavcan.transport.TransferFrom$ 0 0 0 $src.yukon.backend.src.api.controllers.nodes.NodeInfo$ 0 0 0 0 0 $pyuavcan.transport.TransferFrom$ 0 0 0 0 0 0 0 0 0 $uavcan.node.Heartbeat_1_0$ 0 0 0 0 0 0 0 0 0 0 $uavcan.node.Heartbeat_1_0$ 0 0 0 0 $uavcan.node.Heartbeat_1_0$ 0 0 0 $uavcan.node.Heartbeat_1_0$ 0 0 0 0 0 $pyuavcan.transport.TransferFrom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.yukon.backend.src.api.controllers.nodes.NodeInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.yukon.backend.src.api.controllers.nodes.NodeInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.yukon.backend.src.api.controllers.nodes.NodeInfo$ 0 0 0 0 0 0 0 0 $src.yukon.backend.src.api.controllers.nodes.NodeInfo$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0