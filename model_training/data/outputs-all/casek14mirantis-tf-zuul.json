[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import setuptools [EOL] [EOL] setuptools . setup ( setup_requires = [ [string] ] , pbr = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Union , Any , Tuple , Dict [EOL] import typing [EOL] import sys , os [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] suppress_warnings = [ [string] ] [EOL] [EOL] primary_domain = [string] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme_options = { [string] : True , [string] : [string] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , [string] , [string] , [ [string] ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] tenant_config = [string] [EOL] [EOL] print ( tenant_config ) [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] [EOL] def main ( ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] try : [EOL] from ansible . module_utils . basic import * [comment] [EOL] except ImportError : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] def main ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] try : [EOL] from ansible . module_utils . basic import * [comment] [EOL] except ImportError : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] [EOL] [EOL] def my_cool_test ( string ) : [EOL] shell_output = subprocess . check_output ( [ [string] ] ) [EOL] return [string] % shell_output . decode ( [string] ) [EOL] [EOL] [EOL] class FilterModule ( object ) : [EOL] [EOL] def filters ( self ) : [EOL] return { [string] : my_cool_test } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] [EOL] [EOL] def my_cool_test ( string ) : [EOL] shell_output = subprocess . check_output ( [ [string] ] ) [EOL] return [string] % shell_output . decode ( [string] ) [EOL] [EOL] [EOL] class FilterModule ( object ) : [EOL] [EOL] def filters ( self ) : [EOL] return { [string] : my_cool_test } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] [EOL] [EOL] def my_cool_test ( string ) : [EOL] shell_output = subprocess . check_output ( [ [string] ] ) [EOL] return [string] % shell_output . decode ( [string] ) [EOL] [EOL] [EOL] class FilterModule ( object ) : [EOL] [EOL] def filters ( self ) : [EOL] return { [string] : my_cool_test } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] [EOL] [EOL] def my_cool_test ( string ) : [EOL] shell_output = subprocess . check_output ( [ [string] ] ) [EOL] return [string] % shell_output . decode ( [string] ) [EOL] [EOL] [EOL] class FilterModule ( object ) : [EOL] [EOL] def filters ( self ) : [EOL] return { [string] : my_cool_test } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] [EOL] [EOL] def my_cool_test ( string ) : [EOL] shell_output = subprocess . check_output ( [ [string] ] ) [EOL] return [string] % shell_output . decode ( [string] ) [EOL] [EOL] [EOL] class FilterModule ( object ) : [EOL] [EOL] def filters ( self ) : [EOL] return { [string] : my_cool_test } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] [EOL] [EOL] def my_cool_test ( string ) : [EOL] shell_output = subprocess . check_output ( [ [string] ] ) [EOL] return [string] % shell_output . decode ( [string] ) [EOL] [EOL] [EOL] class FilterModule ( object ) : [EOL] [EOL] def filters ( self ) : [EOL] return { [string] : my_cool_test } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Optional , Dict [EOL] import typing [EOL] import dateutil [EOL] import json [EOL] import os [EOL] import textwrap [EOL] [EOL] from tests . base import AnsibleZuulTestCase [EOL] [EOL] [EOL] class TestZuulJSON25 ( AnsibleZuulTestCase ) : [EOL] tenant_config_file = [string] [EOL] ansible_version = [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . fake_nodepool . remote_ansible = True [EOL] [EOL] ansible_remote = os . environ . get ( [string] ) [EOL] self . assertIsNotNone ( ansible_remote ) [EOL] [EOL] def _run_job ( self , job_name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . executor_server . keep_jobdir = True [EOL] [EOL] [comment] [EOL] self . executor_server . verbose = True [EOL] conf = textwrap . dedent ( [string] . format ( job_name = job_name , version = self . ansible_version ) ) [EOL] [EOL] file_dict = { [string] : conf } [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] , files = file_dict ) [EOL] self . fake_gerrit . addEvent ( A . getPatchsetCreatedEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] job = self . getJobFromHistory ( job_name ) [EOL] return job [EOL] [EOL] def _get_json_as_text ( self , build ) : [EOL] path = os . path . join ( self . test_root , build . uuid , [string] , [string] , [string] ) [EOL] with open ( path ) as f : [EOL] return f . read ( ) [EOL] [EOL] def test_no_log ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] self . assertEqual ( build . result , [string] ) [EOL] [EOL] text = self . _get_json_as_text ( build ) [EOL] self . assertIn ( [string] , text ) [EOL] self . assertNotIn ( [string] , text ) [EOL] [EOL] def test_json_task_action ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] self . assertEqual ( build . result , [string] ) [EOL] [EOL] text = self . _get_json_as_text ( build ) [EOL] json_result = json . loads ( text ) [EOL] tasks = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] expected_actions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for i , expected in enumerate ( expected_actions ) : [EOL] host_result = tasks [ i ] [ [string] ] [ [string] ] [EOL] self . assertEquals ( expected , host_result [ [string] ] ) [EOL] [EOL] def test_json_role_log ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] self . assertEqual ( build . result , [string] ) [EOL] [EOL] text = self . _get_json_as_text ( build ) [EOL] self . assertIn ( [string] , text ) [EOL] [EOL] json_result = json . loads ( text ) [EOL] role_name = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [string] ] [EOL] self . assertEqual ( [string] , role_name ) [EOL] [EOL] role_path = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [string] ] [EOL] self . assertEqual ( [string] , os . path . basename ( role_path ) ) [EOL] [EOL] def test_json_time_log ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] self . assertEqual ( build . result , [string] ) [EOL] [EOL] text = self . _get_json_as_text ( build ) [EOL] [comment] [EOL] self . assertIn ( [string] , text ) [EOL] self . assertIn ( [string] , text ) [EOL] [EOL] json_result = json . loads ( text ) [EOL] [comment] [EOL] [comment] [EOL] task = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] task_start_time = task [ [string] ] [ [string] ] [EOL] task_end_time = task [ [string] ] [ [string] ] [EOL] [EOL] play = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] play_start_time = play [ [string] ] [ [string] ] [EOL] play_end_time = play [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] dateutil . parser . parse ( task_start_time ) [EOL] dateutil . parser . parse ( task_end_time ) [EOL] dateutil . parser . parse ( play_start_time ) [EOL] dateutil . parser . parse ( play_end_time ) [EOL] [EOL] [EOL] class TestZuulJSON26 ( TestZuulJSON25 ) : [EOL] ansible_version = [string] [EOL] [EOL] [EOL] class TestZuulJSON27 ( TestZuulJSON25 ) : [EOL] ansible_version = [string] [EOL] [EOL] [EOL] class TestZuulJSON28 ( TestZuulJSON25 ) : [EOL] ansible_version = [string] [EOL] [EOL] def test_json_task_action ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] self . assertEqual ( build . result , [string] ) [EOL] [EOL] text = self . _get_json_as_text ( build ) [EOL] json_result = json . loads ( text ) [EOL] tasks = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] expected_actions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for i , expected in enumerate ( expected_actions ) : [EOL] host_result = tasks [ i ] [ [string] ] [ [string] ] [EOL] self . assertEquals ( expected , host_result [ [string] ] ) [EOL] [EOL] def test_json_role_log ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] self . assertEqual ( build . result , [string] ) [EOL] [EOL] text = self . _get_json_as_text ( build ) [EOL] self . assertIn ( [string] , text ) [EOL] [EOL] json_result = json . loads ( text ) [EOL] [comment] [EOL] [comment] [EOL] role_name = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [string] ] [EOL] self . assertEqual ( [string] , role_name ) [EOL] [EOL] role_path = json_result [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [string] ] [EOL] self . assertEqual ( [string] , os . path . basename ( role_path ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Optional , Dict [EOL] import typing [EOL] import os [EOL] import textwrap [EOL] [EOL] import yaml [EOL] [EOL] from tests . base import AnsibleZuulTestCase [EOL] [EOL] [EOL] class TestZuulHostVars ( AnsibleZuulTestCase ) : [EOL] tenant_config_file = [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . fake_nodepool . remote_ansible = True [EOL] [EOL] ansible_remote = os . environ . get ( [string] ) [EOL] self . assertIsNotNone ( ansible_remote ) [EOL] [EOL] def _run_job ( self , job_name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . executor_server . keep_jobdir = True [EOL] [EOL] [comment] [EOL] self . executor_server . verbose = True [EOL] conf = textwrap . dedent ( [string] . format ( job_name = job_name ) ) [EOL] [EOL] file_dict = { [string] : conf } [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] , files = file_dict ) [EOL] self . fake_gerrit . addEvent ( A . getPatchsetCreatedEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] job = self . getJobFromHistory ( job_name ) [EOL] return job [EOL] [EOL] def test_hostvars ( self ) : [EOL] job = self . _run_job ( [string] ) [EOL] with self . jobLog ( job ) : [EOL] build = self . history [ - [number] ] [EOL] inventory = yaml . safe_load ( open ( os . path . join ( self . test_root , build . uuid , [string] , [string] ) ) ) [EOL] self . assertEqual ( [string] , inventory [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import subprocess [EOL] import io [EOL] import typing [EOL] import io [EOL] import os [EOL] import sys [EOL] import subprocess [EOL] import time [EOL] [EOL] import configparser [EOL] import fixtures [EOL] import jwt [EOL] [EOL] from tests . base import BaseTestCase [EOL] from tests . base import FIXTURE_DIR [EOL] [EOL] [EOL] class BaseClientTestCase ( BaseTestCase ) : [EOL] config_file = [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( BaseClientTestCase , self ) . setUp ( ) [EOL] self . test_root = self . useFixture ( fixtures . TempDir ( rootdir = os . environ . get ( [string] ) ) ) . path [EOL] self . config = configparser . ConfigParser ( ) [EOL] self . config . read ( os . path . join ( FIXTURE_DIR , self . config_file ) ) [EOL] [EOL] [EOL] class TestTenantValidationClient ( BaseClientTestCase ) : [EOL] def test_client_tenant_conf_check ( self ) : [EOL] [EOL] self . config . set ( [string] , [string] , os . path . join ( FIXTURE_DIR , [string] ) ) [EOL] self . config . write ( open ( os . path . join ( self . test_root , [string] ) , [string] ) ) [EOL] p = subprocess . Popen ( [ os . path . join ( sys . prefix , [string] ) , [string] , os . path . join ( self . test_root , [string] ) , [string] ] , stdout = subprocess . PIPE ) [EOL] p . communicate ( ) [EOL] self . assertEqual ( p . returncode , [number] , [string] ) [EOL] [EOL] self . config . set ( [string] , [string] , os . path . join ( FIXTURE_DIR , [string] ) ) [EOL] self . config . write ( open ( os . path . join ( self . test_root , [string] ) , [string] ) ) [EOL] p = subprocess . Popen ( [ os . path . join ( sys . prefix , [string] ) , [string] , os . path . join ( self . test_root , [string] ) , [string] ] , stdout = subprocess . PIPE ) [EOL] out , _ = p . communicate ( ) [EOL] self . assertEqual ( p . returncode , [number] , [string] ) [EOL] self . assertIn ( [string] , out , [string] ) [EOL] [EOL] [EOL] class TestWebTokenClient ( BaseClientTestCase ) : [EOL] config_file = [string] [EOL] [EOL] def test_no_authenticator ( self ) : [EOL] [docstring] [EOL] old_conf = io . StringIO ( ) [EOL] self . config . write ( old_conf ) [EOL] self . config . remove_section ( [string] ) [EOL] self . config . write ( open ( os . path . join ( self . test_root , [string] ) , [string] ) ) [EOL] p = subprocess . Popen ( [ os . path . join ( sys . prefix , [string] ) , [string] , os . path . join ( self . test_root , [string] ) , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = subprocess . PIPE ) [EOL] out , _ = p . communicate ( ) [EOL] old_conf . seek ( [number] ) [EOL] self . config = configparser . ConfigParser ( ) [EOL] self . config . read_file ( old_conf ) [EOL] self . assertEqual ( p . returncode , [number] , [string] ) [EOL] [EOL] def test_unsupported_driver ( self ) : [EOL] [docstring] [EOL] old_conf = io . StringIO ( ) [EOL] self . config . write ( old_conf ) [EOL] self . config . add_section ( [string] ) [EOL] self . config . set ( [string] , [string] , [string] ) [EOL] self . config . write ( open ( os . path . join ( self . test_root , [string] ) , [string] ) ) [EOL] p = subprocess . Popen ( [ os . path . join ( sys . prefix , [string] ) , [string] , os . path . join ( self . test_root , [string] ) , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = subprocess . PIPE ) [EOL] out , _ = p . communicate ( ) [EOL] old_conf . seek ( [number] ) [EOL] self . config = configparser . ConfigParser ( ) [EOL] self . config . read_file ( old_conf ) [EOL] self . assertEqual ( p . returncode , [number] , [string] ) [EOL] [EOL] def test_token_generation ( self ) : [EOL] [docstring] [EOL] self . config . write ( open ( os . path . join ( self . test_root , [string] ) , [string] ) ) [EOL] p = subprocess . Popen ( [ os . path . join ( sys . prefix , [string] ) , [string] , os . path . join ( self . test_root , [string] ) , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = subprocess . PIPE ) [EOL] now = time . time ( ) [EOL] out , _ = p . communicate ( ) [EOL] self . assertEqual ( p . returncode , [number] , [string] ) [EOL] self . assertTrue ( out . startswith ( [string] ) , out ) [EOL] [comment] [EOL] token = jwt . decode ( out [ len ( [string] ) : - [number] ] , key = self . config . get ( [string] , [string] ) , algorithm = self . config . get ( [string] , [string] ) , audience = self . config . get ( [string] , [string] ) , ) [EOL] self . assertEqual ( [string] , token . get ( [string] ) ) [EOL] self . assertEqual ( [string] , token . get ( [string] ) ) [EOL] self . assertEqual ( [string] , token . get ( [string] ) ) [EOL] admin_tenants = token . get ( [string] , { } ) . get ( [string] , [ ] ) [EOL] self . assertTrue ( [string] in admin_tenants , admin_tenants ) [EOL] [comment] [EOL] self . assertTrue ( [number] <= int ( token [ [string] ] ) - now < [number] , ( token [ [string] ] , now ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.float$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type [EOL] import tests [EOL] import typing [EOL] import daemon [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] import extras [EOL] import fixtures [EOL] import testtools [EOL] [EOL] from tests . base import iterate_timeout [EOL] [EOL] [comment] [EOL] [comment] [EOL] pid_file_module = extras . try_imports ( [ [string] , [string] ] ) [EOL] [EOL] [EOL] def daemon_test ( pidfile , flagfile ) : [EOL] pid = pid_file_module . TimeoutPIDLockFile ( pidfile , [number] ) [EOL] with daemon . DaemonContext ( pidfile = pid ) : [EOL] for x in iterate_timeout ( [number] , [string] ) : [EOL] if not os . path . exists ( flagfile ) : [EOL] break [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] class TestDaemon ( testtools . TestCase ) : [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def setUp ( self ) : [EOL] super ( TestDaemon , self ) . setUp ( ) [EOL] self . test_root = self . useFixture ( fixtures . TempDir ( rootdir = os . environ . get ( [string] ) ) ) . path [EOL] [EOL] def test_daemon ( self ) : [EOL] pidfile = os . path . join ( self . test_root , [string] ) [EOL] flagfile = os . path . join ( self . test_root , [string] ) [EOL] open ( flagfile , [string] ) . close ( ) [EOL] if not os . fork ( ) : [EOL] self . _cleanups = [ ] [EOL] daemon_test ( pidfile , flagfile ) [EOL] for x in iterate_timeout ( [number] , [string] ) : [EOL] if os . path . exists ( pidfile ) : [EOL] break [EOL] os . unlink ( flagfile ) [EOL] for x in iterate_timeout ( [number] , [string] ) : [EOL] if not os . path . exists ( pidfile ) : [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Any , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] import base64 [EOL] import os [EOL] [EOL] import yaml [EOL] [EOL] from tests . base import AnsibleZuulTestCase [EOL] from tests . base import ZuulTestCase [EOL] [EOL] [EOL] class TestInventoryBase ( ZuulTestCase ) : [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def setUp ( self , python_path = None ) : [EOL] super ( TestInventoryBase , self ) . setUp ( ) [EOL] if python_path : [EOL] self . fake_nodepool . python_path = python_path [EOL] self . executor_server . hold_jobs_in_build = True [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] self . fake_gerrit . addEvent ( A . getPatchsetCreatedEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] def _get_build_inventory ( self , name ) : [EOL] build = self . getBuildByName ( name ) [EOL] inv_path = os . path . join ( build . jobdir . root , [string] , [string] ) [EOL] return yaml . safe_load ( open ( inv_path , [string] ) ) [EOL] [EOL] def _get_setup_inventory ( self , name ) : [EOL] build = self . getBuildByName ( name ) [EOL] setup_inv_path = os . path . join ( build . jobdir . root , [string] , [string] ) [EOL] return yaml . safe_load ( open ( setup_inv_path , [string] ) ) [EOL] [EOL] [EOL] class TestInventoryPythonPath ( TestInventoryBase ) : [EOL] [EOL] def setUp ( self ) : [EOL] super ( TestInventoryPythonPath , self ) . setUp ( python_path = [string] ) [EOL] [EOL] def test_single_inventory ( self ) : [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] [EOL] all_nodes = ( [string] , ) [EOL] self . assertIn ( [string] , inventory ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] for node_name in all_nodes : [EOL] self . assertIn ( node_name , inventory [ [string] ] [ [string] ] ) [EOL] node_vars = inventory [ [string] ] [ [string] ] [ node_name ] [EOL] self . assertEqual ( [string] , node_vars [ [string] ] ) [EOL] [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] z_vars = inventory [ [string] ] [ [string] ] [ [string] ] [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertIn ( [string] , z_vars [ [string] ] ) [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertEqual ( z_vars [ [string] ] , [string] ) [EOL] self . assertEqual ( z_vars [ [string] ] , [string] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [EOL] class TestInventory ( TestInventoryBase ) : [EOL] [EOL] def test_single_inventory ( self ) : [EOL] [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] [EOL] all_nodes = ( [string] , ) [EOL] self . assertIn ( [string] , inventory ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] for node_name in all_nodes : [EOL] self . assertIn ( node_name , inventory [ [string] ] [ [string] ] ) [EOL] node_vars = inventory [ [string] ] [ [string] ] [ node_name ] [EOL] self . assertEqual ( [string] , node_vars [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] z_vars = inventory [ [string] ] [ [string] ] [ [string] ] [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertIn ( [string] , z_vars [ [string] ] ) [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertEqual ( z_vars [ [string] ] , [string] ) [EOL] self . assertEqual ( z_vars [ [string] ] , [string] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] def test_single_inventory_list ( self ) : [EOL] [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] [EOL] all_nodes = ( [string] , [string] ) [EOL] self . assertIn ( [string] , inventory ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] for node_name in all_nodes : [EOL] self . assertIn ( node_name , inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] z_vars = inventory [ [string] ] [ [string] ] [ [string] ] [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertIn ( [string] , z_vars [ [string] ] ) [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertEqual ( z_vars [ [string] ] , [string] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] def test_group_inventory ( self ) : [EOL] [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] [EOL] all_nodes = ( [string] , [string] , [string] ) [EOL] self . assertIn ( [string] , inventory ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] for group_name in ( [string] , [string] ) : [EOL] self . assertIn ( group_name , inventory [ [string] ] [ [string] ] ) [EOL] for node_name in all_nodes : [EOL] self . assertIn ( node_name , inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( node_name , inventory [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] z_vars = inventory [ [string] ] [ [string] ] [ [string] ] [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertIn ( [string] , z_vars [ [string] ] ) [EOL] self . assertIn ( [string] , z_vars ) [EOL] self . assertEqual ( z_vars [ [string] ] , [string] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] def test_hostvars_inventory ( self ) : [EOL] [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] [EOL] all_nodes = ( [string] , [string] ) [EOL] self . assertIn ( [string] , inventory ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] for node_name in all_nodes : [EOL] self . assertIn ( node_name , inventory [ [string] ] [ [string] ] ) [EOL] [comment] [EOL] if node_name == [string] : [EOL] username = [string] [EOL] else : [EOL] username = [string] [EOL] self . assertEqual ( inventory [ [string] ] [ [string] ] [ node_name ] [ [string] ] , username ) [EOL] [EOL] [comment] [EOL] if node_name == [string] : [EOL] self . assertEqual ( inventory [ [string] ] [ [string] ] [ node_name ] [ [string] ] , [string] ) [EOL] else : [EOL] self . assertEqual ( [string] , inventory [ [string] ] [ [string] ] [ node_name ] [ [string] ] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] def test_setup_inventory ( self ) : [EOL] [EOL] setup_inventory = self . _get_setup_inventory ( [string] ) [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] [EOL] self . assertIn ( [string] , inventory ) [EOL] self . assertIn ( [string] , inventory [ [string] ] ) [EOL] [EOL] self . assertIn ( [string] , setup_inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , setup_inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , setup_inventory [ [string] ] [ [string] ] ) [EOL] self . assertNotIn ( [string] , setup_inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] self . assertIn ( [string] , inventory [ [string] ] [ [string] ] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [EOL] class TestAnsibleInventory ( AnsibleZuulTestCase ) : [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def _get_file ( self , build , path ) : [EOL] p = os . path . join ( build . jobdir . root , path ) [EOL] with open ( p ) as f : [EOL] return f . read ( ) [EOL] [EOL] def _jinja2_message ( self , expected_message ) : [EOL] [EOL] [comment] [EOL] self . wait_timeout = [number] [EOL] [comment] [EOL] self . executor_server . keep_jobdir = True [EOL] [comment] [EOL] self . executor_server . verbose = True [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , expected_message ) [EOL] self . fake_gerrit . addEvent ( A . getPatchsetCreatedEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertHistory ( [ dict ( name = [string] , result = [string] , changes = [string] ) ] ) [EOL] [EOL] build = self . history [ [number] ] [EOL] inv_path = os . path . join ( build . jobdir . root , [string] , [string] ) [EOL] inventory = yaml . safe_load ( open ( inv_path , [string] ) ) [EOL] [EOL] decoded_message = base64 . b64decode ( inventory [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) . decode ( [string] ) [EOL] self . assertEqual ( decoded_message , expected_message ) [EOL] [EOL] obtained_message = self . _get_file ( self . history [ [number] ] , [string] ) [EOL] [EOL] self . assertEqual ( obtained_message , expected_message ) [EOL] [EOL] def test_jinja2_message_brackets ( self ) : [EOL] self . _jinja2_message ( [string] ) [EOL] [EOL] def test_jinja2_message_raw ( self ) : [EOL] self . _jinja2_message ( [string] ) [EOL] [EOL] [EOL] class TestWindowsInventory ( TestInventoryBase ) : [EOL] config_file = [string] [EOL] [EOL] def test_windows_inventory ( self ) : [EOL] [EOL] inventory = self . _get_build_inventory ( [string] ) [EOL] windows_host = inventory [ [string] ] [ [string] ] [ [string] ] [EOL] self . assertEqual ( windows_host [ [string] ] , [string] ) [EOL] self . assertEqual ( windows_host [ [string] ] , [string] ) [EOL] self . assertEqual ( windows_host [ [string] ] , [string] ) [EOL] [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] from tests . base import ZuulTestCase [EOL] [EOL] [EOL] class TestRequirementsApprovalNewerThan ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_approval_newer_than ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_newer_than ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_approval_newer_than ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_newer_than ( [string] , [string] ) [EOL] [EOL] def _test_require_approval_newer_than ( self , project , job ) : [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] , username = [string] , granted_on = time . time ( ) - [number] * [number] * [number] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] , username = [string] ) ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [EOL] class TestRequirementsApprovalOlderThan ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_approval_older_than ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_older_than ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_approval_older_than ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_older_than ( [string] , [string] ) [EOL] [EOL] def _test_require_approval_older_than ( self , project , job ) : [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] , username = [string] , granted_on = time . time ( ) - [number] * [number] * [number] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [EOL] class TestRequirementsUserName ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_approval_username ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_username ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_approval_username ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_username ( [string] , [string] ) [EOL] [EOL] def _test_require_approval_username ( self , project , job ) : [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [EOL] class TestRequirementsEmail ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_approval_email ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_email ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_approval_email ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_email ( [string] , [string] ) [EOL] [EOL] def _test_require_approval_email ( self , project , job ) : [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [EOL] class TestRequirementsVote1 ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_approval_vote1 ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_vote1 ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_approval_vote1 ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_vote1 ( [string] , [string] ) [EOL] [EOL] def _test_require_approval_vote1 ( self , project , job ) : [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , - [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [EOL] class TestRequirementsVote2 ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_approval_vote2 ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_vote2 ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_approval_vote2 ( self ) : [EOL] [docstring] [EOL] return self . _test_require_approval_vote2 ( [string] , [string] ) [EOL] [EOL] def _test_require_approval_vote2 ( self , project , job ) : [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , - [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , - [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [comment] [EOL] B = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] [comment] [EOL] comment = B . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] B . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [EOL] class TestRequirementsState ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_pipeline_require_current_patchset ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] A . addPatchset ( ) [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [comment] [EOL] self . fake_gerrit . addEvent ( A . getChangeCommentEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] self . fake_gerrit . addEvent ( A . getChangeCommentEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] def test_pipeline_require_open ( self ) : [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] , status = [string] ) [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] B = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] self . fake_gerrit . addEvent ( B . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] def test_pipeline_require_status ( self ) : [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] , status = [string] ) [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] B = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] self . fake_gerrit . addEvent ( B . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [EOL] class TestRequirementsRejectUsername ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def _test_require_reject_username ( self , project , job ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] , username = [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [comment] [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] , username = [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] , username = [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] def test_pipeline_reject_username ( self ) : [EOL] [docstring] [EOL] return self . _test_require_reject_username ( [string] , [string] ) [EOL] [EOL] def test_trigger_reject_username ( self ) : [EOL] [docstring] [EOL] return self . _test_require_reject_username ( [string] , [string] ) [EOL] [EOL] [EOL] class TestRequirementsReject ( ZuulTestCase ) : [EOL] [docstring] [EOL] [EOL] tenant_config_file = [string] [EOL] [EOL] def _test_require_reject ( self , project , job ) : [EOL] [docstring] [EOL] A = self . fake_gerrit . addFakeChange ( project , [string] , [string] ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , - [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] self . assertEqual ( self . history [ [number] ] . name , job ) [EOL] [EOL] def test_pipeline_require_reject ( self ) : [EOL] [docstring] [EOL] return self . _test_require_reject ( [string] , [string] ) [EOL] [EOL] def test_trigger_require_reject ( self ) : [EOL] [docstring] [EOL] return self . _test_require_reject ( [string] , [string] ) [EOL] [EOL] def test_pipeline_requirement_reject_unrelated ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] self . fake_gerrit . addEvent ( A . getChangeCommentEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , - [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] comment = A . addApproval ( [string] , [number] , username = [string] ) [EOL] self . fake_gerrit . addEvent ( comment ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( len ( self . history ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Union , Dict [EOL] import typing [EOL] import re [EOL] import yaml [EOL] import time [EOL] import socket [EOL] [EOL] from testtools . matchers import MatchesRegex [EOL] [EOL] import zuul . rpcclient [EOL] [EOL] from tests . base import ZuulTestCase , simple_layout [EOL] from tests . base import ZuulWebFixture [EOL] [EOL] [EOL] class TestPagureDriver ( ZuulTestCase ) : [EOL] config_file = [string] [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pull_request_opened ( self ) : [EOL] [EOL] initial_comment = [string] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] , initial_comment = initial_comment ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] [EOL] job = self . getJobFromHistory ( [string] ) [EOL] zuulvars = job . parameters [ [string] ] [EOL] self . assertEqual ( str ( A . number ) , zuulvars [ [string] ] ) [EOL] self . assertEqual ( str ( A . commit_stop ) , zuulvars [ [string] ] ) [EOL] self . assertEqual ( [string] , zuulvars [ [string] ] ) [EOL] self . assertEquals ( [string] , zuulvars [ [string] ] [ [number] ] [ [string] ] ) [EOL] self . assertEqual ( zuulvars [ [string] ] , initial_comment ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] self . assertEqual ( [number] , len ( A . comments ) ) [EOL] self . assertEqual ( A . comments [ [number] ] [ [string] ] , [string] ) [EOL] self . assertThat ( A . comments [ [number] ] [ [string] ] , MatchesRegex ( [string] , re . DOTALL ) ) [EOL] self . assertThat ( A . comments [ [number] ] [ [string] ] , MatchesRegex ( [string] , re . DOTALL ) ) [EOL] self . assertEqual ( [number] , len ( A . flags ) ) [EOL] self . assertEqual ( [string] , A . flags [ [number] ] [ [string] ] ) [EOL] self . assertEqual ( [string] , A . flags [ [number] ] [ [string] ] ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pull_request_updated ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] pr_tip1 = A . commit_stop [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] self . assertHistory ( [ { [string] : [string] , [string] : [string] % pr_tip1 } , { [string] : [string] , [string] : [string] % pr_tip1 } , ] , ordered = False ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestUpdatedEvent ( ) ) [EOL] pr_tip2 = A . commit_stop [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] self . assertHistory ( [ { [string] : [string] , [string] : [string] % pr_tip1 } , { [string] : [string] , [string] : [string] % pr_tip1 } , { [string] : [string] , [string] : [string] % pr_tip2 } , { [string] : [string] , [string] : [string] % pr_tip2 } ] , ordered = False ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pull_request_updated_builds_aborted ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] pr_tip1 = A . commit_stop [EOL] [EOL] self . executor_server . hold_jobs_in_build = True [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestUpdatedEvent ( ) ) [EOL] pr_tip2 = A . commit_stop [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = False [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertHistory ( [ { [string] : [string] , [string] : [string] , [string] : [string] % pr_tip1 } , { [string] : [string] , [string] : [string] , [string] : [string] % pr_tip1 } , { [string] : [string] , [string] : [string] % pr_tip2 } , { [string] : [string] , [string] : [string] % pr_tip2 } ] , ordered = False ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pull_request_commented ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pull_request_with_dyn_reconf ( self ) : [EOL] [EOL] zuul_yaml = [ { [string] : { [string] : [string] , [string] : [string] } } , { [string] : { [string] : { [string] : [ [string] ] } } } ] [EOL] playbook = [string] [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] A . addCommit ( { [string] : yaml . dump ( zuul_yaml ) , [string] : playbook } ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_ref_updated ( self ) : [EOL] [EOL] event = self . fake_pagure . getGitReceiveEvent ( [string] ) [EOL] expected_newrev = event [ [number] ] [ [string] ] [ [string] ] [EOL] self . fake_pagure . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] [EOL] job = self . getJobFromHistory ( [string] ) [EOL] zuulvars = job . parameters [ [string] ] [EOL] self . assertEqual ( [string] , zuulvars [ [string] ] ) [EOL] self . assertEqual ( [string] , zuulvars [ [string] ] ) [EOL] self . assertEqual ( [string] , zuulvars [ [string] ] ) [EOL] self . assertEqual ( [string] , zuulvars [ [string] ] ) [EOL] self . assertEqual ( [string] % zuulvars [ [string] ] , zuulvars [ [string] ] ) [EOL] self . assertEqual ( expected_newrev , zuulvars [ [string] ] ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_ref_updated_and_tenant_reconfigure ( self ) : [EOL] [EOL] self . waitUntilSettled ( ) [EOL] old = self . sched . tenant_last_reconfigured . get ( [string] , [number] ) [EOL] time . sleep ( [number] ) [EOL] [EOL] zuul_yaml = [ { [string] : { [string] : [string] , [string] : [string] } } , { [string] : { [string] : { [string] : [ [string] ] } } } ] [EOL] playbook = [string] [EOL] self . create_commit ( [string] , { [string] : yaml . dump ( zuul_yaml ) , [string] : playbook } , message = [string] ) [EOL] event = self . fake_pagure . getGitReceiveEvent ( [string] ) [EOL] self . fake_pagure . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] new = self . sched . tenant_last_reconfigured . get ( [string] , [number] ) [EOL] [comment] [EOL] self . assertLess ( old , new ) [EOL] [EOL] self . assertHistory ( [ { [string] : [string] } , { [string] : [string] } , ] , ordered = False ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_client_dequeue_change_pagure ( self ) : [EOL] [EOL] client = zuul . rpcclient . RPCClient ( [string] , self . gearman_server . port ) [EOL] self . addCleanup ( client . shutdown ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = True [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] client . dequeue ( tenant = [string] , pipeline = [string] , project = [string] , change = [string] % ( A . number , A . commit_stop ) , ref = None ) [EOL] [EOL] self . waitUntilSettled ( ) [EOL] [EOL] tenant = self . sched . abide . tenants . get ( [string] ) [EOL] check_pipeline = tenant . layout . pipelines [ [string] ] [EOL] self . assertEqual ( check_pipeline . getAllItems ( ) , [ ] ) [EOL] self . assertEqual ( self . countJobResults ( self . history , [string] ) , [number] ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = False [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_client_enqueue_change_pagure ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] client = zuul . rpcclient . RPCClient ( [string] , self . gearman_server . port ) [EOL] self . addCleanup ( client . shutdown ) [EOL] r = client . enqueue ( tenant = [string] , pipeline = [string] , project = [string] , trigger = [string] , change = [string] % ( A . number , A . commit_stop ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( self . getJobFromHistory ( [string] ) . result , [string] ) [EOL] self . assertEqual ( self . getJobFromHistory ( [string] ) . result , [string] ) [EOL] self . assertEqual ( r , True ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pr_score_require_1_vote ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_pr_score_require_2_votes ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_status_trigger ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestStatusSetEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestStatusSetEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_merge_action_in_independent ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] self . assertEqual ( [string] , A . status ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_merge_action_in_dependent ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] [comment] [EOL] A . cached_merge_status = [string] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] [comment] [EOL] A . threshold_reached = True [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] [comment] [EOL] A . addFlag ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] self . assertEqual ( [string] , A . status ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_crd_independent ( self ) : [EOL] [EOL] [comment] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] msg = [string] % A . url [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] , initial_comment = msg ) [EOL] [EOL] [comment] [EOL] event = B . getPullRequestCommentedEvent ( [string] ) [EOL] self . fake_pagure . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] [EOL] self . assertEqual ( changes , [string] % ( A . number , A . commit_stop , B . number , B . commit_stop ) ) [EOL] [EOL] [comment] [EOL] tenant = self . sched . abide . tenants . get ( [string] ) [EOL] self . assertEqual ( len ( tenant . layout . pipelines [ [string] ] . queues ) , [number] ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_crd_dependent ( self ) : [EOL] [EOL] [comment] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] msg = [string] % A . url [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] , initial_comment = msg ) [EOL] [EOL] [comment] [EOL] event = B . getPullRequestCommentedEvent ( [string] ) [EOL] [EOL] self . fake_pagure . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] B . threshold_reached = True [EOL] B . addFlag ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [number] , len ( self . history ) ) [EOL] [EOL] A . threshold_reached = True [EOL] A . addFlag ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] [EOL] self . assertEqual ( changes , [string] % ( A . number , A . commit_stop , B . number , B . commit_stop ) ) [EOL] [EOL] self . assertTrue ( A . is_merged ) [EOL] self . assertTrue ( B . is_merged ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_crd_needed_changes ( self ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] A . threshold_reached = True [EOL] A . addFlag ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] msg = [string] % A . url [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] , initial_comment = msg ) [EOL] [comment] [EOL] [comment] [EOL] self . fake_pagure . emitEvent ( B . getPullRequestCommentedEvent ( [string] ) ) [EOL] [comment] [EOL] B . threshold_reached = True [EOL] B . addFlag ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] [EOL] self . assertEqual ( changes , [string] % ( A . number , A . commit_stop , B . number , B . commit_stop ) ) [EOL] [EOL] self . assertTrue ( A . is_merged ) [EOL] self . assertTrue ( B . is_merged ) [EOL] [EOL] [EOL] class TestPagureToGerritCRD ( ZuulTestCase ) : [EOL] config_file = [string] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_crd_gate ( self ) : [EOL] [docstring] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] B = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] A . editInitialComment ( [string] % ( B . data [ [string] ] ) ) [EOL] [EOL] A . addFlag ( [string] , [string] , [string] ) [EOL] A . threshold_reached = True [EOL] [EOL] B . addApproval ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] self . assertFalse ( A . is_merged ) [EOL] self . assertEqual ( B . data [ [string] ] , [string] ) [EOL] [EOL] for connection in self . connections . connections . values ( ) : [EOL] connection . maintainCache ( [ ] ) [EOL] [EOL] B . addApproval ( [string] , [number] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( A . is_merged ) [EOL] self . assertEqual ( B . data [ [string] ] , [string] ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] self . assertEqual ( B . reported , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % A . commit_stop ) [EOL] [EOL] def test_crd_check ( self ) : [EOL] [docstring] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] B = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] A . editInitialComment ( [string] % ( B . data [ [string] ] , ) ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = True [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestUpdatedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( self . builds [ [number] ] . hasChanges ( A , B ) ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = False [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertFalse ( A . is_merged ) [EOL] self . assertEqual ( B . data [ [string] ] , [string] ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] self . assertEqual ( B . reported , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % A . commit_stop ) [EOL] [EOL] [EOL] class TestGerritToPagureCRD ( ZuulTestCase ) : [EOL] config_file = [string] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_crd_gate ( self ) : [EOL] [docstring] [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] A . addApproval ( [string] , [number] ) [EOL] [EOL] AM2 = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] AM1 = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] AM2 . setMerged ( ) [EOL] AM1 . setMerged ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] A . setDependsOn ( AM1 , [number] ) [EOL] AM1 . setDependsOn ( AM2 , [number] ) [EOL] [EOL] A . data [ [string] ] = [string] % ( A . subject , B . url ) [EOL] [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( A . data [ [string] ] , [string] ) [EOL] self . assertFalse ( B . is_merged ) [EOL] [EOL] for connection in self . connections . connections . values ( ) : [EOL] connection . maintainCache ( [ ] ) [EOL] [EOL] B . addFlag ( [string] , [string] , [string] ) [EOL] B . threshold_reached = True [EOL] self . fake_pagure . emitEvent ( B . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . fake_gerrit . addEvent ( A . addApproval ( [string] , [number] ) ) [EOL] [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( AM2 . queried , [number] ) [EOL] self . assertEqual ( A . data [ [string] ] , [string] ) [EOL] self . assertTrue ( B . is_merged ) [EOL] self . assertEqual ( A . reported , [number] ) [EOL] self . assertEqual ( len ( B . comments ) , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % B . commit_stop ) [EOL] [EOL] def test_crd_check ( self ) : [EOL] [docstring] [EOL] A = self . fake_gerrit . addFakeChange ( [string] , [string] , [string] ) [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] A . data [ [string] ] = [string] % ( A . subject , B . url ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = True [EOL] [EOL] self . fake_gerrit . addEvent ( A . getPatchsetCreatedEvent ( [number] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( self . builds [ [number] ] . hasChanges ( A , B ) ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = False [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( A . data [ [string] ] , [string] ) [EOL] self . assertFalse ( B . is_merged ) [EOL] self . assertEqual ( A . reported , [number] ) [EOL] self . assertEqual ( len ( B . comments ) , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % B . commit_stop ) [EOL] [EOL] [EOL] class TestPagureToGithubCRD ( ZuulTestCase ) : [EOL] config_file = [string] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_crd_gate ( self ) : [EOL] [docstring] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] B = self . fake_github . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [comment] [EOL] A . editInitialComment ( [string] % ( B . url ) ) [EOL] [EOL] A . addFlag ( [string] , [string] , [string] ) [EOL] A . threshold_reached = True [EOL] [EOL] [comment] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] [comment] [EOL] self . assertFalse ( A . is_merged ) [EOL] self . assertFalse ( B . is_merged ) [EOL] [EOL] for connection in self . connections . connections . values ( ) : [EOL] connection . maintainCache ( [ ] ) [EOL] [EOL] B . addLabel ( [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestCommentedEvent ( [string] ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( A . is_merged ) [EOL] self . assertTrue ( B . is_merged ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] self . assertEqual ( len ( B . comments ) , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % ( B . head_sha , A . commit_stop ) ) [EOL] [EOL] def test_crd_check ( self ) : [EOL] [docstring] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] B = self . fake_github . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] A . editInitialComment ( [string] % B . url ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = True [EOL] [EOL] self . fake_pagure . emitEvent ( A . getPullRequestUpdatedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( self . builds [ [number] ] . hasChanges ( A , B ) ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = False [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertFalse ( A . is_merged ) [EOL] self . assertFalse ( B . is_merged ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % ( B . head_sha , A . commit_stop ) ) [EOL] [EOL] [EOL] class TestGithubToPagureCRD ( ZuulTestCase ) : [EOL] config_file = [string] [EOL] tenant_config_file = [string] [EOL] [EOL] def test_crd_gate ( self ) : [EOL] [docstring] [EOL] A = self . fake_github . openFakePullRequest ( [string] , [string] , [string] ) [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] A . editBody ( [string] % B . url ) [EOL] [EOL] event = A . addLabel ( [string] ) [EOL] self . fake_github . emitEvent ( event ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertFalse ( A . is_merged ) [EOL] self . assertFalse ( B . is_merged ) [EOL] [EOL] for connection in self . connections . connections . values ( ) : [EOL] connection . maintainCache ( [ ] ) [EOL] [EOL] B . addFlag ( [string] , [string] , [string] ) [EOL] B . threshold_reached = True [EOL] self . fake_pagure . emitEvent ( B . getPullRequestCommentedEvent ( [string] ) ) [EOL] [EOL] self . fake_github . emitEvent ( event ) [EOL] [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( A . is_merged ) [EOL] self . assertTrue ( B . is_merged ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] self . assertEqual ( len ( B . comments ) , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % ( B . commit_stop , A . head_sha ) ) [EOL] [EOL] def test_crd_check ( self ) : [EOL] [docstring] [EOL] A = self . fake_github . openFakePullRequest ( [string] , [string] , [string] ) [EOL] B = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] A . editBody ( [string] % B . url ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = True [EOL] [EOL] self . fake_github . emitEvent ( A . getPullRequestEditedEvent ( ) ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertTrue ( self . builds [ [number] ] . hasChanges ( A , B ) ) [EOL] [EOL] self . executor_server . hold_jobs_in_build = False [EOL] self . executor_server . release ( ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertFalse ( A . is_merged ) [EOL] self . assertFalse ( B . is_merged ) [EOL] self . assertEqual ( len ( A . comments ) , [number] ) [EOL] self . assertEqual ( len ( B . comments ) , [number] ) [EOL] [EOL] changes = self . getJobFromHistory ( [string] , [string] ) . changes [EOL] self . assertEqual ( changes , [string] % ( B . commit_stop , A . head_sha ) ) [EOL] [EOL] [EOL] class TestPagureWebhook ( ZuulTestCase ) : [EOL] config_file = [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( TestPagureWebhook , self ) . setUp ( ) [EOL] [EOL] [comment] [EOL] self . web = self . useFixture ( ZuulWebFixture ( self . gearman_server . port , self . config , self . test_root ) ) [EOL] [EOL] host = [string] [EOL] [comment] [EOL] while True : [EOL] port = self . web . port [EOL] try : [EOL] with socket . create_connection ( ( host , port ) ) : [EOL] break [EOL] except ConnectionRefusedError : [EOL] pass [EOL] [EOL] self . fake_pagure . setZuulWebPort ( port ) [EOL] [EOL] def tearDown ( self ) : [EOL] super ( TestPagureWebhook , self ) . tearDown ( ) [EOL] [EOL] @ simple_layout ( [string] , driver = [string] ) def test_webhook ( self ) : [EOL] [EOL] A = self . fake_pagure . openFakePullRequest ( [string] , [string] , [string] ) [EOL] self . fake_pagure . emitEvent ( A . getPullRequestOpenedEvent ( ) , use_zuulweb = True , project = [string] ) [EOL] self . waitUntilSettled ( ) [EOL] [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL] self . assertEqual ( [string] , self . getJobFromHistory ( [string] ) . result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class ChangeNotFound ( Exception ) : [EOL] def __init__ ( self , number , ps ) : [EOL] self . number = number [EOL] self . ps = ps [EOL] self . change = [string] % ( str ( number ) , str ( ps ) ) [EOL] message = [string] % self . change [EOL] super ( ChangeNotFound , self ) . __init__ ( message ) [EOL] [EOL] [EOL] class RevNotFound ( Exception ) : [EOL] def __init__ ( self , project , rev ) : [EOL] self . project = project [EOL] self . revision = rev [EOL] message = ( [string] % ( self . project , self . revision ) ) [EOL] super ( RevNotFound , self ) . __init__ ( message ) [EOL] [EOL] [EOL] class MergeFailure ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ConfigurationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class AuthTokenException ( Exception ) : [EOL] defaultMsg = [string] [EOL] HTTPError = [number] [EOL] [EOL] def __init__ ( self , realm = None , msg = None ) : [EOL] super ( AuthTokenException , self ) . __init__ ( msg or self . defaultMsg ) [EOL] self . realm = realm [EOL] self . error = self . __class__ . __name__ [EOL] self . error_description = msg or self . defaultMsg [EOL] [EOL] def getAdditionalHeaders ( self ) : [EOL] return { } [EOL] [EOL] [EOL] class JWKSException ( AuthTokenException ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class AuthTokenForbiddenException ( AuthTokenException ) : [EOL] defaultMsg = [string] [EOL] HTTPError = [number] [EOL] [EOL] [EOL] class AuthTokenUnauthorizedException ( AuthTokenException ) : [EOL] defaultMsg = [string] [EOL] HTTPError = [number] [EOL] [EOL] def getAdditionalHeaders ( self ) : [EOL] error_header = [string] [EOL] return { [string] : error_header % ( self . realm , self . error , self . error_description ) } [EOL] [EOL] [EOL] class AuthTokenUndecodedException ( AuthTokenUnauthorizedException ) : [EOL] default_msg = [string] [EOL] [EOL] [EOL] class AuthTokenInvalidSignatureException ( AuthTokenUnauthorizedException ) : [EOL] default_msg = [string] [EOL] [EOL] [EOL] class BearerTokenRequiredError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class IssuerUnknownError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class MissingClaimError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class IncorrectAudienceError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class TokenExpiredError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class MissingUIDClaimError ( MissingClaimError ) : [EOL] defaultMsg = [string] [EOL] [EOL] [EOL] class IncorrectZuulAdminClaimError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = ( [string] ) [EOL] [EOL] [EOL] class UnauthorizedZuulAdminClaimError ( AuthTokenUnauthorizedException ) : [EOL] defaultMsg = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import os [EOL] import subprocess [EOL] [EOL] import pbr . packaging [EOL] [EOL] _old_from_git = pbr . packaging . _from_git [EOL] [EOL] [EOL] def _build_javascript ( ) : [EOL] if subprocess . call ( [ [string] , [string] ] ) != [number] : [EOL] return [EOL] if not os . path . exists ( [string] ) : [EOL] r = subprocess . Popen ( [ [string] , [string] , [string] ] , cwd = [string] ) . wait ( ) [EOL] if r : [EOL] raise RuntimeError ( [string] ) [EOL] if not os . path . exists ( [string] ) : [EOL] r = subprocess . Popen ( [ [string] , [string] ] , cwd = [string] ) . wait ( ) [EOL] if r : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] def _from_git ( distribution ) : [EOL] _build_javascript ( ) [EOL] return _old_from_git ( distribution ) [EOL] [EOL] [EOL] def setup_hook ( config ) : [EOL] pbr . packaging . _from_git = _from_git [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class BaseWebController ( object ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] [EOL] from zuul . executor . sensors import SensorInterface [EOL] [EOL] [EOL] class PauseSensor ( SensorInterface ) : [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . pause = False [EOL] [EOL] def isOk ( self ) : [EOL] if self . pause : [EOL] return False , [string] [EOL] else : [EOL] return True , [string] [EOL] [EOL] def reportStats ( self , statsd , base_key ) : [EOL] if self . pause : [EOL] value = [number] [EOL] else : [EOL] value = [number] [EOL] statsd . gauge ( base_key + [string] , value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import abc [EOL] [EOL] [EOL] class SensorInterface ( object , metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def isOk ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abc . abstractmethod def reportStats ( self , statsd , base_key ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import multiprocessing [EOL] import os [EOL] [EOL] from zuul . executor . sensors import SensorInterface [EOL] from zuul . lib . config import get_default [EOL] [EOL] [EOL] class CPUSensor ( SensorInterface ) : [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , config = None ) : [EOL] load_multiplier = float ( get_default ( config , [string] , [string] , [string] ) ) [EOL] self . max_load_avg = multiprocessing . cpu_count ( ) * load_multiplier [EOL] [EOL] def isOk ( self ) : [EOL] load_avg = os . getloadavg ( ) [ [number] ] [EOL] [EOL] if load_avg > self . max_load_avg : [EOL] return False , [string] . format ( load_avg , self . max_load_avg ) [EOL] [EOL] return True , [string] . format ( load_avg , self . max_load_avg ) [EOL] [EOL] def reportStats ( self , statsd , base_key ) : [EOL] load_avg = os . getloadavg ( ) [ [number] ] [EOL] statsd . gauge ( base_key + [string] , int ( load_avg * [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Type [EOL] import yaml [EOL] import typing [EOL] import yaml [EOL] from yaml import YAMLObject , YAMLError [comment] [EOL] [EOL] try : [EOL] [comment] [EOL] from yaml import cyaml [comment] [EOL] import _yaml [EOL] SafeLoader = cyaml . CSafeLoader [EOL] SafeDumper = cyaml . CSafeDumper [EOL] Mark = _yaml . Mark [EOL] except ImportError : [EOL] SafeLoader = yaml . SafeLoader [EOL] SafeDumper = yaml . SafeDumper [EOL] Mark = yaml . Mark [EOL] [EOL] [EOL] def safe_load ( stream , * args , ** kwargs ) : [EOL] return yaml . load ( stream , * args , Loader = SafeLoader , ** kwargs ) [EOL] [EOL] [EOL] def safe_dump ( stream , * args , ** kwargs ) : [EOL] return yaml . dump ( stream , * args , Dumper = SafeDumper , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[yaml.cyaml.CSafeLoader]$ 0 0 0 0 0 $typing.Type[yaml.cyaml.CDumper]$ 0 0 0 0 0 $typing.Type[yaml.error.Mark]$ 0 0 0 $typing.Type[yaml.error.Mark]$ 0 0 0 0 0 $typing.Type[yaml.cyaml.CSafeLoader]$ 0 0 0 $typing.Type[yaml.cyaml.CSafeLoader]$ 0 $typing.Type[yaml.cyaml.CDumper]$ 0 0 0 $typing.Type[yaml.cyaml.CDumper]$ 0 $typing.Type[yaml.error.Mark]$ 0 0 0 $typing.Type[yaml.error.Mark]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[yaml.cyaml.CSafeLoader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[yaml.cyaml.CDumper]$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import threading [EOL] import typing [EOL] import logging [EOL] import threading [EOL] import traceback [EOL] [EOL] import gear [EOL] [EOL] from zuul . lib . config import get_default [EOL] [EOL] [EOL] class ZuulGearWorker : [EOL] [EOL] def __init__ ( self , name , logger_name , thread_name , config , jobs , worker_class = gear . TextWorker , worker_args = None ) : [EOL] self . log = logging . getLogger ( logger_name ) [EOL] [EOL] self . _running = True [EOL] self . name = name [EOL] self . worker_class = worker_class [EOL] self . worker_args = worker_args if worker_args is not None else [ ] [EOL] [EOL] self . server = config . get ( [string] , [string] ) [EOL] self . port = get_default ( config , [string] , [string] , [number] ) [EOL] self . ssl_key = get_default ( config , [string] , [string] ) [EOL] self . ssl_cert = get_default ( config , [string] , [string] ) [EOL] self . ssl_ca = get_default ( config , [string] , [string] ) [EOL] [EOL] self . gearman = None [EOL] self . jobs = jobs [EOL] [EOL] self . thread = threading . Thread ( target = self . _run , name = thread_name ) [EOL] self . thread . daemon = True [EOL] [EOL] def start ( self ) : [EOL] gear_args = self . worker_args + [ self . name ] [EOL] self . gearman = self . worker_class ( * gear_args ) [EOL] self . log . debug ( [string] ) [EOL] self . gearman . addServer ( self . server , self . port , self . ssl_key , self . ssl_cert , self . ssl_ca , keepalive = True , tcp_keepidle = [number] , tcp_keepintvl = [number] , tcp_keepcnt = [number] ) [EOL] self . log . debug ( [string] ) [EOL] self . gearman . waitForServer ( ) [EOL] [EOL] self . log . debug ( [string] ) [EOL] for job in self . jobs : [EOL] self . gearman . registerFunction ( job ) [EOL] self . thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . _running = False [EOL] self . gearman . stopWaitingForJobs ( ) [EOL] self . thread . join ( ) [EOL] self . gearman . shutdown ( ) [EOL] [EOL] def join ( self ) : [EOL] self . thread . join ( ) [EOL] [EOL] def _run ( self ) : [EOL] while self . _running : [EOL] try : [EOL] job = self . gearman . getJob ( ) [EOL] try : [EOL] if job . name not in self . jobs : [EOL] self . log . exception ( [string] ) [EOL] job . sendWorkException ( traceback . format_exc ( ) . encode ( [string] ) ) [EOL] continue [EOL] self . jobs [ job . name ] ( job ) [EOL] except Exception : [EOL] self . log . exception ( [string] ) [EOL] job . sendWorkException ( traceback . format_exc ( ) . encode ( [string] ) ) [EOL] except gear . InterruptedError : [EOL] pass [EOL] except Exception : [EOL] self . log . exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] import logging [EOL] [EOL] [EOL] def get_annotated_logger ( logger , event , build = None ) : [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( logger , EventIdLogAdapter ) : [EOL] extra = logger . extra [EOL] else : [EOL] extra = { } [EOL] [EOL] if event is not None : [EOL] if hasattr ( event , [string] ) : [EOL] extra [ [string] ] = event . zuul_event_id [EOL] else : [EOL] extra [ [string] ] = event [EOL] [EOL] if build is not None : [EOL] extra [ [string] ] = build [EOL] [EOL] if isinstance ( logger , EventIdLogAdapter ) : [EOL] return logger [EOL] [EOL] return EventIdLogAdapter ( logger , extra ) [EOL] [EOL] [EOL] class EventIdLogAdapter ( logging . LoggerAdapter ) : [EOL] def process ( self , msg , kwargs ) : [EOL] msg , kwargs = super ( ) . process ( msg , kwargs ) [EOL] extra = kwargs . get ( [string] , { } ) [EOL] event_id = extra . get ( [string] ) [EOL] build = extra . get ( [string] ) [EOL] new_msg = [ ] [EOL] if event_id is not None : [EOL] new_msg . append ( [string] % event_id ) [EOL] if build is not None : [EOL] new_msg . append ( [string] % build ) [EOL] new_msg . append ( msg ) [EOL] msg = [string] . join ( new_msg ) [EOL] return msg , kwargs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , TextIO [EOL] import code [EOL] import zuul [EOL] import typing [EOL] import sys [EOL] import io [EOL] import threading [EOL] import socketserver [EOL] import code [EOL] [EOL] [EOL] class ThreadLocalProxy ( object ) : [EOL] def __init__ ( self , default ) : [EOL] self . files = { } [EOL] self . default = default [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] obj = self . files . get ( threading . currentThread ( ) , self . default ) [EOL] return getattr ( obj , name ) [EOL] [EOL] def register ( self , obj ) : [EOL] self . files [ threading . currentThread ( ) ] = obj [EOL] [EOL] def unregister ( self ) : [EOL] self . files . pop ( threading . currentThread ( ) ) [EOL] [EOL] [EOL] class REPLHandler ( socketserver . StreamRequestHandler ) : [EOL] def handle ( self ) : [EOL] sys . stdout . register ( io . TextIOWrapper ( self . wfile , [string] ) ) [EOL] sys . stderr . register ( io . TextIOWrapper ( self . wfile , [string] ) ) [EOL] sys . stdin . register ( io . TextIOWrapper ( self . rfile , [string] ) ) [EOL] try : [EOL] console = code . InteractiveConsole ( locals ( ) ) [EOL] console . interact ( [string] ) [EOL] except Exception : [EOL] pass [EOL] finally : [EOL] sys . stdout . unregister ( ) [EOL] sys . stderr . unregister ( ) [EOL] sys . stdin . unregister ( ) [EOL] [EOL] [EOL] class REPLThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ) : [EOL] daemon_threads = True [EOL] allow_reuse_address = True [EOL] [EOL] def __init__ ( self , scheduler , * args , ** kw ) : [EOL] self . scheduler = scheduler [EOL] super ( REPLThreadedTCPServer , self ) . __init__ ( * args , ** kw ) [EOL] sys . stdout = ThreadLocalProxy ( sys . stdout ) [EOL] sys . stderr = ThreadLocalProxy ( sys . stderr ) [EOL] sys . stdin = ThreadLocalProxy ( sys . stdin ) [EOL] [EOL] [EOL] class REPLServer ( object ) : [EOL] def __init__ ( self , scheduler ) : [EOL] self . server = REPLThreadedTCPServer ( scheduler , ( [string] , [number] ) , REPLHandler ) [EOL] [EOL] def start ( self ) : [EOL] self . thread = threading . Thread ( target = self . server . serve_forever ) [EOL] self . thread . daemon = True [EOL] self . thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . server . shutdown ( ) [EOL] self . server . server_close ( ) [EOL] self . thread . join ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $code.InteractiveConsole$ 0 0 0 0 0 0 0 0 0 0 $code.InteractiveConsole$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zuul.lib.repl.REPLThreadedTCPServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Optional , Match , Any , Dict [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import re [EOL] import jwt [EOL] [EOL] from zuul import exceptions [EOL] import zuul . driver . auth . jwt as auth_jwt [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticatorRegistry ( object ) : [EOL] [docstring] [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . authenticators = { } [EOL] self . default_realm = None [EOL] [EOL] def configure ( self , config ) : [EOL] for section_name in config . sections ( ) : [EOL] auth_match = re . match ( [string] , section_name , re . I ) [EOL] if not auth_match : [EOL] continue [EOL] auth_name = auth_match . group ( [number] ) [EOL] auth_config = dict ( config . items ( section_name ) ) [EOL] [EOL] if [string] not in auth_config : [EOL] raise Exception ( [string] % auth_name ) [EOL] [EOL] auth_driver = auth_config [ [string] ] [EOL] try : [EOL] driver = auth_jwt . get_authenticator_by_name ( auth_driver ) [EOL] except IndexError : [EOL] raise Exception ( [string] % ( auth_driver , auth_name ) ) [EOL] [comment] [EOL] self . authenticators [ auth_name ] = driver ( ** auth_config ) [EOL] if auth_config . get ( [string] , [string] ) . lower ( ) == [string] : [EOL] self . default_realm = auth_config . get ( [string] , [string] ) [EOL] if self . default_realm is None : [EOL] self . default_realm = [string] [EOL] [EOL] def authenticate ( self , rawToken ) : [EOL] unverified = jwt . decode ( rawToken , verify = False ) [EOL] for auth_name in self . authenticators : [EOL] authenticator = self . authenticators [ auth_name ] [EOL] if authenticator . issuer_id == unverified . get ( [string] , [string] ) : [EOL] return authenticator . authenticate ( rawToken ) [EOL] [comment] [EOL] raise exceptions . IssuerUnknownError ( self . default_realm ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Type , Union , Any , Set , Dict [EOL] import typing [EOL] import voluptuous as vs [EOL] [EOL] [EOL] FILE_COMMENT = { [string] : int , [string] : str , [string] : { [string] : int , [string] : int , [string] : int , [string] : int , } } [EOL] [EOL] FILE_COMMENTS = { str : [ FILE_COMMENT ] } [EOL] [EOL] FILE_COMMENTS_SCHEMA = vs . Schema ( FILE_COMMENTS ) [EOL] [EOL] [EOL] def validate ( file_comments ) : [EOL] FILE_COMMENTS_SCHEMA ( file_comments ) [EOL] [EOL] [EOL] def extractLines ( file_comments ) : [EOL] [docstring] [EOL] [EOL] lines = set ( ) [EOL] for path , comments in file_comments . items ( ) : [EOL] for comment in comments : [EOL] if [string] in comment : [EOL] lines . add ( ( path , int ( comment [ [string] ] ) ) ) [EOL] if [string] in comment : [EOL] rng = comment [ [string] ] [EOL] for key in [ [string] , [string] ] : [EOL] if key in rng : [EOL] lines . add ( ( path , int ( rng [ key ] ) ) ) [EOL] return list ( lines ) [EOL] [EOL] [EOL] def updateLines ( file_comments , lines ) : [EOL] [docstring] [EOL] [EOL] for path , comments in file_comments . items ( ) : [EOL] for comment in comments : [EOL] if [string] in comment : [EOL] comment [ [string] ] = lines . get ( ( path , comment [ [string] ] ) , comment [ [string] ] ) [EOL] if [string] in comment : [EOL] rng = comment [ [string] ] [EOL] for key in [ [string] , [string] ] : [EOL] if key in rng : [EOL] rng [ key ] = lines . get ( ( path , rng [ key ] ) , rng [ key ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] import types [EOL] [EOL] import zuul . configloader [EOL] import zuul . model [EOL] [EOL] [EOL] class ZuulJSONEncoder ( json . JSONEncoder ) : [EOL] def default ( self , o ) : [EOL] if isinstance ( o , types . MappingProxyType ) : [EOL] d = dict ( o ) [EOL] [comment] [EOL] d . pop ( [string] , None ) [EOL] d . pop ( [string] , None ) [EOL] return d [EOL] elif ( isinstance ( o , zuul . model . SourceContext ) or isinstance ( o , zuul . configloader . ZuulMark ) ) : [EOL] return { } [EOL] return json . JSONEncoder . default ( self , o ) [EOL] [EOL] [EOL] def json_dumps ( obj ) : [EOL] return json . dumps ( obj , cls = ZuulJSONEncoder ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Pattern , Any [EOL] import typing [EOL] import re [EOL] [EOL] [EOL] DEPENDS_ON_RE = re . compile ( [string] , re . MULTILINE | re . IGNORECASE ) [EOL] [EOL] [EOL] def find_dependency_headers ( message ) : [EOL] [comment] [EOL] dependencies = [ ] [EOL] for match in DEPENDS_ON_RE . findall ( message ) : [EOL] if match in dependencies : [EOL] continue [EOL] dependencies . append ( match ) [EOL] return dependencies [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import threading [EOL] import typing [EOL] import collections [EOL] import threading [EOL] [EOL] [EOL] class MergedQueue ( object ) : [EOL] def __init__ ( self ) : [EOL] self . queue = collections . deque ( ) [EOL] self . lock = threading . RLock ( ) [EOL] self . condition = threading . Condition ( self . lock ) [EOL] self . join_condition = threading . Condition ( self . lock ) [EOL] self . tasks = [number] [EOL] [EOL] def qsize ( self ) : [EOL] return len ( self . queue ) [EOL] [EOL] def empty ( self ) : [EOL] return self . qsize ( ) == [number] [EOL] [EOL] def put ( self , item ) : [EOL] [comment] [EOL] [comment] [EOL] self . condition . acquire ( ) [EOL] ret = None [EOL] try : [EOL] for x in self . queue : [EOL] if item == x : [EOL] ret = x [EOL] if hasattr ( ret , [string] ) : [EOL] ret . merge ( item ) [EOL] if ret is None : [EOL] ret = item [EOL] self . queue . append ( item ) [EOL] self . condition . notify ( ) [EOL] finally : [EOL] self . condition . release ( ) [EOL] return ret [EOL] [EOL] def get ( self ) : [EOL] self . condition . acquire ( ) [EOL] try : [EOL] while True : [EOL] try : [EOL] ret = self . queue . popleft ( ) [EOL] self . join_condition . acquire ( ) [EOL] self . tasks += [number] [EOL] self . join_condition . release ( ) [EOL] return ret [EOL] except IndexError : [EOL] self . condition . wait ( ) [EOL] finally : [EOL] self . condition . release ( ) [EOL] [EOL] def task_done ( self ) : [EOL] self . join_condition . acquire ( ) [EOL] self . tasks -= [number] [EOL] self . join_condition . notify ( ) [EOL] self . join_condition . release ( ) [EOL] [EOL] def join ( self ) : [EOL] self . join_condition . acquire ( ) [EOL] while self . tasks : [EOL] self . join_condition . wait ( ) [EOL] self . join_condition . release ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 0 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 $threading.Condition$ 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import smtplib [EOL] import email [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import smtplib [EOL] [EOL] from email . mime . text import MIMEText [EOL] [EOL] from zuul . connection import BaseConnection [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] [EOL] [EOL] class SMTPConnection ( BaseConnection ) : [EOL] driver_name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , driver , connection_name , connection_config ) : [EOL] super ( SMTPConnection , self ) . __init__ ( driver , connection_name , connection_config ) [EOL] [EOL] self . smtp_server = self . connection_config . get ( [string] , [string] ) [EOL] self . smtp_port = self . connection_config . get ( [string] , [number] ) [EOL] self . smtp_default_from = self . connection_config . get ( [string] , [string] ) [EOL] self . smtp_default_to = self . connection_config . get ( [string] , [string] ) [EOL] self . smtp_user = self . connection_config . get ( [string] ) [EOL] self . smtp_pass = self . connection_config . get ( [string] ) [EOL] starttls = self . connection_config . get ( [string] , [string] ) [EOL] if starttls . lower ( ) == [string] : [EOL] self . smtp_starttls = False [EOL] else : [EOL] self . smtp_starttls = True [EOL] [EOL] def sendMail ( self , subject , message , from_email = None , to_email = None , zuul_event_id = None ) : [EOL] [comment] [EOL] from_email = from_email \ [EOL] if from_email is not None else self . smtp_default_from [EOL] to_email = to_email if to_email is not None else self . smtp_default_to [EOL] [EOL] msg = MIMEText ( message ) [EOL] msg [ [string] ] = subject [EOL] msg [ [string] ] = from_email [EOL] msg [ [string] ] = to_email [EOL] [EOL] try : [EOL] s = smtplib . SMTP ( self . smtp_server , self . smtp_port ) [EOL] if self . smtp_starttls : [EOL] s . starttls ( ) [EOL] s . ehlo ( ) [EOL] if self . smtp_user is not None and self . smtp_pass is not None : [EOL] s . login ( self . smtp_user , self . smtp_pass ) [EOL] s . sendmail ( from_email , to_email . split ( [string] ) , msg . as_string ( ) ) [EOL] s . quit ( ) [EOL] except Exception as e : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] log . warning ( [string] , e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 0 $email.mime.text.MIMEText$ 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import voluptuous as v [EOL] [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] from zuul . reporter import BaseReporter [EOL] [EOL] [EOL] class SMTPReporter ( BaseReporter ) : [EOL] [docstring] [EOL] [EOL] name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def report ( self , item ) : [EOL] [docstring] [EOL] log = get_annotated_logger ( self . log , item . event ) [EOL] message = self . _formatItemReport ( item ) [EOL] [EOL] log . debug ( [string] , item . change , self . config , message ) [EOL] [EOL] from_email = self . config [ [string] ] \ [EOL] if [string] in self . config else None [EOL] to_email = self . config [ [string] ] \ [EOL] if [string] in self . config else None [EOL] [EOL] if [string] in self . config : [EOL] subject = self . config [ [string] ] . format ( change = item . change ) [EOL] else : [EOL] subject = [string] % item . change [EOL] [EOL] self . connection . sendMail ( subject , message , from_email , to_email , zuul_event_id = item . event ) [EOL] [EOL] [EOL] def getSchema ( ) : [EOL] smtp_reporter = v . Schema ( { [string] : str , [string] : str , [string] : str , } ) [EOL] return smtp_reporter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import re [EOL] from zuul . model import Change , TriggerEvent , EventFilter , RefFilter [EOL] [EOL] EMPTY_GIT_REF = [string] * [number] [comment] [EOL] [EOL] [EOL] class PullRequest ( Change ) : [EOL] def __init__ ( self , project ) : [EOL] super ( PullRequest , self ) . __init__ ( project ) [EOL] self . project = None [EOL] self . pr = None [EOL] self . updated_at = None [EOL] self . title = None [EOL] self . score = [number] [EOL] self . files = [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] r = [ [string] % id ( self ) ] [EOL] if self . project : [EOL] r . append ( [string] % self . project ) [EOL] if self . number : [EOL] r . append ( [string] % self . number ) [EOL] if self . patchset : [EOL] r . append ( [string] % self . patchset ) [EOL] if self . updated_at : [EOL] r . append ( [string] % self . updated_at ) [EOL] if self . status : [EOL] r . append ( [string] % self . status ) [EOL] if self . score : [EOL] r . append ( [string] % self . score ) [EOL] if self . is_merged : [EOL] r . append ( [string] ) [EOL] if self . open : [EOL] r . append ( [string] ) [EOL] return [string] . join ( r ) + [string] [EOL] [EOL] def isUpdateOf ( self , other ) : [EOL] if ( self . project == other . project and hasattr ( other , [string] ) and self . number == other . number and hasattr ( other , [string] ) and self . updated_at > other . updated_at ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class PagureTriggerEvent ( TriggerEvent ) : [EOL] def __init__ ( self ) : [EOL] super ( PagureTriggerEvent , self ) . __init__ ( ) [EOL] self . trigger_name = [string] [EOL] self . title = None [EOL] self . action = None [EOL] self . status = None [EOL] [EOL] def _repr ( self ) : [EOL] r = [ super ( PagureTriggerEvent , self ) . _repr ( ) ] [EOL] if self . action : [EOL] r . append ( [string] % self . action ) [EOL] if self . status : [EOL] r . append ( [string] % self . status ) [EOL] r . append ( [string] % self . canonical_project_name ) [EOL] if self . change_number : [EOL] r . append ( [string] % self . change_number ) [EOL] return [string] . join ( r ) [EOL] [EOL] def isPatchsetCreated ( self ) : [EOL] if self . type == [string] : [EOL] return self . action in [ [string] , [string] ] [EOL] return False [EOL] [EOL] [EOL] class PagureEventFilter ( EventFilter ) : [EOL] def __init__ ( self , trigger , types = [ ] , refs = [ ] , statuses = [ ] , comments = [ ] , actions = [ ] , ignore_deletes = True ) : [EOL] [EOL] EventFilter . __init__ ( self , trigger ) [EOL] [EOL] self . _types = types [EOL] self . _refs = refs [EOL] self . _comments = comments [EOL] self . types = [ re . compile ( x ) for x in types ] [EOL] self . refs = [ re . compile ( x ) for x in refs ] [EOL] self . comments = [ re . compile ( x ) for x in comments ] [EOL] self . actions = actions [EOL] self . statuses = statuses [EOL] self . ignore_deletes = ignore_deletes [EOL] [EOL] def __repr__ ( self ) : [EOL] ret = [string] [EOL] [EOL] if self . _types : [EOL] ret += [string] % [string] . join ( self . _types ) [EOL] if self . _refs : [EOL] ret += [string] % [string] . join ( self . _refs ) [EOL] if self . ignore_deletes : [EOL] ret += [string] % self . ignore_deletes [EOL] if self . _comments : [EOL] ret += [string] % [string] . join ( self . _comments ) [EOL] if self . actions : [EOL] ret += [string] % [string] . join ( self . actions ) [EOL] if self . statuses : [EOL] ret += [string] % [string] . join ( self . statuses ) [EOL] ret += [string] [EOL] [EOL] return ret [EOL] [EOL] def matches ( self , event , change ) : [EOL] matches_type = False [EOL] for etype in self . types : [EOL] if etype . match ( event . type ) : [EOL] matches_type = True [EOL] if self . types and not matches_type : [EOL] return False [EOL] [EOL] matches_ref = False [EOL] if event . ref is not None : [EOL] for ref in self . refs : [EOL] if ref . match ( event . ref ) : [EOL] matches_ref = True [EOL] if self . refs and not matches_ref : [EOL] return False [EOL] if self . ignore_deletes and event . newrev == EMPTY_GIT_REF : [EOL] [comment] [EOL] [comment] [EOL] return False [EOL] [EOL] matches_comment_re = False [EOL] for comment_re in self . comments : [EOL] if ( event . comment is not None and comment_re . search ( event . comment ) ) : [EOL] matches_comment_re = True [EOL] if self . comments and not matches_comment_re : [EOL] return False [EOL] [EOL] matches_action = False [EOL] for action in self . actions : [EOL] if ( event . action == action ) : [EOL] matches_action = True [EOL] if self . actions and not matches_action : [EOL] return False [EOL] [EOL] matches_status = False [EOL] for status in self . statuses : [EOL] if event . status == status : [EOL] matches_status = True [EOL] if self . statuses and not matches_status : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class PagureRefFilter ( RefFilter ) : [EOL] def __init__ ( self , connection_name , score = None , open = None , merged = None , status = None ) : [EOL] RefFilter . __init__ ( self , connection_name ) [EOL] self . score = score [EOL] self . open = open [EOL] self . merged = merged [EOL] self . status = status [EOL] [EOL] def __repr__ ( self ) : [EOL] ret = [string] % self . connection_name [EOL] if self . score : [EOL] ret += [string] % self . score [EOL] if self . open is not None : [EOL] ret += [string] % self . open [EOL] if self . merged is not None : [EOL] ret += [string] % self . merged [EOL] if self . status is not None : [EOL] ret += [string] % self . status [EOL] ret += [string] [EOL] return ret [EOL] [EOL] def matches ( self , change ) : [EOL] if self . score is not None : [EOL] if change . score < self . score : [EOL] return False [EOL] [EOL] if self . open is not None : [EOL] if change . open != self . open : [EOL] return False [EOL] [EOL] if self . merged is not None : [EOL] if change . is_merged != self . merged : [EOL] return False [EOL] [EOL] if self . status is not None : [EOL] if change . status != self . status : [EOL] return False [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Type , Union , Any , Set , Tuple , Dict [EOL] import threading [EOL] import zuul [EOL] import requests [EOL] import typing [EOL] import logging [EOL] import hmac [EOL] import hashlib [EOL] import queue [EOL] import threading [EOL] import time [EOL] import json [EOL] import requests [EOL] import cherrypy [EOL] import traceback [EOL] import voluptuous as v [EOL] [EOL] import gear [EOL] [EOL] from zuul . connection import BaseConnection [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] from zuul . web . handler import BaseWebController [EOL] from zuul . lib . config import get_default [EOL] from zuul . model import Ref , Branch , Tag [EOL] from zuul . lib import dependson [EOL] [EOL] from zuul . driver . pagure . paguremodel import PagureTriggerEvent , PullRequest [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _sign_request ( body , secret ) : [EOL] signature = hmac . new ( secret . encode ( [string] ) , body , hashlib . sha1 ) . hexdigest ( ) [EOL] return signature , body [EOL] [EOL] [EOL] class PagureGearmanWorker ( object ) : [EOL] [docstring] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , connection ) : [EOL] self . config = connection . sched . config [EOL] self . connection = connection [EOL] self . thread = threading . Thread ( target = self . _run , name = [string] ) [EOL] self . _running = False [EOL] handler = [string] % self . connection . connection_name [EOL] self . jobs = { handler : self . handle_payload , } [EOL] [EOL] def _run ( self ) : [EOL] while self . _running : [EOL] try : [EOL] job = self . gearman . getJob ( ) [EOL] try : [EOL] if job . name not in self . jobs : [EOL] self . log . exception ( [string] ) [EOL] job . sendWorkException ( traceback . format_exc ( ) . encode ( [string] ) ) [EOL] continue [EOL] output = self . jobs [ job . name ] ( json . loads ( job . arguments ) ) [EOL] job . sendWorkComplete ( json . dumps ( output ) ) [EOL] except Exception : [EOL] self . log . exception ( [string] ) [EOL] job . sendWorkException ( traceback . format_exc ( ) . encode ( [string] ) ) [EOL] except gear . InterruptedError : [EOL] pass [EOL] except Exception : [EOL] self . log . exception ( [string] ) [EOL] [EOL] def handle_payload ( self , args ) : [EOL] payload = args [ [string] ] [EOL] [EOL] self . log . info ( [string] % ( [EOL] payload) ) [EOL] [EOL] try : [EOL] self . __dispatch_event ( payload ) [EOL] output = { [string] : [number] } [EOL] except Exception : [EOL] output = { [string] : [number] } [EOL] self . log . exception ( [string] ) [EOL] [EOL] return output [EOL] [EOL] def __dispatch_event ( self , payload ) : [EOL] event = payload [ [string] ] [EOL] try : [EOL] self . log . info ( [string] % event ) [EOL] self . connection . addEvent ( payload , event ) [EOL] except Exception as err : [EOL] message = [string] % str ( err ) [EOL] self . log . exception ( message ) [EOL] raise Exception ( message ) [EOL] [EOL] def start ( self ) : [EOL] self . _running = True [EOL] server = self . config . get ( [string] , [string] ) [EOL] port = get_default ( self . config , [string] , [string] , [number] ) [EOL] ssl_key = get_default ( self . config , [string] , [string] ) [EOL] ssl_cert = get_default ( self . config , [string] , [string] ) [EOL] ssl_ca = get_default ( self . config , [string] , [string] ) [EOL] self . gearman = gear . TextWorker ( [string] ) [EOL] self . log . debug ( [string] ) [EOL] self . gearman . addServer ( server , port , ssl_key , ssl_cert , ssl_ca ) [EOL] self . log . debug ( [string] ) [EOL] self . gearman . waitForServer ( ) [EOL] self . log . debug ( [string] ) [EOL] for job in self . jobs : [EOL] self . gearman . registerFunction ( job ) [EOL] self . thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . _running = False [EOL] self . gearman . stopWaitingForJobs ( ) [EOL] [comment] [EOL] [comment] [EOL] self . thread . join ( timeout = [number] ) [EOL] self . gearman . shutdown ( ) [EOL] [EOL] [EOL] class PagureEventConnector ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , connection ) : [EOL] super ( PagureEventConnector , self ) . __init__ ( ) [EOL] self . daemon = True [EOL] self . connection = connection [EOL] self . _stopped = False [EOL] self . event_handler_mapping = { [string] : self . _event_issue_comment , [string] : self . _event_pull_request , [string] : self . _event_flag_added , [string] : self . _event_ref_updated , } [EOL] [EOL] def stop ( self ) : [EOL] self . _stopped = True [EOL] self . connection . addEvent ( None ) [EOL] [EOL] def _handleEvent ( self ) : [EOL] ts , json_body , event_type = self . connection . getEvent ( ) [EOL] if self . _stopped : [EOL] return [EOL] [EOL] self . log . info ( [string] % str ( event_type ) ) [EOL] [comment] [EOL] [EOL] if event_type not in self . event_handler_mapping : [EOL] message = [string] % event_type [EOL] self . log . info ( message ) [EOL] return [EOL] [EOL] if event_type in self . event_handler_mapping : [EOL] self . log . debug ( [string] % event_type ) [EOL] [EOL] try : [EOL] event = self . event_handler_mapping [ event_type ] ( json_body ) [EOL] except Exception : [EOL] self . log . exception ( [string] % event_type ) [EOL] event = None [EOL] [EOL] if event : [EOL] event . timestamp = ts [EOL] if event . change_number : [EOL] project = self . connection . source . getProject ( event . project_name ) [EOL] self . connection . _getChange ( project , event . change_number , event . patch_number , refresh = True , url = event . change_url , event = event ) [EOL] event . project_hostname = self . connection . canonical_hostname [EOL] self . connection . logEvent ( event ) [EOL] self . connection . sched . addEvent ( event ) [EOL] [EOL] def _event_base ( self , body ) : [EOL] event = PagureTriggerEvent ( ) [EOL] if [string] in body [ [string] ] : [EOL] data = body [ [string] ] [ [string] ] [EOL] data [ [string] ] = body [ [string] ] . get ( [string] ) [EOL] event . title = data . get ( [string] ) [EOL] event . project_name = data . get ( [string] , { } ) . get ( [string] ) [EOL] event . change_number = data . get ( [string] ) [EOL] event . updated_at = data . get ( [string] ) [EOL] event . branch = data . get ( [string] ) [EOL] event . change_url = self . connection . getPullUrl ( event . project_name , event . change_number ) [EOL] event . ref = [string] % event . change_number [EOL] [comment] [EOL] event . patch_number = data . get ( [string] ) [EOL] event . type = [string] [EOL] else : [EOL] data = body [ [string] ] [EOL] event . type = [string] [EOL] return event , data [EOL] [EOL] def _event_issue_comment ( self , body ) : [EOL] [docstring] [EOL] [comment] [EOL] event , data = self . _event_base ( body ) [EOL] last_comment = data . get ( [string] , [ ] ) [ - [number] ] [EOL] if last_comment . get ( [string] ) is True : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] event . action = [string] [EOL] else : [EOL] if last_comment . get ( [string] , [string] ) . find ( [string] ) >= [number] : [EOL] event . action = [string] [EOL] event . type = [string] [EOL] elif last_comment . get ( [string] , [string] ) . find ( [string] ) >= [number] : [EOL] event . action = [string] [EOL] event . type = [string] [EOL] else : [EOL] event . action = [string] [EOL] [comment] [EOL] event . comment = last_comment . get ( [string] ) [EOL] return event [EOL] [EOL] def _event_pull_request ( self , body ) : [EOL] [docstring] [EOL] [comment] [EOL] event , data = self . _event_base ( body ) [EOL] event . action = [string] [EOL] return event [EOL] [EOL] def _event_flag_added ( self , body ) : [EOL] [docstring] [EOL] [comment] [EOL] event , data = self . _event_base ( body ) [EOL] event . status = data [ [string] ] [ [string] ] [EOL] event . action = [string] [EOL] return event [EOL] [EOL] def _event_ref_updated ( self , body ) : [EOL] [docstring] [EOL] [comment] [EOL] event , data = self . _event_base ( body ) [EOL] event . project_name = data . get ( [string] ) [EOL] event . branch = data . get ( [string] ) [EOL] event . ref = [string] % event . branch [EOL] event . newrev = data . get ( [string] , data . get ( [string] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] event . branch_updated = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return event [EOL] [EOL] def run ( self ) : [EOL] while True : [EOL] if self . _stopped : [EOL] return [EOL] try : [EOL] self . _handleEvent ( ) [EOL] except Exception : [EOL] self . log . exception ( [string] ) [EOL] finally : [EOL] self . connection . eventDone ( ) [EOL] [EOL] [EOL] class PagureAPIClient ( ) : [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , baseurl , api_token , project , token_exp_date = None ) : [EOL] self . session = requests . Session ( ) [EOL] self . base_url = [string] % baseurl [EOL] self . api_token = api_token [EOL] self . project = project [EOL] self . headers = { [string] : [string] % self . api_token } [EOL] self . token_exp_date = token_exp_date [EOL] [EOL] def is_expired ( self ) : [EOL] if self . token_exp_date : [EOL] if int ( time . time ( ) ) > ( self . token_exp_date - [number] ) : [EOL] return True [EOL] return False [EOL] [EOL] def get ( self , url ) : [EOL] self . log . debug ( [string] % url ) [EOL] ret = self . session . get ( url , headers = self . headers ) [EOL] self . log . debug ( [string] % ( ret . status_code , ret . text ) ) [EOL] return ret . json ( ) [EOL] [EOL] def post ( self , url , params = None ) : [EOL] self . log . info ( [string] % ( url , params ) ) [EOL] ret = self . session . post ( url , data = params , headers = self . headers ) [EOL] self . log . debug ( [string] % ( ret . status_code , ret . text ) ) [EOL] return ret . json ( ) [EOL] [EOL] def get_project_branches ( self ) : [EOL] path = [string] % self . project [EOL] return self . get ( self . base_url + path ) . get ( [string] , [ ] ) [EOL] [EOL] def get_pr ( self , number ) : [EOL] path = [string] % ( self . project , number ) [EOL] return self . get ( self . base_url + path ) [EOL] [EOL] def get_pr_diffstats ( self , number ) : [EOL] path = [string] % ( self . project , number ) [EOL] return self . get ( self . base_url + path ) [EOL] [EOL] def get_pr_flags ( self , number , last = False ) : [EOL] path = [string] % ( self . project , number ) [EOL] data = self . get ( self . base_url + path ) [EOL] if last : [EOL] if data [ [string] ] : [EOL] return data [ [string] ] [ [number] ] [EOL] else : [EOL] return { } [EOL] else : [EOL] return data [ [string] ] [EOL] [EOL] def set_pr_flag ( self , number , status , url , description ) : [EOL] params = { [string] : [string] , [string] : [string] % status , [string] : status , [string] : url } [EOL] path = [string] % ( self . project , number ) [EOL] return self . post ( self . base_url + path , params ) [EOL] [EOL] def comment_pull ( self , number , message ) : [EOL] params = { [string] : message } [EOL] path = [string] % ( self . project , number ) [EOL] return self . post ( self . base_url + path , params ) [EOL] [EOL] def merge_pr ( self , number ) : [EOL] path = [string] % ( self . project , number ) [EOL] return self . post ( self . base_url + path ) [EOL] [EOL] def create_project_api_token ( self ) : [EOL] [docstring] [EOL] param = { [string] : [string] % int ( time . time ( ) ) , [string] : [ [string] , [string] , [string] ] } [EOL] path = [string] % self . project [EOL] data = self . post ( self . base_url + path , param ) [EOL] [comment] [EOL] return data [ [string] ] [EOL] [EOL] def get_connectors ( self ) : [EOL] [docstring] [EOL] def get_token_epoch ( token ) : [EOL] return int ( token [ [string] ] . split ( [string] ) [ - [number] ] ) [EOL] [EOL] path = [string] % self . project [EOL] data = self . get ( self . base_url + path ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tokens = [ token for token in data [ [string] ] . get ( [string] , { } ) if not token [ [string] ] ] [EOL] [comment] [EOL] [comment] [EOL] api_token = None [EOL] for token in tokens : [EOL] if not token [ [string] ] . startswith ( [string] ) : [EOL] continue [EOL] epoch = get_token_epoch ( token ) [EOL] if api_token : [EOL] if epoch > get_token_epoch ( api_token ) : [EOL] api_token = token [EOL] else : [EOL] api_token = token [EOL] if not api_token : [EOL] [comment] [EOL] api_token = self . create_project_api_token ( ) [EOL] api_token [ [string] ] = get_token_epoch ( api_token ) [EOL] webhook_token = data [ [string] ] [ [string] ] [EOL] return api_token , webhook_token [EOL] [EOL] [EOL] class PagureConnection ( BaseConnection ) : [EOL] driver_name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] payload_path = [string] [EOL] [EOL] def __init__ ( self , driver , connection_name , connection_config ) : [EOL] super ( PagureConnection , self ) . __init__ ( driver , connection_name , connection_config ) [EOL] self . _change_cache = { } [EOL] self . project_branch_cache = { } [EOL] self . projects = { } [EOL] self . server = self . connection_config . get ( [string] , [string] ) [EOL] self . canonical_hostname = self . connection_config . get ( [string] , self . server ) [EOL] self . git_ssh_key = self . connection_config . get ( [string] ) [EOL] self . admin_api_token = self . connection_config . get ( [string] ) [EOL] self . baseurl = self . connection_config . get ( [string] , [string] % self . server ) . rstrip ( [string] ) [EOL] self . cloneurl = self . connection_config . get ( [string] , self . baseurl ) . rstrip ( [string] ) [EOL] self . connectors = { } [EOL] self . source = driver . getSource ( self ) [EOL] self . event_queue = queue . Queue ( ) [EOL] [EOL] self . sched = None [EOL] [EOL] def onLoad ( self ) : [EOL] self . log . info ( [string] % self . connection_name ) [EOL] self . gearman_worker = PagureGearmanWorker ( self ) [EOL] self . log . info ( [string] ) [EOL] self . _start_event_connector ( ) [EOL] self . log . info ( [string] ) [EOL] self . gearman_worker . start ( ) [EOL] [EOL] def _start_event_connector ( self ) : [EOL] self . pagure_event_connector = PagureEventConnector ( self ) [EOL] self . pagure_event_connector . start ( ) [EOL] [EOL] def _stop_event_connector ( self ) : [EOL] if self . pagure_event_connector : [EOL] self . pagure_event_connector . stop ( ) [EOL] self . pagure_event_connector . join ( ) [EOL] [EOL] def onStop ( self ) : [EOL] if hasattr ( self , [string] ) : [EOL] self . gearman_worker . stop ( ) [EOL] self . _stop_event_connector ( ) [EOL] [EOL] def addEvent ( self , data , event = None ) : [EOL] return self . event_queue . put ( ( time . time ( ) , data , event ) ) [EOL] [EOL] def getEvent ( self ) : [EOL] return self . event_queue . get ( ) [EOL] [EOL] def eventDone ( self ) : [EOL] self . event_queue . task_done ( ) [EOL] [EOL] def _refresh_project_connectors ( self , project ) : [EOL] pagure = PagureAPIClient ( self . baseurl , self . admin_api_token , project ) [EOL] api_token , webhook_token = pagure . get_connectors ( ) [EOL] connector = self . connectors . setdefault ( project , { [string] : None , [string] : None } ) [EOL] api_token_exp_date = api_token [ [string] ] + [number] * [number] * [number] [EOL] connector [ [string] ] = PagureAPIClient ( self . baseurl , api_token [ [string] ] , project , token_exp_date = api_token_exp_date ) [EOL] connector [ [string] ] = webhook_token [EOL] return connector [EOL] [EOL] def get_project_webhook_token ( self , project ) : [EOL] token = self . connectors . get ( project , { } ) . get ( [string] , None ) [EOL] if token : [EOL] self . log . debug ( [string] % project ) [EOL] return token [EOL] else : [EOL] self . log . debug ( [string] % project ) [EOL] return self . _refresh_project_connectors ( project ) [ [string] ] [EOL] [EOL] def get_project_api_client ( self , project ) : [EOL] api_client = self . connectors . get ( project , { } ) . get ( [string] , None ) [EOL] if api_client : [EOL] if not api_client . is_expired ( ) : [EOL] self . log . debug ( [string] % project ) [EOL] return api_client [EOL] else : [EOL] self . log . debug ( [string] % ( project , api_client . token_exp_date ) ) [EOL] self . log . debug ( [string] % project ) [EOL] return self . _refresh_project_connectors ( project ) [ [string] ] [EOL] [EOL] def maintainCache ( self , relevant ) : [EOL] remove = set ( ) [EOL] for key , change in self . _change_cache . items ( ) : [EOL] if change not in relevant : [EOL] remove . add ( key ) [EOL] for key in remove : [EOL] del self . _change_cache [ key ] [EOL] [EOL] def clearBranchCache ( self ) : [EOL] self . project_branch_cache = { } [EOL] [EOL] def getWebController ( self , zuul_web ) : [EOL] return PagureWebController ( zuul_web , self ) [EOL] [EOL] def validateWebConfig ( self , config , connections ) : [EOL] return True [EOL] [EOL] def getProject ( self , name ) : [EOL] return self . projects . get ( name ) [EOL] [EOL] def addProject ( self , project ) : [EOL] self . projects [ project . name ] = project [EOL] [EOL] def getPullUrl ( self , project , number ) : [EOL] return [string] % ( self . getGitwebUrl ( project ) , number ) [EOL] [EOL] def getGitwebUrl ( self , project , sha = None ) : [EOL] url = [string] % ( self . baseurl , project ) [EOL] if sha is not None : [EOL] url += [string] % sha [EOL] return url [EOL] [EOL] def getProjectBranches ( self , project , tenant ) : [EOL] branches = self . project_branch_cache . get ( project . name ) [EOL] [EOL] if branches is not None : [EOL] return branches [EOL] [EOL] pagure = self . get_project_api_client ( project . name ) [EOL] branches = pagure . get_project_branches ( ) [EOL] self . project_branch_cache [ project . name ] = branches [EOL] [EOL] self . log . info ( [string] % project . name ) [EOL] return branches [EOL] [EOL] def getGitUrl ( self , project ) : [EOL] return [string] % ( self . cloneurl , project . name ) [EOL] [EOL] def getChange ( self , event , refresh = False ) : [EOL] project = self . source . getProject ( event . project_name ) [EOL] if event . change_number : [EOL] self . log . info ( [string] % ( project , event . change_number ) ) [EOL] change = self . _getChange ( project , event . change_number , event . patch_number , refresh = refresh , event = event ) [EOL] change . source_event = event [EOL] change . is_current_patchset = ( change . pr . get ( [string] ) == event . patch_number ) [EOL] else : [EOL] self . log . info ( [string] % ( project , event . ref ) ) [EOL] if event . ref and event . ref . startswith ( [string] ) : [EOL] change = Tag ( project ) [EOL] change . tag = event . ref [ len ( [string] ) : ] [EOL] elif event . ref and event . ref . startswith ( [string] ) : [EOL] change = Branch ( project ) [EOL] change . branch = event . ref [ len ( [string] ) : ] [EOL] else : [EOL] change = Ref ( project ) [EOL] change . ref = event . ref [EOL] change . oldrev = event . oldrev [EOL] change . newrev = event . newrev [EOL] change . branch = event . branch [EOL] change . url = self . getGitwebUrl ( project , sha = event . newrev ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] change . files = None [EOL] [EOL] change . source_event = event [EOL] return change [EOL] [EOL] def _getChange ( self , project , number , patchset = None , refresh = False , url = None , event = None ) : [EOL] key = ( project . name , number , patchset ) [EOL] change = self . _change_cache . get ( key ) [EOL] if change and not refresh : [EOL] self . log . debug ( [string] % str ( key ) ) [EOL] return change [EOL] if not change : [EOL] change = PullRequest ( project . name ) [EOL] change . project = project [EOL] change . number = number [EOL] [comment] [EOL] change . patchset = patchset [EOL] change . url = url [EOL] change . uris = [ [string] % ( self . baseurl , project , number ) , ] [EOL] self . _change_cache [ key ] = change [EOL] try : [EOL] self . log . debug ( [string] % ( number , project . name ) ) [EOL] self . _updateChange ( change , event ) [EOL] except Exception : [EOL] if key in self . _change_cache : [EOL] del self . _change_cache [ key ] [EOL] raise [EOL] return change [EOL] [EOL] def _hasRequiredStatusChecks ( self , change ) : [EOL] pagure = self . get_project_api_client ( change . project . name ) [EOL] flag = pagure . get_pr_flags ( change . number , last = True ) [EOL] return True if flag . get ( [string] , [string] ) == [string] else False [EOL] [EOL] def canMerge ( self , change , allow_needs , event = None ) : [EOL] log = get_annotated_logger ( self . log , event ) [EOL] pagure = self . get_project_api_client ( change . project . name ) [EOL] pr = pagure . get_pr ( change . number ) [EOL] [EOL] mergeable = False [EOL] if pr . get ( [string] ) in ( [string] , [string] ) : [EOL] mergeable = True [EOL] [EOL] ci_flag = False [EOL] if self . _hasRequiredStatusChecks ( change ) : [EOL] ci_flag = True [EOL] [EOL] threshold = pr . get ( [string] ) [EOL] if threshold is None : [EOL] self . log . debug ( [string] ) [EOL] [EOL] log . debug ( [string] [string] , change . project . name , change . number , mergeable , ci_flag , threshold ) [EOL] [EOL] can_merge = mergeable and ci_flag and threshold [EOL] [EOL] log . info ( [string] , change . project . name , change . number , can_merge ) [EOL] return can_merge [EOL] [EOL] def getPull ( self , project_name , number ) : [EOL] pagure = self . get_project_api_client ( project_name ) [EOL] pr = pagure . get_pr ( number ) [EOL] diffstats = pagure . get_pr_diffstats ( number ) [EOL] pr [ [string] ] = diffstats . keys ( ) [EOL] self . log . info ( [string] , project_name , number ) [EOL] return pr [EOL] [EOL] def getStatus ( self , project , number ) : [EOL] return self . getCommitStatus ( project . name , number ) [EOL] [EOL] def getScore ( self , pr ) : [EOL] score_board = { } [EOL] last_pr_code_updated = [number] [EOL] [comment] [EOL] for comment in pr . get ( [string] , [ ] ) : [EOL] [comment] [EOL] if comment [ [string] ] : [EOL] date = int ( comment [ [string] ] ) [EOL] if date > last_pr_code_updated : [EOL] last_pr_code_updated = date [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for comment in pr . get ( [string] , [ ] ) : [EOL] author = comment [ [string] ] [ [string] ] [EOL] date = int ( comment [ [string] ] ) [EOL] [comment] [EOL] if date >= last_pr_code_updated : [EOL] score_board . setdefault ( author , [number] ) [EOL] [comment] [EOL] if comment . get ( [string] , [string] ) . find ( [string] ) >= [number] : [EOL] score_board [ author ] += [number] [EOL] if comment . get ( [string] , [string] ) . find ( [string] ) >= [number] : [EOL] score_board [ author ] -= [number] [EOL] return sum ( score_board . values ( ) ) [EOL] [EOL] def _updateChange ( self , change , event ) : [EOL] self . log . info ( [string] % change ) [EOL] change . pr = self . getPull ( change . project . name , change . number ) [EOL] change . ref = [string] % change . number [EOL] change . branch = change . pr . get ( [string] ) [EOL] change . patchset = change . pr . get ( [string] ) [EOL] change . files = change . pr . get ( [string] ) [EOL] change . title = change . pr . get ( [string] ) [EOL] change . open = change . pr . get ( [string] ) == [string] [EOL] change . is_merged = change . pr . get ( [string] ) == [string] [EOL] change . status = self . getStatus ( change . project , change . number ) [EOL] change . score = self . getScore ( change . pr ) [EOL] change . message = change . pr . get ( [string] ) or [string] [EOL] [comment] [EOL] change . updated_at = change . pr . get ( [string] ) [EOL] self . log . info ( [string] % change ) [EOL] [EOL] if self . sched : [EOL] self . sched . onChangeUpdated ( change , event ) [EOL] [EOL] return change [EOL] [EOL] def commentPull ( self , project , number , message ) : [EOL] pagure = self . get_project_api_client ( project ) [EOL] pagure . comment_pull ( number , message ) [EOL] self . log . info ( [string] , project , number ) [EOL] [EOL] def setCommitStatus ( self , project , number , state , url = [string] , description = [string] , context = [string] ) : [EOL] pagure = self . get_project_api_client ( project ) [EOL] pagure . set_pr_flag ( number , state , url , description ) [EOL] self . log . info ( [string] % description ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] def getCommitStatus ( self , project , number ) : [EOL] pagure = self . get_project_api_client ( project ) [EOL] flag = pagure . get_pr_flags ( number , last = True ) [EOL] self . log . info ( [string] % ( number , project , flag . get ( [string] ) ) ) [EOL] return flag . get ( [string] ) [EOL] [EOL] def getChangesDependingOn ( self , change , projects , tenant ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] changes_dependencies = [ ] [EOL] for cached_change_id , _change in self . _change_cache . items ( ) : [EOL] for dep_header in dependson . find_dependency_headers ( _change . message ) : [EOL] if change . url in dep_header : [EOL] changes_dependencies . append ( _change ) [EOL] return changes_dependencies [EOL] [EOL] def mergePull ( self , project , number ) : [EOL] pagure = self . get_project_api_client ( project ) [EOL] pagure . merge_pr ( number ) [EOL] self . log . debug ( [string] , project , number ) [EOL] [EOL] [EOL] class PagureWebController ( BaseWebController ) : [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , zuul_web , connection ) : [EOL] self . connection = connection [EOL] self . zuul_web = zuul_web [EOL] [EOL] def _validate_signature ( self , body , headers ) : [EOL] try : [EOL] request_signature = headers [ [string] ] [EOL] except KeyError : [EOL] raise cherrypy . HTTPError ( [number] , [string] ) [EOL] [EOL] project = headers [ [string] ] [EOL] token = self . connection . get_project_webhook_token ( project ) [EOL] if not token : [EOL] raise cherrypy . HTTPError ( [number] , [string] % project ) [EOL] [EOL] signature , payload = _sign_request ( body , token ) [EOL] [EOL] if not hmac . compare_digest ( str ( signature ) , str ( request_signature ) ) : [EOL] self . log . debug ( [string] % ( signature , request_signature ) ) [EOL] raise cherrypy . HTTPError ( [number] , [string] [string] ) [EOL] [EOL] return payload [EOL] [EOL] @ cherrypy . expose @ cherrypy . tools . json_out ( content_type = [string] ) def payload ( self ) : [EOL] [comment] [EOL] headers = dict ( ) [EOL] for key , value in cherrypy . request . headers . items ( ) : [EOL] headers [ key . lower ( ) ] = value [EOL] body = cherrypy . request . body . read ( ) [EOL] payload = self . _validate_signature ( body , headers ) [EOL] json_payload = json . loads ( payload . decode ( [string] ) ) [EOL] [EOL] job = self . zuul_web . rpc . submitJob ( [string] % self . connection . connection_name , { [string] : json_payload } ) [EOL] [EOL] return json . loads ( job . data [ [number] ] ) [EOL] [EOL] [EOL] def getSchema ( ) : [EOL] pagure_connection = v . Any ( str , v . Schema ( dict ) ) [EOL] return pagure_connection [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type [EOL] import zuul [EOL] import typing [EOL] import time [EOL] import logging [EOL] import voluptuous as v [EOL] [EOL] from zuul . reporter import BaseReporter [EOL] from zuul . exceptions import MergeFailure [EOL] from zuul . driver . pagure . paguresource import PagureSource [EOL] [EOL] [EOL] class PagureReporter ( BaseReporter ) : [EOL] [docstring] [EOL] [EOL] name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , driver , connection , pipeline , config = None ) : [EOL] super ( PagureReporter , self ) . __init__ ( driver , connection , config ) [EOL] self . _commit_status = self . config . get ( [string] , None ) [EOL] self . _create_comment = self . config . get ( [string] , True ) [EOL] self . _merge = self . config . get ( [string] , False ) [EOL] self . context = [string] . format ( pipeline . tenant . name , pipeline . name ) [EOL] [EOL] def report ( self , item ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if not isinstance ( item . change . project . source , PagureSource ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if item . change . project . source . connection . canonical_hostname != self . connection . canonical_hostname : [EOL] return [EOL] [EOL] if self . _commit_status is not None : [EOL] if ( hasattr ( item . change , [string] ) and item . change . patchset is not None ) : [EOL] self . setCommitStatus ( item ) [EOL] elif ( hasattr ( item . change , [string] ) and item . change . newrev is not None ) : [EOL] self . setCommitStatus ( item ) [EOL] if hasattr ( item . change , [string] ) : [EOL] if self . _create_comment : [EOL] self . addPullComment ( item ) [EOL] if self . _merge : [EOL] self . mergePull ( item ) [EOL] if not item . change . is_merged : [EOL] msg = self . _formatItemReportMergeFailure ( item ) [EOL] self . addPullComment ( item , msg ) [EOL] [EOL] def _formatItemReportJobs ( self , item ) : [EOL] [comment] [EOL] ret = [string] [EOL] jobs_fields = self . _getItemReportJobsFields ( item ) [EOL] for job_fields in jobs_fields : [EOL] ret += [string] % job_fields [EOL] return ret [EOL] [EOL] def addPullComment ( self , item , comment = None ) : [EOL] message = comment or self . _formatItemReport ( item ) [EOL] project = item . change . project . name [EOL] pr_number = item . change . number [EOL] self . log . debug ( [string] % ( item . change , self . config , message ) ) [EOL] self . connection . commentPull ( project , pr_number , message ) [EOL] [EOL] def setCommitStatus ( self , item ) : [EOL] project = item . change . project . name [EOL] if hasattr ( item . change , [string] ) : [EOL] sha = item . change . patchset [EOL] elif hasattr ( item . change , [string] ) : [EOL] sha = item . change . newrev [EOL] state = self . _commit_status [EOL] change_number = item . change . number [EOL] [EOL] url_pattern = self . config . get ( [string] ) [EOL] sched_config = self . connection . sched . config [EOL] if sched_config . has_option ( [string] , [string] ) : [EOL] url_pattern = sched_config . get ( [string] , [string] ) [EOL] url = item . formatUrlPattern ( url_pattern ) \ [EOL] if url_pattern else [string] [EOL] [EOL] description = [string] % ( item . pipeline . name , self . _commit_status , sha ) [EOL] [EOL] self . log . debug ( [string] [string] % ( item . change , self . config , self . context , state , description , url ) ) [EOL] [EOL] self . connection . setCommitStatus ( project , change_number , state , url , description , self . context ) [EOL] [EOL] def mergePull ( self , item ) : [EOL] project = item . change . project . name [EOL] pr_number = item . change . number [EOL] [EOL] for i in [ [number] , [number] ] : [EOL] try : [EOL] self . connection . mergePull ( project , pr_number ) [EOL] item . change . is_merged = True [EOL] return [EOL] except MergeFailure : [EOL] self . log . exception ( [string] % ( item . change , i ) , exc_info = True ) [EOL] if i == [number] : [EOL] time . sleep ( [number] ) [EOL] self . log . warning ( [string] % item . change ) [EOL] [EOL] def getSubmitAllowNeeds ( self ) : [EOL] return [ ] [EOL] [EOL] [EOL] def getSchema ( ) : [EOL] pagure_reporter = v . Schema ( { [string] : v . Any ( [string] , [string] , [string] ) , [string] : str , [string] : bool , [string] : bool , } ) [EOL] return pagure_reporter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import time [EOL] from uuid import uuid4 [EOL] [EOL] from apscheduler . schedulers . background import BackgroundScheduler [EOL] from apscheduler . triggers . cron import CronTrigger [EOL] [EOL] from zuul . driver import Driver , TriggerInterface [EOL] from zuul . driver . timer import timertrigger [EOL] from zuul . driver . timer . timermodel import TimerTriggerEvent [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] [EOL] [EOL] class TimerDriver ( Driver , TriggerInterface ) : [EOL] name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . apsched = BackgroundScheduler ( ) [EOL] self . apsched . start ( ) [EOL] self . tenant_jobs = { } [EOL] [EOL] def registerScheduler ( self , scheduler ) : [EOL] self . sched = scheduler [EOL] [EOL] def reconfigure ( self , tenant ) : [EOL] self . _removeJobs ( tenant ) [EOL] if not self . apsched : [EOL] [comment] [EOL] self . apsched = BackgroundScheduler ( ) [EOL] self . apsched . start ( ) [EOL] self . _addJobs ( tenant ) [EOL] [EOL] def _removeJobs ( self , tenant ) : [EOL] jobs = self . tenant_jobs . get ( tenant . name , [ ] ) [EOL] for job in jobs : [EOL] job . remove ( ) [EOL] [EOL] def _addJobs ( self , tenant ) : [EOL] jobs = [ ] [EOL] self . tenant_jobs [ tenant . name ] = jobs [EOL] for pipeline in tenant . layout . pipelines . values ( ) : [EOL] for ef in pipeline . manager . event_filters : [EOL] if not isinstance ( ef . trigger , timertrigger . TimerTrigger ) : [EOL] continue [EOL] for timespec in ef . timespecs : [EOL] parts = timespec . split ( ) [EOL] if len ( parts ) < [number] or len ( parts ) > [number] : [EOL] self . log . error ( [string] [string] % ( timespec , pipeline . name ) ) [EOL] continue [EOL] minute , hour , dom , month , dow = parts [ : [number] ] [EOL] if len ( parts ) > [number] : [EOL] second = parts [ [number] ] [EOL] else : [EOL] second = None [EOL] trigger = CronTrigger ( day = dom , day_of_week = dow , hour = hour , minute = minute , second = second ) [EOL] [EOL] job = self . apsched . add_job ( self . _onTrigger , trigger = trigger , args = ( tenant , pipeline . name , timespec , ) ) [EOL] jobs . append ( job ) [EOL] [EOL] def _onTrigger ( self , tenant , pipeline_name , timespec ) : [EOL] for project_name , pcs in tenant . layout . project_configs . items ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pcst = tenant . layout . getAllProjectConfigs ( project_name ) [EOL] if not [ True for pc in pcst if pipeline_name in pc . pipelines ] : [EOL] continue [EOL] [EOL] ( trusted , project ) = tenant . getProject ( project_name ) [EOL] for branch in project . source . getProjectBranches ( project , tenant ) : [EOL] event = TimerTriggerEvent ( ) [EOL] event . type = [string] [EOL] event . timespec = timespec [EOL] event . forced_pipeline = pipeline_name [EOL] event . project_hostname = project . canonical_hostname [EOL] event . project_name = project . name [EOL] event . ref = [string] % branch [EOL] event . branch = branch [EOL] event . zuul_event_id = str ( uuid4 ( ) . hex ) [EOL] event . timestamp = time . time ( ) [EOL] log = get_annotated_logger ( self . log , event ) [EOL] log . debug ( [string] ) [EOL] self . sched . addEvent ( event ) [EOL] [EOL] def stop ( self ) : [EOL] if self . apsched : [EOL] self . apsched . shutdown ( ) [EOL] self . apsched = None [EOL] [EOL] def getTrigger ( self , connection_name , config = None ) : [EOL] return timertrigger . TimerTrigger ( self , config ) [EOL] [EOL] def getTriggerSchema ( self ) : [EOL] return timertrigger . getSchema ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from zuul . driver import Driver , ConnectionInterface , SourceInterface [EOL] from zuul . driver . git import gitconnection [EOL] from zuul . driver . git import gitsource [EOL] from zuul . driver . git import gittrigger [EOL] [EOL] [EOL] class GitDriver ( Driver , ConnectionInterface , SourceInterface ) : [EOL] name = [string] [EOL] [EOL] def getConnection ( self , name , config ) : [EOL] return gitconnection . GitConnection ( self , name , config ) [EOL] [EOL] def getTrigger ( self , connection , config = None ) : [EOL] return gittrigger . GitTrigger ( self , connection , config ) [EOL] [EOL] def getSource ( self , connection ) : [EOL] return gitsource . GitSource ( self , connection ) [EOL] [EOL] def getTriggerSchema ( self ) : [EOL] return gittrigger . getSchema ( ) [EOL] [EOL] def getRequireSchema ( self ) : [EOL] return { } [EOL] [EOL] def getRejectSchema ( self ) : [EOL] return { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Type , Any , Set , Dict [EOL] import zuul [EOL] import urllib [EOL] import typing [EOL] import os [EOL] import git [EOL] import time [EOL] import logging [EOL] import urllib [EOL] import threading [EOL] [EOL] from zuul . connection import BaseConnection [EOL] from zuul . driver . git . gitmodel import GitTriggerEvent , EMPTY_GIT_REF [EOL] from zuul . model import Ref , Branch [EOL] [EOL] [EOL] class GitWatcher ( threading . Thread ) : [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , git_connection , baseurl , poll_delay ) : [EOL] threading . Thread . __init__ ( self ) [EOL] self . daemon = True [EOL] self . git_connection = git_connection [EOL] self . baseurl = baseurl [EOL] self . poll_delay = poll_delay [EOL] self . _stopped = False [EOL] self . projects_refs = self . git_connection . projects_refs [EOL] [comment] [EOL] self . _event_count = [number] [EOL] [EOL] def compareRefs ( self , project , refs ) : [EOL] partial_events = [ ] [EOL] [comment] [EOL] base_refs = self . projects_refs . get ( project ) [EOL] [comment] [EOL] rcreateds = set ( refs . keys ( ) ) - set ( base_refs . keys ( ) ) [EOL] [comment] [EOL] rdeleteds = set ( base_refs . keys ( ) ) - set ( refs . keys ( ) ) [EOL] [comment] [EOL] updateds = { } [EOL] for ref , sha in refs . items ( ) : [EOL] if ref in base_refs and base_refs [ ref ] != sha : [EOL] updateds [ ref ] = sha [EOL] for ref in rcreateds : [EOL] event = { [string] : ref , [string] : True , [string] : EMPTY_GIT_REF , [string] : refs [ ref ] } [EOL] partial_events . append ( event ) [EOL] for ref in rdeleteds : [EOL] event = { [string] : ref , [string] : True , [string] : base_refs [ ref ] , [string] : EMPTY_GIT_REF } [EOL] partial_events . append ( event ) [EOL] for ref , sha in updateds . items ( ) : [EOL] event = { [string] : ref , [string] : True , [string] : base_refs [ ref ] , [string] : sha } [EOL] partial_events . append ( event ) [EOL] events = [ ] [EOL] for pevent in partial_events : [EOL] event = GitTriggerEvent ( ) [EOL] event . type = [string] [EOL] event . timestamp = time . time ( ) [EOL] event . project_hostname = self . git_connection . canonical_hostname [EOL] event . project_name = project [EOL] for attr in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] if attr in pevent : [EOL] setattr ( event , attr , pevent [ attr ] ) [EOL] events . append ( event ) [EOL] return events [EOL] [EOL] def _run ( self ) : [EOL] self . log . debug ( [string] % self . git_connection . connection_name ) [EOL] try : [EOL] for project in self . git_connection . projects : [EOL] refs = self . git_connection . lsRemote ( project ) [EOL] self . log . debug ( [string] % ( refs , project ) ) [EOL] if not self . projects_refs . get ( project ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . projects_refs [ project ] = refs [EOL] events = self . compareRefs ( project , refs ) [EOL] self . projects_refs [ project ] = refs [EOL] [comment] [EOL] for event in events : [EOL] self . log . debug ( [string] % event ) [EOL] [comment] [EOL] [comment] [EOL] self . git_connection . getChange ( event ) [EOL] self . git_connection . logEvent ( event ) [EOL] [comment] [EOL] self . git_connection . sched . addEvent ( event ) [EOL] self . _event_count += [number] [EOL] except Exception as e : [EOL] self . log . debug ( [string] % str ( e ) ) [EOL] [EOL] def run ( self ) : [EOL] while not self . _stopped : [EOL] if not self . git_connection . w_pause : [EOL] self . _run ( ) [EOL] [comment] [EOL] else : [EOL] self . log . debug ( [string] ) [EOL] time . sleep ( self . poll_delay ) [EOL] [EOL] def stop ( self ) : [EOL] self . _stopped = True [EOL] [EOL] [EOL] class GitConnection ( BaseConnection ) : [EOL] driver_name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , driver , connection_name , connection_config ) : [EOL] super ( GitConnection , self ) . __init__ ( driver , connection_name , connection_config ) [EOL] if [string] not in self . connection_config : [EOL] raise Exception ( [string] [string] % self . connection_name ) [EOL] self . baseurl = self . connection_config . get ( [string] ) [EOL] self . poll_timeout = float ( self . connection_config . get ( [string] , [number] * [number] ) ) [EOL] self . canonical_hostname = self . connection_config . get ( [string] ) [EOL] if not self . canonical_hostname : [EOL] r = urllib . parse . urlparse ( self . baseurl ) [EOL] if r . hostname : [EOL] self . canonical_hostname = r . hostname [EOL] else : [EOL] self . canonical_hostname = [string] [EOL] self . w_pause = False [EOL] self . projects = { } [EOL] self . projects_refs = { } [EOL] self . _change_cache = { } [EOL] [EOL] def toDict ( self ) : [EOL] d = super ( ) . toDict ( ) [EOL] d . update ( { [string] : self . baseurl , [string] : self . canonical_hostname , } ) [EOL] return d [EOL] [EOL] def getProject ( self , name ) : [EOL] return self . projects . get ( name ) [EOL] [EOL] def addProject ( self , project ) : [EOL] self . projects [ project . name ] = project [EOL] [EOL] def getChangeFilesUpdated ( self , project_name , branch , tosha ) : [EOL] job = self . sched . merger . getFilesChanges ( self . connection_name , project_name , branch , tosha ) [EOL] self . log . debug ( [string] % job ) [EOL] job . wait ( ) [EOL] if not job . updated : [EOL] raise Exception ( [string] % job ) [EOL] self . log . debug ( [string] % ( job , job . files ) ) [EOL] return job . files [EOL] [EOL] def lsRemote ( self , project ) : [EOL] refs = { } [EOL] client = git . cmd . Git ( ) [EOL] output = client . ls_remote ( [string] , [string] , os . path . join ( self . baseurl , project ) ) [EOL] for line in output . splitlines ( ) : [EOL] sha , ref = line . split ( [string] ) [EOL] if ref . startswith ( [string] ) : [EOL] refs [ ref ] = sha [EOL] return refs [EOL] [EOL] def maintainCache ( self , relevant ) : [EOL] remove = { } [EOL] for branch , refschange in self . _change_cache . items ( ) : [EOL] for ref , change in refschange . items ( ) : [EOL] if change not in relevant : [EOL] remove . setdefault ( branch , [ ] ) . append ( ref ) [EOL] for branch , refs in remove . items ( ) : [EOL] for ref in refs : [EOL] del self . _change_cache [ branch ] [ ref ] [EOL] if not self . _change_cache [ branch ] : [EOL] del self . _change_cache [ branch ] [EOL] [EOL] def getChange ( self , event , refresh = False ) : [EOL] if event . ref and event . ref . startswith ( [string] ) : [EOL] branch = event . ref [ len ( [string] ) : ] [EOL] change = self . _change_cache . get ( branch , { } ) . get ( event . newrev ) [EOL] if change : [EOL] return change [EOL] project = self . getProject ( event . project_name ) [EOL] change = Branch ( project ) [EOL] change . branch = branch [EOL] for attr in ( [string] , [string] , [string] ) : [EOL] setattr ( change , attr , getattr ( event , attr ) ) [EOL] change . url = [string] [EOL] change . files = self . getChangeFilesUpdated ( event . project_name , change . branch , event . oldrev ) [EOL] self . _change_cache . setdefault ( branch , { } ) [ event . newrev ] = change [EOL] elif event . ref : [EOL] [comment] [EOL] project = self . getProject ( event . project_name ) [EOL] change = Ref ( project ) [EOL] for attr in ( [string] , [string] , [string] ) : [EOL] setattr ( change , attr , getattr ( event , attr ) ) [EOL] change . url = [string] [EOL] else : [EOL] self . log . warning ( [string] % ( event , ) ) [EOL] change = None [EOL] return change [EOL] [EOL] def getProjectBranches ( self , project , tenant ) : [EOL] refs = self . lsRemote ( project . name ) [EOL] branches = [ ref [ len ( [string] ) : ] for ref in refs if ref . startswith ( [string] ) ] [EOL] return branches [EOL] [EOL] def getGitUrl ( self , project ) : [EOL] return os . path . join ( self . baseurl , project . name ) [EOL] [EOL] def onLoad ( self ) : [EOL] self . log . debug ( [string] ) [EOL] self . _start_watcher_thread ( ) [EOL] [EOL] def onStop ( self ) : [EOL] self . log . debug ( [string] ) [EOL] self . _stop_watcher_thread ( ) [EOL] [EOL] def _stop_watcher_thread ( self ) : [EOL] if self . watcher_thread : [EOL] self . watcher_thread . stop ( ) [EOL] self . watcher_thread . join ( ) [EOL] [EOL] def _start_watcher_thread ( self ) : [EOL] self . watcher_thread = GitWatcher ( self , self . baseurl , self . poll_timeout ) [EOL] self . watcher_thread . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type , Dict [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import voluptuous as v [EOL] [EOL] from zuul . driver . gerrit . gerritsource import GerritSource [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] from zuul . reporter import BaseReporter [EOL] [EOL] [EOL] class GerritReporter ( BaseReporter ) : [EOL] [docstring] [EOL] [EOL] name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def _getFileComments ( self , item ) : [EOL] ret = { } [EOL] for build in item . current_build_set . getBuilds ( ) : [EOL] fc = build . result_data . get ( [string] , { } ) . get ( [string] ) [EOL] if not fc : [EOL] continue [EOL] for fn , comments in fc . items ( ) : [EOL] existing_comments = ret . setdefault ( fn , [ ] ) [EOL] existing_comments += comments [EOL] self . addConfigurationErrorComments ( item , ret ) [EOL] return ret [EOL] [EOL] def report ( self , item ) : [EOL] [docstring] [EOL] log = get_annotated_logger ( self . log , item . event ) [EOL] [EOL] [comment] [EOL] if not isinstance ( item . change . project . source , GerritSource ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if item . change . project . source . connection . canonical_hostname != self . connection . canonical_hostname : [EOL] return [EOL] [EOL] comments = self . _getFileComments ( item ) [EOL] self . filterComments ( item , comments ) [EOL] message = self . _formatItemReport ( item ) [EOL] [EOL] log . debug ( [string] , item . change , self . config , message , comments ) [EOL] item . change . _ref_sha = item . change . project . source . getRefSha ( item . change . project , [string] + item . change . branch ) [EOL] [EOL] return self . connection . review ( item . change , message , self . config , comments , zuul_event_id = item . event ) [EOL] [EOL] def getSubmitAllowNeeds ( self ) : [EOL] [docstring] [EOL] return self . config [EOL] [EOL] [EOL] def getSchema ( ) : [EOL] gerrit_reporter = v . Any ( str , v . Schema ( dict ) ) [EOL] return gerrit_reporter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Type , Tuple [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import time [EOL] from uuid import uuid4 [EOL] [EOL] from zuul . driver import Driver , TriggerInterface [EOL] from zuul . driver . zuul . zuulmodel import ZuulTriggerEvent [EOL] from zuul . driver . zuul import zuultrigger [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] [EOL] PARENT_CHANGE_ENQUEUED = [string] [EOL] PROJECT_CHANGE_MERGED = [string] [EOL] [EOL] [EOL] class ZuulDriver ( Driver , TriggerInterface ) : [EOL] name = [string] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . parent_change_enqueued_events = { } [EOL] self . project_change_merged_events = { } [EOL] [EOL] def registerScheduler ( self , scheduler ) : [EOL] self . sched = scheduler [EOL] [EOL] def reconfigure ( self , tenant ) : [EOL] for pipeline in tenant . layout . pipelines . values ( ) : [EOL] for ef in pipeline . manager . event_filters : [EOL] if not isinstance ( ef . trigger , zuultrigger . ZuulTrigger ) : [EOL] continue [EOL] if PARENT_CHANGE_ENQUEUED in ef . _types : [EOL] [comment] [EOL] [comment] [EOL] for pipeline in ef . _pipelines : [EOL] key = ( tenant . name , pipeline ) [EOL] self . parent_change_enqueued_events [ key ] = True [EOL] elif PROJECT_CHANGE_MERGED in ef . _types : [EOL] self . project_change_merged_events [ tenant . name ] = True [EOL] [EOL] def onChangeMerged ( self , tenant , change , source ) : [EOL] [comment] [EOL] if self . project_change_merged_events . get ( tenant . name ) : [EOL] try : [EOL] self . _createProjectChangeMergedEvents ( change , source ) [EOL] except Exception : [EOL] self . log . exception ( [string] [string] % ( change , ) ) [EOL] [EOL] def onChangeEnqueued ( self , tenant , change , pipeline , event ) : [EOL] log = get_annotated_logger ( self . log , event ) [EOL] [EOL] [comment] [EOL] tenant_events = self . parent_change_enqueued_events . get ( ( tenant . name , pipeline . name ) ) [EOL] log . debug ( [string] , tenant_events ) [EOL] if tenant_events : [EOL] try : [EOL] self . _createParentChangeEnqueuedEvents ( change , pipeline , tenant , event ) [EOL] except Exception : [EOL] log . exception ( [string] [string] % ( change , pipeline ) ) [EOL] [EOL] def _createProjectChangeMergedEvents ( self , change , source ) : [EOL] changes = source . getProjectOpenChanges ( change . project ) [EOL] for open_change in changes : [EOL] self . _createProjectChangeMergedEvent ( open_change ) [EOL] [EOL] def _createProjectChangeMergedEvent ( self , change ) : [EOL] event = ZuulTriggerEvent ( ) [EOL] event . type = PROJECT_CHANGE_MERGED [EOL] event . trigger_name = self . name [EOL] event . project_hostname = change . project . canonical_hostname [EOL] event . project_name = change . project . name [EOL] event . change_number = change . number [EOL] event . branch = change . branch [EOL] event . change_url = change . url [EOL] event . patch_number = change . patchset [EOL] event . ref = change . ref [EOL] event . zuul_event_id = str ( uuid4 ( ) . hex ) [EOL] event . timestamp = time . time ( ) [EOL] self . sched . addEvent ( event ) [EOL] [EOL] def _createParentChangeEnqueuedEvents ( self , change , pipeline , tenant , event ) : [EOL] log = get_annotated_logger ( self . log , event ) [EOL] [EOL] log . debug ( [string] % change ) [EOL] if not hasattr ( change , [string] ) : [EOL] log . debug ( [string] % type ( change ) ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] needed_by_changes = set ( change . needed_by_changes ) [EOL] for source in self . sched . connections . getSources ( ) : [EOL] log . debug ( [string] , source ) [EOL] needed_by_changes . update ( source . getChangesDependingOn ( change , None , tenant ) ) [EOL] log . debug ( [string] , needed_by_changes ) [EOL] [EOL] for needs in needed_by_changes : [EOL] self . _createParentChangeEnqueuedEvent ( needs , pipeline ) [EOL] [EOL] def _createParentChangeEnqueuedEvent ( self , change , pipeline ) : [EOL] event = ZuulTriggerEvent ( ) [EOL] event . type = PARENT_CHANGE_ENQUEUED [EOL] event . trigger_name = self . name [EOL] event . pipeline_name = pipeline . name [EOL] event . project_hostname = change . project . canonical_hostname [EOL] event . project_name = change . project . name [EOL] event . change_number = change . number [EOL] event . branch = change . branch [EOL] event . change_url = change . url [EOL] event . patch_number = change . patchset [EOL] event . ref = change . ref [EOL] event . zuul_event_id = str ( uuid4 ( ) . hex ) [EOL] self . sched . addEvent ( event ) [EOL] [EOL] def getTrigger ( self , connection_name , config = None ) : [EOL] return zuultrigger . ZuulTrigger ( self , config ) [EOL] [EOL] def getTriggerSchema ( self ) : [EOL] return zuultrigger . getSchema ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import copy [EOL] import re [EOL] import re2 [EOL] import time [EOL] [EOL] from zuul . model import Change , TriggerEvent , EventFilter , RefFilter [EOL] from zuul . model import FalseWithReason [EOL] from zuul . driver . util import time_to_seconds [EOL] [EOL] [EOL] EMPTY_GIT_REF = [string] * [number] [comment] [EOL] [EOL] [EOL] class PullRequest ( Change ) : [EOL] def __init__ ( self , project ) : [EOL] super ( PullRequest , self ) . __init__ ( project ) [EOL] self . project = None [EOL] self . pr = None [EOL] self . updated_at = None [EOL] self . title = None [EOL] self . reviews = [ ] [EOL] self . files = [ ] [EOL] self . labels = [ ] [EOL] [EOL] def isUpdateOf ( self , other ) : [EOL] if ( self . project == other . project and hasattr ( other , [string] ) and self . number == other . number and hasattr ( other , [string] ) and self . patchset != other . patchset and hasattr ( other , [string] ) and self . updated_at > other . updated_at ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class GithubTriggerEvent ( TriggerEvent ) : [EOL] def __init__ ( self ) : [EOL] super ( GithubTriggerEvent , self ) . __init__ ( ) [EOL] self . title = None [EOL] self . label = None [EOL] self . unlabel = None [EOL] self . action = None [EOL] self . delivery = None [EOL] [EOL] def isPatchsetCreated ( self ) : [EOL] if self . type == [string] : [EOL] return self . action in [ [string] , [string] ] [EOL] return False [EOL] [EOL] def isChangeAbandoned ( self ) : [EOL] if self . type == [string] : [EOL] return [string] == self . action [EOL] return False [EOL] [EOL] def _repr ( self ) : [EOL] r = [ super ( GithubTriggerEvent , self ) . _repr ( ) ] [EOL] if self . action : [EOL] r . append ( self . action ) [EOL] r . append ( self . canonical_project_name ) [EOL] if self . change_number : [EOL] r . append ( [string] % ( self . change_number , self . patch_number ) ) [EOL] if self . delivery : [EOL] r . append ( [string] % self . delivery ) [EOL] return [string] . join ( r ) [EOL] [EOL] [EOL] class GithubCommonFilter ( object ) : [EOL] def __init__ ( self , required_reviews = [ ] , required_statuses = [ ] , reject_reviews = [ ] , reject_statuses = [ ] ) : [EOL] self . _required_reviews = copy . deepcopy ( required_reviews ) [EOL] self . _reject_reviews = copy . deepcopy ( reject_reviews ) [EOL] self . required_reviews = self . _tidy_reviews ( self . _required_reviews ) [EOL] self . reject_reviews = self . _tidy_reviews ( self . _reject_reviews ) [EOL] self . required_statuses = required_statuses [EOL] self . reject_statuses = reject_statuses [EOL] [EOL] def _tidy_reviews ( self , reviews ) : [EOL] for r in reviews : [EOL] for k , v in r . items ( ) : [EOL] if k == [string] : [EOL] r [ [string] ] = re . compile ( v ) [EOL] elif k == [string] : [EOL] r [ [string] ] = re . compile ( v ) [EOL] elif k == [string] : [EOL] r [ k ] = time_to_seconds ( v ) [EOL] elif k == [string] : [EOL] r [ k ] = time_to_seconds ( v ) [EOL] return reviews [EOL] [EOL] def _match_review_required_review ( self , rreview , review ) : [EOL] [comment] [EOL] now = time . time ( ) [EOL] by = review . get ( [string] , { } ) [EOL] for k , v in rreview . items ( ) : [EOL] if k == [string] : [EOL] if ( not v . search ( by . get ( [string] , [string] ) ) ) : [EOL] return False [EOL] elif k == [string] : [EOL] if ( not v . search ( by . get ( [string] , [string] ) ) ) : [EOL] return False [EOL] elif k == [string] : [EOL] t = now - v [EOL] if ( review [ [string] ] < t ) : [EOL] return False [EOL] elif k == [string] : [EOL] t = now - v [EOL] if ( review [ [string] ] >= t ) : [EOL] return False [EOL] elif k == [string] : [EOL] if review [ [string] ] != v : [EOL] return False [EOL] elif k == [string] : [EOL] [comment] [EOL] [comment] [EOL] if v != [string] : [EOL] [comment] [EOL] if v == [string] : [EOL] if review [ [string] ] not in ( [string] , [string] ) : [EOL] return False [EOL] elif v == [string] : [EOL] if review [ [string] ] != [string] : [EOL] return False [EOL] return True [EOL] [EOL] def matchesReviews ( self , change ) : [EOL] if self . required_reviews or self . reject_reviews : [EOL] if not hasattr ( change , [string] ) : [EOL] [comment] [EOL] return FalseWithReason ( [string] ) [EOL] if self . required_reviews and not change . reviews : [EOL] [comment] [EOL] [comment] [EOL] return FalseWithReason ( [string] % ( self . required_reviews , change . reviews ) ) [EOL] [EOL] return ( self . matchesRequiredReviews ( change ) and self . matchesNoRejectReviews ( change ) ) [EOL] [EOL] def matchesRequiredReviews ( self , change ) : [EOL] for rreview in self . required_reviews : [EOL] matches_review = False [EOL] for review in change . reviews : [EOL] if self . _match_review_required_review ( rreview , review ) : [EOL] [comment] [EOL] matches_review = True [EOL] break [EOL] if not matches_review : [EOL] return FalseWithReason ( [string] % ( self . required_reviews , change . reviews ) ) [EOL] return True [EOL] [EOL] def matchesNoRejectReviews ( self , change ) : [EOL] for rreview in self . reject_reviews : [EOL] for review in change . reviews : [EOL] if self . _match_review_required_review ( rreview , review ) : [EOL] [comment] [EOL] return FalseWithReason ( [string] % ( self . reject_reviews , change . reviews ) ) [EOL] return True [EOL] [EOL] def matchesStatuses ( self , change ) : [EOL] if self . required_statuses or self . reject_statuses : [EOL] if not hasattr ( change , [string] ) : [EOL] [comment] [EOL] return FalseWithReason ( [string] ) [EOL] if self . required_statuses and not change . status : [EOL] return FalseWithReason ( [string] % ( self . required_statuses , change . status ) ) [EOL] required_statuses_results = self . matchesRequiredStatuses ( change ) [EOL] if not required_statuses_results : [EOL] return required_statuses_results [EOL] return self . matchesNoRejectStatuses ( change ) [EOL] [EOL] def matchesRequiredStatuses ( self , change ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . required_statuses : [EOL] for required_status in self . required_statuses : [EOL] for status in change . status : [EOL] if re2 . fullmatch ( required_status , status ) : [EOL] return True [EOL] return FalseWithReason ( [string] % ( self . required_statuses , change . status ) ) [EOL] return True [EOL] [EOL] def matchesNoRejectStatuses ( self , change ) : [EOL] [comment] [EOL] [comment] [EOL] for rstatus in self . reject_statuses : [EOL] for status in change . status : [EOL] if re2 . fullmatch ( rstatus , status ) : [EOL] return FalseWithReason ( [string] % ( self . reject_statuses , change . status ) ) [EOL] return True [EOL] [EOL] [EOL] class GithubEventFilter ( EventFilter , GithubCommonFilter ) : [EOL] def __init__ ( self , trigger , types = [ ] , branches = [ ] , refs = [ ] , comments = [ ] , actions = [ ] , labels = [ ] , unlabels = [ ] , states = [ ] , statuses = [ ] , required_statuses = [ ] , ignore_deletes = True ) : [EOL] [EOL] EventFilter . __init__ ( self , trigger ) [EOL] [EOL] GithubCommonFilter . __init__ ( self , required_statuses = required_statuses ) [EOL] [EOL] self . _types = types [EOL] self . _branches = branches [EOL] self . _refs = refs [EOL] self . _comments = comments [EOL] self . types = [ re . compile ( x ) for x in types ] [EOL] self . branches = [ re . compile ( x ) for x in branches ] [EOL] self . refs = [ re . compile ( x ) for x in refs ] [EOL] self . comments = [ re . compile ( x ) for x in comments ] [EOL] self . actions = actions [EOL] self . labels = labels [EOL] self . unlabels = unlabels [EOL] self . states = states [EOL] self . statuses = statuses [EOL] self . required_statuses = required_statuses [EOL] self . ignore_deletes = ignore_deletes [EOL] [EOL] def __repr__ ( self ) : [EOL] ret = [string] [EOL] [EOL] if self . _types : [EOL] ret += [string] % [string] . join ( self . _types ) [EOL] if self . _branches : [EOL] ret += [string] % [string] . join ( self . _branches ) [EOL] if self . _refs : [EOL] ret += [string] % [string] . join ( self . _refs ) [EOL] if self . ignore_deletes : [EOL] ret += [string] % self . ignore_deletes [EOL] if self . _comments : [EOL] ret += [string] % [string] . join ( self . _comments ) [EOL] if self . actions : [EOL] ret += [string] % [string] . join ( self . actions ) [EOL] if self . labels : [EOL] ret += [string] % [string] . join ( self . labels ) [EOL] if self . unlabels : [EOL] ret += [string] % [string] . join ( self . unlabels ) [EOL] if self . states : [EOL] ret += [string] % [string] . join ( self . states ) [EOL] if self . statuses : [EOL] ret += [string] % [string] . join ( self . statuses ) [EOL] if self . required_statuses : [EOL] ret += [string] % [string] . join ( self . required_statuses ) [EOL] ret += [string] [EOL] [EOL] return ret [EOL] [EOL] def matches ( self , event , change ) : [EOL] [comment] [EOL] matches_type = False [EOL] for etype in self . types : [EOL] if etype . match ( event . type ) : [EOL] matches_type = True [EOL] if self . types and not matches_type : [EOL] return FalseWithReason ( [string] % ( self . types , event . type ) ) [EOL] [EOL] [comment] [EOL] matches_branch = False [EOL] for branch in self . branches : [EOL] if branch . match ( event . branch ) : [EOL] matches_branch = True [EOL] if self . branches and not matches_branch : [EOL] return FalseWithReason ( [string] % ( self . branches , event . branch ) ) [EOL] [EOL] [comment] [EOL] matches_ref = False [EOL] if event . ref is not None : [EOL] for ref in self . refs : [EOL] if ref . match ( event . ref ) : [EOL] matches_ref = True [EOL] if self . refs and not matches_ref : [EOL] return FalseWithReason ( [string] % ( self . refs , event . ref ) ) [EOL] if self . ignore_deletes and event . newrev == EMPTY_GIT_REF : [EOL] [comment] [EOL] [comment] [EOL] return FalseWithReason ( [string] ) [EOL] [EOL] [comment] [EOL] matches_comment_re = False [EOL] for comment_re in self . comments : [EOL] if ( event . comment is not None and comment_re . search ( event . comment ) ) : [EOL] matches_comment_re = True [EOL] if self . comments and not matches_comment_re : [EOL] return FalseWithReason ( [string] % ( self . comments , event . comment ) ) [EOL] [EOL] [comment] [EOL] matches_action = False [EOL] for action in self . actions : [EOL] if ( event . action == action ) : [EOL] matches_action = True [EOL] if self . actions and not matches_action : [EOL] return FalseWithReason ( [string] % ( self . actions , event . action ) ) [EOL] [EOL] [comment] [EOL] if self . labels and event . label not in self . labels : [EOL] return FalseWithReason ( [string] % ( self . labels , event . label ) ) [EOL] [EOL] [comment] [EOL] if self . unlabels and event . unlabel not in self . unlabels : [EOL] return FalseWithReason ( [string] % ( self . unlabels , event . unlabel ) ) [EOL] [EOL] [comment] [EOL] if self . states and event . state not in self . states : [EOL] return FalseWithReason ( [string] % ( self . states , event . state ) ) [EOL] [EOL] [comment] [EOL] if self . statuses : [EOL] status_found = False [EOL] for status in self . statuses : [EOL] if re2 . fullmatch ( status , event . status ) : [EOL] status_found = True [EOL] break [EOL] if not status_found : [EOL] return FalseWithReason ( [string] % ( self . statuses , event . status ) ) [EOL] [EOL] return self . matchesStatuses ( change ) [EOL] [EOL] [EOL] class GithubRefFilter ( RefFilter , GithubCommonFilter ) : [EOL] def __init__ ( self , connection_name , statuses = [ ] , required_reviews = [ ] , reject_reviews = [ ] , open = None , merged = None , current_patchset = None , reject_open = None , reject_merged = None , reject_current_patchset = None , labels = [ ] , reject_labels = [ ] , reject_statuses = [ ] ) : [EOL] RefFilter . __init__ ( self , connection_name ) [EOL] [EOL] GithubCommonFilter . __init__ ( self , required_reviews = required_reviews , reject_reviews = reject_reviews , required_statuses = statuses , reject_statuses = reject_statuses ) [EOL] self . statuses = statuses [EOL] if reject_open is not None : [EOL] self . open = not reject_open [EOL] else : [EOL] self . open = open [EOL] if reject_merged is not None : [EOL] self . merged = not reject_merged [EOL] else : [EOL] self . merged = merged [EOL] if reject_current_patchset is not None : [EOL] self . current_patchset = not reject_current_patchset [EOL] else : [EOL] self . current_patchset = current_patchset [EOL] self . labels = labels [EOL] self . reject_labels = reject_labels [EOL] [EOL] def __repr__ ( self ) : [EOL] ret = [string] [EOL] [EOL] ret += [string] % self . connection_name [EOL] if self . statuses : [EOL] ret += [string] % [string] . join ( self . statuses ) [EOL] if self . reject_statuses : [EOL] ret += [string] % [string] . join ( self . reject_statuses ) [EOL] if self . required_reviews : [EOL] ret += ( [string] % str ( self . required_reviews ) ) [EOL] if self . reject_reviews : [EOL] ret += ( [string] % str ( self . reject_reviews ) ) [EOL] if self . open : [EOL] ret += [string] % self . open [EOL] if self . merged : [EOL] ret += [string] % self . merged [EOL] if self . current_patchset : [EOL] ret += [string] % self . current_patchset [EOL] if self . labels : [EOL] ret += [string] % self . labels [EOL] if self . reject_labels : [EOL] ret += [string] % self . reject_labels [EOL] [EOL] ret += [string] [EOL] [EOL] return ret [EOL] [EOL] def matches ( self , change ) : [EOL] statuses_result = self . matchesStatuses ( change ) [EOL] if not statuses_result : [EOL] return statuses_result [EOL] [EOL] if self . open is not None : [EOL] [comment] [EOL] [comment] [EOL] if hasattr ( change , [string] ) : [EOL] if self . open != change . open : [EOL] return FalseWithReason ( [string] ) [EOL] else : [EOL] return FalseWithReason ( [string] ) [EOL] [EOL] if self . merged is not None : [EOL] [comment] [EOL] [comment] [EOL] if hasattr ( change , [string] ) : [EOL] if self . merged != change . is_merged : [EOL] return FalseWithReason ( [string] ) [EOL] else : [EOL] return FalseWithReason ( [string] ) [EOL] [EOL] if self . current_patchset is not None : [EOL] [comment] [EOL] [comment] [EOL] if hasattr ( change , [string] ) : [EOL] if self . current_patchset != change . is_current_patchset : [EOL] return FalseWithReason ( [string] ) [EOL] else : [EOL] return FalseWithReason ( [string] ) [EOL] [EOL] [comment] [EOL] reviews_result = self . matchesReviews ( change ) [EOL] if not reviews_result : [EOL] return reviews_result [EOL] [EOL] [comment] [EOL] for label in self . labels : [EOL] if label not in change . labels : [EOL] return FalseWithReason ( [string] % ( self . labels , change . labels ) ) [EOL] [EOL] [comment] [EOL] for label in self . reject_labels : [EOL] if label in change . labels : [EOL] return FalseWithReason ( [string] % ( self . reject_labels , change . labels ) ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import zuul [EOL] import typing [EOL] import logging [EOL] import textwrap [EOL] import zuul . cmd [EOL] from zuul . lib . ansible import AnsibleManager [EOL] [EOL] [EOL] class ManageAnsible ( zuul . cmd . ZuulApp ) : [EOL] [EOL] app_name = [string] [EOL] app_description = textwrap . dedent ( [string] ) [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def createParser ( self ) : [EOL] parser = super ( ) . createParser ( ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] def _setup_logging ( self ) : [EOL] [docstring] [EOL] if self . args . verbose : [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] else : [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] [EOL] def main ( self ) : [EOL] self . parseArguments ( ) [EOL] try : [EOL] self . readConfig ( ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] self . _setup_logging ( ) [EOL] [EOL] manager = AnsibleManager ( ) [EOL] [EOL] if self . args . list_supported : [EOL] versions = [ ] [EOL] for version , default in manager . getSupportedVersions ( ) : [EOL] if default : [EOL] version = version + [string] [EOL] versions . append ( version ) [EOL] print ( [string] . join ( versions ) ) [EOL] return [EOL] [EOL] manager . install ( upgrade = self . args . upgrade ) [EOL] [EOL] [EOL] def main ( ) : [EOL] ManageAnsible ( ) . main ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import zuul [EOL] import typing [EOL] from docutils import nodes [EOL] from sphinx . domains import Domain [EOL] [EOL] MODULE_URL = [string] [EOL] [EOL] [EOL] def ansible_module_role ( name , rawtext , text , lineno , inliner , options = { } , content = [ ] ) : [EOL] [docstring] [EOL] node = nodes . reference ( rawtext , [string] . format ( module_name = text ) , refuri = MODULE_URL . format ( module_name = text ) , ** options ) [EOL] return ( [ node ] , [ ] ) [EOL] [EOL] [EOL] class AnsibleDomain ( Domain ) : [EOL] name = [string] [EOL] label = [string] [EOL] [EOL] roles = { [string] : ansible_module_role , } [EOL] [EOL] [EOL] def setup ( app ) : [EOL] app . add_domain ( AnsibleDomain ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import abc [EOL] [EOL] [EOL] class BaseExecutionContext ( object , metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def getPopen ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Type , Any , Set , Tuple , Dict [EOL] import paramiko [EOL] import zuul [EOL] import urllib [EOL] import typing [EOL] from contextlib import contextmanager [EOL] from urllib . parse import urlsplit , urlunsplit , urlparse [EOL] import logging [EOL] import os [EOL] import re [EOL] import shutil [EOL] import time [EOL] [EOL] import git [EOL] import gitdb [EOL] import paramiko [EOL] [EOL] import zuul . model [EOL] [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] [EOL] NULL_REF = [string] [EOL] [EOL] [EOL] def reset_repo_to_head ( repo ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] repo . git . reset ( [string] , [string] , [string] ) [EOL] except git . GitCommandError as e : [EOL] [comment] [EOL] [comment] [EOL] if e . status != [number] : [EOL] raise [EOL] [EOL] [EOL] def redact_url ( url ) : [EOL] parsed = urlsplit ( url ) [EOL] if parsed . password is None : [EOL] return url [EOL] [EOL] [comment] [EOL] items = list ( parsed ) [EOL] items [ [number] ] = re . sub ( [string] , [string] , items [ [number] ] ) [EOL] return urlunsplit ( items ) [EOL] [EOL] [EOL] @ contextmanager def timeout_handler ( path ) : [EOL] try : [EOL] yield [EOL] except git . exc . GitCommandError as e : [EOL] if e . status == - [number] : [EOL] [comment] [EOL] if os . path . exists ( path ) : [EOL] shutil . rmtree ( path ) [EOL] raise [EOL] [EOL] [EOL] @ contextmanager def nullcontext ( ) : [EOL] yield [EOL] [EOL] [EOL] class Repo ( object ) : [EOL] commit_re = re . compile ( [string] ) [EOL] diff_re = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self , remote , local , email , username , speed_limit , speed_time , sshkey = None , cache_path = None , logger = None , git_timeout = [number] , retry_attempts = [number] , retry_interval = [number] , zuul_event_id = None ) : [EOL] if logger is None : [EOL] self . log = logging . getLogger ( [string] ) [EOL] else : [EOL] self . log = logger [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] self . env = { [string] : speed_limit , [string] : speed_time , } [EOL] self . git_timeout = git_timeout [EOL] self . sshkey = sshkey [EOL] if sshkey : [EOL] self . env [ [string] ] = [string] % ( sshkey , ) [EOL] [EOL] self . remote_url = remote [EOL] self . local_path = local [EOL] self . email = email [EOL] self . username = username [EOL] self . cache_path = cache_path [EOL] self . _initialized = False [EOL] self . retry_attempts = retry_attempts [EOL] self . retry_interval = retry_interval [EOL] try : [EOL] self . _setup_known_hosts ( ) [EOL] except Exception : [EOL] log . exception ( [string] , remote ) [EOL] try : [EOL] self . _ensure_cloned ( zuul_event_id ) [EOL] self . _git_set_remote_url ( git . Repo ( self . local_path ) , self . remote_url ) [EOL] except Exception : [EOL] log . exception ( [string] , remote ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( hex ( id ( self ) ) , self . local_path ) [EOL] [EOL] def _setup_known_hosts ( self ) : [EOL] url = urlparse ( self . remote_url ) [EOL] if [string] not in url . scheme : [EOL] return [EOL] [EOL] port = url . port or [number] [EOL] username = url . username or self . username [EOL] [EOL] path = os . path . expanduser ( [string] ) [EOL] os . makedirs ( path , exist_ok = True ) [EOL] path = os . path . expanduser ( [string] ) [EOL] if not os . path . exists ( path ) : [EOL] with open ( path , [string] ) : [EOL] pass [EOL] [EOL] client = paramiko . SSHClient ( ) [EOL] client . load_system_host_keys ( ) [EOL] client . load_host_keys ( path ) [EOL] client . set_missing_host_key_policy ( paramiko . AutoAddPolicy ( ) ) [EOL] [EOL] try : [EOL] client . connect ( url . hostname , username = username , port = port , key_filename = self . sshkey ) [EOL] finally : [EOL] [comment] [EOL] [comment] [EOL] client . close ( ) [EOL] [EOL] def _ensure_cloned ( self , zuul_event_id , build = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id , build = build ) [EOL] repo_is_cloned = os . path . exists ( os . path . join ( self . local_path , [string] ) ) [EOL] if self . _initialized and repo_is_cloned : [EOL] try : [EOL] [comment] [EOL] git . Repo ( self . local_path ) [EOL] return [EOL] except Exception : [EOL] [comment] [EOL] shutil . rmtree ( self . local_path ) [EOL] repo_is_cloned = False [EOL] self . _initialized = False [EOL] [EOL] [comment] [EOL] rewrite_url = False [EOL] if not repo_is_cloned : [EOL] if self . cache_path : [EOL] clone_url = self . cache_path [EOL] rewrite_url = True [EOL] else : [EOL] clone_url = self . remote_url [EOL] [EOL] log . debug ( [string] , redact_url ( clone_url ) , self . local_path ) [EOL] self . _git_clone ( clone_url , zuul_event_id , build = build ) [EOL] [EOL] repo = git . Repo ( self . local_path ) [EOL] repo . git . update_environment ( ** self . env ) [EOL] [comment] [EOL] if not repo_is_cloned : [EOL] origin = repo . remotes . origin [EOL] for ref in origin . refs : [EOL] if ref . remote_head == [string] : [EOL] continue [EOL] repo . create_head ( ref . remote_head , ref , force = True ) [EOL] with repo . config_writer ( ) as config_writer : [EOL] if self . email : [EOL] config_writer . set_value ( [string] , [string] , self . email ) [EOL] if self . username : [EOL] config_writer . set_value ( [string] , [string] , self . username ) [EOL] config_writer . write ( ) [EOL] if rewrite_url : [EOL] self . _git_set_remote_url ( repo , self . remote_url ) [EOL] self . _initialized = True [EOL] [EOL] def isInitialized ( self ) : [EOL] return self . _initialized [EOL] [EOL] def _git_clone ( self , url , zuul_event_id , build = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id , build = build ) [EOL] mygit = git . cmd . Git ( os . getcwd ( ) ) [EOL] mygit . update_environment ( ** self . env ) [EOL] [EOL] for attempt in range ( [number] , self . retry_attempts + [number] ) : [EOL] try : [EOL] with timeout_handler ( self . local_path ) : [EOL] mygit . clone ( git . cmd . Git . polish_url ( url ) , self . local_path , kill_after_timeout = self . git_timeout ) [EOL] break [EOL] except Exception : [EOL] if attempt < self . retry_attempts : [EOL] time . sleep ( self . retry_interval ) [EOL] log . warning ( [string] , attempt , self . local_path ) [EOL] else : [EOL] raise [EOL] [EOL] def _git_fetch ( self , repo , remote , zuul_event_id , ref = None , ** kwargs ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] for attempt in range ( [number] , self . retry_attempts + [number] ) : [EOL] try : [EOL] with timeout_handler ( self . local_path ) : [EOL] repo . git . fetch ( remote , ref , kill_after_timeout = self . git_timeout , ** kwargs ) [EOL] break [EOL] except Exception as e : [EOL] if attempt < self . retry_attempts : [EOL] if [string] in e . stderr . lower ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] reset_repo_to_head ( repo ) [EOL] repo . git . clean ( [string] , [string] , [string] ) [EOL] elif [string] in e . stderr . lower ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] shutil . rmtree ( self . local_path ) [EOL] elif [string] in e . stderr . lower ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] shutil . rmtree ( self . local_path ) [EOL] else : [EOL] time . sleep ( self . retry_interval ) [EOL] log . exception ( [string] % ( attempt , self . local_path , remote , ref ) ) [EOL] self . _ensure_cloned ( zuul_event_id ) [EOL] else : [EOL] raise [EOL] [EOL] def _git_set_remote_url ( self , repo , url ) : [EOL] with repo . remotes . origin . config_writer as config_writer : [EOL] config_writer . set ( [string] , url ) [EOL] [EOL] def createRepoObject ( self , zuul_event_id , build = None ) : [EOL] self . _ensure_cloned ( zuul_event_id , build = build ) [EOL] repo = git . Repo ( self . local_path ) [EOL] repo . git . update_environment ( ** self . env ) [EOL] return repo [EOL] [EOL] def reset ( self , zuul_event_id = None , build = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id , build = build ) [EOL] log . debug ( [string] , self . local_path ) [EOL] self . update ( zuul_event_id = zuul_event_id , build = build ) [EOL] repo = self . createRepoObject ( zuul_event_id , build = build ) [EOL] origin = repo . remotes . origin [EOL] seen = set ( ) [EOL] head = None [EOL] stale_refs = origin . stale_refs [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for ref in origin . refs : [EOL] if ref . remote_head == [string] : [EOL] continue [EOL] if ref in stale_refs : [EOL] continue [EOL] repo . create_head ( ref . remote_head , ref , force = True ) [EOL] seen . add ( ref . remote_head ) [EOL] if head is None : [EOL] head = ref . remote_head [EOL] log . debug ( [string] , head ) [EOL] repo . head . reference = head [EOL] for ref in stale_refs : [EOL] log . debug ( [string] , ref . remote_head ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for head in repo . heads : [EOL] if head . name == ref . remote_head : [EOL] repo . delete_head ( ref . remote_head , force = True ) [EOL] break [EOL] git . refs . RemoteReference . delete ( repo , ref , force = True ) [EOL] [EOL] def prune ( self , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] origin = repo . remotes . origin [EOL] stale_refs = origin . stale_refs [EOL] if stale_refs : [EOL] log . debug ( [string] , stale_refs ) [EOL] git . refs . RemoteReference . delete ( repo , force = True , * stale_refs ) [EOL] [EOL] def getBranchHead ( self , branch , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] branch_head = repo . heads [ branch ] [EOL] return branch_head . commit [EOL] [EOL] def hasBranch ( self , branch , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] origin = repo . remotes . origin [EOL] return branch in origin . refs [EOL] [EOL] def getBranches ( self , zuul_event_id = None ) : [EOL] [comment] [EOL] [comment] [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] return [ x . name for x in repo . heads ] [EOL] [EOL] def getCommitFromRef ( self , refname , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] if refname not in repo . refs : [EOL] return None [EOL] ref = repo . refs [ refname ] [EOL] return ref . commit [EOL] [EOL] def getRefs ( self , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] return repo . refs [EOL] [EOL] def setRef ( self , path , hexsha , repo = None , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] log . debug ( [string] , path , hexsha , self . local_path ) [EOL] if repo is None : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] binsha = gitdb . util . to_bin_sha ( hexsha ) [EOL] obj = git . objects . Object . new_from_sha ( repo , binsha ) [EOL] git . refs . Reference . create ( repo , path , obj , force = True ) [EOL] [EOL] def setRefs ( self , refs , keep_remotes = False , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] current_refs = { } [EOL] for ref in repo . refs : [EOL] current_refs [ ref . path ] = ref [EOL] unseen = set ( current_refs . keys ( ) ) [EOL] for path , hexsha in refs . items ( ) : [EOL] self . setRef ( path , hexsha , repo , zuul_event_id = zuul_event_id ) [EOL] unseen . discard ( path ) [EOL] ref = current_refs . get ( path ) [EOL] if keep_remotes and ref : [EOL] unseen . discard ( [string] . format ( ref . name ) ) [EOL] for path in unseen : [EOL] self . deleteRef ( path , repo , zuul_event_id = zuul_event_id ) [EOL] [EOL] def setRemoteRef ( self , branch , rev , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] try : [EOL] origin_ref = repo . remotes . origin . refs [ branch ] [EOL] except IndexError : [EOL] log . warning ( [string] , branch ) [EOL] return [EOL] log . debug ( [string] , origin_ref , rev ) [EOL] origin_ref . commit = rev [EOL] [EOL] def deleteRef ( self , path , repo = None , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] if repo is None : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] log . debug ( [string] , path ) [EOL] git . refs . SymbolicReference . delete ( repo , path ) [EOL] [EOL] def checkout ( self , ref , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] [comment] [EOL] [comment] [EOL] if not repo . head . is_detached and repo . head . reference == ref : [EOL] log . debug ( [string] % ref ) [EOL] else : [EOL] log . debug ( [string] % ref ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] repo . head . reference = ref [EOL] reset_repo_to_head ( repo ) [EOL] repo . git . clean ( [string] , [string] , [string] ) [EOL] repo . git . checkout ( ref ) [EOL] [EOL] return repo . head . commit [EOL] [EOL] def cherryPick ( self , ref , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] log . debug ( [string] , ref ) [EOL] self . fetch ( ref , zuul_event_id = zuul_event_id ) [EOL] repo . git . cherry_pick ( [string] ) [EOL] return repo . head . commit [EOL] [EOL] def merge ( self , ref , strategy = None , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] args = [ ] [EOL] if strategy : [EOL] args += [ [string] , strategy ] [EOL] args . append ( [string] ) [EOL] self . fetch ( ref , zuul_event_id = zuul_event_id ) [EOL] log . debug ( [string] , ref , args ) [EOL] repo . git . merge ( * args ) [EOL] return repo . head . commit [EOL] [EOL] def squash_merge ( self , item , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] args = [ [string] , [string] ] [EOL] ref = item [ [string] ] [EOL] self . fetch ( ref , zuul_event_id = zuul_event_id ) [EOL] log . debug ( [string] , ref , args ) [EOL] repo . git . merge ( * args ) [EOL] repo . index . commit ( [string] % ( item [ [string] ] , item [ [string] ] ) ) [EOL] return repo . head . commit [EOL] [EOL] def fetch ( self , ref , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _git_fetch ( repo , [string] , zuul_event_id , ref = ref ) [EOL] [EOL] def revParse ( self , ref , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] return repo . git . rev_parse ( ref ) [EOL] [EOL] def fetchFrom ( self , repository , ref , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] self . _git_fetch ( repo , repository , zuul_event_id , ref = ref ) [EOL] [EOL] def push ( self , local , remote , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] log . debug ( [string] , local , remote , self . remote_url ) [EOL] repo . remotes . origin . push ( [string] % ( local , remote ) ) [EOL] [EOL] def update ( self , zuul_event_id = None , build = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id , build = build ) [EOL] repo = self . createRepoObject ( zuul_event_id , build = build ) [EOL] log . debug ( [string] % self . local_path ) [EOL] if repo . git . version_info [ : [number] ] < ( [number] , [number] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _git_fetch ( repo , [string] , zuul_event_id ) [EOL] self . _git_fetch ( repo , [string] , zuul_event_id , tags = True ) [EOL] [EOL] def isUpdateNeeded ( self , repo_state , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] for rev in repo_state . values ( ) : [EOL] try : [EOL] repo . commit ( rev ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] return False [EOL] [EOL] def getFiles ( self , files , dirs = [ ] , branch = None , commit = None , zuul_event_id = None ) : [EOL] ret = { } [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] if branch : [EOL] tree = repo . heads [ branch ] . commit . tree [EOL] else : [EOL] tree = repo . commit ( commit ) . tree [EOL] for fn in files : [EOL] if fn in tree : [EOL] ret [ fn ] = tree [ fn ] . data_stream . read ( ) . decode ( [string] ) [EOL] else : [EOL] ret [ fn ] = None [EOL] if dirs : [EOL] for dn in dirs : [EOL] if dn not in tree : [EOL] continue [EOL] for blob in tree [ dn ] . traverse ( ) : [EOL] if blob . path . endswith ( [string] ) : [EOL] ret [ blob . path ] = blob . data_stream . read ( ) . decode ( [string] ) [EOL] return ret [EOL] [EOL] def getFilesChanges ( self , branch , tosha = None , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] self . fetch ( branch , zuul_event_id = zuul_event_id ) [EOL] head = repo . commit ( self . revParse ( [string] , zuul_event_id = zuul_event_id ) ) [EOL] files = set ( ) [EOL] [EOL] if tosha : [EOL] commit_diff = [string] . format ( tosha , head . hexsha ) [EOL] for cmt in repo . iter_commits ( commit_diff , no_merges = True ) : [EOL] files . update ( cmt . stats . files . keys ( ) ) [EOL] else : [EOL] files . update ( head . stats . files . keys ( ) ) [EOL] return list ( files ) [EOL] [EOL] def deleteRemote ( self , remote , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] repo . delete_remote ( repo . remotes [ remote ] ) [EOL] [EOL] def setRemoteUrl ( self , url , zuul_event_id = None ) : [EOL] if self . remote_url == url : [EOL] return [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] log . debug ( [string] , redact_url ( url ) ) [EOL] self . remote_url = url [EOL] self . _git_set_remote_url ( self . createRepoObject ( zuul_event_id ) , self . remote_url ) [EOL] [EOL] def mapLine ( self , commit , filename , lineno , zuul_event_id = None ) : [EOL] repo = self . createRepoObject ( zuul_event_id ) [EOL] [comment] [EOL] [comment] [EOL] cur_commit = None [EOL] out = repo . git . log ( L = [string] % ( lineno , lineno , filename ) ) [EOL] for l in out . split ( [string] ) : [EOL] if cur_commit is None : [EOL] m = self . commit_re . match ( l ) [EOL] if m : [EOL] if m . group ( [number] ) == commit : [EOL] cur_commit = commit [EOL] continue [EOL] m = self . diff_re . match ( l ) [EOL] if m : [EOL] return int ( m . group ( [number] ) ) [EOL] return None [EOL] [EOL] [EOL] class Merger ( object ) : [EOL] def __init__ ( self , working_root , connections , email , username , speed_limit , speed_time , cache_root = None , logger = None , execution_context = False , git_timeout = [number] ) : [EOL] self . logger = logger [EOL] if logger is None : [EOL] self . log = logging . getLogger ( [string] ) [EOL] else : [EOL] self . log = logger [EOL] self . repos = { } [EOL] self . working_root = working_root [EOL] os . makedirs ( working_root , exist_ok = True ) [EOL] self . connections = connections [EOL] self . email = email [EOL] self . username = username [EOL] self . speed_limit = speed_limit [EOL] self . speed_time = speed_time [EOL] self . git_timeout = git_timeout [EOL] self . cache_root = cache_root [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . execution_context = execution_context [EOL] [EOL] def _addProject ( self , hostname , project_name , url , sshkey , zuul_event_id ) : [EOL] repo = None [EOL] key = [string] . join ( [ hostname , project_name ] ) [EOL] try : [EOL] path = os . path . join ( self . working_root , hostname , project_name ) [EOL] if self . cache_root : [EOL] cache_path = os . path . join ( self . cache_root , hostname , project_name ) [EOL] else : [EOL] cache_path = None [EOL] repo = Repo ( url , path , self . email , self . username , self . speed_limit , self . speed_time , sshkey = sshkey , cache_path = cache_path , logger = self . logger , git_timeout = self . git_timeout , zuul_event_id = zuul_event_id ) [EOL] [EOL] self . repos [ key ] = repo [EOL] except Exception : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] log . exception ( [string] , hostname , project_name ) [EOL] return repo [EOL] [EOL] def getRepo ( self , connection_name , project_name , zuul_event_id = None ) : [EOL] source = self . connections . getSource ( connection_name ) [EOL] project = source . getProject ( project_name ) [EOL] hostname = project . canonical_hostname [EOL] url = source . getGitUrl ( project ) [EOL] key = [string] . join ( [ hostname , project_name ] ) [EOL] if key in self . repos : [EOL] repo = self . repos [ key ] [EOL] repo . setRemoteUrl ( url ) [EOL] return repo [EOL] sshkey = self . connections . connections . get ( connection_name ) . connection_config . get ( [string] ) [EOL] if not url : [EOL] raise Exception ( [string] [string] % ( connection_name , project_name , ) ) [EOL] return self . _addProject ( hostname , project_name , url , sshkey , zuul_event_id ) [EOL] [EOL] def updateRepo ( self , connection_name , project_name , repo_state = None , zuul_event_id = None , build = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id , build = build ) [EOL] repo = self . getRepo ( connection_name , project_name , zuul_event_id = zuul_event_id ) [EOL] try : [EOL] [EOL] [comment] [EOL] if repo_state and not repo . isUpdateNeeded ( repo_state , zuul_event_id = zuul_event_id ) : [EOL] log . info ( [string] , connection_name , project_name ) [EOL] else : [EOL] log . info ( [string] , connection_name , project_name ) [EOL] repo . reset ( zuul_event_id = zuul_event_id , build = build ) [EOL] except Exception : [EOL] log . exception ( [string] , connection_name , project_name ) [EOL] [EOL] def checkoutBranch ( self , connection_name , project_name , branch , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] log . info ( [string] , connection_name , project_name , branch ) [EOL] repo = self . getRepo ( connection_name , project_name , zuul_event_id = zuul_event_id ) [EOL] repo . checkout ( branch , zuul_event_id = zuul_event_id ) [EOL] [EOL] def _saveRepoState ( self , connection_name , project_name , repo , repo_state , recent , branches ) : [EOL] projects = repo_state . setdefault ( connection_name , { } ) [EOL] project = projects . setdefault ( project_name , { } ) [EOL] for ref in repo . getRefs ( ) : [EOL] if ref . path . startswith ( [string] ) : [EOL] continue [EOL] if ref . path . startswith ( [string] ) : [EOL] continue [EOL] if ref . path . startswith ( [string] ) : [EOL] branch = ref . path [ len ( [string] ) : ] [EOL] if branches is not None and branch not in branches : [EOL] continue [EOL] key = ( connection_name , project_name , branch ) [EOL] if key not in recent : [EOL] recent [ key ] = ref . object [EOL] project [ ref . path ] = ref . object . hexsha [EOL] [EOL] def _alterRepoState ( self , connection_name , project_name , repo_state , path , hexsha ) : [EOL] projects = repo_state . setdefault ( connection_name , { } ) [EOL] project = projects . setdefault ( project_name , { } ) [EOL] if hexsha == NULL_REF : [EOL] if path in project : [EOL] del project [ path ] [EOL] else : [EOL] project [ path ] = hexsha [EOL] [EOL] def _restoreRepoState ( self , connection_name , project_name , repo , repo_state , zuul_event_id ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] projects = repo_state . get ( connection_name , { } ) [EOL] project = projects . get ( project_name , { } ) [EOL] if not project : [EOL] [comment] [EOL] return [EOL] log . debug ( [string] , connection_name , project_name ) [EOL] repo . setRefs ( project , keep_remotes = self . execution_context , zuul_event_id = zuul_event_id ) [EOL] [EOL] def _mergeChange ( self , item , ref , zuul_event_id ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] repo = self . getRepo ( item [ [string] ] , item [ [string] ] , zuul_event_id = zuul_event_id ) [EOL] try : [EOL] repo . checkout ( ref , zuul_event_id = zuul_event_id ) [EOL] except Exception : [EOL] log . exception ( [string] , ref ) [EOL] return None , None [EOL] [EOL] try : [EOL] mode = item [ [string] ] [EOL] if mode == zuul . model . MERGER_MERGE : [EOL] commit = repo . merge ( item [ [string] ] , zuul_event_id = zuul_event_id ) [EOL] elif mode == zuul . model . MERGER_MERGE_RESOLVE : [EOL] commit = repo . merge ( item [ [string] ] , [string] , zuul_event_id = zuul_event_id ) [EOL] elif mode == zuul . model . MERGER_CHERRY_PICK : [EOL] commit = repo . cherryPick ( item [ [string] ] , zuul_event_id = zuul_event_id ) [EOL] elif mode == zuul . model . MERGER_SQUASH_MERGE : [EOL] commit = repo . squash_merge ( item , zuul_event_id = zuul_event_id ) [EOL] else : [EOL] raise Exception ( [string] % mode ) [EOL] except git . GitCommandError : [EOL] [comment] [EOL] [comment] [EOL] log . debug ( [string] , item , exc_info = True ) [EOL] return None , None [EOL] except Exception : [EOL] log . exception ( [string] ) [EOL] return None , None [EOL] [EOL] orig_commit = repo . revParse ( [string] ) [EOL] return orig_commit , commit [EOL] [EOL] def _mergeItem ( self , item , recent , repo_state , zuul_event_id , branches = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] log . debug ( [string] % ( item [ [string] ] , item [ [string] ] , item [ [string] ] , item [ [string] ] , item [ [string] ] ) ) [EOL] repo = self . getRepo ( item [ [string] ] , item [ [string] ] ) [EOL] key = ( item [ [string] ] , item [ [string] ] , item [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] base = recent . get ( key ) [EOL] if not base : [EOL] [comment] [EOL] [comment] [EOL] log . debug ( [string] % ( key , ) ) [EOL] try : [EOL] repo . reset ( zuul_event_id = zuul_event_id ) [EOL] except Exception : [EOL] log . exception ( [string] % repo ) [EOL] return None , None [EOL] self . _restoreRepoState ( item [ [string] ] , item [ [string] ] , repo , repo_state , zuul_event_id ) [EOL] [EOL] base = repo . getBranchHead ( item [ [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] self . _saveRepoState ( item [ [string] ] , item [ [string] ] , repo , repo_state , recent , branches ) [EOL] else : [EOL] log . debug ( [string] % ( base , key , ) ) [EOL] [EOL] if self . execution_context : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] repo . setRemoteRef ( item [ [string] ] , base , zuul_event_id = zuul_event_id ) [EOL] [EOL] [comment] [EOL] orig_commit , commit = self . _mergeChange ( item , base , zuul_event_id ) [EOL] if not commit : [EOL] return None , None [EOL] [comment] [EOL] recent [ key ] = commit [EOL] return orig_commit , commit [EOL] [EOL] def mergeChanges ( self , items , files = None , dirs = None , repo_state = None , repo_locks = None , branches = None , zuul_event_id = None ) : [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] [comment] [EOL] recent = { } [EOL] commit = None [EOL] read_files = [ ] [EOL] [comment] [EOL] if repo_state is None : [EOL] repo_state = { } [EOL] for item in items : [EOL] [comment] [EOL] [comment] [EOL] if repo_locks is not None : [EOL] lock = repo_locks . getRepoLock ( item [ [string] ] , item [ [string] ] ) [EOL] else : [EOL] lock = nullcontext ( ) [EOL] with lock : [EOL] log . debug ( [string] % ( item [ [string] ] , item [ [string] ] ) ) [EOL] orig_commit , commit = self . _mergeItem ( item , recent , repo_state , zuul_event_id , branches = branches ) [EOL] if not commit : [EOL] return None [EOL] if files or dirs : [EOL] repo = self . getRepo ( item [ [string] ] , item [ [string] ] ) [EOL] repo_files = repo . getFiles ( files , dirs , commit = commit ) [EOL] read_files . append ( dict ( connection = item [ [string] ] , project = item [ [string] ] , branch = item [ [string] ] , files = repo_files ) ) [EOL] ret_recent = { } [EOL] for k , v in recent . items ( ) : [EOL] ret_recent [ k ] = v . hexsha [EOL] return commit . hexsha , read_files , repo_state , ret_recent , orig_commit [EOL] [EOL] def setRepoState ( self , items , repo_state , zuul_event_id = None ) : [EOL] [comment] [EOL] seen = set ( ) [EOL] for item in items : [EOL] repo = self . getRepo ( item [ [string] ] , item [ [string] ] , zuul_event_id = zuul_event_id ) [EOL] key = ( item [ [string] ] , item [ [string] ] , item [ [string] ] ) [EOL] [EOL] if key in seen : [EOL] continue [EOL] [EOL] repo . reset ( ) [EOL] self . _restoreRepoState ( item [ [string] ] , item [ [string] ] , repo , repo_state , zuul_event_id ) [EOL] [EOL] def getRepoState ( self , items , branches = None , repo_locks = None ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] seen = set ( ) [EOL] recent = { } [EOL] repo_state = { } [EOL] for item in items : [EOL] [comment] [EOL] [comment] [EOL] if repo_locks is not None : [EOL] lock = repo_locks . getRepoLock ( item [ [string] ] , item [ [string] ] ) [EOL] else : [EOL] lock = nullcontext ( ) [EOL] with lock : [EOL] repo = self . getRepo ( item [ [string] ] , item [ [string] ] ) [EOL] key = ( item [ [string] ] , item [ [string] ] , item [ [string] ] ) [EOL] if key not in seen : [EOL] try : [EOL] repo . reset ( ) [EOL] except Exception : [EOL] self . log . exception ( [string] % repo ) [EOL] return ( False , { } ) [EOL] [EOL] self . _saveRepoState ( item [ [string] ] , item [ [string] ] , repo , repo_state , recent , branches ) [EOL] [EOL] if item . get ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] self . _alterRepoState ( item [ [string] ] , item [ [string] ] , repo_state , item [ [string] ] , item [ [string] ] ) [EOL] return ( True , repo_state ) [EOL] [EOL] def getFiles ( self , connection_name , project_name , branch , files , dirs = [ ] ) : [EOL] repo = self . getRepo ( connection_name , project_name ) [EOL] return repo . getFiles ( files , dirs , branch = branch ) [EOL] [EOL] def getFilesChanges ( self , connection_name , project_name , branch , tosha = None , zuul_event_id = None ) : [EOL] repo = self . getRepo ( connection_name , project_name , zuul_event_id = zuul_event_id ) [EOL] return repo . getFilesChanges ( branch , tosha , zuul_event_id = zuul_event_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 $builtins.int$ 0 $urllib.parse.ParseResult$ 0 $builtins.int$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $builtins.str$ 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zuul.merger.merger.Repo$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $zuul.merger.merger.Repo$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $zuul.merger.merger.Repo$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $zuul.merger.merger.Repo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , Dict [EOL] import threading [EOL] import zuul [EOL] import typing [EOL] import json [EOL] import logging [EOL] import threading [EOL] from uuid import uuid4 [EOL] [EOL] import gear [EOL] [EOL] import zuul . model [EOL] from zuul . lib . config import get_default [EOL] from zuul . lib . logutil import get_annotated_logger [EOL] [EOL] [EOL] def getJobData ( job ) : [EOL] if not len ( job . data ) : [EOL] return { } [EOL] d = job . data [ - [number] ] [EOL] if not d : [EOL] return { } [EOL] return json . loads ( d ) [EOL] [EOL] [EOL] class MergeGearmanClient ( gear . Client ) : [EOL] def __init__ ( self , merge_client ) : [EOL] super ( MergeGearmanClient , self ) . __init__ ( [string] ) [EOL] self . __merge_client = merge_client [EOL] [EOL] def handleWorkComplete ( self , packet ) : [EOL] job = super ( MergeGearmanClient , self ) . handleWorkComplete ( packet ) [EOL] self . __merge_client . onBuildCompleted ( job ) [EOL] return job [EOL] [EOL] def handleWorkFail ( self , packet ) : [EOL] job = super ( MergeGearmanClient , self ) . handleWorkFail ( packet ) [EOL] self . __merge_client . onBuildCompleted ( job ) [EOL] return job [EOL] [EOL] def handleWorkException ( self , packet ) : [EOL] job = super ( MergeGearmanClient , self ) . handleWorkException ( packet ) [EOL] self . __merge_client . onBuildCompleted ( job ) [EOL] return job [EOL] [EOL] def handleDisconnect ( self , job ) : [EOL] job = super ( MergeGearmanClient , self ) . handleDisconnect ( job ) [EOL] self . __merge_client . onBuildCompleted ( job ) [EOL] [EOL] [EOL] class MergeJob ( gear . TextJob ) : [EOL] def __init__ ( self , * args , ** kw ) : [EOL] super ( MergeJob , self ) . __init__ ( * args , ** kw ) [EOL] self . __event = threading . Event ( ) [EOL] [EOL] def setComplete ( self ) : [EOL] self . __event . set ( ) [EOL] [EOL] def wait ( self , timeout = [number] ) : [EOL] return self . __event . wait ( timeout ) [EOL] [EOL] [EOL] class MergeClient ( object ) : [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , config , sched ) : [EOL] self . config = config [EOL] self . sched = sched [EOL] server = self . config . get ( [string] , [string] ) [EOL] port = get_default ( self . config , [string] , [string] , [number] ) [EOL] ssl_key = get_default ( self . config , [string] , [string] ) [EOL] ssl_cert = get_default ( self . config , [string] , [string] ) [EOL] ssl_ca = get_default ( self . config , [string] , [string] ) [EOL] self . log . debug ( [string] % ( server , port ) ) [EOL] self . gearman = MergeGearmanClient ( self ) [EOL] self . gearman . addServer ( server , port , ssl_key , ssl_cert , ssl_ca , keepalive = True , tcp_keepidle = [number] , tcp_keepintvl = [number] , tcp_keepcnt = [number] ) [EOL] self . git_timeout = get_default ( self . config , [string] , [string] , [number] ) [EOL] self . log . debug ( [string] ) [EOL] self . gearman . waitForServer ( ) [EOL] self . jobs = set ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . gearman . shutdown ( ) [EOL] [EOL] def areMergesOutstanding ( self ) : [EOL] if self . jobs : [EOL] return True [EOL] return False [EOL] [EOL] def submitJob ( self , name , data , build_set , precedence = zuul . model . PRECEDENCE_NORMAL , event = None ) : [EOL] log = get_annotated_logger ( self . log , event ) [EOL] uuid = str ( uuid4 ( ) . hex ) [EOL] job = MergeJob ( name , json . dumps ( data ) , unique = uuid ) [EOL] job . build_set = build_set [EOL] log . debug ( [string] , job , data ) [EOL] self . jobs . add ( job ) [EOL] self . gearman . submitJob ( job , precedence = precedence , timeout = [number] ) [EOL] return job [EOL] [EOL] def mergeChanges ( self , items , build_set , files = None , dirs = None , repo_state = None , precedence = zuul . model . PRECEDENCE_NORMAL , branches = None , event = None ) : [EOL] if event is not None : [EOL] zuul_event_id = event . zuul_event_id [EOL] else : [EOL] zuul_event_id = None [EOL] data = dict ( items = items , files = files , dirs = dirs , repo_state = repo_state , branches = branches , zuul_event_id = zuul_event_id ) [EOL] self . submitJob ( [string] , data , build_set , precedence , event = event ) [EOL] [EOL] def getRepoState ( self , items , build_set , precedence = zuul . model . PRECEDENCE_NORMAL , branches = None , event = None ) : [EOL] if event is not None : [EOL] zuul_event_id = event . zuul_event_id [EOL] else : [EOL] zuul_event_id = None [EOL] [EOL] data = dict ( items = items , branches = branches , zuul_event_id = zuul_event_id ) [EOL] self . submitJob ( [string] , data , build_set , precedence , event = event ) [EOL] [EOL] def getFiles ( self , connection_name , project_name , branch , files , dirs = [ ] , precedence = zuul . model . PRECEDENCE_HIGH , event = None ) : [EOL] if event is not None : [EOL] zuul_event_id = event . zuul_event_id [EOL] else : [EOL] zuul_event_id = None [EOL] [EOL] data = dict ( connection = connection_name , project = project_name , branch = branch , files = files , dirs = dirs , zuul_event_id = zuul_event_id ) [EOL] job = self . submitJob ( [string] , data , None , precedence , event = event ) [EOL] return job [EOL] [EOL] def getFilesChanges ( self , connection_name , project_name , branch , tosha = None , precedence = zuul . model . PRECEDENCE_HIGH , build_set = None , event = None ) : [EOL] if event is not None : [EOL] zuul_event_id = event . zuul_event_id [EOL] else : [EOL] zuul_event_id = None [EOL] [EOL] data = dict ( connection = connection_name , project = project_name , branch = branch , tosha = tosha , zuul_event_id = zuul_event_id ) [EOL] job = self . submitJob ( [string] , data , build_set , precedence , event = event ) [EOL] return job [EOL] [EOL] def onBuildCompleted ( self , job ) : [EOL] data = getJobData ( job ) [EOL] zuul_event_id = data . get ( [string] ) [EOL] log = get_annotated_logger ( self . log , zuul_event_id ) [EOL] [EOL] merged = data . get ( [string] , False ) [EOL] job . updated = data . get ( [string] , False ) [EOL] commit = data . get ( [string] ) [EOL] files = data . get ( [string] , { } ) [EOL] repo_state = data . get ( [string] , { } ) [EOL] job . files = files [EOL] log . info ( [string] [string] , job , merged , job . updated , commit ) [EOL] job . setComplete ( ) [EOL] if job . build_set : [EOL] if job . name == [string] : [EOL] self . sched . onFilesChangesCompleted ( job . build_set , files ) [EOL] else : [EOL] self . sched . onMergeCompleted ( job . build_set , merged , job . updated , commit , files , repo_state ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . jobs . remove ( job ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $zuul.merger.client.MergeGearmanClient$ 0 0 0 0 0 0 0 0 $zuul.merger.client.MergeGearmanClient$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zuul.merger.client.MergeGearmanClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $zuul.merger.client.MergeJob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $zuul.merger.client.MergeJob$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $zuul.merger.client.MergeJob$ 0 0 0 0 0 0 0 0 0 0 $zuul.merger.client.MergeJob$ 0 0 0 0 0 0 0 0 $zuul.merger.client.MergeJob$ 0 0 0 0 0 0 0 0 0 0 0 $zuul.merger.client.MergeJob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Optional , Union , Pattern , Any , Dict [EOL] import threading [EOL] import datetime [EOL] import subprocess [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] __metaclass__ = type [EOL] [EOL] [EOL] ANSIBLE_METADATA = { [string] : [string] , [string] : [ [string] ] , [string] : [string] } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] DOCUMENTATION = [string] [EOL] [EOL] EXAMPLES = [string] [EOL] [EOL] RETURN = [string] [EOL] [EOL] import datetime [EOL] import glob [EOL] import os [EOL] import shlex [EOL] [EOL] from ansible . module_utils . basic import AnsibleModule [EOL] [EOL] [comment] [EOL] import re [EOL] import subprocess [EOL] import traceback [EOL] import threading [EOL] from ansible . module_utils . basic import heuristic_log_sanitize [EOL] from ansible . module_utils . six import ( PY2 , PY3 , b , binary_type , string_types , text_type , ) [EOL] from ansible . module_utils . six . moves import shlex_quote [EOL] from ansible . module_utils . _text import to_native , to_bytes , to_text [EOL] [EOL] [EOL] LOG_STREAM_FILE = [string] [EOL] PASSWD_ARG_RE = re . compile ( [string] ) [EOL] [comment] [EOL] _log_lines = [ ] [EOL] [EOL] [EOL] class Console ( object ) : [EOL] def __init__ ( self , log_uuid ) : [EOL] self . logfile_name = LOG_STREAM_FILE . format ( log_uuid = log_uuid ) [EOL] [EOL] def __enter__ ( self ) : [EOL] self . logfile = open ( self . logfile_name , [string] , buffering = [number] ) [EOL] return self [EOL] [EOL] def __exit__ ( self , etype , value , tb ) : [EOL] self . logfile . close ( ) [EOL] [EOL] def addLine ( self , ln ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ts = str ( datetime . datetime . now ( ) ) . encode ( [string] ) [EOL] if not isinstance ( ln , bytes ) : [EOL] try : [EOL] ln = ln . encode ( [string] ) [EOL] except Exception : [EOL] ln = repr ( ln ) . encode ( [string] ) + [string] [EOL] outln = [string] % ( ts , ln ) [EOL] self . logfile . write ( outln ) [EOL] [EOL] [EOL] def follow ( fd , log_uuid ) : [EOL] newline_warning = False [EOL] with Console ( log_uuid ) as console : [EOL] while True : [EOL] line = fd . readline ( ) [EOL] if not line : [EOL] break [EOL] _log_lines . append ( line ) [EOL] if not line . endswith ( [string] ) : [EOL] line += [string] [EOL] newline_warning = True [EOL] console . addLine ( line ) [EOL] if newline_warning : [EOL] console . addLine ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def zuul_run_command ( self , args , zuul_log_id , check_rc = False , close_fds = True , executable = None , data = None , binary_data = False , path_prefix = None , cwd = None , use_unsafe_shell = False , prompt_regex = None , environ_update = None , umask = None , encoding = [string] , errors = [string] ) : [EOL] [docstring] [EOL] [EOL] if not isinstance ( args , ( list , binary_type , text_type ) ) : [EOL] msg = [string] [EOL] self . fail_json ( rc = [number] , cmd = args , msg = msg ) [EOL] [EOL] shell = False [EOL] if use_unsafe_shell : [EOL] [EOL] [comment] [EOL] if isinstance ( args , list ) : [EOL] args = [string] . join ( [ shlex_quote ( x ) for x in args ] ) [EOL] [EOL] [comment] [EOL] if executable : [EOL] args = [ executable , [string] , args ] [EOL] elif self . _shell not in ( None , [string] ) : [EOL] args = [ self . _shell , [string] , args ] [EOL] else : [EOL] shell = True [EOL] else : [EOL] [comment] [EOL] if isinstance ( args , ( binary_type , text_type ) ) : [EOL] [comment] [EOL] [comment] [EOL] if PY2 : [EOL] args = to_bytes ( args , errors = [string] ) [EOL] elif PY3 : [EOL] args = to_text ( args , errors = [string] ) [EOL] args = shlex . split ( args ) [EOL] [EOL] [comment] [EOL] args = [ os . path . expanduser ( os . path . expandvars ( x ) ) for x in args if x is not None ] [EOL] [EOL] prompt_re = None [EOL] if prompt_regex : [EOL] if isinstance ( prompt_regex , text_type ) : [EOL] if PY3 : [EOL] prompt_regex = to_bytes ( prompt_regex , errors = [string] ) [EOL] elif PY2 : [EOL] prompt_regex = to_bytes ( prompt_regex , errors = [string] ) [EOL] try : [EOL] prompt_re = re . compile ( prompt_regex , re . MULTILINE ) [EOL] except re . error : [EOL] self . fail_json ( msg = [string] ) [EOL] [EOL] rc = [number] [EOL] msg = None [EOL] st_in = None [EOL] [EOL] [comment] [EOL] old_env_vals = { } [EOL] [comment] [EOL] for key , val in self . run_command_environ_update . items ( ) : [EOL] old_env_vals [ key ] = os . environ . get ( key , None ) [EOL] os . environ [ key ] = val [EOL] if environ_update : [EOL] for key , val in environ_update . items ( ) : [EOL] old_env_vals [ key ] = os . environ . get ( key , None ) [EOL] os . environ [ key ] = val [EOL] if path_prefix : [EOL] old_env_vals [ [string] ] = os . environ [ [string] ] [EOL] os . environ [ [string] ] = [string] % ( path_prefix , os . environ [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if [string] in os . environ : [EOL] pypaths = os . environ [ [string] ] . split ( [string] ) [EOL] pypaths = [ x for x in pypaths if not x . endswith ( [string] ) and not x . endswith ( [string] ) ] [EOL] os . environ [ [string] ] = [string] . join ( pypaths ) [EOL] if not os . environ [ [string] ] : [EOL] del os . environ [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] to_clean_args = args [EOL] if PY2 : [EOL] if isinstance ( args , text_type ) : [EOL] to_clean_args = to_bytes ( args ) [EOL] else : [EOL] if isinstance ( args , binary_type ) : [EOL] to_clean_args = to_text ( args ) [EOL] if isinstance ( args , ( text_type , binary_type ) ) : [EOL] to_clean_args = shlex . split ( to_clean_args ) [EOL] [EOL] clean_args = [ ] [EOL] is_passwd = False [EOL] for arg in ( to_native ( a ) for a in to_clean_args ) : [EOL] if is_passwd : [EOL] is_passwd = False [EOL] clean_args . append ( [string] ) [EOL] continue [EOL] if PASSWD_ARG_RE . match ( arg ) : [EOL] sep_idx = arg . find ( [string] ) [EOL] if sep_idx > - [number] : [EOL] clean_args . append ( [string] % arg [ : sep_idx ] ) [EOL] continue [EOL] else : [EOL] is_passwd = True [EOL] arg = heuristic_log_sanitize ( arg , self . no_log_values ) [EOL] clean_args . append ( arg ) [EOL] clean_args = [string] . join ( shlex_quote ( arg ) for arg in clean_args ) [EOL] [EOL] if data : [EOL] st_in = subprocess . PIPE [EOL] [EOL] [comment] [EOL] kwargs = dict ( executable = executable , shell = shell , close_fds = close_fds , stdin = st_in , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , ) [EOL] [EOL] [comment] [EOL] prev_dir = os . getcwd ( ) [EOL] [EOL] [comment] [EOL] if cwd and os . path . isdir ( cwd ) : [EOL] cwd = os . path . abspath ( os . path . expanduser ( cwd ) ) [EOL] kwargs [ [string] ] = cwd [EOL] try : [EOL] os . chdir ( cwd ) [EOL] except ( OSError , IOError ) as e : [EOL] self . fail_json ( rc = e . errno , msg = [string] % ( cwd , to_native ( e ) ) , exception = traceback . format_exc ( ) ) [EOL] [EOL] old_umask = None [EOL] if umask : [EOL] old_umask = os . umask ( umask ) [EOL] [EOL] t = None [EOL] fail_json_kwargs = None [EOL] [EOL] try : [EOL] if self . _debug : [EOL] self . log ( [string] + clean_args ) [EOL] [EOL] [comment] [EOL] [EOL] cmd = subprocess . Popen ( args , ** kwargs ) [EOL] if self . no_log : [EOL] t = None [EOL] else : [EOL] t = threading . Thread ( target = follow , args = ( cmd . stdout , zuul_log_id ) ) [EOL] t . daemon = True [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] rc = cmd . wait ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if t : [EOL] t . join ( [number] ) [EOL] with Console ( zuul_log_id ) as console : [EOL] if t . isAlive ( ) : [EOL] console . addLine ( [string] [string] ) [EOL] [comment] [EOL] [comment] [EOL] stdout = b ( [string] ) . join ( _log_lines ) [EOL] else : [EOL] stdout = b ( [string] ) [EOL] stderr = b ( [string] ) [EOL] [EOL] except ( OSError , IOError ) as e : [EOL] self . log ( [string] % ( clean_args , to_native ( e ) ) ) [EOL] [comment] [EOL] fail_json_kwargs = dict ( rc = e . errno , msg = to_native ( e ) , cmd = clean_args ) [EOL] except Exception as e : [EOL] self . log ( [string] % ( clean_args , to_native ( traceback . format_exc ( ) ) ) ) [EOL] [comment] [EOL] fail_json_kwargs = dict ( rc = [number] , msg = to_native ( e ) , exception = traceback . format_exc ( ) , cmd = clean_args ) [EOL] finally : [EOL] if t : [EOL] with Console ( zuul_log_id ) as console : [EOL] if t . isAlive ( ) : [EOL] console . addLine ( [string] [string] ) [EOL] if fail_json_kwargs : [EOL] [comment] [EOL] [comment] [EOL] rc = fail_json_kwargs [ [string] ] [EOL] [EOL] console . addLine ( [string] % rc ) [EOL] [EOL] if fail_json_kwargs : [EOL] self . fail_json ( ** fail_json_kwargs ) [EOL] [EOL] [comment] [EOL] for key , val in old_env_vals . items ( ) : [EOL] if val is None : [EOL] del os . environ [ key ] [EOL] else : [EOL] os . environ [ key ] = val [EOL] [EOL] if old_umask : [EOL] os . umask ( old_umask ) [EOL] [EOL] if rc != [number] and check_rc : [EOL] msg = heuristic_log_sanitize ( stderr . rstrip ( ) , self . no_log_values ) [EOL] self . fail_json ( cmd = clean_args , rc = rc , stdout = stdout , stderr = stderr , msg = msg ) [EOL] [EOL] [comment] [EOL] os . chdir ( prev_dir ) [EOL] [EOL] if encoding is not None : [EOL] return ( rc , to_native ( stdout , encoding = encoding , errors = errors ) , to_native ( stderr , encoding = encoding , errors = errors ) ) [EOL] return ( rc , stdout , stderr ) [EOL] [EOL] [EOL] def check_command ( module , commandline ) : [EOL] arguments = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] commands = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] become = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] command = os . path . basename ( commandline . split ( ) [ [number] ] ) [EOL] [EOL] disable_suffix = [string] [string] [string] [EOL] substitutions = { [string] : None , [string] : command } [EOL] [EOL] if command in arguments : [EOL] msg = [string] + disable_suffix [EOL] substitutions [ [string] ] = [string] [EOL] substitutions [ [string] ] = arguments [ command ] [EOL] module . warn ( msg . format ( ** substitutions ) ) [EOL] [EOL] if command in commands : [EOL] msg = [string] + disable_suffix [EOL] substitutions [ [string] ] = commands [ command ] [EOL] module . warn ( msg . format ( ** substitutions ) ) [EOL] [EOL] if command in become : [EOL] module . warn ( [string] % ( command , ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] module = AnsibleModule ( argument_spec = dict ( _raw_params = dict ( ) , _uses_shell = dict ( type = [string] , default = False ) , chdir = dict ( type = [string] ) , executable = dict ( ) , creates = dict ( type = [string] ) , removes = dict ( type = [string] ) , warn = dict ( type = [string] , default = True ) , stdin = dict ( required = False ) , zuul_log_id = dict ( type = [string] ) , ) ) [EOL] [EOL] shell = module . params [ [string] ] [EOL] chdir = module . params [ [string] ] [EOL] executable = module . params [ [string] ] [EOL] args = module . params [ [string] ] [EOL] creates = module . params [ [string] ] [EOL] removes = module . params [ [string] ] [EOL] warn = module . params [ [string] ] [EOL] stdin = module . params [ [string] ] [EOL] zuul_log_id = module . params [ [string] ] [EOL] [EOL] if not shell and executable : [EOL] module . warn ( [string] % executable ) [EOL] executable = None [EOL] [EOL] if not zuul_log_id : [EOL] module . fail_json ( rc = [number] , msg = [string] % module . params ) [EOL] [EOL] if not args or args . strip ( ) == [string] : [EOL] module . fail_json ( rc = [number] , msg = [string] ) [EOL] [EOL] if chdir : [EOL] chdir = os . path . abspath ( chdir ) [EOL] os . chdir ( chdir ) [EOL] [EOL] if creates : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if glob . glob ( creates ) : [EOL] module . exit_json ( cmd = args , stdout = [string] % creates , changed = False , rc = [number] ) [EOL] [EOL] if removes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not glob . glob ( removes ) : [EOL] module . exit_json ( cmd = args , stdout = [string] % removes , changed = False , rc = [number] ) [EOL] [EOL] if warn : [EOL] check_command ( module , args ) [EOL] [EOL] if not shell : [EOL] args = shlex . split ( args ) [EOL] startd = datetime . datetime . now ( ) [EOL] [EOL] rc , out , err = zuul_run_command ( module , args , zuul_log_id , executable = executable , use_unsafe_shell = shell , encoding = None , data = stdin ) [EOL] [EOL] endd = datetime . datetime . now ( ) [EOL] delta = endd - startd [EOL] [EOL] result = dict ( cmd = args , stdout = out . rstrip ( [string] ) , stderr = err . rstrip ( [string] ) , rc = rc , start = str ( startd ) , end = str ( endd ) , delta = str ( delta ) , changed = True , zuul_log_id = zuul_log_id ) [EOL] [EOL] if rc != [number] : [EOL] module . fail_json ( msg = [string] , ** result ) [EOL] [EOL] module . exit_json ( ** result ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , List , Any [EOL] import typing [EOL] import imp [EOL] import os [EOL] [EOL] from ansible import constants as C [EOL] from ansible . errors import AnsibleError [EOL] import ansible . modules [EOL] import ansible . plugins . action [EOL] import ansible . plugins . lookup [EOL] [EOL] [EOL] def _safe_find_needle ( super , dirname , needle ) : [EOL] result = super . _find_needle ( dirname , needle ) [EOL] [comment] [EOL] [comment] [EOL] if not _is_safe_path ( result , allow_trusted = True ) : [EOL] fail_dict = _fail_dict ( _full_path ( result ) ) [EOL] raise AnsibleError ( [string] . format ( msg = fail_dict [ [string] ] , path = fail_dict [ [string] ] ) ) [EOL] return result [EOL] [EOL] [EOL] def _full_path ( path ) : [EOL] return os . path . realpath ( os . path . abspath ( os . path . expanduser ( path ) ) ) [EOL] [EOL] [EOL] def _is_safe_path ( path , allow_trusted = False ) : [EOL] [EOL] home_path = os . path . abspath ( os . path . expanduser ( [string] ) ) [EOL] allowed_paths = [ home_path ] [EOL] if allow_trusted : [EOL] allowed_paths . append ( os . path . abspath ( os . path . join ( home_path , [string] ) ) ) [EOL] allowed_paths . append ( os . path . abspath ( os . path . join ( home_path , [string] ) ) ) [EOL] [EOL] def _is_safe ( path_to_check ) : [EOL] for allowed_path in allowed_paths : [EOL] if path_to_check . startswith ( allowed_path ) : [EOL] return True [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] full_path = _full_path ( path ) [EOL] if not _is_safe ( full_path ) : [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] visited = set ( ) [EOL] for root , dirs , files in os . walk ( full_path , followlinks = True ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] full_root = _full_path ( root ) [EOL] if not _is_safe ( full_root ) : [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if full_root in visited : [EOL] del dirs [ : ] [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] visited . add ( full_root ) [EOL] [EOL] for entry in files : [EOL] full_path = _full_path ( os . path . join ( root , entry ) ) [EOL] if not _is_safe ( full_path ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def _fail_dict ( path , prefix = [string] ) : [EOL] return dict ( failed = True , path = path , msg = [string] . format ( prefix = prefix , curdir = os . path . abspath ( os . path . curdir ) ) ) [EOL] [EOL] [EOL] def _fail_if_unsafe ( path , allow_trusted = False ) : [EOL] if not _is_safe_path ( path , allow_trusted ) : [EOL] msg_dict = _fail_dict ( path ) [EOL] raise AnsibleError ( msg_dict [ [string] ] ) [EOL] [EOL] [EOL] def _import_ansible_action_plugin ( name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return imp . load_module ( [string] + name , * imp . find_module ( name , ansible . plugins . action . __path__ ) ) [EOL] [EOL] [EOL] def _import_ansible_lookup_plugin ( name ) : [EOL] [comment] [EOL] [EOL] return imp . load_module ( [string] + name , * imp . find_module ( name , ansible . plugins . lookup . __path__ ) ) [EOL] [EOL] [EOL] def _is_official_module ( module ) : [EOL] task_module_path = module . _shared_loader_obj . module_loader . find_plugin ( module . _task . action ) [EOL] ansible_module_paths = [ os . path . dirname ( ansible . modules . __file__ ) ] [EOL] [comment] [EOL] [comment] [EOL] ansible_module_paths . extend ( C . DEFAULT_MODULE_PATH ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for path in ansible_module_paths : [EOL] if task_module_path . startswith ( path ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def _fail_module_dict ( module_name ) : [EOL] return dict ( failed = True , msg = [string] . format ( name = module_name ) ) [EOL] [EOL] [EOL] def _fail_if_local_module ( module ) : [EOL] if not _is_official_module ( module ) : [EOL] msg_dict = _fail_module_dict ( module . _task . action ) [EOL] raise AnsibleError ( msg_dict [ [string] ] ) [EOL] [EOL] [EOL] def _is_localhost_task ( task ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if ( task . _play_context . connection == [string] or task . _play_context . remote_addr == [string] or task . _task . delegate_to == [string] ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def _sanitize_filename ( name ) : [EOL] return [string] . join ( c for c in name if c . isalnum ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] ini = paths . _import_ansible_lookup_plugin ( [string] ) [EOL] [EOL] [EOL] class LookupModule ( ini . LookupModule ) : [EOL] [EOL] def read_properties ( self , filename , * args , ** kwargs ) : [EOL] paths . _fail_if_unsafe ( filename , allow_trusted = True ) [EOL] return super ( LookupModule , self ) . read_properties ( filename , * args , ** kwargs ) [EOL] [EOL] def read_ini ( self , filename , * args , ** kwargs ) : [EOL] paths . _fail_if_unsafe ( filename , allow_trusted = True ) [EOL] return super ( LookupModule , self ) . read_ini ( filename , * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] synchronize = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( synchronize . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] if not paths . _is_official_module ( self ) : [EOL] return paths . _fail_module_dict ( self . _task . action ) [EOL] [EOL] try : [EOL] delegate_to = self . _task . delegate_to [EOL] except ( AttributeError , KeyError ) : [EOL] delegate_to = None [EOL] [EOL] if delegate_to and not paths . _is_localhost_task ( self ) : [EOL] return super ( ActionModule , self ) . run ( tmp , task_vars ) [EOL] [EOL] source = self . _task . args . get ( [string] , None ) [EOL] dest = self . _task . args . get ( [string] , None ) [EOL] mode = self . _task . args . get ( [string] , [string] ) [EOL] [EOL] if [string] not in self . _task . args : [EOL] self . _task . args [ [string] ] = [ ] [EOL] if [string] not in self . _task . args [ [string] ] : [EOL] self . _task . args [ [string] ] . append ( [string] ) [EOL] [EOL] if mode == [string] and not paths . _is_safe_path ( source , allow_trusted = True ) : [EOL] return paths . _fail_dict ( source , prefix = [string] ) [EOL] if mode == [string] and not paths . _is_safe_path ( dest ) : [EOL] return paths . _fail_dict ( dest , prefix = [string] ) [EOL] return super ( ActionModule , self ) . run ( tmp , task_vars ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] win_template = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( win_template . ActionModule ) : [EOL] [EOL] def _find_needle ( self , dirname , needle ) : [EOL] return paths . _safe_find_needle ( super ( ActionModule , self ) , dirname , needle ) [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] if not paths . _is_official_module ( self ) : [EOL] return paths . _fail_module_dict ( self . _task . action ) [EOL] [EOL] return super ( ActionModule , self ) . run ( tmp , task_vars ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import os [EOL] [EOL] from ansible . plugins . callback import default [EOL] [EOL] [EOL] class CallbackModule ( default . CallbackModule ) : [EOL] [EOL] CALLBACK_VERSION = [number] [EOL] [comment] [EOL] CALLBACK_TYPE = [string] [EOL] CALLBACK_NAME = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( CallbackModule , self ) . __init__ ( ) [EOL] self . output_path = os . path . join ( os . environ [ [string] ] , [string] , [string] ) [EOL] self . unreachable_hosts = set ( ) [EOL] [EOL] def v2_runner_on_unreachable ( self , result ) : [EOL] host = result . _host . get_name ( ) [EOL] if host not in self . unreachable_hosts : [EOL] self . unreachable_hosts . add ( host ) [EOL] with open ( self . output_path , [string] ) as f : [EOL] f . write ( [string] % host ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Union , Dict [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] import copy [EOL] import logging . config [EOL] import json [EOL] import os [EOL] [EOL] import yaml [EOL] [EOL] _DEFAULT_JOB_LOGGING_CONFIG = { [string] : [number] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , } , [string] : { [string] : [ ] } , } [EOL] [EOL] _DEFAULT_SERVER_LOGGING_CONFIG = { [string] : [number] , [string] : { [string] : { [string] : [string] } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , [string] : { [string] : [ [string] ] , [string] : [string] , } , } , [string] : { [string] : [ ] } , } [EOL] [EOL] _DEFAULT_SERVER_FILE_HANDLERS = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } [EOL] [EOL] [EOL] def _read_config_file ( filename ) : [EOL] if not os . path . exists ( filename ) : [EOL] raise ValueError ( [string] % filename ) [EOL] [EOL] if os . path . splitext ( filename ) [ [number] ] in ( [string] , [string] , [string] ) : [EOL] return yaml . safe_load ( open ( filename , [string] ) ) [EOL] return filename [EOL] [EOL] [EOL] def load_config ( filename ) : [EOL] config = _read_config_file ( filename ) [EOL] if isinstance ( config , dict ) : [EOL] return DictLoggingConfig ( config ) [EOL] return FileLoggingConfig ( filename ) [EOL] [EOL] [EOL] def load_job_config ( filename ) : [EOL] return JobLoggingConfig ( _read_config_file ( filename ) ) [EOL] [EOL] [EOL] class LoggingConfig ( object , metaclass = abc . ABCMeta ) : [EOL] [EOL] @ abc . abstractmethod def apply ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] class DictLoggingConfig ( LoggingConfig , metaclass = abc . ABCMeta ) : [EOL] [EOL] def __init__ ( self , config ) : [EOL] self . _config = config [EOL] [EOL] def apply ( self ) : [EOL] logging . config . dictConfig ( self . _config ) [EOL] [EOL] def writeJson ( self , filename ) : [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( json . dumps ( self . _config , indent = [number] ) ) [EOL] [EOL] [EOL] class JobLoggingConfig ( DictLoggingConfig ) : [EOL] [EOL] def __init__ ( self , config = None , job_output_file = None ) : [EOL] if not config : [EOL] config = copy . deepcopy ( _DEFAULT_JOB_LOGGING_CONFIG ) [EOL] super ( JobLoggingConfig , self ) . __init__ ( config = config ) [EOL] if job_output_file : [EOL] self . job_output_file = job_output_file [EOL] [EOL] def setDebug ( self ) : [EOL] [comment] [EOL] self . _config [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] [EOL] @ property def job_output_file ( self ) : [EOL] return self . _config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] @ job_output_file . setter def job_output_file ( self , filename ) : [EOL] self . _config [ [string] ] [ [string] ] [ [string] ] = filename [EOL] [EOL] [EOL] class ServerLoggingConfig ( DictLoggingConfig ) : [EOL] [EOL] def __init__ ( self , config = None , server = None ) : [EOL] if not config : [EOL] config = copy . deepcopy ( _DEFAULT_SERVER_LOGGING_CONFIG ) [EOL] super ( ServerLoggingConfig , self ) . __init__ ( config = config ) [EOL] if server : [EOL] self . server = server [EOL] [EOL] @ property def server ( self ) : [EOL] return self . _server [EOL] [EOL] @ server . setter def server ( self , server ) : [EOL] self . _server = server [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for name , handler in _DEFAULT_SERVER_FILE_HANDLERS . items ( ) : [EOL] server_handler = copy . deepcopy ( handler ) [EOL] server_handler [ [string] ] = server_handler [ [string] ] . format ( server = server ) [EOL] self . _config [ [string] ] [ name ] = server_handler [EOL] [comment] [EOL] [comment] [EOL] for logger in self . _config [ [string] ] . values ( ) : [EOL] if logger [ [string] ] == [ [string] ] : [EOL] logger [ [string] ] = [ [string] ] [EOL] [EOL] def setDebug ( self ) : [EOL] [comment] [EOL] for section in ( [string] , [string] ) : [EOL] for handler in self . _config [ section ] . values ( ) : [EOL] if handler . get ( [string] ) == [string] : [EOL] handler [ [string] ] = [string] [EOL] [EOL] [EOL] class FileLoggingConfig ( LoggingConfig ) : [EOL] [EOL] def __init__ ( self , filename ) : [EOL] self . _filename = filename [EOL] [EOL] def apply ( self ) : [EOL] logging . config . fileConfig ( self . _filename ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [comment] [EOL] config = JobLoggingConfig ( job_output_file = os . path . abspath ( [string] ) ) [EOL] config . writeJson ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] copy = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( copy . ActionModule ) : [EOL] [EOL] def _find_needle ( self , dirname , needle ) : [EOL] return paths . _safe_find_needle ( super ( ActionModule , self ) , dirname , needle ) [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] if not paths . _is_official_module ( self ) : [EOL] return paths . _fail_module_dict ( self . _task . action ) [EOL] [EOL] if paths . _is_localhost_task ( self ) : [EOL] paths . _fail_if_unsafe ( self . _task . args [ [string] ] ) [EOL] [EOL] return super ( ActionModule , self ) . run ( tmp , task_vars ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import os [EOL] import glob [EOL] [EOL] from zuul . ansible import paths [EOL] [EOL] from ansible . plugins . lookup import LookupBase [EOL] from ansible . module_utils . _text import to_bytes , to_text [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , terms , variables = None , ** kwargs ) : [EOL] [EOL] ret = [ ] [EOL] for term in terms : [EOL] term_file = os . path . basename ( term ) [EOL] dwimmed_path = self . find_file_in_search_path ( variables , [string] , os . path . dirname ( term ) ) [EOL] if dwimmed_path : [EOL] paths . _fail_if_unsafe ( dwimmed_path , allow_trusted = True ) [EOL] globbed = glob . glob ( to_bytes ( os . path . join ( dwimmed_path , term_file ) , errors = [string] ) ) [EOL] ret . extend ( to_text ( g , errors = [string] ) for g in globbed if os . path . isfile ( g ) ) [EOL] return ret [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from ansible . errors import AnsibleError [EOL] from ansible . plugins . lookup import LookupBase [EOL] [EOL] [EOL] class LookupModule ( LookupBase ) : [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] raise AnsibleError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] password = paths . _import_ansible_lookup_plugin ( [string] ) [EOL] [EOL] [EOL] class LookupModule ( password . LookupModule ) : [EOL] [EOL] def run ( self , terms , variables , ** kwargs ) : [EOL] for term in terms : [EOL] relpath = password . _parse_parameters ( term ) [ [number] ] [EOL] [comment] [EOL] if relpath != [string] : [EOL] path = self . _loader . path_dwim ( relpath ) [EOL] paths . _fail_if_unsafe ( path , allow_trusted = True ) [EOL] return super ( LookupModule , self ) . run ( terms , variables , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import os [EOL] import typing [EOL] import io [EOL] import threading [EOL] import socket [EOL] import select [EOL] import glob [EOL] import os [EOL] import sys [EOL] import select [EOL] import socket [EOL] import subprocess [EOL] import threading [EOL] import time [EOL] [EOL] LOG_STREAM_FILE = [string] [EOL] LOG_STREAM_PORT = [number] [EOL] [EOL] [EOL] def daemonize ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] pid = os . fork ( ) [EOL] if pid > [number] : [EOL] return True [EOL] [EOL] os . chdir ( [string] ) [EOL] os . setsid ( ) [EOL] os . umask ( [number] ) [EOL] [EOL] pid = os . fork ( ) [EOL] if pid > [number] : [EOL] sys . exit ( [number] ) [EOL] [EOL] sys . stdout . flush ( ) [EOL] sys . stderr . flush ( ) [EOL] i = open ( [string] , [string] ) [EOL] o = open ( [string] , [string] ) [EOL] e = open ( [string] , [string] , [number] ) [EOL] os . dup2 ( i . fileno ( ) , sys . stdin . fileno ( ) ) [EOL] os . dup2 ( o . fileno ( ) , sys . stdout . fileno ( ) ) [EOL] os . dup2 ( e . fileno ( ) , sys . stderr . fileno ( ) ) [EOL] return False [EOL] [EOL] [EOL] class Console ( object ) : [EOL] def __init__ ( self , path ) : [EOL] self . path = path [EOL] self . file = open ( path , [string] ) [EOL] self . stat = os . stat ( path ) [EOL] self . size = self . stat . st_size [EOL] [EOL] [EOL] class Server ( object ) : [EOL] [EOL] MAX_REQUEST_LEN = [number] [EOL] REQUEST_TIMEOUT = [number] [EOL] [EOL] def __init__ ( self , path , port ) : [EOL] self . path = path [EOL] [EOL] s = socket . socket ( socket . AF_INET6 , socket . SOCK_STREAM ) [EOL] s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] s . bind ( ( [string] , port ) ) [EOL] s . listen ( [number] ) [EOL] [EOL] self . socket = s [EOL] [EOL] def accept ( self ) : [EOL] conn , addr = self . socket . accept ( ) [EOL] return conn [EOL] [EOL] def run ( self ) : [EOL] while True : [EOL] conn = self . accept ( ) [EOL] t = threading . Thread ( target = self . handleOneConnection , args = ( conn , ) ) [EOL] t . daemon = True [EOL] t . start ( ) [EOL] [EOL] def chunkConsole ( self , conn , log_uuid ) : [EOL] try : [EOL] console = Console ( self . path . format ( log_uuid = log_uuid ) ) [EOL] except Exception : [EOL] return [EOL] while True : [EOL] chunk = console . file . read ( [number] ) [EOL] if not chunk : [EOL] break [EOL] conn . send ( chunk ) [EOL] return console [EOL] [EOL] def followConsole ( self , console , conn ) : [EOL] while True : [EOL] [comment] [EOL] while True : [EOL] chunk = console . file . read ( [number] ) [EOL] if chunk : [EOL] conn . send ( chunk ) [EOL] else : [EOL] break [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] r , w , e = select . select ( [ conn ] , [ ] , [ conn ] , [number] ) [EOL] if conn in e : [EOL] return False [EOL] if conn in r : [EOL] ret = conn . recv ( [number] ) [EOL] [comment] [EOL] [comment] [EOL] if not ret : [EOL] return False [EOL] [EOL] [comment] [EOL] try : [EOL] st = os . stat ( console . path ) [EOL] if ( st . st_ino != console . stat . st_ino or st . st_size < console . size ) : [EOL] return True [EOL] except Exception : [EOL] return True [EOL] console . size = st . st_size [EOL] [EOL] def get_command ( self , conn ) : [EOL] poll = select . poll ( ) [EOL] bitmask = ( select . POLLIN | select . POLLERR | select . POLLHUP | select . POLLNVAL ) [EOL] poll . register ( conn , bitmask ) [EOL] buffer = [string] [EOL] ret = None [EOL] start = time . time ( ) [EOL] while True : [EOL] elapsed = time . time ( ) - start [EOL] timeout = max ( self . REQUEST_TIMEOUT - elapsed , [number] ) [EOL] if not timeout : [EOL] raise Exception ( [string] ) [EOL] for fd , event in poll . poll ( timeout ) : [EOL] if event & select . POLLIN : [EOL] buffer += conn . recv ( self . MAX_REQUEST_LEN ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] if len ( buffer ) >= self . MAX_REQUEST_LEN : [EOL] raise Exception ( [string] ) [EOL] try : [EOL] ret = buffer . decode ( [string] ) [EOL] x = ret . find ( [string] ) [EOL] if x > [number] : [EOL] return ret [ : x ] [EOL] except UnicodeDecodeError : [EOL] pass [EOL] [EOL] def handleOneConnection ( self , conn ) : [EOL] log_uuid = self . get_command ( conn ) [EOL] [comment] [EOL] [comment] [EOL] log_uuid = os . path . split ( log_uuid . rstrip ( ) ) [ - [number] ] [EOL] [EOL] [comment] [EOL] console = None [EOL] try : [EOL] while True : [EOL] if console is not None : [EOL] try : [EOL] console . file . close ( ) [EOL] except Exception : [EOL] pass [EOL] while True : [EOL] console = self . chunkConsole ( conn , log_uuid ) [EOL] if console : [EOL] break [EOL] conn . send ( [string] ) [EOL] time . sleep ( [number] ) [EOL] while True : [EOL] if self . followConsole ( console , conn ) : [EOL] break [EOL] else : [EOL] return [EOL] finally : [EOL] try : [EOL] conn . close ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] [EOL] def get_inode ( port_number = [number] ) : [EOL] for netfile in ( [string] , [string] ) : [EOL] if not os . path . exists ( netfile ) : [EOL] continue [EOL] with open ( netfile ) as f : [EOL] [comment] [EOL] f . readline ( ) [EOL] for line in f : [EOL] [comment] [EOL] [comment] [EOL] fields = line . split ( ) [EOL] [comment] [EOL] port = int ( fields [ [number] ] . split ( [string] ) [ [number] ] , base = [number] ) [EOL] if port == port_number : [EOL] return fields [ [number] ] [EOL] [EOL] [EOL] def get_pid_from_inode ( inode ) : [EOL] my_euid = os . geteuid ( ) [EOL] exceptions = [ ] [EOL] for d in os . listdir ( [string] ) : [EOL] try : [EOL] try : [EOL] int ( d ) [EOL] except Exception : [EOL] continue [EOL] d_abs_path = os . path . join ( [string] , d ) [EOL] if os . stat ( d_abs_path ) . st_uid != my_euid : [EOL] continue [EOL] fd_dir = os . path . join ( d_abs_path , [string] ) [EOL] if os . path . exists ( fd_dir ) : [EOL] if os . stat ( fd_dir ) . st_uid != my_euid : [EOL] continue [EOL] for fd in os . listdir ( fd_dir ) : [EOL] try : [EOL] fd_path = os . path . join ( fd_dir , fd ) [EOL] if os . path . islink ( fd_path ) : [EOL] target = os . readlink ( fd_path ) [EOL] if [string] + inode + [string] in target : [EOL] return d , exceptions [EOL] except Exception as e : [EOL] exceptions . append ( e ) [EOL] except Exception as e : [EOL] exceptions . append ( e ) [EOL] return None , exceptions [EOL] [EOL] [EOL] def test ( ) : [EOL] s = Server ( LOG_STREAM_FILE , LOG_STREAM_PORT ) [EOL] s . run ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] module = AnsibleModule ( argument_spec = dict ( path = dict ( default = LOG_STREAM_FILE ) , port = dict ( default = LOG_STREAM_PORT , type = [string] ) , state = dict ( default = [string] , choices = [ [string] , [string] ] ) , ) ) [EOL] [EOL] p = module . params [EOL] path = p [ [string] ] [EOL] port = p [ [string] ] [EOL] state = p [ [string] ] [EOL] [EOL] if state == [string] : [EOL] if daemonize ( ) : [EOL] module . exit_json ( ) [EOL] [EOL] s = Server ( path , port ) [EOL] s . run ( ) [EOL] else : [EOL] pid = None [EOL] exceptions = [ ] [EOL] inode = get_inode ( port ) [EOL] if not inode : [EOL] module . fail_json ( msg = [string] , exceptions = [ ] ) [EOL] [EOL] pid , exceptions = get_pid_from_inode ( inode ) [EOL] if not pid : [EOL] except_strings = [ str ( e ) for e in exceptions ] [EOL] module . fail_json ( msg = [string] , exceptions = except_strings ) [EOL] [EOL] try : [EOL] subprocess . check_output ( [ [string] , pid ] ) [EOL] except subprocess . CalledProcessError as e : [EOL] module . fail_json ( msg = [string] , exceptions = [ str ( e ) ] ) [EOL] [EOL] for fn in glob . glob ( LOG_STREAM_FILE . format ( log_uuid = [string] ) ) : [EOL] try : [EOL] os . unlink ( fn ) [EOL] except Exception as e : [EOL] module . fail_json ( msg = [string] . format ( fn = fn ) , exceptions = [ str ( e ) ] ) [EOL] [EOL] module . exit_json ( ) [EOL] [EOL] from ansible . module_utils . basic import * [comment] [EOL] from ansible . module_utils . basic import AnsibleModule [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $threading.Thread$ 0 $builtins.bool$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $select.poll$ 0 0 0 $select.poll$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $select.poll$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $select.poll$ 0 $select.poll$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from zuul . ansible import paths [EOL] network = paths . _import_ansible_action_plugin ( [string] ) [EOL] [EOL] [EOL] class ActionModule ( network . ActionModule ) : [EOL] [EOL] def run ( self , tmp = None , task_vars = None ) : [EOL] [EOL] return dict ( failed = True , msg = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Optional , Dict [EOL] import storyboard [EOL] import tools [EOL] import typing [EOL] import requests [EOL] import boartty . config [EOL] import boartty . sync [EOL] import logging [comment] [EOL] from pprint import pprint as p [comment] [EOL] [EOL] [EOL] class App ( object ) : [EOL] pass [EOL] [EOL] [EOL] def get_tasks ( sync ) : [EOL] task_list = [ ] [EOL] for story in sync . get ( [string] ) : [EOL] print ( [string] % ( story [ [string] ] , story [ [string] ] ) ) [EOL] for task in sync . get ( [string] % ( story [ [string] ] ) ) : [EOL] print ( [string] % ( task [ [string] ] , ) ) [EOL] task_list . append ( task ) [EOL] return task_list [EOL] [EOL] [EOL] def task_in_lane ( task , lane ) : [EOL] for item in lane [ [string] ] [ [string] ] : [EOL] if [string] in item and item [ [string] ] [ [string] ] == task [ [string] ] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def add_task ( sync , task , lane ) : [EOL] print ( [string] % ( task [ [string] ] , lane [ [string] ] [ [string] ] ) ) [EOL] r = sync . post ( [string] % lane [ [string] ] [ [string] ] , dict ( item_id = task [ [string] ] , item_type = [string] , list_position = [number] ) ) [EOL] print ( r ) [EOL] [EOL] [EOL] def remove_task ( sync , task , lane ) : [EOL] print ( [string] % ( task [ [string] ] , lane [ [string] ] [ [string] ] ) ) [EOL] for item in lane [ [string] ] [ [string] ] : [EOL] if [string] in item and item [ [string] ] [ [string] ] == task [ [string] ] : [EOL] r = sync . delete ( [string] % lane [ [string] ] [ [string] ] , dict ( item_id = item [ [string] ] ) ) [EOL] print ( r ) [EOL] [EOL] [EOL] MAP = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : None , [string] : None , } [EOL] [EOL] [EOL] def main ( ) : [EOL] requests . packages . urllib3 . disable_warnings ( ) [EOL] [comment] [EOL] app = App ( ) [EOL] app . config = boartty . config . Config ( [string] ) [EOL] sync = boartty . sync . Sync ( app , False ) [EOL] board = sync . get ( [string] ) [EOL] tasks = get_tasks ( sync ) [EOL] [EOL] lanes = dict ( ) [EOL] for lane in board [ [string] ] : [EOL] lanes [ lane [ [string] ] [ [string] ] ] = lane [EOL] [EOL] for task in tasks : [EOL] ok_lanes = MAP [ task [ [string] ] ] [EOL] task_found = False [EOL] for lane_name , lane in lanes . items ( ) : [EOL] if task_in_lane ( task , lane ) : [EOL] if ok_lanes and lane_name in ok_lanes : [EOL] task_found = True [EOL] else : [EOL] remove_task ( sync , task , lane ) [EOL] if ok_lanes and not task_found : [EOL] add_task ( sync , task , lanes [ ok_lanes [ [number] ] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0