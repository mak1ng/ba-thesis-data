from typing import List , Any , Dict [EOL] import pathlib [EOL] import typing [EOL] import json [EOL] from pathlib import Path [EOL] import platform [EOL] [EOL] HEADER = f" [string] { __file__ } [string] " [EOL] [EOL] PF = platform . system ( ) [EOL] [EOL] HOME_DIR = str ( Path . home ( ) ) [EOL] DATA_JSON = { [string] : HOME_DIR + [string] , [string] : HOME_DIR + [string] } [EOL] [EOL] ENUM_TRANSLATE = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] FILE_TRANSLATE = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def make_key ( key ) : [EOL] if key [ [number] ] . isdigit ( ) : [EOL] key = [string] + key [EOL] return key . upper ( ) . replace ( [string] , [string] ) [EOL] [EOL] def parse_data ( data ) : [EOL] [comment] [EOL] [EOL] units = parse_simple ( [string] , data ) [EOL] upgrades = parse_simple ( [string] , data ) [EOL] effects = parse_simple ( [string] , data ) [EOL] buffs = parse_simple ( [string] , data ) [EOL] [EOL] abilities = { } [EOL] for v in data [ [string] ] : [EOL] key = v [ [string] ] [EOL] remapid = v . get ( [string] ) [EOL] [EOL] if ( not key ) and ( remapid is None ) : [EOL] assert v [ [string] ] == [string] [EOL] continue [EOL] [EOL] if not key : [EOL] if v [ [string] ] != [string] : [EOL] key = v [ [string] ] [EOL] else : [EOL] exit ( f" [string] { v !r}" ) [EOL] [EOL] key = key . upper ( ) . replace ( [string] , [string] ) [EOL] [EOL] if [string] in v : [EOL] key = [string] . format ( v [ [string] ] . upper ( ) . replace ( [string] , [string] ) , key ) [EOL] [EOL] if [string] in v : [EOL] key = v [ [string] ] . upper ( ) . replace ( [string] , [string] ) [EOL] [EOL] if key [ [number] ] . isdigit ( ) : [EOL] key = [string] + key [EOL] [EOL] if key in abilities and v [ [string] ] == [number] : [EOL] print ( key ) [EOL] raise ValueError [EOL] abilities [ key ] = v [ [string] ] [EOL] [EOL] abilities [ [string] ] = [number] [EOL] [EOL] enums = { } [EOL] enums [ [string] ] = units [EOL] enums [ [string] ] = abilities [EOL] enums [ [string] ] = upgrades [EOL] enums [ [string] ] = buffs [EOL] enums [ [string] ] = effects [EOL] [EOL] return enums [EOL] [EOL] [EOL] def parse_simple ( d , data ) : [EOL] units = { } [EOL] for v in data [ d ] : [EOL] key = v [ [string] ] [EOL] [EOL] if not key : [EOL] continue [EOL] key_to_insert = make_key ( key ) [EOL] if key_to_insert in units : [EOL] index = [number] [EOL] tmp = f'{ key_to_insert } [string] { index }' [EOL] while tmp in units : [EOL] index += [number] [EOL] tmp = f'{ key_to_insert } [string] { index }' [EOL] key_to_insert = tmp [EOL] units [ key_to_insert ] = v [ [string] ] [EOL] [EOL] return units [EOL] [EOL] [EOL] def generate_python_code ( enums ) : [EOL] assert { [string] , [string] , [string] , [string] , [string] } <= enums . keys ( ) [EOL] [EOL] sc2dir = Path ( [string] ) [EOL] idsdir = ( sc2dir / [string] ) [EOL] idsdir . mkdir ( exist_ok = True ) [EOL] [EOL] with ( idsdir / [string] ) . open ( [string] ) as f : [EOL] f . write ( [string] . join ( [ HEADER , f" [string] { [ n . lower ( ) for n in FILE_TRANSLATE . values ( ) ] !r} [string] " ] ) ) [EOL] [EOL] for name , body in enums . items ( ) : [EOL] class_name = ENUM_TRANSLATE [ name ] [EOL] [EOL] code = [ HEADER , [string] , [string] , f" [string] { class_name } [string] " ] [EOL] [EOL] for key , value in sorted ( body . items ( ) , key = lambda p : p [ [number] ] ) : [EOL] code . append ( f" [string] { key } [string] { value }" ) [EOL] [EOL] code += [ [string] , f" [string] { class_name } [string] " , f" [string] " , f" [string] " , [string] ] [EOL] [EOL] with ( idsdir / FILE_TRANSLATE [ name ] ) . with_suffix ( [string] ) . open ( [string] ) as f : [EOL] f . write ( [string] . join ( code ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with open ( DATA_JSON [ PF ] , encoding = [string] ) as data_file : [EOL] data = json . loads ( data_file . read ( ) ) [EOL] generate_python_code ( parse_data ( data ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Optional , Dict , Set , Union , List , Any [EOL] import position [EOL] import typing [EOL] import unit [EOL] import ids [EOL] import builtins [EOL] import random [EOL] [EOL] from . unit import Unit [EOL] from . ids . unit_typeid import UnitTypeId [EOL] from . position import Point2 , Point3 [EOL] from typing import List , Dict , Set , Tuple , Any , Optional , Union [comment] [EOL] [EOL] class Units ( list ) : [EOL] [docstring] [EOL] @ classmethod def from_proto ( cls , units , game_data ) : [EOL] return cls ( ( Unit ( u , game_data ) for u in units ) , game_data ) [EOL] [EOL] def __init__ ( self , units , game_data ) : [EOL] super ( ) . __init__ ( units ) [EOL] self . game_data = game_data [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return UnitSelection ( self , * args , ** kwargs ) [EOL] [EOL] def select ( self , * args , ** kwargs ) : [EOL] return UnitSelection ( self , * args , ** kwargs ) [EOL] [EOL] def __or__ ( self , other ) : [EOL] tags = { unit . tag for unit in self } [EOL] units = self + [ unit for unit in other if unit . tag not in tags ] [EOL] return Units ( units , self . game_data ) [EOL] [EOL] def __and__ ( self , other ) : [EOL] tags = { unit . tag for unit in self } [EOL] units = [ unit for unit in other if unit . tag in tags ] [EOL] return Units ( units , self . game_data ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] tags = { unit . tag for unit in other } [EOL] units = [ unit for unit in self if unit . tag not in tags ] [EOL] return Units ( units , self . game_data ) [EOL] [EOL] @ property def amount ( self ) : [EOL] return len ( self ) [EOL] [EOL] @ property def empty ( self ) : [EOL] return self . amount == [number] [EOL] [EOL] @ property def exists ( self ) : [EOL] return not self . empty [EOL] [EOL] def find_by_tag ( self , tag ) : [EOL] for unit in self : [EOL] if unit . tag == tag : [EOL] return unit [EOL] return None [EOL] [EOL] def by_tag ( self , tag ) : [EOL] unit = self . find_by_tag ( tag ) [EOL] if unit is None : [EOL] raise KeyError ( [string] ) [EOL] return unit [EOL] [EOL] @ property def first ( self ) : [EOL] assert self . exists [EOL] return self [ [number] ] [EOL] [EOL] def take ( self , n , require_all = True ) : [EOL] assert ( not require_all ) or len ( self ) >= n [EOL] return self [ : n ] [EOL] [EOL] @ property def random ( self ) : [EOL] assert self . exists [EOL] return random . choice ( self ) [EOL] [EOL] def random_or ( self , other ) : [EOL] if self . exists : [EOL] return random . choice ( self ) [EOL] else : [EOL] return other [EOL] [EOL] def random_group_of ( self , n ) : [EOL] assert [number] <= n <= self . amount [EOL] if n == [number] : [EOL] return self . subgroup ( [ ] ) [EOL] elif self . amount == n : [EOL] return self [EOL] else : [EOL] return self . subgroup ( random . sample ( self , n ) ) [EOL] [EOL] def in_attack_range_of ( self , unit , bonus_distance = [number] ) : [EOL] [docstring] [EOL] return self . filter ( lambda x : unit . target_in_range ( x , bonus_distance = bonus_distance ) ) [EOL] [EOL] def closest_distance_to ( self , position ) : [EOL] [docstring] [EOL] assert self . exists [EOL] if isinstance ( position , Unit ) : [EOL] position = position . position [EOL] return position . distance_to_closest ( [ u . position for u in self ] ) [comment] [EOL] [EOL] def furthest_distance_to ( self , position ) : [EOL] [docstring] [EOL] assert self . exists [EOL] if isinstance ( position , Unit ) : [EOL] position = position . position [EOL] return position . distance_to_furthest ( [ u . position for u in self ] ) [EOL] [EOL] def closest_to ( self , position ) : [EOL] assert self . exists [EOL] if isinstance ( position , Unit ) : [EOL] position = position . position [EOL] return position . closest ( self ) [EOL] [EOL] def furthest_to ( self , position ) : [EOL] assert self . exists [EOL] if isinstance ( position , Unit ) : [EOL] position = position . position [EOL] return position . furthest ( self ) [EOL] [EOL] def closer_than ( self , distance , position ) : [EOL] if isinstance ( position , Unit ) : [EOL] position = position . position [EOL] return self . filter ( lambda unit : unit . position . distance_to_point2 ( position . to2 ) < distance ) [EOL] [EOL] def further_than ( self , distance , position ) : [EOL] if isinstance ( position , Unit ) : [EOL] position = position . position [EOL] return self . filter ( lambda unit : unit . position . distance_to_point2 ( position . to2 ) > distance ) [EOL] [EOL] def subgroup ( self , units ) : [EOL] return Units ( list ( units ) , self . game_data ) [EOL] [EOL] def filter ( self , pred ) : [EOL] return self . subgroup ( filter ( pred , self ) ) [EOL] [EOL] def sorted ( self , keyfn , reverse = False ) : [EOL] return self . subgroup ( sorted ( self , key = keyfn , reverse = reverse ) ) [EOL] [EOL] def sorted_by_distance_to ( self , position , reverse = False ) : [EOL] [docstring] [EOL] position = position . position [EOL] return self . sorted ( keyfn = lambda unit : unit . position . _distance_squared ( position ) , reverse = reverse ) [EOL] [EOL] def tags_in ( self , other ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( other , list ) : [EOL] other = set ( other ) [EOL] return self . filter ( lambda unit : unit . tag in other ) [EOL] [EOL] def tags_not_in ( self , other ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( other , list ) : [EOL] other = set ( other ) [EOL] return self . filter ( lambda unit : unit . tag not in other ) [EOL] [EOL] def of_type ( self , other ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( other , UnitTypeId ) : [EOL] other = { other } [EOL] if isinstance ( other , list ) : [EOL] other = set ( other ) [EOL] return self . filter ( lambda unit : unit . type_id in other ) [EOL] [EOL] def exclude_type ( self , other ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( other , UnitTypeId ) : [EOL] other = { other } [EOL] if isinstance ( other , list ) : [EOL] other = set ( other ) [EOL] return self . filter ( lambda unit : unit . type_id not in other ) [EOL] [EOL] def same_tech ( self , other ) : [EOL] [docstring] [EOL] if isinstance ( other , UnitTypeId ) : [EOL] other = { other } [EOL] tech_alias_types = set ( other ) [EOL] for unitType in other : [EOL] tech_alias = self . game_data . units [ unitType . value ] . tech_alias [EOL] if tech_alias : [EOL] for same in tech_alias : [EOL] tech_alias_types . add ( same ) [EOL] return self . filter ( lambda unit : unit . type_id in tech_alias_types or unit . _type_data . tech_alias is not None [EOL] and any ( same in tech_alias_types for same in unit . _type_data . tech_alias ) ) [EOL] [EOL] def same_unit ( self , other ) : [EOL] [docstring] [EOL] if isinstance ( other , UnitTypeId ) : [EOL] other = { other } [EOL] unit_alias_types = set ( other ) [EOL] for unitType in other : [EOL] unit_alias = self . game_data . units [ unitType . value ] . unit_alias [EOL] if unit_alias : [EOL] unit_alias_types . add ( unit_alias ) [EOL] return self . filter ( lambda unit : unit . type_id in unit_alias_types or unit . _type_data . unit_alias is not None [EOL] and unit . _type_data . unit_alias in unit_alias_types ) [EOL] [EOL] @ property def center ( self ) : [EOL] [docstring] [EOL] assert self . exists [EOL] pos = Point2 ( ( sum ( [ unit . position . x for unit in self ] ) / self . amount , sum ( [ unit . position . y for unit in self ] ) / self . amount ) ) [EOL] return pos [EOL] [EOL] @ property def selected ( self ) : [EOL] return self . filter ( lambda unit : unit . is_selected ) [EOL] [EOL] @ property def tags ( self ) : [EOL] return { unit . tag for unit in self } [EOL] [EOL] @ property def ready ( self ) : [EOL] return self . filter ( lambda unit : unit . is_ready ) [EOL] [EOL] @ property def not_ready ( self ) : [EOL] return self . filter ( lambda unit : not unit . is_ready ) [EOL] [EOL] @ property def noqueue ( self ) : [EOL] return self . filter ( lambda unit : unit . noqueue ) [EOL] [EOL] @ property def idle ( self ) : [EOL] return self . filter ( lambda unit : unit . is_idle ) [EOL] [EOL] @ property def owned ( self ) : [EOL] return self . filter ( lambda unit : unit . is_mine ) [EOL] [EOL] @ property def enemy ( self ) : [EOL] return self . filter ( lambda unit : unit . is_enemy ) [EOL] [EOL] @ property def flying ( self ) : [EOL] return self . filter ( lambda unit : unit . is_flying ) [EOL] [EOL] @ property def not_flying ( self ) : [EOL] return self . filter ( lambda unit : not unit . is_flying ) [EOL] [EOL] @ property def structure ( self ) : [EOL] return self . filter ( lambda unit : unit . is_structure ) [EOL] [EOL] @ property def not_structure ( self ) : [EOL] return self . filter ( lambda unit : not unit . is_structure ) [EOL] [EOL] @ property def gathering ( self ) : [EOL] return self . filter ( lambda unit : unit . is_gathering ) [EOL] [EOL] @ property def returning ( self ) : [EOL] return self . filter ( lambda unit : unit . is_returning ) [EOL] [EOL] @ property def collecting ( self ) : [EOL] return self . filter ( lambda unit : unit . is_collecting ) [EOL] [EOL] @ property def mineral_field ( self ) : [EOL] return self . filter ( lambda unit : unit . is_mineral_field ) [EOL] [EOL] @ property def vespene_geyser ( self ) : [EOL] return self . filter ( lambda unit : unit . is_vespene_geyser ) [EOL] [EOL] @ property def prefer_idle ( self ) : [EOL] return self . sorted ( lambda unit : unit . is_idle , reverse = True ) [EOL] [EOL] def prefer_close_to ( self , p ) : [EOL] return self . sorted ( lambda unit : unit . distance_to ( p ) ) [EOL] [EOL] [EOL] class UnitSelection ( Units ) : [EOL] def __init__ ( self , parent , unit_type_id = None ) : [EOL] assert unit_type_id is None or isinstance ( unit_type_id , ( UnitTypeId , set ) ) [EOL] if isinstance ( unit_type_id , set ) : [EOL] assert all ( isinstance ( t , UnitTypeId ) for t in unit_type_id ) [EOL] [EOL] self . unit_type_id = unit_type_id [EOL] super ( ) . __init__ ( [ u for u in parent if self . matches ( u ) ] , parent . game_data ) [EOL] [EOL] def matches ( self , unit ) : [EOL] if self . unit_type_id is None : [EOL] [comment] [EOL] return True [EOL] elif isinstance ( self . unit_type_id , set ) : [EOL] return unit . type_id in self . unit_type_id [EOL] else : [EOL] return self . unit_type_id == unit . type_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $position.Point2$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Units"$ 0 0 0 $typing.Union[unit.Unit,position.Point2,position.Point3]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[unit.Unit,position.Point2,position.Point3]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Optional [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Optional , List [EOL] [EOL] import sys [EOL] import signal [EOL] import time [EOL] import asyncio [EOL] import os . path [EOL] import shutil [EOL] import tempfile [EOL] import subprocess [EOL] import portpicker [EOL] import aiohttp [EOL] [EOL] import logging [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] from . paths import Paths [EOL] from . controller import Controller [EOL] [EOL] class kill_switch ( object ) : [EOL] _to_kill = [ ] [EOL] [EOL] @ classmethod def add ( cls , value ) : [EOL] logger . debug ( [string] ) [EOL] cls . _to_kill . append ( value ) [EOL] [EOL] @ classmethod def kill_all ( cls ) : [EOL] logger . info ( [string] ) [EOL] for p in cls . _to_kill : [EOL] p . _clean ( ) [EOL] [EOL] class SC2Process : [EOL] def __init__ ( self , host = [string] , port = None , fullscreen = False ) : [EOL] assert isinstance ( host , str ) [EOL] assert isinstance ( port , int ) or port is None [EOL] [EOL] self . _fullscreen = fullscreen [EOL] self . _host = host [EOL] if port is None : [EOL] self . _port = portpicker . pick_unused_port ( ) [EOL] else : [EOL] self . _port = port [EOL] self . _tmp_dir = tempfile . mkdtemp ( prefix = [string] ) [EOL] self . _process = None [EOL] self . _session = None [EOL] self . _ws = None [EOL] [EOL] async def __aenter__ ( self ) : [EOL] kill_switch . add ( self ) [EOL] [EOL] def signal_handler ( signal , frame ) : [EOL] kill_switch . kill_all ( ) [EOL] [EOL] signal . signal ( signal . SIGINT , signal_handler ) [EOL] [EOL] try : [EOL] self . _process = self . _launch ( ) [EOL] self . _ws = await self . _connect ( ) [EOL] except : [EOL] await self . _close_connection ( ) [EOL] self . _clean ( ) [EOL] raise [EOL] [EOL] return Controller ( self . _ws , self ) [EOL] [EOL] async def __aexit__ ( self , * args ) : [EOL] kill_switch . kill_all ( ) [EOL] signal . signal ( signal . SIGINT , signal . SIG_DFL ) [EOL] [EOL] @ property def ws_url ( self ) : [EOL] return f" [string] { self . _host } [string] { self . _port } [string] " [EOL] [EOL] def _launch ( self ) : [EOL] args = [ str ( Paths . EXECUTABLE ) , [string] , self . _host , [string] , str ( self . _port ) , [string] , [string] if self . _fullscreen else [string] , [string] , str ( Paths . BASE ) , [string] , self . _tmp_dir ] [EOL] [EOL] if logger . getEffectiveLevel ( ) <= logging . DEBUG : [EOL] args . append ( [string] ) [EOL] [EOL] return subprocess . Popen ( args , cwd = ( str ( Paths . CWD ) if Paths . CWD else None ) , ) [EOL] [EOL] async def _connect ( self ) : [EOL] for i in range ( [number] ) : [EOL] if self . _process == None : [EOL] [comment] [EOL] logger . debug ( [string] ) [EOL] sys . exit ( ) [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] try : [EOL] self . _session = aiohttp . ClientSession ( ) [EOL] ws = await self . _session . ws_connect ( self . ws_url , timeout = [number] ) [EOL] logger . debug ( [string] ) [EOL] return ws [EOL] except aiohttp . client_exceptions . ClientConnectorError : [EOL] await self . _session . close ( ) [EOL] if i > [number] : [EOL] logger . debug ( [string] ) [EOL] [EOL] logger . debug ( [string] ) [EOL] raise TimeoutError ( [string] ) [EOL] [EOL] async def _close_connection ( self ) : [EOL] logger . info ( [string] ) [EOL] [EOL] if self . _ws is not None : [EOL] await self . _ws . close ( ) [EOL] [EOL] if self . _session is not None : [EOL] await self . _session . close ( ) [EOL] [EOL] def _clean ( self ) : [EOL] logger . info ( [string] ) [EOL] [EOL] if self . _process is not None : [EOL] if self . _process . poll ( ) is None : [EOL] for _ in range ( [number] ) : [EOL] self . _process . terminate ( ) [EOL] time . sleep ( [number] ) [EOL] if self . _process . poll ( ) is not None : [EOL] break [EOL] else : [EOL] self . _process . kill ( ) [EOL] self . _process . wait ( ) [EOL] logger . error ( [string] ) [EOL] [EOL] if os . path . exists ( self . _tmp_dir ) : [EOL] shutil . rmtree ( self . _tmp_dir ) [EOL] [EOL] self . _process = None [EOL] self . _ws = None [EOL] logger . info ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Set [EOL] import position [EOL] import data [EOL] import typing [EOL] import score [EOL] import power_source [EOL] import ids [EOL] import units [EOL] import builtins [EOL] import pixel_map [EOL] from . units import Units [EOL] from . power_source import PsionicMatrix [EOL] from . pixel_map import PixelMap [EOL] from . pixel_map_feature import PixelMapFeature [EOL] from . ids . upgrade_id import UpgradeId [EOL] from . ids . effect_id import EffectId [EOL] from . position import Point2 , Point3 [EOL] from . data import Alliance , DisplayType [EOL] from . score import ScoreDetails [EOL] from typing import List , Dict , Set , Tuple , Any , Optional , Union [comment] [EOL] [EOL] class Blip ( object ) : [EOL] def __init__ ( self , proto ) : [EOL] self . _proto = proto [EOL] [EOL] @ property def is_blip ( self ) : [EOL] [docstring] [EOL] return self . _proto . is_blip [EOL] [EOL] @ property def is_snapshot ( self ) : [EOL] return self . _proto . display_type == DisplayType . Snapshot . value [EOL] [EOL] @ property def is_visible ( self ) : [EOL] return self . _proto . display_type == DisplayType . Visible . value [EOL] [EOL] @ property def alliance ( self ) : [EOL] return self . _proto . alliance [EOL] [EOL] @ property def is_mine ( self ) : [EOL] return self . _proto . alliance == Alliance . Self . value [EOL] [EOL] @ property def is_enemy ( self ) : [EOL] return self . _proto . alliance == Alliance . Enemy . value [EOL] [EOL] @ property def position ( self ) : [EOL] [docstring] [EOL] return self . position3d . to2 [EOL] [EOL] @ property def position3d ( self ) : [EOL] [docstring] [EOL] return Point3 . from_proto ( self . _proto . pos ) [EOL] [EOL] [EOL] class Common ( object ) : [EOL] ATTRIBUTES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , proto ) : [EOL] self . _proto = proto [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] assert attr in self . ATTRIBUTES , f" [string] { attr } [string] " [EOL] return int ( getattr ( self . _proto , attr ) ) [EOL] [EOL] [EOL] class EffectData ( object ) : [EOL] def __init__ ( self , proto ) : [EOL] self . _proto = proto [EOL] [EOL] @ property def id ( self ) : [EOL] return EffectId ( self . _proto . effect_id ) [EOL] [EOL] @ property def positions ( self ) : [EOL] return [ Point2 . from_proto ( p ) for p in self . _proto . pos ] [EOL] [EOL] [EOL] class GameState ( object ) : [EOL] def __init__ ( self , response_observation , game_data ) : [EOL] self . actions = response_observation . actions [comment] [EOL] self . action_errors = response_observation . action_errors [comment] [EOL] [comment] [EOL] [comment] [EOL] self . observation = response_observation . observation [EOL] self . player_result = response_observation . player_result [EOL] self . chat = response_observation . chat [EOL] self . common = Common ( self . observation . player_common ) [EOL] self . psionic_matrix = PsionicMatrix . from_proto ( self . observation . raw_data . player . power_sources ) [comment] [EOL] self . game_loop = self . observation . game_loop [comment] [EOL] [EOL] self . score = ScoreDetails ( self . observation . score ) [comment] [EOL] self . abilities = self . observation . abilities [comment] [EOL] destructables = [ x for x in self . observation . raw_data . units if x . alliance == [number] and x . radius > [number] ] [comment] [EOL] self . destructables = Units . from_proto ( destructables , game_data ) [EOL] [EOL] [comment] [EOL] visibleUnits , hiddenUnits = [ ] , [ ] [EOL] for u in self . observation . raw_data . units : [EOL] hiddenUnits . append ( u ) if u . is_blip else visibleUnits . append ( u ) [EOL] self . units = Units . from_proto ( visibleUnits , game_data ) [EOL] self . blips = { Blip ( unit ) for unit in hiddenUnits } [EOL] [EOL] self . visibility = PixelMap ( self . observation . raw_data . map_state . visibility ) [EOL] self . creep = PixelMap ( self . observation . raw_data . map_state . creep ) [EOL] [EOL] self . dead_units = { dead_unit_tag for dead_unit_tag in self . observation . raw_data . event . dead_units } [comment] [EOL] self . effects = { EffectData ( effect ) for effect in self . observation . raw_data . effects } [comment] [EOL] [docstring] [EOL] [EOL] self . upgrades = { UpgradeId ( upgrade ) for upgrade in self . observation . raw_data . player . upgrade_ids } [comment] [EOL] [EOL] [EOL] [comment] [EOL] self . feature = dict ( ) [EOL] self . feature [ [string] ] = dict ( ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . height_map , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . visibility_map , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . creep , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . power , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . player_id , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_type , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . selected , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_hit_points , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_hit_points_ratio , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_energy , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_energy_ratio , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_shields , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_shields_ratio , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . player_relative , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_density_aa , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . unit_density , [string] , [string] ) [EOL] self . feature [ [string] ] [ [string] ] = PixelMapFeature ( self . observation . feature_layer_data . renders . effects , [string] , [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] @ property def mineral_field ( self ) : [EOL] return self . units . mineral_field [EOL] [EOL] @ property def vespene_geyser ( self ) : [EOL] return self . units . vespene_geyser [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Common$ 0 0 0 0 0 0 0 0 0 0 0 0 $power_source.PsionicMatrix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $score.ScoreDetails$ 0 0 0 0 0 0 0 $score.ScoreDetails$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[Blip]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pixel_map.PixelMap$ 0 0 0 0 0 0 0 0 0 0 0 $pixel_map.PixelMap$ 0 0 0 0 $pixel_map.PixelMap$ 0 0 0 0 0 0 0 0 0 0 0 $pixel_map.PixelMap$ 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 $typing.Set[EffectData]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[EffectData]$ 0 0 0 0 0 0 0 0 $typing.Set[ids.upgrade_id.UpgradeId]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pixel_map.PixelMap$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[EffectData]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $units.Units$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Callable , Set , FrozenSet , List , Any [EOL] import position [EOL] import typing [EOL] import builtins [EOL] from typing import Callable , Set , FrozenSet , List [EOL] [EOL] from . position import Point2 [EOL] [EOL] class PixelMap ( object ) : [EOL] def __init__ ( self , proto ) : [EOL] self . _proto = proto [EOL] assert self . bits_per_pixel % [number] == [number] , [string] [EOL] assert self . width * self . height * self . bits_per_pixel / [number] == len ( self . _proto . data ) [EOL] self . data = bytearray ( self . _proto . data ) [EOL] [EOL] @ property def width ( self ) : [EOL] return self . _proto . size . x [EOL] [EOL] @ property def height ( self ) : [EOL] return self . _proto . size . y [EOL] [EOL] @ property def bits_per_pixel ( self ) : [EOL] return self . _proto . bits_per_pixel [EOL] [EOL] @ property def bytes_per_pixel ( self ) : [EOL] return self . _proto . bits_per_pixel // [number] [EOL] [EOL] def __getitem__ ( self , pos ) : [EOL] x , y = pos [EOL] [EOL] assert [number] <= x < self . width [EOL] assert [number] <= y < self . height [EOL] [EOL] index = - self . width * y + x [EOL] [comment] [EOL] start = index * self . bytes_per_pixel [EOL] data = self . data [ start : start + self . bytes_per_pixel ] [EOL] return int . from_bytes ( data , byteorder = [string] , signed = False ) [EOL] [EOL] def __setitem__ ( self , pos , val ) : [EOL] x , y = pos [EOL] [EOL] assert [number] <= x < self . width [EOL] assert [number] <= y < self . height [EOL] [EOL] index = self . width * y + x [EOL] start = index * self . bytes_per_pixel [EOL] self . data [ start : start + self . bytes_per_pixel ] = val [EOL] [EOL] def is_set ( self , p ) : [EOL] return self [ p ] != [number] [EOL] [EOL] def is_empty ( self , p ) : [EOL] return not self . is_set ( p ) [EOL] [EOL] def invert ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def flood_fill ( self , start_point , pred ) : [EOL] nodes = set ( ) [EOL] queue = [ start_point ] [EOL] [EOL] while queue : [EOL] x , y = queue . pop ( ) [EOL] [EOL] if not ( [number] <= x < self . width and [number] <= y < self . height ) : [EOL] continue [EOL] [EOL] if Point2 ( ( x , y ) ) in nodes : [EOL] continue [EOL] [EOL] if pred ( self [ x , y ] ) : [EOL] nodes . add ( Point2 ( ( x , y ) ) ) [EOL] [EOL] queue . append ( Point2 ( ( x + [number] , y ) ) ) [EOL] queue . append ( Point2 ( ( x - [number] , y ) ) ) [EOL] queue . append ( Point2 ( ( x , y + [number] ) ) ) [EOL] queue . append ( Point2 ( ( x , y - [number] ) ) ) [EOL] [EOL] return nodes [EOL] [EOL] def flood_fill_all ( self , pred ) : [EOL] groups = set ( ) [EOL] [EOL] for x in range ( self . width ) : [EOL] for y in range ( self . height ) : [EOL] if any ( ( x , y ) in g for g in groups ) : [EOL] continue [EOL] [EOL] if pred ( self [ x , y ] ) : [EOL] groups . add ( frozenset ( self . flood_fill ( Point2 ( ( x , y ) ) , pred ) ) ) [EOL] [EOL] return groups [EOL] [EOL] def print ( self , wide = False ) : [EOL] for y in range ( self . height ) : [EOL] for x in range ( self . width ) : [EOL] print ( [string] if self . is_set ( ( x , y ) ) else [string] , end = ( [string] if wide else [string] ) ) [EOL] print ( [string] ) [EOL] [EOL] def save_image ( self , filename ) : [EOL] data = [ ( [number] , [number] , self [ x , y ] ) for y in range ( self . height ) for x in range ( self . width ) ] [EOL] from PIL import Image [EOL] im = Image . new ( [string] , ( self . width , self . height ) ) [EOL] im . putdata ( data ) [EOL] im . save ( filename ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.bytearray$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 $position.Point2$ 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 $typing.Set[position.Point2]$ 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 $position.Point2$ 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , Generator , Any [EOL] import sc2 [EOL] import logging [EOL] import typing [EOL] import asyncio [EOL] import async_timeout [EOL] [EOL] import logging [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] from . sc2process import SC2Process [EOL] from . portconfig import Portconfig [EOL] from . client import Client [EOL] from . player import Human , Bot [EOL] from . data import Race , Difficulty , Result , ActionResult , CreateGameError [EOL] from . game_state import GameState [EOL] from . protocol import ConnectionAlreadyClosed [EOL] [EOL] async def _play_game_human ( client , player_id , realtime , game_time_limit ) : [EOL] while True : [EOL] state = await client . observation ( ) [EOL] if client . _game_result : [EOL] return client . _game_result [ player_id ] [EOL] [EOL] if game_time_limit and ( state . observation . observation . game_loop * [number] * ( [number] / [number] ) ) > game_time_limit : [EOL] print ( state . observation . game_loop , state . observation . game_loop * [number] ) [EOL] return Result . Tie [EOL] [EOL] if not realtime : [EOL] await client . step ( ) [EOL] [EOL] async def _play_game_ai ( client , player_id , ai , realtime , step_time_limit , game_time_limit ) : [EOL] game_data = await client . get_game_data ( ) [EOL] game_info = await client . get_game_info ( ) [EOL] [EOL] ai . _prepare_start ( client , player_id , game_info , game_data ) [EOL] ai . on_start ( ) [EOL] [EOL] iteration = [number] [EOL] while True : [EOL] state = await client . observation ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] gs = GameState ( state . observation , game_data ) [EOL] [EOL] if game_time_limit and ( gs . game_loop * [number] * ( [number] / [number] ) ) > game_time_limit : [EOL] ai . on_end ( Result . Tie ) [EOL] return Result . Tie [EOL] [EOL] ai . _prepare_step ( gs ) [EOL] [EOL] if iteration == [number] : [EOL] ai . _prepare_first_step ( ) [EOL] [EOL] logger . debug ( f" [string] { realtime }" ) [EOL] [EOL] try : [EOL] await ai . issue_events ( ) [EOL] if realtime : [EOL] await ai . on_step ( iteration ) [EOL] else : [EOL] logger . debug ( f" [string] { step_time_limit }" ) [EOL] try : [EOL] async with async_timeout . timeout ( step_time_limit ) : [EOL] await ai . on_step ( iteration ) [EOL] except asyncio . TimeoutError : [EOL] logger . warning ( f" [string] " ) [EOL] except Exception as e : [EOL] [comment] [EOL] logger . exception ( f" [string] " ) [comment] [EOL] logger . error ( f" [string] " ) [EOL] ai . on_end ( Result . Defeat ) [EOL] return Result . Defeat [EOL] [EOL] logger . debug ( f" [string] " ) [EOL] [EOL] if not realtime : [EOL] if not client . in_game : [comment] [EOL] ai . on_end ( client . _game_result [ player_id ] ) [EOL] return client . _game_result [ player_id ] [EOL] [EOL] await client . step ( ) [EOL] [EOL] iteration += [number] [EOL] [EOL] async def _play_game ( player , client , realtime , portconfig , step_time_limit = None , game_time_limit = None ) : [EOL] assert isinstance ( realtime , bool ) , repr ( realtime ) [EOL] [EOL] player_id = await client . join_game ( player . race , portconfig = portconfig ) [EOL] logging . info ( f" [string] { player_id }" ) [EOL] [EOL] if isinstance ( player , Human ) : [EOL] result = await _play_game_human ( client , player_id , realtime , game_time_limit ) [EOL] else : [EOL] result = await _play_game_ai ( client , player_id , player . ai , realtime , step_time_limit , game_time_limit ) [EOL] [EOL] logging . info ( f" [string] { player_id } [string] { result }" ) [EOL] return result [EOL] [EOL] async def _setup_host_game ( server , map_settings , players , realtime ) : [EOL] r = await server . create_game ( map_settings , players , realtime ) [EOL] if r . create_game . HasField ( [string] ) : [EOL] err = f" [string] { CreateGameError ( r . create_game . error ) }" [EOL] if r . create_game . HasField ( [string] ) : [EOL] err += f" [string] { r . create_game . error_details }" [EOL] logger . critical ( err ) [EOL] raise RuntimeError ( err ) [EOL] [EOL] return Client ( server . _ws ) [EOL] [EOL] [EOL] async def _host_game ( map_settings , players , realtime , portconfig = None , save_replay_as = None , step_time_limit = None , game_time_limit = None ) : [EOL] assert len ( players ) > [number] , [string] [EOL] [EOL] assert any ( isinstance ( p , ( Human , Bot ) ) for p in players ) [EOL] [EOL] async with SC2Process ( ) as server : [EOL] await server . ping ( ) [EOL] [EOL] client = await _setup_host_game ( server , map_settings , players , realtime ) [EOL] [EOL] try : [EOL] result = await _play_game ( players [ [number] ] , client , realtime , portconfig , step_time_limit , game_time_limit ) [EOL] if save_replay_as is not None : [EOL] await client . save_replay ( save_replay_as ) [EOL] await client . leave ( ) [EOL] await client . quit ( ) [EOL] except ConnectionAlreadyClosed : [EOL] logging . error ( f" [string] " ) [EOL] return None [EOL] [EOL] return result [EOL] [EOL] async def _host_game_aiter ( map_settings , players , realtime , portconfig = None , save_replay_as = None , step_time_limit = None , game_time_limit = None ) : [EOL] assert len ( players ) > [number] , [string] [EOL] [EOL] assert any ( isinstance ( p , ( Human , Bot ) ) for p in players ) [EOL] [EOL] async with SC2Process ( ) as server : [EOL] while True : [EOL] await server . ping ( ) [EOL] [EOL] client = await _setup_host_game ( server , map_settings , players , realtime ) [EOL] [EOL] try : [EOL] result = await _play_game ( players [ [number] ] , client , realtime , portconfig , step_time_limit , game_time_limit ) [EOL] [EOL] if save_replay_as is not None : [EOL] await client . save_replay ( save_replay_as ) [EOL] await client . leave ( ) [EOL] except ConnectionAlreadyClosed : [EOL] logging . error ( f" [string] " ) [EOL] return [EOL] [EOL] new_players = yield result [EOL] if new_players is not None : [EOL] players = new_players [EOL] [EOL] def _host_game_iter ( * args , ** kwargs ) : [EOL] game = _host_game_aiter ( * args , ** kwargs ) [EOL] new_playerconfig = None [EOL] while True : [EOL] new_playerconfig = yield asyncio . get_event_loop ( ) . run_until_complete ( game . asend ( new_playerconfig ) ) [EOL] [EOL] [EOL] async def _join_game ( players , realtime , portconfig , save_replay_as = None , step_time_limit = None , game_time_limit = None ) : [EOL] async with SC2Process ( ) as server : [EOL] await server . ping ( ) [EOL] [EOL] client = Client ( server . _ws ) [EOL] [EOL] try : [EOL] result = await _play_game ( players [ [number] ] , client , realtime , portconfig , step_time_limit , game_time_limit ) [EOL] if save_replay_as is not None : [EOL] await client . save_replay ( save_replay_as ) [EOL] await client . leave ( ) [EOL] await client . quit ( ) [EOL] except ConnectionAlreadyClosed : [EOL] logging . error ( f" [string] " ) [EOL] return None [EOL] [EOL] return result [EOL] [EOL] def run_game ( map_settings , players , ** kwargs ) : [EOL] if sum ( isinstance ( p , ( Human , Bot ) ) for p in players ) > [number] : [EOL] join_kwargs = { k : v for k , v in kwargs . items ( ) if k != [string] } [EOL] [EOL] portconfig = Portconfig ( ) [EOL] result = asyncio . get_event_loop ( ) . run_until_complete ( asyncio . gather ( _host_game ( map_settings , players , ** kwargs , portconfig = portconfig ) , _join_game ( players , ** join_kwargs , portconfig = portconfig ) ) ) [EOL] else : [EOL] result = asyncio . get_event_loop ( ) . run_until_complete ( _host_game ( map_settings , players , ** kwargs ) ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . ids . ability_id import * [EOL] from . ids . buff_id import * [EOL] from . ids . effect_id import * [EOL] from . ids . unit_typeid import * [EOL] from . ids . upgrade_id import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] [EOL] import six [EOL] [EOL] [EOL] class StaticData ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data ) : [EOL] [docstring] [EOL] self . _units = { u . unit_id : u . name for u in data . units } [EOL] self . _unit_stats = { u . unit_id : u for u in data . units } [EOL] self . _abilities = { a . ability_id : a for a in data . abilities } [EOL] self . _general_abilities = { a . remaps_to_ability_id for a in data . abilities if a . remaps_to_ability_id } [EOL] [EOL] for a in six . itervalues ( self . _abilities ) : [EOL] a . hotkey = a . hotkey . lower ( ) [EOL] [EOL] @ property def abilities ( self ) : [EOL] return self . _abilities [EOL] [EOL] @ property def units ( self ) : [EOL] return self . _units [EOL] [EOL] @ property def unit_stats ( self ) : [EOL] return self . _unit_stats [EOL] [EOL] @ property def general_abilities ( self ) : [EOL] return self . _general_abilities [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] UNIT_TYPES = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Optional , Tuple [EOL] import logging [EOL] import typing [EOL] import os [EOL] from pathlib import Path [EOL] import platform [EOL] import re [EOL] import logging [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] BASEDIR = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] USERPATH = { [string] : [string] , [string] : [string] , [string] : None } [EOL] [EOL] BINPATH = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] CWD = { [string] : [string] , [string] : None , [string] : None } [EOL] [EOL] PF = platform . system ( ) [EOL] [EOL] def get_env ( ) : [EOL] [comment] [EOL] return None [EOL] [EOL] def latest_executeble ( versions_dir ) : [EOL] latest = max ( ( int ( p . name [ [number] : ] ) , p ) for p in versions_dir . iterdir ( ) if p . is_dir ( ) and p . name . startswith ( [string] ) ) [EOL] version , path = latest [EOL] if version < [number] : [EOL] logger . critical ( f" [string] " ) [EOL] exit ( [number] ) [EOL] return path / BINPATH [ PF ] [EOL] [EOL] [EOL] class _MetaPaths ( type ) : [EOL] [docstring] [EOL] def __setup ( self ) : [EOL] if PF not in BASEDIR : [EOL] logger . critical ( f" [string] { PF } [string] " ) [EOL] exit ( [number] ) [EOL] [EOL] try : [EOL] base = os . environ . get ( [string] ) [EOL] if base is None and USERPATH [ PF ] is not None : [EOL] einfo = str ( Path . home ( ) . expanduser ( ) ) + USERPATH [ PF ] [EOL] if os . path . isfile ( einfo ) : [EOL] with open ( einfo ) as f : [EOL] content = f . read ( ) [EOL] if content : [EOL] base = re . search ( [string] , content ) . group ( [number] ) [EOL] if not os . path . exists ( base ) : [EOL] base = None [EOL] if base is None : [EOL] base = BASEDIR [ PF ] [EOL] self . BASE = Path ( base ) . expanduser ( ) [EOL] self . EXECUTABLE = latest_executeble ( self . BASE / [string] ) [EOL] self . CWD = self . BASE / CWD [ PF ] if CWD [ PF ] else None [EOL] [EOL] self . REPLAYS = self . BASE / [string] [EOL] [EOL] [EOL] if ( self . BASE / [string] ) . exists ( ) : [EOL] self . MAPS = self . BASE / [string] [EOL] else : [EOL] self . MAPS = self . BASE / [string] [EOL] except FileNotFoundError as e : [EOL] logger . critical ( f" [string] { e . filename } [string] " ) [EOL] exit ( [number] ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] self . __setup ( ) [EOL] return getattr ( self , attr ) [EOL] [EOL] class Paths ( metaclass = _MetaPaths ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import enum [EOL] [EOL] class UpgradeId ( enum . Enum ) : [EOL] NULL = [number] [EOL] CARRIERLAUNCHSPEEDUPGRADE = [number] [EOL] GLIALRECONSTITUTION = [number] [EOL] TUNNELINGCLAWS = [number] [EOL] CHITINOUSPLATING = [number] [EOL] HISECAUTOTRACKING = [number] [EOL] TERRANBUILDINGARMOR = [number] [EOL] TERRANINFANTRYWEAPONSLEVEL1 = [number] [EOL] TERRANINFANTRYWEAPONSLEVEL2 = [number] [EOL] TERRANINFANTRYWEAPONSLEVEL3 = [number] [EOL] NEOSTEELFRAME = [number] [EOL] TERRANINFANTRYARMORSLEVEL1 = [number] [EOL] TERRANINFANTRYARMORSLEVEL2 = [number] [EOL] TERRANINFANTRYARMORSLEVEL3 = [number] [EOL] REAPERSPEED = [number] [EOL] STIMPACK = [number] [EOL] SHIELDWALL = [number] [EOL] PUNISHERGRENADES = [number] [EOL] SIEGETECH = [number] [EOL] HIGHCAPACITYBARRELS = [number] [EOL] BANSHEECLOAK = [number] [EOL] MEDIVACCADUCEUSREACTOR = [number] [EOL] RAVENCORVIDREACTOR = [number] [EOL] HUNTERSEEKER = [number] [EOL] DURABLEMATERIALS = [number] [EOL] PERSONALCLOAKING = [number] [EOL] GHOSTMOEBIUSREACTOR = [number] [EOL] TERRANVEHICLEARMORSLEVEL1 = [number] [EOL] TERRANVEHICLEARMORSLEVEL2 = [number] [EOL] TERRANVEHICLEARMORSLEVEL3 = [number] [EOL] TERRANVEHICLEWEAPONSLEVEL1 = [number] [EOL] TERRANVEHICLEWEAPONSLEVEL2 = [number] [EOL] TERRANVEHICLEWEAPONSLEVEL3 = [number] [EOL] TERRANSHIPARMORSLEVEL1 = [number] [EOL] TERRANSHIPARMORSLEVEL2 = [number] [EOL] TERRANSHIPARMORSLEVEL3 = [number] [EOL] TERRANSHIPWEAPONSLEVEL1 = [number] [EOL] TERRANSHIPWEAPONSLEVEL2 = [number] [EOL] TERRANSHIPWEAPONSLEVEL3 = [number] [EOL] PROTOSSGROUNDWEAPONSLEVEL1 = [number] [EOL] PROTOSSGROUNDWEAPONSLEVEL2 = [number] [EOL] PROTOSSGROUNDWEAPONSLEVEL3 = [number] [EOL] PROTOSSGROUNDARMORSLEVEL1 = [number] [EOL] PROTOSSGROUNDARMORSLEVEL2 = [number] [EOL] PROTOSSGROUNDARMORSLEVEL3 = [number] [EOL] PROTOSSSHIELDSLEVEL1 = [number] [EOL] PROTOSSSHIELDSLEVEL2 = [number] [EOL] PROTOSSSHIELDSLEVEL3 = [number] [EOL] OBSERVERGRAVITICBOOSTER = [number] [EOL] GRAVITICDRIVE = [number] [EOL] EXTENDEDTHERMALLANCE = [number] [EOL] HIGHTEMPLARKHAYDARINAMULET = [number] [EOL] PSISTORMTECH = [number] [EOL] ZERGMELEEWEAPONSLEVEL1 = [number] [EOL] ZERGMELEEWEAPONSLEVEL2 = [number] [EOL] ZERGMELEEWEAPONSLEVEL3 = [number] [EOL] ZERGGROUNDARMORSLEVEL1 = [number] [EOL] ZERGGROUNDARMORSLEVEL2 = [number] [EOL] ZERGGROUNDARMORSLEVEL3 = [number] [EOL] ZERGMISSILEWEAPONSLEVEL1 = [number] [EOL] ZERGMISSILEWEAPONSLEVEL2 = [number] [EOL] ZERGMISSILEWEAPONSLEVEL3 = [number] [EOL] OVERLORDSPEED = [number] [EOL] OVERLORDTRANSPORT = [number] [EOL] BURROW = [number] [EOL] ZERGLINGATTACKSPEED = [number] [EOL] ZERGLINGMOVEMENTSPEED = [number] [EOL] HYDRALISKSPEED = [number] [EOL] ZERGFLYERWEAPONSLEVEL1 = [number] [EOL] ZERGFLYERWEAPONSLEVEL2 = [number] [EOL] ZERGFLYERWEAPONSLEVEL3 = [number] [EOL] ZERGFLYERARMORSLEVEL1 = [number] [EOL] ZERGFLYERARMORSLEVEL2 = [number] [EOL] ZERGFLYERARMORSLEVEL3 = [number] [EOL] INFESTORENERGYUPGRADE = [number] [EOL] CENTRIFICALHOOKS = [number] [EOL] BATTLECRUISERENABLESPECIALIZATIONS = [number] [EOL] BATTLECRUISERBEHEMOTHREACTOR = [number] [EOL] PROTOSSAIRWEAPONSLEVEL1 = [number] [EOL] PROTOSSAIRWEAPONSLEVEL2 = [number] [EOL] PROTOSSAIRWEAPONSLEVEL3 = [number] [EOL] PROTOSSAIRARMORSLEVEL1 = [number] [EOL] PROTOSSAIRARMORSLEVEL2 = [number] [EOL] PROTOSSAIRARMORSLEVEL3 = [number] [EOL] WARPGATERESEARCH = [number] [EOL] HALTECH = [number] [EOL] CHARGE = [number] [EOL] BLINKTECH = [number] [EOL] ANABOLICSYNTHESIS = [number] [EOL] OBVERSEINCUBATION = [number] [EOL] VIKINGJOTUNBOOSTERS = [number] [EOL] ORGANICCARAPACE = [number] [EOL] INFESTORPERISTALSIS = [number] [EOL] ABDOMINALFORTITUDE = [number] [EOL] HYDRALISKSPEEDUPGRADE = [number] [EOL] BANELINGBURROWMOVE = [number] [EOL] COMBATDRUGS = [number] [EOL] STRIKECANNONS = [number] [EOL] TRANSFORMATIONSERVOS = [number] [EOL] PHOENIXRANGEUPGRADE = [number] [EOL] TEMPESTRANGEUPGRADE = [number] [EOL] NEURALPARASITE = [number] [EOL] LOCUSTLIFETIMEINCREASE = [number] [EOL] ULTRALISKBURROWCHARGEUPGRADE = [number] [EOL] ORACLEENERGYUPGRADE = [number] [EOL] RESTORESHIELDS = [number] [EOL] PROTOSSHEROSHIPWEAPON = [number] [EOL] PROTOSSHEROSHIPDETECTOR = [number] [EOL] PROTOSSHEROSHIPSPELL = [number] [EOL] REAPERJUMP = [number] [EOL] INCREASEDRANGE = [number] [EOL] ZERGBURROWMOVE = [number] [EOL] ANIONPULSECRYSTALS = [number] [EOL] TERRANVEHICLEANDSHIPWEAPONSLEVEL1 = [number] [EOL] TERRANVEHICLEANDSHIPWEAPONSLEVEL2 = [number] [EOL] TERRANVEHICLEANDSHIPWEAPONSLEVEL3 = [number] [EOL] TERRANVEHICLEANDSHIPARMORSLEVEL1 = [number] [EOL] TERRANVEHICLEANDSHIPARMORSLEVEL2 = [number] [EOL] TERRANVEHICLEANDSHIPARMORSLEVEL3 = [number] [EOL] FLYINGLOCUSTS = [number] [EOL] ROACHSUPPLY = [number] [EOL] IMMORTALREVIVE = [number] [EOL] DRILLCLAWS = [number] [EOL] CYCLONELOCKONRANGEUPGRADE = [number] [EOL] CYCLONEAIRUPGRADE = [number] [EOL] LIBERATORMORPH = [number] [EOL] ADEPTSHIELDUPGRADE = [number] [EOL] LURKERRANGE = [number] [EOL] IMMORTALBARRIER = [number] [EOL] ADEPTKILLBOUNCE = [number] [EOL] ADEPTPIERCINGATTACK = [number] [EOL] CINEMATICMODE = [number] [EOL] CURSORDEBUG = [number] [EOL] MAGFIELDLAUNCHERS = [number] [EOL] EVOLVEGROOVEDSPINES = [number] [EOL] EVOLVEMUSCULARAUGMENTS = [number] [EOL] BANSHEESPEED = [number] [EOL] MEDIVACRAPIDDEPLOYMENT = [number] [EOL] RAVENRECALIBRATEDEXPLOSIVES = [number] [EOL] MEDIVACINCREASESPEEDBOOST = [number] [EOL] LIBERATORAGRANGEUPGRADE = [number] [EOL] DARKTEMPLARBLINKUPGRADE = [number] [EOL] RAVAGERRANGE = [number] [EOL] RAVENDAMAGEUPGRADE = [number] [EOL] CYCLONELOCKONDAMAGEUPGRADE = [number] [EOL] ARESCLASSWEAPONSSYSTEMVIKING = [number] [EOL] AUTOHARVESTER = [number] [EOL] HYBRIDCPLASMAUPGRADEHARD = [number] [EOL] HYBRIDCPLASMAUPGRADEINSANE = [number] [EOL] INTERCEPTORLIMIT4 = [number] [EOL] INTERCEPTORLIMIT6 = [number] [EOL] _330MMBARRAGECANNONS = [number] [EOL] NOTPOSSIBLESIEGEMODE = [number] [EOL] NEOSTEELFRAME_2 = [number] [EOL] NEOSTEELANDSHRIKETURRETICONUPGRADE = [number] [EOL] OCULARIMPLANTS = [number] [EOL] CROSSSPECTRUMDAMPENERS = [number] [EOL] ORBITALSTRIKE = [number] [EOL] CLUSTERBOMB = [number] [EOL] SHAPEDHULL = [number] [EOL] SPECTRETOOLTIPUPGRADE = [number] [EOL] ULTRACAPACITORS = [number] [EOL] VANADIUMPLATING = [number] [EOL] COMMANDCENTERREACTOR = [number] [EOL] REGENERATIVEBIOSTEEL = [number] [EOL] CELLULARREACTORS = [number] [EOL] BANSHEECLOAKEDDAMAGE = [number] [EOL] DISTORTIONBLASTERS = [number] [EOL] EMPTOWER = [number] [EOL] SUPPLYDEPOTDROP = [number] [EOL] HIVEMINDEMULATOR = [number] [EOL] FORTIFIEDBUNKERCARAPACE = [number] [EOL] PREDATOR = [number] [EOL] SCIENCEVESSEL = [number] [EOL] DUALFUSIONWELDERS = [number] [EOL] ADVANCEDCONSTRUCTION = [number] [EOL] ADVANCEDMEDICTRAINING = [number] [EOL] PROJECTILEACCELERATORS = [number] [EOL] REINFORCEDSUPERSTRUCTURE = [number] [EOL] MULE = [number] [EOL] ORBITALRELAY = [number] [EOL] RAZORWIRE = [number] [EOL] ADVANCEDHEALINGAI = [number] [EOL] TWINLINKEDFLAMETHROWERS = [number] [EOL] NANOCONSTRUCTOR = [number] [EOL] CERBERUSMINES = [number] [EOL] HYPERFLUXOR = [number] [EOL] TRILITHIUMPOWERCELLS = [number] [EOL] PERMANENTCLOAKGHOST = [number] [EOL] PERMANENTCLOAKSPECTRE = [number] [EOL] ULTRASONICPULSE = [number] [EOL] SURVIVALPODS = [number] [EOL] ENERGYSTORAGE = [number] [EOL] FULLBORECANISTERAMMO = [number] [EOL] CAMPAIGNJOTUNBOOSTERS = [number] [EOL] MICROFILTERING = [number] [EOL] PARTICLECANNONAIR = [number] [EOL] VULTUREAUTOREPAIR = [number] [EOL] PSIDISRUPTOR = [number] [EOL] SCIENCEVESSELENERGYMANIPULATION = [number] [EOL] SCIENCEVESSELPLASMAWEAPONRY = [number] [EOL] SHOWGATLINGGUN = [number] [EOL] TECHREACTOR = [number] [EOL] TECHREACTORAI = [number] [EOL] TERRANDEFENSERANGEBONUS = [number] [EOL] X88TNAPALMUPGRADE = [number] [EOL] HURRICANEMISSILES = [number] [EOL] MECHANICALREBIRTH = [number] [EOL] MARINESTIMPACK = [number] [EOL] DARKTEMPLARTACTICS = [number] [EOL] CLUSTERWARHEADS = [number] [EOL] CLOAKDISTORTIONFIELD = [number] [EOL] DEVASTATORMISSILES = [number] [EOL] DISTORTIONTHRUSTERS = [number] [EOL] DYNAMICPOWERROUTING = [number] [EOL] IMPALERROUNDS = [number] [EOL] KINETICFIELDS = [number] [EOL] BURSTCAPACITORS = [number] [EOL] HAILSTORMMISSILEPODS = [number] [EOL] RAPIDDEPLOYMENT = [number] [EOL] REAPERSTIMPACK = [number] [EOL] REAPERD8CHARGE = [number] [EOL] TYCHUS05BATTLECRUISERPENETRATION = [number] [EOL] VIRALPLASMA = [number] [EOL] FIREBATJUGGERNAUTPLATING = [number] [EOL] MULTILOCKTARGETINGSYSTEMS = [number] [EOL] TURBOCHARGEDENGINES = [number] [EOL] DISTORTIONSENSORS = [number] [EOL] INFERNALPREIGNITERS = [number] [EOL] HELLIONCAMPAIGNINFERNALPREIGNITER = [number] [EOL] NAPALMFUELTANKS = [number] [EOL] AUXILIARYMEDBOTS = [number] [EOL] JUGGERNAUTPLATING = [number] [EOL] MARAUDERLIFEBOOST = [number] [EOL] COMBATSHIELD = [number] [EOL] REAPERU238ROUNDS = [number] [EOL] MAELSTROMROUNDS = [number] [EOL] SIEGETANKSHAPEDBLAST = [number] [EOL] TUNGSTENSPIKES = [number] [EOL] BEARCLAWNOZZLES = [number] [EOL] NANOBOTINJECTORS = [number] [EOL] STABILIZERMEDPACKS = [number] [EOL] HALOROCKETS = [number] [EOL] SCAVENGINGSYSTEMS = [number] [EOL] EXTRAMINES = [number] [EOL] ARESCLASSWEAPONSSYSTEM = [number] [EOL] WHITENAPALM = [number] [EOL] VIRALMUNITIONS = [number] [EOL] JACKHAMMERCONCUSSIONGRENADES = [number] [EOL] FIRESUPPRESSIONSYSTEMS = [number] [EOL] FLARERESEARCH = [number] [EOL] MODULARCONSTRUCTION = [number] [EOL] EXPANDEDHULL = [number] [EOL] SHRIKETURRET = [number] [EOL] MICROFUSIONREACTORS = [number] [EOL] WRAITHCLOAK = [number] [EOL] SINGULARITYCHARGE = [number] [EOL] GRAVITICTHRUSTERS = [number] [EOL] YAMATOCANNON = [number] [EOL] DEFENSIVEMATRIX = [number] [EOL] DARKPROTOSS = [number] [EOL] TERRANINFANTRYWEAPONSULTRACAPACITORSLEVEL1 = [number] [EOL] TERRANINFANTRYWEAPONSULTRACAPACITORSLEVEL2 = [number] [EOL] TERRANINFANTRYWEAPONSULTRACAPACITORSLEVEL3 = [number] [EOL] TERRANINFANTRYARMORSVANADIUMPLATINGLEVEL1 = [number] [EOL] TERRANINFANTRYARMORSVANADIUMPLATINGLEVEL2 = [number] [EOL] TERRANINFANTRYARMORSVANADIUMPLATINGLEVEL3 = [number] [EOL] TERRANVEHICLEWEAPONSULTRACAPACITORSLEVEL1 = [number] [EOL] TERRANVEHICLEWEAPONSULTRACAPACITORSLEVEL2 = [number] [EOL] TERRANVEHICLEWEAPONSULTRACAPACITORSLEVEL3 = [number] [EOL] TERRANVEHICLEARMORSVANADIUMPLATINGLEVEL1 = [number] [EOL] TERRANVEHICLEARMORSVANADIUMPLATINGLEVEL2 = [number] [EOL] TERRANVEHICLEARMORSVANADIUMPLATINGLEVEL3 = [number] [EOL] TERRANSHIPWEAPONSULTRACAPACITORSLEVEL1 = [number] [EOL] TERRANSHIPWEAPONSULTRACAPACITORSLEVEL2 = [number] [EOL] TERRANSHIPWEAPONSULTRACAPACITORSLEVEL3 = [number] [EOL] TERRANSHIPARMORSVANADIUMPLATINGLEVEL1 = [number] [EOL] TERRANSHIPARMORSVANADIUMPLATINGLEVEL2 = [number] [EOL] TERRANSHIPARMORSVANADIUMPLATINGLEVEL3 = [number] [EOL] HIREKELMORIANMINERSPH = [number] [EOL] HIREDEVILDOGSPH = [number] [EOL] HIRESPARTANCOMPANYPH = [number] [EOL] HIREHAMMERSECURITIESPH = [number] [EOL] HIRESIEGEBREAKERSPH = [number] [EOL] HIREHELSANGELSPH = [number] [EOL] HIREDUSKWINGPH = [number] [EOL] HIREDUKESREVENGE = [number] [EOL] TOSHEASYMODE = [number] [EOL] VOIDRAYSPEEDUPGRADE = [number] [EOL] SMARTSERVOS = [number] [EOL] ARMORPIERCINGROCKETS = [number] [EOL] CYCLONERAPIDFIRELAUNCHERS = [number] [EOL] RAVENENHANCEDMUNITIONS = [number] [EOL] DIGGINGCLAWS = [number] [EOL] [EOL] for item in UpgradeId : [EOL] assert not item . name in globals ( ) [EOL] globals ( ) [ item . name ] = item [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] def is_submodule ( path ) : [EOL] if path . is_file ( ) : [EOL] return path . suffix == [string] and path . stem != [string] [EOL] elif path . is_dir ( ) : [EOL] return ( path / [string] ) . exists ( ) [EOL] return False [EOL] [EOL] __all__ = [ p . stem for p in Path ( __file__ ) . parent . iterdir ( ) if is_submodule ( p ) ] [EOL] [EOL] from . control_group import ControlGroup [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import RL [EOL] import typing [EOL] import numpy as np [EOL] import torch [EOL] import random [EOL] import cv2 [EOL] import torch . nn . functional as F [EOL] from torch import nn [EOL] [EOL] MEMORY_SIZE = [number] [EOL] GAMMA = [number] [EOL] [EOL] EPSILON_MIN = [number] [EOL] LEARNING_RATE = [number] [EOL] [EOL] class Net ( nn . Module ) : [EOL] [EOL] [EOL] def __init__ ( self , s_dim , a_dim , param_dim ) : [EOL] super ( Net , self ) . __init__ ( ) [EOL] [EOL] self . s_dim = s_dim [EOL] self . a_dim = a_dim [EOL] self . param_dim = param_dim [EOL] [EOL] self . conv = nn . Sequential ( nn . Conv2d ( in_channels = [number] , out_channels = [number] , kernel_size = [number] , padding = [number] ) , nn . ReLU ( ) , nn . MaxPool2d ( kernel_size = [number] ) , nn . Conv2d ( [number] , [number] , kernel_size = [number] , padding = [number] ) , nn . ReLU ( ) , nn . MaxPool2d ( kernel_size = [number] ) , nn . Conv2d ( [number] , [number] , kernel_size = [number] , padding = [number] ) , nn . ReLU ( ) , nn . MaxPool2d ( kernel_size = [number] ) , nn . Conv2d ( [number] , [number] , kernel_size = [number] , padding = [number] ) , nn . ReLU ( ) , ) . cuda ( ) [EOL] [EOL] self . action_fc = nn . Sequential ( nn . Linear ( [number] , [number] ) , nn . ReLU ( ) , nn . Linear ( [number] , a_dim ) , nn . ReLU ( ) ) . cuda ( ) [EOL] [EOL] self . param_fc = nn . Sequential ( nn . Linear ( [number] + a_dim , [number] ) , nn . ReLU ( ) , nn . Linear ( [number] , [number] ) , nn . Sigmoid ( ) ) . cuda ( ) [EOL] [EOL] [EOL] self . step = [number] [EOL] [EOL] def cnn_forward ( self , s ) : [EOL] if s . dim ( ) == [number] : [EOL] s = s [ np . newaxis , : ] [EOL] s = torch . Tensor ( s ) . cuda ( ) [EOL] conv_out = self . conv ( s ) [EOL] flatten = conv_out . view ( conv_out . size ( [number] ) , - [number] ) [EOL] return flatten [EOL] [EOL] def action_forward ( self , cnn_flatten ) : [EOL] return self . action_fc ( cnn_flatten ) [EOL] [EOL] def param_forward ( self , cnn_output , action ) : [EOL] [EOL] action = torch . LongTensor ( action ) . reshape ( [ - [number] , [number] ] ) . cuda ( ) [EOL] [EOL] onehot_action = torch . zeros ( len ( action ) , self . a_dim ) . cuda ( ) [EOL] onehot_action . scatter_ ( [number] , action , [number] ) [EOL] [EOL] input = torch . cat ( ( cnn_output , onehot_action ) , - [number] ) [EOL] return self . param_fc ( input ) [EOL] [EOL] [EOL] class DQN ( ) : [EOL] def __init__ ( self , s_dim , a_dim ) : [EOL] self . replay_buffer = [ ] [EOL] self . global_step = [number] [EOL] self . global_episode = [number] [EOL] self . epsilon = [number] [EOL] [EOL] self . s_dim = s_dim [EOL] self . a_dim = a_dim [EOL] [EOL] self . m_net = Net ( s_dim , a_dim , [number] ) [comment] [EOL] self . t_net = Net ( s_dim , a_dim , [number] ) [EOL] [EOL] self . require_position = [ False , False , False , True , True ] [EOL] [EOL] initialize ( self . m_net ) [EOL] initialize ( self . t_net ) [EOL] [EOL] self . optimizer = torch . optim . Adam ( self . m_net . parameters ( ) , lr = LEARNING_RATE ) [EOL] [EOL] def update_target ( self ) : [EOL] self . t_net . load_state_dict ( self . m_net . state_dict ( ) ) [EOL] [EOL] def push_to_buffer ( self , s , a , action_r , param_r , s_ ) : [EOL] s = s . reshape ( - [number] ) [EOL] a = np . array ( [ a ] ) . reshape ( - [number] ) [EOL] action_r = np . array ( [ action_r ] ) . reshape ( - [number] ) [EOL] param_r = np . array ( [ param_r ] ) . reshape ( - [number] ) [EOL] s_ = s_ . reshape ( - [number] ) [EOL] [EOL] transition = np . hstack ( ( s , a , action_r , param_r , s_ ) ) [EOL] if self . is_replay_full ( ) : [EOL] self . replay_buffer . pop ( [number] ) [EOL] self . replay_buffer . append ( transition ) [EOL] [EOL] def clear_buffer ( self ) : [EOL] self . replay_buffer . clear ( ) [EOL] [EOL] def is_replay_full ( self ) : [EOL] return len ( self . replay_buffer ) == MEMORY_SIZE [EOL] [EOL] def train ( self ) : [EOL] sample = random . sample ( self . replay_buffer , [number] ) [EOL] action_loss , param_loss = self . get_loss ( sample ) [EOL] [EOL] [comment] [EOL] [docstring] [EOL] [comment] [EOL] self . optimizer . zero_grad ( ) [EOL] action_loss . backward ( ) [EOL] self . optimizer . step ( ) [EOL] [EOL] [EOL] def get_action ( self , obs ) : [EOL] cnn_feature = self . m_net . cnn_forward ( np2torch ( obs ) ) [EOL] [EOL] if random . uniform ( [number] , [number] ) <= self . epsilon : [comment] [EOL] rand_a = np . random . randint ( [number] , self . a_dim ) [EOL] action = np . array ( [ [ rand_a ] ] ) [EOL] param = np . random . rand ( [number] ) [EOL] else : [EOL] q_value = self . m_net . action_forward ( cnn_feature ) [EOL] action = torch . argmax ( q_value ) . cpu ( ) . detach ( ) . reshape ( [ - [number] , [number] ] ) [EOL] param = np . random . rand ( [number] ) [EOL] [EOL] if ( self . epsilon > EPSILON_MIN ) : [EOL] self . epsilon = self . epsilon * [number] [EOL] [EOL] return int ( action ) , param [EOL] [EOL] def get_param ( self , cnn_feature , action ) : [EOL] return self . get_param ( cnn_feature , action ) [EOL] [EOL] def get_probs ( self , obs ) : [EOL] cnn_feature = self . m_net . cnn_forward ( np2torch ( obs ) ) [EOL] q_value = self . m_net . action_forward ( cnn_feature ) [EOL] [comment] [EOL] return q_value . detach ( ) . cpu ( ) . numpy ( ) [ [number] ] [EOL] [EOL] def get_loss ( self , memory ) : [EOL] s_dim = self . s_dim [EOL] memory = np . vstack ( memory ) [EOL] [EOL] [comment] [EOL] q_batch_s = torch . Tensor ( memory [ : , [number] : [number] ] ) . reshape ( [ - [number] , [number] , [number] , [number] ] ) [EOL] q_batch_a = torch . LongTensor ( memory [ : , [number] ] ) . reshape ( [ - [number] , [number] ] ) [EOL] q_batch_r = torch . Tensor ( memory [ : , [number] ] ) . reshape ( [ - [number] , [number] ] ) [EOL] p_batch_r = torch . Tensor ( memory [ : , [number] ] ) . reshape ( [ - [number] , [number] ] ) [EOL] q_batch_s_ = torch . Tensor ( memory [ : , [number] : ] ) . reshape ( [ - [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] m_cnn_features = self . m_net . cnn_forward ( q_batch_s ) [EOL] t_cnn_features = self . t_net . cnn_forward ( q_batch_s_ ) . detach ( ) [EOL] [EOL] [comment] [EOL] t_q_next = self . t_net . action_forward ( t_cnn_features ) . cpu ( ) . max ( dim = - [number] ) [ [number] ] . reshape ( [ - [number] , [number] ] ) . detach ( ) [EOL] q_target = ( q_batch_r + GAMMA * t_q_next ) [EOL] q_main = self . m_net . action_forward ( m_cnn_features ) . gather ( dim = [number] , index = q_batch_a . cuda ( ) ) . cpu ( ) [EOL] action_loss = torch . nn . MSELoss ( ) ( q_main , q_target ) [EOL] [EOL] [comment] [EOL] [docstring] [EOL] [comment] [EOL] return action_loss , None [EOL] [EOL] def save ( self ) : [EOL] state = { [string] : self . global_episode , [string] : self . global_step , [string] : self . m_net . state_dict ( ) , [string] : self . t_net . state_dict ( ) , [string] : self . epsilon } [EOL] torch . save ( state , [string] + ( [string] % ( self . global_episode ) ) + [string] ) [EOL] [EOL] def load ( self , path ) : [EOL] data = torch . load ( [string] + path ) [EOL] self . global_episode = data [ [string] ] [EOL] self . global_step = data [ [string] ] [EOL] self . m_net . load_state_dict ( data [ [string] ] ) [EOL] self . t_net . load_state_dict ( data [ [string] ] ) [EOL] [comment] [EOL] self . epsilon = data [ [string] ] [EOL] print ( [string] + path ) [EOL] [EOL] def np2torch ( np_array , dtype = np . float32 ) : [EOL] if np_array . dtype != dtype : [EOL] np_array = np_array . astype ( dtype ) [EOL] return torch . from_numpy ( np_array ) [EOL] [EOL] [EOL] def initialize ( m ) : [EOL] if type ( m ) == nn . Linear : [EOL] m . weight . data . normal_ ( [number] , [number] ) [EOL] m . bias . data . fill_ ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RL.Net.Net$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $RL.Net.Net$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RL.Net.Net$ 0 0 0 0 0 0 $RL.Net.Net$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RL.Net.Net$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.float$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type [EOL] import RL [EOL] import typing [EOL] import pickle [EOL] import numpy as np [EOL] import cv2 [EOL] [EOL] import sc2 . colors as colors [EOL] [EOL] class UnitFeature ( ) : [EOL] [EOL] palette = None [EOL] obs = None [EOL] width = None [EOL] height = None [EOL] [EOL] [comment] [EOL] def __init__ ( self , feature_map = None ) : [EOL] self . palette = colors . unit_type ( ) [EOL] assert feature_map is not None [EOL] self . width = feature_map . size . x [EOL] self . height = feature_map . size . y [EOL] self . raw = np . frombuffer ( bytearray ( feature_map . data ) , dtype = np . int32 ) . reshape ( self . height , self . width ) [EOL] [EOL] @ property def numpy ( self ) : [EOL] output = np . zeros ( [ self . height , self . width , [number] ] ) [EOL] for y in range ( self . height ) : [EOL] for x in range ( self . width ) : [EOL] color = self . palette [ self . raw [ y ] [ x ] ] [EOL] output [ y ] [ x ] = color [EOL] [EOL] [comment] [EOL] return output [EOL] [EOL] [comment] [EOL] @ property def dataset ( self ) : [EOL] src = self . numpy [EOL] return np . array ( cv2 . split ( src ) ) [EOL] [EOL] def show ( self , w_name = [string] ) : [EOL] img = self . numpy / [number] [EOL] cv2 . imshow ( w_name , img ) [EOL] cv2 . waitKey ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0
from sc2 . constants import * [EOL] from sc2 . position import Point2 [EOL] [EOL] class Macro ( ) : [EOL] def __init__ ( self , bot ) : [EOL] self . env = bot [EOL] [EOL] async def run ( self , action , param = None ) : [EOL] await self . default_action ( ) [EOL] [EOL] if param [ [number] ] is not None : [EOL] param [ [number] ] = int ( param [ [number] ] * self . env . game_info . playable_area . width + self . env . game_info . playable_area . x ) [EOL] param [ [number] ] = int ( param [ [number] ] * self . env . game_info . playable_area . height + self . env . game_info . playable_area . y ) [EOL] [EOL] if action == [number] : [EOL] self . NO_OP ( ) [EOL] elif action == [number] : [EOL] await self . TRAIN_SCV ( ) [EOL] elif action == [number] : [EOL] await self . TRAIN_MARINE ( ) [EOL] elif action == [number] : [EOL] await self . BUILD_SUPPLYDEPOT ( pos = param ) [EOL] elif action == [number] : [EOL] await self . BUILD_BARRACK ( pos = param ) [EOL] [EOL] async def default_action ( self ) : [EOL] [comment] [EOL] try : [EOL] await self . env . distribute_workers ( ) [EOL] except : [EOL] pass [EOL] [EOL] def NO_OP ( self ) : [EOL] pass [EOL] [EOL] async def TRAIN_SCV ( self ) : [EOL] cc = self . env . units ( COMMANDCENTER ) . random [EOL] await self . env . do_actions ( actions = [ cc . train ( SCV ) ] ) [EOL] [EOL] async def BUILD_SUPPLYDEPOT ( self , pos = None ) : [EOL] if pos is None : return [EOL] scv = self . env . units ( SCV ) [EOL] if not scv : [EOL] return [EOL] scv = scv . random [EOL] await self . env . build ( SUPPLYDEPOT , near = Point2 ( ( pos [ [number] ] , pos [ [number] ] ) ) ) [EOL] [EOL] [EOL] async def BUILD_BARRACK ( self , pos = None ) : [EOL] if pos is None : return [EOL] scv = self . env . units ( SCV ) [EOL] if not scv : [EOL] return [EOL] scv = scv . random [EOL] await self . env . build ( BARRACKS , near = Point2 ( ( pos [ [number] ] , pos [ [number] ] ) ) ) [EOL] [EOL] async def TRAIN_MARINE ( self ) : [EOL] br = self . env . units ( BARRACKS ) [EOL] if not br : [EOL] return [EOL] br = br . random [EOL] await self . env . do_actions ( actions = [ br . train ( MARINE ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Type [EOL] import RL [EOL] import typing [EOL] import random [EOL] import time [EOL] import sc2 [EOL] import torch [EOL] [EOL] from sc2 import Race , Difficulty [EOL] from sc2 . constants import * [EOL] from sc2 . player import Bot , Human [EOL] from sc2 . unit_command import UnitCommand [EOL] from sc2 . position import Point2 , Point3 [EOL] [EOL] from FeatureRGB import UnitFeature [EOL] from Net import DQN [EOL] from Macro import Macro [EOL] [EOL] LOAD_MODEL = True [EOL] MODEL_NAME = [string] [EOL] [EOL] class RLAgent ( sc2 . BotAI ) : [EOL] [EOL] [comment] [EOL] f_unit = None [EOL] net = None [EOL] macro = None [EOL] [EOL] [comment] [EOL] obs = None [EOL] [EOL] def __init__ ( self ) : [EOL] self . macro = Macro ( self ) [EOL] [EOL] self . available_actions = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . require_position = [ False , False , False , True , True ] [EOL] [EOL] self . DQN = DQN ( [number] , len ( self . available_actions ) ) [EOL] [EOL] self . prev_obs = None [EOL] self . prev_a = None [EOL] self . prev_score = [number] [EOL] [EOL] self . g_episode = [number] [EOL] [EOL] [comment] [EOL] self . prev_collected_minerals = [number] [EOL] self . prev_collected_minerals_efficiency = [number] [EOL] [EOL] if LOAD_MODEL : [EOL] self . DQN . load ( MODEL_NAME ) [EOL] [EOL] [EOL] def on_start ( self ) : [EOL] self . _client . game_step = [number] [EOL] [EOL] [docstring] [EOL] async def on_step ( self , iteration ) : [EOL] if self . state . player_result : [EOL] self . prev_obs = None [EOL] self . prev_a = None [EOL] self . prev_score = [number] [EOL] self . prev_collected_minerals = [number] [EOL] self . prev_collected_minerals_efficiency = [number] [EOL] [EOL] self . DQN . global_episode += [number] [EOL] print ( [string] % ( self . DQN . global_episode , self . DQN . global_step , self . state . score . score , self . DQN . epsilon ) ) [EOL] [EOL] await self . _client . reset ( ) [EOL] [EOL] if self . DQN . global_episode % [number] == [number] : [EOL] try : [EOL] self . DQN . save ( ) [EOL] except : [EOL] pass [EOL] await self . macro . default_action ( ) [EOL] [EOL] self . DQN . global_step += [number] [EOL] [EOL] [comment] [EOL] collected = self . state . score . collected_minerals - self . prev_collected_minerals [EOL] param_r = [number] [EOL] if collected < self . prev_collected_minerals_efficiency : [EOL] param_r = - [number] [EOL] [EOL] [comment] [EOL] action_r = self . state . score . score - self . prev_score [EOL] [EOL] obs = self . state . feature [ [string] ] [ [string] ] [EOL] unit_feature = UnitFeature ( feature_map = obs ) [EOL] obs = unit_feature . dataset [EOL] [EOL] action , param = self . DQN . get_action ( obs ) [EOL] [EOL] [EOL] if self . prev_obs is not None : [EOL] self . DQN . push_to_buffer ( self . prev_obs , self . prev_a , action_r , param_r , obs ) [EOL] [EOL] if self . DQN . global_step > [number] and len ( self . DQN . replay_buffer ) > [number] : [EOL] self . DQN . train ( ) [EOL] [EOL] if self . DQN . global_step % [number] == [number] : [EOL] self . DQN . update_target ( ) [EOL] [EOL] self . prev_obs = obs [EOL] self . prev_a = action [EOL] self . prev_param = param [EOL] self . prev_score = self . state . score . score [EOL] self . prev_collected_minerals = self . state . score . collected_minerals [EOL] self . prev_collected_minerals_efficiency = collected [EOL] [EOL] q_value = self . DQN . get_probs ( obs ) [EOL] debug = [string] + str ( q_value [ [number] ] ) + [string] + str ( q_value [ [number] ] ) + [string] + str ( q_value [ [number] ] ) + [string] + str ( q_value [ [number] ] ) + [string] + str ( q_value [ [number] ] ) + [string] + str ( action_r ) + [string] + str ( param_r ) + [string] + str ( len ( self . DQN . replay_buffer ) ) [EOL] self . _client . debug_text_2d ( text = debug , pos = Point2 ( ( [number] , [number] ) ) , size = [number] ) [EOL] await self . _client . send_debug ( ) [EOL] [EOL] try : [EOL] await self . macro . run ( action , param ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] [EOL] def on_end ( self , result ) : [EOL] pass [EOL] [EOL] [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] sc2 . run_game ( sc2 . maps . get ( [string] ) , [ Bot ( Race . Terran , RLAgent ( ) ) ] , realtime = False ) [EOL] [docstring] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] class Writer ( ) : [EOL] [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] [EOL] def on_episode_finished ( self ) : [EOL] pass [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import sc2 [EOL] import typing [EOL] import pickle [EOL] import matplotlib . pyplot as plt [EOL] import cv2 [EOL] import numpy [EOL] from PIL import Image [EOL] from sc2 . pixel_map import PixelMap [EOL] import time [EOL] from enum import Enum [EOL] [EOL] from sc2 . pixel_map_feature import PixelMapFeature [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] obs = pickle . load ( f ) [EOL] f . close ( ) [EOL] [comment] [EOL] print ( [string] , time . time ( ) ) [EOL] unit_type = obs . feature_layer_data . renders . unit_energy_ratio [EOL] pm = PixelMapFeature ( unit_type , [string] , [string] ) [EOL] print ( pm . numpy . shape ) [EOL] [EOL] [EOL] print ( [string] , time . time ( ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $sc2.pixel_map_feature.PixelMapFeature$ 0 0 0 0 0 0 0 0 0 0 0 0 $sc2.pixel_map_feature.PixelMapFeature$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import random [EOL] [EOL] import sc2 [EOL] from sc2 import Race , Difficulty [EOL] from sc2 . constants import * [EOL] from sc2 . ids . buff_id import BuffId [EOL] from sc2 . player import Bot , Computer [EOL] [EOL] class ThreebaseVoidrayBot ( sc2 . BotAI ) : [EOL] def select_target ( self , state ) : [EOL] if self . known_enemy_structures . exists : [EOL] return random . choice ( self . known_enemy_structures ) [EOL] [EOL] return self . enemy_start_locations [ [number] ] [EOL] [EOL] async def on_step ( self , iteration ) : [EOL] if iteration == [number] : [EOL] await self . chat_send ( [string] ) [EOL] [EOL] if not self . units ( NEXUS ) . ready . exists : [EOL] for worker in self . workers : [EOL] await self . do ( worker . attack ( self . enemy_start_locations [ [number] ] ) ) [EOL] return [EOL] else : [EOL] nexus = self . units ( NEXUS ) . ready . random [EOL] [EOL] if not nexus . has_buff ( BuffId . CHRONOBOOSTENERGYCOST ) : [EOL] abilities = await self . get_available_abilities ( nexus ) [EOL] if AbilityId . EFFECT_CHRONOBOOSTENERGYCOST in abilities : [EOL] await self . do ( nexus ( AbilityId . EFFECT_CHRONOBOOSTENERGYCOST , nexus ) ) [EOL] [EOL] for idle_worker in self . workers . idle : [EOL] mf = self . state . mineral_field . closest_to ( idle_worker ) [EOL] await self . do ( idle_worker . gather ( mf ) ) [EOL] [EOL] if self . units ( VOIDRAY ) . amount > [number] and iteration % [number] == [number] : [EOL] for vr in self . units ( VOIDRAY ) . idle : [EOL] await self . do ( vr . attack ( self . select_target ( self . state ) ) ) [EOL] [EOL] for a in self . units ( ASSIMILATOR ) : [EOL] if a . assigned_harvesters < a . ideal_harvesters : [EOL] w = self . workers . closer_than ( [number] , a ) [EOL] if w . exists : [EOL] await self . do ( w . random . gather ( a ) ) [EOL] [EOL] if self . supply_left < [number] and not self . already_pending ( PYLON ) : [EOL] if self . can_afford ( PYLON ) : [EOL] await self . build ( PYLON , near = nexus ) [EOL] return [EOL] [EOL] if self . workers . amount < self . units ( NEXUS ) . amount * [number] and nexus . noqueue : [EOL] if self . can_afford ( PROBE ) : [EOL] await self . do ( nexus . train ( PROBE ) ) [EOL] [EOL] elif not self . units ( PYLON ) . exists and not self . already_pending ( PYLON ) : [EOL] if self . can_afford ( PYLON ) : [EOL] await self . build ( PYLON , near = nexus ) [EOL] [EOL] if self . units ( NEXUS ) . amount < [number] and not self . already_pending ( NEXUS ) : [EOL] if self . can_afford ( NEXUS ) : [EOL] await self . expand_now ( ) [EOL] [EOL] if self . units ( PYLON ) . ready . exists : [EOL] pylon = self . units ( PYLON ) . ready . random [EOL] if self . units ( GATEWAY ) . ready . exists : [EOL] if not self . units ( CYBERNETICSCORE ) . exists : [EOL] if self . can_afford ( CYBERNETICSCORE ) and not self . already_pending ( CYBERNETICSCORE ) : [EOL] await self . build ( CYBERNETICSCORE , near = pylon ) [EOL] else : [EOL] if self . can_afford ( GATEWAY ) and not self . already_pending ( GATEWAY ) : [EOL] await self . build ( GATEWAY , near = pylon ) [EOL] [EOL] for nexus in self . units ( NEXUS ) . ready : [EOL] vgs = self . state . vespene_geyser . closer_than ( [number] , nexus ) [EOL] for vg in vgs : [EOL] if not self . can_afford ( ASSIMILATOR ) : [EOL] break [EOL] [EOL] worker = self . select_build_worker ( vg . position ) [EOL] if worker is None : [EOL] break [EOL] [EOL] if not self . units ( ASSIMILATOR ) . closer_than ( [number] , vg ) . exists : [EOL] await self . do ( worker . build ( ASSIMILATOR , vg ) ) [EOL] [EOL] if self . units ( PYLON ) . ready . exists and self . units ( CYBERNETICSCORE ) . ready . exists : [EOL] pylon = self . units ( PYLON ) . ready . random [EOL] if self . units ( STARGATE ) . amount < [number] and not self . already_pending ( STARGATE ) : [EOL] if self . can_afford ( STARGATE ) : [EOL] await self . build ( STARGATE , near = pylon ) [EOL] [EOL] for sg in self . units ( STARGATE ) . ready . noqueue : [EOL] if self . can_afford ( VOIDRAY ) : [EOL] await self . do ( sg . train ( VOIDRAY ) ) [EOL] [EOL] def main ( ) : [EOL] sc2 . run_game ( sc2 . maps . get ( [string] ) , [ Bot ( Race . Protoss , ThreebaseVoidrayBot ( ) ) , Computer ( Race . Protoss , Difficulty . Easy ) ] , realtime = False ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] import random [EOL] [EOL] import sc2 [EOL] from sc2 import Race , Difficulty [EOL] from sc2 . constants import * [EOL] from sc2 . player import Bot , Computer [EOL] from sc2 . position import Point2 , Point3 [EOL] [EOL] [EOL] class RampWallBot ( sc2 . BotAI ) : [EOL] async def on_step ( self , iteration ) : [EOL] cc = self . units ( COMMANDCENTER ) [EOL] if not cc . exists : [EOL] return [EOL] else : [EOL] cc = cc . first [EOL] [EOL] if self . can_afford ( SCV ) and self . workers . amount < [number] and cc . noqueue : [EOL] await self . do ( cc . train ( SCV ) ) [EOL] [EOL] [EOL] [comment] [EOL] for depo in self . units ( SUPPLYDEPOT ) . ready : [EOL] for unit in self . known_enemy_units . not_structure : [EOL] if unit . position . to2 . distance_to ( depo . position . to2 ) < [number] : [EOL] break [EOL] else : [EOL] await self . do ( depo ( MORPH_SUPPLYDEPOT_LOWER ) ) [EOL] [EOL] [comment] [EOL] for depo in self . units ( SUPPLYDEPOTLOWERED ) . ready : [EOL] for unit in self . known_enemy_units . not_structure : [EOL] if unit . position . to2 . distance_to ( depo . position . to2 ) < [number] : [EOL] await self . do ( depo ( MORPH_SUPPLYDEPOT_RAISE ) ) [EOL] break [EOL] [EOL] depot_placement_positions = self . main_base_ramp . corner_depots [EOL] [comment] [EOL] [comment] [EOL] [EOL] barracks_placement_position = None [EOL] barracks_placement_position = self . main_base_ramp . barracks_correct_placement [EOL] [comment] [EOL] [comment] [EOL] [EOL] depots = self . units ( SUPPLYDEPOT ) | self . units ( SUPPLYDEPOTLOWERED ) [EOL] [EOL] [comment] [EOL] if depots : [EOL] depot_placement_positions = { d for d in depot_placement_positions if depots . closest_distance_to ( d ) > [number] } [EOL] [EOL] [comment] [EOL] if self . can_afford ( SUPPLYDEPOT ) and not self . already_pending ( SUPPLYDEPOT ) : [EOL] if len ( depot_placement_positions ) == [number] : [EOL] return [EOL] [comment] [EOL] target_depot_location = depot_placement_positions . pop ( ) [EOL] ws = self . workers . gathering [EOL] if ws : [comment] [EOL] w = ws . random [EOL] await self . do ( w . build ( SUPPLYDEPOT , target_depot_location ) ) [EOL] [EOL] [comment] [EOL] if depots . ready . exists and self . can_afford ( BARRACKS ) and not self . already_pending ( BARRACKS ) : [EOL] if self . units ( BARRACKS ) . amount + self . already_pending ( BARRACKS ) > [number] : [EOL] return [EOL] ws = self . workers . gathering [EOL] if ws and barracks_placement_position : [comment] [EOL] w = ws . random [EOL] await self . do ( w . build ( BARRACKS , barracks_placement_position ) ) [EOL] [EOL] [EOL] [EOL] def main ( ) : [EOL] sc2 . run_game ( sc2 . maps . get ( [string] ) , [ Bot ( Race . Terran , RampWallBot ( ) ) , Computer ( Race . Zerg , Difficulty . Hard ) ] , realtime = False ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] [EOL] import sc2 [EOL] from sc2 import Race , Difficulty [EOL] from sc2 . constants import * [EOL] from sc2 . position import Point2 , Point3 [EOL] from sc2 . unit import Unit [EOL] from sc2 . player import Bot , Computer [EOL] from sc2 . player import Human [EOL] from sc2 . ids . unit_typeid import UnitTypeId [EOL] from sc2 . ids . ability_id import AbilityId [EOL] [EOL] class MassReaperBot ( sc2 . BotAI ) : [EOL] def __init__ ( self ) : [EOL] self . combinedActions = [ ] [EOL] [EOL] async def on_step ( self , iteration ) : [EOL] self . combinedActions = [ ] [EOL] [EOL] [docstring] [EOL] if self . supply_left < [number] and self . townhalls . exists and self . supply_used >= [number] and self . can_afford ( UnitTypeId . SUPPLYDEPOT ) and self . units ( UnitTypeId . SUPPLYDEPOT ) . not_ready . amount + self . already_pending ( UnitTypeId . SUPPLYDEPOT ) < [number] : [EOL] ws = self . workers . gathering [EOL] if ws : [comment] [EOL] w = ws . furthest_to ( ws . center ) [EOL] loc = await self . find_placement ( UnitTypeId . SUPPLYDEPOT , w . position , placement_step = [number] ) [EOL] if loc : [comment] [EOL] [comment] [EOL] self . combinedActions . append ( w . build ( UnitTypeId . SUPPLYDEPOT , loc ) ) [EOL] [EOL] [comment] [EOL] for depot in self . units ( UnitTypeId . SUPPLYDEPOT ) . ready : [EOL] self . combinedActions . append ( depot ( AbilityId . MORPH_SUPPLYDEPOT_LOWER ) ) [EOL] [EOL] [comment] [EOL] if self . units ( UnitTypeId . BARRACKS ) . ready . exists and self . can_afford ( UnitTypeId . ORBITALCOMMAND ) : [comment] [EOL] for cc in self . units ( UnitTypeId . COMMANDCENTER ) . idle : [comment] [EOL] self . combinedActions . append ( cc ( AbilityId . UPGRADETOORBITAL_ORBITALCOMMAND ) ) [EOL] [EOL] [comment] [EOL] if [number] <= self . townhalls . amount < [number] and self . already_pending ( UnitTypeId . COMMANDCENTER ) == [number] and self . can_afford ( UnitTypeId . COMMANDCENTER ) : [EOL] [comment] [EOL] next_expo = await self . get_next_expansion ( ) [EOL] [comment] [EOL] location = await self . find_placement ( UnitTypeId . COMMANDCENTER , next_expo , placement_step = [number] ) [EOL] if location : [EOL] [comment] [EOL] w = self . select_build_worker ( location ) [EOL] if w and self . can_afford ( UnitTypeId . COMMANDCENTER ) : [EOL] [comment] [EOL] error = await self . do ( w . build ( UnitTypeId . COMMANDCENTER , location ) ) [EOL] if error : [EOL] print ( error ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . units . of_type ( [ UnitTypeId . SUPPLYDEPOT , UnitTypeId . SUPPLYDEPOTLOWERED , UnitTypeId . SUPPLYDEPOTDROP ] ) . ready . exists and self . units ( UnitTypeId . BARRACKS ) . amount + self . already_pending ( UnitTypeId . BARRACKS ) < [number] and self . can_afford ( UnitTypeId . BARRACKS ) : [EOL] ws = self . workers . gathering [EOL] if ws and self . townhalls . exists : [comment] [EOL] w = ws . furthest_to ( ws . center ) [EOL] [comment] [EOL] loc = await self . find_placement ( UnitTypeId . BARRACKS , self . townhalls . random . position , placement_step = [number] ) [EOL] if loc : [EOL] self . combinedActions . append ( w . build ( UnitTypeId . BARRACKS , loc ) ) [EOL] [EOL] [comment] [EOL] if self . units ( UnitTypeId . BARRACKS ) . amount > [number] and self . already_pending ( UnitTypeId . REFINERY ) < [number] : [EOL] for th in self . townhalls : [EOL] vgs = self . state . vespene_geyser . closer_than ( [number] , th ) [EOL] for vg in vgs : [EOL] if await self . can_place ( UnitTypeId . REFINERY , vg . position ) and self . can_afford ( UnitTypeId . REFINERY ) : [EOL] ws = self . workers . gathering [EOL] if ws . exists : [comment] [EOL] w = ws . closest_to ( vg ) [EOL] [comment] [EOL] self . combinedActions . append ( w . build ( UnitTypeId . REFINERY , vg ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . can_afford ( UnitTypeId . SCV ) and self . supply_left > [number] and self . units ( UnitTypeId . SCV ) . amount < [number] and ( self . units ( UnitTypeId . BARRACKS ) . ready . amount < [number] and self . units ( UnitTypeId . COMMANDCENTER ) . idle . exists or self . units ( UnitTypeId . ORBITALCOMMAND ) . idle . exists ) : [EOL] for th in self . townhalls . idle : [EOL] self . combinedActions . append ( th . train ( UnitTypeId . SCV ) ) [EOL] [EOL] [comment] [EOL] if self . can_afford ( UnitTypeId . REAPER ) and self . supply_left > [number] : [EOL] [comment] [EOL] for rax in self . units ( UnitTypeId . BARRACKS ) . idle : [EOL] self . combinedActions . append ( rax . train ( UnitTypeId . REAPER ) ) [EOL] [EOL] [comment] [EOL] if iteration % [number] == [number] : [EOL] await self . distribute_workers ( ) [EOL] [EOL] [comment] [EOL] for r in self . units ( UnitTypeId . REAPER ) : [EOL] [EOL] [comment] [EOL] enemyThreatsClose = self . known_enemy_units . filter ( lambda x : x . can_attack_ground ) . closer_than ( [number] , r ) [comment] [EOL] if r . health_percentage < [number] / [number] and enemyThreatsClose . exists : [EOL] retreatPoints = self . neighbors8 ( r . position , distance = [number] ) | self . neighbors8 ( r . position , distance = [number] ) [EOL] [comment] [EOL] retreatPoints = { x for x in retreatPoints if self . inPathingGrid ( x ) } [EOL] if retreatPoints : [EOL] closestEnemy = enemyThreatsClose . closest_to ( r ) [EOL] retreatPoint = closestEnemy . position . furthest ( retreatPoints ) [EOL] self . combinedActions . append ( r . move ( retreatPoint ) ) [EOL] continue [comment] [EOL] [EOL] [comment] [EOL] enemyGroundUnits = self . known_enemy_units . not_flying . closer_than ( [number] , r ) [comment] [EOL] if r . weapon_cooldown == [number] and enemyGroundUnits . exists : [EOL] enemyGroundUnits = enemyGroundUnits . sorted ( lambda x : x . distance_to ( r ) ) [EOL] closestEnemy = enemyGroundUnits [ [number] ] [EOL] self . combinedActions . append ( r . attack ( closestEnemy ) ) [EOL] continue [comment] [EOL] [EOL] [comment] [EOL] reaperGrenadeRange = self . _game_data . abilities [ AbilityId . KD8CHARGE_KD8CHARGE . value ] . _proto . cast_range [EOL] enemyGroundUnitsInGrenadeRange = self . known_enemy_units . not_structure . not_flying . exclude_type ( [ UnitTypeId . LARVA , UnitTypeId . EGG ] ) . closer_than ( reaperGrenadeRange , r ) [EOL] if enemyGroundUnitsInGrenadeRange . exists and ( r . is_attacking or r . is_moving ) : [EOL] [comment] [EOL] abilities = ( await self . get_available_abilities ( r ) ) [EOL] enemyGroundUnitsInGrenadeRange = enemyGroundUnitsInGrenadeRange . sorted ( lambda x : x . distance_to ( r ) , reverse = True ) [EOL] furthestEnemy = None [EOL] for enemy in enemyGroundUnitsInGrenadeRange : [EOL] if await self . can_cast ( r , AbilityId . KD8CHARGE_KD8CHARGE , enemy , cached_abilities_of_unit = abilities ) : [EOL] furthestEnemy = enemy [EOL] break [EOL] if furthestEnemy : [EOL] self . combinedActions . append ( r ( AbilityId . KD8CHARGE_KD8CHARGE , furthestEnemy ) ) [EOL] continue [comment] [EOL] [EOL] [comment] [EOL] enemyThreatsVeryClose = self . known_enemy_units . filter ( lambda x : x . can_attack_ground ) . closer_than ( [number] , r ) [comment] [EOL] [comment] [EOL] if r . weapon_cooldown != [number] and enemyThreatsVeryClose . exists : [EOL] retreatPoints = self . neighbors8 ( r . position , distance = [number] ) | self . neighbors8 ( r . position , distance = [number] ) [EOL] [comment] [EOL] retreatPoints = { x for x in retreatPoints if self . inPathingGrid ( x ) } [EOL] if retreatPoints : [EOL] closestEnemy = enemyThreatsVeryClose . closest_to ( r ) [EOL] retreatPoint = max ( retreatPoints , key = lambda x : x . distance_to ( closestEnemy ) - x . distance_to ( r ) ) [EOL] [comment] [EOL] self . combinedActions . append ( r . move ( retreatPoint ) ) [EOL] continue [comment] [EOL] [EOL] [comment] [EOL] allEnemyGroundUnits = self . known_enemy_units . not_flying [EOL] if allEnemyGroundUnits . exists : [EOL] closestEnemy = allEnemyGroundUnits . closest_to ( r ) [EOL] self . combinedActions . append ( r . move ( closestEnemy ) ) [EOL] continue [comment] [EOL] [EOL] [comment] [EOL] self . combinedActions . append ( r . move ( random . choice ( self . enemy_start_locations ) ) ) [EOL] [EOL] [comment] [EOL] if self . townhalls . exists : [EOL] for w in self . workers . idle : [EOL] th = self . townhalls . closest_to ( w ) [EOL] mfs = self . state . mineral_field . closer_than ( [number] , th ) [EOL] if mfs : [EOL] mf = mfs . closest_to ( w ) [EOL] self . combinedActions . append ( w . gather ( mf ) ) [EOL] [EOL] [comment] [EOL] for oc in self . units ( UnitTypeId . ORBITALCOMMAND ) . filter ( lambda x : x . energy >= [number] ) : [EOL] mfs = self . state . mineral_field . closer_than ( [number] , oc ) [EOL] if mfs : [EOL] mf = max ( mfs , key = lambda x : x . mineral_contents ) [EOL] self . combinedActions . append ( oc ( AbilityId . CALLDOWNMULE_CALLDOWNMULE , mf ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] await self . do_actions ( self . combinedActions ) [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def inPathingGrid ( self , pos ) : [EOL] [comment] [EOL] assert isinstance ( pos , ( Point2 , Point3 , Unit ) ) [EOL] pos = pos . position . to2 . rounded [EOL] return self . _game_info . pathing_grid [ (pos) ] != [number] [EOL] [EOL] [comment] [EOL] def neighbors4 ( self , position , distance = [number] ) : [EOL] p = position [EOL] d = distance [EOL] return { Point2 ( ( p . x - d , p . y ) ) , Point2 ( ( p . x + d , p . y ) ) , Point2 ( ( p . x , p . y - d ) ) , Point2 ( ( p . x , p . y + d ) ) , } [EOL] [EOL] [comment] [EOL] def neighbors8 ( self , position , distance = [number] ) : [EOL] p = position [EOL] d = distance [EOL] return self . neighbors4 ( position , distance ) | { Point2 ( ( p . x - d , p . y - d ) ) , Point2 ( ( p . x - d , p . y + d ) ) , Point2 ( ( p . x + d , p . y - d ) ) , Point2 ( ( p . x + d , p . y + d ) ) , } [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def already_pending ( self , unit_type ) : [EOL] ability = self . _game_data . units [ unit_type . value ] . creation_ability [EOL] unitAttributes = self . _game_data . units [ unit_type . value ] . attributes [EOL] [EOL] buildings_in_construction = self . units . structure ( unit_type ) . not_ready [EOL] if [number] not in unitAttributes and any ( o . ability == ability for w in ( self . units . not_structure ) for o in w . orders ) : [EOL] return sum ( [ o . ability == ability for w in ( self . units - self . workers ) for o in w . orders ] ) [EOL] [comment] [EOL] elif any ( o . ability . id == ability . id for w in ( self . units . structure ) for o in w . orders ) : [EOL] return sum ( [ o . ability . id == ability . id for w in ( self . units . structure ) for o in w . orders ] ) [EOL] [comment] [EOL] elif any ( o . ability == ability for w in self . workers for o in w . orders ) : [EOL] return sum ( [ o . ability == ability for w in self . workers for o in w . orders ] ) - buildings_in_construction . amount [EOL] elif any ( egg . orders [ [number] ] . ability == ability for egg in self . units ( UnitTypeId . EGG ) ) : [EOL] return sum ( [ egg . orders [ [number] ] . ability == ability for egg in self . units ( UnitTypeId . EGG ) ] ) [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] async def distribute_workers ( self , performanceHeavy = True , onlySaturateGas = False ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] mineralTags = [ x . tag for x in self . state . units . mineral_field ] [EOL] [comment] [EOL] geyserTags = [ x . tag for x in self . geysers ] [EOL] [EOL] workerPool = self . units & [ ] [EOL] workerPoolTags = set ( ) [EOL] [EOL] [comment] [EOL] deficitGeysers = { } [EOL] surplusGeysers = { } [EOL] for g in self . geysers . filter ( lambda x : x . vespene_contents > [number] ) : [EOL] [comment] [EOL] deficit = g . ideal_harvesters - g . assigned_harvesters [EOL] if deficit > [number] : [EOL] deficitGeysers [ g . tag ] = { [string] : g , [string] : deficit } [EOL] elif deficit < [number] : [EOL] surplusWorkers = self . workers . closer_than ( [number] , g ) . filter ( lambda w : w not in workerPoolTags and len ( w . orders ) == [number] and w . orders [ [number] ] . ability . id in [ AbilityId . HARVEST_GATHER ] and w . orders [ [number] ] . target in geyserTags ) [EOL] [comment] [EOL] for i in range ( - deficit ) : [EOL] if surplusWorkers . amount > [number] : [EOL] w = surplusWorkers . pop ( ) [EOL] workerPool . append ( w ) [EOL] workerPoolTags . add ( w . tag ) [EOL] surplusGeysers [ g . tag ] = { [string] : g , [string] : deficit } [EOL] [EOL] [comment] [EOL] deficitTownhalls = { } [EOL] surplusTownhalls = { } [EOL] if not onlySaturateGas : [EOL] for th in self . townhalls : [EOL] deficit = th . ideal_harvesters - th . assigned_harvesters [EOL] if deficit > [number] : [EOL] deficitTownhalls [ th . tag ] = { [string] : th , [string] : deficit } [EOL] elif deficit < [number] : [EOL] surplusWorkers = self . workers . closer_than ( [number] , th ) . filter ( lambda w : w . tag not in workerPoolTags and len ( w . orders ) == [number] and w . orders [ [number] ] . ability . id in [ AbilityId . HARVEST_GATHER ] and w . orders [ [number] ] . target in mineralTags ) [EOL] [comment] [EOL] for i in range ( - deficit ) : [EOL] if surplusWorkers . amount > [number] : [EOL] w = surplusWorkers . pop ( ) [EOL] workerPool . append ( w ) [EOL] workerPoolTags . add ( w . tag ) [EOL] surplusTownhalls [ th . tag ] = { [string] : th , [string] : deficit } [EOL] [EOL] if all ( [ len ( deficitGeysers ) == [number] , len ( surplusGeysers ) == [number] , len ( surplusTownhalls ) == [number] or deficitTownhalls == [number] ] ) : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] deficitGasCount = sum ( gasInfo [ [string] ] for gasTag , gasInfo in deficitGeysers . items ( ) if gasInfo [ [string] ] > [number] ) [EOL] surplusCount = sum ( - gasInfo [ [string] ] for gasTag , gasInfo in surplusGeysers . items ( ) if gasInfo [ [string] ] < [number] ) [EOL] surplusCount += sum ( - thInfo [ [string] ] for thTag , thInfo in surplusTownhalls . items ( ) if thInfo [ [string] ] < [number] ) [EOL] [EOL] if deficitGasCount - surplusCount > [number] : [EOL] [comment] [EOL] for gTag , gInfo in deficitGeysers . items ( ) : [EOL] if workerPool . amount >= deficitGasCount : [EOL] break [EOL] workersNearGas = self . workers . closer_than ( [number] , gInfo [ [string] ] ) . filter ( lambda w : w . tag not in workerPoolTags and len ( w . orders ) == [number] and w . orders [ [number] ] . ability . id in [ AbilityId . HARVEST_GATHER ] and w . orders [ [number] ] . target in mineralTags ) [EOL] while workersNearGas . amount > [number] and workerPool . amount < deficitGasCount : [EOL] w = workersNearGas . pop ( ) [EOL] workerPool . append ( w ) [EOL] workerPoolTags . add ( w . tag ) [EOL] [EOL] [comment] [EOL] for gTag , gInfo in deficitGeysers . items ( ) : [EOL] if performanceHeavy : [EOL] [comment] [EOL] workerPool . sort ( key = lambda x : x . distance_to ( gInfo [ [string] ] ) , reverse = True ) [EOL] for i in range ( gInfo [ [string] ] ) : [EOL] if workerPool . amount > [number] : [EOL] w = workerPool . pop ( ) [EOL] if len ( w . orders ) == [number] and w . orders [ [number] ] . ability . id in [ AbilityId . HARVEST_RETURN ] : [EOL] self . combinedActions . append ( w . gather ( gInfo [ [string] ] , queue = True ) ) [EOL] else : [EOL] self . combinedActions . append ( w . gather ( gInfo [ [string] ] ) ) [EOL] [EOL] if not onlySaturateGas : [EOL] [comment] [EOL] for thTag , thInfo in deficitTownhalls . items ( ) : [EOL] if performanceHeavy : [EOL] [comment] [EOL] workerPool . sort ( key = lambda x : x . distance_to ( thInfo [ [string] ] ) , reverse = True ) [EOL] for i in range ( thInfo [ [string] ] ) : [EOL] if workerPool . amount > [number] : [EOL] w = workerPool . pop ( ) [EOL] mf = self . state . mineral_field . closer_than ( [number] , thInfo [ [string] ] ) . closest_to ( w ) [EOL] if len ( w . orders ) == [number] and w . orders [ [number] ] . ability . id in [ AbilityId . HARVEST_RETURN ] : [EOL] self . combinedActions . append ( w . gather ( mf , queue = True ) ) [EOL] else : [EOL] self . combinedActions . append ( w . gather ( mf ) ) [EOL] [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] sc2 . run_game ( sc2 . maps . get ( [string] ) , [ Bot ( Race . Terran , MassReaperBot ( ) ) , Computer ( Race . Zerg , Difficulty . VeryHard ) ] , realtime = False ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0