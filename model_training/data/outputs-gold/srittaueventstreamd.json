[comment] [EOL] [EOL] import os . path [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] def read ( fname ) : [EOL] return open ( os . path . join ( os . path . dirname ( __file__ ) , fname ) ) . read ( ) [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = read ( [string] ) , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( ) , scripts = [ os . path . join ( [string] , [string] ) ] , tests_require = [ [string] ] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Tuple , Any , Optional , Mapping [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] from http import HTTPStatus [EOL] from typing import Any , Mapping , Tuple , Optional [EOL] [EOL] from evtstrd . exc import PluginError [EOL] from evtstrd . http import HTTPError [EOL] from evtstrd . plugins import load_plugin [EOL] [EOL] [EOL] async def check_auth ( path , headers , ** kwargs ) : [EOL] auth = load_plugin ( [string] , [string] ) [EOL] if auth is None : [EOL] return None , None [EOL] response = await auth ( path , headers , ** kwargs ) [EOL] status = response [ [string] ] [EOL] if status == [string] : [EOL] expire = response . get ( [string] ) [EOL] return expire , response . get ( [string] ) [EOL] elif status == [string] : [EOL] authenticate = response . get ( [string] ) [EOL] if authenticate is None : [EOL] raise PluginError ( [string] , [string] ) [EOL] raise HTTPError ( HTTPStatus . UNAUTHORIZED , [string] , headers = [ ( [string] , authenticate ) ] , ) [EOL] elif status == [string] : [EOL] raise HTTPError ( HTTPStatus . FORBIDDEN , [string] ) [EOL] else : [EOL] raise PluginError ( [string] , f" [string] { status } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[datetime.datetime],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , Type , Tuple , Dict , List [EOL] import http [EOL] import asyncio [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] from asyncio . streams import StreamWriter , StreamReader [EOL] from http import HTTPStatus [EOL] from typing import Tuple , Iterable , List , Dict [EOL] [EOL] Header = Tuple [ str , str ] [EOL] [EOL] [EOL] class HTTPError ( Exception ) : [EOL] def __init__ ( self , status , message , * , headers = [ ] , ) : [EOL] super ( ) . __init__ ( message ) [EOL] self . status = status [EOL] self . headers = list ( headers ) [EOL] [EOL] [EOL] class BadRequestError ( HTTPError ) : [EOL] def __init__ ( self , message ) : [EOL] super ( ) . __init__ ( HTTPStatus . BAD_REQUEST , message ) [EOL] [EOL] [EOL] class CGIArgumentError ( BadRequestError ) : [EOL] def __init__ ( self , argument_name , message ) : [EOL] full_message = f"{ argument_name } [string] { message }" [EOL] super ( ) . __init__ ( full_message ) [EOL] self . argument_name = argument_name [EOL] [EOL] [EOL] class NotFoundError ( HTTPError ) : [EOL] def __init__ ( self , path ) : [EOL] message = f" [string] { path } [string] " [EOL] super ( ) . __init__ ( HTTPStatus . NOT_FOUND , message ) [EOL] [EOL] [EOL] class MethodNotAllowedError ( HTTPError ) : [EOL] def __init__ ( self , method ) : [EOL] message = f" [string] { method } [string] " [EOL] super ( ) . __init__ ( HTTPStatus . METHOD_NOT_ALLOWED , message ) [EOL] self . method = method [EOL] [EOL] [EOL] async def read_http_head ( reader ) : [EOL] async def read_line ( ) : [EOL] line_ = await reader . readline ( ) [EOL] try : [EOL] return line_ . decode ( [string] ) . strip ( ) [EOL] except UnicodeDecodeError : [EOL] raise BadRequestError ( [string] ) [EOL] [EOL] async def read_request_line ( ) : [EOL] line_ = await read_line ( ) [EOL] try : [EOL] m , p , http_tag = line_ . split ( [string] ) [EOL] except ValueError : [EOL] raise BadRequestError ( [string] ) [EOL] if http_tag != [string] : [EOL] raise BadRequestError ( [string] ) [EOL] if m not in [ [string] , [string] , [string] , [string] ] : [EOL] raise NotImplementedError ( ) [EOL] return m , p [EOL] [EOL] def parse_header_line ( li ) : [EOL] try : [EOL] return tuple ( li . split ( [string] , maxsplit = [number] ) ) [EOL] except ValueError : [EOL] raise BadRequestError ( [string] ) [EOL] [EOL] method , path = await read_request_line ( ) [EOL] headers = { } [EOL] while True : [EOL] line = await read_line ( ) [EOL] if not line : [EOL] break [EOL] he , va = parse_header_line ( line ) [EOL] headers [ he . lower ( ) ] = va [EOL] [EOL] return method , path , headers [EOL] [EOL] [EOL] def write_http_head ( writer , code , headers ) : [EOL] status_line = [string] . format ( code . value , code . phrase ) [EOL] writer . write ( status_line . encode ( [string] ) ) [EOL] for h , v in headers : [EOL] line = h . encode ( [string] ) + [string] + v . encode ( [string] ) + [string] [EOL] writer . write ( line ) [EOL] writer . write ( [string] ) [EOL] [EOL] [EOL] def write_response ( writer , status , headers , body , ) : [EOL] write_http_head ( writer , status , headers ) [EOL] writer . write ( body . encode ( [string] ) ) [EOL] [EOL] [EOL] def write_http_error ( writer , exc ) : [EOL] body = str ( exc ) + [string] [EOL] write_response ( writer , exc . status , exc . headers , body ) [EOL] [EOL] [EOL] def write_chunk ( writer , data ) : [EOL] writer . write ( bytes ( hex ( len ( data ) ) [ [number] : ] , [string] ) ) [EOL] writer . write ( [string] ) [EOL] writer . write ( data ) [EOL] writer . write ( [string] ) [EOL] encoded = ( data . decode ( [string] , errors = [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] logging . debug ( f" [string] { encoded }" ) [EOL] [EOL] [EOL] def write_last_chunk ( writer ) : [EOL] write_chunk ( writer , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $http.HTTPStatus$ 0 $builtins.str$ 0 0 0 $typing.List[Header]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $http.HTTPStatus$ 0 $http.HTTPStatus$ 0 0 0 $typing.List[Header]$ 0 0 0 $typing.List[Header]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Pattern [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import re [EOL] [EOL] [EOL] _iso_date_re = re . compile ( [string] ) [EOL] [EOL] [EOL] def parse_iso_date ( date_string ) : [EOL] if not date_string : [EOL] raise ValueError ( f" [string] { date_string } [string] " ) [EOL] m = _iso_date_re . match ( date_string ) [EOL] if not m : [EOL] raise ValueError ( f" [string] { date_string } [string] " ) [EOL] try : [EOL] return datetime . date ( int ( m . group ( [number] ) ) , int ( m . group ( [number] ) ) , int ( m . group ( [number] ) ) ) [EOL] except ValueError as exc : [EOL] raise ValueError ( f" [string] { date_string } [string] " ) from exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] import configparser [EOL] import evtstrd [EOL] import configparser [EOL] from configparser import NoOptionError [EOL] from typing import Optional [EOL] [EOL] DEFAULT_CONFIG = [string] [EOL] [EOL] SOCKET_NAME = [string] [EOL] SOCKET_MODE = [number] [EOL] [EOL] HTTP_PORT = [number] [EOL] [EOL] PING_INTERVAL = [number] [EOL] [EOL] [EOL] class Config : [EOL] def __init__ ( self ) : [EOL] self . socket_file = SOCKET_NAME [EOL] self . socket_owner = None [EOL] self . socket_group = None [EOL] self . socket_mode = SOCKET_MODE [EOL] self . cert_file = None [EOL] self . key_file = None [EOL] self . http_port = HTTP_PORT [EOL] self . ping_interval = PING_INTERVAL [EOL] self . debug = False [EOL] [EOL] @ property def with_ssl ( self ) : [EOL] return bool ( self . cert_file ) and bool ( self . key_file ) [EOL] [EOL] [EOL] def read_config ( filename ) : [EOL] config = Config ( ) [EOL] parser = configparser . ConfigParser ( ) [EOL] with open ( filename , [string] ) as f : [EOL] parser . read_file ( f ) [EOL] config . socket_file = parser . get ( [string] , [string] , fallback = SOCKET_NAME ) [EOL] try : [EOL] socket_mode = parser . get ( [string] , [string] ) [EOL] except NoOptionError : [EOL] pass [EOL] else : [EOL] config . socket_mode = int ( socket_mode , base = [number] ) [EOL] config . socket_owner = parser . get ( [string] , [string] , fallback = [string] ) [EOL] config . socket_group = parser . get ( [string] , [string] , fallback = [string] ) [EOL] config . cert_file = parser . get ( [string] , [string] , fallback = [string] ) [EOL] config . key_file = parser . get ( [string] , [string] , fallback = [string] ) [EOL] config . http_port = parser . getint ( [string] , [string] , fallback = HTTP_PORT ) [EOL] return config [EOL] [EOL] [EOL] def read_default_config ( ) : [EOL] try : [EOL] return read_config ( DEFAULT_CONFIG ) [EOL] except FileNotFoundError : [EOL] return Config ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncio [EOL] import datetime [EOL] import typing [EOL] import asyncio [EOL] import datetime [EOL] import json [EOL] import logging [EOL] from asyncio . streams import StreamReader [EOL] from typing import Any [EOL] [EOL] from evtstrd . exc import DisconnectedError [EOL] [EOL] [EOL] async def read_json_line ( reader ) : [EOL] while True : [EOL] line = await reader . readline ( ) [EOL] if line : [EOL] logging . debug ( f" [string] { line !r}" ) [EOL] try : [EOL] return json . loads ( line . decode ( [string] ) . strip ( ) ) [EOL] except ( ValueError , UnicodeDecodeError ) : [EOL] logging . warning ( [string] ) [EOL] if reader . at_eof ( ) : [EOL] raise DisconnectedError ( ) [EOL] [EOL] [EOL] _RECHECK_SECONDS = [number] [comment] [EOL] [EOL] [EOL] async def sleep_until ( dt ) : [EOL] while True : [EOL] now = datetime . datetime . utcnow ( ) [EOL] if now >= dt : [EOL] return [EOL] remaining = ( dt - now ) . total_seconds ( ) [EOL] await asyncio . sleep ( min ( remaining , _RECHECK_SECONDS ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
import builtins [EOL] class ServerAlreadyRunningError ( Exception ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [EOL] class DisconnectedError ( Exception ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [EOL] class PluginError ( Exception ) : [EOL] def __init__ ( self , plugin , message ) : [EOL] super ( ) . __init__ ( f" [string] { plugin } [string] { message }" ) [EOL] self . plugin = plugin [EOL]	0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0
from typing import Optional [EOL] import argparse [EOL] import typing [EOL] import evtstrd [EOL] import argparse [EOL] [EOL] from evtstrd . config import Config , read_config , read_default_config [EOL] [EOL] [EOL] def parse_command_line ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = int ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] args = parser . parse_args ( ) [EOL] if args . config_file is not None : [EOL] config = read_config ( args . config_file ) [EOL] else : [EOL] config = read_default_config ( ) [EOL] config . debug = args . debug [EOL] if args . socket is not None : [EOL] config . socket_file = args . socket [EOL] if args . ssl_key is not None : [EOL] config . key_file = args . ssl_key [EOL] if args . ssl_cert is not None : [EOL] config . cert_file = args . ssl_cert [EOL] if args . port is not None : [EOL] config . http_port = args . port [EOL] return config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $evtstrd.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import builtins [EOL] import json [EOL] from typing import Any , SupportsBytes [EOL] [EOL] [EOL] class Event ( SupportsBytes ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , event_type , data = [string] , id = None ) : [EOL] self . type = event_type [EOL] self . id = id [EOL] self . data = data [EOL] [EOL] def __bytes__ ( self ) : [EOL] [docstring] [EOL] return bytes ( str ( self ) , [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] fields = [ ( [string] , self . type ) , ( [string] , self . data ) ] [EOL] if self . id : [EOL] fields . append ( ( [string] , self . id ) ) [EOL] lines = [ [string] . format ( f [ [number] ] , f [ [number] ] ) for f in fields ] [EOL] return [string] . join ( lines ) + [string] [EOL] [EOL] [EOL] class PingEvent ( Event ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [EOL] class JSONEvent ( Event ) : [EOL] def __init__ ( self , event_type , json_data , id = None ) : [EOL] if not isinstance ( json_data , str ) : [EOL] json_data = json . dumps ( json_data ) [EOL] super ( ) . __init__ ( event_type , json_data , id ) [EOL] [EOL] [EOL] class LogoutEvent ( JSONEvent ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import builtins [EOL] import _importlib_modulespec [EOL] from importlib import import_module [EOL] from typing import Any , Optional [EOL] [EOL] from evtstrd . exc import PluginError [EOL] [EOL] [EOL] def load_plugin ( plugin , obj ) : [EOL] try : [EOL] pkg = import_module ( [string] + plugin , [string] ) [EOL] except ImportError : [EOL] return None [EOL] if not hasattr ( pkg , obj ) : [EOL] raise PluginError ( plugin , f" [string] { obj } [string] " ) [EOL] return getattr ( pkg , obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Mapping [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] from datetime import timedelta [EOL] from typing import Any , Mapping [EOL] [EOL] [EOL] async def check_auth ( route , headers , ** kwargs ) : [EOL] authorization = headers . get ( [string] ) [EOL] [EOL] [comment] [EOL] if route == [string] : [EOL] return { [string] : [string] } [EOL] [EOL] if authorization is None : [EOL] return { [string] : [string] , [string] : [string] } [EOL] if authorization . lower ( ) == [string] : [EOL] return { [string] : [string] , [string] : datetime . datetime . utcnow ( ) + timedelta ( minutes = [number] ) , } [EOL] else : [EOL] return { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import datetime [EOL] import datetime [EOL] from unittest import TestCase [EOL] [EOL] from asserts import assert_equal , assert_raises_regex [EOL] [EOL] from evtstrd . date import parse_iso_date [EOL] [EOL] [EOL] class ParseISODateTest ( TestCase ) : [EOL] def test_empty ( self ) : [EOL] with assert_raises_regex ( ValueError , [string] ) : [EOL] parse_iso_date ( [string] ) [EOL] [EOL] def test_invalid ( self ) : [EOL] with assert_raises_regex ( ValueError , [string] ) : [EOL] parse_iso_date ( [string] ) [EOL] [EOL] def test_with_dashes ( self ) : [EOL] date = parse_iso_date ( [string] ) [EOL] assert_equal ( datetime . date ( [number] , [number] , [number] ) , date ) [EOL] [EOL] def test_without_dashes ( self ) : [EOL] date = parse_iso_date ( [string] ) [EOL] assert_equal ( datetime . date ( [number] , [number] , [number] ) , date ) [EOL] [EOL] def test_out_of_range ( self ) : [EOL] with assert_raises_regex ( ValueError , [string] ) : [EOL] parse_iso_date ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 $None$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import evtstrd [EOL] from unittest import TestCase [EOL] [EOL] from asserts import assert_equal [EOL] [EOL] from evtstrd . events import Event , JSONEvent [EOL] [EOL] [EOL] class EventTest ( TestCase ) : [EOL] def test_str ( self ) : [EOL] event = Event ( [string] , [string] ) [EOL] string = str ( event ) [EOL] assert_equal ( [string] , string ) [EOL] [EOL] [EOL] class JSONEventTest ( TestCase ) : [EOL] def test_exercise ( self ) : [EOL] JSONEvent ( [string] , { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $evtstrd.events.Event$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $evtstrd.events.Event$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0