from typing import Type [EOL] import typing [EOL] import examples [EOL] import unittest [EOL] [EOL] from props import AbstractTestArbitraryInterface , ArbitraryInterface , arbitrary , for_all [EOL] [EOL] from examples import BinaryTree , prop_associative [EOL] [EOL] [EOL] class ForgotToImplementArbitrary ( ArbitraryInterface ) : [EOL] pass [EOL] [EOL] [EOL] class TestProps ( unittest . TestCase , AbstractTestArbitraryInterface ) : [EOL] def setUp ( self ) : [EOL] self . cls = BinaryTree [EOL] [EOL] def test_forgot_to_implement_arbitrary ( self ) : [EOL] with self . assertRaises ( NotImplementedError ) : [EOL] arbitrary ( ForgotToImplementArbitrary ) [EOL] [EOL] def test_floats_are_not_associative ( self ) : [EOL] with self . assertRaises ( AssertionError ) : [EOL] for_all ( float , float , float ) ( prop_associative ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[examples.BinaryTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dataclasses import dataclass [EOL] [EOL] from props import for_all , ArbitraryInterface , one_of , arbitrary [EOL] [EOL] for_all ( int , int ) ( lambda a , b : a + b == b + a ) [EOL] for_all ( int , int ) ( lambda a , b : a * b == b * a ) [EOL] for_all ( int , int , int ) ( lambda a , b , c : c * ( a + b ) == a * c + b * c ) [EOL] [EOL] [EOL] def prop_associative ( a , b , c ) : [EOL] return a + ( b + c ) == ( a + b ) + c [EOL] [EOL] [EOL] for_all ( int , int , int ) ( prop_associative ) [EOL] [EOL] [EOL] def prop_list_append_pop ( list , element ) : [EOL] if element not in list : [EOL] list . append ( element ) [EOL] assert element in list [EOL] list . pop ( ) [EOL] return element not in list [EOL] return element in list [comment] [EOL] [EOL] [EOL] for_all ( list , int ) ( prop_list_append_pop ) [EOL] [EOL] [EOL] class BinaryTree ( ArbitraryInterface ) : [EOL] @ classmethod def arbitrary ( cls ) : [EOL] return arbitrary ( one_of ( Leaf , Node ) ) [EOL] [EOL] [EOL] class Leaf ( BinaryTree ) : [EOL] @ classmethod def arbitrary ( cls ) : [EOL] return cls ( ) [comment] [EOL] [EOL] [EOL] @ dataclass class Node ( BinaryTree ) : [EOL] left = ... [EOL] right = ... [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] return cls ( arbitrary ( BinaryTree ) , BinaryTree . arbitrary ( ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BinaryTree$ 0 0 0 $BinaryTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import props [EOL] [docstring] [EOL] import sys [EOL] import random [EOL] from collections . abc import Hashable [EOL] [EOL] [EOL] class ArbitraryInterface ( object ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class AbstractTestArbitraryInterface ( object ) : [EOL] [docstring] [EOL] [EOL] def test_arbitrary ( self ) : [EOL] [docstring] [EOL] try : [EOL] assert issubclass ( self . cls , ArbitraryInterface ) [EOL] self . cls . arbitrary ( ) [EOL] except AssertionError : [EOL] self . fail ( self . cls . __name__ + [string] ) [EOL] except NotImplementedError : [EOL] self . fail ( self . cls . __name__ + [string] ) [EOL] [EOL] [EOL] class ArbitraryError ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class AbstractArbitrary ( dict ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , cls ) : [EOL] if cls is None : [EOL] return None [EOL] if issubclass ( cls , ArbitraryInterface ) : [EOL] return cls . arbitrary ( ) [EOL] if cls in self : [EOL] return self [ cls ] ( ) [EOL] raise ArbitraryError ( [string] [string] [string] . format ( cls . __name__ ) ) [EOL] [EOL] [EOL] arbitrary = AbstractArbitrary ( { int : lambda : random . randint ( - sys . maxsize - [number] , sys . maxsize ) , bool : lambda : arbitrary ( int ) > [number] , float : lambda : random . gauss ( [number] , sys . maxsize ) , complex : lambda : complex ( arbitrary ( float ) , arbitrary ( float ) ) , str : lambda : [string] . join ( chr ( ( i % [number] ) + [number] ) for i in arbitrary ( list_of ( int ) ) ) , tuple : lambda : arbitrary ( tuple_of ( * [ generator for generator in arbitrary . keys ( ) if generator is not tuple [EOL] and issubclass ( generator , Hashable ) ] ) ) , set : lambda : arbitrary ( set_of ( * [ generator for generator in arbitrary . keys ( ) if generator is not tuple [EOL] and issubclass ( generator , Hashable ) ] ) ) , list : lambda : arbitrary ( list_of ( * [ generator for generator in arbitrary . keys ( ) if generator is not list [EOL] and issubclass ( generator , Hashable ) ] ) ) , dict : lambda : arbitrary ( dict_of ( ** { arbitrary ( str ) : generator for generator in arbitrary . keys ( ) if generator is not dict [EOL] and issubclass ( generator , Hashable ) } ) ) } ) [EOL] [EOL] [EOL] def for_all ( * generators ) : [EOL] [docstring] [EOL] [comment] [EOL] n = [number] [EOL] [EOL] def test_property ( property_function ) : [EOL] [docstring] [EOL] for generator in generators : [EOL] assert ( issubclass ( generator , ArbitraryInterface ) or generator in arbitrary ) [EOL] [EOL] def test_once ( ) : [EOL] [docstring] [EOL] instances = [ arbitrary ( generator ) for generator in generators ] [EOL] try : [EOL] assert property_function ( * instances ) [EOL] except AssertionError : [EOL] generator_names = [string] . join ( generator . __name__ for generator in generators ) [EOL] stringed_instances = [string] . join ( str ( instance ) for instance in instances ) [EOL] error_message = [string] . join ( [ [string] , stringed_instances , [string] , generator_names , [string] ] ) [EOL] raise AssertionError ( error_message ) [EOL] [EOL] for _ in range ( n ) : [EOL] test_once ( ) [EOL] [EOL] return test_property [EOL] [EOL] [EOL] def maybe_a ( generator ) : [EOL] [docstring] [EOL] [EOL] class MaybeAGenerator ( ArbitraryInterface ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] return arbitrary ( one_of ( None , generator ) ) [EOL] [EOL] MaybeAGenerator . __name__ = [string] . join ( [ [string] , generator . __name__ , [string] ] ) [EOL] return MaybeAGenerator [EOL] [EOL] [EOL] def maybe_an ( generator ) : [EOL] [docstring] [EOL] return maybe_a ( generator ) [EOL] [EOL] [EOL] def one_of ( * generators ) : [EOL] [docstring] [EOL] [EOL] class OneOfGenerators ( ArbitraryInterface ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] return arbitrary ( random . choice ( generators ) ) [EOL] [EOL] OneOfGenerators . __name__ = [string] . join ( [ [string] , [string] . join ( generator . __name__ for generator in generators ) , [string] ] ) [EOL] return OneOfGenerators [EOL] [EOL] [EOL] def tuple_of ( * generators ) : [EOL] [docstring] [EOL] [EOL] class TupleOfGenerators ( ArbitraryInterface ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] return tuple ( [ arbitrary ( generator ) for generator in generators if generator is not tuple ] ) [EOL] [EOL] TupleOfGenerators . __name__ = [string] . join ( [ [string] , [string] . join ( generator . __name__ for generator in generators ) , [string] ] ) [EOL] return TupleOfGenerators [EOL] [EOL] [EOL] def set_of ( * generators ) : [EOL] [docstring] [EOL] [EOL] class SetOfGenerators ( ArbitraryInterface ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] arbitrary_set = set ( ) [EOL] for generator in generators : [EOL] arbitrary_set |= { arbitrary ( generator ) for _ in range ( arbitrary ( int ) % [number] ) } [EOL] return arbitrary_set [EOL] [EOL] SetOfGenerators . __name__ = [string] . join ( [ [string] , [string] . join ( generator . __name__ for generator in generators ) , [string] ] ) [EOL] return SetOfGenerators [EOL] [EOL] [EOL] def list_of ( * generators ) : [EOL] [docstring] [EOL] [EOL] class ListOfGenerators ( ArbitraryInterface ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] arbitrary_list = [ ] [EOL] for generator in generators : [EOL] arbitrary_list += [ arbitrary ( generator ) for _ in range ( arbitrary ( int ) % [number] ) ] [EOL] return arbitrary_list [EOL] [EOL] ListOfGenerators . __name__ = [string] . join ( [ [string] , [string] . join ( generator . __name__ for generator in generators ) , [string] ] ) [EOL] return ListOfGenerators [EOL] [EOL] [EOL] def dict_of ( ** kwargs ) : [EOL] [docstring] [EOL] [EOL] class DictOfKeyGenerators ( ArbitraryInterface ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def arbitrary ( cls ) : [EOL] [docstring] [EOL] return { key : arbitrary ( generator ) for key , generator in kwargs . iteritems ( ) } [EOL] [EOL] DictOfKeyGenerators . __name__ = [string] . join ( [ [string] , [string] . join ( [ key + [string] + generator . __name__ for key , generator in kwargs . iteritems ( ) ] ) , [string] ] ) [EOL] return DictOfKeyGenerators [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 $props.AbstractArbitrary$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0