from typing import Dict , Union , Any [EOL] import barbara [EOL] import typing [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] from barbara import utils [EOL] from barbara . variables import EnvVariable , GitCommitVariable [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def create_stub_template ( ) : [EOL] template = { [string] : EnvVariable ( [string] , [string] ) , [string] : EnvVariable ( [string] , [string] ) , [string] : EnvVariable ( [string] , [string] ) , } [EOL] return template [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def create_stub_template_with_auto_variables ( ) : [EOL] template = { [string] : EnvVariable ( [string] , [string] ) , [string] : EnvVariable ( [string] , [string] ) , [string] : EnvVariable ( [string] , [string] ) , [string] : GitCommitVariable ( [string] , [number] ) , } [EOL] return template [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def patch_subprocess_output ( ) : [EOL] with mock . patch ( [string] ) as patched_subprocess_output : [EOL] yield patched_subprocess_output [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_confirm_target_default_create_confirmed ( patched_create_target , patched_click , tmp_path ) : [EOL] [docstring] [EOL] patched_click . confirm . return_value = True [EOL] assert utils . confirm_target_file ( tmp_path / [string] ) [EOL] [EOL] patched_create_target . assert_called_once_with ( tmp_path / [string] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_confirm_target_default_create_rejected ( patched_create_target , patched_click , tmp_path ) : [EOL] [docstring] [EOL] patched_click . confirm . return_value = False [EOL] [EOL] with pytest . raises ( SystemExit , match = [string] ) : [EOL] assert utils . confirm_target_file ( tmp_path / [string] ) [EOL] [EOL] patched_create_target . assert_not_called ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_confirm_target_provided_confirmed ( patched_click , tmp_path ) : [EOL] [docstring] [EOL] patched_click . prompt . return_value = True [EOL] [EOL] target_file = tmp_path / [string] [EOL] assert not target_file . exists ( ) [EOL] assert utils . confirm_target_file ( target_file ) [EOL] assert target_file . exists ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_confirm_target_provided_rejected ( patched_create_target , patched_click , tmp_path ) : [EOL] [docstring] [EOL] patched_click . confirm . return_value = False [EOL] [EOL] target_file = tmp_path / [string] [EOL] assert not target_file . exists ( ) [EOL] with pytest . raises ( SystemExit , match = [string] ) : [EOL] utils . confirm_target_file ( target_file ) [EOL] patched_create_target . assert_not_called ( ) [EOL] [EOL] [EOL] class TestEnvVariableMerges : [EOL] def test_merge_with_presets_matching_with_skip ( self , template ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_presets ( existing , template , skip_existing = True ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] def test_merge_with_presets_matching_without_skip ( self , template ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_presets ( existing , template , skip_existing = False ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] @ mock . patch ( [string] , return_value = [string] ) def test_merge_with_prompts_matching_with_skip ( self , patched_get , template ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_prompts ( existing , template , skip_existing = True ) [EOL] patched_get . assert_called_once_with ( EnvVariable ( [string] , [string] ) ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] @ mock . patch ( [string] , side_effect = [ [string] , [string] , [string] ] ) def test_merge_with_prompts_matching_without_skip ( self , patched_get , template ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_prompts ( existing , template , skip_existing = False ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] @ mock . patch ( [string] ) def test_prompt_user_for_value ( self , patched_click ) : [EOL] [docstring] [EOL] patched_click . prompt . return_value = [string] [EOL] result = utils . prompt_user_for_value ( EnvVariable ( [string] , [string] ) ) [EOL] assert result == [string] [EOL] patched_click . prompt . assert_called_once_with ( [string] , default = [string] , type = str ) [EOL] [EOL] [EOL] class TestAutoVariableMerges : [EOL] def test_merge_with_presets_matching_with_skip ( self , auto_var_template , patched_subprocess_output ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_presets ( existing , auto_var_template , skip_existing = True ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] expected_length = auto_var_template [ [string] ] . length [EOL] mock_commit_hash = patched_subprocess_output . return_value [EOL] assert merged [ [string] ] == mock_commit_hash [ expected_length ] [EOL] [EOL] def test_merge_with_presets_matching_without_skip ( self , auto_var_template , patched_subprocess_output ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_presets ( existing , auto_var_template , skip_existing = False ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] expected_length = auto_var_template [ [string] ] . length [EOL] mock_commit_hash = patched_subprocess_output . return_value [EOL] assert merged [ [string] ] == mock_commit_hash [ expected_length ] [EOL] [EOL] def test_merge_with_presets_matching_without_skip_and_auto_vars ( self , auto_var_template , patched_subprocess_output ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_presets ( existing , auto_var_template , skip_existing = False ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] expected_length = auto_var_template [ [string] ] . length [EOL] mock_commit_hash = patched_subprocess_output . return_value [EOL] assert merged [ [string] ] == mock_commit_hash [ expected_length ] [EOL] [EOL] @ mock . patch ( [string] , return_value = [string] ) def test_merge_with_prompts_matching_with_skip ( self , patched_get , auto_var_template , patched_subprocess_output ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_prompts ( existing , auto_var_template , skip_existing = True ) [EOL] patched_get . assert_called_once_with ( EnvVariable ( [string] , [string] ) ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] expected_length = auto_var_template [ [string] ] . length [EOL] mock_commit_hash = patched_subprocess_output . return_value [EOL] assert merged [ [string] ] == mock_commit_hash [ expected_length ] [EOL] [EOL] @ mock . patch ( [string] , side_effect = [ [string] , [string] , [string] ] ) def test_merge_with_prompts_matching_without_skip ( self , patched_get , auto_var_template , patched_subprocess_output ) : [EOL] [docstring] [EOL] existing = { [string] : [string] , [string] : [string] } [EOL] merged = utils . merge_with_prompts ( existing , auto_var_template , skip_existing = False ) [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] assert merged [ [string] ] == [string] [EOL] [EOL] expected_length = auto_var_template [ [string] ] . length [EOL] mock_commit_hash = patched_subprocess_output . return_value [EOL] assert merged [ [string] ] == mock_commit_hash [ expected_length ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , Any [EOL] import barbara [EOL] import typing [EOL] from barbara import readers [EOL] from barbara . variables import GitCommitVariable [EOL] [EOL] [EOL] class TestEnvReader : [EOL] reader_class = readers . EnvReader [EOL] [EOL] def assert_env_value ( self , env , key , value ) : [EOL] assert env [ key ] == value [EOL] [EOL] def test_read_single_line ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = self . reader_class ( path ) [EOL] values = reader . read ( ) [EOL] assert [string] in values [EOL] [EOL] def test_read_multi_line ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = self . reader_class ( path ) [EOL] values = reader . read ( ) [EOL] assert [string] in values [EOL] assert [string] in values [EOL] [EOL] def test_read_single_line_with_comment ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = self . reader_class ( path ) [EOL] env = reader . read ( ) [EOL] assert [string] in env . keys ( ) [EOL] self . assert_env_value ( env , [string] , [string] ) [EOL] [EOL] def test_read_multi_line_with_comment ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = self . reader_class ( path ) [EOL] env = reader . read ( ) [EOL] assert [string] in env [EOL] self . assert_env_value ( env , [string] , [string] ) [EOL] [EOL] [EOL] class TestYAMLConfigReader : [EOL] def test_read_single_line ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = readers . YAMLTemplateReader ( path ) [EOL] template = reader . read ( ) [EOL] assert [string] in template [ [string] ] [EOL] [EOL] def test_read_multi_line ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = readers . YAMLTemplateReader ( path ) [EOL] template = reader . read ( ) [EOL] assert [string] in template [ [string] ] [EOL] assert [string] in template [ [string] ] [EOL] [EOL] def test_read_single_line_with_comment ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = readers . YAMLTemplateReader ( path ) [EOL] template = reader . read ( ) [EOL] assert [string] in template [ [string] ] [EOL] assert template [ [string] ] [ [string] ] . preset == [string] [EOL] [EOL] def test_read_multi_line_with_comment ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] [EOL] reader = readers . YAMLTemplateReader ( path ) [EOL] template = reader . read ( ) [ [string] ] [EOL] assert [string] in template [EOL] assert template [ [string] ] . preset == [string] [EOL] [EOL] def test_find_git_commit ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] reader = readers . YAMLTemplateReader ( path ) [EOL] template = reader . read ( ) [ [string] ] [EOL] assert [string] in template [EOL] assert template [ [string] ] == GitCommitVariable ( [string] , [string] ) [EOL] [EOL] def test_find_git_commit__malformed_variable ( self , tmp_path ) : [EOL] [docstring] [EOL] path = tmp_path / [string] [EOL] path . write_text ( [string] ) [EOL] reader = readers . YAMLTemplateReader ( path ) [EOL] template = reader . read ( ) [ [string] ] [EOL] assert [string] in template [EOL] assert not isinstance ( template [ [string] ] , GitCommitVariable ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[barbara.readers.EnvReader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.EnvReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.EnvReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.EnvReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.EnvReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.EnvReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.EnvReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.EnvReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.EnvReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $barbara.readers.YAMLTemplateReader$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
import unittest [EOL] from unittest import mock [EOL] [EOL] from barbara . writers import Writer [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_writer_writes ( patched_shutil , patched_os ) : [EOL] [docstring] [EOL] env_file = mock . MagicMock ( ) [EOL] Writer ( env_file , { [string] : [string] } ) . write ( ) [EOL] env_file . open ( ) . __enter__ ( ) . write . assert_called ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_writer_backup ( patched_os , patched_shutil ) : [EOL] [docstring] [EOL] env_file = mock . MagicMock ( ) [EOL] Writer ( env_file , { [string] : [string] } ) . write ( ) [EOL] patched_shutil . copy2 . assert_called ( ) [EOL] patched_os . remove . assert_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Dict , Type , Any [EOL] import barbara [EOL] import typing [EOL] import builtins [EOL] import abc [EOL] import re [EOL] import subprocess [EOL] from collections import namedtuple [EOL] from typing . re import Pattern [EOL] [EOL] [comment] [EOL] EnvVariable = namedtuple ( [string] , ( [string] , [string] ) ) [EOL] [EOL] AUTO_VARIABLE_MATCHERS = { } [EOL] [EOL] [EOL] class AutoVariable ( metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] def __init_subclass__ ( cls , ** kwargs ) : [EOL] super ( ) . __init_subclass__ ( ** kwargs ) [EOL] AUTO_VARIABLE_MATCHERS [ cls ] = cls . MATCHER [EOL] [EOL] @ property @ abc . abstractmethod def MATCHER ( self ) : [EOL] [docstring] [EOL] return NotImplemented [EOL] [EOL] def validate ( self ) : [EOL] [docstring] [EOL] return NotImplemented [EOL] [EOL] def generate ( self ) : [EOL] [docstring] [EOL] return NotImplemented [EOL] [EOL] [EOL] class GitCommitVariable ( AutoVariable ) : [EOL] [docstring] [EOL] [EOL] MATCHER = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self , name , length ) : [EOL] self . name = name [EOL] self . length = int ( length ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return all ( ( self . name == other . name , self . length == other . length ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . name } [string] { self . length } [string] " [EOL] [EOL] def validate ( self ) : [EOL] [docstring] [EOL] assert isinstance ( self . length , int ) and self . length <= [number] [EOL] [EOL] def generate ( self ) : [EOL] [docstring] [EOL] try : [EOL] git_revision = subprocess . check_output ( [ [string] , [string] , [string] ] , encoding = [string] ) [EOL] hash_size = slice ( [number] , self . length ) [EOL] return git_revision [ hash_size ] [EOL] except subprocess . CalledProcessError : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.slice$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.slice$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Set , List [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] import barbara [EOL] import variables [EOL] import os [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Dict , List , Union [EOL] [EOL] import click [EOL] [EOL] from . variables import AutoVariable , EnvVariable [EOL] [EOL] EMPTY = object ( ) [EOL] [EOL] [EOL] def confirm_target_file ( target_file = None ) : [EOL] [docstring] [EOL] if target_file . exists ( ) : [EOL] return click . prompt ( [string] , default = target_file . relative_to ( os . getcwd ( ) ) ) [EOL] if click . confirm ( f"{ target_file } [string] " ) : [EOL] return create_target_file ( target_file ) [EOL] [EOL] click . echo ( [string] , color = [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def create_target_file ( target_file = None ) : [EOL] [docstring] [EOL] target_file . touch ( ) [EOL] return target_file [EOL] [EOL] [EOL] def prompt_user_for_value ( env_variable ) : [EOL] [docstring] [EOL] return click . prompt ( env_variable . name , default = env_variable . preset , type = str ) [EOL] [EOL] [EOL] def merge_keys ( existing , template , skip_existing ) : [EOL] [docstring] [EOL] template_keys = set ( k . upper ( ) for k in template . keys ( ) ) [EOL] existing_keys = set ( k . upper ( ) for k in existing . keys ( ) ) [EOL] auto_var_keys = set ( k . upper ( ) for k in template . keys ( ) if isinstance ( template . get ( k ) , AutoVariable ) ) [EOL] [EOL] merged_keys = template_keys - existing_keys if skip_existing else template_keys [EOL] [EOL] [comment] [EOL] merged_keys |= auto_var_keys [EOL] [EOL] return sorted ( merged_keys ) [EOL] [EOL] [EOL] def merge_with_presets ( existing , template , skip_existing ) : [EOL] [docstring] [EOL] merged = existing . copy ( ) [EOL] [EOL] for key in merge_keys ( existing , template , skip_existing ) : [EOL] if isinstance ( template . get ( key ) , AutoVariable ) : [EOL] merged [ key ] = template [ key ] . generate ( ) [EOL] elif existing . get ( key , EMPTY ) is not EMPTY : [EOL] merged [ key ] = existing . get ( key ) [EOL] elif isinstance ( template . get ( key ) , EnvVariable ) : [EOL] merged [ key ] = template [ key ] . preset [EOL] else : [EOL] raise TypeError ( f" [string] { template [ key ] }" ) [EOL] [EOL] return dict ( sorted ( merged . items ( ) ) ) [EOL] [EOL] [EOL] def merge_with_prompts ( existing , template , skip_existing ) : [EOL] [docstring] [EOL] merged = existing . copy ( ) [EOL] [EOL] for key in merge_keys ( existing , template , skip_existing ) : [EOL] if isinstance ( template . get ( key ) , AutoVariable ) : [EOL] merged [ key ] = template [ key ] . generate ( ) [EOL] else : [EOL] variable = EnvVariable ( key , existing . get ( key ) ) if key in existing else template . get ( key ) [EOL] merged [ key ] = prompt_user_for_value ( variable ) [EOL] [EOL] return dict ( sorted ( merged . items ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Type , Tuple , Any , Union , List , Literal , TextIO [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] import functools [EOL] import pathlib [EOL] import re [EOL] from fnmatch import fnmatch [EOL] from functools import partial [EOL] from pathlib import Path [EOL] from typing import Dict , TextIO , Type , Union [EOL] [EOL] import yaml [EOL] from click import FileError [EOL] from dotenv . main import DotEnv [EOL] [EOL] from . variables import AUTO_VARIABLE_MATCHERS , EnvVariable [EOL] [EOL] TEMPLATE_READERS = [ ] [EOL] [EOL] [EOL] class BaseTemplateReader : [EOL] def __init_subclass__ ( cls , ** kwargs ) : [EOL] super ( ) . __init_subclass__ ( ** kwargs ) [EOL] TEMPLATE_READERS . append ( cls ) [EOL] [EOL] [EOL] def get_reader ( file_or_name ) : [EOL] [docstring] [EOL] filename = getattr ( file_or_name , [string] , file_or_name ) [EOL] filename_matcher = partial ( fnmatch , filename ) [EOL] yaml_extensions = ( [string] , [string] ) [EOL] if any ( filename_matcher ( extension ) for extension in yaml_extensions ) : [EOL] for reader_class in TEMPLATE_READERS : [EOL] try : [EOL] reader_class ( file_or_name ) . read ( ) [EOL] return reader_class [EOL] except FileError : [EOL] pass [EOL] raise FileError ( [string] ) [EOL] [EOL] [EOL] class EnvReader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source ) : [EOL] self . source = source [EOL] [EOL] def read ( self ) : [EOL] return DotEnv ( self . source , interpolate = False ) . dict ( ) [EOL] [EOL] [EOL] class YAMLTemplateReader ( BaseTemplateReader ) : [EOL] [docstring] [EOL] [EOL] SCHEMA_VERSION_MATCH = [string] [EOL] [EOL] def __init__ ( self , source ) : [EOL] self . source = source [EOL] [EOL] def _read ( self ) : [EOL] [docstring] [EOL] source = yaml . safe_load ( self . source . read_text ( ) ) [EOL] assert source , self . source [EOL] try : [EOL] if re . match ( self . SCHEMA_VERSION_MATCH , str ( source [ [string] ] ) ) : [EOL] return source [EOL] else : [EOL] raise TypeError [EOL] except TypeError : [EOL] raise TypeError ( f" [string] { source . get ( [string] ) }" ) [EOL] [EOL] def read ( self ) : [EOL] template = self . _read ( ) [EOL] for key , value in template [ [string] ] . items ( ) : [EOL] for var_type , var_pattern in AUTO_VARIABLE_MATCHERS . items ( ) : [EOL] match = var_pattern . search ( str ( value ) ) [EOL] if match : [EOL] template [ [string] ] [ key ] = var_type ( key , match . group ( [string] ) ) [EOL] break [EOL] else : [EOL] template [ [string] ] [ key ] = EnvVariable ( key , value ) [EOL] return template [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.str,typing.TextIO]$ 0 0 0 0 0 $typing.Union[builtins.str,typing.TextIO]$ 0 $typing.Union[builtins.str,typing.TextIO]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Dict [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import shutil [EOL] from pathlib import Path [EOL] from typing import Dict [EOL] [EOL] [EOL] class Writer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , target_file , environment ) : [EOL] self . target_file = target_file [EOL] self . environment = environment [EOL] [EOL] def write ( self ) : [EOL] backup_file = Path ( f"{ self . target_file } [string] " ) [EOL] shutil . copy2 ( self . target_file , backup_file ) [EOL] [EOL] with self . target_file . open ( [string] , encoding = [string] ) as f : [EOL] f . seek ( [number] ) [EOL] for k , v in self . environment . items ( ) : [EOL] [comment] [EOL] v = [string] if not v else v [EOL] f . write ( f"{ k } [string] { v } [string] " ) [EOL] [EOL] os . remove ( backup_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0