from typing import Dict , Any [EOL] import typing [EOL] import setuptools [EOL] [EOL] version = { } [EOL] with open ( [string] ) as fd : [EOL] exec ( fd . read ( ) , version ) [EOL] [EOL] setuptools . setup ( name = [string] , version = version [ [string] ] , description = [string] , long_description = [string] , author = [string] , author_email = [string] , url = [string] , packages = [ [string] ] , entry_points = { [string] : [ [string] ] } , python_requires = [string] , classifiers = [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional [EOL] import typing [EOL] import os [EOL] [EOL] [comment] [EOL] git_reference_workspace = os . getenv ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import logging [EOL] import logging [EOL] import sys [EOL] from typing import cast [EOL] [EOL] VERBOSE = [number] [EOL] TRACE = [number] [EOL] SPAM = [number] [EOL] [EOL] [EOL] def getLogger ( ) : [EOL] [docstring] [EOL] [comment] [EOL] return cast ( WitLogger , logging . getLogger ( [string] ) ) [EOL] [EOL] [EOL] class WitFormatter ( logging . Formatter ) : [EOL] [docstring] [EOL] [EOL] info_format = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( fmt = [string] , datefmt = None , style = [string] ) [EOL] [EOL] def format ( self , record ) : [EOL] [EOL] orig_fmt = self . _style . _fmt [EOL] if record . levelno == logging . INFO : [EOL] self . _style . _fmt = WitFormatter . info_format [EOL] [EOL] result = logging . Formatter . format ( self , record ) [EOL] self . _style . _fmt = orig_fmt [EOL] [EOL] return result [EOL] [EOL] [EOL] class WitLogger ( logging . Logger ) : [EOL] [comment] [EOL] [EOL] def __init__ ( self , name , level = logging . NOTSET ) : [EOL] super ( ) . __init__ ( name , level ) [EOL] [comment] [EOL] _handler = logging . StreamHandler ( sys . stdout ) [EOL] _handler . setFormatter ( WitFormatter ( ) ) [EOL] logging . basicConfig ( level = logging . INFO , handlers = [ _handler ] ) [EOL] [EOL] logging . addLevelName ( VERBOSE , [string] ) [EOL] logging . addLevelName ( TRACE , [string] ) [EOL] logging . addLevelName ( SPAM , [string] ) [EOL] [EOL] def getLevelName ( self ) : [EOL] return logging . getLevelName ( getLogger ( ) . getEffectiveLevel ( ) ) [EOL] [EOL] def verbose ( self , msg , * args , ** kwargs ) : [EOL] if self . isEnabledFor ( VERBOSE ) : [EOL] self . _log ( VERBOSE , msg , args , ** kwargs ) [EOL] [EOL] def trace ( self , msg , * args , ** kwargs ) : [EOL] if self . isEnabledFor ( TRACE ) : [EOL] self . _log ( TRACE , msg , args , ** kwargs ) [EOL] [EOL] def spam ( self , msg , * args , ** kwargs ) : [EOL] if self . isEnabledFor ( SPAM ) : [EOL] self . _log ( SPAM , msg , args , ** kwargs ) [EOL] [EOL] [comment] [EOL] def output ( self , msg ) : [EOL] print ( msg ) [EOL] [EOL] [EOL] logging . setLoggerClass ( WitLogger ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Tuple [EOL] import typing [EOL] import sys [EOL] from . common import print_errors [EOL] from . witlogger import getLogger [EOL] [EOL] log = getLogger ( ) [EOL] [EOL] [EOL] def inspect_tree ( ws , args ) : [EOL] packages , errors = ws . resolve ( ) [EOL] [EOL] if args . tree : [EOL] tree = { } [EOL] for dep in ws . manifest . dependencies : [EOL] tree [ dep . get_id ( ) ] = dep . crawl_dep_tree ( ws . root , ws . repo_paths , packages ) [EOL] for key in tree : [EOL] top_dep = tree [ key ] [EOL] x , _ = _deduplicate_tree ( top_dep ) [EOL] _print_generic_tree ( x ) [EOL] [EOL] if args . dot : [EOL] _print_dot_tree ( ws , packages ) [EOL] [EOL] print_errors ( errors ) [EOL] [EOL] [EOL] BOXED_DEPS = False [EOL] VERBOSE_GRAPH = False [EOL] [EOL] [EOL] def _deduplicate_tree ( tree , seen = None ) : [EOL] tree = tree . copy ( ) [EOL] seen = seen or [ ] [EOL] tag = tree . pop ( [string] ) [EOL] ident = tag [ - [number] : ] [EOL] out = { [string] : tag } [EOL] [EOL] if ident in seen : [EOL] return out , seen [EOL] else : [EOL] seen . append ( ident ) [EOL] for key in tree : [EOL] out [ key ] , seen = _deduplicate_tree ( tree [ key ] , seen ) [EOL] return out , seen [EOL] [EOL] [EOL] def _print_dot_tree ( ws , packages_dict ) : [EOL] packages = list ( packages_dict . values ( ) ) [EOL] [EOL] log . output ( [string] ) [EOL] log . output ( [string] ) [EOL] [EOL] pkg_ids = [ ] [EOL] for pkg in packages : [EOL] pkg_id = pkg . get_id ( ) [EOL] pkg_ids . append ( pkg_id ) [EOL] log . output ( [string] . format ( pkg_id , pkg . id ( ) ) ) [EOL] [EOL] drawn_connections = [ ] [EOL] [EOL] def draw_connection ( from_id , to_id , dotted = False ) : [EOL] if from_id == to_id : [EOL] return [EOL] pair = ( from_id , to_id ) [EOL] if pair not in drawn_connections : [EOL] log . output ( [string] . format ( from_id , to_id , [string] if dotted else [string] ) ) [EOL] drawn_connections . append ( pair ) [EOL] [EOL] def print_dep ( pkg , dep ) : [EOL] pkg_id = pkg . get_id ( ) [EOL] dep_id = dep . get_id ( ) [EOL] dep . load ( packages_dict , ws . repo_paths , ws . root , False ) [EOL] if dep . package . repo is None : [EOL] log . error ( [string] . format ( dep . name ) ) [EOL] sys . exit ( [number] ) [EOL] dep_pkg_id = dep . package . get_id ( ) [EOL] if dep . id ( ) != dep . package . id ( ) or VERBOSE_GRAPH : [EOL] draw_connection ( dep_id , dep_pkg_id , dotted = True ) [EOL] log . output ( [string] . format ( dep_id , dep . id ( ) , [string] if BOXED_DEPS else [string] ) ) [EOL] draw_connection ( pkg_id , dep_id ) [EOL] else : [EOL] draw_connection ( pkg_id , dep_pkg_id ) [EOL] [EOL] for dep in ws . manifest . dependencies : [EOL] print_dep ( ws , dep ) [EOL] [EOL] for pkg in packages : [EOL] for dep in pkg . get_dependencies ( ) : [EOL] print_dep ( pkg , dep ) [EOL] [EOL] log . output ( [string] ) [EOL] [EOL] [EOL] def _print_generic_tree ( data ) : [EOL] tag = data . pop ( [string] ) [EOL] print ( tag ) [EOL] return _recur_print_generic_tree ( [number] , data , [ ] ) [EOL] [EOL] [EOL] def _recur_print_generic_tree ( depth , data , done_cols ) : [EOL] [EOL] def print_indent ( depth ) : [EOL] for i in range ( [number] , depth ) : [EOL] if i in done_cols : [EOL] print ( [string] , end = [string] ) [EOL] else : [EOL] print ( [string] , end = [string] ) [EOL] [EOL] done_cols_copy = done_cols [ : ] [EOL] [EOL] keys = list ( data . keys ( ) ) [EOL] for i , key in enumerate ( keys ) : [EOL] subdata = data [ key ] [EOL] subtag = subdata . pop ( [string] ) [EOL] print_indent ( depth ) [EOL] if i == len ( keys ) - [number] : [EOL] print ( [string] , end = [string] ) [EOL] done_cols_copy . append ( depth ) [EOL] else : [EOL] print ( [string] , end = [string] ) [EOL] print ( subtag ) [EOL] _recur_print_generic_tree ( depth + [number] , subdata , done_cols_copy ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , Any , List [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import sys [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class Format ( Enum ) : [EOL] Lock = [number] [EOL] Manifest = [number] [EOL] [EOL] @ staticmethod def from_path ( path ) : [EOL] if path . name == [string] : [EOL] return Format . Lock [EOL] if path . name == [string] or path . name == [string] : [EOL] return Format . Manifest [EOL] raise Exception ( [string] . format ( str ( path ) ) ) [EOL] [EOL] [EOL] class RepoEntry : [EOL] def __init__ ( self , checkout_path , revision , remote_url , message = None ) : [EOL] [comment] [EOL] [comment] [EOL] self . checkout_path = checkout_path [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . revision = revision [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . remote_url = remote_url [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . message = message [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . __dict__ ) [EOL] [EOL] [EOL] [comment] [EOL] class OriginalEntry ( ) : [EOL] @ staticmethod def to_dict ( entry ) : [EOL] d = { [string] : entry . checkout_path , [string] : entry . revision , [string] : entry . remote_url , } [EOL] if entry . message : [EOL] d [ [string] ] = entry . message [EOL] return d [EOL] [EOL] @ staticmethod def from_dict ( data ) : [EOL] return RepoEntry ( data [ [string] ] , data [ [string] ] , data . get ( [string] ) , data . get ( [string] ) ) [comment] [EOL] [EOL] [EOL] [comment] [EOL] class RepoEntries : [EOL] @ staticmethod def write ( path , entries ) : [EOL] fmt = Format . from_path ( path ) [EOL] if fmt is Format . Manifest : [EOL] manifest_data = [ OriginalEntry . to_dict ( e ) for e in entries ] [EOL] json_data = json . dumps ( manifest_data , sort_keys = True , indent = [number] ) + [string] [EOL] if fmt is Format . Lock : [EOL] lock_data = dict ( ( e . checkout_path , OriginalEntry . to_dict ( e ) ) for e in entries ) [EOL] json_data = json . dumps ( lock_data , sort_keys = True , indent = [number] ) + [string] [EOL] path . write_text ( json_data ) [EOL] [EOL] @ staticmethod def read ( path ) : [EOL] text = path . read_text ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return RepoEntries . parse ( text , path , [string] ) [EOL] [EOL] @ staticmethod def parse ( text , path , rev ) : [EOL] try : [EOL] fromtext = json . loads ( text ) [EOL] except json . JSONDecodeError as e : [EOL] print ( [string] . format ( path , rev , e . msg ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] entries = [ ] [EOL] fmt = Format . from_path ( path ) [EOL] if fmt is Format . Manifest : [EOL] for entry in fromtext : [EOL] entries . append ( OriginalEntry . from_dict ( entry ) ) [EOL] if fmt is Format . Lock : [EOL] for _ , entry in fromtext . items ( ) : [EOL] entries . append ( OriginalEntry . from_dict ( entry ) ) [EOL] [EOL] [comment] [EOL] names = [ entry . checkout_path for entry in entries ] [EOL] if len ( names ) != len ( set ( names ) ) : [EOL] dup = set ( [ x for x in names if names . count ( x ) > [number] ] ) [EOL] print ( [string] . format ( path , rev , dup ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] return entries [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[RepoEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] __version__ = [string] [EOL]	0 0 $builtins.str$ 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import sys [EOL] from . witlogger import getLogger [EOL] [EOL] log = getLogger ( ) [EOL] [EOL] [EOL] def error ( * args , ** kwargs ) : [EOL] log . error ( * args , ** kwargs ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def print_errors ( errors ) : [EOL] if len ( errors ) > [number] : [EOL] log . info ( [string] ) [comment] [EOL] [EOL] for err in errors : [EOL] log . info ( [string] ) [EOL] log . info ( err ) [EOL] [EOL] [EOL] class WitUserError ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0