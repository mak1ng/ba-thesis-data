[comment] [EOL] from typing import Iterator , Pattern , Dict , List , Any , Union [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import glob [EOL] import json [EOL] import os [EOL] import re [EOL] from typing import Union , List , Dict [EOL] [EOL] FILENAME_FORMAT = re . compile ( [string] ) [EOL] [EOL] [EOL] def load_json ( filename ) : [EOL] [docstring] [EOL] with open ( filename , encoding = [string] ) as fdesc : [EOL] return json . loads ( fdesc . read ( ) ) [EOL] return { } [EOL] [EOL] [EOL] def save_json ( filename , data ) : [EOL] [docstring] [EOL] data = json . dumps ( data , sort_keys = True , indent = [number] ) [EOL] with open ( filename , [string] , encoding = [string] ) as fdesc : [EOL] fdesc . write ( data ) [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def get_language ( path ) : [EOL] [docstring] [EOL] return os . path . splitext ( os . path . basename ( path ) ) [ [number] ] [EOL] [EOL] [EOL] def get_component_path ( lang , component ) : [EOL] [docstring] [EOL] if os . path . isdir ( os . path . join ( [string] , [string] , component ) ) : [EOL] return os . path . join ( [string] , [string] , component , [string] , [string] . format ( lang ) ) [EOL] else : [EOL] return os . path . join ( [string] , [string] , [string] , [string] . format ( component , lang ) ) [EOL] [EOL] [EOL] def get_platform_path ( lang , component , platform ) : [EOL] [docstring] [EOL] if os . path . isdir ( os . path . join ( [string] , [string] , component , platform ) ) : [EOL] return os . path . join ( [string] , [string] , component , platform , [string] , [string] . format ( lang ) ) [EOL] else : [EOL] return os . path . join ( [string] , [string] , component , [string] , [string] . format ( platform , lang ) ) [EOL] [EOL] [EOL] def get_component_translations ( translations ) : [EOL] [docstring] [EOL] translations = translations . copy ( ) [EOL] translations . pop ( [string] , None ) [EOL] [EOL] return translations [EOL] [EOL] [EOL] def save_language_translations ( lang , translations ) : [EOL] [docstring] [EOL] components = translations . get ( [string] , { } ) [EOL] for component , component_translations in components . items ( ) : [EOL] base_translations = get_component_translations ( component_translations ) [EOL] if base_translations : [EOL] path = get_component_path ( lang , component ) [EOL] os . makedirs ( os . path . dirname ( path ) , exist_ok = True ) [EOL] save_json ( path , base_translations ) [EOL] [EOL] for platform , platform_translations in component_translations . get ( [string] , { } ) . items ( ) : [EOL] path = get_platform_path ( lang , component , platform ) [EOL] os . makedirs ( os . path . dirname ( path ) , exist_ok = True ) [EOL] save_json ( path , platform_translations ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] if not os . path . isfile ( [string] ) : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] paths = glob . iglob ( [string] ) [EOL] for path in paths : [EOL] lang = get_language ( path ) [EOL] translations = load_json ( path ) [EOL] save_language_translations ( lang , translations ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import locale [EOL] locale . setlocale ( locale . LC_ALL , [string] ) [EOL] except : [EOL] pass [EOL] [EOL] from docutils . core import publish_cmdline , default_description [EOL] [EOL] [EOL] description = ( [string] [string] + default_description ) [EOL] [EOL] publish_cmdline ( description = description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import locale [EOL] locale . setlocale ( locale . LC_ALL , [string] ) [EOL] except : [EOL] pass [EOL] [EOL] from docutils . core import publish_cmdline , default_description [EOL] [EOL] [EOL] description = ( [string] [string] + default_description ) [EOL] [EOL] publish_cmdline ( writer_name = [string] , description = description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import locale [EOL] locale . setlocale ( locale . LC_ALL , [string] ) [EOL] except : [EOL] pass [EOL] [EOL] from docutils . core import publish_cmdline , default_description [EOL] [EOL] [EOL] description = ( [string] [string] + default_description ) [EOL] [EOL] publish_cmdline ( writer_name = [string] , description = description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import locale [EOL] locale . setlocale ( locale . LC_ALL , [string] ) [EOL] except : [EOL] pass [EOL] [EOL] from docutils . core import publish_cmdline , default_description [EOL] [EOL] [EOL] description = ( [string] [string] + default_description ) [EOL] [EOL] publish_cmdline ( writer_name = [string] , description = description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import locale [EOL] locale . setlocale ( locale . LC_ALL , [string] ) [EOL] except : [EOL] pass [EOL] [EOL] from docutils . core import publish_cmdline , default_description [EOL] [EOL] [EOL] description = ( [string] [string] + default_description ) [EOL] [EOL] publish_cmdline ( writer_name = [string] , description = description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
[docstring] [EOL]	0 0
from typing import List , Optional , Dict , Any [EOL] import threading [EOL] import logging [EOL] import pkg_resources [EOL] import builtins [EOL] import subprocess [EOL] import asyncio [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import os [EOL] from subprocess import PIPE , Popen [EOL] import sys [EOL] import threading [EOL] from urllib . parse import urlparse [EOL] [EOL] from typing import Optional [EOL] [EOL] import pkg_resources [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] INSTALL_LOCK = threading . Lock ( ) [EOL] [EOL] [EOL] def is_virtual_env ( ) : [EOL] [docstring] [EOL] [comment] [EOL] return ( getattr ( sys , [string] , sys . prefix ) != sys . prefix or hasattr ( sys , [string] ) ) [EOL] [EOL] [EOL] def install_package ( package , upgrade = True , target = None , constraints = None ) : [EOL] [docstring] [EOL] [comment] [EOL] with INSTALL_LOCK : [EOL] if package_loadable ( package ) : [EOL] return True [EOL] [EOL] _LOGGER . info ( [string] , package ) [EOL] env = os . environ . copy ( ) [EOL] args = [ sys . executable , [string] , [string] , [string] , [string] , package ] [EOL] if upgrade : [EOL] args . append ( [string] ) [EOL] if constraints is not None : [EOL] args += [ [string] , constraints ] [EOL] if target : [EOL] assert not is_virtual_env ( ) [EOL] [comment] [EOL] args += [ [string] ] [EOL] env [ [string] ] = os . path . abspath ( target ) [EOL] if sys . platform != [string] : [EOL] [comment] [EOL] [comment] [EOL] args += [ [string] ] [EOL] process = Popen ( args , stdin = PIPE , stdout = PIPE , stderr = PIPE , env = env ) [EOL] _ , stderr = process . communicate ( ) [EOL] if process . returncode != [number] : [EOL] _LOGGER . error ( [string] , package , stderr . decode ( [string] ) . lstrip ( ) . strip ( ) ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def package_loadable ( package ) : [EOL] [docstring] [EOL] try : [EOL] req = pkg_resources . Requirement . parse ( package ) [EOL] except ValueError : [EOL] [comment] [EOL] req = pkg_resources . Requirement . parse ( urlparse ( package ) . fragment ) [EOL] [EOL] for path in sys . path : [EOL] for dist in pkg_resources . find_distributions ( path ) : [EOL] [comment] [EOL] [comment] [EOL] if dist . project_name == req . project_name : [EOL] return dist in req [EOL] [EOL] return False [EOL] [EOL] [EOL] async def async_get_user_site ( deps_dir ) : [EOL] [docstring] [EOL] env = os . environ . copy ( ) [EOL] env [ [string] ] = os . path . abspath ( deps_dir ) [EOL] args = [ sys . executable , [string] , [string] , [string] ] [EOL] process = await asyncio . create_subprocess_exec ( * args , stdin = asyncio . subprocess . PIPE , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . DEVNULL , env = env ) [EOL] stdout , _ = await process . communicate ( ) [EOL] lib_dir = stdout . decode ( ) . strip ( ) [EOL] return lib_dir [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] from requests . exceptions import HTTPError [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers import discovery [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . const import CONF_USERNAME , CONF_PASSWORD [EOL] from homeassistant . util import Throttle [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] IS_IN_BED = [string] [EOL] SLEEP_NUMBER = [string] [EOL] SENSOR_TYPES = { SLEEP_NUMBER : [string] , IS_IN_BED : [string] , } [EOL] [EOL] LEFT = [string] [EOL] RIGHT = [string] [EOL] SIDES = [ LEFT , RIGHT ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DATA = None [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { vol . Required ( DOMAIN ) : vol . Schema ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] global DATA [EOL] [EOL] from sleepyq import Sleepyq [EOL] username = config [ DOMAIN ] [ CONF_USERNAME ] [EOL] password = config [ DOMAIN ] [ CONF_PASSWORD ] [EOL] client = Sleepyq ( username , password ) [EOL] try : [EOL] DATA = SleepIQData ( client ) [EOL] DATA . update ( ) [EOL] except HTTPError : [EOL] message = [string] [EOL] _LOGGER . error ( message ) [EOL] return False [EOL] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class SleepIQData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . beds = { } [EOL] [EOL] self . update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . _client . login ( ) [EOL] beds = self . _client . beds_with_sleeper_status ( ) [EOL] [EOL] self . beds = { bed . bed_id : bed for bed in beds } [EOL] [EOL] [EOL] class SleepIQSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sleepiq_data , bed_id , side ) : [EOL] [docstring] [EOL] self . _bed_id = bed_id [EOL] self . _side = side [EOL] self . sleepiq_data = sleepiq_data [EOL] self . side = None [EOL] self . bed = None [EOL] [EOL] [comment] [EOL] self . _name = None [EOL] self . type = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . bed . name , self . side . sleeper . first_name , self . _name ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . sleepiq_data . update ( ) [EOL] [EOL] self . bed = self . sleepiq_data . beds [ self . _bed_id ] [EOL] self . side = getattr ( self . bed , self . _side ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , Generator [EOL] import typing [EOL] import api [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_API_KEY , CONF_DOMAIN [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . http import HomeAssistantView [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] API_PATH = [string] . format ( DOMAIN ) [EOL] DATA_MAILGUN = DOMAIN [EOL] DEPENDENCIES = [ [string] ] [EOL] MESSAGE_RECEIVED = [string] . format ( DOMAIN ) [EOL] CONF_SANDBOX = [string] [EOL] DEFAULT_SANDBOX = False [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_DOMAIN ) : cv . string , vol . Optional ( CONF_SANDBOX , default = DEFAULT_SANDBOX ) : cv . boolean } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] hass . data [ DATA_MAILGUN ] = config [ DOMAIN ] [EOL] hass . http . register_view ( MailgunReceiveMessageView ( ) ) [EOL] return True [EOL] [EOL] [EOL] class MailgunReceiveMessageView ( HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = API_PATH [EOL] name = [string] . format ( DOMAIN ) [EOL] [EOL] @ callback def post ( self , request ) : [comment] [EOL] [docstring] [EOL] hass = request . app [ [string] ] [EOL] data = yield from request . post ( ) [EOL] hass . bus . async_fire ( MESSAGE_RECEIVED , dict ( data ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] import logging [EOL] import api [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] from aiohttp . hdrs import CONTENT_TYPE [EOL] [EOL] from homeassistant . const import CONF_API_KEY , CONF_HOST , CONTENT_TYPE_JSON [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] CONF_NUMBER_OF_TOOLS = [string] [EOL] CONF_BED = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NUMBER_OF_TOOLS , default = [number] ) : cv . positive_int , vol . Optional ( CONF_BED , default = False ) : cv . boolean } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] base_url = [string] . format ( config [ DOMAIN ] [ CONF_HOST ] ) [EOL] api_key = config [ DOMAIN ] [ CONF_API_KEY ] [EOL] number_of_tools = config [ DOMAIN ] [ CONF_NUMBER_OF_TOOLS ] [EOL] bed = config [ DOMAIN ] [ CONF_BED ] [EOL] [EOL] hass . data [ DOMAIN ] = { [string] : None } [EOL] [EOL] try : [EOL] octoprint_api = OctoPrintAPI ( base_url , api_key , bed , number_of_tools ) [EOL] hass . data [ DOMAIN ] [ [string] ] = octoprint_api [EOL] octoprint_api . get ( [string] ) [EOL] octoprint_api . get ( [string] ) [EOL] except requests . exceptions . RequestException as conn_err : [EOL] _LOGGER . error ( [string] , conn_err ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class OctoPrintAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_url , key , bed , number_of_tools ) : [EOL] [docstring] [EOL] self . api_url = api_url [EOL] self . headers = { CONTENT_TYPE : CONTENT_TYPE_JSON , [string] : key , } [EOL] self . printer_last_reading = [ { } , None ] [EOL] self . job_last_reading = [ { } , None ] [EOL] self . job_available = False [EOL] self . printer_available = False [EOL] self . available = False [EOL] self . printer_error_logged = False [EOL] self . job_error_logged = False [EOL] self . bed = bed [EOL] self . number_of_tools = number_of_tools [EOL] [EOL] def get_tools ( self ) : [EOL] [docstring] [EOL] tools = [ ] [EOL] if self . number_of_tools > [number] : [EOL] for tool_number in range ( [number] , self . number_of_tools ) : [EOL] tools . append ( [string] + str ( tool_number ) ) [EOL] if self . bed : [EOL] tools . append ( [string] ) [EOL] if not self . bed and self . number_of_tools == [number] : [EOL] temps = self . printer_last_reading [ [number] ] . get ( [string] ) [EOL] if temps is not None : [EOL] tools = temps . keys ( ) [EOL] return tools [EOL] [EOL] def get ( self , endpoint ) : [EOL] [docstring] [EOL] [comment] [EOL] now = time . time ( ) [EOL] if endpoint == [string] : [EOL] last_time = self . job_last_reading [ [number] ] [EOL] if last_time is not None : [EOL] if now - last_time < [number] : [EOL] return self . job_last_reading [ [number] ] [EOL] elif endpoint == [string] : [EOL] last_time = self . printer_last_reading [ [number] ] [EOL] if last_time is not None : [EOL] if now - last_time < [number] : [EOL] return self . printer_last_reading [ [number] ] [EOL] [EOL] url = self . api_url + endpoint [EOL] try : [EOL] response = requests . get ( url , headers = self . headers , timeout = [number] ) [EOL] response . raise_for_status ( ) [EOL] if endpoint == [string] : [EOL] self . job_last_reading [ [number] ] = response . json ( ) [EOL] self . job_last_reading [ [number] ] = time . time ( ) [EOL] self . job_available = True [EOL] elif endpoint == [string] : [EOL] self . printer_last_reading [ [number] ] = response . json ( ) [EOL] self . printer_last_reading [ [number] ] = time . time ( ) [EOL] self . printer_available = True [EOL] self . available = self . printer_available and self . job_available [EOL] if self . available : [EOL] self . job_error_logged = False [EOL] self . printer_error_logged = False [EOL] return response . json ( ) [EOL] except Exception as conn_exc : [comment] [EOL] log_string = [string] + [string] % (conn_exc) [EOL] [comment] [EOL] if endpoint == [string] : [EOL] log_string = [string] + log_string [EOL] if not self . job_error_logged : [EOL] _LOGGER . error ( log_string ) [EOL] self . job_error_logged = True [EOL] self . job_available = False [EOL] elif endpoint == [string] : [EOL] log_string = [string] + log_string [EOL] if not self . printer_error_logged : [EOL] _LOGGER . error ( log_string ) [EOL] self . printer_error_logged = True [EOL] self . printer_available = False [EOL] self . available = False [EOL] return None [EOL] [EOL] def update ( self , sensor_type , end_point , group , tool = None ) : [EOL] [docstring] [EOL] response = self . get ( end_point ) [EOL] if response is not None : [EOL] return get_value_from_json ( response , sensor_type , group , tool ) [EOL] return response [EOL] [EOL] [EOL] def get_value_from_json ( json_dict , sensor_type , group , tool ) : [EOL] [docstring] [EOL] if group not in json_dict : [EOL] return None [EOL] [EOL] if sensor_type in json_dict [ group ] : [EOL] if sensor_type == [string] and json_dict [ sensor_type ] is None : [EOL] return [number] [EOL] return json_dict [ group ] [ sensor_type ] [EOL] [EOL] if tool is not None : [EOL] if sensor_type in json_dict [ group ] [ tool ] : [EOL] return json_dict [ group ] [ tool ] [ sensor_type ] [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . mqtt import ( valid_publish_topic , valid_subscribe_topic ) [EOL] from homeassistant . const import ( ATTR_SERVICE_DATA , EVENT_CALL_SERVICE , EVENT_SERVICE_EXECUTED , EVENT_STATE_CHANGED , EVENT_TIME_CHANGED , MATCH_ALL ) [EOL] from homeassistant . core import EventOrigin , State [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . json import JSONEncoder [EOL] [EOL] DOMAIN = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_PUBLISH_TOPIC = [string] [EOL] CONF_SUBSCRIBE_TOPIC = [string] [EOL] CONF_PUBLISH_EVENTSTREAM_RECEIVED = [string] [EOL] CONF_IGNORE_EVENT = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_PUBLISH_TOPIC ) : valid_publish_topic , vol . Optional ( CONF_SUBSCRIBE_TOPIC ) : valid_subscribe_topic , vol . Optional ( CONF_PUBLISH_EVENTSTREAM_RECEIVED , default = False ) : cv . boolean , vol . Optional ( CONF_IGNORE_EVENT , default = [ ] ) : cv . ensure_list } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] mqtt = hass . components . mqtt [EOL] conf = config . get ( DOMAIN , { } ) [EOL] pub_topic = conf . get ( CONF_PUBLISH_TOPIC ) [EOL] sub_topic = conf . get ( CONF_SUBSCRIBE_TOPIC ) [EOL] ignore_event = conf . get ( CONF_IGNORE_EVENT ) [EOL] [EOL] @ callback def _event_publisher ( event ) : [EOL] [docstring] [EOL] if event . origin != EventOrigin . local : [EOL] return [EOL] if event . event_type == EVENT_TIME_CHANGED : [EOL] return [EOL] [EOL] [comment] [EOL] if event . event_type in ignore_event : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if event . event_type == EVENT_CALL_SERVICE : [EOL] if ( event . data . get ( [string] ) == mqtt . DOMAIN and event . data . get ( [string] ) == mqtt . SERVICE_PUBLISH and event . data [ ATTR_SERVICE_DATA ] . get ( [string] ) == pub_topic ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if event . event_type == EVENT_SERVICE_EXECUTED : [EOL] return [EOL] [EOL] event_info = { [string] : event . event_type , [string] : event . data } [EOL] msg = json . dumps ( event_info , cls = JSONEncoder ) [EOL] mqtt . async_publish ( pub_topic , msg ) [EOL] [EOL] [comment] [EOL] if pub_topic : [EOL] hass . bus . async_listen ( MATCH_ALL , _event_publisher ) [EOL] [EOL] [comment] [EOL] @ callback def _event_receiver ( topic , payload , qos ) : [EOL] [docstring] [EOL] event = json . loads ( payload ) [EOL] event_type = event . get ( [string] ) [EOL] event_data = event . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if event_type == EVENT_STATE_CHANGED and event_data : [EOL] for key in ( [string] , [string] ) : [EOL] state = State . from_dict ( event_data . get ( key ) ) [EOL] [EOL] if state : [EOL] event_data [ key ] = state [EOL] [EOL] hass . bus . async_fire ( event_type , event_data = event_data , origin = EventOrigin . remote ) [EOL] [EOL] [comment] [EOL] if sub_topic : [EOL] yield from mqtt . async_subscribe ( sub_topic , _event_receiver ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , CONF_ICON , CONF_NAME , SERVICE_TURN_OFF , SERVICE_TURN_ON , SERVICE_TOGGLE , STATE_ON ) [EOL] from homeassistant . loader import bind_hass [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_INITIAL = [string] [EOL] [EOL] SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { cv . slug : vol . Any ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_INITIAL ) : cv . boolean , vol . Optional ( CONF_ICON ) : cv . icon , } , None ) } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ bind_hass def is_on ( hass , entity_id ) : [EOL] [docstring] [EOL] return hass . states . is_state ( entity_id , STATE_ON ) [EOL] [EOL] [EOL] @ bind_hass def turn_on ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity_id } ) [EOL] [EOL] [EOL] @ bind_hass def turn_off ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : entity_id } ) [EOL] [EOL] [EOL] @ bind_hass def toggle ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_TOGGLE , { ATTR_ENTITY_ID : entity_id } ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] entities = [ ] [EOL] [EOL] for object_id , cfg in config [ DOMAIN ] . items ( ) : [EOL] if not cfg : [EOL] cfg = { } [EOL] [EOL] name = cfg . get ( CONF_NAME ) [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] icon = cfg . get ( CONF_ICON ) [EOL] [EOL] entities . append ( InputBoolean ( object_id , name , initial , icon ) ) [EOL] [EOL] if not entities : [EOL] return False [EOL] [EOL] component . async_register_entity_service ( SERVICE_TURN_ON , SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TURN_OFF , SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TOGGLE , SERVICE_SCHEMA , [string] ) [EOL] [EOL] await component . async_add_entities ( entities ) [EOL] return True [EOL] [EOL] [EOL] class InputBoolean ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , object_id , name , initial , icon ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _name = name [EOL] self . _state = initial [EOL] self . _icon = icon [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _state is not None : [EOL] return [EOL] [EOL] state = await async_get_last_state ( self . hass , self . entity_id ) [EOL] self . _state = state and state . state == STATE_ON [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = True [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = False [EOL] await self . async_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Dict , Any , Union [EOL] import typing [EOL] import logging [EOL] import api [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . bmw_connected_drive import DOMAIN as BMW_DOMAIN [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_TO_HA = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] accounts = hass . data [ BMW_DOMAIN ] [EOL] _LOGGER . debug ( [string] , [string] . join ( [ a . name for a in accounts ] ) ) [EOL] devices = [ ] [EOL] for account in accounts : [EOL] for vehicle in account . account . vehicles : [EOL] for attribute_name in vehicle . drive_train_attributes : [EOL] device = BMWConnectedDriveSensor ( account , vehicle , attribute_name ) [EOL] devices . append ( device ) [EOL] device = BMWConnectedDriveSensor ( account , vehicle , [string] ) [EOL] devices . append ( device ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class BMWConnectedDriveSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , account , vehicle , attribute ) : [EOL] [docstring] [EOL] self . _vehicle = vehicle [EOL] self . _account = account [EOL] self . _attribute = attribute [EOL] self . _state = None [EOL] self . _name = [string] . format ( self . _vehicle . name , self . _attribute ) [EOL] self . _unique_id = [string] . format ( self . _vehicle . vin , self . _attribute ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] from bimmer_connected . state import ChargingState [EOL] vehicle_state = self . _vehicle . state [EOL] charging_state = vehicle_state . charging_status in [ ChargingState . CHARGING ] [EOL] [EOL] if self . _attribute == [string] : [EOL] return icon_for_battery_level ( battery_level = vehicle_state . charging_level_hv , charging = charging_state ) [EOL] icon , _ = ATTR_TO_HA . get ( self . _attribute , [ None , None ] ) [EOL] return icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] _ , unit = ATTR_TO_HA . get ( self . _attribute , [ None , None ] ) [EOL] return unit [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _vehicle . name } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _vehicle . name ) [EOL] vehicle_state = self . _vehicle . state [EOL] if self . _attribute == [string] : [EOL] self . _state = getattr ( vehicle_state , self . _attribute ) . value [EOL] else : [EOL] self . _state = getattr ( vehicle_state , self . _attribute ) [EOL] [EOL] def update_callback ( self ) : [EOL] [docstring] [EOL] self . schedule_update_ha_state ( True ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _account . add_update_listener ( self . update_callback ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import api [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_VALUE_TEMPLATE , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_SERIAL_PORT = [string] [EOL] CONF_BAUDRATE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_BAUDRATE = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SERIAL_PORT ) : cv . string , vol . Optional ( CONF_BAUDRATE , default = DEFAULT_BAUDRATE ) : cv . positive_int , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] port = config . get ( CONF_SERIAL_PORT ) [EOL] baudrate = config . get ( CONF_BAUDRATE ) [EOL] [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] sensor = SerialSensor ( name , port , baudrate , value_template ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , sensor . stop_serial_read ( ) ) [EOL] async_add_entities ( [ sensor ] , True ) [EOL] [EOL] [EOL] class SerialSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , port , baudrate , value_template ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _port = port [EOL] self . _baudrate = baudrate [EOL] self . _serial_loop_task = None [EOL] self . _template = value_template [EOL] self . _attributes = [ ] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _serial_loop_task = self . hass . loop . create_task ( self . serial_read ( self . _port , self . _baudrate ) ) [EOL] [EOL] @ asyncio . coroutine def serial_read ( self , device , rate , ** kwargs ) : [EOL] [docstring] [EOL] import serial_asyncio [EOL] reader , _ = yield from serial_asyncio . open_serial_connection ( url = device , baudrate = rate , ** kwargs ) [EOL] while True : [EOL] line = yield from reader . readline ( ) [EOL] line = line . decode ( [string] ) . strip ( ) [EOL] [EOL] try : [EOL] data = json . loads ( line ) [EOL] if isinstance ( data , dict ) : [EOL] self . _attributes = data [EOL] except ValueError : [EOL] pass [EOL] [EOL] if self . _template is not None : [EOL] line = self . _template . async_render_with_possible_json_value ( line ) [EOL] [EOL] _LOGGER . debug ( [string] , line ) [EOL] self . _state = line [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def stop_serial_read ( self ) : [EOL] [docstring] [EOL] if self . _serial_loop_task : [EOL] self . _serial_loop_task . cancel ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import api [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] CHANNEL_ID = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( hours = [number] ) [EOL] [EOL] SUBSCRIBERS = [string] [EOL] [EOL] TOTAL_VIEWS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CHANNEL_ID ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] social_blade = SocialBladeSensor ( config [ CHANNEL_ID ] , config [ CONF_NAME ] ) [EOL] [EOL] social_blade . update ( ) [EOL] if social_blade . valid_channel_id is False : [EOL] return [EOL] [EOL] add_entities ( [ social_blade ] ) [EOL] [EOL] [EOL] class SocialBladeSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , case , name ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . channel_id = case [EOL] self . _attributes = None [EOL] self . valid_channel_id = None [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _attributes : [EOL] return self . _attributes [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import socialbladeclient [EOL] try : [EOL] data = socialbladeclient . get_data ( self . channel_id ) [EOL] self . _attributes = { TOTAL_VIEWS : data [ TOTAL_VIEWS ] } [EOL] self . _state = data [ SUBSCRIBERS ] [EOL] self . valid_channel_id = True [EOL] [EOL] except ( ValueError , IndexError ) : [EOL] _LOGGER . error ( [string] ) [EOL] self . valid_channel_id = False [EOL] self . _attributes = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , Dict , List , Union [EOL] import typing [EOL] import logging [EOL] import typing_extensions [EOL] [docstring] [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME , DEVICE_DEFAULT_NAME , TEMP_FAHRENHEIT [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] CONF_SCALE = [string] [EOL] CONF_OFFSET = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEVICE_DEFAULT_NAME ) : vol . Coerce ( str ) , vol . Optional ( CONF_SCALE , default = [number] ) : vol . Coerce ( float ) , vol . Optional ( CONF_OFFSET , default = [number] ) : vol . Coerce ( float ) } ) [EOL] [EOL] TEMPER_SENSORS = [ ] [EOL] [EOL] [EOL] def get_temper_devices ( ) : [EOL] [docstring] [EOL] from temperusb . temper import TemperHandler [EOL] return TemperHandler ( ) . get_devices ( ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] temp_unit = hass . config . units . temperature_unit [EOL] name = config . get ( CONF_NAME ) [EOL] scaling = { [string] : config . get ( CONF_SCALE ) , [string] : config . get ( CONF_OFFSET ) } [EOL] temper_devices = get_temper_devices ( ) [EOL] [EOL] for idx , dev in enumerate ( temper_devices ) : [EOL] if idx != [number] : [EOL] name = name + [string] + str ( idx ) [EOL] TEMPER_SENSORS . append ( TemperSensor ( dev , temp_unit , name , scaling ) ) [EOL] add_entities ( TEMPER_SENSORS ) [EOL] [EOL] [EOL] def reset_devices ( ) : [EOL] [docstring] [EOL] temper_devices = get_temper_devices ( ) [EOL] for sensor , device in zip ( TEMPER_SENSORS , temper_devices ) : [EOL] sensor . set_temper_device ( device ) [EOL] [EOL] [EOL] class TemperSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , temper_device , temp_unit , name , scaling ) : [EOL] [docstring] [EOL] self . temp_unit = temp_unit [EOL] self . scale = scaling [ [string] ] [EOL] self . offset = scaling [ [string] ] [EOL] self . current_value = None [EOL] self . _name = name [EOL] self . set_temper_device ( temper_device ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . current_value [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . temp_unit [EOL] [EOL] def set_temper_device ( self , temper_device ) : [EOL] [docstring] [EOL] self . temper_device = temper_device [EOL] [EOL] [comment] [EOL] self . temper_device . set_calibration_data ( scale = self . scale , offset = self . offset ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] format_str = ( [string] if self . temp_unit == TEMP_FAHRENHEIT [EOL] else [string] ) [EOL] sensor_value = self . temper_device . get_temperature ( format_str ) [EOL] self . current_value = round ( sensor_value , [number] ) [EOL] except IOError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] reset_devices ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Dict , List , Union , Generator [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] from functools import partial [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( TEMP_FAHRENHEIT , CONF_NAME , CONF_MONITORED_CONDITIONS ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . temperature import celsius_to_fahrenheit [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_I2C_ADDRESS = [string] [EOL] CONF_I2C_BUS = [string] [EOL] CONF_OVERSAMPLING_TEMP = [string] [EOL] CONF_OVERSAMPLING_PRES = [string] [EOL] CONF_OVERSAMPLING_HUM = [string] [EOL] CONF_OPERATION_MODE = [string] [EOL] CONF_T_STANDBY = [string] [EOL] CONF_FILTER_MODE = [string] [EOL] CONF_DELTA_TEMP = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_I2C_ADDRESS = [string] [EOL] DEFAULT_I2C_BUS = [number] [EOL] DEFAULT_OVERSAMPLING_TEMP = [number] [comment] [EOL] DEFAULT_OVERSAMPLING_PRES = [number] [comment] [EOL] DEFAULT_OVERSAMPLING_HUM = [number] [comment] [EOL] DEFAULT_OPERATION_MODE = [number] [comment] [EOL] DEFAULT_T_STANDBY = [number] [comment] [EOL] DEFAULT_FILTER_MODE = [number] [comment] [EOL] DEFAULT_DELTA_TEMP = [number] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TEMP = [string] [EOL] SENSOR_HUMID = [string] [EOL] SENSOR_PRESS = [string] [EOL] SENSOR_TYPES = { SENSOR_TEMP : [ [string] , None ] , SENSOR_HUMID : [ [string] , [string] ] , SENSOR_PRESS : [ [string] , [string] ] } [EOL] DEFAULT_MONITORED = [ SENSOR_TEMP , SENSOR_HUMID , SENSOR_PRESS ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_I2C_ADDRESS , default = DEFAULT_I2C_ADDRESS ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = DEFAULT_MONITORED ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_I2C_BUS , default = DEFAULT_I2C_BUS ) : vol . Coerce ( int ) , vol . Optional ( CONF_OVERSAMPLING_TEMP , default = DEFAULT_OVERSAMPLING_TEMP ) : vol . Coerce ( int ) , vol . Optional ( CONF_OVERSAMPLING_PRES , default = DEFAULT_OVERSAMPLING_PRES ) : vol . Coerce ( int ) , vol . Optional ( CONF_OVERSAMPLING_HUM , default = DEFAULT_OVERSAMPLING_HUM ) : vol . Coerce ( int ) , vol . Optional ( CONF_OPERATION_MODE , default = DEFAULT_OPERATION_MODE ) : vol . Coerce ( int ) , vol . Optional ( CONF_T_STANDBY , default = DEFAULT_T_STANDBY ) : vol . Coerce ( int ) , vol . Optional ( CONF_FILTER_MODE , default = DEFAULT_FILTER_MODE ) : vol . Coerce ( int ) , vol . Optional ( CONF_DELTA_TEMP , default = DEFAULT_DELTA_TEMP ) : vol . Coerce ( float ) , } ) [EOL] [EOL] [EOL] [comment] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import smbus [EOL] from i2csense . bme280 import BME280 [EOL] [EOL] SENSOR_TYPES [ SENSOR_TEMP ] [ [number] ] = hass . config . units . temperature_unit [EOL] name = config . get ( CONF_NAME ) [EOL] i2c_address = config . get ( CONF_I2C_ADDRESS ) [EOL] [EOL] bus = smbus . SMBus ( config . get ( CONF_I2C_BUS ) ) [EOL] sensor = yield from hass . async_add_job ( partial ( BME280 , bus , i2c_address , osrs_t = config . get ( CONF_OVERSAMPLING_TEMP ) , osrs_p = config . get ( CONF_OVERSAMPLING_PRES ) , osrs_h = config . get ( CONF_OVERSAMPLING_HUM ) , mode = config . get ( CONF_OPERATION_MODE ) , t_sb = config . get ( CONF_T_STANDBY ) , filter_mode = config . get ( CONF_FILTER_MODE ) , delta_temp = config . get ( CONF_DELTA_TEMP ) , logger = _LOGGER ) ) [EOL] if not sensor . sample_ok : [EOL] _LOGGER . error ( [string] , i2c_address ) [EOL] return False [EOL] [EOL] sensor_handler = yield from hass . async_add_job ( BME280Handler , sensor ) [EOL] [EOL] dev = [ ] [EOL] try : [EOL] for variable in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( BME280Sensor ( sensor_handler , variable , SENSOR_TYPES [ variable ] [ [number] ] , name ) ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] async_add_entities ( dev , True ) [EOL] [EOL] [EOL] class BME280Handler : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor ) : [EOL] [docstring] [EOL] self . sensor = sensor [EOL] self . update ( True ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self , first_reading = False ) : [EOL] [docstring] [EOL] self . sensor . update ( first_reading ) [EOL] [EOL] [EOL] class BME280Sensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bme280_client , sensor_type , temp_unit , name ) : [EOL] [docstring] [EOL] self . client_name = name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . bme280_client = bme280_client [EOL] self . temp_unit = temp_unit [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] yield from self . hass . async_add_job ( self . bme280_client . update ) [EOL] if self . bme280_client . sensor . sample_ok : [EOL] if self . type == SENSOR_TEMP : [EOL] temperature = round ( self . bme280_client . sensor . temperature , [number] ) [EOL] if self . temp_unit == TEMP_FAHRENHEIT : [EOL] temperature = round ( celsius_to_fahrenheit ( temperature ) , [number] ) [EOL] self . _state = temperature [EOL] elif self . type == SENSOR_HUMID : [EOL] self . _state = round ( self . bme280_client . sensor . humidity , [number] ) [EOL] elif self . type == SENSOR_PRESS : [EOL] self . _state = round ( self . bme280_client . sensor . pressure , [number] ) [EOL] else : [EOL] _LOGGER . warning ( [string] , self . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Dict , Any [EOL] import typing [EOL] import api [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import datetime [EOL] import logging [EOL] import math [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import history [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_ENTITY_ID , CONF_STATE , CONF_TYPE , EVENT_HOMEASSISTANT_START ) [EOL] from homeassistant . exceptions import TemplateError [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_state_change [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_START = [string] [EOL] CONF_END = [string] [EOL] CONF_DURATION = [string] [EOL] CONF_PERIOD_KEYS = [ CONF_START , CONF_END , CONF_DURATION ] [EOL] [EOL] CONF_TYPE_TIME = [string] [EOL] CONF_TYPE_RATIO = [string] [EOL] CONF_TYPE_COUNT = [string] [EOL] CONF_TYPE_KEYS = [ CONF_TYPE_TIME , CONF_TYPE_RATIO , CONF_TYPE_COUNT ] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] UNITS = { CONF_TYPE_TIME : [string] , CONF_TYPE_RATIO : [string] , CONF_TYPE_COUNT : [string] } [EOL] ICON = [string] [EOL] [EOL] ATTR_VALUE = [string] [EOL] [EOL] [EOL] def exactly_two_period_keys ( conf ) : [EOL] [docstring] [EOL] if sum ( param in conf for param in CONF_PERIOD_KEYS ) != [number] : [EOL] raise vol . Invalid ( [string] [string] ) [EOL] return conf [EOL] [EOL] [EOL] PLATFORM_SCHEMA = vol . All ( PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ENTITY_ID ) : cv . entity_id , vol . Required ( CONF_STATE ) : cv . string , vol . Optional ( CONF_START ) : cv . template , vol . Optional ( CONF_END ) : cv . template , vol . Optional ( CONF_DURATION ) : cv . time_period , vol . Optional ( CONF_TYPE , default = CONF_TYPE_TIME ) : vol . In ( CONF_TYPE_KEYS ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) , exactly_two_period_keys ) [EOL] [EOL] [EOL] [comment] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] entity_id = config . get ( CONF_ENTITY_ID ) [EOL] entity_state = config . get ( CONF_STATE ) [EOL] start = config . get ( CONF_START ) [EOL] end = config . get ( CONF_END ) [EOL] duration = config . get ( CONF_DURATION ) [EOL] sensor_type = config . get ( CONF_TYPE ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] for template in [ start , end ] : [EOL] if template is not None : [EOL] template . hass = hass [EOL] [EOL] add_entities ( [ HistoryStatsSensor ( hass , entity_id , entity_state , start , end , duration , sensor_type , name ) ] ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class HistoryStatsSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , entity_id , entity_state , start , end , duration , sensor_type , name ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] [EOL] self . _entity_id = entity_id [EOL] self . _entity_state = entity_state [EOL] self . _duration = duration [EOL] self . _start = start [EOL] self . _end = end [EOL] self . _type = sensor_type [EOL] self . _name = name [EOL] self . _unit_of_measurement = UNITS [ sensor_type ] [EOL] [EOL] self . _period = ( datetime . datetime . now ( ) , datetime . datetime . now ( ) ) [EOL] self . value = None [EOL] self . count = None [EOL] [EOL] def force_refresh ( * args ) : [EOL] [docstring] [EOL] self . schedule_update_ha_state ( True ) [EOL] [EOL] [comment] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , force_refresh ) [EOL] [EOL] [comment] [EOL] track_state_change ( hass , entity_id , force_refresh ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . value is None or self . count is None : [EOL] return None [EOL] [EOL] if self . _type == CONF_TYPE_TIME : [EOL] return round ( self . value , [number] ) [EOL] [EOL] if self . _type == CONF_TYPE_RATIO : [EOL] return HistoryStatsHelper . pretty_ratio ( self . value , self . _period ) [EOL] [EOL] if self . _type == CONF_TYPE_COUNT : [EOL] return self . count [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . value is None : [EOL] return { } [EOL] [EOL] hsh = HistoryStatsHelper [EOL] return { ATTR_VALUE : hsh . pretty_duration ( self . value ) , } [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] p_start , p_end = self . _period [EOL] [EOL] [comment] [EOL] self . update_period ( ) [EOL] start , end = self . _period [EOL] [EOL] [comment] [EOL] start = dt_util . as_utc ( start ) [EOL] end = dt_util . as_utc ( end ) [EOL] p_start = dt_util . as_utc ( p_start ) [EOL] p_end = dt_util . as_utc ( p_end ) [EOL] now = datetime . datetime . now ( ) [EOL] [EOL] [comment] [EOL] start_timestamp = math . floor ( dt_util . as_timestamp ( start ) ) [EOL] end_timestamp = math . floor ( dt_util . as_timestamp ( end ) ) [EOL] p_start_timestamp = math . floor ( dt_util . as_timestamp ( p_start ) ) [EOL] p_end_timestamp = math . floor ( dt_util . as_timestamp ( p_end ) ) [EOL] now_timestamp = math . floor ( dt_util . as_timestamp ( now ) ) [EOL] [EOL] [comment] [EOL] if start_timestamp == p_start_timestamp and end_timestamp == p_end_timestamp and end_timestamp <= now_timestamp : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] history_list = history . state_changes_during_period ( self . hass , start , end , str ( self . _entity_id ) ) [EOL] [EOL] if self . _entity_id not in history_list . keys ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] last_state = history . get_state ( self . hass , start , self . _entity_id ) [EOL] last_state = ( last_state is not None and last_state == self . _entity_state ) [EOL] last_time = start_timestamp [EOL] elapsed = [number] [EOL] count = [number] [EOL] [EOL] [comment] [EOL] for item in history_list . get ( self . _entity_id ) : [EOL] current_state = item . state == self . _entity_state [EOL] current_time = item . last_changed . timestamp ( ) [EOL] [EOL] if last_state : [EOL] elapsed += current_time - last_time [EOL] if current_state and not last_state : [EOL] count += [number] [EOL] [EOL] last_state = current_state [EOL] last_time = current_time [EOL] [EOL] [comment] [EOL] if last_state : [EOL] measure_end = min ( end_timestamp , now_timestamp ) [EOL] elapsed += measure_end - last_time [EOL] [EOL] [comment] [EOL] self . value = elapsed / [number] [EOL] [EOL] [comment] [EOL] self . count = count [EOL] [EOL] def update_period ( self ) : [EOL] [docstring] [EOL] start = None [EOL] end = None [EOL] [EOL] [comment] [EOL] if self . _start is not None : [EOL] try : [EOL] start_rendered = self . _start . render ( ) [EOL] except ( TemplateError , TypeError ) as ex : [EOL] HistoryStatsHelper . handle_template_exception ( ex , [string] ) [EOL] return [EOL] start = dt_util . parse_datetime ( start_rendered ) [EOL] if start is None : [EOL] try : [EOL] start = dt_util . as_local ( dt_util . utc_from_timestamp ( math . floor ( float ( start_rendered ) ) ) ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] if self . _end is not None : [EOL] try : [EOL] end_rendered = self . _end . render ( ) [EOL] except ( TemplateError , TypeError ) as ex : [EOL] HistoryStatsHelper . handle_template_exception ( ex , [string] ) [EOL] return [EOL] end = dt_util . parse_datetime ( end_rendered ) [EOL] if end is None : [EOL] try : [EOL] end = dt_util . as_local ( dt_util . utc_from_timestamp ( math . floor ( float ( end_rendered ) ) ) ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] if start is None : [EOL] start = end - self . _duration [EOL] if end is None : [EOL] end = start + self . _duration [EOL] [EOL] self . _period = start , end [EOL] [EOL] [EOL] class HistoryStatsHelper : [EOL] [docstring] [EOL] [EOL] @ staticmethod def pretty_duration ( hours ) : [EOL] [docstring] [EOL] seconds = int ( [number] * hours ) [EOL] days , seconds = divmod ( seconds , [number] ) [EOL] hours , seconds = divmod ( seconds , [number] ) [EOL] minutes , seconds = divmod ( seconds , [number] ) [EOL] if days > [number] : [EOL] return [string] % ( days , hours , minutes ) [EOL] if hours > [number] : [EOL] return [string] % ( hours , minutes ) [EOL] return [string] % minutes [EOL] [EOL] @ staticmethod def pretty_ratio ( value , period ) : [EOL] [docstring] [EOL] if len ( period ) != [number] or period [ [number] ] == period [ [number] ] : [EOL] return [number] [EOL] [EOL] ratio = [number] * [number] * value / ( period [ [number] ] - period [ [number] ] ) . total_seconds ( ) [EOL] return round ( ratio , [number] ) [EOL] [EOL] @ staticmethod def handle_template_exception ( ex , field ) : [EOL] [docstring] [EOL] if ex . args and ex . args [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] _LOGGER . warning ( ex ) [EOL] return [EOL] _LOGGER . error ( [string] , field ) [EOL] _LOGGER . error ( ex ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[api.homeassistant.components.sensor.history_stats.HistoryStatsHelper]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Type[api.homeassistant.components.sensor.history_stats.HistoryStatsHelper]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import statistics [EOL] from collections import deque [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_ENTITY_ID , STATE_UNKNOWN , ATTR_UNIT_OF_MEASUREMENT ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] from homeassistant . util import dt as dt_util [EOL] from homeassistant . components . recorder . util import session_scope , execute [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_AVERAGE_CHANGE = [string] [EOL] ATTR_CHANGE = [string] [EOL] ATTR_COUNT = [string] [EOL] ATTR_MAX_VALUE = [string] [EOL] ATTR_MIN_VALUE = [string] [EOL] ATTR_MEAN = [string] [EOL] ATTR_MEDIAN = [string] [EOL] ATTR_VARIANCE = [string] [EOL] ATTR_STANDARD_DEVIATION = [string] [EOL] ATTR_SAMPLING_SIZE = [string] [EOL] ATTR_TOTAL = [string] [EOL] ATTR_MAX_AGE = [string] [EOL] ATTR_MIN_AGE = [string] [EOL] [EOL] CONF_SAMPLING_SIZE = [string] [EOL] CONF_MAX_AGE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_SIZE = [number] [EOL] ICON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ENTITY_ID ) : cv . entity_id , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_SAMPLING_SIZE , default = DEFAULT_SIZE ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , vol . Optional ( CONF_MAX_AGE ) : cv . time_period } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] entity_id = config . get ( CONF_ENTITY_ID ) [EOL] name = config . get ( CONF_NAME ) [EOL] sampling_size = config . get ( CONF_SAMPLING_SIZE ) [EOL] max_age = config . get ( CONF_MAX_AGE , None ) [EOL] [EOL] async_add_entities ( [ StatisticsSensor ( hass , entity_id , name , sampling_size , max_age ) ] , True ) [EOL] return True [EOL] [EOL] [EOL] class StatisticsSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , entity_id , name , sampling_size , max_age ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _entity_id = entity_id [EOL] self . is_binary = True if self . _entity_id . split ( [string] ) [ [number] ] == [string] else False [EOL] if not self . is_binary : [EOL] self . _name = [string] . format ( name , ATTR_MEAN ) [EOL] else : [EOL] self . _name = [string] . format ( name , ATTR_COUNT ) [EOL] self . _sampling_size = sampling_size [EOL] self . _max_age = max_age [EOL] self . _unit_of_measurement = None [EOL] self . states = deque ( maxlen = self . _sampling_size ) [EOL] if self . _max_age is not None : [EOL] self . ages = deque ( maxlen = self . _sampling_size ) [EOL] [EOL] self . median = self . mean = self . variance = self . stdev = [number] [EOL] self . min = self . max = self . total = self . count = [number] [EOL] self . average_change = self . change = [number] [EOL] self . max_age = self . min_age = [number] [EOL] [EOL] if [string] in self . _hass . config . components : [EOL] [comment] [EOL] hass . async_add_job ( self . _initialize_from_database ) [EOL] [EOL] @ callback def async_stats_sensor_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] self . _unit_of_measurement = new_state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] [EOL] self . _add_state_to_queue ( new_state ) [EOL] [EOL] hass . async_add_job ( self . async_update_ha_state , True ) [EOL] [EOL] async_track_state_change ( hass , entity_id , async_stats_sensor_state_listener ) [EOL] [EOL] def _add_state_to_queue ( self , new_state ) : [EOL] try : [EOL] self . states . append ( float ( new_state . state ) ) [EOL] if self . _max_age is not None : [EOL] self . ages . append ( new_state . last_updated ) [EOL] self . count = self . count + [number] [EOL] except ValueError : [EOL] self . count = self . count + [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . mean if not self . is_binary else self . count [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement if not self . is_binary else None [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if not self . is_binary : [EOL] state = { ATTR_MEAN : self . mean , ATTR_COUNT : self . count , ATTR_MAX_VALUE : self . max , ATTR_MEDIAN : self . median , ATTR_MIN_VALUE : self . min , ATTR_SAMPLING_SIZE : self . _sampling_size , ATTR_STANDARD_DEVIATION : self . stdev , ATTR_TOTAL : self . total , ATTR_VARIANCE : self . variance , ATTR_CHANGE : self . change , ATTR_AVERAGE_CHANGE : self . average_change , } [EOL] [comment] [EOL] if self . _max_age : [EOL] state . update ( { ATTR_MAX_AGE : self . max_age , ATTR_MIN_AGE : self . min_age , } ) [EOL] return state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def _purge_old ( self ) : [EOL] [docstring] [EOL] now = dt_util . utcnow ( ) [EOL] [EOL] while self . ages and ( now - self . ages [ [number] ] ) > self . _max_age : [EOL] self . ages . popleft ( ) [EOL] self . states . popleft ( ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] if self . _max_age is not None : [EOL] self . _purge_old ( ) [EOL] [EOL] if not self . is_binary : [EOL] try : [comment] [EOL] self . mean = round ( statistics . mean ( self . states ) , [number] ) [EOL] self . median = round ( statistics . median ( self . states ) , [number] ) [EOL] except statistics . StatisticsError as err : [EOL] _LOGGER . error ( err ) [EOL] self . mean = self . median = STATE_UNKNOWN [EOL] [EOL] try : [comment] [EOL] self . stdev = round ( statistics . stdev ( self . states ) , [number] ) [EOL] self . variance = round ( statistics . variance ( self . states ) , [number] ) [EOL] except statistics . StatisticsError as err : [EOL] _LOGGER . error ( err ) [EOL] self . stdev = self . variance = STATE_UNKNOWN [EOL] [EOL] if self . states : [EOL] self . count = len ( self . states ) [EOL] self . total = round ( sum ( self . states ) , [number] ) [EOL] self . min = min ( self . states ) [EOL] self . max = max ( self . states ) [EOL] self . change = self . states [ - [number] ] - self . states [ [number] ] [EOL] self . average_change = self . change [EOL] if len ( self . states ) > [number] : [EOL] self . average_change /= len ( self . states ) - [number] [EOL] if self . _max_age is not None : [EOL] self . max_age = max ( self . ages ) [EOL] self . min_age = min ( self . ages ) [EOL] else : [EOL] self . min = self . max = self . total = STATE_UNKNOWN [EOL] self . average_change = self . change = STATE_UNKNOWN [EOL] [EOL] @ asyncio . coroutine def _initialize_from_database ( self ) : [EOL] [docstring] [EOL] from homeassistant . components . recorder . models import States [EOL] _LOGGER . debug ( [string] , self . entity_id ) [EOL] [EOL] with session_scope ( hass = self . _hass ) as session : [EOL] query = session . query ( States ) . filter ( States . entity_id == self . _entity_id . lower ( ) ) . order_by ( States . last_updated . desc ( ) ) . limit ( self . _sampling_size ) [EOL] states = execute ( query ) [EOL] [EOL] for state in reversed ( states ) : [EOL] self . _add_state_to_queue ( state ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any , List , Generator [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_NAME = [string] [EOL] CONF_HOSTNAME = [string] [EOL] CONF_RESOLVER = [string] [EOL] CONF_RESOLVER_IPV6 = [string] [EOL] CONF_IPV6 = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_HOSTNAME = [string] [EOL] DEFAULT_RESOLVER = [string] [EOL] DEFAULT_RESOLVER_IPV6 = [string] [EOL] DEFAULT_IPV6 = False [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_HOSTNAME , default = DEFAULT_HOSTNAME ) : cv . string , vol . Optional ( CONF_RESOLVER , default = DEFAULT_RESOLVER ) : cv . string , vol . Optional ( CONF_RESOLVER_IPV6 , default = DEFAULT_RESOLVER_IPV6 ) : cv . string , vol . Optional ( CONF_IPV6 , default = DEFAULT_IPV6 ) : cv . boolean , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] hostname = config . get ( CONF_HOSTNAME ) [EOL] name = config . get ( CONF_NAME ) [EOL] if not name : [EOL] if hostname == DEFAULT_HOSTNAME : [EOL] name = DEFAULT_NAME [EOL] else : [EOL] name = hostname [EOL] ipv6 = config . get ( CONF_IPV6 ) [EOL] if ipv6 : [EOL] resolver = config . get ( CONF_RESOLVER_IPV6 ) [EOL] else : [EOL] resolver = config . get ( CONF_RESOLVER ) [EOL] [EOL] async_add_devices ( [ WanIpSensor ( hass , name , hostname , resolver , ipv6 ) ] , True ) [EOL] [EOL] [EOL] class WanIpSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , hostname , resolver , ipv6 ) : [EOL] [docstring] [EOL] import aiodns [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . hostname = hostname [EOL] self . resolver = aiodns . DNSResolver ( loop = self . hass . loop ) [EOL] self . resolver . nameservers = [ resolver ] [EOL] self . querytype = [string] if ipv6 else [string] [EOL] self . _state = STATE_UNKNOWN [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] response = yield from self . resolver . query ( self . hostname , self . querytype ) [EOL] if response : [EOL] self . _state = response [ [number] ] . host [EOL] else : [EOL] self . _state = STATE_UNKNOWN [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . components . canary import DATA_CANARY [EOL] from homeassistant . const import TEMP_CELSIUS [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SENSOR_VALUE_PRECISION = [number] [EOL] ATTR_AIR_QUALITY = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] SENSOR_TYPES = [ [ [string] , TEMP_CELSIUS , [string] , [ [string] ] ] , [ [string] , [string] , [string] , [ [string] ] ] , [ [string] , None , [string] , [ [string] ] ] , [ [string] , [string] , [string] , [ [string] ] ] , [ [string] , [string] , [string] , [ [string] ] ] , ] [EOL] [EOL] STATE_AIR_QUALITY_NORMAL = [string] [EOL] STATE_AIR_QUALITY_ABNORMAL = [string] [EOL] STATE_AIR_QUALITY_VERY_ABNORMAL = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] data = hass . data [ DATA_CANARY ] [EOL] devices = [ ] [EOL] [EOL] for location in data . locations : [EOL] for device in location . devices : [EOL] if device . is_online : [EOL] device_type = device . device_type [EOL] for sensor_type in SENSOR_TYPES : [EOL] if device_type . get ( [string] ) in sensor_type [ [number] ] : [EOL] devices . append ( CanarySensor ( data , sensor_type , location , device ) ) [EOL] [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class CanarySensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , sensor_type , location , device ) : [EOL] [docstring] [EOL] self . _data = data [EOL] self . _sensor_type = sensor_type [EOL] self . _device_id = device . device_id [EOL] self . _sensor_value = None [EOL] [EOL] sensor_type_name = sensor_type [ [number] ] . replace ( [string] , [string] ) . title ( ) [EOL] self . _name = [string] . format ( location . name , device . name , sensor_type_name ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _sensor_value [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _device_id , self . _sensor_type [ [number] ] ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _sensor_type [ [number] ] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . state is not None and self . _sensor_type [ [number] ] == [string] : [EOL] return icon_for_battery_level ( battery_level = self . state ) [EOL] [EOL] return self . _sensor_type [ [number] ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _sensor_type [ [number] ] == [string] \ [EOL] and self . _sensor_value is not None : [EOL] air_quality = None [EOL] if self . _sensor_value <= [number] : [EOL] air_quality = STATE_AIR_QUALITY_VERY_ABNORMAL [EOL] elif self . _sensor_value <= [number] : [EOL] air_quality = STATE_AIR_QUALITY_ABNORMAL [EOL] elif self . _sensor_value <= [number] : [EOL] air_quality = STATE_AIR_QUALITY_NORMAL [EOL] [EOL] return { ATTR_AIR_QUALITY : air_quality } [EOL] [EOL] return None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _data . update ( ) [EOL] [EOL] from canary . api import SensorType [EOL] canary_sensor_type = None [EOL] if self . _sensor_type [ [number] ] == [string] : [EOL] canary_sensor_type = SensorType . AIR_QUALITY [EOL] elif self . _sensor_type [ [number] ] == [string] : [EOL] canary_sensor_type = SensorType . TEMPERATURE [EOL] elif self . _sensor_type [ [number] ] == [string] : [EOL] canary_sensor_type = SensorType . HUMIDITY [EOL] elif self . _sensor_type [ [number] ] == [string] : [EOL] canary_sensor_type = SensorType . WIFI [EOL] elif self . _sensor_type [ [number] ] == [string] : [EOL] canary_sensor_type = SensorType . BATTERY [EOL] [EOL] value = self . _data . get_reading ( self . _device_id , canary_sensor_type ) [EOL] [EOL] if value is not None : [EOL] self . _sensor_value = round ( float ( value ) , SENSOR_VALUE_PRECISION ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import logging [EOL] import api [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . homematicip_cloud import ( HMIPC_HAPID , HomematicipGenericDevice ) [EOL] from homeassistant . components . homematicip_cloud import DOMAIN as HMIPC_DOMAIN [EOL] from homeassistant . const import ( DEVICE_CLASS_HUMIDITY , DEVICE_CLASS_ILLUMINANCE , DEVICE_CLASS_TEMPERATURE , TEMP_CELSIUS ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ATTR_VALVE_STATE = [string] [EOL] ATTR_VALVE_POSITION = [string] [EOL] ATTR_TEMPERATURE = [string] [EOL] ATTR_TEMPERATURE_OFFSET = [string] [EOL] ATTR_HUMIDITY = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] from homematicip . device import ( HeatingThermostat , TemperatureHumiditySensorWithoutDisplay , TemperatureHumiditySensorDisplay , MotionDetectorIndoor ) [EOL] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ HomematicipAccesspointStatus ( home ) ] [EOL] for device in home . devices : [EOL] if isinstance ( device , HeatingThermostat ) : [EOL] devices . append ( HomematicipHeatingThermostat ( home , device ) ) [EOL] if isinstance ( device , ( TemperatureHumiditySensorDisplay , TemperatureHumiditySensorWithoutDisplay ) ) : [EOL] devices . append ( HomematicipTemperatureSensor ( home , device ) ) [EOL] devices . append ( HomematicipHumiditySensor ( home , device ) ) [EOL] if isinstance ( device , MotionDetectorIndoor ) : [EOL] devices . append ( HomematicipIlluminanceSensor ( home , device ) ) [EOL] [EOL] if devices : [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class HomematicipAccesspointStatus ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , home ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _home . dutyCycle [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _home . connected [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipHeatingThermostat ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] from homematicip . base . enums import ValveState [EOL] [EOL] if super ( ) . icon : [EOL] return super ( ) . icon [EOL] if self . _device . valveState != ValveState . ADAPTION_DONE : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] from homematicip . base . enums import ValveState [EOL] [EOL] if self . _device . valveState != ValveState . ADAPTION_DONE : [EOL] return self . _device . valveState [EOL] return round ( self . _device . valvePosition * [number] ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipHumiditySensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_HUMIDITY [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . humidity [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipTemperatureSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_TEMPERATURE [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . actualTemperature [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] [EOL] class HomematicipIlluminanceSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_ILLUMINANCE [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . illumination [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import api [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_UNIT_SYSTEM_IMPERIAL , CONF_UNIT_SYSTEM_METRIC , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] CONF_ELEC = [string] [EOL] CONF_GAS = [string] [EOL] [EOL] CONF_ELEC_SERIAL = [string] [EOL] CONF_ELEC_SECRET = [string] [EOL] [EOL] CONF_GAS_SERIAL = [string] [EOL] CONF_GAS_SECRET = [string] [EOL] CONF_GAS_CALORIFIC = [string] [EOL] [EOL] CONF_GAS_TYPE = [string] [EOL] [EOL] DEFAULT_CALORIFIC = [number] [EOL] DEFAULT_UNIT = [string] [EOL] [EOL] ELEC_SCHEMA = vol . Schema ( { vol . Required ( CONF_ELEC_SERIAL ) : cv . string , vol . Required ( CONF_ELEC_SECRET ) : cv . string , } ) [EOL] [EOL] GAS_TYPE_SCHEMA = vol . In ( [ CONF_UNIT_SYSTEM_METRIC , CONF_UNIT_SYSTEM_IMPERIAL ] ) [EOL] [EOL] GAS_SCHEMA = vol . Schema ( { vol . Required ( CONF_GAS_SERIAL ) : cv . string , vol . Required ( CONF_GAS_SECRET ) : cv . string , vol . Optional ( CONF_GAS_TYPE , default = CONF_UNIT_SYSTEM_METRIC ) : GAS_TYPE_SCHEMA , vol . Optional ( CONF_GAS_CALORIFIC , default = DEFAULT_CALORIFIC ) : vol . Coerce ( float ) , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ELEC ) : ELEC_SCHEMA , vol . Optional ( CONF_GAS ) : GAS_SCHEMA , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import pyloopenergy [EOL] [EOL] elec_config = config . get ( CONF_ELEC ) [EOL] gas_config = config . get ( CONF_GAS , { } ) [EOL] [EOL] controller = pyloopenergy . LoopEnergy ( elec_config . get ( CONF_ELEC_SERIAL ) , elec_config . get ( CONF_ELEC_SECRET ) , gas_config . get ( CONF_GAS_SERIAL ) , gas_config . get ( CONF_GAS_SECRET ) , gas_config . get ( CONF_GAS_TYPE ) , gas_config . get ( CONF_GAS_CALORIFIC ) ) [EOL] [EOL] def stop_loopenergy ( event ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] controller . terminate ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_loopenergy ) [EOL] [EOL] sensors = [ LoopEnergyElec ( controller ) ] [EOL] [EOL] if gas_config . get ( CONF_GAS_SERIAL ) : [EOL] sensors . append ( LoopEnergyGas ( controller ) ) [EOL] [EOL] add_entities ( sensors ) [EOL] [EOL] [EOL] class LoopEnergyDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , controller ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . _unit_of_measurement = DEFAULT_UNIT [EOL] self . _controller = controller [EOL] self . _name = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def _callback ( self ) : [EOL] self . schedule_update_ha_state ( True ) [EOL] [EOL] [EOL] class LoopEnergyElec ( LoopEnergyDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , controller ) : [EOL] [docstring] [EOL] super ( LoopEnergyElec , self ) . __init__ ( controller ) [EOL] self . _name = [string] [EOL] self . _controller . subscribe_elecricity ( self . _callback ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _state = round ( self . _controller . electricity_useage , [number] ) [EOL] [EOL] [EOL] class LoopEnergyGas ( LoopEnergyDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , controller ) : [EOL] [docstring] [EOL] super ( LoopEnergyGas , self ) . __init__ ( controller ) [EOL] self . _name = [string] [EOL] self . _controller . subscribe_gas ( self . _callback ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _state = round ( self . _controller . gas_useage , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( ClimateDevice , PLATFORM_SCHEMA , SUPPORT_TARGET_TEMPERATURE ) [EOL] from homeassistant . const import CONF_HOST , TEMP_CELSIUS , ATTR_TEMPERATURE [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_FLAGS = (SUPPORT_TARGET_TEMPERATURE) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pytouchline import PyTouchline [EOL] host = config [ CONF_HOST ] [EOL] py_touchline = PyTouchline ( ) [EOL] number_of_devices = int ( py_touchline . get_number_of_devices ( host ) ) [EOL] devices = [ ] [EOL] for device_id in range ( [number] , number_of_devices ) : [EOL] devices . append ( Touchline ( PyTouchline ( device_id ) ) ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class Touchline ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , touchline_thermostat ) : [EOL] [docstring] [EOL] self . unit = touchline_thermostat [EOL] self . _name = None [EOL] self . _current_temperature = None [EOL] self . _target_temperature = None [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . unit . update ( ) [EOL] self . _name = self . unit . get_name ( ) [EOL] self . _current_temperature = self . unit . get_current_temperature ( ) [EOL] self . _target_temperature = self . unit . get_target_temperature ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temperature [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] if kwargs . get ( ATTR_TEMPERATURE ) is not None : [EOL] self . _target_temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] self . unit . set_target_temperature ( self . _target_temperature ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . climate import ( ClimateDevice , ATTR_TARGET_TEMP_HIGH , ATTR_TARGET_TEMP_LOW , SUPPORT_TARGET_TEMPERATURE , SUPPORT_TARGET_HUMIDITY , SUPPORT_TARGET_HUMIDITY_LOW , SUPPORT_TARGET_HUMIDITY_HIGH , SUPPORT_AWAY_MODE , SUPPORT_HOLD_MODE , SUPPORT_FAN_MODE , SUPPORT_OPERATION_MODE , SUPPORT_AUX_HEAT , SUPPORT_SWING_MODE , SUPPORT_TARGET_TEMPERATURE_HIGH , SUPPORT_TARGET_TEMPERATURE_LOW , SUPPORT_ON_OFF ) [EOL] from homeassistant . const import TEMP_CELSIUS , TEMP_FAHRENHEIT , ATTR_TEMPERATURE [EOL] [EOL] SUPPORT_FLAGS = SUPPORT_TARGET_HUMIDITY_LOW | SUPPORT_TARGET_HUMIDITY_HIGH [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ DemoClimate ( [string] , [number] , TEMP_FAHRENHEIT , None , None , [number] , None , None , None , None , [string] , None , None , None , True ) , DemoClimate ( [string] , [number] , TEMP_CELSIUS , True , None , [number] , [string] , [number] , [number] , [string] , [string] , False , None , None , None ) , DemoClimate ( [string] , None , TEMP_CELSIUS , None , [string] , [number] , [string] , None , None , [string] , [string] , None , [number] , [number] , None ) ] ) [EOL] [EOL] [EOL] class DemoClimate ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , target_temperature , unit_of_measurement , away , hold , current_temperature , current_fan_mode , target_humidity , current_humidity , current_swing_mode , current_operation , aux , target_temp_high , target_temp_low , is_on ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _support_flags = SUPPORT_FLAGS [EOL] if target_temperature is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_TARGET_TEMPERATURE [EOL] if away is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_AWAY_MODE [EOL] if hold is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_HOLD_MODE [EOL] if current_fan_mode is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_FAN_MODE [EOL] if target_humidity is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_TARGET_HUMIDITY [EOL] if current_swing_mode is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_SWING_MODE [EOL] if current_operation is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_OPERATION_MODE [EOL] if aux is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_AUX_HEAT [EOL] if target_temp_high is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_TARGET_TEMPERATURE_HIGH [EOL] if target_temp_low is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_TARGET_TEMPERATURE_LOW [EOL] if is_on is not None : [EOL] self . _support_flags = self . _support_flags | SUPPORT_ON_OFF [EOL] self . _target_temperature = target_temperature [EOL] self . _target_humidity = target_humidity [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _away = away [EOL] self . _hold = hold [EOL] self . _current_temperature = current_temperature [EOL] self . _current_humidity = current_humidity [EOL] self . _current_fan_mode = current_fan_mode [EOL] self . _current_operation = current_operation [EOL] self . _aux = aux [EOL] self . _current_swing_mode = current_swing_mode [EOL] self . _fan_list = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . _operation_list = [ [string] , [string] , [string] , [string] ] [EOL] self . _swing_list = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . _target_temperature_high = target_temp_high [EOL] self . _target_temperature_low = target_temp_low [EOL] self . _on = is_on [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _support_flags [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temperature [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature [EOL] [EOL] @ property def target_temperature_high ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature_high [EOL] [EOL] @ property def target_temperature_low ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature_low [EOL] [EOL] @ property def current_humidity ( self ) : [EOL] [docstring] [EOL] return self . _current_humidity [EOL] [EOL] @ property def target_humidity ( self ) : [EOL] [docstring] [EOL] return self . _target_humidity [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] return self . _current_operation [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return self . _operation_list [EOL] [EOL] @ property def is_away_mode_on ( self ) : [EOL] [docstring] [EOL] return self . _away [EOL] [EOL] @ property def current_hold_mode ( self ) : [EOL] [docstring] [EOL] return self . _hold [EOL] [EOL] @ property def is_aux_heat_on ( self ) : [EOL] [docstring] [EOL] return self . _aux [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _on [EOL] [EOL] @ property def current_fan_mode ( self ) : [EOL] [docstring] [EOL] return self . _current_fan_mode [EOL] [EOL] @ property def fan_list ( self ) : [EOL] [docstring] [EOL] return self . _fan_list [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] if kwargs . get ( ATTR_TEMPERATURE ) is not None : [EOL] self . _target_temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if kwargs . get ( ATTR_TARGET_TEMP_HIGH ) is not None and kwargs . get ( ATTR_TARGET_TEMP_LOW ) is not None : [EOL] self . _target_temperature_high = kwargs . get ( ATTR_TARGET_TEMP_HIGH ) [EOL] self . _target_temperature_low = kwargs . get ( ATTR_TARGET_TEMP_LOW ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_humidity ( self , humidity ) : [EOL] [docstring] [EOL] self . _target_humidity = humidity [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_swing_mode ( self , swing_mode ) : [EOL] [docstring] [EOL] self . _current_swing_mode = swing_mode [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_fan_mode ( self , fan_mode ) : [EOL] [docstring] [EOL] self . _current_fan_mode = fan_mode [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] self . _current_operation = operation_mode [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def current_swing_mode ( self ) : [EOL] [docstring] [EOL] return self . _current_swing_mode [EOL] [EOL] @ property def swing_list ( self ) : [EOL] [docstring] [EOL] return self . _swing_list [EOL] [EOL] def turn_away_mode_on ( self ) : [EOL] [docstring] [EOL] self . _away = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_away_mode_off ( self ) : [EOL] [docstring] [EOL] self . _away = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_hold_mode ( self , hold_mode ) : [EOL] [docstring] [EOL] self . _hold = hold_mode [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_aux_heat_on ( self ) : [EOL] [docstring] [EOL] self . _aux = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_aux_heat_off ( self ) : [EOL] [docstring] [EOL] self . _aux = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _on = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _on = False [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . homematicip_cloud import ( HMIPC_HAPID , HomematicipGenericDevice ) [EOL] from homeassistant . components . homematicip_cloud import DOMAIN as HMIPC_DOMAIN [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ENERGY_COUNTER = [string] [EOL] ATTR_POWER_CONSUMPTION = [string] [EOL] ATTR_PROFILE_MODE = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] from homematicip . aio . device import AsyncBrandSwitchMeasuring , AsyncDimmer [EOL] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ ] [EOL] for device in home . devices : [EOL] if isinstance ( device , AsyncBrandSwitchMeasuring ) : [EOL] devices . append ( HomematicipLightMeasuring ( home , device ) ) [EOL] elif isinstance ( device , AsyncDimmer ) : [EOL] devices . append ( HomematicipDimmer ( home , device ) ) [EOL] [EOL] if devices : [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class HomematicipLight ( HomematicipGenericDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . on [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . _device . turn_on ( ) [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . _device . turn_off ( ) [EOL] [EOL] [EOL] class HomematicipLightMeasuring ( HomematicipLight ) : [EOL] [docstring] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = super ( ) . device_state_attributes [EOL] if self . _device . currentPowerConsumption > [number] : [EOL] attr . update ( { ATTR_POWER_CONSUMPTION : round ( self . _device . currentPowerConsumption , [number] ) } ) [EOL] attr . update ( { ATTR_ENERGY_COUNTER : round ( self . _device . energyCounter , [number] ) } ) [EOL] return attr [EOL] [EOL] [EOL] class HomematicipDimmer ( HomematicipGenericDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . dimLevel != [number] [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return int ( self . _device . dimLevel * [number] ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] await self . _device . set_dim_level ( kwargs [ ATTR_BRIGHTNESS ] / [number] ) [EOL] else : [EOL] await self . _device . set_dim_level ( [number] ) [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . _device . set_dim_level ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import voluptuous as vol [EOL] from homeassistant . components . light import Light , ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . components . ads import DATA_ADS , CONF_ADS_VAR , CONF_ADS_VAR_BRIGHTNESS [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] DEPENDENCIES = [ [string] ] [EOL] DEFAULT_NAME = [string] [EOL] CONF_ADSVAR_BRIGHTNESS = [string] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ADS_VAR ) : cv . string , vol . Optional ( CONF_ADS_VAR_BRIGHTNESS ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] ads_hub = hass . data . get ( DATA_ADS ) [EOL] [EOL] ads_var_enable = config . get ( CONF_ADS_VAR ) [EOL] ads_var_brightness = config . get ( CONF_ADS_VAR_BRIGHTNESS ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] add_entities ( [ AdsLight ( ads_hub , ads_var_enable , ads_var_brightness , name ) ] , True ) [EOL] [EOL] [EOL] class AdsLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ads_hub , ads_var_enable , ads_var_brightness , name ) : [EOL] [docstring] [EOL] self . _ads_hub = ads_hub [EOL] self . _on_state = False [EOL] self . _brightness = None [EOL] self . _name = name [EOL] self . ads_var_enable = ads_var_enable [EOL] self . ads_var_brightness = ads_var_brightness [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def update_on_state ( name , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , name , value ) [EOL] self . _on_state = value [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def update_brightness ( name , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , name , value ) [EOL] self . _brightness = value [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] self . hass . async_add_job ( self . _ads_hub . add_device_notification , self . ads_var_enable , self . _ads_hub . PLCTYPE_BOOL , update_on_state ) [EOL] self . hass . async_add_job ( self . _ads_hub . add_device_notification , self . ads_var_brightness , self . _ads_hub . PLCTYPE_INT , update_brightness ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _on_state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . ads_var_brightness is not None : [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS ) [EOL] self . _ads_hub . write_by_name ( self . ads_var_enable , True , self . _ads_hub . PLCTYPE_BOOL ) [EOL] [EOL] if self . ads_var_brightness is not None and brightness is not None : [EOL] self . _ads_hub . write_by_name ( self . ads_var_brightness , brightness , self . _ads_hub . PLCTYPE_UINT ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _ads_hub . write_by_name ( self . ads_var_enable , False , self . _ads_hub . PLCTYPE_BOOL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , ENTITY_ID_FORMAT , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_COLOR , Light ) [EOL] [EOL] from homeassistant . components . tuya import DATA_TUYA , TuyaDevice [EOL] from homeassistant . util import color as colorutil [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] tuya = hass . data [ DATA_TUYA ] [EOL] dev_ids = discovery_info . get ( [string] ) [EOL] devices = [ ] [EOL] for dev_id in dev_ids : [EOL] device = tuya . get_device_by_id ( dev_id ) [EOL] if device is None : [EOL] continue [EOL] devices . append ( TuyaLight ( device ) ) [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class TuyaLight ( TuyaDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tuya ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( tuya ) [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( tuya . object_id ( ) ) [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . tuya . brightness ( ) [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . tuya . hs_color ( ) [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] color_temp = self . tuya . color_temp ( ) [EOL] if color_temp is None : [EOL] return None [EOL] return colorutil . color_temperature_kelvin_to_mired ( color_temp ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . tuya . state ( ) [EOL] [EOL] @ property def min_mireds ( self ) : [EOL] [docstring] [EOL] return colorutil . color_temperature_kelvin_to_mired ( self . tuya . min_color_temp ( ) ) [EOL] [EOL] @ property def max_mireds ( self ) : [EOL] [docstring] [EOL] return colorutil . color_temperature_kelvin_to_mired ( self . tuya . max_color_temp ( ) ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ( ATTR_BRIGHTNESS not in kwargs [EOL] and ATTR_HS_COLOR not in kwargs [EOL] and ATTR_COLOR_TEMP not in kwargs ) : [EOL] self . tuya . turn_on ( ) [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . tuya . set_brightness ( kwargs [ ATTR_BRIGHTNESS ] ) [EOL] if ATTR_HS_COLOR in kwargs : [EOL] self . tuya . set_color ( kwargs [ ATTR_HS_COLOR ] ) [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] color_temp = colorutil . color_temperature_mired_to_kelvin ( kwargs [ ATTR_COLOR_TEMP ] ) [EOL] self . tuya . set_color_temp ( color_temp ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . tuya . turn_off ( ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supports = SUPPORT_BRIGHTNESS [EOL] if self . tuya . support_color ( ) : [EOL] supports = supports | SUPPORT_COLOR [EOL] if self . tuya . support_color_temp ( ) : [EOL] supports = supports | SUPPORT_COLOR_TEMP [EOL] return supports [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
from typing import List , Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . homekit_controller import ( HomeKitEntity , KNOWN_ACCESSORIES ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_HS_COLOR , ATTR_COLOR_TEMP , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , SUPPORT_COLOR_TEMP , Light ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] accessory = hass . data [ KNOWN_ACCESSORIES ] [ discovery_info [ [string] ] ] [EOL] add_entities ( [ HomeKitLight ( accessory , discovery_info ) ] , True ) [EOL] [EOL] [EOL] class HomeKitLight ( HomeKitEntity , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args ) [EOL] self . _on = None [EOL] self . _brightness = None [EOL] self . _color_temperature = None [EOL] self . _hue = None [EOL] self . _saturation = None [EOL] [EOL] def update_characteristics ( self , characteristics ) : [EOL] [docstring] [EOL] [comment] [EOL] import homekit [EOL] [EOL] for characteristic in characteristics : [EOL] ctype = characteristic [ [string] ] [EOL] ctype = homekit . CharacteristicsTypes . get_short ( ctype ) [EOL] if ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _on = characteristic [ [string] ] [EOL] elif ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _features |= SUPPORT_BRIGHTNESS [EOL] self . _brightness = characteristic [ [string] ] [EOL] elif ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _features |= SUPPORT_COLOR_TEMP [EOL] self . _color_temperature = characteristic [ [string] ] [EOL] elif ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _features |= SUPPORT_COLOR [EOL] self . _hue = characteristic [ [string] ] [EOL] elif ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _features |= SUPPORT_COLOR [EOL] self . _saturation = characteristic [ [string] ] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _on [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] if self . _features & SUPPORT_BRIGHTNESS : [EOL] return self . _brightness * [number] / [number] [EOL] return None [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] if self . _features & SUPPORT_COLOR : [EOL] return ( self . _hue , self . _saturation ) [EOL] return None [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] if self . _features & SUPPORT_COLOR_TEMP : [EOL] return self . _color_temperature [EOL] return None [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _features [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] hs_color = kwargs . get ( ATTR_HS_COLOR ) [EOL] temperature = kwargs . get ( ATTR_COLOR_TEMP ) [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS ) [EOL] [EOL] characteristics = [ ] [EOL] if hs_color is not None : [EOL] characteristics . append ( { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : hs_color [ [number] ] } ) [EOL] characteristics . append ( { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : hs_color [ [number] ] } ) [EOL] if brightness is not None : [EOL] characteristics . append ( { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : int ( brightness * [number] / [number] ) } ) [EOL] [EOL] if temperature is not None : [EOL] characteristics . append ( { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : int ( temperature ) } ) [EOL] characteristics . append ( { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : True } ) [EOL] self . put_characteristics ( characteristics ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] characteristics = [ { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : False } ] [EOL] self . put_characteristics ( characteristics ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import ftplib [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA [EOL] from homeassistant . components . ffmpeg import DATA_FFMPEG [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PATH , CONF_PASSWORD , CONF_PORT , CONF_USERNAME ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . aiohttp_client import async_aiohttp_proxy_stream [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_BRAND = [string] [EOL] DEFAULT_PATH = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_USERNAME = [string] [EOL] [EOL] CONF_FFMPEG_ARGUMENTS = [string] [EOL] CONF_MODEL = [string] [EOL] [EOL] MODEL_YI = [string] [EOL] MODEL_XIAOFANG = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_MODEL ) : vol . Any ( MODEL_YI , MODEL_XIAOFANG ) , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . string , vol . Optional ( CONF_PATH , default = DEFAULT_PATH ) : cv . string , vol . Optional ( CONF_USERNAME , default = DEFAULT_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_FFMPEG_ARGUMENTS ) : cv . string } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , config [ CONF_MODEL ] ) [EOL] async_add_entities ( [ XiaomiCamera ( hass , config ) ] ) [EOL] [EOL] [EOL] class XiaomiCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _extra_arguments = config . get ( CONF_FFMPEG_ARGUMENTS ) [EOL] self . _last_image = None [EOL] self . _last_url = None [EOL] self . _manager = hass . data [ DATA_FFMPEG ] [EOL] self . _name = config [ CONF_NAME ] [EOL] self . host = config [ CONF_HOST ] [EOL] self . _model = config [ CONF_MODEL ] [EOL] self . port = config [ CONF_PORT ] [EOL] self . path = config [ CONF_PATH ] [EOL] self . user = config [ CONF_USERNAME ] [EOL] self . passwd = config [ CONF_PASSWORD ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return DEFAULT_BRAND [EOL] [EOL] @ property def model ( self ) : [EOL] [docstring] [EOL] return self . _model [EOL] [EOL] def get_latest_video_url ( self ) : [EOL] [docstring] [EOL] from ftplib import FTP , error_perm [EOL] [EOL] ftp = FTP ( self . host ) [EOL] try : [EOL] ftp . login ( self . user , self . passwd ) [EOL] except error_perm as exc : [EOL] _LOGGER . error ( [string] , exc ) [EOL] return False [EOL] [EOL] try : [EOL] ftp . cwd ( self . path ) [EOL] except error_perm as exc : [EOL] _LOGGER . error ( [string] , self . path , exc ) [EOL] return False [EOL] [EOL] dirs = [ d for d in ftp . nlst ( ) if [string] not in d ] [EOL] if not dirs : [EOL] _LOGGER . warning ( [string] ) [EOL] return False [EOL] [EOL] first_dir = dirs [ - [number] ] [EOL] try : [EOL] ftp . cwd ( first_dir ) [EOL] except error_perm as exc : [EOL] _LOGGER . error ( [string] , first_dir , exc ) [EOL] return False [EOL] [EOL] if self . _model == MODEL_XIAOFANG : [EOL] dirs = [ d for d in ftp . nlst ( ) if [string] not in d ] [EOL] if not dirs : [EOL] _LOGGER . warning ( [string] ) [EOL] return False [EOL] [EOL] latest_dir = dirs [ - [number] ] [EOL] ftp . cwd ( latest_dir ) [EOL] [EOL] videos = [ v for v in ftp . nlst ( ) if [string] not in v ] [EOL] if not videos : [EOL] _LOGGER . info ( [string] , latest_dir ) [EOL] return False [EOL] [EOL] if self . _model == MODEL_XIAOFANG : [EOL] video = videos [ - [number] ] [EOL] else : [EOL] video = videos [ - [number] ] [EOL] [EOL] return [string] . format ( self . user , self . passwd , self . host , self . port , ftp . pwd ( ) , video ) [EOL] [EOL] async def async_camera_image ( self ) : [EOL] [docstring] [EOL] from haffmpeg import ImageFrame , IMAGE_JPEG [EOL] [EOL] url = await self . hass . async_add_job ( self . get_latest_video_url ) [EOL] if url != self . _last_url : [EOL] ffmpeg = ImageFrame ( self . _manager . binary , loop = self . hass . loop ) [EOL] self . _last_image = await asyncio . shield ( ffmpeg . get_image ( url , output_format = IMAGE_JPEG , extra_cmd = self . _extra_arguments ) , loop = self . hass . loop ) [EOL] self . _last_url = url [EOL] [EOL] return self . _last_image [EOL] [EOL] async def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] from haffmpeg import CameraMjpeg [EOL] [EOL] stream = CameraMjpeg ( self . _manager . binary , loop = self . hass . loop ) [EOL] await stream . open_camera ( self . _last_url , extra_cmd = self . _extra_arguments ) [EOL] [EOL] await async_aiohttp_proxy_stream ( self . hass , request , stream , [string] ) [EOL] await stream . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $ftplib.FTP$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import api [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_USERNAME , CONF_PASSWORD , CONF_URL , CONF_WHITELIST , CONF_VERIFY_SSL , CONF_TIMEOUT ) [EOL] from homeassistant . components . camera import ( Camera , PLATFORM_SCHEMA ) [EOL] from homeassistant . helpers . aiohttp_client import ( async_aiohttp_proxy_web , async_get_clientsession ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_URL ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , vol . Optional ( CONF_WHITELIST , default = [ ] ) : cv . ensure_list , vol . Optional ( CONF_VERIFY_SSL , default = True ) : cv . boolean , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] verify_ssl = config . get ( CONF_VERIFY_SSL ) [EOL] timeout = config . get ( CONF_TIMEOUT ) [EOL] [EOL] try : [EOL] from synology . surveillance_station import SurveillanceStation [EOL] surveillance = SurveillanceStation ( config . get ( CONF_URL ) , config . get ( CONF_USERNAME ) , config . get ( CONF_PASSWORD ) , verify_ssl = verify_ssl , timeout = timeout ) [EOL] except ( requests . exceptions . RequestException , ValueError ) : [EOL] _LOGGER . exception ( [string] ) [EOL] return False [EOL] [EOL] cameras = surveillance . get_all_cameras ( ) [EOL] [EOL] [comment] [EOL] devices = [ ] [EOL] for camera in cameras : [EOL] if not config . get ( CONF_WHITELIST ) : [EOL] device = SynologyCamera ( surveillance , camera . camera_id , verify_ssl ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class SynologyCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , surveillance , camera_id , verify_ssl ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _surveillance = surveillance [EOL] self . _camera_id = camera_id [EOL] self . _verify_ssl = verify_ssl [EOL] self . _camera = self . _surveillance . get_camera ( camera_id ) [EOL] self . _motion_setting = self . _surveillance . get_motion_setting ( camera_id ) [EOL] self . is_streaming = self . _camera . is_enabled [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] return self . _surveillance . get_camera_image ( self . _camera_id ) [EOL] [EOL] @ asyncio . coroutine def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] streaming_url = self . _camera . video_stream_url [EOL] [EOL] websession = async_get_clientsession ( self . hass , self . _verify_ssl ) [EOL] stream_coro = websession . get ( streaming_url ) [EOL] [EOL] yield from async_aiohttp_proxy_web ( self . hass , request , stream_coro ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _camera . name [EOL] [EOL] @ property def is_recording ( self ) : [EOL] [docstring] [EOL] return self . _camera . is_recording [EOL] [EOL] def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _surveillance . update ( ) [EOL] self . _camera = self . _surveillance . get_camera ( self . _camera . camera_id ) [EOL] self . _motion_setting = self . _surveillance . get_motion_setting ( self . _camera . camera_id ) [EOL] self . is_streaming = self . _camera . is_enabled [EOL] [EOL] @ property def motion_detection_enabled ( self ) : [EOL] [docstring] [EOL] return self . _motion_setting . is_enabled [EOL] [EOL] def enable_motion_detection ( self ) : [EOL] [docstring] [EOL] self . _surveillance . enable_motion_detection ( self . _camera_id ) [EOL] [EOL] def disable_motion_detection ( self ) : [EOL] [docstring] [EOL] self . _surveillance . disable_motion_detection ( self . _camera_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . xiaomi_aqara import ( PY_XIAOMI_GATEWAY , XiaomiDevice ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] ATTR_LOAD_POWER = [string] [EOL] [EOL] [comment] [EOL] ATTR_POWER_CONSUMED = [string] [EOL] ATTR_IN_USE = [string] [EOL] [EOL] LOAD_POWER = [string] [EOL] POWER_CONSUMED = [string] [EOL] IN_USE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for ( _ , gateway ) in hass . data [ PY_XIAOMI_GATEWAY ] . gateways . items ( ) : [EOL] for device in gateway . devices [ [string] ] : [EOL] model = device [ [string] ] [EOL] if model == [string] : [EOL] if [string] not in device or int ( device [ [string] ] [ [number] : [number] ] ) == [number] : [EOL] data_key = [string] [EOL] else : [EOL] data_key = [string] [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , data_key , True , gateway ) ) [EOL] elif model in [ [string] , [string] ] : [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , False , gateway ) ) [EOL] elif model in [ [string] , [string] ] : [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , False , gateway ) ) [EOL] elif model in [ [string] , [string] ] : [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , False , gateway ) ) [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , False , gateway ) ) [EOL] elif model in [ [string] , [string] ] : [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , False , gateway ) ) [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , False , gateway ) ) [EOL] elif model in [ [string] , [string] , [string] ] : [EOL] devices . append ( XiaomiGenericSwitch ( device , [string] , [string] , True , gateway ) ) [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class XiaomiGenericSwitch ( XiaomiDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , name , data_key , supports_power_consumption , xiaomi_hub ) : [EOL] [docstring] [EOL] self . _data_key = data_key [EOL] self . _in_use = None [EOL] self . _load_power = None [EOL] self . _power_consumed = None [EOL] self . _supports_power_consumption = supports_power_consumption [EOL] XiaomiDevice . __init__ ( self , device , name , xiaomi_hub ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _data_key == [string] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _supports_power_consumption : [EOL] attrs = { ATTR_IN_USE : self . _in_use , ATTR_LOAD_POWER : self . _load_power , ATTR_POWER_CONSUMED : self . _power_consumed } [EOL] else : [EOL] attrs = { } [EOL] attrs . update ( super ( ) . device_state_attributes ) [EOL] return attrs [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _write_to_hub ( self . _sid , ** { self . _data_key : [string] } ) : [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _write_to_hub ( self . _sid , ** { self . _data_key : [string] } ) : [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def parse_data ( self , data , raw_data ) : [EOL] [docstring] [EOL] if IN_USE in data : [EOL] self . _in_use = int ( data [ IN_USE ] ) [EOL] if not self . _in_use : [EOL] self . _load_power = [number] [EOL] if POWER_CONSUMED in data : [EOL] self . _power_consumed = round ( float ( data [ POWER_CONSUMED ] ) , [number] ) [EOL] if LOAD_POWER in data : [EOL] self . _load_power = round ( float ( data [ LOAD_POWER ] ) , [number] ) [EOL] [EOL] value = data . get ( self . _data_key ) [EOL] if value is None : [EOL] return False [EOL] [EOL] state = value == [string] [EOL] if self . _state == state : [EOL] return False [EOL] self . _state = state [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . tahoma import ( DOMAIN as TAHOMA_DOMAIN , TahomaDevice ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] controller = hass . data [ TAHOMA_DOMAIN ] [ [string] ] [EOL] devices = [ ] [EOL] for switch in hass . data [ TAHOMA_DOMAIN ] [ [string] ] [ [string] ] : [EOL] devices . append ( TahomaSwitch ( switch , controller ) ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class TahomaSwitch ( TahomaDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] if self . tahoma_device . type == [string] : [EOL] return [string] [EOL] return None [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . toggle ( ) [EOL] [EOL] def toggle ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . apply_action ( [string] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . wink import DOMAIN , WinkDevice [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import pywink [EOL] [EOL] for switch in pywink . get_switches ( ) : [EOL] _id = switch . object_id ( ) + switch . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] add_entities ( [ WinkToggleDevice ( switch , hass ) ] ) [EOL] for switch in pywink . get_powerstrips ( ) : [EOL] _id = switch . object_id ( ) + switch . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] add_entities ( [ WinkToggleDevice ( switch , hass ) ] ) [EOL] for sprinkler in pywink . get_sprinklers ( ) : [EOL] _id = sprinkler . object_id ( ) + sprinkler . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] add_entities ( [ WinkToggleDevice ( sprinkler , hass ) ] ) [EOL] for switch in pywink . get_binary_switch_groups ( ) : [EOL] _id = switch . object_id ( ) + switch . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] add_entities ( [ WinkToggleDevice ( switch , hass ) ] ) [EOL] [EOL] [EOL] class WinkToggleDevice ( WinkDevice , ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . data [ DOMAIN ] [ [string] ] [ [string] ] . append ( self ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . wink . state ( ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wink . set_state ( True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wink . set_state ( False ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = super ( WinkToggleDevice , self ) . device_state_attributes [EOL] try : [EOL] event = self . wink . last_event ( ) [EOL] if event is not None : [EOL] attributes [ [string] ] = event [EOL] except AttributeError : [EOL] pass [EOL] return attributes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from homeassistant . components . tellstick import ( DEFAULT_SIGNAL_REPETITIONS , ATTR_DISCOVER_DEVICES , ATTR_DISCOVER_CONFIG , DATA_TELLSTICK , TellstickDevice ) [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if ( discovery_info is None or discovery_info [ ATTR_DISCOVER_DEVICES ] is None ) : [EOL] return [EOL] [EOL] [comment] [EOL] signal_repetitions = discovery_info . get ( ATTR_DISCOVER_CONFIG , DEFAULT_SIGNAL_REPETITIONS ) [EOL] [EOL] add_entities ( [ TellstickSwitch ( hass . data [ DATA_TELLSTICK ] [ tellcore_id ] , signal_repetitions ) for tellcore_id in discovery_info [ ATTR_DISCOVER_DEVICES ] ] , True ) [EOL] [EOL] [EOL] class TellstickSwitch ( TellstickDevice , ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def _parse_ha_data ( self , kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _parse_tellcore_data ( self , tellcore_data ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _update_model ( self , new_state , data ) : [EOL] [docstring] [EOL] self . _state = new_state [EOL] [EOL] def _send_device_command ( self , requested_state , requested_data ) : [EOL] [docstring] [EOL] if requested_state : [EOL] self . _tellcore_device . turn_on ( ) [EOL] else : [EOL] self . _tellcore_device . turn_off ( ) [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pymystrom . switch import MyStromPlug , exceptions [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] [EOL] try : [EOL] MyStromPlug ( host ) . get_status ( ) [EOL] except exceptions . MyStromConnectionError : [EOL] _LOGGER . error ( [string] , host ) [EOL] return [EOL] [EOL] add_entities ( [ MyStromSwitch ( name , host ) ] ) [EOL] [EOL] [EOL] class MyStromSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , resource ) : [EOL] [docstring] [EOL] from pymystrom . switch import MyStromPlug [EOL] [EOL] self . _name = name [EOL] self . _resource = resource [EOL] self . data = { } [EOL] self . plug = MyStromPlug ( self . _resource ) [EOL] self . update ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . data [ [string] ] ) [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] return round ( self . data [ [string] ] , [number] ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from pymystrom import exceptions [EOL] try : [EOL] self . plug . set_relay_on ( ) [EOL] except exceptions . MyStromConnectionError : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] from pymystrom import exceptions [EOL] try : [EOL] self . plug . set_relay_off ( ) [EOL] except exceptions . MyStromConnectionError : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pymystrom import exceptions [EOL] try : [EOL] self . data = self . plug . get_status ( ) [EOL] except exceptions . MyStromConnectionError : [EOL] self . data = { [string] : [number] , [string] : False } [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import mimetypes [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( ATTR_DATA , ATTR_TARGET , ATTR_TITLE , ATTR_TITLE_DEFAULT , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] from homeassistant . const import CONF_API_KEY [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_URL = [string] [EOL] ATTR_FILE = [string] [EOL] ATTR_FILE_URL = [string] [EOL] ATTR_LIST = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] from pushbullet import PushBullet [EOL] from pushbullet import InvalidKeyError [EOL] [EOL] try : [EOL] pushbullet = PushBullet ( config [ CONF_API_KEY ] ) [EOL] except InvalidKeyError : [EOL] _LOGGER . error ( [string] ) [EOL] return None [EOL] [EOL] return PushBulletNotificationService ( pushbullet ) [EOL] [EOL] [EOL] class PushBulletNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pb ) : [EOL] [docstring] [EOL] self . pushbullet = pb [EOL] self . pbtargets = { } [EOL] self . refresh ( ) [EOL] [EOL] def refresh ( self ) : [EOL] [docstring] [EOL] self . pushbullet . refresh ( ) [EOL] self . pbtargets = { [string] : { tgt . nickname . lower ( ) : tgt for tgt in self . pushbullet . devices } , [string] : { tgt . channel_tag . lower ( ) : tgt for tgt in self . pushbullet . channels } , } [EOL] [EOL] def send_message ( self , message = None , ** kwargs ) : [EOL] [docstring] [EOL] targets = kwargs . get ( ATTR_TARGET ) [EOL] title = kwargs . get ( ATTR_TITLE , ATTR_TITLE_DEFAULT ) [EOL] data = kwargs . get ( ATTR_DATA ) [EOL] refreshed = False [EOL] [EOL] if not targets : [EOL] [comment] [EOL] self . _push_data ( message , title , data , self . pushbullet ) [EOL] _LOGGER . info ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] for target in targets : [EOL] try : [EOL] ttype , tname = target . split ( [string] , [number] ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] , target ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ttype == [string] : [EOL] self . _push_data ( message , title , data , self . pushbullet , tname ) [EOL] _LOGGER . info ( [string] , tname ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ttype not in self . pbtargets : [EOL] _LOGGER . error ( [string] , target ) [EOL] continue [EOL] [EOL] tname = tname . lower ( ) [EOL] [EOL] if tname not in self . pbtargets [ ttype ] and not refreshed : [EOL] self . refresh ( ) [EOL] refreshed = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] self . _push_data ( message , title , data , self . pbtargets [ ttype ] [ tname ] ) [EOL] _LOGGER . info ( [string] , ttype , tname ) [EOL] except KeyError : [EOL] _LOGGER . error ( [string] , ttype , tname ) [EOL] continue [EOL] [EOL] def _push_data ( self , message , title , data , pusher , email = None ) : [EOL] [docstring] [EOL] from pushbullet import PushError [EOL] if data is None : [EOL] data = { } [EOL] data_list = data . get ( ATTR_LIST ) [EOL] url = data . get ( ATTR_URL ) [EOL] filepath = data . get ( ATTR_FILE ) [EOL] file_url = data . get ( ATTR_FILE_URL ) [EOL] try : [EOL] email_kwargs = { } [EOL] if email : [EOL] email_kwargs [ [string] ] = email [EOL] if url : [EOL] pusher . push_link ( title , url , body = message , ** email_kwargs ) [EOL] elif filepath : [EOL] if not self . hass . config . is_allowed_path ( filepath ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] with open ( filepath , [string] ) as fileh : [EOL] filedata = self . pushbullet . upload_file ( fileh , filepath ) [EOL] if filedata . get ( [string] ) == [string] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] filedata . update ( email_kwargs ) [EOL] pusher . push_file ( title = title , body = message , ** filedata ) [EOL] elif file_url : [EOL] if not file_url . startswith ( [string] ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] pusher . push_file ( title = title , body = message , file_name = file_url , file_url = file_url , file_type = ( mimetypes . guess_type ( file_url ) [ [number] ] ) , ** email_kwargs ) [EOL] elif data_list : [EOL] pusher . push_list ( title , data_list , ** email_kwargs ) [EOL] else : [EOL] pusher . push_note ( title , message , ** email_kwargs ) [EOL] except PushError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . components . config import EditKeyBasedConfigView [EOL] from homeassistant . components . script import SCRIPT_ENTRY_SCHEMA , async_reload [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] [EOL] CONFIG_PATH = [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass ) : [EOL] [docstring] [EOL] hass . http . register_view ( EditKeyBasedConfigView ( [string] , [string] , CONFIG_PATH , cv . slug , SCRIPT_ENTRY_SCHEMA , post_write_hook = async_reload ) ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Pattern [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] from aiohttp import hdrs [EOL] from aiohttp . web import FileResponse , middleware [EOL] from aiohttp . web_exceptions import HTTPNotFound [EOL] from aiohttp . web_urldispatcher import StaticResource [EOL] from yarl import URL [EOL] [EOL] _FINGERPRINT = re . compile ( [string] , re . IGNORECASE ) [EOL] [EOL] [EOL] class CachingStaticResource ( StaticResource ) : [EOL] [docstring] [EOL] [EOL] async def _handle ( self , request ) : [EOL] filename = URL ( request . match_info [ [string] ] ) . path [EOL] try : [EOL] [comment] [EOL] filepath = self . _directory . joinpath ( filename ) . resolve ( ) [EOL] if not self . _follow_symlinks : [EOL] filepath . relative_to ( self . _directory ) [EOL] except ( ValueError , FileNotFoundError ) as error : [EOL] [comment] [EOL] raise HTTPNotFound ( ) from error [EOL] except Exception as error : [EOL] [comment] [EOL] request . app . logger . exception ( error ) [EOL] raise HTTPNotFound ( ) from error [EOL] [EOL] if filepath . is_dir ( ) : [EOL] return await super ( ) . _handle ( request ) [EOL] if filepath . is_file ( ) : [EOL] return CachingFileResponse ( filepath , chunk_size = self . _chunk_size ) [EOL] raise HTTPNotFound [EOL] [EOL] [EOL] [comment] [EOL] class CachingFileResponse ( FileResponse ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] orig_sendfile = self . _sendfile [EOL] [EOL] async def sendfile ( request , fobj , count ) : [EOL] [docstring] [EOL] cache_time = [number] * [number] [comment] [EOL] self . headers [ hdrs . CACHE_CONTROL ] = [string] . format ( cache_time ) [EOL] [EOL] await orig_sendfile ( request , fobj , count ) [EOL] [EOL] [comment] [EOL] self . _sendfile = sendfile [EOL] [EOL] [EOL] @ middleware async def staticresource_middleware ( request , handler ) : [EOL] [docstring] [EOL] path = request . path [EOL] if not path . startswith ( [string] ) and not path . startswith ( [string] ) : [EOL] return await handler ( request ) [EOL] [EOL] fingerprinted = _FINGERPRINT . match ( request . match_info [ [string] ] ) [EOL] [EOL] if fingerprinted : [EOL] request . match_info [ [string] ] = [string] . format ( * fingerprinted . groups ( ) ) [EOL] [EOL] return await handler ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import api [EOL] [docstring] [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . components . knx import ( ATTR_DISCOVER_DEVICES , DATA_KNX , KNXAutomation ) [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] CONF_ADDRESS = [string] [EOL] CONF_DEVICE_CLASS = [string] [EOL] CONF_SIGNIFICANT_BIT = [string] [EOL] CONF_DEFAULT_SIGNIFICANT_BIT = [number] [EOL] CONF_AUTOMATION = [string] [EOL] CONF_HOOK = [string] [EOL] CONF_DEFAULT_HOOK = [string] [EOL] CONF_COUNTER = [string] [EOL] CONF_DEFAULT_COUNTER = [number] [EOL] CONF_ACTION = [string] [EOL] CONF_RESET_AFTER = [string] [EOL] [EOL] CONF__ACTION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] AUTOMATION_SCHEMA = vol . Schema ( { vol . Optional ( CONF_HOOK , default = CONF_DEFAULT_HOOK ) : cv . string , vol . Optional ( CONF_COUNTER , default = CONF_DEFAULT_COUNTER ) : cv . port , vol . Required ( CONF_ACTION ) : cv . SCRIPT_SCHEMA } ) [EOL] [EOL] AUTOMATIONS_SCHEMA = vol . All ( cv . ensure_list , [ AUTOMATION_SCHEMA ] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ADDRESS ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : cv . string , vol . Optional ( CONF_SIGNIFICANT_BIT , default = CONF_DEFAULT_SIGNIFICANT_BIT ) : cv . positive_int , vol . Optional ( CONF_RESET_AFTER ) : cv . positive_int , vol . Optional ( CONF_AUTOMATION ) : AUTOMATIONS_SCHEMA , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] async_add_entities_discovery ( hass , discovery_info , async_add_entities ) [EOL] else : [EOL] async_add_entities_config ( hass , config , async_add_entities ) [EOL] [EOL] [EOL] @ callback def async_add_entities_discovery ( hass , discovery_info , async_add_entities ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for device_name in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] device = hass . data [ DATA_KNX ] . xknx . devices [ device_name ] [EOL] entities . append ( KNXBinarySensor ( hass , device ) ) [EOL] async_add_entities ( entities ) [EOL] [EOL] [EOL] @ callback def async_add_entities_config ( hass , config , async_add_entities ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] import xknx [EOL] binary_sensor = xknx . devices . BinarySensor ( hass . data [ DATA_KNX ] . xknx , name = name , group_address = config . get ( CONF_ADDRESS ) , device_class = config . get ( CONF_DEVICE_CLASS ) , significant_bit = config . get ( CONF_SIGNIFICANT_BIT ) , reset_after = config . get ( CONF_RESET_AFTER ) ) [EOL] hass . data [ DATA_KNX ] . xknx . devices . add ( binary_sensor ) [EOL] [EOL] entity = KNXBinarySensor ( hass , binary_sensor ) [EOL] automations = config . get ( CONF_AUTOMATION ) [EOL] if automations is not None : [EOL] for automation in automations : [EOL] counter = automation . get ( CONF_COUNTER ) [EOL] hook = automation . get ( CONF_HOOK ) [EOL] action = automation . get ( CONF_ACTION ) [EOL] entity . automations . append ( KNXAutomation ( hass = hass , device = binary_sensor , hook = hook , action = action , counter = counter ) ) [EOL] async_add_entities ( [ entity ] ) [EOL] [EOL] [EOL] class KNXBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] self . device = device [EOL] self . hass = hass [EOL] self . async_register_callbacks ( ) [EOL] self . automations = [ ] [EOL] [EOL] @ callback def async_register_callbacks ( self ) : [EOL] [docstring] [EOL] async def after_update_callback ( device ) : [EOL] [docstring] [EOL] await self . async_update_ha_state ( ) [EOL] self . device . register_device_updated_cb ( after_update_callback ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . device . name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . hass . data [ DATA_KNX ] . connected [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . device . device_class [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . device . is_on ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SENSOR_TYPES = { [string] : [string] , [string] : None , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] bloomsky = hass . components . bloomsky [EOL] [comment] [EOL] sensors = config . get ( CONF_MONITORED_CONDITIONS , SENSOR_TYPES ) [EOL] [EOL] for device in bloomsky . BLOOMSKY . devices . values ( ) : [EOL] for variable in sensors : [EOL] add_entities ( [ BloomSkySensor ( bloomsky . BLOOMSKY , device , variable ) ] , True ) [EOL] [EOL] [EOL] class BloomSkySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bs , device , sensor_name ) : [EOL] [docstring] [EOL] self . _bloomsky = bs [EOL] self . _device_id = device [ [string] ] [EOL] self . _sensor_name = sensor_name [EOL] self . _name = [string] . format ( device [ [string] ] , sensor_name ) [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES . get ( self . _sensor_name ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _bloomsky . refresh_devices ( ) [EOL] [EOL] self . _state = self . _bloomsky . devices [ self . _device_id ] [ [string] ] [ self . _sensor_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components import ecobee [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ECOBEE_CONFIG_FILE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] data = ecobee . NETWORK [EOL] dev = list ( ) [EOL] for index in range ( len ( data . ecobee . thermostats ) ) : [EOL] for sensor in data . ecobee . get_remote_sensors ( index ) : [EOL] for item in sensor [ [string] ] : [EOL] if item [ [string] ] != [string] : [EOL] continue [EOL] [EOL] dev . append ( EcobeeBinarySensor ( sensor [ [string] ] , index ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class EcobeeBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_name , sensor_index ) : [EOL] [docstring] [EOL] self . _name = sensor_name + [string] [EOL] self . sensor_name = sensor_name [EOL] self . index = sensor_index [EOL] self . _state = None [EOL] self . _device_class = [string] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name . rstrip ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state == [string] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] data = ecobee . NETWORK [EOL] data . update ( ) [EOL] for sensor in data . ecobee . get_remote_sensors ( self . index ) : [EOL] for item in sensor [ [string] ] : [EOL] if ( item [ [string] ] == [string] and self . sensor_name == sensor [ [string] ] ) : [EOL] self . _state = item [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . blink import DOMAIN [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] data = hass . data [ DOMAIN ] . blink [EOL] devs = list ( ) [EOL] for name in data . cameras : [EOL] devs . append ( BlinkCameraMotionSensor ( name , data ) ) [EOL] devs . append ( BlinkSystemSensor ( data ) ) [EOL] add_entities ( devs , True ) [EOL] [EOL] [EOL] class BlinkCameraMotionSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , data ) : [EOL] [docstring] [EOL] self . _name = [string] + name + [string] [EOL] self . _camera_name = name [EOL] self . data = data [EOL] self . _state = self . data . cameras [ self . _camera_name ] . armed [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . refresh ( ) [EOL] self . _state = self . data . cameras [ self . _camera_name ] . armed [EOL] [EOL] [EOL] class BlinkSystemSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data ) : [EOL] [docstring] [EOL] self . _name = [string] [EOL] self . data = data [EOL] self . _state = self . data . arm [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name . replace ( [string] , [string] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . refresh ( ) [EOL] self . _state = self . data . arm [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Match , Any , Optional , List , Type [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] import api [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] import re [EOL] [EOL] from aiohttp import web [EOL] [EOL] from homeassistant . components . google import ( CONF_OFFSET , CONF_DEVICE_ID , CONF_NAME ) [EOL] from homeassistant . const import STATE_OFF , STATE_ON [EOL] from homeassistant . helpers . config_validation import PLATFORM_SCHEMA [comment] [EOL] from homeassistant . helpers . config_validation import time_period_str [EOL] from homeassistant . helpers . entity import Entity , generate_entity_id [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . template import DATE_STR_FORMAT [EOL] from homeassistant . util import dt [EOL] from homeassistant . components import http [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass , SCAN_INTERVAL , DOMAIN ) [EOL] [EOL] hass . http . register_view ( CalendarListView ( component ) ) [EOL] hass . http . register_view ( CalendarEventView ( component ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] await component . async_setup ( config ) [EOL] return True [EOL] [EOL] [EOL] DEFAULT_CONF_TRACK_NEW = True [EOL] DEFAULT_CONF_OFFSET = [string] [EOL] [EOL] [EOL] def get_date ( date ) : [EOL] [docstring] [EOL] if [string] in date : [EOL] return dt . start_of_local_day ( dt . dt . datetime . combine ( dt . parse_date ( date [ [string] ] ) , dt . dt . time . min ) ) [EOL] return dt . as_local ( dt . parse_datetime ( date [ [string] ] ) ) [EOL] [EOL] [EOL] class CalendarEventDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] data = None [EOL] [EOL] def __init__ ( self , hass , data ) : [EOL] [docstring] [EOL] self . _name = data . get ( CONF_NAME ) [EOL] self . dev_id = data . get ( CONF_DEVICE_ID ) [EOL] self . _offset = data . get ( CONF_OFFSET , DEFAULT_CONF_OFFSET ) [EOL] self . entity_id = generate_entity_id ( ENTITY_ID_FORMAT , self . dev_id , hass = hass ) [EOL] [EOL] self . _cal_data = { [string] : False , [string] : dt . dt . timedelta ( ) , [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : [string] , } [EOL] [EOL] self . update ( ) [EOL] [EOL] def offset_reached ( self ) : [EOL] [docstring] [EOL] if self . _cal_data [ [string] ] is None or self . _cal_data [ [string] ] == dt . dt . timedelta ( ) : [EOL] return False [EOL] [EOL] return self . _cal_data [ [string] ] + self . _cal_data [ [string] ] <= dt . now ( self . _cal_data [ [string] ] . tzinfo ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] start = self . _cal_data . get ( [string] , None ) [EOL] end = self . _cal_data . get ( [string] , None ) [EOL] start = start . strftime ( DATE_STR_FORMAT ) if start is not None else None [EOL] end = end . strftime ( DATE_STR_FORMAT ) if end is not None else None [EOL] [EOL] return { [string] : self . _cal_data . get ( [string] , [string] ) , [string] : self . _cal_data . get ( [string] , False ) , [string] : self . offset_reached ( ) , [string] : start , [string] : end , [string] : self . _cal_data . get ( [string] , None ) , [string] : self . _cal_data . get ( [string] , None ) , } [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] start = self . _cal_data . get ( [string] , None ) [EOL] end = self . _cal_data . get ( [string] , None ) [EOL] if start is None or end is None : [EOL] return STATE_OFF [EOL] [EOL] now = dt . now ( ) [EOL] [EOL] if start <= now < end : [EOL] return STATE_ON [EOL] [EOL] if now >= end : [EOL] self . cleanup ( ) [EOL] [EOL] return STATE_OFF [EOL] [EOL] def cleanup ( self ) : [EOL] [docstring] [EOL] self . _cal_data = { [string] : False , [string] : [number] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : None } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if not self . data or not self . data . update ( ) : [EOL] [comment] [EOL] return [EOL] [EOL] if not self . data . event : [EOL] [comment] [EOL] self . cleanup ( ) [EOL] return [EOL] [EOL] start = get_date ( self . data . event [ [string] ] ) [EOL] end = get_date ( self . data . event [ [string] ] ) [EOL] [EOL] summary = self . data . event . get ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] reg = [string] . format ( self . _offset ) [EOL] search = re . search ( reg , summary ) [EOL] if search and search . group ( [number] ) : [EOL] time = search . group ( [number] ) [EOL] if [string] not in time : [EOL] if time [ [number] ] == [string] or time [ [number] ] == [string] : [EOL] time = [string] . format ( time [ [number] ] , time [ [number] : ] ) [EOL] else : [EOL] time = [string] . format ( time ) [EOL] [EOL] offset_time = time_period_str ( time ) [EOL] summary = ( summary [ : search . start ( ) ] + summary [ search . end ( ) : ] ) . strip ( ) [EOL] else : [EOL] offset_time = dt . dt . timedelta ( ) [comment] [EOL] [EOL] [comment] [EOL] self . _cal_data [ [string] ] = re . sub ( [string] , [string] , summary ) . strip ( ) [EOL] self . _cal_data [ [string] ] = offset_time [EOL] self . _cal_data [ [string] ] = self . data . event . get ( [string] , [string] ) [EOL] self . _cal_data [ [string] ] = self . data . event . get ( [string] , [string] ) [EOL] self . _cal_data [ [string] ] = start [EOL] self . _cal_data [ [string] ] = end [EOL] self . _cal_data [ [string] ] = [string] in self . data . event [ [string] ] [EOL] [EOL] [EOL] class CalendarEventView ( http . HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] [EOL] def __init__ ( self , component ) : [EOL] [docstring] [EOL] self . component = component [EOL] [EOL] async def get ( self , request , entity_id ) : [EOL] [docstring] [EOL] entity = self . component . get_entity ( entity_id ) [EOL] start = request . query . get ( [string] ) [EOL] end = request . query . get ( [string] ) [EOL] if None in ( start , end , entity ) : [EOL] return web . Response ( status = [number] ) [EOL] try : [EOL] start_date = dt . parse_datetime ( start ) [EOL] end_date = dt . parse_datetime ( end ) [EOL] except ( ValueError , AttributeError ) : [EOL] return web . Response ( status = [number] ) [EOL] event_list = await entity . async_get_events ( request . app [ [string] ] , start_date , end_date ) [EOL] return self . json ( event_list ) [EOL] [EOL] [EOL] class CalendarListView ( http . HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] [EOL] def __init__ ( self , component ) : [EOL] [docstring] [EOL] self . component = component [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] get_state = request . app [ [string] ] . states . get [EOL] calendar_list = [ ] [EOL] [EOL] for entity in self . component . entities : [EOL] state = get_state ( entity . entity_id ) [EOL] calendar_list . append ( { [string] : state . name , [string] : entity . entity_id , } ) [EOL] [EOL] return self . json ( sorted ( calendar_list , key = lambda x : x [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components import remote [EOL] from homeassistant . const import ( DEVICE_DEFAULT_NAME , CONF_NAME , CONF_MAC , CONF_HOST , CONF_PORT , CONF_DEVICES ) [EOL] from homeassistant . components . remote import PLATFORM_SCHEMA [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_PORT = [number] [EOL] CONNECT_TIMEOUT = [number] [EOL] [EOL] CONF_MODADDR = [string] [EOL] CONF_CONNADDR = [string] [EOL] CONF_COMMANDS = [string] [EOL] CONF_DATA = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MAC ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , [ { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_MODADDR ) : vol . Coerce ( int ) , vol . Required ( CONF_CONNADDR ) : vol . Coerce ( int ) , vol . Required ( CONF_COMMANDS ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_DATA ) : cv . string } ] ) } ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import pyitachip2ir [EOL] itachip2ir = pyitachip2ir . ITachIP2IR ( config . get ( CONF_MAC ) , config . get ( CONF_HOST ) , int ( config . get ( CONF_PORT ) ) ) [EOL] [EOL] if not itachip2ir . ready ( CONNECT_TIMEOUT ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] devices = [ ] [EOL] for data in config . get ( CONF_DEVICES ) : [EOL] name = data . get ( CONF_NAME ) [EOL] modaddr = int ( data . get ( CONF_MODADDR , [number] ) ) [EOL] connaddr = int ( data . get ( CONF_CONNADDR , [number] ) ) [EOL] cmddatas = [string] [EOL] for cmd in data . get ( CONF_COMMANDS ) : [EOL] cmdname = cmd [ CONF_NAME ] . strip ( ) [EOL] if not cmdname : [EOL] cmdname = [string] [EOL] cmddata = cmd [ CONF_DATA ] . strip ( ) [EOL] if not cmddata : [EOL] cmddata = [string] [EOL] cmddatas += [string] . format ( cmdname , cmddata ) [EOL] itachip2ir . addDevice ( name , modaddr , connaddr , cmddatas ) [EOL] devices . append ( ITachIP2IRRemote ( itachip2ir , name ) ) [EOL] add_entities ( devices , True ) [EOL] return True [EOL] [EOL] [EOL] class ITachIP2IRRemote ( remote . RemoteDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , itachip2ir , name ) : [EOL] [docstring] [EOL] self . itachip2ir = itachip2ir [EOL] self . _power = False [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _power [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _power = True [EOL] self . itachip2ir . send ( self . _name , [string] , [number] ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _power = False [EOL] self . itachip2ir . send ( self . _name , [string] , [number] ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] for single_command in command : [EOL] self . itachip2ir . send ( self . _name , single_command , [number] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . itachip2ir . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Generator [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import aiohttp [EOL] from aiohttp . hdrs import AUTHORIZATION [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . scene import Scene [EOL] from homeassistant . const import CONF_TOKEN , CONF_TIMEOUT , CONF_PLATFORM [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] LIFX_API_URL = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : [string] , vol . Required ( CONF_TOKEN ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] token = config . get ( CONF_TOKEN ) [EOL] timeout = config . get ( CONF_TIMEOUT ) [EOL] [EOL] headers = { AUTHORIZATION : [string] . format ( token ) , } [EOL] [EOL] url = LIFX_API_URL . format ( [string] ) [EOL] [EOL] try : [EOL] httpsession = async_get_clientsession ( hass ) [EOL] with async_timeout . timeout ( timeout , loop = hass . loop ) : [EOL] scenes_resp = yield from httpsession . get ( url , headers = headers ) [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . exception ( [string] , url ) [EOL] return False [EOL] [EOL] status = scenes_resp . status [EOL] if status == [number] : [EOL] data = yield from scenes_resp . json ( ) [EOL] devices = [ ] [EOL] for scene in data : [EOL] devices . append ( LifxCloudScene ( hass , headers , timeout , scene ) ) [EOL] async_add_entities ( devices ) [EOL] return True [EOL] if status == [number] : [EOL] _LOGGER . error ( [string] , url ) [EOL] return False [EOL] [EOL] _LOGGER . error ( [string] , scenes_resp . status , url ) [EOL] return False [EOL] [EOL] [EOL] class LifxCloudScene ( Scene ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , headers , timeout , scene_data ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _headers = headers [EOL] self . _timeout = timeout [EOL] self . _name = scene_data [ [string] ] [EOL] self . _uuid = scene_data [ [string] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ asyncio . coroutine def async_activate ( self ) : [EOL] [docstring] [EOL] url = LIFX_API_URL . format ( [string] % self . _uuid ) [EOL] [EOL] try : [EOL] httpsession = async_get_clientsession ( self . hass ) [EOL] with async_timeout . timeout ( self . _timeout , loop = self . hass . loop ) : [EOL] yield from httpsession . put ( url , headers = self . _headers ) [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . exception ( [string] , url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0
from typing import Callable , Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] from typing import Callable [EOL] [EOL] from homeassistant . components . cover import CoverDevice , DOMAIN [EOL] from homeassistant . components . isy994 import ( ISY994_NODES , ISY994_PROGRAMS , ISYDevice ) [EOL] from homeassistant . const import ( STATE_OPEN , STATE_CLOSED , STATE_OPENING , STATE_CLOSING , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . typing import ConfigType [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] VALUE_TO_STATE = { [number] : STATE_CLOSED , [number] : STATE_UNKNOWN , [number] : [string] , [number] : STATE_CLOSING , [number] : STATE_OPENING } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for node in hass . data [ ISY994_NODES ] [ DOMAIN ] : [EOL] devices . append ( ISYCoverDevice ( node ) ) [EOL] [EOL] for name , status , actions in hass . data [ ISY994_PROGRAMS ] [ DOMAIN ] : [EOL] devices . append ( ISYCoverProgram ( name , status , actions ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class ISYCoverDevice ( ISYDevice , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] return sorted ( ( [number] , self . value , [number] ) ) [ [number] ] [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return self . state == STATE_CLOSED [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . is_unknown ( ) : [EOL] return None [EOL] return VALUE_TO_STATE . get ( self . value , STATE_OPEN ) [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . on ( val = [number] ) : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . off ( ) : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] [EOL] class ISYCoverProgram ( ISYCoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , node , actions ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( node ) [EOL] self . _name = name [EOL] self . _actions = actions [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return STATE_CLOSED if bool ( self . value ) else STATE_OPEN [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _actions . runThen ( ) : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _actions . runElse ( ) : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import api [EOL] import telnetlib [EOL] [docstring] [EOL] import logging [EOL] import telnetlib [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_PAUSE , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_PLAY ) [EOL] from homeassistant . const import ( CONF_HOST , STATE_OFF , STATE_ON , STATE_UNKNOWN , CONF_NAME , CONF_PORT , CONF_TIMEOUT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [comment] [EOL] DEFAULT_TIMEOUT = None [EOL] [EOL] SUPPORT_PIONEER = SUPPORT_PAUSE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY [EOL] [EOL] MAX_VOLUME = [number] [EOL] MAX_SOURCE_NUMBERS = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . socket_timeout , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pioneer = PioneerDevice ( config . get ( CONF_NAME ) , config . get ( CONF_HOST ) , config . get ( CONF_PORT ) , config . get ( CONF_TIMEOUT ) ) [EOL] [EOL] if pioneer . update ( ) : [EOL] add_entities ( [ pioneer ] ) [EOL] [EOL] [EOL] class PioneerDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host , port , timeout ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _timeout = timeout [EOL] self . _pwstate = [string] [EOL] self . _volume = [number] [EOL] self . _muted = False [EOL] self . _selected_source = [string] [EOL] self . _source_name_to_number = { } [EOL] self . _source_number_to_name = { } [EOL] [EOL] @ classmethod def telnet_request ( cls , telnet , command , expected_prefix ) : [EOL] [docstring] [EOL] try : [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] except telnetlib . socket . timeout : [EOL] _LOGGER . debug ( [string] , command ) [EOL] return None [EOL] [EOL] [comment] [EOL] [comment] [EOL] for _ in range ( [number] ) : [EOL] result = telnet . read_until ( [string] , timeout = [number] ) . decode ( [string] ) . strip ( ) [EOL] if result . startswith ( expected_prefix ) : [EOL] return result [EOL] [EOL] return None [EOL] [EOL] def telnet_command ( self , command ) : [EOL] [docstring] [EOL] try : [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _host , self . _port , self . _timeout ) [EOL] except ( ConnectionRefusedError , OSError ) : [EOL] _LOGGER . warning ( [string] , self . _name ) [EOL] return [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] telnet . read_very_eager ( ) [comment] [EOL] telnet . close ( ) [EOL] except telnetlib . socket . timeout : [EOL] _LOGGER . debug ( [string] , self . _name , command ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _host , self . _port , self . _timeout ) [EOL] except ( ConnectionRefusedError , OSError ) : [EOL] _LOGGER . warning ( [string] , self . _name ) [EOL] return False [EOL] [EOL] pwstate = self . telnet_request ( telnet , [string] , [string] ) [EOL] if pwstate : [EOL] self . _pwstate = pwstate [EOL] [EOL] volume_str = self . telnet_request ( telnet , [string] , [string] ) [EOL] self . _volume = int ( volume_str [ [number] : ] ) / MAX_VOLUME if volume_str else None [EOL] [EOL] muted_value = self . telnet_request ( telnet , [string] , [string] ) [EOL] self . _muted = ( muted_value == [string] ) if muted_value else None [EOL] [EOL] [comment] [EOL] if not self . _source_name_to_number : [EOL] for i in range ( MAX_SOURCE_NUMBERS ) : [EOL] result = self . telnet_request ( telnet , [string] + str ( i ) . zfill ( [number] ) , [string] ) [EOL] [EOL] if not result : [EOL] continue [EOL] [EOL] source_name = result [ [number] : ] [EOL] source_number = str ( i ) . zfill ( [number] ) [EOL] [EOL] self . _source_name_to_number [ source_name ] = source_number [EOL] self . _source_number_to_name [ source_number ] = source_name [EOL] [EOL] source_number = self . telnet_request ( telnet , [string] , [string] ) [EOL] [EOL] if source_number : [EOL] self . _selected_source = self . _source_number_to_name . get ( source_number [ [number] : ] ) [EOL] else : [EOL] self . _selected_source = None [EOL] [EOL] telnet . close ( ) [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _pwstate == [string] : [EOL] return STATE_OFF [EOL] if self . _pwstate == [string] : [EOL] return STATE_ON [EOL] [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_PIONEER [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _selected_source [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return list ( self . _source_name_to_number . keys ( ) ) [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _selected_source [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] [comment] [EOL] self . telnet_command ( str ( round ( volume * MAX_VOLUME ) ) . zfill ( [number] ) + [string] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] if mute else [string] ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . telnet_command ( self . _source_name_to_number . get ( source ) + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Generator [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , SUPPORT_SEEK , SUPPORT_PLAY_MEDIA , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP , SUPPORT_STOP , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_PLAY , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA , MEDIA_TYPE_MUSIC ) [EOL] from homeassistant . const import ( STATE_OFF , STATE_PLAYING , STATE_PAUSED , STATE_UNKNOWN , CONF_HOST , CONF_PORT , CONF_PASSWORD ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_FRONTIER_SILICON = SUPPORT_PAUSE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_STEP | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_SEEK | SUPPORT_PLAY_MEDIA | SUPPORT_PLAY | SUPPORT_STOP | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE [EOL] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_PASSWORD = [string] [EOL] DEVICE_URL = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_PASSWORD , default = DEFAULT_PASSWORD ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import requests [EOL] [EOL] if discovery_info is not None : [EOL] async_add_entities ( [ AFSAPIDevice ( discovery_info [ [string] ] , DEFAULT_PASSWORD ) ] , update_before_add = True ) [EOL] return True [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] try : [EOL] async_add_entities ( [ AFSAPIDevice ( DEVICE_URL . format ( host , port ) , password ) ] , update_before_add = True ) [EOL] _LOGGER . debug ( [string] , host , port , password ) [EOL] return True [EOL] except requests . exceptions . RequestException : [EOL] _LOGGER . error ( [string] , host , port , password ) [EOL] [EOL] return False [EOL] [EOL] [EOL] class AFSAPIDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_url , password ) : [EOL] [docstring] [EOL] self . _device_url = device_url [EOL] self . _password = password [EOL] self . _state = STATE_UNKNOWN [EOL] [EOL] self . _name = None [EOL] self . _title = None [EOL] self . _artist = None [EOL] self . _album_name = None [EOL] self . _mute = None [EOL] self . _source = None [EOL] self . _source_list = None [EOL] self . _media_image_url = None [EOL] [EOL] [comment] [EOL] @ property def fs_device ( self ) : [EOL] [docstring] [EOL] from afsapi import AFSAPI [EOL] [EOL] return AFSAPI ( self . _device_url , self . _password ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _title [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _artist [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _album_name [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FRONTIER_SILICON [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] [comment] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _source_list [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _media_image_url [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] fs_device = self . fs_device [EOL] [EOL] if not self . _name : [EOL] self . _name = yield from fs_device . get_friendly_name ( ) [EOL] [EOL] if not self . _source_list : [EOL] self . _source_list = yield from fs_device . get_mode_list ( ) [EOL] [EOL] status = yield from fs_device . get_play_status ( ) [EOL] self . _state = { [string] : STATE_PLAYING , [string] : STATE_PAUSED , [string] : STATE_OFF , [string] : STATE_UNKNOWN , None : STATE_OFF , } . get ( status , STATE_UNKNOWN ) [EOL] [EOL] if self . _state != STATE_OFF : [EOL] info_name = yield from fs_device . get_play_name ( ) [EOL] info_text = yield from fs_device . get_play_text ( ) [EOL] [EOL] self . _title = [string] . join ( filter ( None , [ info_name , info_text ] ) ) [EOL] self . _artist = yield from fs_device . get_play_artist ( ) [EOL] self . _album_name = yield from fs_device . get_play_album ( ) [EOL] [EOL] self . _source = yield from fs_device . get_mode ( ) [EOL] self . _mute = yield from fs_device . get_mute ( ) [EOL] self . _media_image_url = yield from fs_device . get_play_graphic ( ) [EOL] else : [EOL] self . _title = None [EOL] self . _artist = None [EOL] self . _album_name = None [EOL] [EOL] self . _source = None [EOL] self . _mute = None [EOL] self . _media_image_url = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ asyncio . coroutine def async_turn_on ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . set_power ( True ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . set_power ( False ) [EOL] [EOL] @ asyncio . coroutine def async_media_play ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . play ( ) [EOL] [EOL] @ asyncio . coroutine def async_media_pause ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . pause ( ) [EOL] [EOL] @ asyncio . coroutine def async_media_play_pause ( self ) : [EOL] [docstring] [EOL] if [string] in self . _state : [EOL] yield from self . fs_device . pause ( ) [EOL] else : [EOL] yield from self . fs_device . play ( ) [EOL] [EOL] @ asyncio . coroutine def async_media_stop ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . pause ( ) [EOL] [EOL] @ asyncio . coroutine def async_media_previous_track ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . rewind ( ) [EOL] [EOL] @ asyncio . coroutine def async_media_next_track ( self ) : [EOL] [docstring] [EOL] yield from self . fs_device . forward ( ) [EOL] [EOL] [comment] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _mute [EOL] [EOL] @ asyncio . coroutine def async_mute_volume ( self , mute ) : [EOL] [docstring] [EOL] yield from self . fs_device . set_mute ( mute ) [EOL] [EOL] [comment] [EOL] @ asyncio . coroutine def async_volume_up ( self ) : [EOL] [docstring] [EOL] volume = yield from self . fs_device . get_volume ( ) [EOL] yield from self . fs_device . set_volume ( volume + [number] ) [EOL] [EOL] @ asyncio . coroutine def async_volume_down ( self ) : [EOL] [docstring] [EOL] volume = yield from self . fs_device . get_volume ( ) [EOL] yield from self . fs_device . set_volume ( volume - [number] ) [EOL] [EOL] @ asyncio . coroutine def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] yield from self . fs_device . set_volume ( volume ) [EOL] [EOL] @ asyncio . coroutine def async_select_source ( self , source ) : [EOL] [docstring] [EOL] yield from self . fs_device . set_mode ( source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components import mqtt [EOL] from homeassistant . const import ( CONF_NAME , CONF_OPTIMISTIC , CONF_STATE , STATE_ON , STATE_OFF , CONF_PAYLOAD_OFF , CONF_PAYLOAD_ON ) [EOL] from homeassistant . components . mqtt import ( CONF_AVAILABILITY_TOPIC , CONF_STATE_TOPIC , CONF_COMMAND_TOPIC , CONF_PAYLOAD_AVAILABLE , CONF_PAYLOAD_NOT_AVAILABLE , CONF_QOS , CONF_RETAIN , MqttAvailability ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . typing import HomeAssistantType , ConfigType [EOL] from homeassistant . components . fan import ( SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , FanEntity , SUPPORT_SET_SPEED , SUPPORT_OSCILLATE , SPEED_OFF , ATTR_SPEED ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_STATE_VALUE_TEMPLATE = [string] [EOL] CONF_SPEED_STATE_TOPIC = [string] [EOL] CONF_SPEED_COMMAND_TOPIC = [string] [EOL] CONF_SPEED_VALUE_TEMPLATE = [string] [EOL] CONF_OSCILLATION_STATE_TOPIC = [string] [EOL] CONF_OSCILLATION_COMMAND_TOPIC = [string] [EOL] CONF_OSCILLATION_VALUE_TEMPLATE = [string] [EOL] CONF_PAYLOAD_OSCILLATION_ON = [string] [EOL] CONF_PAYLOAD_OSCILLATION_OFF = [string] [EOL] CONF_PAYLOAD_LOW_SPEED = [string] [EOL] CONF_PAYLOAD_MEDIUM_SPEED = [string] [EOL] CONF_PAYLOAD_HIGH_SPEED = [string] [EOL] CONF_SPEED_LIST = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PAYLOAD_ON = [string] [EOL] DEFAULT_PAYLOAD_OFF = [string] [EOL] DEFAULT_OPTIMISTIC = False [EOL] [EOL] OSCILLATE_ON_PAYLOAD = [string] [EOL] OSCILLATE_OFF_PAYLOAD = [string] [EOL] [EOL] OSCILLATION = [string] [EOL] [EOL] PLATFORM_SCHEMA = mqtt . MQTT_RW_PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_STATE_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_SPEED_STATE_TOPIC ) : mqtt . valid_subscribe_topic , vol . Optional ( CONF_SPEED_COMMAND_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_SPEED_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_OSCILLATION_STATE_TOPIC ) : mqtt . valid_subscribe_topic , vol . Optional ( CONF_OSCILLATION_COMMAND_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_OSCILLATION_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_PAYLOAD_ON , default = DEFAULT_PAYLOAD_ON ) : cv . string , vol . Optional ( CONF_PAYLOAD_OFF , default = DEFAULT_PAYLOAD_OFF ) : cv . string , vol . Optional ( CONF_PAYLOAD_OSCILLATION_ON , default = DEFAULT_PAYLOAD_ON ) : cv . string , vol . Optional ( CONF_PAYLOAD_OSCILLATION_OFF , default = DEFAULT_PAYLOAD_OFF ) : cv . string , vol . Optional ( CONF_PAYLOAD_LOW_SPEED , default = SPEED_LOW ) : cv . string , vol . Optional ( CONF_PAYLOAD_MEDIUM_SPEED , default = SPEED_MEDIUM ) : cv . string , vol . Optional ( CONF_PAYLOAD_HIGH_SPEED , default = SPEED_HIGH ) : cv . string , vol . Optional ( CONF_SPEED_LIST , default = [ SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH ] ) : cv . ensure_list , vol . Optional ( CONF_OPTIMISTIC , default = DEFAULT_OPTIMISTIC ) : cv . boolean , } ) . extend ( mqtt . MQTT_AVAILABILITY_SCHEMA . schema ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] config = PLATFORM_SCHEMA ( discovery_info ) [EOL] [EOL] async_add_entities ( [ MqttFan ( config . get ( CONF_NAME ) , { key : config . get ( key ) for key in ( CONF_STATE_TOPIC , CONF_COMMAND_TOPIC , CONF_SPEED_STATE_TOPIC , CONF_SPEED_COMMAND_TOPIC , CONF_OSCILLATION_STATE_TOPIC , CONF_OSCILLATION_COMMAND_TOPIC , ) } , { CONF_STATE : config . get ( CONF_STATE_VALUE_TEMPLATE ) , ATTR_SPEED : config . get ( CONF_SPEED_VALUE_TEMPLATE ) , OSCILLATION : config . get ( CONF_OSCILLATION_VALUE_TEMPLATE ) } , config . get ( CONF_QOS ) , config . get ( CONF_RETAIN ) , { STATE_ON : config . get ( CONF_PAYLOAD_ON ) , STATE_OFF : config . get ( CONF_PAYLOAD_OFF ) , OSCILLATE_ON_PAYLOAD : config . get ( CONF_PAYLOAD_OSCILLATION_ON ) , OSCILLATE_OFF_PAYLOAD : config . get ( CONF_PAYLOAD_OSCILLATION_OFF ) , SPEED_LOW : config . get ( CONF_PAYLOAD_LOW_SPEED ) , SPEED_MEDIUM : config . get ( CONF_PAYLOAD_MEDIUM_SPEED ) , SPEED_HIGH : config . get ( CONF_PAYLOAD_HIGH_SPEED ) , } , config . get ( CONF_SPEED_LIST ) , config . get ( CONF_OPTIMISTIC ) , config . get ( CONF_AVAILABILITY_TOPIC ) , config . get ( CONF_PAYLOAD_AVAILABLE ) , config . get ( CONF_PAYLOAD_NOT_AVAILABLE ) , ) ] ) [EOL] [EOL] [EOL] class MqttFan ( MqttAvailability , FanEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , topic , templates , qos , retain , payload , speed_list , optimistic , availability_topic , payload_available , payload_not_available ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( availability_topic , qos , payload_available , payload_not_available ) [EOL] self . _name = name [EOL] self . _topic = topic [EOL] self . _qos = qos [EOL] self . _retain = retain [EOL] self . _payload = payload [EOL] self . _templates = templates [EOL] self . _speed_list = speed_list [EOL] self . _optimistic = optimistic or topic [ CONF_STATE_TOPIC ] is None [EOL] self . _optimistic_oscillation = ( optimistic or topic [ CONF_OSCILLATION_STATE_TOPIC ] is None ) [EOL] self . _optimistic_speed = ( optimistic or topic [ CONF_SPEED_STATE_TOPIC ] is None ) [EOL] self . _state = False [EOL] self . _speed = None [EOL] self . _oscillation = None [EOL] self . _supported_features = [number] [EOL] self . _supported_features |= ( topic [ CONF_OSCILLATION_STATE_TOPIC ] is not None and SUPPORT_OSCILLATE ) [EOL] self . _supported_features |= ( topic [ CONF_SPEED_STATE_TOPIC ] is not None and SUPPORT_SET_SPEED ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] [EOL] templates = { } [EOL] for key , tpl in list ( self . _templates . items ( ) ) : [EOL] if tpl is None : [EOL] templates [ key ] = lambda value : value [EOL] else : [EOL] tpl . hass = self . hass [EOL] templates [ key ] = tpl . async_render_with_possible_json_value [EOL] [EOL] @ callback def state_received ( topic , payload , qos ) : [EOL] [docstring] [EOL] payload = templates [ CONF_STATE ] ( payload ) [EOL] if payload == self . _payload [ STATE_ON ] : [EOL] self . _state = True [EOL] elif payload == self . _payload [ STATE_OFF ] : [EOL] self . _state = False [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] if self . _topic [ CONF_STATE_TOPIC ] is not None : [EOL] await mqtt . async_subscribe ( self . hass , self . _topic [ CONF_STATE_TOPIC ] , state_received , self . _qos ) [EOL] [EOL] @ callback def speed_received ( topic , payload , qos ) : [EOL] [docstring] [EOL] payload = templates [ ATTR_SPEED ] ( payload ) [EOL] if payload == self . _payload [ SPEED_LOW ] : [EOL] self . _speed = SPEED_LOW [EOL] elif payload == self . _payload [ SPEED_MEDIUM ] : [EOL] self . _speed = SPEED_MEDIUM [EOL] elif payload == self . _payload [ SPEED_HIGH ] : [EOL] self . _speed = SPEED_HIGH [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] if self . _topic [ CONF_SPEED_STATE_TOPIC ] is not None : [EOL] await mqtt . async_subscribe ( self . hass , self . _topic [ CONF_SPEED_STATE_TOPIC ] , speed_received , self . _qos ) [EOL] self . _speed = SPEED_OFF [EOL] [EOL] @ callback def oscillation_received ( topic , payload , qos ) : [EOL] [docstring] [EOL] payload = templates [ OSCILLATION ] ( payload ) [EOL] if payload == self . _payload [ OSCILLATE_ON_PAYLOAD ] : [EOL] self . _oscillation = True [EOL] elif payload == self . _payload [ OSCILLATE_OFF_PAYLOAD ] : [EOL] self . _oscillation = False [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] if self . _topic [ CONF_OSCILLATION_STATE_TOPIC ] is not None : [EOL] await mqtt . async_subscribe ( self . hass , self . _topic [ CONF_OSCILLATION_STATE_TOPIC ] , oscillation_received , self . _qos ) [EOL] self . _oscillation = False [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return self . _optimistic [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return self . _speed_list [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] return self . _speed [EOL] [EOL] @ property def oscillating ( self ) : [EOL] [docstring] [EOL] return self . _oscillation [EOL] [EOL] async def async_turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] mqtt . async_publish ( self . hass , self . _topic [ CONF_COMMAND_TOPIC ] , self . _payload [ STATE_ON ] , self . _qos , self . _retain ) [EOL] if speed : [EOL] await self . async_set_speed ( speed ) [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] mqtt . async_publish ( self . hass , self . _topic [ CONF_COMMAND_TOPIC ] , self . _payload [ STATE_OFF ] , self . _qos , self . _retain ) [EOL] [EOL] async def async_set_speed ( self , speed ) : [EOL] [docstring] [EOL] if self . _topic [ CONF_SPEED_COMMAND_TOPIC ] is None : [EOL] return [EOL] [EOL] if speed == SPEED_LOW : [EOL] mqtt_payload = self . _payload [ SPEED_LOW ] [EOL] elif speed == SPEED_MEDIUM : [EOL] mqtt_payload = self . _payload [ SPEED_MEDIUM ] [EOL] elif speed == SPEED_HIGH : [EOL] mqtt_payload = self . _payload [ SPEED_HIGH ] [EOL] else : [EOL] mqtt_payload = speed [EOL] [EOL] mqtt . async_publish ( self . hass , self . _topic [ CONF_SPEED_COMMAND_TOPIC ] , mqtt_payload , self . _qos , self . _retain ) [EOL] [EOL] if self . _optimistic_speed : [EOL] self . _speed = speed [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_oscillate ( self , oscillating ) : [EOL] [docstring] [EOL] if self . _topic [ CONF_OSCILLATION_COMMAND_TOPIC ] is None : [EOL] return [EOL] [EOL] if oscillating is False : [EOL] payload = self . _payload [ OSCILLATE_OFF_PAYLOAD ] [EOL] else : [EOL] payload = self . _payload [ OSCILLATE_ON_PAYLOAD ] [EOL] [EOL] mqtt . async_publish ( self . hass , self . _topic [ CONF_OSCILLATION_COMMAND_TOPIC ] , payload , self . _qos , self . _retain ) [EOL] [EOL] if self . _optimistic_oscillation : [EOL] self . _oscillation = oscillating [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import api [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarm_control_panel import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PASSWORD , CONF_USERNAME , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] [EOL] def no_application_protocol ( value ) : [EOL] [docstring] [EOL] protocol_separator = [string] [EOL] if not value or protocol_separator in value : [EOL] raise vol . Invalid ( [string] . format ( protocol_separator ) ) [EOL] [EOL] return value [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : vol . All ( cv . string , no_application_protocol ) , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] host = config . get ( CONF_HOST ) [EOL] [EOL] url = [string] . format ( host ) [EOL] ialarm = IAlarmPanel ( name , username , password , url ) [EOL] add_entities ( [ ialarm ] , True ) [EOL] [EOL] [EOL] class IAlarmPanel ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , username , password , url ) : [EOL] [docstring] [EOL] from pyialarm import IAlarm [EOL] [EOL] self . _name = name [EOL] self . _username = username [EOL] self . _password = password [EOL] self . _url = url [EOL] self . _state = None [EOL] self . _client = IAlarm ( username , password , url ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] status = self . _client . get_status ( ) [EOL] _LOGGER . debug ( [string] , status ) [EOL] if status : [EOL] status = int ( status ) [EOL] [EOL] if status == self . _client . DISARMED : [EOL] state = STATE_ALARM_DISARMED [EOL] elif status == self . _client . ARMED_AWAY : [EOL] state = STATE_ALARM_ARMED_AWAY [EOL] elif status == self . _client . ARMED_STAY : [EOL] state = STATE_ALARM_ARMED_HOME [EOL] else : [EOL] state = None [EOL] [EOL] self . _state = state [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . disarm ( ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . arm_away ( ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . arm_stay ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import api [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . abode import CONF_ATTRIBUTION , AbodeDevice [EOL] from homeassistant . components . abode import DOMAIN as ABODE_DOMAIN [EOL] from homeassistant . components . alarm_control_panel import AlarmControlPanel [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ICON = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] data = hass . data [ ABODE_DOMAIN ] [EOL] [EOL] alarm_devices = [ AbodeAlarm ( data , data . abode . get_alarm ( ) , data . name ) ] [EOL] [EOL] data . devices . extend ( alarm_devices ) [EOL] [EOL] add_entities ( alarm_devices ) [EOL] [EOL] [EOL] class AbodeAlarm ( AbodeDevice , AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , device , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( data , device ) [EOL] self . _name = name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . is_standby : [EOL] state = STATE_ALARM_DISARMED [EOL] elif self . _device . is_away : [EOL] state = STATE_ALARM_ARMED_AWAY [EOL] elif self . _device . is_home : [EOL] state = STATE_ALARM_ARMED_HOME [EOL] else : [EOL] state = None [EOL] return state [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] self . _device . set_standby ( ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] self . _device . set_home ( ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] self . _device . set_away ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name or super ( ) . name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , [string] : self . _device . device_id , [string] : self . _device . battery , [string] : self . _device . is_cellular , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Generator [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import unittest [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] [EOL] from homeassistant . core import EVENT_HOMEASSISTANT_CLOSE [EOL] from homeassistant . setup import async_setup_component [EOL] import homeassistant . helpers . aiohttp_client as client [EOL] from homeassistant . util . async_ import run_callback_threadsafe [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] @ pytest . fixture def camera_client ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] assert hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } ) ) [EOL] [EOL] yield hass . loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] class TestHelpersAiohttpClient ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_get_clientsession_with_ssl ( self ) : [EOL] [docstring] [EOL] run_callback_threadsafe ( self . hass . loop , client . async_get_clientsession , self . hass ) . result ( ) [EOL] [EOL] assert isinstance ( self . hass . data [ client . DATA_CLIENTSESSION ] , aiohttp . ClientSession ) [EOL] assert isinstance ( self . hass . data [ client . DATA_CONNECTOR ] , aiohttp . TCPConnector ) [EOL] [EOL] def test_get_clientsession_without_ssl ( self ) : [EOL] [docstring] [EOL] run_callback_threadsafe ( self . hass . loop , client . async_get_clientsession , self . hass , False ) . result ( ) [EOL] [EOL] assert isinstance ( self . hass . data [ client . DATA_CLIENTSESSION_NOTVERIFY ] , aiohttp . ClientSession ) [EOL] assert isinstance ( self . hass . data [ client . DATA_CONNECTOR_NOTVERIFY ] , aiohttp . TCPConnector ) [EOL] [EOL] def test_create_clientsession_with_ssl_and_cookies ( self ) : [EOL] [docstring] [EOL] def _async_helper ( ) : [EOL] return client . async_create_clientsession ( self . hass , cookies = { [string] : True } ) [EOL] [EOL] session = run_callback_threadsafe ( self . hass . loop , _async_helper , ) . result ( ) [EOL] [EOL] assert isinstance ( session , aiohttp . ClientSession ) [EOL] assert isinstance ( self . hass . data [ client . DATA_CONNECTOR ] , aiohttp . TCPConnector ) [EOL] [EOL] def test_create_clientsession_without_ssl_and_cookies ( self ) : [EOL] [docstring] [EOL] def _async_helper ( ) : [EOL] return client . async_create_clientsession ( self . hass , False , cookies = { [string] : True } ) [EOL] [EOL] session = run_callback_threadsafe ( self . hass . loop , _async_helper , ) . result ( ) [EOL] [EOL] assert isinstance ( session , aiohttp . ClientSession ) [EOL] assert isinstance ( self . hass . data [ client . DATA_CONNECTOR_NOTVERIFY ] , aiohttp . TCPConnector ) [EOL] [EOL] def test_get_clientsession_cleanup ( self ) : [EOL] [docstring] [EOL] run_callback_threadsafe ( self . hass . loop , client . async_get_clientsession , self . hass ) . result ( ) [EOL] [EOL] assert isinstance ( self . hass . data [ client . DATA_CLIENTSESSION ] , aiohttp . ClientSession ) [EOL] assert isinstance ( self . hass . data [ client . DATA_CONNECTOR ] , aiohttp . TCPConnector ) [EOL] [EOL] self . hass . bus . fire ( EVENT_HOMEASSISTANT_CLOSE ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . data [ client . DATA_CLIENTSESSION ] . closed [EOL] assert self . hass . data [ client . DATA_CONNECTOR ] . closed [EOL] [EOL] def test_get_clientsession_cleanup_without_ssl ( self ) : [EOL] [docstring] [EOL] run_callback_threadsafe ( self . hass . loop , client . async_get_clientsession , self . hass , False ) . result ( ) [EOL] [EOL] assert isinstance ( self . hass . data [ client . DATA_CLIENTSESSION_NOTVERIFY ] , aiohttp . ClientSession ) [EOL] assert isinstance ( self . hass . data [ client . DATA_CONNECTOR_NOTVERIFY ] , aiohttp . TCPConnector ) [EOL] [EOL] self . hass . bus . fire ( EVENT_HOMEASSISTANT_CLOSE ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . data [ client . DATA_CLIENTSESSION_NOTVERIFY ] . closed [EOL] assert self . hass . data [ client . DATA_CONNECTOR_NOTVERIFY ] . closed [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_aiohttp_proxy_stream ( aioclient_mock , camera_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , content = [string] ) [EOL] [EOL] resp = yield from camera_client . get ( [string] ) [EOL] [EOL] assert resp . status == [number] [EOL] assert aioclient_mock . call_count == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_aiohttp_proxy_stream_timeout ( aioclient_mock , camera_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , exc = asyncio . TimeoutError ( ) ) [EOL] [EOL] resp = yield from camera_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_aiohttp_proxy_stream_client_err ( aioclient_mock , camera_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , exc = aiohttp . ClientError ( ) ) [EOL] [EOL] resp = yield from camera_client . get ( [string] ) [EOL] assert resp . status == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any , Union [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] import aiohttp [EOL] [EOL] import homeassistant . components . rest_command as rc [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component ) [EOL] [EOL] [EOL] class TestRestCommandSetup : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] self . config = { rc . DOMAIN : { [string] : { [string] : [string] } } } [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_component ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] def test_setup_component_timeout ( self ) : [EOL] [docstring] [EOL] self . config [ rc . DOMAIN ] [ [string] ] [ [string] ] = [number] [EOL] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] def test_setup_component_test_service ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] assert self . hass . services . has_service ( rc . DOMAIN , [string] ) [EOL] [EOL] [EOL] class TestRestCommandComponent : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . url = [string] [EOL] self . config = { rc . DOMAIN : { [string] : { [string] : self . url , [string] : [string] , } , [string] : { [string] : self . url , [string] : [string] , } , [string] : { [string] : self . url , [string] : [string] , } , [string] : { [string] : self . url , [string] : [string] , } , } } [EOL] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_tests ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] assert self . hass . services . has_service ( rc . DOMAIN , [string] ) [EOL] assert self . hass . services . has_service ( rc . DOMAIN , [string] ) [EOL] assert self . hass . services . has_service ( rc . DOMAIN , [string] ) [EOL] assert self . hass . services . has_service ( rc . DOMAIN , [string] ) [EOL] [EOL] def test_rest_command_timeout ( self , aioclient_mock ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . get ( self . url , exc = asyncio . TimeoutError ( ) ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] def test_rest_command_aiohttp_error ( self , aioclient_mock ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . get ( self . url , exc = aiohttp . ClientError ( ) ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] def test_rest_command_http_error ( self , aioclient_mock ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . get ( self . url , status = [number] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] def test_rest_command_auth ( self , aioclient_mock ) : [EOL] [docstring] [EOL] data = { [string] : [string] , [string] : [string] , } [EOL] self . config [ rc . DOMAIN ] [ [string] ] . update ( data ) [EOL] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . get ( self . url , content = [string] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] def test_rest_command_form_data ( self , aioclient_mock ) : [EOL] [docstring] [EOL] data = { [string] : [string] } [EOL] self . config [ rc . DOMAIN ] [ [string] ] . update ( data ) [EOL] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . post ( self . url , content = [string] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] == [string] [EOL] [EOL] def test_rest_command_get ( self , aioclient_mock ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . get ( self . url , content = [string] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] def test_rest_command_delete ( self , aioclient_mock ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . delete ( self . url , content = [string] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] def test_rest_command_post ( self , aioclient_mock ) : [EOL] [docstring] [EOL] data = { [string] : [string] , } [EOL] self . config [ rc . DOMAIN ] [ [string] ] . update ( data ) [EOL] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . post ( self . url , content = [string] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] == [string] [EOL] [EOL] def test_rest_command_put ( self , aioclient_mock ) : [EOL] [docstring] [EOL] data = { [string] : [string] , } [EOL] self . config [ rc . DOMAIN ] [ [string] ] . update ( data ) [EOL] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , self . config ) [EOL] [EOL] aioclient_mock . put ( self . url , content = [string] ) [EOL] [EOL] self . hass . services . call ( rc . DOMAIN , [string] , { } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] == [string] [EOL] [EOL] def test_rest_command_headers ( self , aioclient_mock ) : [EOL] [docstring] [EOL] header_config_variations = { rc . DOMAIN : { [string] : { } , [string] : { [string] : [string] } , [string] : { [string] : { [string] : [string] , [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : [string] } , [string] : { [string] : { [string] : [string] , aiohttp . hdrs . CONTENT_TYPE : [string] } , [string] : [string] } } } [EOL] [EOL] [comment] [EOL] for variation in header_config_variations [ rc . DOMAIN ] . values ( ) : [EOL] variation . update ( { [string] : self . url , [string] : [string] , [string] : [string] } ) [EOL] [EOL] with assert_setup_component ( [number] ) : [EOL] setup_component ( self . hass , rc . DOMAIN , header_config_variations ) [EOL] [EOL] [comment] [EOL] aioclient_mock . post ( self . url , content = [string] ) [EOL] [EOL] for test_service in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] self . hass . services . call ( rc . DOMAIN , test_service , { } ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] is None [EOL] [EOL] [comment] [EOL] assert len ( aioclient_mock . mock_calls [ [number] ] [ [number] ] ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( aiohttp . hdrs . CONTENT_TYPE ) == [string] [EOL] [EOL] [comment] [EOL] assert len ( aioclient_mock . mock_calls [ [number] ] [ [number] ] ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( [string] ) == [string] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] assert len ( aioclient_mock . mock_calls [ [number] ] [ [number] ] ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( aiohttp . hdrs . CONTENT_TYPE ) == [string] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] assert len ( aioclient_mock . mock_calls [ [number] ] [ [number] ] ) == [number] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( aiohttp . hdrs . CONTENT_TYPE ) == [string] [EOL] assert aioclient_mock . mock_calls [ [number] ] [ [number] ] . get ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[unknown,builtins.str],builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[unknown,builtins.str],builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[unknown,builtins.str],builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . components . auth import indieauth [EOL] [EOL] from tests . common import mock_coro [EOL] from tests . test_util . aiohttp import AiohttpClientMocker [EOL] [EOL] [EOL] @ pytest . fixture def mock_session ( ) : [EOL] [docstring] [EOL] mocker = AiohttpClientMocker ( ) [EOL] [EOL] with patch ( [string] , side_effect = lambda * args , ** kwargs : mocker . create_session ( asyncio . get_event_loop ( ) ) ) : [EOL] yield mocker [EOL] [EOL] [EOL] def test_client_id_scheme ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_path ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_fragment ( ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_user_pass ( ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_hostname ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_parse_url_lowercase_host ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_url ( [string] ) . path == [string] [EOL] assert indieauth . _parse_url ( [string] ) . hostname == [string] [EOL] [EOL] parts = indieauth . _parse_url ( [string] ) [EOL] assert parts . netloc == [string] [EOL] assert parts . path == [string] [EOL] [EOL] [EOL] def test_parse_url_path ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_url ( [string] ) . path == [string] [EOL] [EOL] [EOL] async def test_verify_redirect_uri ( ) : [EOL] [docstring] [EOL] assert await indieauth . verify_redirect_uri ( None , [string] , [string] ) [EOL] [EOL] with patch . object ( indieauth , [string] , side_effect = lambda * _ : mock_coro ( [ ] ) ) : [EOL] [comment] [EOL] assert not await indieauth . verify_redirect_uri ( None , [string] , [string] ) [EOL] [EOL] [comment] [EOL] assert not await indieauth . verify_redirect_uri ( None , [string] , [string] ) [EOL] [EOL] [comment] [EOL] assert not await indieauth . verify_redirect_uri ( None , [string] , [string] ) [EOL] [EOL] [EOL] async def test_find_link_tag ( hass , mock_session ) : [EOL] [docstring] [EOL] mock_session . get ( [string] , text = [string] ) [EOL] redirect_uris = await indieauth . fetch_redirect_uris ( hass , [string] ) [EOL] [EOL] assert redirect_uris == [ [string] , [string] , ] [EOL] [EOL] [EOL] async def test_find_link_tag_max_size ( hass , mock_session ) : [EOL] [docstring] [EOL] text = [string] . join ( [ [string] , ( [string] * [number] * [number] ) , [string] , ] ) [EOL] mock_session . get ( [string] , text = text ) [EOL] redirect_uris = await indieauth . fetch_redirect_uris ( hass , [string] ) [EOL] [EOL] assert redirect_uris == [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] from collections import namedtuple [EOL] from unittest . mock import patch , MagicMock [EOL] import pytest [EOL] from homeassistant . const import ( DEVICE_CLASS_TEMPERATURE , DEVICE_CLASS_HUMIDITY , ATTR_ATTRIBUTION ) [EOL] from homeassistant . components . sensor import arlo [EOL] from homeassistant . components . arlo import DATA_ARLO [EOL] [EOL] [EOL] def _get_named_tuple ( input_dict ) : [EOL] return namedtuple ( [string] , input_dict . keys ( ) ) ( * input_dict . values ( ) ) [EOL] [EOL] [EOL] def _get_sensor ( name = [string] , sensor_type = [string] , data = None ) : [EOL] if data is None : [EOL] data = { } [EOL] return arlo . ArloSensor ( name , data , sensor_type ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def default_sensor ( ) : [EOL] [docstring] [EOL] return _get_sensor ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def battery_sensor ( ) : [EOL] [docstring] [EOL] data = _get_named_tuple ( { [string] : [number] } ) [EOL] return _get_sensor ( [string] , [string] , data ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def temperature_sensor ( ) : [EOL] [docstring] [EOL] return _get_sensor ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def humidity_sensor ( ) : [EOL] [docstring] [EOL] return _get_sensor ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def cameras_sensor ( ) : [EOL] [docstring] [EOL] data = _get_named_tuple ( { [string] : [ [number] , [number] ] } ) [EOL] return _get_sensor ( [string] , [string] , data ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def captured_sensor ( ) : [EOL] [docstring] [EOL] data = _get_named_tuple ( { [string] : [ [number] , [number] , [number] , [number] , [number] ] } ) [EOL] return _get_sensor ( [string] , [string] , data ) [EOL] [EOL] [EOL] class PlatformSetupFixture ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . sensors = None [EOL] self . update = False [EOL] [EOL] def add_entities ( self , sensors , update ) : [EOL] [docstring] [EOL] self . sensors = sensors [EOL] self . update = update [EOL] [EOL] [EOL] @ pytest . fixture ( ) def platform_setup ( ) : [EOL] [docstring] [EOL] return PlatformSetupFixture ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def sensor_with_hass_data ( default_sensor , hass ) : [EOL] [docstring] [EOL] hass . data = { } [EOL] default_sensor . hass = hass [EOL] return default_sensor [EOL] [EOL] [EOL] @ pytest . fixture ( ) def mock_dispatch ( ) : [EOL] [docstring] [EOL] target = [string] [EOL] with patch ( target , MagicMock ( ) ) as _mock : [EOL] yield _mock [EOL] [EOL] [EOL] def test_setup_with_no_data ( platform_setup , hass ) : [EOL] [docstring] [EOL] arlo . setup_platform ( hass , None , platform_setup . add_entities ) [EOL] assert platform_setup . sensors is None [EOL] assert not platform_setup . update [EOL] [EOL] [EOL] def test_setup_with_valid_data ( platform_setup , hass ) : [EOL] [docstring] [EOL] config = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] hass . data [ DATA_ARLO ] = _get_named_tuple ( { [string] : [ _get_named_tuple ( { [string] : [string] , [string] : [string] } ) ] , [string] : [ _get_named_tuple ( { [string] : [string] , [string] : [string] } ) ] } ) [EOL] [EOL] arlo . setup_platform ( hass , config , platform_setup . add_entities ) [EOL] assert len ( platform_setup . sensors ) == [number] [EOL] assert platform_setup . update [EOL] [EOL] [EOL] def test_sensor_name ( default_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . name == [string] [EOL] [EOL] [EOL] async def test_async_added_to_hass ( sensor_with_hass_data , mock_dispatch ) : [EOL] [docstring] [EOL] await sensor_with_hass_data . async_added_to_hass ( ) [EOL] assert len ( mock_dispatch . mock_calls ) == [number] [EOL] kall = mock_dispatch . call_args [EOL] args , kwargs = kall [EOL] assert len ( args ) == [number] [EOL] assert args [ [number] ] == sensor_with_hass_data . hass [EOL] assert args [ [number] ] == [string] [EOL] assert not kwargs [EOL] [EOL] [EOL] def test_sensor_state_default ( default_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . state is None [EOL] [EOL] [EOL] def test_sensor_icon_battery ( battery_sensor ) : [EOL] [docstring] [EOL] assert battery_sensor . icon == [string] [EOL] [EOL] [EOL] def test_sensor_icon ( temperature_sensor ) : [EOL] [docstring] [EOL] assert temperature_sensor . icon == [string] [EOL] [EOL] [EOL] def test_unit_of_measure ( default_sensor , battery_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . unit_of_measurement is None [EOL] assert battery_sensor . unit_of_measurement == [string] [EOL] [EOL] [EOL] def test_device_class ( default_sensor , temperature_sensor , humidity_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . device_class is None [EOL] assert temperature_sensor . device_class == DEVICE_CLASS_TEMPERATURE [EOL] assert humidity_sensor . device_class == DEVICE_CLASS_HUMIDITY [EOL] [EOL] [EOL] def test_update_total_cameras ( cameras_sensor ) : [EOL] [docstring] [EOL] cameras_sensor . update ( ) [EOL] assert cameras_sensor . state == [number] [EOL] [EOL] [EOL] def test_update_captured_today ( captured_sensor ) : [EOL] [docstring] [EOL] captured_sensor . update ( ) [EOL] assert captured_sensor . state == [number] [EOL] [EOL] [EOL] def _test_attributes ( sensor_type ) : [EOL] data = _get_named_tuple ( { [string] : [string] } ) [EOL] sensor = _get_sensor ( [string] , sensor_type , data ) [EOL] attrs = sensor . device_state_attributes [EOL] assert attrs . get ( ATTR_ATTRIBUTION ) == [string] [EOL] assert attrs . get ( [string] ) == [string] [EOL] assert attrs . get ( [string] ) == [string] [EOL] [EOL] [EOL] def test_state_attributes ( ) : [EOL] [docstring] [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] [EOL] [EOL] def test_attributes_total_cameras ( cameras_sensor ) : [EOL] [docstring] [EOL] attrs = cameras_sensor . device_state_attributes [EOL] assert attrs . get ( ATTR_ATTRIBUTION ) == [string] [EOL] assert attrs . get ( [string] ) == [string] [EOL] assert attrs . get ( [string] ) is None [EOL] [EOL] [EOL] def _test_update ( sensor_type , key , value ) : [EOL] data = _get_named_tuple ( { key : value } ) [EOL] sensor = _get_sensor ( [string] , sensor_type , data ) [EOL] sensor . update ( ) [EOL] assert sensor . state == value [EOL] [EOL] [EOL] def test_update ( ) : [EOL] [docstring] [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from homeassistant . const import TEMP_CELSIUS , TEMP_FAHRENHEIT , STATE_OFF [EOL] from homeassistant . components . sensor import dyson [EOL] from tests . common import get_test_home_assistant [EOL] from libpurecoollink . dyson_pure_cool_link import DysonPureCoolLink [EOL] [EOL] [EOL] def _get_device_without_state ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( spec = DysonPureCoolLink ) [EOL] device . name = [string] [EOL] device . state = None [EOL] device . environmental_state = None [EOL] return device [EOL] [EOL] [EOL] def _get_with_state ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( ) [EOL] device . name = [string] [EOL] device . state = mock . Mock ( ) [EOL] device . state . filter_life = [number] [EOL] device . environmental_state = mock . Mock ( ) [EOL] device . environmental_state . dust = [number] [EOL] device . environmental_state . humidity = [number] [EOL] device . environmental_state . temperature = [number] [EOL] device . environmental_state . volatil_organic_compounds = [number] [EOL] [EOL] return device [EOL] [EOL] [EOL] def _get_with_standby_monitoring ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( ) [EOL] device . name = [string] [EOL] device . state = mock . Mock ( ) [EOL] device . state . filter_life = [number] [EOL] device . environmental_state = mock . Mock ( ) [EOL] device . environmental_state . dust = [number] [EOL] device . environmental_state . humidity = [number] [EOL] device . environmental_state . temperature = [number] [EOL] device . environmental_state . volatil_organic_compounds = [number] [EOL] [EOL] return device [EOL] [EOL] [EOL] class DysonTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_component_with_no_devices ( self ) : [EOL] [docstring] [EOL] self . hass . data [ dyson . DYSON_DEVICES ] = [ ] [EOL] add_entities = mock . MagicMock ( ) [EOL] dyson . setup_platform ( self . hass , None , add_entities ) [EOL] add_entities . assert_called_with ( [ ] ) [EOL] [EOL] def test_setup_component ( self ) : [EOL] [docstring] [EOL] def _add_device ( devices ) : [EOL] assert len ( devices ) == [number] [EOL] assert devices [ [number] ] . name == [string] [EOL] assert devices [ [number] ] . name == [string] [EOL] assert devices [ [number] ] . name == [string] [EOL] assert devices [ [number] ] . name == [string] [EOL] assert devices [ [number] ] . name == [string] [EOL] [EOL] device_fan = _get_device_without_state ( ) [EOL] device_non_fan = _get_with_state ( ) [EOL] self . hass . data [ dyson . DYSON_DEVICES ] = [ device_fan , device_non_fan ] [EOL] dyson . setup_platform ( self . hass , None , _add_device ) [EOL] [EOL] def test_dyson_filter_life_sensor ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonFilterLifeSensor ( self . hass , _get_device_without_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertIsNone ( sensor . state ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] sensor . on_message ( [string] ) [EOL] [EOL] def test_dyson_filter_life_sensor_with_values ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonFilterLifeSensor ( self . hass , _get_with_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , [number] ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] sensor . on_message ( [string] ) [EOL] [EOL] def test_dyson_dust_sensor ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonDustSensor ( self . hass , _get_device_without_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertIsNone ( sensor . state ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_dust_sensor_with_values ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonDustSensor ( self . hass , _get_with_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , [number] ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_humidity_sensor ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonHumiditySensor ( self . hass , _get_device_without_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertIsNone ( sensor . state ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_humidity_sensor_with_values ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonHumiditySensor ( self . hass , _get_with_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , [number] ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_humidity_standby_monitoring ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonHumiditySensor ( self . hass , _get_with_standby_monitoring ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , STATE_OFF ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_temperature_sensor ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonTemperatureSensor ( self . hass , _get_device_without_state ( ) , TEMP_CELSIUS ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertIsNone ( sensor . state ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_temperature_sensor_with_values ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonTemperatureSensor ( self . hass , _get_with_state ( ) , TEMP_CELSIUS ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , [number] ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] sensor = dyson . DysonTemperatureSensor ( self . hass , _get_with_state ( ) , TEMP_FAHRENHEIT ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , [number] ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_temperature_standby_monitoring ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonTemperatureSensor ( self . hass , _get_with_standby_monitoring ( ) , TEMP_CELSIUS ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , STATE_OFF ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_air_quality_sensor ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonAirQualitySensor ( self . hass , _get_device_without_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertIsNone ( sensor . state ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL] [EOL] def test_dyson_air_quality_sensor_with_values ( self ) : [EOL] [docstring] [EOL] sensor = dyson . DysonAirQualitySensor ( self . hass , _get_with_state ( ) ) [EOL] sensor . entity_id = [string] [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertEqual ( sensor . state , [number] ) [EOL] self . assertEqual ( sensor . unit_of_measurement , [string] ) [EOL] self . assertEqual ( sensor . name , [string] ) [EOL] self . assertEqual ( sensor . entity_id , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from aiohttp import web [EOL] from aiohttp . hdrs import X_FORWARDED_FOR [EOL] from ipaddress import ip_network [EOL] [EOL] from homeassistant . components . http . real_ip import setup_real_ip [EOL] from homeassistant . components . http . const import KEY_REAL_IP [EOL] [EOL] [EOL] async def mock_handler ( request ) : [EOL] [docstring] [EOL] return web . Response ( text = str ( request [ KEY_REAL_IP ] ) ) [EOL] [EOL] [EOL] async def test_ignore_x_forwarded_for ( aiohttp_client ) : [EOL] [docstring] [EOL] app = web . Application ( ) [EOL] app . router . add_get ( [string] , mock_handler ) [EOL] setup_real_ip ( app , False , [ ] ) [EOL] [EOL] mock_api_client = await aiohttp_client ( app ) [EOL] [EOL] resp = await mock_api_client . get ( [string] , headers = { X_FORWARDED_FOR : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . text ( ) [EOL] assert text != [string] [EOL] [EOL] [EOL] async def test_use_x_forwarded_for_without_trusted_proxy ( aiohttp_client ) : [EOL] [docstring] [EOL] app = web . Application ( ) [EOL] app . router . add_get ( [string] , mock_handler ) [EOL] setup_real_ip ( app , True , [ ] ) [EOL] [EOL] mock_api_client = await aiohttp_client ( app ) [EOL] [EOL] resp = await mock_api_client . get ( [string] , headers = { X_FORWARDED_FOR : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . text ( ) [EOL] assert text != [string] [EOL] [EOL] [EOL] async def test_use_x_forwarded_for_with_trusted_proxy ( aiohttp_client ) : [EOL] [docstring] [EOL] app = web . Application ( ) [EOL] app . router . add_get ( [string] , mock_handler ) [EOL] setup_real_ip ( app , True , [ ip_network ( [string] ) ] ) [EOL] [EOL] mock_api_client = await aiohttp_client ( app ) [EOL] [EOL] resp = await mock_api_client . get ( [string] , headers = { X_FORWARDED_FOR : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . text ( ) [EOL] assert text == [string] [EOL] [EOL] [EOL] async def test_use_x_forwarded_for_with_untrusted_proxy ( aiohttp_client ) : [EOL] [docstring] [EOL] app = web . Application ( ) [EOL] app . router . add_get ( [string] , mock_handler ) [EOL] setup_real_ip ( app , True , [ ip_network ( [string] ) ] ) [EOL] [EOL] mock_api_client = await aiohttp_client ( app ) [EOL] [EOL] resp = await mock_api_client . get ( [string] , headers = { X_FORWARDED_FOR : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . text ( ) [EOL] assert text != [string] [EOL] [EOL] [EOL] async def test_use_x_forwarded_for_with_spoofed_header ( aiohttp_client ) : [EOL] [docstring] [EOL] app = web . Application ( ) [EOL] app . router . add_get ( [string] , mock_handler ) [EOL] setup_real_ip ( app , True , [ ip_network ( [string] ) ] ) [EOL] [EOL] mock_api_client = await aiohttp_client ( app ) [EOL] [EOL] resp = await mock_api_client . get ( [string] , headers = { X_FORWARDED_FOR : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . text ( ) [EOL] assert text == [string] [EOL] [EOL] [EOL] async def test_use_x_forwarded_for_with_nonsense_header ( aiohttp_client ) : [EOL] [docstring] [EOL] app = web . Application ( ) [EOL] app . router . add_get ( [string] , mock_handler ) [EOL] setup_real_ip ( app , True , [ ip_network ( [string] ) ] ) [EOL] [EOL] mock_api_client = await aiohttp_client ( app ) [EOL] [EOL] resp = await mock_api_client . get ( [string] , headers = { X_FORWARDED_FOR : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . text ( ) [EOL] assert text == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , Generator [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from unittest import mock [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] [EOL] @ asyncio . coroutine def test_fetching_url ( aioclient_mock , hass , aiohttp_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] [EOL] assert resp . status == [number] [EOL] assert aioclient_mock . call_count == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_fetching_without_verify_ssl ( aioclient_mock , hass , aiohttp_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_fetching_url_with_verify_ssl ( aioclient_mock , hass , aiohttp_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_limit_refetch ( aioclient_mock , hass , aiohttp_client ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] aioclient_mock . get ( [string] , status = [number] ) [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , } } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] [EOL] with mock . patch ( [string] , side_effect = asyncio . TimeoutError ( ) ) : [EOL] resp = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp . status == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp . status == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp . status == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] resp = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp . status == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL] [EOL] [comment] [EOL] hass . states . async_remove ( [string] ) [EOL] resp = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp . status == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_camera_content_type ( aioclient_mock , hass , aiohttp_client ) : [EOL] [docstring] [EOL] svg_image = [string] [EOL] urlsvg = [string] [EOL] aioclient_mock . get ( urlsvg , text = svg_image ) [EOL] [EOL] cam_config_svg = { [string] : [string] , [string] : [string] , [string] : urlsvg , [string] : [string] , } [EOL] cam_config_normal = cam_config_svg . copy ( ) [EOL] cam_config_normal . pop ( [string] ) [EOL] cam_config_normal [ [string] ] = [string] [EOL] [EOL] yield from async_setup_component ( hass , [string] , { [string] : [ cam_config_svg , cam_config_normal ] } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] [EOL] resp_1 = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp_1 . status == [number] [EOL] assert resp_1 . content_type == [string] [EOL] body = yield from resp_1 . text ( ) [EOL] assert body == svg_image [EOL] [EOL] resp_2 = yield from client . get ( [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert resp_2 . status == [number] [EOL] assert resp_2 . content_type == [string] [EOL] body = yield from resp_2 . text ( ) [EOL] assert body == svg_image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from homeassistant . components . homekit . type_locks import Lock [EOL] from homeassistant . components . lock import DOMAIN [EOL] from homeassistant . const import ( ATTR_CODE , ATTR_ENTITY_ID , STATE_LOCKED , STATE_UNKNOWN , STATE_UNLOCKED ) [EOL] [EOL] from tests . common import async_mock_service [EOL] [EOL] [EOL] async def test_lock_unlock ( hass , hk_driver ) : [EOL] [docstring] [EOL] code = [string] [EOL] config = { ATTR_CODE : code } [EOL] entity_id = [string] [EOL] [EOL] hass . states . async_set ( entity_id , None ) [EOL] await hass . async_block_till_done ( ) [EOL] acc = Lock ( hass , hk_driver , [string] , entity_id , [number] , config ) [EOL] await hass . async_add_job ( acc . run ) [EOL] [EOL] assert acc . aid == [number] [EOL] assert acc . category == [number] [comment] [EOL] [EOL] assert acc . char_current_state . value == [number] [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] hass . states . async_set ( entity_id , STATE_LOCKED ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . char_current_state . value == [number] [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] hass . states . async_set ( entity_id , STATE_UNLOCKED ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . char_current_state . value == [number] [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] hass . states . async_set ( entity_id , STATE_UNKNOWN ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . char_current_state . value == [number] [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] hass . states . async_remove ( entity_id ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . char_current_state . value == [number] [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] [comment] [EOL] call_lock = async_mock_service ( hass , DOMAIN , [string] ) [EOL] call_unlock = async_mock_service ( hass , DOMAIN , [string] ) [EOL] [EOL] await hass . async_add_job ( acc . char_target_state . client_update_value , [number] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert call_lock [EOL] assert call_lock [ [number] ] . data [ ATTR_ENTITY_ID ] == entity_id [EOL] assert call_lock [ [number] ] . data [ ATTR_CODE ] == code [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] await hass . async_add_job ( acc . char_target_state . client_update_value , [number] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert call_unlock [EOL] assert call_unlock [ [number] ] . data [ ATTR_ENTITY_ID ] == entity_id [EOL] assert call_unlock [ [number] ] . data [ ATTR_CODE ] == code [EOL] assert acc . char_target_state . value == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { } , { ATTR_CODE : None } ] ) async def test_no_code ( hass , hk_driver , config ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] [EOL] hass . states . async_set ( entity_id , None ) [EOL] await hass . async_block_till_done ( ) [EOL] acc = Lock ( hass , hk_driver , [string] , entity_id , [number] , config ) [EOL] [EOL] [comment] [EOL] call_lock = async_mock_service ( hass , DOMAIN , [string] ) [EOL] [EOL] await hass . async_add_job ( acc . char_target_state . client_update_value , [number] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert call_lock [EOL] assert call_lock [ [number] ] . data [ ATTR_ENTITY_ID ] == entity_id [EOL] assert ATTR_CODE not in call_lock [ [number] ] . data [EOL] assert acc . char_target_state . value == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from homeassistant . helpers . entity_registry import RegistryEntry [EOL] from homeassistant . components . config import entity_registry [EOL] from tests . common import mock_registry , MockEntity , MockEntityPlatform [EOL] [EOL] [EOL] @ pytest . fixture def client ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( entity_registry . async_setup ( hass ) ) [EOL] yield hass . loop . run_until_complete ( hass_ws_client ( hass ) ) [EOL] [EOL] [EOL] async def test_get_entity ( hass , client ) : [EOL] [docstring] [EOL] mock_registry ( hass , { [string] : RegistryEntry ( entity_id = [string] , unique_id = [string] , platform = [string] , name = [string] ) , [string] : RegistryEntry ( entity_id = [string] , unique_id = [string] , platform = [string] , ) , } ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == { [string] : [string] , [string] : [string] } [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == { [string] : [string] , [string] : None } [EOL] [EOL] [EOL] async def test_update_entity_name ( hass , client ) : [EOL] [docstring] [EOL] mock_registry ( hass , { [string] : RegistryEntry ( entity_id = [string] , unique_id = [string] , platform = [string] , name = [string] ) } ) [EOL] platform = MockEntityPlatform ( hass ) [EOL] entity = MockEntity ( unique_id = [string] ) [EOL] await platform . async_add_entities ( [ entity ] ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . name == [string] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == { [string] : [string] , [string] : [string] } [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . name == [string] [EOL] [EOL] [EOL] async def test_update_entity_no_changes ( hass , client ) : [EOL] [docstring] [EOL] mock_registry ( hass , { [string] : RegistryEntry ( entity_id = [string] , unique_id = [string] , platform = [string] , name = [string] ) } ) [EOL] platform = MockEntityPlatform ( hass ) [EOL] entity = MockEntity ( unique_id = [string] ) [EOL] await platform . async_add_entities ( [ entity ] ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . name == [string] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == { [string] : [string] , [string] : [string] } [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . name == [string] [EOL] [EOL] [EOL] async def test_get_nonexisting_entity ( client ) : [EOL] [docstring] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert not msg [ [string] ] [EOL] [EOL] [EOL] async def test_update_nonexisting_entity ( client ) : [EOL] [docstring] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert not msg [ [string] ] [EOL] [EOL] [EOL] async def test_update_entity_id ( hass , client ) : [EOL] [docstring] [EOL] mock_registry ( hass , { [string] : RegistryEntry ( entity_id = [string] , unique_id = [string] , platform = [string] , ) } ) [EOL] platform = MockEntityPlatform ( hass ) [EOL] entity = MockEntity ( unique_id = [string] ) [EOL] await platform . async_add_entities ( [ entity ] ) [EOL] [EOL] assert hass . states . get ( [string] ) is not None [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == { [string] : [string] , [string] : None } [EOL] [EOL] assert hass . states . get ( [string] ) is None [EOL] assert hass . states . get ( [string] ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Generator [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import os [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . bootstrap import async_setup_component [EOL] from homeassistant . components import config [EOL] from homeassistant . components . config . hassbian import ( HassbianSuitesView , HassbianSuiteInstallView ) [EOL] [EOL] [EOL] def test_setup_check_env_prevents_load ( hass , loop ) : [EOL] [docstring] [EOL] with patch . dict ( os . environ , clear = True ) , patch . object ( config , [string] , [ [string] ] ) , patch ( [string] [string] ) as reg_view : [EOL] loop . run_until_complete ( async_setup_component ( hass , [string] , { } ) ) [EOL] assert [string] in hass . config . components [EOL] assert reg_view . called is False [EOL] [EOL] [EOL] def test_setup_check_env_works ( hass , loop ) : [EOL] [docstring] [EOL] with patch . dict ( os . environ , { [string] : [string] } ) , patch . object ( config , [string] , [ [string] ] ) , patch ( [string] [string] ) as reg_view : [EOL] loop . run_until_complete ( async_setup_component ( hass , [string] , { } ) ) [EOL] assert [string] in hass . config . components [EOL] assert len ( reg_view . mock_calls ) == [number] [EOL] assert isinstance ( reg_view . mock_calls [ [number] ] [ [number] ] [ [number] ] , HassbianSuitesView ) [EOL] assert isinstance ( reg_view . mock_calls [ [number] ] [ [number] ] [ [number] ] , HassbianSuiteInstallView ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_suites ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] with patch . dict ( os . environ , { [string] : [string] } ) , patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] resp = yield from client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] result = yield from resp . json ( ) [EOL] [EOL] assert [string] in result [EOL] info = result [ [string] ] [EOL] assert info [ [string] ] == [string] [EOL] assert info [ [string] ] == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_install_suite ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] with patch . dict ( os . environ , { [string] : [string] } ) , patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] resp = yield from client . post ( [string] ) [EOL] assert resp . status == [number] [EOL] result = yield from resp . json ( ) [EOL] [EOL] assert result == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import List , Dict , Any , Union , Type [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import socket [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import voluptuous as vol [EOL] import somecomfort [EOL] [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] from homeassistant . components . climate import ( ATTR_FAN_MODE , ATTR_OPERATION_MODE , ATTR_FAN_LIST , ATTR_OPERATION_LIST ) [EOL] [EOL] import homeassistant . components . climate . honeywell as honeywell [EOL] [EOL] [EOL] class TestHoneywell ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] [string] ) def test_setup_us ( self , mock_ht , mock_sc ) : [EOL] [docstring] [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_COOL_AWAY_TEMPERATURE : [number] , honeywell . CONF_HEAT_AWAY_TEMPERATURE : [number] , honeywell . CONF_REGION : [string] , } [EOL] bad_pass_config = { CONF_USERNAME : [string] , honeywell . CONF_COOL_AWAY_TEMPERATURE : [number] , honeywell . CONF_HEAT_AWAY_TEMPERATURE : [number] , honeywell . CONF_REGION : [string] , } [EOL] bad_region_config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_COOL_AWAY_TEMPERATURE : [number] , honeywell . CONF_HEAT_AWAY_TEMPERATURE : [number] , honeywell . CONF_REGION : [string] , } [EOL] [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] honeywell . PLATFORM_SCHEMA ( None ) [EOL] [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] honeywell . PLATFORM_SCHEMA ( { } ) [EOL] [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] honeywell . PLATFORM_SCHEMA ( bad_pass_config ) [EOL] [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] honeywell . PLATFORM_SCHEMA ( bad_region_config ) [EOL] [EOL] hass = mock . MagicMock ( ) [EOL] add_entities = mock . MagicMock ( ) [EOL] [EOL] locations = [ mock . MagicMock ( ) , mock . MagicMock ( ) , ] [EOL] devices_1 = [ mock . MagicMock ( ) ] [EOL] devices_2 = [ mock . MagicMock ( ) , mock . MagicMock ] [EOL] mock_sc . return_value . locations_by_id . values . return_value = locations [EOL] locations [ [number] ] . devices_by_id . values . return_value = devices_1 [EOL] locations [ [number] ] . devices_by_id . values . return_value = devices_2 [EOL] [EOL] result = honeywell . setup_platform ( hass , config , add_entities ) [EOL] self . assertTrue ( result ) [EOL] self . assertEqual ( mock_sc . call_count , [number] ) [EOL] self . assertEqual ( mock_sc . call_args , mock . call ( [string] , [string] ) ) [EOL] mock_ht . assert_has_calls ( [ mock . call ( mock_sc . return_value , devices_1 [ [number] ] , [number] , [number] , [string] , [string] ) , mock . call ( mock_sc . return_value , devices_2 [ [number] ] , [number] , [number] , [string] , [string] ) , mock . call ( mock_sc . return_value , devices_2 [ [number] ] , [number] , [number] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_setup_us_failures ( self , mock_sc ) : [EOL] [docstring] [EOL] hass = mock . MagicMock ( ) [EOL] add_entities = mock . MagicMock ( ) [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_REGION : [string] , } [EOL] [EOL] mock_sc . side_effect = somecomfort . AuthError [EOL] result = honeywell . setup_platform ( hass , config , add_entities ) [EOL] self . assertFalse ( result ) [EOL] self . assertFalse ( add_entities . called ) [EOL] [EOL] mock_sc . side_effect = somecomfort . SomeComfortError [EOL] result = honeywell . setup_platform ( hass , config , add_entities ) [EOL] self . assertFalse ( result ) [EOL] self . assertFalse ( add_entities . called ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] [string] ) def _test_us_filtered_devices ( self , mock_ht , mock_sc , loc = None , dev = None ) : [EOL] [docstring] [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_REGION : [string] , [string] : loc , [string] : dev , } [EOL] locations = { [number] : mock . MagicMock ( locationid = mock . sentinel . loc1 , devices_by_id = { [number] : mock . MagicMock ( deviceid = mock . sentinel . loc1dev1 ) , [number] : mock . MagicMock ( deviceid = mock . sentinel . loc1dev2 ) , } ) , [number] : mock . MagicMock ( locationid = mock . sentinel . loc2 , devices_by_id = { [number] : mock . MagicMock ( deviceid = mock . sentinel . loc2dev1 ) , } ) , [number] : mock . MagicMock ( locationid = mock . sentinel . loc3 , devices_by_id = { [number] : mock . MagicMock ( deviceid = mock . sentinel . loc3dev1 ) , } ) , } [EOL] mock_sc . return_value = mock . MagicMock ( locations_by_id = locations ) [EOL] hass = mock . MagicMock ( ) [EOL] add_entities = mock . MagicMock ( ) [EOL] self . assertEqual ( True , honeywell . setup_platform ( hass , config , add_entities ) ) [EOL] [EOL] return mock_ht . call_args_list , mock_sc [EOL] [EOL] def test_us_filtered_thermostat_1 ( self ) : [EOL] [docstring] [EOL] result , client = self . _test_us_filtered_devices ( dev = mock . sentinel . loc1dev1 ) [EOL] devices = [ x [ [number] ] [ [number] ] . deviceid for x in result ] [EOL] self . assertEqual ( [ mock . sentinel . loc1dev1 ] , devices ) [EOL] [EOL] def test_us_filtered_thermostat_2 ( self ) : [EOL] [docstring] [EOL] result , client = self . _test_us_filtered_devices ( dev = mock . sentinel . loc2dev1 ) [EOL] devices = [ x [ [number] ] [ [number] ] . deviceid for x in result ] [EOL] self . assertEqual ( [ mock . sentinel . loc2dev1 ] , devices ) [EOL] [EOL] def test_us_filtered_location_1 ( self ) : [EOL] [docstring] [EOL] result , client = self . _test_us_filtered_devices ( loc = mock . sentinel . loc1 ) [EOL] devices = [ x [ [number] ] [ [number] ] . deviceid for x in result ] [EOL] self . assertEqual ( [ mock . sentinel . loc1dev1 , mock . sentinel . loc1dev2 ] , devices ) [EOL] [EOL] def test_us_filtered_location_2 ( self ) : [EOL] [docstring] [EOL] result , client = self . _test_us_filtered_devices ( loc = mock . sentinel . loc2 ) [EOL] devices = [ x [ [number] ] [ [number] ] . deviceid for x in result ] [EOL] self . assertEqual ( [ mock . sentinel . loc2dev1 ] , devices ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] [string] ) def test_eu_setup_full_config ( self , mock_round , mock_evo ) : [EOL] [docstring] [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_AWAY_TEMPERATURE : [number] , honeywell . CONF_REGION : [string] , } [EOL] mock_evo . return_value . temperatures . return_value = [ { [string] : [string] } , { [string] : [string] } ] [EOL] hass = mock . MagicMock ( ) [EOL] add_entities = mock . MagicMock ( ) [EOL] self . assertTrue ( honeywell . setup_platform ( hass , config , add_entities ) ) [EOL] self . assertEqual ( mock_evo . call_count , [number] ) [EOL] self . assertEqual ( mock_evo . call_args , mock . call ( [string] , [string] ) ) [EOL] self . assertEqual ( mock_evo . return_value . temperatures . call_count , [number] ) [EOL] self . assertEqual ( mock_evo . return_value . temperatures . call_args , mock . call ( force_refresh = True ) ) [EOL] mock_round . assert_has_calls ( [ mock . call ( mock_evo . return_value , [string] , True , [number] ) , mock . call ( mock_evo . return_value , [string] , False , [number] ) , ] ) [EOL] self . assertEqual ( [number] , add_entities . call_count ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] [string] ) def test_eu_setup_partial_config ( self , mock_round , mock_evo ) : [EOL] [docstring] [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_REGION : [string] , } [EOL] [EOL] mock_evo . return_value . temperatures . return_value = [ { [string] : [string] } , { [string] : [string] } ] [EOL] config [ honeywell . CONF_AWAY_TEMPERATURE ] = honeywell . DEFAULT_AWAY_TEMPERATURE [EOL] [EOL] hass = mock . MagicMock ( ) [EOL] add_entities = mock . MagicMock ( ) [EOL] self . assertTrue ( honeywell . setup_platform ( hass , config , add_entities ) ) [EOL] mock_round . assert_has_calls ( [ mock . call ( mock_evo . return_value , [string] , True , [number] ) , mock . call ( mock_evo . return_value , [string] , False , [number] ) , ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] [string] ) def test_eu_setup_bad_temp ( self , mock_round , mock_evo ) : [EOL] [docstring] [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_AWAY_TEMPERATURE : [string] , honeywell . CONF_REGION : [string] , } [EOL] [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] honeywell . PLATFORM_SCHEMA ( config ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] [string] ) def test_eu_setup_error ( self , mock_round , mock_evo ) : [EOL] [docstring] [EOL] config = { CONF_USERNAME : [string] , CONF_PASSWORD : [string] , honeywell . CONF_AWAY_TEMPERATURE : [number] , honeywell . CONF_REGION : [string] , } [EOL] mock_evo . return_value . temperatures . side_effect = socket . error [EOL] add_entities = mock . MagicMock ( ) [EOL] hass = mock . MagicMock ( ) [EOL] self . assertFalse ( honeywell . setup_platform ( hass , config , add_entities ) ) [EOL] [EOL] [EOL] class TestHoneywellRound ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] def fake_temperatures ( force_refresh = None ) : [EOL] [docstring] [EOL] temps = [ { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] } , ] [EOL] return temps [EOL] [EOL] self . device = mock . MagicMock ( ) [EOL] self . device . temperatures . side_effect = fake_temperatures [EOL] self . round1 = honeywell . RoundThermostat ( self . device , [string] , True , [number] ) [EOL] self . round1 . update ( ) [EOL] self . round2 = honeywell . RoundThermostat ( self . device , [string] , False , [number] ) [EOL] self . round2 . update ( ) [EOL] [EOL] def test_attributes ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , self . round1 . name ) [EOL] self . assertEqual ( TEMP_CELSIUS , self . round1 . temperature_unit ) [EOL] self . assertEqual ( [number] , self . round1 . current_temperature ) [EOL] self . assertEqual ( [number] , self . round1 . target_temperature ) [EOL] self . assertFalse ( self . round1 . is_away_mode_on ) [EOL] [EOL] self . assertEqual ( [string] , self . round2 . name ) [EOL] self . assertEqual ( TEMP_CELSIUS , self . round2 . temperature_unit ) [EOL] self . assertEqual ( [number] , self . round2 . current_temperature ) [EOL] self . assertEqual ( None , self . round2 . target_temperature ) [EOL] self . assertFalse ( self . round2 . is_away_mode_on ) [EOL] [EOL] def test_away_mode ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( self . round1 . is_away_mode_on ) [EOL] self . round1 . turn_away_mode_on ( ) [EOL] self . assertTrue ( self . round1 . is_away_mode_on ) [EOL] self . assertEqual ( self . device . set_temperature . call_count , [number] ) [EOL] self . assertEqual ( self . device . set_temperature . call_args , mock . call ( [string] , [number] ) ) [EOL] [EOL] self . device . set_temperature . reset_mock ( ) [EOL] self . round1 . turn_away_mode_off ( ) [EOL] self . assertFalse ( self . round1 . is_away_mode_on ) [EOL] self . assertEqual ( self . device . cancel_temp_override . call_count , [number] ) [EOL] self . assertEqual ( self . device . cancel_temp_override . call_args , mock . call ( [string] ) ) [EOL] [EOL] def test_set_temperature ( self ) : [EOL] [docstring] [EOL] self . round1 . set_temperature ( temperature = [number] ) [EOL] self . assertEqual ( self . device . set_temperature . call_count , [number] ) [EOL] self . assertEqual ( self . device . set_temperature . call_args , mock . call ( [string] , [number] ) ) [EOL] [EOL] def test_set_operation_mode ( self ) : [EOL] [docstring] [EOL] self . round1 . set_operation_mode ( [string] ) [EOL] self . assertEqual ( [string] , self . round1 . current_operation ) [EOL] self . assertEqual ( [string] , self . device . system_mode ) [EOL] [EOL] self . round1 . set_operation_mode ( [string] ) [EOL] self . assertEqual ( [string] , self . round1 . current_operation ) [EOL] self . assertEqual ( [string] , self . device . system_mode ) [EOL] [EOL] [EOL] class TestHoneywellUS ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . client = mock . MagicMock ( ) [EOL] self . device = mock . MagicMock ( ) [EOL] self . cool_away_temp = [number] [EOL] self . heat_away_temp = [number] [EOL] self . honeywell = honeywell . HoneywellUSThermostat ( self . client , self . device , self . cool_away_temp , self . heat_away_temp , [string] , [string] ) [EOL] [EOL] self . device . fan_running = True [EOL] self . device . name = [string] [EOL] self . device . temperature_unit = [string] [EOL] self . device . current_temperature = [number] [EOL] self . device . setpoint_cool = [number] [EOL] self . device . setpoint_heat = [number] [EOL] self . device . system_mode = [string] [EOL] self . device . fan_mode = [string] [EOL] [EOL] def test_properties ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( self . honeywell . is_fan_on ) [EOL] self . assertEqual ( [string] , self . honeywell . name ) [EOL] self . assertEqual ( [number] , self . honeywell . current_temperature ) [EOL] [EOL] def test_unit_of_measurement ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( TEMP_FAHRENHEIT , self . honeywell . temperature_unit ) [EOL] self . device . temperature_unit = [string] [EOL] self . assertEqual ( TEMP_CELSIUS , self . honeywell . temperature_unit ) [EOL] [EOL] def test_target_temp ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . honeywell . target_temperature ) [EOL] self . device . system_mode = [string] [EOL] self . assertEqual ( [number] , self . honeywell . target_temperature ) [EOL] [EOL] def test_set_temp ( self ) : [EOL] [docstring] [EOL] self . honeywell . set_temperature ( temperature = [number] ) [EOL] self . assertEqual ( [number] , self . device . setpoint_heat ) [EOL] self . assertEqual ( [number] , self . honeywell . target_temperature ) [EOL] [EOL] self . device . system_mode = [string] [EOL] self . assertEqual ( [number] , self . honeywell . target_temperature ) [EOL] self . honeywell . set_temperature ( temperature = [number] ) [EOL] self . assertEqual ( [number] , self . device . setpoint_cool ) [EOL] self . assertEqual ( [number] , self . honeywell . target_temperature ) [EOL] [EOL] def test_set_operation_mode ( self ) : [EOL] [docstring] [EOL] self . honeywell . set_operation_mode ( [string] ) [EOL] self . assertEqual ( [string] , self . device . system_mode ) [EOL] [EOL] self . honeywell . set_operation_mode ( [string] ) [EOL] self . assertEqual ( [string] , self . device . system_mode ) [EOL] [EOL] def test_set_temp_fail ( self ) : [EOL] [docstring] [EOL] self . device . setpoint_heat = mock . MagicMock ( side_effect = somecomfort . SomeComfortError ) [EOL] self . honeywell . set_temperature ( temperature = [number] ) [EOL] [EOL] def test_attributes ( self ) : [EOL] [docstring] [EOL] expected = { honeywell . ATTR_FAN : [string] , ATTR_FAN_MODE : [string] , ATTR_OPERATION_MODE : [string] , ATTR_FAN_LIST : somecomfort . FAN_MODES , ATTR_OPERATION_LIST : somecomfort . SYSTEM_MODES , } [EOL] self . assertEqual ( expected , self . honeywell . device_state_attributes ) [EOL] expected [ [string] ] = [string] [EOL] self . device . fan_running = False [EOL] self . assertEqual ( expected , self . honeywell . device_state_attributes ) [EOL] [EOL] def test_with_no_fan ( self ) : [EOL] [docstring] [EOL] self . device . fan_running = False [EOL] self . device . fan_mode = None [EOL] expected = { honeywell . ATTR_FAN : [string] , ATTR_FAN_MODE : None , ATTR_OPERATION_MODE : [string] , ATTR_FAN_LIST : somecomfort . FAN_MODES , ATTR_OPERATION_LIST : somecomfort . SYSTEM_MODES , } [EOL] self . assertEqual ( expected , self . honeywell . device_state_attributes ) [EOL] [EOL] def test_heat_away_mode ( self ) : [EOL] [docstring] [EOL] self . honeywell . set_operation_mode ( [string] ) [EOL] self . assertFalse ( self . honeywell . is_away_mode_on ) [EOL] self . honeywell . turn_away_mode_on ( ) [EOL] self . assertTrue ( self . honeywell . is_away_mode_on ) [EOL] self . assertEqual ( self . device . setpoint_heat , self . heat_away_temp ) [EOL] self . assertEqual ( self . device . hold_heat , True ) [EOL] [EOL] self . honeywell . turn_away_mode_off ( ) [EOL] self . assertFalse ( self . honeywell . is_away_mode_on ) [EOL] self . assertEqual ( self . device . hold_heat , False ) [EOL] [EOL] @ mock . patch ( [string] ) def test_retry ( self , test_somecomfort ) : [EOL] [docstring] [EOL] old_device = self . honeywell . _device [EOL] self . honeywell . _retry ( ) [EOL] self . assertEqual ( self . honeywell . _device , old_device ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $typing.List[unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock.MagicMock]$ 0 $typing.List[unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 $typing.List[unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[unittest.mock.MagicMock],unittest.mock.MagicMock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,builtins.str]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,builtins.str]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,unittest.mock.MagicMock]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,typing.Any]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,typing.Union[builtins.float,builtins.str]]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,builtins.str]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Dict[unknown,typing.Union[builtins.int,builtins.str]]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import unittest [EOL] [EOL] from homeassistant . components import device_tracker [EOL] from homeassistant . components . device_tracker . tplink import Tplink4DeviceScanner [EOL] from homeassistant . const import ( CONF_PLATFORM , CONF_PASSWORD , CONF_USERNAME , CONF_HOST ) [EOL] import requests_mock [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestTplink4DeviceScanner ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] try : [EOL] os . remove ( self . hass . config . path ( device_tracker . YAML_DEVICES ) ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] @ requests_mock . mock ( ) def test_get_mac_addresses_from_both_bands ( self , m ) : [EOL] [docstring] [EOL] conf_dict = { CONF_PLATFORM : [string] , CONF_HOST : [string] , CONF_USERNAME : [string] , CONF_PASSWORD : [string] } [EOL] [EOL] [comment] [EOL] FAKE_TOKEN = [string] [EOL] fake_auth_token_response = [string] [string] . format ( FAKE_TOKEN ) [EOL] [EOL] m . get ( [string] . format ( conf_dict [ CONF_HOST ] ) , text = fake_auth_token_response ) [EOL] [EOL] FAKE_MAC_1 = [string] [EOL] FAKE_MAC_2 = [string] [EOL] FAKE_MAC_3 = [string] [EOL] mac_response_2_4 = [string] . format ( FAKE_MAC_1 , FAKE_MAC_2 ) [EOL] mac_response_5 = [string] . format ( FAKE_MAC_3 ) [EOL] [EOL] [comment] [EOL] m . get ( [string] . format ( conf_dict [ CONF_HOST ] , FAKE_TOKEN ) , text = mac_response_2_4 ) [EOL] [EOL] [comment] [EOL] m . get ( [string] . format ( conf_dict [ CONF_HOST ] , FAKE_TOKEN ) , text = mac_response_5 ) [EOL] [EOL] tplink = Tplink4DeviceScanner ( conf_dict ) [EOL] [EOL] expected_mac_results = [ mac . replace ( [string] , [string] ) for mac in [ FAKE_MAC_1 , FAKE_MAC_2 , FAKE_MAC_3 ] ] [EOL] [EOL] self . assertEqual ( tplink . last_results , expected_mac_results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . const import STATE_OPEN , STATE_CLOSED , STATE_UNKNOWN , STATE_UNAVAILABLE , ATTR_ASSUMED_STATE [EOL] import homeassistant . components . cover as cover [EOL] from homeassistant . components . cover . mqtt import MqttCover [EOL] [EOL] from tests . common import ( get_test_home_assistant , mock_mqtt_component , fire_mqtt_message ) [EOL] [EOL] [EOL] class TestCoverMQTT ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . mock_publish = mock_mqtt_component ( self . hass ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_state_via_state_topic ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] self . assertFalse ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_CLOSED , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OPEN , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OPEN , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , STATE_CLOSED ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_CLOSED , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , STATE_OPEN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OPEN , state . state ) [EOL] [EOL] def test_state_via_template ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OPEN , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_CLOSED , state . state ) [EOL] [EOL] def test_optimistic_state_change ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] self . assertTrue ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] cover . open_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OPEN , state . state ) [EOL] [EOL] cover . close_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_CLOSED , state . state ) [EOL] [EOL] def test_send_open_cover_command ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] cover . open_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] def test_send_close_cover_command ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] cover . close_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] def test_send_stop__cover_command ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] cover . stop_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNKNOWN , state . state ) [EOL] [EOL] def test_current_cover_position ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state_attributes_dict = self . hass . states . get ( [string] ) . attributes [EOL] self . assertFalse ( [string] in state_attributes_dict ) [EOL] self . assertFalse ( [string] in state_attributes_dict ) [EOL] self . assertFalse ( [number] & self . hass . states . get ( [string] ) . attributes [ [string] ] == [number] ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] current_cover_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_position ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] current_cover_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_position ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] current_cover_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_position ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] current_cover_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_position ) [EOL] [EOL] def test_set_cover_position ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state_attributes_dict = self . hass . states . get ( [string] ) . attributes [EOL] self . assertFalse ( [string] in state_attributes_dict ) [EOL] self . assertFalse ( [string] in state_attributes_dict ) [EOL] [EOL] self . assertTrue ( [number] & self . hass . states . get ( [string] ) . attributes [ [string] ] == [number] ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state_attributes_dict = self . hass . states . get ( [string] ) . attributes [EOL] self . assertTrue ( [string] in state_attributes_dict ) [EOL] self . assertFalse ( [string] in state_attributes_dict ) [EOL] current_cover_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_position ) [EOL] [EOL] def test_set_position_templated ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] cover . set_cover_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] [EOL] def test_set_position_untemplated ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] cover . set_cover_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] [EOL] def test_no_command_topic ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] self . assertEqual ( [number] , self . hass . states . get ( [string] ) . attributes [ [string] ] ) [EOL] [EOL] def test_with_command_topic_and_tilt ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] self . assertEqual ( [number] , self . hass . states . get ( [string] ) . attributes [ [string] ] ) [EOL] [EOL] def test_tilt_defaults ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state_attributes_dict = self . hass . states . get ( [string] ) . attributes [EOL] self . assertTrue ( [string] in state_attributes_dict ) [EOL] [EOL] current_cover_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( STATE_UNKNOWN , current_cover_position ) [EOL] [EOL] def test_tilt_via_invocation_defaults ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] cover . open_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] [EOL] cover . close_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] [EOL] def test_tilt_given_value ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] } } ) ) [EOL] [EOL] cover . open_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] [EOL] cover . close_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] [EOL] def test_tilt_via_topic ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] } } ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] current_cover_tilt_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_tilt_position ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] current_cover_tilt_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_tilt_position ) [EOL] [EOL] def test_tilt_via_topic_altered_range ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] current_cover_tilt_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_tilt_position ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] current_cover_tilt_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_tilt_position ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] current_cover_tilt_position = self . hass . states . get ( [string] ) . attributes [ [string] ] [EOL] self . assertEqual ( [number] , current_cover_tilt_position ) [EOL] [EOL] def test_tilt_position ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] } } ) ) [EOL] [EOL] cover . set_cover_tilt_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] [EOL] def test_tilt_position_altered_range ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } ) ) [EOL] [EOL] cover . set_cover_tilt_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [number] , [number] , False ) [EOL] [EOL] def test_find_percentage_in_range_defaults ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , False , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_percentage_in_range ( [number] ) ) [EOL] [EOL] def test_find_percentage_in_range_altered ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , False , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_percentage_in_range ( [number] ) ) [EOL] [EOL] def test_find_percentage_in_range_defaults_inverted ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , True , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_percentage_in_range ( [number] ) ) [EOL] [EOL] def test_find_percentage_in_range_altered_inverted ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , True , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_percentage_in_range ( [number] ) ) [EOL] [EOL] def test_find_in_range_defaults ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , False , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_in_range_from_percent ( [number] ) ) [EOL] [EOL] def test_find_in_range_altered ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , False , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_in_range_from_percent ( [number] ) ) [EOL] [EOL] def test_find_in_range_defaults_inverted ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , True , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_in_range_from_percent ( [number] ) ) [EOL] [EOL] def test_find_in_range_altered_inverted ( self ) : [EOL] [docstring] [EOL] mqtt_cover = MqttCover ( [string] , [string] , [string] , None , [string] , [string] , [number] , False , [string] , [string] , [string] , [string] , [string] , None , None , False , None , [number] , [number] , [number] , [number] , False , True , None , None ) [EOL] [EOL] self . assertEqual ( [number] , mqtt_cover . find_in_range_from_percent ( [number] ) ) [EOL] [EOL] def test_availability_without_topic ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] def test_availability_by_defaults ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] def test_availability_by_custom_payload ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , cover . DOMAIN , { cover . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0