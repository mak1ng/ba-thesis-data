from setuptools import setup , find_packages [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( exclude = [ [string] ] ) , include_package_data = True , install_requires = [ [string] , [string] ] , entry_points = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Optional [EOL] import builtins [EOL] import resttest [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] [comment] [EOL] import fire [EOL] [EOL] [comment] [EOL] from resttest . service import Reader , FileReader [EOL] from resttest . service import get_random_port [EOL] from resttest . service import run_tests [EOL] [EOL] [EOL] class RestTest : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _reader = FileReader ( [string] ) [EOL] [EOL] def get_port ( self ) : [EOL] [docstring] [EOL] print ( get_random_port ( ) ) [EOL] [EOL] def run ( self , port = [number] , name = None ) : [EOL] [docstring] [EOL] if name : [EOL] self . _run_test_case ( port , name ) [EOL] return [EOL] self . _run_all ( port ) [EOL] [EOL] def _run_test_case ( self , port , name ) : [EOL] [docstring] [EOL] env = self . _reader . read_env ( port ) [EOL] test_case = self . _reader . read_test_case ( name ) [EOL] run_tests ( [ test_case ] , env ) [EOL] [EOL] def _run_all ( self , port ) : [EOL] [docstring] [EOL] env = self . _reader . read_env ( port ) [EOL] test_cases = self . _reader . read_test_cases ( ) [EOL] run_tests ( test_cases , env ) [EOL] [EOL] [EOL] def main ( ) : [EOL] fire . Fire ( RestTest ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resttest.service.Reader$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $resttest.models.Env$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $resttest.models.TestCase$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $resttest.models.TestCase$ 0 0 $resttest.models.Env$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $resttest.models.Env$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[resttest.models.TestCase]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[resttest.models.TestCase]$ 0 $resttest.models.Env$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any [EOL] import builtins [EOL] import resttest [EOL] import typing [EOL] from typing import Any , Dict , List , Optional [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Env : [EOL] base_url = ... [EOL] data = ... [EOL] [EOL] @ classmethod def fromdict ( cls , port , raw ) : [EOL] base_url = raw [ [string] ] if [string] in raw else f" [string] { port }" [EOL] env_data = raw [ [string] ] if [string] in raw else { } [EOL] return cls ( base_url = base_url , data = env_data ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Request : [EOL] method = ... [EOL] path = ... [EOL] body = ... [EOL] headers = ... [EOL] [EOL] @ classmethod def fromdict ( cls , raw ) : [EOL] return cls ( method = raw [ [string] ] , path = raw [ [string] ] , body = raw . get ( [string] , None ) , headers = raw . get ( [string] , { } ) , ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Response : [EOL] status = ... [EOL] body = ... [EOL] [EOL] @ classmethod def fromdict ( cls , raw ) : [EOL] return cls ( status = raw [ [string] ] , body = raw [ [string] ] if [string] in raw else None ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class EnvUpdate : [EOL] env_key = ... [EOL] response_key = ... [EOL] [EOL] @ classmethod def fromdict ( cls , raw ) : [EOL] return cls ( env_key = raw [ [string] ] , response_key = raw [ [string] ] ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class TestCase : [EOL] name = ... [EOL] request = ... [EOL] response = ... [EOL] set_env = ... [EOL] [EOL] @ classmethod def fromdict ( cls , raw ) : [EOL] updates = [ ] [EOL] if [string] in raw : [EOL] updates = [ EnvUpdate . fromdict ( u ) for u in raw [ [string] ] ] [EOL] [EOL] return cls ( name = raw [ [string] ] , request = Request . fromdict ( raw [ [string] ] ) , response = Response . fromdict ( raw [ [string] ] ) , set_env = updates , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $"Env"$ 0 0 0 $builtins.int$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $"Request"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $"Response"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $"EnvUpdate"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Request$ 0 0 0 $Response$ 0 0 0 $typing.List[EnvUpdate]$ 0 0 0 0 0 0 0 $"TestCase"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[resttest.models.EnvUpdate]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.List[resttest.models.EnvUpdate]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[resttest.models.EnvUpdate]$ 0 0 0
	0
from . random_port import get_random_port [EOL] from . reader import Reader , FileReader [EOL] from . test_service import run_tests [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import requests [EOL] import builtins [EOL] import resttest [EOL] import typing [EOL] import re [EOL] from functools import reduce [EOL] from typing import Dict [EOL] [EOL] [comment] [EOL] from resttest . models import TestCase , Request , Response , Env [EOL] from . template_util import resolve_dict , resolve_value [EOL] [EOL] [comment] [EOL] import requests [EOL] [EOL] [EOL] def make_request ( req , env ) : [EOL] if req . method in ( [string] , [string] ) : [EOL] return _make_request_without_body ( req , env ) [EOL] return _make_request_with_body ( req , env ) [EOL] [EOL] [EOL] def _make_path ( req , env ) : [EOL] path = env . base_url + req . path [EOL] for key , val in env . data . items ( ) : [EOL] path_key = [string] + key + [string] [EOL] path = path . replace ( path_key , val ) [EOL] return path [EOL] [EOL] [EOL] def _make_request_without_body ( req , env ) : [EOL] url = _make_path ( req , env ) [EOL] headers = _make_headers ( env , req ) [EOL] resp = requests . request ( req . method , url , headers = headers ) [EOL] return _map_response ( resp ) [EOL] [EOL] [EOL] def _make_request_with_body ( req , env ) : [EOL] if not req . body : [EOL] return _make_request_without_body ( req , env ) [EOL] url = _make_path ( req , env ) [EOL] headers = _make_headers ( env , req ) [EOL] body = resolve_dict ( env , req . body ) [EOL] resp = requests . request ( req . method , url , json = body , headers = headers ) [EOL] return _map_response ( resp ) [EOL] [EOL] [EOL] def _make_headers ( env , req ) : [EOL] headers = { [string] : [string] , [string] : env . data [ [string] ] } [EOL] for key , val in req . headers . items ( ) : [EOL] headers [ key ] = resolve_value ( env , val ) [EOL] return headers [EOL] [EOL] [EOL] def _map_response ( resp ) : [EOL] return Response ( status = resp . status_code , body = resp . json ( ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resttest.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resttest.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resttest.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resttest.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any , Type [EOL] import builtins [EOL] import resttest [EOL] import typing [EOL] import json [EOL] from abc import ABCMeta , abstractmethod [EOL] from os import listdir [EOL] from os . path import join , isfile [EOL] from typing import Any , Dict , List [EOL] from collections import namedtuple [EOL] [EOL] [comment] [EOL] from resttest . models import Env , TestCase [EOL] [EOL] [EOL] NumberedFilename = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [EOL] [EOL] class Reader ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def read_env ( self , port ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def read_test_case ( self , name ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def read_test_cases ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class FileReader ( Reader ) : [EOL] def __init__ ( self , test_dir ) : [EOL] self . test_dir = test_dir [EOL] [EOL] def read_env ( self , port ) : [EOL] raw = self . _read_file ( [string] ) [EOL] return Env . fromdict ( port , raw ) [EOL] [EOL] def read_test_case ( self , name ) : [EOL] filename = self . _append_suffix ( name ) [EOL] raw = self . _read_file ( filename ) [EOL] return TestCase . fromdict ( raw ) [EOL] [EOL] def read_test_cases ( self ) : [EOL] filenames = self . _get_test_case_names ( ) [EOL] return [ self . read_test_case ( fname ) for fname in filenames ] [EOL] [EOL] def _read_file ( self , name ) : [EOL] filename = f"{ self . test_dir } [string] { name }" [EOL] with open ( filename , [string] ) as f : [EOL] return json . load ( f ) [EOL] [EOL] def _append_suffix ( self , name ) : [EOL] if name . endswith ( [string] ) : [EOL] return name [EOL] return name + [string] [EOL] [EOL] def _get_test_case_names ( self ) : [EOL] unsorted_names = [ fname for fname in listdir ( self . test_dir ) if isfile ( join ( self . test_dir , fname ) ) and fname != [string] ] [EOL] return self . _sort_filenames ( unsorted_names ) [EOL] [EOL] def _sort_filenames ( self , filenames ) : [EOL] numbered = self . _number_filenames ( filenames ) [EOL] sorted_names = sorted ( numbered , key = lambda nf : nf . number ) [EOL] return [ nf . name for nf in sorted_names ] [EOL] [EOL] def _number_filenames ( self , filenames ) : [EOL] return [ NumberedFilename ( number = int ( fname . split ( [string] ) [ [number] ] ) , name = fname ) for fname in filenames ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[resttest.service.reader.NumberedFilename]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resttest.models.Env$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $resttest.models.TestCase$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[resttest.models.TestCase]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $resttest.models.Env$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $resttest.models.TestCase$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[resttest.models.TestCase]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[resttest.service.reader.NumberedFilename]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[resttest.service.reader.NumberedFilename]$ 0 0 0 $typing.List[resttest.service.reader.NumberedFilename]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[resttest.service.reader.NumberedFilename]$ 0 0 0 0 $typing.List[NumberedFilename]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Type[resttest.service.reader.NumberedFilename]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0
[comment] [EOL] import builtins [EOL] import socket [EOL] import socket [EOL] import sys [EOL] [EOL] [EOL] def get_random_port ( ) : [EOL] [docstring] [EOL] try : [EOL] port = _find_unused_port ( ) [EOL] return port [EOL] except Exception as e : [EOL] print ( f" [string] { e }" ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def _find_unused_port ( ) : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] s . bind ( ( [string] , [number] ) ) [EOL] port = s . getsockname ( ) [ [number] ] [EOL] s . close ( ) [EOL] return port [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any [EOL] import builtins [EOL] import resttest [EOL] import typing [EOL] import re [EOL] from functools import reduce [EOL] from typing import Dict [EOL] [EOL] [comment] [EOL] from resttest . models import Env [EOL] [EOL] [EOL] def resolve_dict ( env , body ) : [EOL] final_body = { } [EOL] for key , val in body . items ( ) : [EOL] if isinstance ( val , str ) : [EOL] final_body [ key ] = resolve_value ( env , val ) [EOL] elif isinstance ( val , dict ) : [EOL] final_body [ key ] = resolve_dict ( env , val ) [EOL] else : [EOL] final_body [ key ] = val [EOL] return final_body [EOL] [EOL] [EOL] def resolve_value ( env , val ) : [EOL] matches = re . findall ( [string] , val ) [EOL] return reduce ( lambda templ , match : templ . replace ( [string] + match + [string] , env . data [ match ] ) , matches , val , ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0