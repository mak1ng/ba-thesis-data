from typing import Tuple , Type , Dict , Callable , Optional , Any , List , Union [EOL] import exceptions [EOL] import types [EOL] import graphql [EOL] import cgi [EOL] import builtins [EOL] import ariadne [EOL] import typing [EOL] import json [EOL] from cgi import FieldStorage [EOL] from typing import Any , Callable , List , Optional , Type , Union [EOL] [EOL] from graphql import GraphQLError , GraphQLSchema [EOL] from graphql . execution import Middleware , MiddlewareManager [EOL] [EOL] from . constants import ( CONTENT_TYPE_JSON , CONTENT_TYPE_TEXT_HTML , CONTENT_TYPE_TEXT_PLAIN , DATA_TYPE_JSON , DATA_TYPE_MULTIPART , HTTP_STATUS_200_OK , HTTP_STATUS_400_BAD_REQUEST , PLAYGROUND_HTML , ) [EOL] from . exceptions import HttpBadRequestError , HttpError , HttpMethodNotAllowedError [EOL] from . file_uploads import combine_multipart_data [EOL] from . format_error import format_error [EOL] from . graphql import graphql_sync [EOL] from . types import ( ContextValue , ErrorFormatter , Extension , GraphQLResult , RootValue , ValidationRules , ) [EOL] [EOL] ExtensionList = Optional [ List [ Type [ Extension ] ] ] [EOL] Extensions = Union [ Callable [ [ Any , Optional [ ContextValue ] ] , ExtensionList ] , ExtensionList ] [EOL] MiddlewareList = Optional [ List [ Middleware ] ] [EOL] Middlewares = Union [ Callable [ [ Any , Optional [ ContextValue ] ] , MiddlewareList ] , MiddlewareList ] [EOL] [EOL] [EOL] class GraphQL : [EOL] def __init__ ( self , schema , * , context_value = None , root_value = None , validation_rules = None , debug = False , introspection = True , logger = None , error_formatter = format_error , extensions = None , middleware = None , ) : [EOL] self . context_value = context_value [EOL] self . root_value = root_value [EOL] self . validation_rules = validation_rules [EOL] self . debug = debug [EOL] self . introspection = introspection [EOL] self . logger = logger [EOL] self . error_formatter = error_formatter [EOL] self . extensions = extensions [EOL] self . middleware = middleware [EOL] self . schema = schema [EOL] [EOL] def __call__ ( self , environ , start_response ) : [EOL] try : [EOL] return self . handle_request ( environ , start_response ) [EOL] except GraphQLError as error : [EOL] return self . handle_graphql_error ( error , start_response ) [EOL] except HttpError as error : [EOL] return self . handle_http_error ( error , start_response ) [EOL] [EOL] def handle_graphql_error ( self , error , start_response ) : [EOL] start_response ( HTTP_STATUS_400_BAD_REQUEST , [ ( [string] , CONTENT_TYPE_JSON ) ] ) [EOL] error_json = { [string] : [ { [string] : error . message } ] } [EOL] return [ json . dumps ( error_json ) . encode ( [string] ) ] [EOL] [EOL] def handle_http_error ( self , error , start_response ) : [EOL] start_response ( error . status , [ ( [string] , CONTENT_TYPE_TEXT_PLAIN ) ] ) [EOL] response_body = error . message or error . status [EOL] return [ str ( response_body ) . encode ( [string] ) ] [EOL] [EOL] def handle_request ( self , environ , start_response ) : [EOL] if environ [ [string] ] == [string] and self . introspection : [EOL] return self . handle_get ( start_response ) [EOL] if environ [ [string] ] == [string] : [EOL] return self . handle_post ( environ , start_response ) [EOL] raise HttpMethodNotAllowedError ( ) [EOL] [EOL] def handle_get ( self , start_response ) : [EOL] start_response ( HTTP_STATUS_200_OK , [ ( [string] , CONTENT_TYPE_TEXT_HTML ) ] ) [EOL] return [ PLAYGROUND_HTML . encode ( [string] ) ] [EOL] [EOL] def handle_post ( self , environ , start_response ) : [EOL] data = self . get_request_data ( environ ) [EOL] result = self . execute_query ( environ , data ) [EOL] return self . return_response_from_result ( start_response , result ) [EOL] [EOL] def get_request_data ( self , environ ) : [EOL] content_type = environ . get ( [string] , [string] ) [EOL] content_type = content_type . split ( [string] ) [ [number] ] [EOL] [EOL] if content_type == DATA_TYPE_JSON : [EOL] return self . extract_data_from_json_request ( environ ) [EOL] if content_type == DATA_TYPE_MULTIPART : [EOL] return self . extract_data_from_multipart_request ( environ ) [EOL] [EOL] raise HttpBadRequestError ( [string] . format ( DATA_TYPE_JSON , DATA_TYPE_MULTIPART ) ) [EOL] [EOL] def extract_data_from_json_request ( self , environ ) : [EOL] request_content_length = self . get_request_content_length ( environ ) [EOL] request_body = self . get_request_body ( environ , request_content_length ) [EOL] [EOL] try : [EOL] return json . loads ( request_body ) [EOL] except ValueError : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] def get_request_content_length ( self , environ ) : [EOL] try : [EOL] content_length = int ( environ . get ( [string] , [number] ) ) [EOL] if content_length < [number] : [EOL] raise HttpBadRequestError ( [string] ) [EOL] return content_length [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] def get_request_body ( self , environ , content_length ) : [EOL] if not environ . get ( [string] ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] request_body = environ [ [string] ] . read ( content_length ) [EOL] if not request_body : [EOL] raise HttpBadRequestError ( [string] ) [EOL] return request_body [EOL] [EOL] def extract_data_from_multipart_request ( self , environ ) : [EOL] try : [EOL] form = FieldStorage ( fp = environ [ [string] ] , environ = environ , keep_blank_values = True ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] try : [EOL] operations = json . loads ( form . getvalue ( [string] ) ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] try : [EOL] files_map = json . loads ( form . getvalue ( [string] ) ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] return combine_multipart_data ( operations , files_map , form ) [EOL] [EOL] def execute_query ( self , environ , data ) : [EOL] context_value = self . get_context_for_request ( environ ) [EOL] extensions = self . get_extensions_for_request ( environ , context_value ) [EOL] middleware = self . get_middleware_for_request ( environ , context_value ) [EOL] [EOL] return graphql_sync ( self . schema , data , context_value = context_value , root_value = self . root_value , validation_rules = self . validation_rules , debug = self . debug , introspection = self . introspection , logger = self . logger , error_formatter = self . error_formatter , extensions = extensions , middleware = middleware , ) [EOL] [EOL] def get_context_for_request ( self , environ ) : [EOL] if callable ( self . context_value ) : [EOL] return self . context_value ( environ ) [EOL] return self . context_value or { [string] : environ } [EOL] [EOL] def get_extensions_for_request ( self , environ , context ) : [EOL] if callable ( self . extensions ) : [EOL] return self . extensions ( environ , context ) [EOL] return self . extensions [EOL] [EOL] def get_middleware_for_request ( self , environ , context ) : [EOL] middleware = self . middleware [EOL] if callable ( middleware ) : [EOL] middleware = middleware ( environ , context ) [EOL] if middleware : [EOL] return MiddlewareManager ( * middleware ) [EOL] return None [EOL] [EOL] def return_response_from_result ( self , start_response , result ) : [EOL] success , response = result [EOL] status_str = HTTP_STATUS_200_OK if success else HTTP_STATUS_400_BAD_REQUEST [EOL] start_response ( status_str , [ ( [string] , CONTENT_TYPE_JSON ) ] ) [EOL] return [ json . dumps ( response ) . encode ( [string] ) ] [EOL] [EOL] [EOL] class GraphQLMiddleware : [EOL] def __init__ ( self , app , graphql_app , path = [string] ) : [EOL] self . app = app [EOL] self . path = path [EOL] self . graphql_app = graphql_app [EOL] [EOL] if not callable ( app ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not path : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if path == [string] : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] def __call__ ( self , environ , start_response ) : [EOL] if not environ [ [string] ] . startswith ( self . path ) : [EOL] return self . app ( environ , start_response ) [EOL] return self . graphql_app ( environ , start_response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 $builtins.dict$ 0 $typing.Callable$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $typing.Callable$ 0 0 0 0 0 0 0 $builtins.dict$ 0 $typing.Callable$ 0 0
DATA_TYPE_JSON = [string] [EOL] DATA_TYPE_MULTIPART = [string] [EOL] [EOL] CONTENT_TYPE_JSON = [string] [EOL] CONTENT_TYPE_TEXT_HTML = [string] [EOL] CONTENT_TYPE_TEXT_PLAIN = [string] [EOL] [EOL] HTTP_STATUS_200_OK = [string] [EOL] HTTP_STATUS_400_BAD_REQUEST = [string] [EOL] HTTP_STATUS_405_METHOD_NOT_ALLOWED = [string] [EOL] [EOL] PLAYGROUND_HTML = [string] . strip ( ) [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
from typing import Generator , List [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from typing import Generator [EOL] [EOL] from graphql import parse [EOL] from graphql . error import GraphQLSyntaxError [EOL] [EOL] from . exceptions import GraphQLFileSyntaxError [EOL] [EOL] [EOL] def load_schema_from_path ( path ) : [EOL] if os . path . isdir ( path ) : [EOL] schema_list = [ read_graphql_file ( f ) for f in sorted ( walk_graphql_files ( path ) ) ] [EOL] return [string] . join ( schema_list ) [EOL] return read_graphql_file ( os . path . abspath ( path ) ) [EOL] [EOL] [EOL] def walk_graphql_files ( path ) : [EOL] extension = [string] [EOL] for dirpath , _ , files in os . walk ( path ) : [EOL] for name in files : [EOL] if extension and name . lower ( ) . endswith ( extension ) : [EOL] yield os . path . join ( dirpath , name ) [EOL] [EOL] [EOL] def read_graphql_file ( path ) : [EOL] with open ( path , [string] ) as graphql_file : [EOL] schema = graphql_file . read ( ) [EOL] try : [EOL] parse ( schema ) [EOL] except GraphQLSyntaxError as e : [EOL] raise GraphQLFileSyntaxError ( path , str ( e ) ) [EOL] return schema [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.str,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , AsyncGenerator , Dict , Callable [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import types [EOL] from typing import Callable , Dict [EOL] [EOL] from graphql . type import GraphQLSchema [EOL] [EOL] from . objects import ObjectType [EOL] from . types import Subscriber [EOL] [EOL] [EOL] class SubscriptionType ( ObjectType ) : [EOL] _subscribers = ... [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] self . _subscribers = { } [EOL] [EOL] def source ( self , name ) : [EOL] if not isinstance ( name , str ) : [EOL] raise ValueError ( [string] ) [EOL] return self . create_register_subscriber ( name ) [EOL] [EOL] def create_register_subscriber ( self , name ) : [EOL] def register_subscriber ( generator ) : [EOL] self . _subscribers [ name ] = generator [EOL] return generator [EOL] [EOL] return register_subscriber [EOL] [EOL] def set_source ( self , name , generator ) : [EOL] self . _subscribers [ name ] = generator [EOL] return generator [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] self . validate_graphql_type ( graphql_type ) [EOL] self . bind_resolvers_to_graphql_type ( graphql_type ) [EOL] self . bind_subscribers_to_graphql_type ( graphql_type ) [EOL] [EOL] def bind_subscribers_to_graphql_type ( self , graphql_type ) : [EOL] for field , subscriber in self . _subscribers . items ( ) : [EOL] if field not in graphql_type . fields : [EOL] raise ValueError ( [string] % ( field , self . name ) ) [EOL] [EOL] graphql_type . fields [ field ] . subscribe = subscriber [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,types.Subscriber]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 $typing.Any$ 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Any , List , Union [EOL] import schema_visitor [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List , Type , Union [EOL] [EOL] from graphql import ( GraphQLSchema , assert_valid_schema , build_ast_schema , parse , validate_schema , ) [EOL] [EOL] from . enums import set_default_enum_values_on_schema [EOL] from . schema_visitor import SchemaDirectiveVisitor [EOL] from . types import SchemaBindable [EOL] [EOL] [EOL] def make_executable_schema ( type_defs , * bindables , directives = None , ) : [EOL] if isinstance ( type_defs , list ) : [EOL] type_defs = join_type_defs ( type_defs ) [EOL] [EOL] ast_document = parse ( type_defs ) [EOL] schema = build_ast_schema ( ast_document ) [EOL] validate_schema ( schema ) [EOL] [EOL] for bindable in bindables : [EOL] if isinstance ( bindable , list ) : [EOL] for obj in bindable : [EOL] obj . bind_to_schema ( schema ) [EOL] else : [EOL] bindable . bind_to_schema ( schema ) [EOL] [EOL] set_default_enum_values_on_schema ( schema ) [EOL] [EOL] if directives : [EOL] SchemaDirectiveVisitor . visit_schema_directives ( schema , directives ) [EOL] [EOL] assert_valid_schema ( schema ) [EOL] [EOL] return schema [EOL] [EOL] [EOL] def join_type_defs ( type_defs ) : [EOL] return [string] . join ( t . strip ( ) for t in type_defs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import ariadne [EOL] import typing [EOL] from typing import Any [EOL] [EOL] from graphql import default_field_resolver [EOL] from graphql . type import ( GraphQLField , GraphQLObjectType , GraphQLResolveInfo , GraphQLSchema , ) [EOL] [EOL] from . types import Resolver , SchemaBindable [EOL] from . utils import convert_camel_case_to_snake [EOL] [EOL] [EOL] class FallbackResolversSetter ( SchemaBindable ) : [EOL] def bind_to_schema ( self , schema ) : [EOL] for type_object in schema . type_map . values ( ) : [EOL] if isinstance ( type_object , GraphQLObjectType ) : [EOL] self . add_resolvers_to_object_fields ( type_object ) [EOL] [EOL] def add_resolvers_to_object_fields ( self , type_object ) : [EOL] for field_name , field_object in type_object . fields . items ( ) : [EOL] self . add_resolver_to_field ( field_name , field_object ) [EOL] [EOL] def add_resolver_to_field ( self , _ , field_object ) : [EOL] if field_object . resolve is None : [EOL] field_object . resolve = default_field_resolver [EOL] [EOL] [EOL] class SnakeCaseFallbackResolversSetter ( FallbackResolversSetter ) : [EOL] def add_resolver_to_field ( self , field_name , field_object ) : [EOL] if field_object . resolve is None : [EOL] field_name = convert_camel_case_to_snake ( field_name ) [EOL] field_object . resolve = resolve_to ( field_name ) [EOL] [EOL] [EOL] fallback_resolvers = FallbackResolversSetter ( ) [EOL] snake_case_fallback_resolvers = SnakeCaseFallbackResolversSetter ( ) [EOL] [EOL] [EOL] def resolve_parent_field ( parent , field_name ) : [EOL] if isinstance ( parent , dict ) : [EOL] return parent . get ( field_name ) [EOL] return getattr ( parent , field_name , None ) [EOL] [EOL] [EOL] def resolve_to ( field_name ) : [EOL] def resolver ( parent , info , ** kwargs ) : [EOL] value = resolve_parent_field ( parent , field_name ) [EOL] if callable ( value ) : [EOL] return value ( info , ** kwargs ) [EOL] return value [EOL] [EOL] [comment] [EOL] resolver . _ariadne_alias_resolver = True [comment] [EOL] return resolver [EOL] [EOL] [EOL] def is_default_resolver ( resolver ) : [EOL] [comment] [EOL] if resolver == default_field_resolver : [EOL] return True [EOL] return hasattr ( resolver , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $graphql.type.GraphQLField$ 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $graphql.type.GraphQLField$ 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Optional , Sequence , Any , List [EOL] import extensions [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import ariadne [EOL] import typing [EOL] from asyncio import ensure_future [EOL] from inspect import isawaitable [EOL] from typing import Any , AsyncGenerator , Awaitable , List , Optional , Sequence , Type , cast [EOL] [EOL] from graphql import ( DocumentNode , ExecutionContext , ExecutionResult , GraphQLError , GraphQLSchema , TypeInfo , execute , parse , subscribe as _subscribe , ) [EOL] from graphql . execution import MiddlewareManager [EOL] from graphql . validation import specified_rules , validate [EOL] from graphql . validation . rules import ASTValidationRule [EOL] [EOL] from . extensions import ExtensionManager [EOL] from . format_error import format_error [EOL] from . logger import log_error [EOL] from . types import ( ErrorFormatter , Extension , GraphQLResult , RootValue , SubscriptionResult , ValidationRules , ) [EOL] from . validation . introspection_disabled import IntrospectionDisabledRule [EOL] [EOL] RuleType = Type [ ASTValidationRule ] [EOL] [EOL] [EOL] async def graphql ( schema , data , * , context_value = None , root_value = None , debug = False , introspection = True , logger = None , validation_rules = None , error_formatter = format_error , middleware = None , extensions = None , ** kwargs , ) : [EOL] extension_manager = ExtensionManager ( extensions , context_value ) [EOL] [EOL] with extension_manager . request ( ) : [EOL] try : [EOL] validate_data ( data ) [EOL] query , variables , operation_name = ( data [ [string] ] , data . get ( [string] ) , data . get ( [string] ) , ) [EOL] [EOL] document = parse_query ( query ) [EOL] [EOL] if callable ( validation_rules ) : [EOL] validation_rules = cast ( Optional [ Sequence [ RuleType ] ] , validation_rules ( context_value , document , data ) , ) [EOL] [EOL] validation_errors = validate_query ( schema , document , validation_rules , enable_introspection = introspection ) [EOL] if validation_errors : [EOL] return handle_graphql_errors ( validation_errors , logger = logger , error_formatter = error_formatter , debug = debug , extension_manager = extension_manager , ) [EOL] [EOL] if callable ( root_value ) : [EOL] root_value = root_value ( context_value , document ) [EOL] if isawaitable ( root_value ) : [EOL] root_value = await root_value [EOL] [EOL] result = execute ( schema , document , root_value = root_value , context_value = context_value , variable_values = variables , operation_name = operation_name , execution_context_class = ExecutionContext , middleware = extension_manager . as_middleware_manager ( middleware ) , ** kwargs , ) [EOL] [EOL] if isawaitable ( result ) : [EOL] result = await cast ( Awaitable [ ExecutionResult ] , result ) [EOL] except GraphQLError as error : [EOL] return handle_graphql_errors ( [ error ] , logger = logger , error_formatter = error_formatter , debug = debug , extension_manager = extension_manager , ) [EOL] else : [EOL] return handle_query_result ( result , logger = logger , error_formatter = error_formatter , debug = debug , extension_manager = extension_manager , ) [EOL] [EOL] [EOL] def graphql_sync ( schema , data , * , context_value = None , root_value = None , debug = False , introspection = True , logger = None , validation_rules = None , error_formatter = format_error , middleware = None , extensions = None , ** kwargs , ) : [EOL] extension_manager = ExtensionManager ( extensions , context_value ) [EOL] [EOL] with extension_manager . request ( ) : [EOL] try : [EOL] validate_data ( data ) [EOL] query , variables , operation_name = ( data [ [string] ] , data . get ( [string] ) , data . get ( [string] ) , ) [EOL] [EOL] document = parse_query ( query ) [EOL] [EOL] if callable ( validation_rules ) : [EOL] validation_rules = cast ( Optional [ Sequence [ RuleType ] ] , validation_rules ( context_value , document , data ) , ) [EOL] [EOL] validation_errors = validate_query ( schema , document , validation_rules , enable_introspection = introspection ) [EOL] if validation_errors : [EOL] return handle_graphql_errors ( validation_errors , logger = logger , error_formatter = error_formatter , debug = debug , extension_manager = extension_manager , ) [EOL] [EOL] if callable ( root_value ) : [EOL] root_value = root_value ( context_value , document ) [EOL] if isawaitable ( root_value ) : [EOL] ensure_future ( root_value ) . cancel ( ) [EOL] raise RuntimeError ( [string] [string] ) [EOL] [EOL] result = execute ( schema , document , root_value = root_value , context_value = context_value , variable_values = variables , operation_name = operation_name , execution_context_class = ExecutionContext , middleware = extension_manager . as_middleware_manager ( middleware ) , ** kwargs , ) [EOL] [EOL] if isawaitable ( result ) : [EOL] ensure_future ( cast ( Awaitable [ ExecutionResult ] , result ) ) . cancel ( ) [EOL] raise RuntimeError ( [string] ) [EOL] except GraphQLError as error : [EOL] return handle_graphql_errors ( [ error ] , logger = logger , error_formatter = error_formatter , debug = debug , extension_manager = extension_manager , ) [EOL] else : [EOL] return handle_query_result ( result , logger = logger , error_formatter = error_formatter , debug = debug , extension_manager = extension_manager , ) [EOL] [EOL] [EOL] async def subscribe ( schema , data , * , context_value = None , root_value = None , debug = False , introspection = True , logger = None , validation_rules = None , error_formatter = format_error , ** kwargs , ) : [EOL] try : [EOL] validate_data ( data ) [EOL] query , variables , operation_name = ( data [ [string] ] , data . get ( [string] ) , data . get ( [string] ) , ) [EOL] [EOL] document = parse_query ( query ) [EOL] [EOL] if callable ( validation_rules ) : [EOL] validation_rules = cast ( Optional [ Sequence [ RuleType ] ] , validation_rules ( context_value , document , data ) , ) [EOL] [EOL] validation_errors = validate_query ( schema , document , validation_rules , enable_introspection = introspection ) [EOL] if validation_errors : [EOL] for error_ in validation_errors : [comment] [EOL] log_error ( error_ , logger ) [EOL] return ( False , [ error_formatter ( error , debug ) for error in validation_errors ] , ) [EOL] [EOL] if callable ( root_value ) : [EOL] root_value = root_value ( context_value , document ) [EOL] if isawaitable ( root_value ) : [EOL] root_value = await root_value [EOL] [EOL] result = await _subscribe ( schema , document , root_value = root_value , context_value = context_value , variable_values = variables , operation_name = operation_name , ** kwargs , ) [EOL] except GraphQLError as error : [EOL] log_error ( error , logger ) [EOL] return False , [ error_formatter ( error , debug ) ] [EOL] else : [EOL] if isinstance ( result , ExecutionResult ) : [EOL] errors = cast ( List [ GraphQLError ] , result . errors ) [EOL] for error_ in errors : [comment] [EOL] log_error ( error_ , logger ) [EOL] return False , [ error_formatter ( error , debug ) for error in errors ] [EOL] return True , cast ( AsyncGenerator , result ) [EOL] [EOL] [EOL] def handle_query_result ( result , * , logger , error_formatter , debug , extension_manager = None ) : [EOL] response = { [string] : result . data } [EOL] if result . errors : [EOL] for error in result . errors : [EOL] log_error ( error , logger ) [EOL] response [ [string] ] = [ error_formatter ( error , debug ) for error in result . errors ] [EOL] [EOL] if extension_manager : [EOL] if result . errors : [EOL] extension_manager . has_errors ( result . errors ) [EOL] add_extensions_to_response ( extension_manager , response ) [EOL] return True , response [EOL] [EOL] [EOL] def handle_graphql_errors ( errors , * , logger , error_formatter , debug , extension_manager = None , ) : [EOL] for error in errors : [EOL] log_error ( error , logger ) [EOL] response = { [string] : [ error_formatter ( error , debug ) for error in errors ] } [EOL] if extension_manager : [EOL] extension_manager . has_errors ( errors ) [EOL] add_extensions_to_response ( extension_manager , response ) [EOL] return False , response [EOL] [EOL] [EOL] def parse_query ( query ) : [EOL] try : [EOL] return parse ( query ) [EOL] except GraphQLError as error : [EOL] raise error [EOL] except Exception as error : [EOL] raise GraphQLError ( str ( error ) , original_error = error ) [EOL] [EOL] [EOL] def add_extensions_to_response ( extension_manager , response ) : [EOL] formatted_extensions = extension_manager . format ( ) [EOL] if formatted_extensions : [EOL] if [string] in response : [EOL] response [ [string] ] . update ( formatted_extensions ) [EOL] else : [EOL] response [ [string] ] = formatted_extensions [EOL] [EOL] [EOL] def validate_query ( schema , document_ast , rules = None , type_info = None , enable_introspection = True , ) : [EOL] if not enable_introspection : [EOL] rules = ( list ( rules ) + [ IntrospectionDisabledRule ] [EOL] if rules is not None [EOL] else [ IntrospectionDisabledRule ] ) [EOL] if rules : [EOL] [comment] [EOL] supplemented_rules = specified_rules + list ( rules ) [EOL] return validate ( schema , document_ast , rules = supplemented_rules , type_info = type_info , ) [EOL] [comment] [EOL] return validate ( schema , document_ast , rules = specified_rules , type_info = type_info ) [EOL] [EOL] [EOL] def validate_data ( data ) : [EOL] if not isinstance ( data , dict ) : [EOL] raise GraphQLError ( [string] ) [EOL] validate_query_body ( data . get ( [string] ) ) [EOL] validate_variables ( data . get ( [string] ) ) [EOL] validate_operation_name ( data . get ( [string] ) ) [EOL] [EOL] [EOL] def validate_query_body ( query ) : [EOL] if not query or not isinstance ( query , str ) : [EOL] raise GraphQLError ( [string] ) [EOL] [EOL] [EOL] def validate_variables ( variables ) : [EOL] if variables is not None and not isinstance ( variables , dict ) : [EOL] raise GraphQLError ( [string] ) [EOL] [EOL] [EOL] def validate_operation_name ( operation_name ) : [EOL] if operation_name is not None and not isinstance ( operation_name , str ) : [EOL] raise GraphQLError ( [string] % operation_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graphql.GraphQLError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Callable , Dict , Literal , Optional , Any , AsyncGenerator , List , Union [EOL] import typing_extensions [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import starlette [EOL] import ariadne [EOL] import typing [EOL] import asyncio [EOL] import json [EOL] from inspect import isawaitable [EOL] from typing import ( Any , AsyncGenerator , Callable , Dict , List , Optional , Union , Type , cast , ) [EOL] [EOL] from graphql import GraphQLError , GraphQLSchema [EOL] from graphql . execution import Middleware , MiddlewareManager [EOL] from starlette . datastructures import UploadFile [EOL] from starlette . requests import Request [EOL] from starlette . responses import HTMLResponse , JSONResponse , PlainTextResponse , Response [EOL] from starlette . types import Receive , Scope , Send [EOL] from starlette . websockets import WebSocket , WebSocketState , WebSocketDisconnect [EOL] [EOL] from . constants import DATA_TYPE_JSON , DATA_TYPE_MULTIPART , PLAYGROUND_HTML [EOL] from . exceptions import HttpBadRequestError , HttpError [EOL] from . file_uploads import combine_multipart_data [EOL] from . format_error import format_error [EOL] from . graphql import graphql , subscribe [EOL] from . logger import log_error [EOL] from . types import ContextValue , ErrorFormatter , Extension , RootValue , ValidationRules [EOL] [EOL] GQL_CONNECTION_INIT = [string] [comment] [EOL] GQL_CONNECTION_ACK = [string] [comment] [EOL] GQL_CONNECTION_ERROR = [string] [comment] [EOL] [EOL] [comment] [EOL] GQL_CONNECTION_KEEP_ALIVE = [string] [comment] [EOL] [EOL] GQL_CONNECTION_TERMINATE = [string] [comment] [EOL] GQL_START = [string] [comment] [EOL] GQL_DATA = [string] [comment] [EOL] GQL_ERROR = [string] [comment] [EOL] GQL_COMPLETE = [string] [comment] [EOL] GQL_STOP = [string] [comment] [EOL] [EOL] ExtensionList = Optional [ List [ Type [ Extension ] ] ] [EOL] Extensions = Union [ Callable [ [ Any , Optional [ ContextValue ] ] , ExtensionList ] , ExtensionList ] [EOL] MiddlewareList = Optional [ List [ Middleware ] ] [EOL] Middlewares = Union [ Callable [ [ Any , Optional [ ContextValue ] ] , MiddlewareList ] , MiddlewareList ] [EOL] [EOL] [EOL] class GraphQL : [EOL] def __init__ ( self , schema , * , context_value = None , root_value = None , validation_rules = None , debug = False , introspection = True , logger = None , error_formatter = format_error , extensions = None , middleware = None , keepalive = None , ) : [EOL] self . context_value = context_value [EOL] self . root_value = root_value [EOL] self . validation_rules = validation_rules [EOL] self . debug = debug [EOL] self . introspection = introspection [EOL] self . logger = logger [EOL] self . error_formatter = error_formatter [EOL] self . extensions = extensions [EOL] self . middleware = middleware [EOL] self . keepalive = keepalive [EOL] self . schema = schema [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] if scope [ [string] ] == [string] : [EOL] await self . handle_http ( scope = scope , receive = receive , send = send ) [EOL] elif scope [ [string] ] == [string] : [EOL] await self . handle_websocket ( scope = scope , receive = receive , send = send ) [EOL] else : [EOL] raise ValueError ( [string] % ( scope [ [string] ] , ) ) [EOL] [EOL] async def get_context_for_request ( self , request ) : [EOL] if callable ( self . context_value ) : [EOL] context = self . context_value ( request ) [EOL] if isawaitable ( context ) : [EOL] context = await context [EOL] return context [EOL] [EOL] return self . context_value or { [string] : request } [EOL] [EOL] async def get_extensions_for_request ( self , request , context ) : [EOL] if callable ( self . extensions ) : [EOL] extensions = self . extensions ( request , context ) [EOL] if isawaitable ( extensions ) : [EOL] extensions = await extensions [comment] [EOL] return extensions [EOL] return self . extensions [EOL] [EOL] async def get_middleware_for_request ( self , request , context ) : [EOL] middleware = self . middleware [EOL] if callable ( middleware ) : [EOL] middleware = middleware ( request , context ) [EOL] if isawaitable ( middleware ) : [EOL] middleware = await middleware [comment] [EOL] if middleware : [EOL] middleware = cast ( list , middleware ) [EOL] return MiddlewareManager ( * middleware ) [EOL] return None [EOL] [EOL] async def handle_http ( self , scope , receive , send ) : [EOL] request = Request ( scope = scope , receive = receive ) [EOL] if request . method == [string] and self . introspection : [EOL] [comment] [EOL] response = await self . render_playground ( request ) [EOL] elif request . method == [string] : [EOL] response = await self . graphql_http_server ( request ) [EOL] else : [EOL] response = Response ( status_code = [number] ) [EOL] await response ( scope , receive , send ) [EOL] [EOL] async def handle_websocket ( self , scope , receive , send ) : [EOL] websocket = WebSocket ( scope = scope , receive = receive , send = send ) [EOL] await self . websocket_server ( websocket ) [EOL] [EOL] async def render_playground ( self , request ) : [EOL] return HTMLResponse ( PLAYGROUND_HTML ) [EOL] [EOL] async def graphql_http_server ( self , request ) : [EOL] try : [EOL] data = await self . extract_data_from_request ( request ) [EOL] except HttpError as error : [EOL] return PlainTextResponse ( error . message or error . status , status_code = [number] ) [EOL] [EOL] context_value = await self . get_context_for_request ( request ) [EOL] extensions = await self . get_extensions_for_request ( request , context_value ) [EOL] middleware = await self . get_middleware_for_request ( request , context_value ) [EOL] [EOL] success , response = await graphql ( self . schema , data , context_value = context_value , root_value = self . root_value , validation_rules = self . validation_rules , debug = self . debug , introspection = self . introspection , logger = self . logger , error_formatter = self . error_formatter , extensions = extensions , middleware = middleware , ) [EOL] status_code = [number] if success else [number] [EOL] return JSONResponse ( response , status_code = status_code ) [EOL] [EOL] async def extract_data_from_request ( self , request ) : [EOL] content_type = request . headers . get ( [string] , [string] ) [EOL] content_type = content_type . split ( [string] ) [ [number] ] [EOL] [EOL] if content_type == DATA_TYPE_JSON : [EOL] return await self . extract_data_from_json_request ( request ) [EOL] if content_type == DATA_TYPE_MULTIPART : [EOL] return await self . extract_data_from_multipart_request ( request ) [EOL] [EOL] raise HttpBadRequestError ( [string] . format ( DATA_TYPE_JSON , DATA_TYPE_MULTIPART ) ) [EOL] [EOL] async def extract_data_from_json_request ( self , request ) : [EOL] try : [EOL] return await request . json ( ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] async def extract_data_from_multipart_request ( self , request ) : [EOL] try : [EOL] request_body = await request . form ( ) [EOL] except ValueError : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] try : [EOL] operations = json . loads ( request_body . get ( [string] ) ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] try : [EOL] files_map = json . loads ( request_body . get ( [string] ) ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] request_files = { key : value for key , value in request_body . items ( ) if isinstance ( value , UploadFile ) } [EOL] [EOL] return combine_multipart_data ( operations , files_map , request_files ) [EOL] [EOL] async def websocket_server ( self , websocket ) : [EOL] subscriptions = { } [EOL] await websocket . accept ( [string] ) [EOL] try : [EOL] while ( websocket . client_state != WebSocketState . DISCONNECTED [EOL] and websocket . application_state != WebSocketState . DISCONNECTED ) : [EOL] message = await websocket . receive_json ( ) [EOL] await self . handle_websocket_message ( message , websocket , subscriptions ) [EOL] except WebSocketDisconnect : [EOL] pass [EOL] finally : [EOL] for operation_id in subscriptions : [EOL] await subscriptions [ operation_id ] . aclose ( ) [EOL] [EOL] async def handle_websocket_message ( self , message , websocket , subscriptions , ) : [EOL] operation_id = cast ( str , message . get ( [string] ) ) [EOL] message_type = cast ( str , message . get ( [string] ) ) [EOL] [EOL] if message_type == GQL_CONNECTION_INIT : [EOL] await websocket . send_json ( { [string] : GQL_CONNECTION_ACK } ) [EOL] asyncio . ensure_future ( self . keep_websocket_alive ( websocket ) ) [EOL] elif message_type == GQL_CONNECTION_TERMINATE : [EOL] await websocket . close ( ) [EOL] elif message_type == GQL_START : [EOL] await self . start_websocket_subscription ( message . get ( [string] ) , operation_id , websocket , subscriptions ) [EOL] elif message_type == GQL_STOP : [EOL] if operation_id in subscriptions : [EOL] await subscriptions [ operation_id ] . aclose ( ) [EOL] del subscriptions [ operation_id ] [EOL] [EOL] async def keep_websocket_alive ( self , websocket ) : [EOL] if not self . keepalive : [EOL] return [EOL] while websocket . application_state != WebSocketState . DISCONNECTED : [EOL] try : [EOL] await websocket . send_json ( { [string] : GQL_CONNECTION_KEEP_ALIVE } ) [EOL] except WebSocketDisconnect : [EOL] return [EOL] await asyncio . sleep ( self . keepalive ) [EOL] [EOL] async def start_websocket_subscription ( self , data , operation_id , websocket , subscriptions , ) : [EOL] context_value = await self . get_context_for_request ( websocket ) [EOL] success , results = await subscribe ( self . schema , data , context_value = context_value , root_value = self . root_value , validation_rules = self . validation_rules , debug = self . debug , introspection = self . introspection , logger = self . logger , error_formatter = self . error_formatter , ) [EOL] if not success : [EOL] results = cast ( List [ dict ] , results ) [EOL] await websocket . send_json ( { [string] : GQL_ERROR , [string] : operation_id , [string] : results [ [number] ] } ) [EOL] else : [EOL] results = cast ( AsyncGenerator , results ) [EOL] subscriptions [ operation_id ] = results [EOL] asyncio . ensure_future ( self . observe_async_results ( results , operation_id , websocket ) ) [EOL] [EOL] async def observe_async_results ( self , results , operation_id , websocket ) : [EOL] try : [EOL] async for result in results : [EOL] payload = { } [EOL] if result . data : [EOL] payload [ [string] ] = result . data [EOL] if result . errors : [EOL] for error in result . errors : [EOL] log_error ( error , self . logger ) [EOL] payload [ [string] ] = [ self . error_formatter ( error , self . debug ) for error in result . errors ] [EOL] await websocket . send_json ( { [string] : GQL_DATA , [string] : operation_id , [string] : payload } ) [EOL] except Exception as error : [EOL] if not isinstance ( error , GraphQLError ) : [EOL] error = GraphQLError ( str ( error ) , original_error = error ) [EOL] log_error ( error , self . logger ) [EOL] payload = { [string] : [ self . error_formatter ( error , self . debug ) ] } [EOL] await websocket . send_json ( { [string] : GQL_DATA , [string] : operation_id , [string] : payload } ) [EOL] [EOL] if ( websocket . client_state != WebSocketState . DISCONNECTED [EOL] and websocket . application_state != WebSocketState . DISCONNECTED ) : [EOL] await websocket . send_json ( { [string] : GQL_COMPLETE , [string] : operation_id } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[typing.Any,unknown]$ 0 0 0 0 0 $None$ 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $starlette.websockets.WebSocket$ 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $starlette.websockets.WebSocket$ 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $starlette.websockets.WebSocket$ 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $starlette.websockets.WebSocket$ 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.AsyncGenerator]$ 0 $builtins.str$ 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.AsyncGenerator[typing.Any,typing.Any]$ 0 $builtins.str$ 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 $None$ 0 0 0 $typing.AsyncGenerator$ 0 $builtins.str$ 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $typing.AsyncGenerator$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $starlette.websockets.WebSocket$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Callable , Optional , Any , List , Union [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] from functools import wraps [EOL] from typing import Optional , Union , Callable , Dict , Any [EOL] [EOL] from graphql import GraphQLError , parse [EOL] [EOL] [EOL] def convert_camel_case_to_snake ( graphql_name ) : [EOL] python_name = [string] [EOL] for i , c in enumerate ( graphql_name . lower ( ) ) : [EOL] if i and c != graphql_name [ i ] : [EOL] python_name += [string] [EOL] python_name += c [EOL] return python_name [EOL] [EOL] [EOL] def gql ( value ) : [EOL] parse ( value ) [EOL] return value [EOL] [EOL] [EOL] def unwrap_graphql_error ( error ) : [EOL] if isinstance ( error , GraphQLError ) : [EOL] return unwrap_graphql_error ( error . original_error ) [EOL] return error [EOL] [EOL] [EOL] def convert_kwargs_to_snake_case ( func ) : [EOL] def convert_to_snake_case ( d ) : [EOL] converted = { } [EOL] for k , v in d . items ( ) : [EOL] if isinstance ( v , dict ) : [EOL] v = convert_to_snake_case ( v ) [EOL] if isinstance ( v , list ) : [EOL] v = [ convert_to_snake_case ( i ) if isinstance ( i , dict ) else i for i in v ] [EOL] converted [ convert_camel_case_to_snake ( k ) ] = v [EOL] return converted [EOL] [EOL] if asyncio . iscoroutinefunction ( func ) : [EOL] [EOL] @ wraps ( func ) async def async_wrapper ( * args , ** kwargs ) : [EOL] return await func ( * args , ** convert_to_snake_case ( kwargs ) ) [EOL] [EOL] return async_wrapper [EOL] [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] return func ( * args , ** convert_to_snake_case ( kwargs ) ) [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import ariadne [EOL] from typing import Optional , cast [EOL] [EOL] from graphql . type import ( GraphQLNamedType , GraphQLScalarLiteralParser , GraphQLScalarSerializer , GraphQLScalarType , GraphQLScalarValueParser , GraphQLSchema , ) [EOL] [EOL] from . types import SchemaBindable [EOL] [EOL] [EOL] class ScalarType ( SchemaBindable ) : [EOL] _serialize = ... [EOL] _parse_value = ... [EOL] _parse_literal = ... [EOL] [EOL] def __init__ ( self , name , * , serializer = None , value_parser = None , literal_parser = None , ) : [EOL] self . name = name [EOL] self . _serialize = serializer [EOL] self . _parse_value = value_parser [EOL] self . _parse_literal = literal_parser [EOL] [EOL] def set_serializer ( self , f ) : [EOL] self . _serialize = f [EOL] return f [EOL] [EOL] def set_value_parser ( self , f ) : [EOL] self . _parse_value = f [EOL] return f [EOL] [EOL] def set_literal_parser ( self , f ) : [EOL] self . _parse_literal = f [EOL] return f [EOL] [EOL] [comment] [EOL] serializer = set_serializer [EOL] value_parser = set_value_parser [EOL] literal_parser = set_literal_parser [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] self . validate_graphql_type ( graphql_type ) [EOL] graphql_type = cast ( GraphQLScalarType , graphql_type ) [EOL] [EOL] if self . _serialize : [EOL] [comment] [EOL] graphql_type . serialize = self . _serialize [comment] [EOL] if self . _parse_value : [EOL] graphql_type . parse_value = self . _parse_value [comment] [EOL] if self . _parse_literal : [EOL] graphql_type . parse_literal = self . _parse_literal [comment] [EOL] [EOL] def validate_graphql_type ( self , graphql_type ) : [EOL] if not graphql_type : [EOL] raise ValueError ( [string] % self . name ) [EOL] if not isinstance ( graphql_type , GraphQLScalarType ) : [EOL] raise ValueError ( [string] % ( self . name , type ( graphql_type ) . __name__ , GraphQLScalarType . __name__ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLScalarSerializer]$ 0 0 0 $typing.Optional[graphql.type.GraphQLScalarValueParser]$ 0 0 0 $typing.Optional[graphql.type.GraphQLScalarLiteralParser]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $graphql.type.GraphQLScalarSerializer$ 0 0 0 $graphql.type.GraphQLScalarValueParser$ 0 0 0 $graphql.type.GraphQLScalarLiteralParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $graphql.type.GraphQLScalarSerializer$ 0 0 0 0 0 $graphql.type.GraphQLScalarValueParser$ 0 0 0 0 0 $graphql.type.GraphQLScalarLiteralParser$ 0 0 0 $graphql.type.GraphQLScalarSerializer$ 0 0 0 $graphql.type.GraphQLScalarSerializer$ 0 0 0 0 0 0 0 $graphql.type.GraphQLScalarSerializer$ 0 0 $graphql.type.GraphQLScalarSerializer$ 0 0 0 $graphql.type.GraphQLScalarValueParser$ 0 0 0 $graphql.type.GraphQLScalarValueParser$ 0 0 0 0 0 0 0 $graphql.type.GraphQLScalarValueParser$ 0 0 $graphql.type.GraphQLScalarValueParser$ 0 0 0 $graphql.type.GraphQLScalarLiteralParser$ 0 0 0 $graphql.type.GraphQLScalarLiteralParser$ 0 0 0 0 0 0 0 $graphql.type.GraphQLScalarLiteralParser$ 0 0 $graphql.type.GraphQLScalarLiteralParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Optional [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import types [EOL] from reprlib import repr [comment] [EOL] from traceback import format_exception [EOL] [EOL] from typing import List , Optional , cast [EOL] [EOL] from graphql import GraphQLError [EOL] [EOL] from . utils import unwrap_graphql_error [EOL] [EOL] [EOL] def format_error ( error , debug = False ) : [EOL] formatted = error . formatted [EOL] if debug : [EOL] if [string] not in formatted : [EOL] formatted [ [string] ] = { } [EOL] formatted [ [string] ] [ [string] ] = get_error_extension ( error ) [EOL] return formatted [EOL] [EOL] [EOL] def get_error_extension ( error ) : [EOL] unwrapped_error = unwrap_graphql_error ( error ) [EOL] if unwrapped_error is None or not error . __traceback__ : [EOL] return None [EOL] [EOL] unwrapped_error = cast ( Exception , unwrapped_error ) [EOL] return { [string] : get_formatted_error_traceback ( unwrapped_error ) , [string] : get_formatted_error_context ( unwrapped_error ) , } [EOL] [EOL] [EOL] def get_formatted_error_traceback ( error ) : [EOL] formatted = [ ] [EOL] for line in format_exception ( type ( error ) , error , error . __traceback__ ) : [EOL] formatted . extend ( line . rstrip ( ) . splitlines ( ) ) [EOL] return formatted [EOL] [EOL] [EOL] def get_formatted_error_context ( error ) : [EOL] tb_last = error . __traceback__ [EOL] while tb_last and tb_last . tb_next : [EOL] tb_last = tb_last . tb_next [EOL] if tb_last is None : [EOL] return None [EOL] return { key : repr ( value ) for key , value in tb_last . tb_frame . f_locals . items ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type , Dict , Optional , Any , List [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import types [EOL] from contextlib import contextmanager [EOL] from typing import List , Optional , Type [EOL] [EOL] from graphql import GraphQLError [EOL] from graphql . execution import MiddlewareManager [EOL] [EOL] from . types import ContextValue , Extension [EOL] [EOL] [EOL] class ExtensionManager : [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , extensions = None , context = None , ) : [EOL] self . context = context [EOL] [EOL] if extensions : [EOL] self . extensions = tuple ( ext ( ) for ext in extensions ) [EOL] self . extensions_reversed = tuple ( reversed ( self . extensions ) ) [EOL] else : [EOL] self . extensions_reversed = self . extensions = tuple ( ) [EOL] [EOL] def as_middleware_manager ( self , manager ) : [EOL] if manager and manager . middlewares : [EOL] return MiddlewareManager ( * manager . middlewares , * self . extensions ) [EOL] return MiddlewareManager ( * self . extensions ) [EOL] [EOL] @ contextmanager def request ( self ) : [EOL] for ext in self . extensions : [EOL] ext . request_started ( self . context ) [EOL] try : [EOL] yield [EOL] finally : [EOL] for ext in self . extensions_reversed : [EOL] ext . request_finished ( self . context ) [EOL] [EOL] def has_errors ( self , errors ) : [EOL] for ext in self . extensions : [EOL] ext . has_errors ( errors , self . context ) [EOL] [EOL] def format ( self ) : [EOL] data = { } [EOL] for ext in self . extensions : [EOL] ext_data = ext . format ( self . context ) [EOL] if ext_data : [EOL] data . update ( ext_data ) [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.MiddlewareManager$ 0 0 0 $typing.Optional[graphql.execution.MiddlewareManager]$ 0 0 0 0 $typing.Optional[graphql.execution.MiddlewareManager]$ 0 $typing.Optional[graphql.execution.MiddlewareManager]$ 0 0 0 0 0 0 0 0 $typing.Optional[graphql.execution.MiddlewareManager]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graphql.GraphQLError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graphql.GraphQLError]$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Tuple , Type , Callable , Dict , Optional , Any , AsyncGenerator , List [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] from inspect import isawaitable [EOL] from typing import ( Any , AsyncGenerator , Callable , List , Optional , Sequence , Tuple , Type , Union , ) [EOL] from typing_extensions import Protocol [EOL] [EOL] from graphql import ( DocumentNode , ExecutionResult , GraphQLError , GraphQLResolveInfo , GraphQLSchema , ) [EOL] from graphql . validation . rules import ASTValidationRule [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] Resolver = Callable [ ... , Any ] [EOL] GraphQLResult = Tuple [ bool , dict ] [EOL] SubscriptionResult = Tuple [ bool , Union [ List [ dict ] , AsyncGenerator [ ExecutionResult , None ] ] ] [EOL] Subscriber = Callable [ ... , AsyncGenerator ] [EOL] ErrorFormatter = Callable [ [ GraphQLError , bool ] , dict ] [EOL] [EOL] ContextValue = Union [ Any , Callable [ [ Any ] , Any ] ] [EOL] RootValue = Union [ Any , Callable [ [ Optional [ Any ] , DocumentNode ] , Any ] ] [EOL] [EOL] ValidationRules = Union [ Sequence [ Type [ ASTValidationRule ] ] , Callable [ [ Optional [ Any ] , DocumentNode , dict ] , Optional [ Sequence [ Type [ ASTValidationRule ] ] ] ] , ] [EOL] [EOL] [EOL] class Extension ( Protocol ) : [EOL] def request_started ( self , context ) : [EOL] pass [comment] [EOL] [EOL] def request_finished ( self , context ) : [EOL] pass [comment] [EOL] [EOL] async def resolve ( self , next_ , parent , info , ** kwargs ) : [EOL] result = next_ ( parent , info , ** kwargs ) [EOL] if isawaitable ( result ) : [EOL] result = await result [EOL] return result [EOL] [EOL] def has_errors ( self , errors , context ) : [EOL] pass [comment] [EOL] [EOL] def format ( self , context ) : [EOL] pass [comment] [EOL] [EOL] [EOL] class ExtensionSync ( Extension ) : [EOL] def resolve ( self , next_ , parent , info , ** kwargs ) : [comment] [EOL] return next_ ( parent , info , ** kwargs ) [EOL] [EOL] [EOL] class SchemaBindable ( Protocol ) : [EOL] def bind_to_schema ( self , schema ) : [EOL] pass [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContextValue$ 0 0 0 0 0 0 0 0 0 0 0 0 $ContextValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Resolver$ 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 $typing.Any$ 0 $Resolver$ 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[graphql.GraphQLError]$ 0 $ContextValue$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 $ContextValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Resolver$ 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 0 $Resolver$ 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.GraphQLSchema$ 0 0 0 0 0 0
from typing import Any , Callable , Type , Optional [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import ariadne [EOL] import typing [EOL] from typing import Optional , cast [EOL] [EOL] from graphql . type import ( GraphQLInterfaceType , GraphQLNamedType , GraphQLObjectType , GraphQLSchema , ) [EOL] [EOL] from . objects import ObjectType [EOL] from . types import Resolver [EOL] [EOL] [EOL] class InterfaceType ( ObjectType ) : [EOL] _resolve_type = ... [EOL] [EOL] def __init__ ( self , name , type_resolver = None ) : [EOL] super ( ) . __init__ ( name ) [EOL] self . _resolve_type = type_resolver [EOL] [EOL] def set_type_resolver ( self , type_resolver ) : [EOL] self . _resolve_type = type_resolver [EOL] return type_resolver [EOL] [EOL] [comment] [EOL] type_resolver = set_type_resolver [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] self . validate_graphql_type ( graphql_type ) [EOL] graphql_type = cast ( GraphQLInterfaceType , graphql_type ) [EOL] [EOL] graphql_type . resolve_type = self . _resolve_type [EOL] self . bind_resolvers_to_graphql_type ( graphql_type ) [EOL] [EOL] for object_type in schema . type_map . values ( ) : [EOL] if _type_implements_interface ( self . name , object_type ) : [EOL] self . bind_resolvers_to_graphql_type ( object_type , replace_existing = False ) [EOL] [EOL] def validate_graphql_type ( self , graphql_type ) : [EOL] if not graphql_type : [EOL] raise ValueError ( [string] % self . name ) [EOL] if not isinstance ( graphql_type , GraphQLInterfaceType ) : [EOL] raise ValueError ( [string] % ( self . name , type ( graphql_type ) . __name__ , GraphQLInterfaceType . __name__ , ) ) [EOL] [EOL] [EOL] def _type_implements_interface ( interface , graphql_type ) : [EOL] if not isinstance ( graphql_type , GraphQLObjectType ) : [EOL] return False [EOL] return interface in [ i . name for i in graphql_type . interfaces ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[types.Resolver]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import enum [EOL] [EOL] from typing import Any , Dict , Optional , Union , cast [EOL] [EOL] from graphql . type import GraphQLEnumType , GraphQLNamedType , GraphQLSchema [EOL] [EOL] from . types import SchemaBindable [EOL] [EOL] [EOL] class EnumType ( SchemaBindable ) : [EOL] def __init__ ( self , name , values = Union [ Dict [ str , Any ] , enum . Enum , enum . IntEnum ] ) : [EOL] self . name = name [EOL] try : [EOL] self . values = values . __members__ [comment] [EOL] except AttributeError : [EOL] self . values = values [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] self . validate_graphql_type ( graphql_type ) [EOL] graphql_type = cast ( GraphQLEnumType , graphql_type ) [EOL] [EOL] for key , value in self . values . items ( ) : [EOL] if key not in graphql_type . values : [EOL] raise ValueError ( [string] % ( key , self . name ) ) [EOL] graphql_type . values [ key ] . value = value [EOL] [EOL] def validate_graphql_type ( self , graphql_type ) : [EOL] if not graphql_type : [EOL] raise ValueError ( [string] % self . name ) [EOL] if not isinstance ( graphql_type , GraphQLEnumType ) : [EOL] raise ValueError ( [string] % ( self . name , type ( graphql_type ) . __name__ , GraphQLEnumType . __name__ ) ) [EOL] [EOL] [EOL] def set_default_enum_values_on_schema ( schema ) : [EOL] for type_object in schema . type_map . values ( ) : [EOL] if isinstance ( type_object , GraphQLEnumType ) : [EOL] set_default_enum_values ( type_object ) [EOL] [EOL] [EOL] def set_default_enum_values ( graphql_type ) : [EOL] for key in graphql_type . values : [EOL] if graphql_type . values [ key ] . value is None : [EOL] graphql_type . values [ key ] . value = key [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import ariadne [EOL] from . constants import HTTP_STATUS_400_BAD_REQUEST , HTTP_STATUS_405_METHOD_NOT_ALLOWED [EOL] [EOL] [EOL] class HttpError ( Exception ) : [EOL] status = [string] [EOL] [EOL] def __init__ ( self , message = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . message = message [EOL] [EOL] [EOL] class HttpBadRequestError ( HttpError ) : [EOL] status = HTTP_STATUS_400_BAD_REQUEST [EOL] [EOL] [EOL] class HttpMethodNotAllowedError ( HttpError ) : [EOL] status = HTTP_STATUS_405_METHOD_NOT_ALLOWED [EOL] [EOL] [EOL] class GraphQLFileSyntaxError ( Exception ) : [EOL] def __init__ ( self , schema_file , message ) : [EOL] super ( ) . __init__ ( ) [EOL] self . message = self . format_message ( schema_file , message ) [EOL] [EOL] def format_message ( self , schema_file , message ) : [EOL] return f" [string] { schema_file } [string] { message }" [EOL] [EOL] def __str__ ( self ) : [EOL] return self . message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Type , Optional [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import ariadne [EOL] import typing [EOL] from typing import Optional , cast [EOL] [EOL] from graphql . type import GraphQLNamedType , GraphQLUnionType , GraphQLSchema [EOL] [EOL] from . types import Resolver , SchemaBindable [EOL] [EOL] [EOL] class UnionType ( SchemaBindable ) : [EOL] _resolve_type = ... [EOL] [EOL] def __init__ ( self , name , type_resolver = None ) : [EOL] self . name = name [EOL] self . _resolve_type = type_resolver [EOL] [EOL] def set_type_resolver ( self , type_resolver ) : [EOL] self . _resolve_type = type_resolver [EOL] return type_resolver [EOL] [EOL] [comment] [EOL] type_resolver = set_type_resolver [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] self . validate_graphql_type ( graphql_type ) [EOL] graphql_type = cast ( GraphQLUnionType , graphql_type ) [EOL] graphql_type . resolve_type = self . _resolve_type [EOL] [EOL] def validate_graphql_type ( self , graphql_type ) : [EOL] if not graphql_type : [EOL] raise ValueError ( [string] % self . name ) [EOL] if not isinstance ( graphql_type , GraphQLUnionType ) : [EOL] raise ValueError ( [string] % ( self . name , type ( graphql_type ) . __name__ , GraphQLUnionType . __name__ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[types.Resolver]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . enums import EnumType [EOL] from . executable_schema import make_executable_schema [EOL] from . extensions import ExtensionManager [EOL] from . file_uploads import combine_multipart_data , upload_scalar [EOL] from . format_error import ( format_error , get_error_extension , get_formatted_error_context , get_formatted_error_traceback , ) [EOL] from . graphql import graphql , graphql_sync , subscribe [EOL] from . interfaces import InterfaceType [EOL] from . load_schema import load_schema_from_path [EOL] from . objects import MutationType , ObjectType , QueryType [EOL] from . resolvers import ( FallbackResolversSetter , SnakeCaseFallbackResolversSetter , fallback_resolvers , is_default_resolver , resolve_to , snake_case_fallback_resolvers , ) [EOL] from . scalars import ScalarType [EOL] from . schema_visitor import SchemaDirectiveVisitor [EOL] from . subscriptions import SubscriptionType [EOL] from . types import SchemaBindable [EOL] from . unions import UnionType [EOL] from . utils import ( convert_camel_case_to_snake , convert_kwargs_to_snake_case , gql , unwrap_graphql_error , ) [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import logging [EOL] from typing import Optional [EOL] [EOL] from . utils import unwrap_graphql_error [EOL] [EOL] [EOL] def log_error ( error , logger_name ) : [EOL] original_error = unwrap_graphql_error ( error ) [EOL] if original_error and original_error is not error : [EOL] error . __suppress_context__ = True [EOL] error . __cause__ = original_error [EOL] [EOL] logger = logging . getLogger ( logger_name or [string] ) [EOL] logger . error ( error , exc_info = error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Optional , Union [EOL] import typing [EOL] import builtins [EOL] import ariadne [EOL] from typing import Optional , Union [EOL] from typing_extensions import Protocol [EOL] [EOL] from . exceptions import HttpBadRequestError [EOL] from . scalars import ScalarType [EOL] [EOL] SPEC_URL = [string] [EOL] [EOL] [EOL] class FilesDict ( Protocol ) : [EOL] def __getitem__ ( self , key ) : [EOL] ... [comment] [EOL] [EOL] [EOL] def combine_multipart_data ( operations , files_map , files ) : [EOL] if not isinstance ( operations , ( dict , list ) ) : [EOL] raise HttpBadRequestError ( [string] . format ( SPEC_URL ) ) [EOL] if not isinstance ( files_map , dict ) : [EOL] raise HttpBadRequestError ( [string] . format ( SPEC_URL ) ) [EOL] [EOL] files_map = inverse_files_map ( files_map , files ) [EOL] if isinstance ( operations , list ) : [EOL] for i , operation in enumerate ( operations ) : [EOL] add_files_to_variables ( operation . get ( [string] ) , [string] . format ( i ) , files_map ) [EOL] if isinstance ( operations , dict ) : [EOL] add_files_to_variables ( operations . get ( [string] ) , [string] , files_map ) [EOL] return operations [EOL] [EOL] [EOL] def inverse_files_map ( files_map , files ) : [EOL] inverted_map = { } [EOL] for field_name , paths in files_map . items ( ) : [EOL] if not isinstance ( paths , list ) : [EOL] raise HttpBadRequestError ( ( [string] [string] ) . format ( field_name , SPEC_URL ) ) [EOL] [EOL] for i , path in enumerate ( paths ) : [EOL] if not isinstance ( path , str ) : [EOL] raise HttpBadRequestError ( ( [string] [string] ) . format ( field_name , i , SPEC_URL ) ) [EOL] [EOL] try : [EOL] inverted_map [ path ] = files [ field_name ] [EOL] except KeyError : [EOL] raise HttpBadRequestError ( ( [string] ) . format ( field_name , SPEC_URL ) ) [EOL] [EOL] return inverted_map [EOL] [EOL] [EOL] def add_files_to_variables ( variables , path , files_map ) : [EOL] if isinstance ( variables , dict ) : [EOL] for variable , value in variables . items ( ) : [EOL] variable_path = [string] . format ( path , variable ) [EOL] if isinstance ( value , ( dict , list ) ) : [EOL] add_files_to_variables ( value , variable_path , files_map ) [EOL] elif value is None : [EOL] variables [ variable ] = files_map . get ( variable_path ) [EOL] [EOL] if isinstance ( variables , list ) : [EOL] for i , value in enumerate ( variables ) : [EOL] variable_path = [string] . format ( path , i ) [EOL] if isinstance ( value , ( dict , list ) ) : [EOL] add_files_to_variables ( value , variable_path , files_map ) [EOL] elif value is None : [EOL] variables [ i ] = files_map . get ( variable_path ) [EOL] [EOL] [EOL] upload_scalar = ScalarType ( [string] ) [EOL] [EOL] [EOL] @ upload_scalar . serializer def serialize_upload ( * _ ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] @ upload_scalar . literal_parser def parse_upload_literal ( * _ ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] @ upload_scalar . value_parser def parse_upload_value ( value ) : [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Callable , Optional [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import types [EOL] from typing import Callable , Dict , Optional , cast [EOL] [EOL] from graphql . type import GraphQLNamedType , GraphQLObjectType , GraphQLSchema [EOL] [EOL] from . resolvers import resolve_to [EOL] from . types import Resolver , SchemaBindable [EOL] [EOL] [EOL] class ObjectType ( SchemaBindable ) : [EOL] _resolvers = ... [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] self . _resolvers = { } [EOL] [EOL] def field ( self , name ) : [EOL] if not isinstance ( name , str ) : [EOL] raise ValueError ( [string] ) [EOL] return self . create_register_resolver ( name ) [EOL] [EOL] def create_register_resolver ( self , name ) : [EOL] def register_resolver ( f ) : [EOL] self . _resolvers [ name ] = f [EOL] return f [EOL] [EOL] return register_resolver [EOL] [EOL] def set_field ( self , name , resolver ) : [EOL] self . _resolvers [ name ] = resolver [EOL] return resolver [EOL] [EOL] def set_alias ( self , name , to ) : [EOL] self . _resolvers [ name ] = resolve_to ( to ) [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] self . validate_graphql_type ( graphql_type ) [EOL] graphql_type = cast ( GraphQLObjectType , graphql_type ) [EOL] self . bind_resolvers_to_graphql_type ( graphql_type ) [EOL] [EOL] def validate_graphql_type ( self , graphql_type ) : [EOL] if not graphql_type : [EOL] raise ValueError ( [string] % self . name ) [EOL] if not isinstance ( graphql_type , GraphQLObjectType ) : [EOL] raise ValueError ( [string] % ( self . name , type ( graphql_type ) . __name__ , GraphQLObjectType . __name__ ) ) [EOL] [EOL] def bind_resolvers_to_graphql_type ( self , graphql_type , replace_existing = True ) : [EOL] for field , resolver in self . _resolvers . items ( ) : [EOL] if field not in graphql_type . fields : [EOL] raise ValueError ( [string] % ( field , self . name ) ) [EOL] if graphql_type . fields [ field ] . resolve is None or replace_existing : [EOL] graphql_type . fields [ field ] . resolve = resolver [EOL] [EOL] [EOL] class QueryType ( ObjectType ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [EOL] class MutationType ( ObjectType ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,types.Resolver]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Optional , Union [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import ariadne [EOL] from datetime import date , datetime [EOL] from typing import Any , List , Optional , Union [EOL] [EOL] import dateutil . parser [EOL] from django . forms . utils import from_current_timezone [EOL] from django . utils import formats [EOL] from django . utils . translation import gettext_lazy as _ [EOL] [EOL] from . . . scalars import ScalarType [EOL] [EOL] [EOL] date_input_formats = formats . get_format_lazy ( [string] ) [EOL] datetime_input_formats = formats . get_format_lazy ( [string] ) [EOL] [EOL] date_scalar = ScalarType ( [string] ) [EOL] datetime_scalar = ScalarType ( [string] ) [EOL] [EOL] [EOL] @ date_scalar . serializer def serialize_date ( value ) : [EOL] if isinstance ( value , datetime ) : [EOL] value = value . date ( ) [EOL] return value . isoformat ( ) [EOL] [EOL] [EOL] @ date_scalar . value_parser def parse_date_value ( value ) : [EOL] parsed_value = parse_value ( value , date_input_formats ) [EOL] if not parsed_value : [EOL] raise ValueError ( _ ( [string] ) ) [EOL] return parsed_value . date ( ) [EOL] [EOL] [EOL] @ datetime_scalar . serializer def serialize_datetime ( value ) : [EOL] return value . isoformat ( ) [EOL] [EOL] [EOL] @ datetime_scalar . value_parser def parse_datetime_value ( value ) : [EOL] parsed_value = parse_value ( value , datetime_input_formats ) [EOL] if not parsed_value : [EOL] raise ValueError ( _ ( [string] ) ) [EOL] return from_current_timezone ( parsed_value ) [EOL] [EOL] [EOL] def parse_value ( value , formats ) : [EOL] for format_str in formats : [EOL] try : [EOL] return datetime . strptime ( value , format_str ) [EOL] except ( ValueError , TypeError ) : [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] return dateutil . parser . parse ( value ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Literal , Optional , Any , List , Union [EOL] import typing_extensions [EOL] import django [EOL] import types [EOL] import graphql [EOL] import builtins [EOL] import ariadne [EOL] import typing [EOL] import json [EOL] from typing import Any , Callable , List , Optional , Type , Union , cast [EOL] [EOL] from django . conf import settings [EOL] from django . http import HttpRequest , HttpResponseBadRequest , JsonResponse [EOL] from django . shortcuts import render [EOL] from django . utils . decorators import method_decorator [EOL] from django . views . decorators . csrf import csrf_exempt [EOL] from django . views . generic import TemplateView [EOL] from graphql import GraphQLSchema [EOL] from graphql . execution import MiddlewareManager [EOL] [EOL] from . . . constants import DATA_TYPE_JSON , DATA_TYPE_MULTIPART [EOL] from . . . exceptions import HttpBadRequestError [EOL] from . . . file_uploads import combine_multipart_data [EOL] from . . . format_error import format_error [EOL] from . . . graphql import graphql_sync [EOL] from . . . types import ( ContextValue , ErrorFormatter , Extension , GraphQLResult , RootValue , ValidationRules , ) [EOL] [EOL] ExtensionList = Optional [ List [ Type [ Extension ] ] ] [EOL] Extensions = Union [ Callable [ [ Any , Optional [ ContextValue ] ] , ExtensionList ] , ExtensionList ] [EOL] [EOL] DEFAULT_PLAYGROUND_OPTIONS = { [string] : [string] } [EOL] [EOL] [EOL] @ method_decorator ( csrf_exempt , name = [string] ) class GraphQLView ( TemplateView ) : [EOL] http_method_names = [ [string] , [string] , [string] ] [EOL] template_name = [string] [EOL] playground_options = None [EOL] introspection = True [EOL] schema = None [EOL] context_value = None [EOL] root_value = None [EOL] logger = None [EOL] validation_rules = None [EOL] error_formatter = None [EOL] extensions = None [EOL] middleware = None [EOL] [EOL] def get ( self , request , * args , ** kwargs ) : [comment] [EOL] options = DEFAULT_PLAYGROUND_OPTIONS . copy ( ) [EOL] if self . playground_options : [EOL] options . update ( self . playground_options ) [EOL] [EOL] return render ( request , self . get_template_names ( ) , { [string] : json . dumps ( options ) } , ) [EOL] [EOL] def post ( self , request , * args , ** kwargs ) : [comment] [EOL] if not self . schema : [EOL] raise ValueError ( [string] ) [EOL] [EOL] try : [EOL] data = self . extract_data_from_request ( request ) [EOL] except HttpBadRequestError as error : [EOL] return HttpResponseBadRequest ( error . message ) [EOL] [EOL] success , result = self . execute_query ( request , data ) [EOL] status_code = [number] if success else [number] [EOL] return JsonResponse ( result , status = status_code ) [EOL] [EOL] def extract_data_from_request ( self , request ) : [EOL] content_type = request . content_type or [string] [EOL] content_type = content_type . split ( [string] ) [ [number] ] [EOL] [EOL] if content_type == DATA_TYPE_JSON : [EOL] return self . extract_data_from_json_request ( request ) [EOL] if content_type == DATA_TYPE_MULTIPART : [EOL] return self . extract_data_from_multipart_request ( request ) [EOL] [EOL] raise HttpBadRequestError ( [string] . format ( DATA_TYPE_JSON , DATA_TYPE_MULTIPART ) ) [EOL] [EOL] def extract_data_from_json_request ( self , request ) : [EOL] try : [EOL] return json . loads ( request . body ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] def extract_data_from_multipart_request ( self , request ) : [EOL] try : [EOL] operations = json . loads ( request . POST . get ( [string] ) ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] try : [EOL] files_map = json . loads ( request . POST . get ( [string] ) ) [EOL] except ( TypeError , ValueError ) : [EOL] raise HttpBadRequestError ( [string] ) [EOL] [EOL] return combine_multipart_data ( operations , files_map , request . FILES ) [EOL] [EOL] def execute_query ( self , request , data ) : [EOL] context_value = self . get_context_for_request ( request ) [EOL] extensions = self . get_extensions_for_request ( request , context_value ) [EOL] [EOL] return graphql_sync ( cast ( GraphQLSchema , self . schema ) , data , context_value = context_value , root_value = self . root_value , validation_rules = self . validation_rules , debug = settings . DEBUG , introspection = self . introspection , logger = self . logger , error_formatter = self . error_formatter or format_error , extensions = extensions , middleware = self . middleware , ) [EOL] [EOL] def get_context_for_request ( self , request ) : [EOL] if callable ( self . context_value ) : [EOL] return self . context_value ( request ) [comment] [EOL] return self . context_value or { [string] : request } [EOL] [EOL] def get_extensions_for_request ( self , request , context ) : [EOL] if callable ( self . extensions ) : [EOL] return self . extensions ( request , context ) [comment] [EOL] return self . extensions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ExtensionList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from django . apps import AppConfig [EOL] [EOL] [EOL] class AriadneConfig ( AppConfig ) : [EOL] name = [string] [EOL] label = [string] [EOL] verbose_name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
default_app_config = [string] [EOL]	$builtins.str$ 0 0 0
	0
from typing import Type , Dict , Callable , Optional , Any [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import types [EOL] from copy import deepcopy [EOL] from functools import partial [EOL] from inspect import isawaitable [EOL] from typing import Any , Callable , Dict , Optional [EOL] [EOL] from graphql import GraphQLResolveInfo [EOL] from opentracing import Scope , Tracer , global_tracer [EOL] from opentracing . ext import tags [EOL] [EOL] from . . . types import ContextValue , Extension , Resolver [EOL] from . utils import format_path , should_trace [EOL] [EOL] ArgFilter = Callable [ [ Dict [ str , Any ] , GraphQLResolveInfo ] , Dict [ str , Any ] ] [EOL] [EOL] [EOL] class OpenTracingExtension ( Extension ) : [EOL] _arg_filter = ... [EOL] _root_scope = ... [EOL] _tracer = ... [EOL] [EOL] def __init__ ( self , * , arg_filter = None ) : [EOL] self . _arg_filter = arg_filter [EOL] self . _tracer = global_tracer ( ) [EOL] self . _root_scope = None [EOL] [EOL] def request_started ( self , context ) : [EOL] self . _root_scope = self . _tracer . start_active_span ( [string] ) [EOL] self . _root_scope . span . set_tag ( tags . COMPONENT , [string] ) [EOL] [EOL] def request_finished ( self , context ) : [EOL] self . _root_scope . close ( ) [EOL] [EOL] async def resolve ( self , next_ , parent , info , ** kwargs ) : [EOL] if not should_trace ( info ) : [EOL] result = next_ ( parent , info , ** kwargs ) [EOL] if isawaitable ( result ) : [EOL] result = await result [EOL] return result [EOL] [EOL] with self . _tracer . start_active_span ( info . field_name ) as scope : [EOL] span = scope . span [EOL] span . set_tag ( tags . COMPONENT , [string] ) [EOL] span . set_tag ( [string] , info . parent_type . name ) [EOL] [EOL] graphql_path = [string] . join ( map ( str , format_path ( info . path ) ) ) [EOL] span . set_tag ( [string] , graphql_path ) [EOL] [EOL] if kwargs : [EOL] filtered_kwargs = self . filter_resolver_args ( kwargs , info ) [EOL] for kwarg , value in filtered_kwargs . items ( ) : [EOL] span . set_tag ( f" [string] { kwarg }" , value ) [EOL] [EOL] result = next_ ( parent , info , ** kwargs ) [EOL] if isawaitable ( result ) : [EOL] result = await result [EOL] return result [EOL] [EOL] def filter_resolver_args ( self , args , info ) : [EOL] if not self . _arg_filter : [EOL] return args [EOL] [EOL] return self . _arg_filter ( deepcopy ( args ) , info ) [EOL] [EOL] [EOL] class OpenTracingExtensionSync ( OpenTracingExtension ) : [EOL] def resolve ( self , next_ , parent , info , ** kwargs ) : [comment] [EOL] if not should_trace ( info ) : [EOL] result = next_ ( parent , info , ** kwargs ) [EOL] return result [EOL] [EOL] with self . _tracer . start_active_span ( info . field_name ) as scope : [EOL] span = scope . span [EOL] span . set_tag ( tags . COMPONENT , [string] ) [EOL] span . set_tag ( [string] , info . parent_type . name ) [EOL] [EOL] graphql_path = [string] . join ( map ( str , format_path ( info . path ) ) ) [EOL] span . set_tag ( [string] , graphql_path ) [EOL] [EOL] if kwargs : [EOL] filtered_kwargs = self . filter_resolver_args ( kwargs , info ) [EOL] for kwarg , value in filtered_kwargs . items ( ) : [EOL] span . set_tag ( f" [string] { kwarg }" , value ) [EOL] [EOL] result = next_ ( parent , info , ** kwargs ) [EOL] return result [EOL] [EOL] [EOL] def opentracing_extension ( * , arg_filter = None ) : [EOL] return partial ( OpenTracingExtension , arg_filter = arg_filter ) [EOL] [EOL] [EOL] def opentracing_extension_sync ( * , arg_filter = None ) : [EOL] return partial ( OpenTracingExtensionSync , arg_filter = arg_filter ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ArgFilter]$ 0 0 0 $opentracing.Scope$ 0 0 0 $opentracing.Tracer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 0 0 0 0 $graphql.GraphQLResolveInfo$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $graphql.GraphQLResolveInfo$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] from graphql import GraphQLResolveInfo , ResponsePath [EOL] [EOL] from . . . resolvers import is_default_resolver [EOL] [EOL] [EOL] def format_path ( path ) : [EOL] elements = [ ] [EOL] while path : [EOL] elements . append ( path . key ) [EOL] path = path . prev [EOL] return elements [ : : - [number] ] [EOL] [EOL] [EOL] def should_trace ( info ) : [EOL] if info . field_name not in info . parent_type . fields : [EOL] return False [EOL] [EOL] resolver = info . parent_type . fields [ info . field_name ] . resolve [EOL] return not ( resolver is None or is_default_resolver ( resolver ) or is_introspection_field ( info ) ) [EOL] [EOL] [EOL] def is_introspection_field ( info ) : [EOL] path = info . path [EOL] while path : [EOL] if isinstance ( path . key , str ) and is_introspection_key ( path . key ) : [EOL] return True [EOL] path = path . prev [EOL] return False [EOL] [EOL] [EOL] def is_introspection_key ( key ) : [EOL] return key . lower ( ) in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Any , List , Union [EOL] import types [EOL] import schema_visitor [EOL] import graphql [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List , Type , Union , cast [EOL] [EOL] from graphql import extend_schema , parse [EOL] from graphql . language import DocumentNode [EOL] from graphql . type import ( GraphQLObjectType , GraphQLSchema , GraphQLUnionType , ) [EOL] [EOL] from . . . executable_schema import make_executable_schema , join_type_defs [EOL] from . . . schema_visitor import SchemaDirectiveVisitor [EOL] from . . . types import SchemaBindable [EOL] from . utils import get_entity_types , purge_schema_directives , resolve_entities [EOL] [EOL] [EOL] federation_service_type_defs = [string] [EOL] [EOL] federation_entity_type_defs = [string] [EOL] [EOL] [EOL] def make_federated_schema ( type_defs , * bindables , directives = None , ) : [EOL] if isinstance ( type_defs , list ) : [EOL] type_defs = join_type_defs ( type_defs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] sdl = purge_schema_directives ( type_defs ) [EOL] [EOL] type_defs = join_type_defs ( [ type_defs , federation_service_type_defs ] ) [EOL] schema = make_executable_schema ( type_defs , * bindables , directives = directives , ) [EOL] [EOL] [comment] [EOL] entity_types = get_entity_types ( schema ) [EOL] has_entities = len ( entity_types ) > [number] [EOL] [EOL] [comment] [EOL] if has_entities : [EOL] schema = extend_federated_schema ( schema , parse ( federation_entity_type_defs ) , ) [EOL] [EOL] [comment] [EOL] entity_type = schema . get_type ( [string] ) [EOL] if entity_type : [EOL] entity_type = cast ( GraphQLUnionType , entity_type ) [EOL] entity_type . types = entity_types [EOL] [EOL] query_type = schema . get_type ( [string] ) [EOL] if query_type : [EOL] query_type = cast ( GraphQLObjectType , query_type ) [EOL] query_type . fields [ [string] ] . resolve = resolve_entities [EOL] [EOL] [comment] [EOL] query_type = schema . get_type ( [string] ) [EOL] if query_type : [EOL] query_type = cast ( GraphQLObjectType , query_type ) [EOL] query_type . fields [ [string] ] . resolve = lambda _service , info : { [string] : sdl } [EOL] [EOL] return schema [EOL] [EOL] [EOL] def extend_federated_schema ( schema , document_ast , assume_valid = False , assume_valid_sdl = False , ) : [EOL] extended_schema = extend_schema ( schema , document_ast , assume_valid , assume_valid_sdl , ) [EOL] [EOL] for ( k , v ) in schema . type_map . items ( ) : [EOL] resolve_reference = getattr ( v , [string] , None ) [EOL] if resolve_reference and k in extended_schema . type_map : [EOL] setattr ( extended_schema . type_map [ k ] , [string] , resolve_reference , ) [EOL] [EOL] return extended_schema [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . interfaces import FederatedInterfaceType [EOL] from . objects import FederatedObjectType [EOL] from . schema import make_federated_schema [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Pattern , List [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from inspect import isawaitable [EOL] from typing import Any , List [EOL] [EOL] from graphql . language import DirectiveNode [EOL] from graphql . type import ( GraphQLNamedType , GraphQLInputObjectType , GraphQLObjectType , GraphQLResolveInfo , GraphQLSchema , ) [EOL] [EOL] [EOL] _i_token_delimiter = [string] [EOL] _i_token_name = [string] [EOL] _i_token_arguments = [string] [EOL] _i_token_location = [string] [EOL] [EOL] _r_directive_definition = re . compile ( [string] f"{ _i_token_delimiter } [string] " f" [string] { _i_token_delimiter } [string] { _i_token_name } [string] " f" [string] { _i_token_delimiter } [string] { _i_token_arguments } [string] " f"{ _i_token_delimiter } [string] " f"{ _i_token_delimiter } [string] { _i_token_delimiter } [string] { _i_token_location }" f" [string] { _i_token_delimiter } [string] { _i_token_delimiter }{ _i_token_location } [string] " [string] f" [string] { _i_token_delimiter } [string] " , ) [EOL] [EOL] _r_directive = re . compile ( [string] f" [string] { _i_token_delimiter } [string] { _i_token_name } [string] " f" [string] { _i_token_delimiter } [string] { _i_token_arguments } [string] " [string] f" [string] { _i_token_delimiter } [string] " , ) [EOL] [EOL] _allowed_directives = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def purge_schema_directives ( joined_type_defs ) : [EOL] [docstring] [EOL] joined_type_defs = _r_directive_definition . sub ( [string] , joined_type_defs ) [EOL] joined_type_defs = _r_directive . sub ( lambda m : m . group ( [number] ) if m . group ( [number] ) in _allowed_directives else [string] , joined_type_defs , ) [EOL] return joined_type_defs [EOL] [EOL] [EOL] def resolve_entities ( _ , info , ** kwargs ) : [EOL] representations = list ( kwargs . get ( [string] , list ( ) ) ) [EOL] [EOL] result = [ ] [EOL] for reference in representations : [EOL] __typename = reference [ [string] ] [EOL] type_object = info . schema . get_type ( __typename ) [EOL] [EOL] if not type_object or not isinstance ( type_object , GraphQLObjectType ) : [EOL] raise Exception ( f" [string] " f' [string] { __typename } [string] ' f" [string] " , ) [EOL] [EOL] resolve_reference = getattr ( type_object , [string] , lambda o , i , r : reference , ) [EOL] [EOL] representation = resolve_reference ( type_object , info , reference ) [EOL] [EOL] if isawaitable ( representation ) : [EOL] result . append ( add_typename_to_async_return ( representation , __typename ) ) [EOL] else : [EOL] result . append ( add_typename_to_possible_return ( representation , __typename ) ) [EOL] [EOL] return result [EOL] [EOL] [EOL] async def add_typename_to_async_return ( obj , typename ) : [EOL] return add_typename_to_possible_return ( await obj , typename ) [EOL] [EOL] [EOL] def get_entity_types ( schema ) : [EOL] [docstring] [EOL] schema_types = schema . type_map . values ( ) [EOL] [EOL] def check_type ( t ) : [EOL] return isinstance ( t , GraphQLObjectType ) and includes_directive ( t , [string] ) [EOL] [EOL] return [ t for t in schema_types if check_type ( t ) ] [EOL] [EOL] [EOL] def includes_directive ( type_object , directive_name , ) : [EOL] [docstring] [EOL] if isinstance ( type_object , GraphQLInputObjectType ) : [EOL] return False [EOL] [EOL] directives = gather_directives ( type_object ) [EOL] return any ( [ d . name . value == directive_name for d in directives ] ) [EOL] [EOL] [EOL] def gather_directives ( type_object , ) : [EOL] [docstring] [EOL] directives = [ ] [EOL] [EOL] if hasattr ( type_object , [string] ) : [EOL] if type_object . extension_ast_nodes : [EOL] for ast_node in type_object . extension_ast_nodes : [EOL] if ast_node . directives : [EOL] directives . extend ( ast_node . directives ) [EOL] [EOL] if hasattr ( type_object , [string] ) : [EOL] if type_object . ast_node and type_object . ast_node . directives : [EOL] directives . extend ( type_object . ast_node . directives ) [EOL] [EOL] return directives [EOL] [EOL] [EOL] def add_typename_to_possible_return ( obj , typename ) : [EOL] if obj is not None : [EOL] if isinstance ( obj , dict ) : [EOL] obj [ [string] ] = typename [EOL] else : [EOL] setattr ( obj , f" [string] { obj . __class__ . __name__ } [string] " , typename ) [EOL] return obj [EOL] return { [string] : typename } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graphql.type.GraphQLNamedType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graphql.language.DirectiveNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Optional [EOL] import graphql [EOL] import typing [EOL] import types [EOL] from typing import Optional [EOL] [EOL] from graphql . type import GraphQLSchema [EOL] [EOL] from . . . objects import ObjectType [EOL] from . . . types import Resolver [EOL] [EOL] [EOL] class FederatedObjectType ( ObjectType ) : [EOL] [docstring] [EOL] [EOL] _reference_resolver = None [EOL] [EOL] def reference_resolver ( self , arg = None ) : [EOL] def register_reference_resolver ( f ) : [EOL] self . _reference_resolver = f [EOL] return f [EOL] [EOL] if callable ( arg ) : [EOL] return register_reference_resolver ( arg ) [EOL] return register_reference_resolver [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] super ( ) . bind_to_schema ( schema ) [EOL] [EOL] if callable ( self . _reference_resolver ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] setattr ( graphql_type , [string] , self . _reference_resolver , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Optional [EOL] import graphql [EOL] import typing [EOL] import types [EOL] from typing import Optional [EOL] [EOL] from graphql . type import GraphQLSchema [EOL] [EOL] from . . . interfaces import InterfaceType , _type_implements_interface [EOL] from . . . types import Resolver [EOL] [EOL] [EOL] class FederatedInterfaceType ( InterfaceType ) : [EOL] [docstring] [EOL] [EOL] _reference_resolver = None [EOL] [EOL] def reference_resolver ( self , arg = None ) : [EOL] def register_reference_resolver ( f ) : [EOL] self . _reference_resolver = f [EOL] return f [EOL] [EOL] if callable ( arg ) : [EOL] return register_reference_resolver ( arg ) [EOL] return register_reference_resolver [EOL] [EOL] def bind_to_schema ( self , schema ) : [EOL] super ( ) . bind_to_schema ( schema ) [EOL] [EOL] if callable ( self . _reference_resolver ) : [EOL] graphql_type = schema . type_map . get ( self . name ) [EOL] setattr ( graphql_type , [string] , self . _reference_resolver , ) [EOL] [EOL] for object_type in schema . type_map . values ( ) : [EOL] if _type_implements_interface ( self . name , object_type ) : [EOL] if not hasattr ( object_type , [string] ) : [EOL] setattr ( object_type , [string] , self . _reference_resolver , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Optional , Any , List , Union [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] from functools import reduce [EOL] from operator import add , mul [EOL] from typing import Any , Dict , List , Optional , Union , cast [EOL] [EOL] from graphql import ( GraphQLError , GraphQLInterfaceType , GraphQLObjectType , GraphQLSchema , get_named_type , ) [EOL] from graphql . language import ( BooleanValueNode , FieldNode , FragmentDefinitionNode , FragmentSpreadNode , InlineFragmentNode , IntValueNode , ListValueNode , Node , OperationDefinitionNode , OperationType , StringValueNode , ) [EOL] from graphql . execution . values import get_argument_values [EOL] from graphql . type import GraphQLFieldMap [EOL] from graphql . validation import ValidationContext [EOL] from graphql . validation . rules import ASTValidationRule , ValidationRule [EOL] [EOL] cost_directive = [string] [EOL] [EOL] [EOL] CostAwareNode = Union [ FieldNode , FragmentDefinitionNode , FragmentSpreadNode , InlineFragmentNode , OperationDefinitionNode , ] [EOL] [EOL] [EOL] class CostValidator ( ValidationRule ) : [EOL] context = ... [EOL] maximum_cost = ... [EOL] default_cost = [number] [EOL] default_complexity = [number] [EOL] variables = None [EOL] cost_map = None [EOL] [EOL] def __init__ ( self , context , maximum_cost , * , default_cost = [number] , default_complexity = [number] , variables = None , cost_map = None , ) : [comment] [EOL] self . context = context [EOL] self . maximum_cost = maximum_cost [EOL] self . variables = variables [EOL] self . cost_map = cost_map [EOL] self . default_cost = default_cost [EOL] self . default_complexity = default_complexity [EOL] self . cost = [number] [EOL] self . operation_multipliers = [ ] [EOL] [EOL] def compute_node_cost ( self , node , type_def , parent_multipliers = None ) : [EOL] if parent_multipliers is None : [EOL] parent_multipliers = [ ] [EOL] if isinstance ( node , FragmentSpreadNode ) or not node . selection_set : [EOL] return [number] [EOL] fields = { } [EOL] if isinstance ( type_def , ( GraphQLObjectType , GraphQLInterfaceType ) ) : [EOL] fields = type_def . fields [EOL] total = [number] [EOL] for child_node in node . selection_set . selections : [EOL] self . operation_multipliers = parent_multipliers [ : ] [EOL] node_cost = self . default_cost [EOL] if isinstance ( child_node , FieldNode ) : [EOL] field = fields . get ( child_node . name . value ) [EOL] if not field : [EOL] continue [EOL] field_type = get_named_type ( field . type ) [EOL] try : [EOL] field_args = get_argument_values ( field , child_node , self . variables ) [EOL] except Exception as e : [EOL] report_error ( self . context , e ) [EOL] if self . cost_map : [EOL] cost_map_args = ( self . get_args_from_cost_map ( child_node , type_def . name , field_args ) [EOL] if type_def and type_def . name [EOL] else None ) [EOL] if cost_map_args is not None : [EOL] try : [EOL] node_cost = self . compute_cost ( ** cost_map_args ) [EOL] except ( TypeError , ValueError ) as e : [EOL] report_error ( self . context , e ) [EOL] else : [EOL] cost_is_computed = False [EOL] if field . ast_node and field . ast_node . directives : [EOL] directives_args = self . get_args_from_directives ( field . ast_node . directives , field_args ) [EOL] if directives_args is not None : [EOL] try : [EOL] node_cost = self . compute_cost ( ** directives_args ) [EOL] except ( TypeError , ValueError ) as e : [EOL] report_error ( self . context , e ) [EOL] cost_is_computed = True [EOL] if ( field_type [EOL] and field_type . ast_node [EOL] and field_type . ast_node . directives ) : [EOL] if not cost_is_computed and isinstance ( field_type , GraphQLObjectType ) : [EOL] directives_args = self . get_args_from_directives ( field_type . ast_node . directives , field_args ) [EOL] if directives_args is not None : [EOL] try : [EOL] node_cost = self . compute_cost ( ** directives_args ) [EOL] except ( TypeError , ValueError ) as e : [EOL] report_error ( self . context , e ) [EOL] child_cost = self . compute_node_cost ( child_node , field_type , self . operation_multipliers ) [EOL] node_cost += child_cost [EOL] if isinstance ( child_node , FragmentSpreadNode ) : [EOL] fragment = self . context . get_fragment ( child_node . name . value ) [EOL] if fragment : [EOL] fragment_type = self . context . schema . get_type ( fragment . type_condition . name . value ) [EOL] node_cost = self . compute_node_cost ( fragment , fragment_type ) [EOL] if isinstance ( child_node , InlineFragmentNode ) : [EOL] inline_fragment_type = type_def [EOL] if child_node . type_condition and child_node . type_condition . name : [EOL] inline_fragment_type = self . context . schema . get_type ( child_node . type_condition . name . value ) [EOL] node_cost = self . compute_node_cost ( child_node , inline_fragment_type ) [EOL] total += node_cost [EOL] return total [EOL] [EOL] def enter_operation_definition ( self , node , key , parent , path , ancestors ) : [comment] [EOL] if self . cost_map : [EOL] try : [EOL] validate_cost_map ( self . cost_map , self . context . schema ) [EOL] except GraphQLError as cost_map_error : [EOL] self . context . report_error ( cost_map_error ) [EOL] return [EOL] [EOL] if node . operation is OperationType . QUERY : [EOL] self . cost += self . compute_node_cost ( node , self . context . schema . query_type ) [EOL] if node . operation is OperationType . MUTATION : [EOL] self . cost += self . compute_node_cost ( node , self . context . schema . mutation_type ) [EOL] if node . operation is OperationType . SUBSCRIPTION : [EOL] self . cost += self . compute_node_cost ( node , self . context . schema . subscription_type ) [EOL] [EOL] def leave_operation_definition ( self , node , key , parent , path , ancestors ) : [comment] [EOL] if self . cost > self . maximum_cost : [EOL] self . context . report_error ( self . get_cost_exceeded_error ( ) ) [EOL] [EOL] def compute_cost ( self , multipliers = None , use_multipliers = True , complexity = None ) : [EOL] if complexity is None : [EOL] complexity = self . default_complexity [EOL] if use_multipliers : [EOL] if multipliers : [EOL] multiplier = reduce ( add , multipliers , [number] ) [EOL] self . operation_multipliers = self . operation_multipliers + [ multiplier ] [EOL] return reduce ( mul , self . operation_multipliers , complexity ) [EOL] return complexity [EOL] [EOL] def get_args_from_cost_map ( self , node , parent_type , field_args ) : [EOL] cost_args = None [EOL] cost_map = cast ( Dict [ Any , Dict ] , self . cost_map ) [EOL] if parent_type in cost_map : [EOL] cost_args = cost_map [ parent_type ] . get ( node . name . value ) [EOL] if not cost_args : [EOL] return None [EOL] cost_args = cost_args . copy ( ) [EOL] if [string] in cost_args : [EOL] cost_args [ [string] ] = self . get_multipliers_from_string ( cost_args [ [string] ] , field_args ) [EOL] return cost_args [EOL] [EOL] def get_args_from_directives ( self , directives , field_args ) : [EOL] cost_directive = next ( ( directive for directive in directives if directive . name . value == [string] ) , None , ) [EOL] if cost_directive and cost_directive . arguments : [EOL] complexity_arg = next ( ( argument for argument in cost_directive . arguments if argument . name . value == [string] ) , None , ) [EOL] use_multipliers_arg = next ( ( argument for argument in cost_directive . arguments if argument . name . value == [string] ) , None , ) [EOL] multipliers_arg = next ( ( argument for argument in cost_directive . arguments if argument . name . value == [string] ) , None , ) [EOL] use_multipliers = ( use_multipliers_arg . value . value [EOL] if use_multipliers_arg [EOL] and use_multipliers_arg . value [EOL] and isinstance ( use_multipliers_arg . value , BooleanValueNode ) [EOL] else True ) [EOL] multipliers = ( self . get_multipliers_from_list_node ( multipliers_arg . value . values , field_args ) [EOL] if multipliers_arg [EOL] and multipliers_arg . value [EOL] and isinstance ( multipliers_arg . value , ListValueNode ) [EOL] else [ ] ) [EOL] complexity = ( int ( complexity_arg . value . value ) [EOL] if complexity_arg [EOL] and complexity_arg . value [EOL] and isinstance ( complexity_arg . value , IntValueNode ) [EOL] else [ ] ) [EOL] return { [string] : complexity , [string] : multipliers , [string] : use_multipliers , } [EOL] [EOL] return None [EOL] [EOL] def get_multipliers_from_list_node ( self , multipliers , field_args ) : [EOL] multipliers = [ node . value for node in multipliers if isinstance ( node , StringValueNode ) ] [EOL] return self . get_multipliers_from_string ( multipliers , field_args ) [comment] [EOL] [EOL] def get_multipliers_from_string ( self , multipliers , field_args ) : [EOL] multipliers = [ field_args . get ( multiplier ) for multiplier in multipliers ] [EOL] multipliers = [ len ( multiplier ) if isinstance ( multiplier , ( list , tuple ) ) else multiplier for multiplier in multipliers ] [EOL] return [ m for m in multipliers if m != [number] ] [EOL] [EOL] def get_cost_exceeded_error ( self ) : [EOL] return GraphQLError ( cost_analysis_message ( self . maximum_cost , self . cost ) , extensions = { [string] : { [string] : self . cost , [string] : self . maximum_cost , } } , ) [EOL] [EOL] [EOL] def validate_cost_map ( cost_map , schema ) : [EOL] for type_name , type_fields in cost_map . items ( ) : [EOL] if type_name not in schema . type_map : [EOL] raise GraphQLError ( [string] f"{ type_name } [string] " ) [EOL] [EOL] if not isinstance ( schema . type_map [ type_name ] , GraphQLObjectType ) : [EOL] raise GraphQLError ( [string] f"{ type_name } [string] " ) [EOL] [EOL] for field_name in type_fields : [EOL] graphql_type = cast ( GraphQLObjectType , schema . type_map [ type_name ] ) [EOL] if field_name not in graphql_type . fields : [EOL] raise GraphQLError ( [string] f" [string] { field_name } [string] { type_name } [string] " ) [EOL] [EOL] [EOL] def report_error ( context , error ) : [EOL] context . report_error ( GraphQLError ( str ( error ) , original_error = error ) ) [EOL] [EOL] [EOL] def cost_analysis_message ( maximum_cost , cost ) : [EOL] return [string] % ( maximum_cost , cost , ) [EOL] [EOL] [EOL] def cost_validator ( maximum_cost , * , default_cost = [number] , default_complexity = [number] , variables = None , cost_map = None , ) : [EOL] class _CostValidator ( CostValidator ) : [EOL] def __init__ ( self , context ) : [EOL] super ( _CostValidator , self ) . __init__ ( context , maximum_cost = maximum_cost , default_cost = default_cost , default_complexity = default_complexity , variables = variables , cost_map = cost_map , ) [EOL] [EOL] return cast ( ASTValidationRule , _CostValidator ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.validation.ValidationContext$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $graphql.GraphQLError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.validation.ValidationContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.validation.ValidationContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . query_cost import cost_directive , cost_validator [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
import graphql [EOL] from graphql import GraphQLError [EOL] from graphql . language import FieldNode [EOL] from graphql . validation import ValidationRule [EOL] [EOL] from . . contrib . tracing . utils import is_introspection_key [EOL] [EOL] [EOL] class IntrospectionDisabledRule ( ValidationRule ) : [EOL] def enter_field ( self , node , * _args ) : [EOL] field_name = node . name . value [EOL] if not is_introspection_key ( field_name ) : [EOL] return [EOL] [EOL] self . report_error ( GraphQLError ( f" [string] { field_name } [string] " , node , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.language.FieldNode$ 0 0 0 0 0 0 0 0 $graphql.language.FieldNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.language.FieldNode$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from ariadne import make_executable_schema [EOL] [EOL] type_defs = [string] [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return make_executable_schema ( type_defs ) [EOL] [EOL] [EOL] def test_enum_has_description ( schema ) : [EOL] description = schema . get_type ( [string] ) . description [EOL] assert isinstance ( description , str ) [EOL] [EOL] [EOL] def test_enum_value_has_description ( schema ) : [EOL] value = schema . get_type ( [string] ) . values . get ( [string] ) [EOL] assert isinstance ( value . description , str ) [EOL] [EOL] [EOL] def test_object_type_has_description ( schema ) : [EOL] description = schema . get_type ( [string] ) . description [EOL] assert isinstance ( description , str ) [EOL] [EOL] [EOL] def test_object_field_has_description ( schema ) : [EOL] description = schema . get_type ( [string] ) . fields . get ( [string] ) . description [EOL] assert isinstance ( description , str ) [EOL] [EOL] [EOL] def test_object_field_argument_has_description ( schema ) : [EOL] translate_field = schema . get_type ( [string] ) . fields . get ( [string] ) [EOL] argument = translate_field . args . get ( [string] ) [EOL] assert isinstance ( argument . description , str ) [EOL] [EOL] [EOL] def test_undocumented_object_field_description_is_none ( schema ) : [EOL] description = schema . get_type ( [string] ) . fields . get ( [string] ) . description [EOL] assert description is None [EOL] [EOL] [EOL] def test_undocumented_object_field_argument_description_is_none ( schema ) : [EOL] my_field = schema . get_type ( [string] ) . fields . get ( [string] ) [EOL] description = my_field . args . get ( [string] ) . description [EOL] assert description is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import ariadne [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from ariadne import ExtensionManager , graphql_sync [EOL] from ariadne . types import ExtensionSync [EOL] [EOL] [EOL] context = { } [EOL] exception = ValueError ( ) [EOL] [EOL] [EOL] def test_request_started_hook_is_called_by_extension_manager ( ) : [EOL] extension = Mock ( spec = ExtensionSync ) [EOL] manager = ExtensionManager ( [ Mock ( return_value = extension ) ] , context ) [EOL] with manager . request ( ) : [EOL] pass [EOL] [EOL] extension . request_started . assert_called_once_with ( context ) [EOL] [EOL] [EOL] def test_request_finished_hook_is_called_by_extension_manager ( ) : [EOL] extension = Mock ( spec = ExtensionSync ) [EOL] manager = ExtensionManager ( [ Mock ( return_value = extension ) ] , context ) [EOL] with manager . request ( ) : [EOL] pass [EOL] [EOL] extension . request_finished . assert_called_once_with ( context ) [EOL] [EOL] [EOL] def test_has_errors_hook_is_called_with_errors_list_and_context ( ) : [EOL] extension = Mock ( spec = ExtensionSync ) [EOL] manager = ExtensionManager ( [ Mock ( return_value = extension ) ] , context ) [EOL] manager . has_errors ( [ exception ] ) [EOL] extension . has_errors . assert_called_once_with ( [ exception ] , context ) [EOL] [EOL] [EOL] def test_extension_format_hook_is_called_with_context ( ) : [EOL] extension = Mock ( spec = ExtensionSync , format = Mock ( return_value = { [string] : [number] } ) ) [EOL] manager = ExtensionManager ( [ Mock ( return_value = extension ) ] , context ) [EOL] manager . format ( ) [EOL] extension . format . assert_called_once_with ( context ) [EOL] [EOL] [EOL] def test_extensions_are_formatted ( ) : [EOL] extensions = [ Mock ( spec = ExtensionSync , format = Mock ( return_value = { [string] : [number] } ) ) , Mock ( spec = ExtensionSync , format = Mock ( return_value = { [string] : [number] } ) ) , ] [EOL] manager = ExtensionManager ( [ Mock ( return_value = ext ) for ext in extensions ] , context ) [EOL] assert manager . format ( ) == { [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] def test_default_extension_hooks_dont_interrupt_query_execution ( schema ) : [EOL] _ , response = graphql_sync ( schema , { [string] : [string] } , extensions = [ ExtensionSync ] ) [EOL] assert response [ [string] ] == { [string] : True } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.ValueError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.ValueError$ 0 0 0 0 0 0 0 0 0 0 $builtins.ValueError$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from graphql import GraphQLError [EOL] from graphql . validation . rules import ValidationRule [EOL] [EOL] from ariadne import graphql , graphql_sync , subscribe [EOL] [EOL] [EOL] class AlwaysInvalid ( ValidationRule ) : [EOL] def leave_operation_definition ( self , * args , ** kwargs ) : [EOL] self . context . report_error ( GraphQLError ( [string] ) ) [EOL] [EOL] [EOL] def test_graphql_sync_executes_the_query ( schema ) : [EOL] success , result = graphql_sync ( schema , { [string] : [string] } ) [EOL] assert success [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] def test_graphql_sync_uses_validation_rules ( schema ) : [EOL] success , result = graphql_sync ( schema , { [string] : [string] } , validation_rules = [ AlwaysInvalid ] ) [EOL] assert not success [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_graphql_sync_prevents_introspection_query_when_option_is_disabled ( schema ) : [EOL] success , result = graphql_sync ( schema , { [string] : [string] } , introspection = False ) [EOL] assert not success [EOL] assert ( result [ [string] ] [ [number] ] [ [string] ] == [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_graphql_execute_the_query ( schema ) : [EOL] success , result = await graphql ( schema , { [string] : [string] } ) [EOL] assert success [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_graphql_uses_validation_rules ( schema ) : [EOL] success , result = await graphql ( schema , { [string] : [string] } , validation_rules = [ AlwaysInvalid ] ) [EOL] assert not success [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_graphql_prevents_introspection_query_when_option_is_disabled ( schema ) : [EOL] success , result = await graphql ( schema , { [string] : [string] } , introspection = False ) [EOL] assert not success [EOL] assert ( result [ [string] ] [ [number] ] [ [string] ] == [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_subscription_returns_an_async_iterator ( schema ) : [EOL] success , result = await subscribe ( schema , { [string] : [string] } ) [EOL] assert success [EOL] response = await result . __anext__ ( ) [EOL] assert response . data == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_subscription_uses_validation_rules ( schema ) : [EOL] success , result = await subscribe ( schema , { [string] : [string] } , validation_rules = [ AlwaysInvalid ] ) [EOL] assert not success [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_subscription_prevents_introspection_query_when_option_is_disabled ( schema , ) : [EOL] success , result = await subscribe ( schema , { [string] : [string] } , introspection = False ) [EOL] assert not success [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from graphql . error import GraphQLSyntaxError [EOL] [EOL] from ariadne import gql [EOL] [EOL] [EOL] def test_valid_graphql_schema_string_is_returned_unchanged ( ) : [EOL] sdl = [string] [EOL] result = gql ( sdl ) [EOL] assert sdl == result [EOL] [EOL] [EOL] def test_invalid_graphql_schema_string_causes_syntax_error ( ) : [EOL] with pytest . raises ( GraphQLSyntaxError ) : [EOL] gql ( [string] ) [EOL] [EOL] [EOL] def test_valid_graphql_query_string_is_returned_unchanged ( ) : [EOL] query = [string] [EOL] result = gql ( query ) [EOL] assert query == result [EOL] [EOL] [EOL] def test_invalid_graphql_query_string_causes_syntax_error ( ) : [EOL] with pytest . raises ( GraphQLSyntaxError ) : [EOL] gql ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from graphql import get_introspection_query , graphql_sync [EOL] [EOL] from ariadne import make_executable_schema [EOL] [EOL] type_defs = [string] [EOL] [EOL] [EOL] def test_executable_schema_can_be_introspected ( ) : [EOL] schema = make_executable_schema ( type_defs ) [EOL] introspection_query = get_introspection_query ( descriptions = True ) [EOL] result = graphql_sync ( schema , introspection_query ) [EOL] assert result . errors is None [EOL] assert result . data is not None [EOL] assert [string] in result . data [EOL] type_names = [ schema_type [ [string] ] for schema_type in result . data [ [string] ] [ [string] ] ] [EOL] assert [string] in type_names [EOL] assert [string] in type_names [EOL] assert [string] in type_names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from unittest . mock import Mock [EOL] [EOL] from graphql import graphql_sync [EOL] [EOL] from ariadne import ObjectType , QueryType , make_executable_schema [EOL] [EOL] [EOL] def test_default_resolver_resolves_value_from_dict_item ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : { [string] : [string] } ) [EOL] [EOL] schema = make_executable_schema ( type_defs , query ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_default_resolver_resolves_value_from_object_attr ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : Mock ( node = [string] ) ) [EOL] [EOL] schema = make_executable_schema ( type_defs , query ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_resolver_is_called_to_resolve_custom_type_field_value ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : { [string] : [string] } ) [EOL] [EOL] custom = ObjectType ( [string] ) [EOL] custom . set_field ( [string] , lambda * _ : [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query , custom ] ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_and_default_resolvers_are_combined_to_resolve_custom_type_fields ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : { [string] : [string] , [string] : [string] } ) [EOL] [EOL] custom = ObjectType ( [string] ) [EOL] custom . set_field ( [string] , lambda * _ : [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query , custom ] ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_resolver_is_called_with_arguments_passed_with_query ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] [EOL] @ query . field ( [string] ) def resolve_test ( * _ , returnValue ) : [comment] [EOL] assert returnValue == [number] [EOL] return [string] [EOL] [EOL] schema = make_executable_schema ( type_defs , query ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [number] } [EOL] [EOL] [EOL] def test_custom_resolver_is_called_with_input_type_value_as_dict ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] [EOL] @ query . field ( [string] ) def resolve_test ( * _ , data ) : [comment] [EOL] assert data == { [string] : [number] } [EOL] return [string] [EOL] [EOL] schema = make_executable_schema ( type_defs , query ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import ariadne [EOL] import pytest [EOL] from graphql . validation . rules import ValidationRule [EOL] [EOL] from ariadne import ( MutationType , QueryType , SubscriptionType , make_executable_schema , upload_scalar , ) [EOL] [EOL] [EOL] @ pytest . fixture def type_defs ( ) : [EOL] return [string] [EOL] [EOL] [EOL] def resolve_hello ( * _ , name ) : [EOL] return [string] % name [EOL] [EOL] [EOL] def resolve_status ( * _ ) : [EOL] return True [EOL] [EOL] [EOL] def resolve_test_context ( _ , info ) : [EOL] return info . context . get ( [string] ) [EOL] [EOL] [EOL] def resolve_test_root ( root , * _ ) : [EOL] return root . get ( [string] ) [EOL] [EOL] [EOL] def resolve_error ( * _ ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def resolvers ( ) : [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , resolve_hello ) [EOL] query . set_field ( [string] , resolve_status ) [EOL] query . set_field ( [string] , resolve_test_context ) [EOL] query . set_field ( [string] , resolve_test_root ) [EOL] query . set_field ( [string] , resolve_error ) [EOL] return query [EOL] [EOL] [EOL] def resolve_upload ( * _ , file ) : [EOL] if file is not None : [EOL] return type ( file ) . __name__ [EOL] return None [EOL] [EOL] [EOL] @ pytest . fixture def mutations ( ) : [EOL] mutation = MutationType ( ) [EOL] mutation . set_field ( [string] , resolve_upload ) [EOL] return mutation [EOL] [EOL] [EOL] async def ping_generator ( * _ ) : [EOL] yield { [string] : [string] } [EOL] [EOL] [EOL] async def error_generator ( * _ ) : [EOL] raise Exception ( [string] ) [EOL] yield [number] [comment] [EOL] [EOL] [EOL] async def test_context_generator ( _ , info ) : [EOL] yield { [string] : info . context . get ( [string] ) } [EOL] [EOL] [EOL] async def test_root_generator ( root , * _ ) : [EOL] yield { [string] : root . get ( [string] ) } [EOL] [EOL] [EOL] @ pytest . fixture def subscriptions ( ) : [EOL] subscription = SubscriptionType ( ) [EOL] subscription . set_source ( [string] , ping_generator ) [EOL] subscription . set_source ( [string] , ping_generator ) [EOL] subscription . set_field ( [string] , resolve_error ) [EOL] subscription . set_source ( [string] , error_generator ) [EOL] subscription . set_source ( [string] , test_context_generator ) [EOL] subscription . set_source ( [string] , test_root_generator ) [EOL] return subscription [EOL] [EOL] [EOL] @ pytest . fixture def schema ( type_defs , resolvers , mutations , subscriptions ) : [EOL] return make_executable_schema ( type_defs , [ resolvers , mutations , subscriptions , upload_scalar ] ) [EOL] [EOL] [EOL] @ pytest . fixture def validation_rule ( ) : [EOL] class NoopRule ( ValidationRule ) : [EOL] pass [EOL] [EOL] return NoopRule [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] import pytest [EOL] from graphql import build_schema [EOL] [EOL] from ariadne import SubscriptionType [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return build_schema ( [string] ) [EOL] [EOL] [EOL] def test_field_source_can_be_set_using_setter ( schema ) : [EOL] async def source ( * _ ) : [EOL] yield [string] [comment] [EOL] [EOL] subscription = SubscriptionType ( ) [EOL] subscription . set_source ( [string] , source ) [EOL] subscription . bind_to_schema ( schema ) [EOL] field = schema . type_map . get ( [string] ) . fields [ [string] ] [EOL] assert field . subscribe is source [EOL] [EOL] [EOL] def test_field_source_can_be_set_using_decorator ( schema ) : [EOL] async def source ( * _ ) : [EOL] yield [string] [comment] [EOL] [EOL] subscription = SubscriptionType ( ) [EOL] subscription . source ( [string] ) ( source ) [EOL] subscription . bind_to_schema ( schema ) [EOL] field = schema . type_map . get ( [string] ) . fields [ [string] ] [EOL] assert field . subscribe is source [EOL] [EOL] [EOL] def test_value_error_is_raised_if_source_decorator_was_used_without_argument ( ) : [EOL] async def source ( * _ ) : [EOL] yield [string] [comment] [EOL] [EOL] subscription = SubscriptionType ( ) [EOL] with pytest . raises ( ValueError ) : [EOL] subscription . source ( source ) [EOL] [EOL] [EOL] def test_attempt_bind_subscription_to_undefined_field_raises_error ( schema ) : [EOL] async def source ( * _ ) : [EOL] yield [string] [comment] [EOL] [EOL] subscription = SubscriptionType ( ) [EOL] subscription . set_source ( [string] , source ) [EOL] with pytest . raises ( ValueError ) : [EOL] subscription . bind_to_schema ( schema ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] import pytest [EOL] [EOL] from graphql import GraphQLError [EOL] from graphql . language import parse [EOL] from graphql . validation import validate [EOL] [EOL] from ariadne import make_executable_schema [EOL] from ariadne . validation import cost_validator [EOL] [EOL] cost_directive = [string] [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] type_defs = [string] [EOL] [EOL] return make_executable_schema ( type_defs ) [EOL] [EOL] [EOL] @ pytest . fixture def schema_with_costs ( ) : [EOL] type_defs = [string] [EOL] [EOL] return make_executable_schema ( [ type_defs , cost_directive ] ) [EOL] [EOL] [EOL] cost_map = { [string] : { [string] : { [string] : [number] } , [string] : { [string] : [number] , [string] : [ [string] ] } , [string] : { [string] : [number] , [string] : [ [string] , [string] ] } , [string] : { [string] : [number] , [string] : [ [string] ] } , } , [string] : { [string] : { [string] : [number] } } , } [EOL] [EOL] [EOL] def test_cost_map_is_used_to_calculate_query_cost ( schema ) : [EOL] ast = parse ( [string] ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_query_validation_fails_if_cost_map_contains_undefined_type ( schema ) : [EOL] ast = parse ( [string] ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = { [string] : { [string] : [number] } } ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] [string] ) ] [EOL] [EOL] [EOL] def test_query_validation_fails_if_cost_map_contains_undefined_type_field ( schema ) : [EOL] ast = parse ( [string] ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = { [string] : { [string] : [number] } } ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] [string] ) ] [EOL] [EOL] [EOL] def test_query_validation_fails_if_cost_map_contains_non_object_type ( schema ) : [EOL] ast = parse ( [string] ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = { [string] : { [string] : [number] } } ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] [string] ) ] [EOL] [EOL] [EOL] def test_cost_directive_is_used_to_calculate_query_cost ( schema_with_costs ) : [EOL] ast = parse ( [string] ) [EOL] rule = cost_validator ( maximum_cost = [number] ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_field_cost_defined_in_map_is_multiplied_by_value_from_variables ( schema ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , variables = { [string] : [number] } , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_field_cost_defined_in_map_is_multiplied_by_value_from_literal ( schema ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_field_cost_defined_in_directive_is_multiplied_by_value_from_variables ( schema_with_costs , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , variables = { [string] : [number] } ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_field_cost_defined_in_directive_is_multiplied_by_value_from_literal ( schema_with_costs , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_complex_field_cost_defined_in_map_is_multiplied_by_values_from_variables ( schema , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , variables = { [string] : [number] , [string] : [number] } , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_complex_field_cost_defined_in_map_is_multiplied_by_values_from_literal ( schema ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_complex_field_cost_defined_in_directive_is_multiplied_by_values_from_variables ( schema_with_costs , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , variables = { [string] : [number] , [string] : [number] } ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_complex_field_cost_defined_in_directive_is_multiplied_by_values_from_literal ( schema_with_costs , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_child_field_cost_defined_in_map_is_multiplied_by_values_from_variables ( schema ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , variables = { [string] : [number] } , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_child_field_cost_defined_in_map_is_multiplied_by_values_from_literal ( schema ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , cost_map = cost_map ) [EOL] result = validate ( schema , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_child_field_cost_defined_in_directive_is_multiplied_by_values_from_variables ( schema_with_costs , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] , variables = { [string] : [number] } ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL] [EOL] [EOL] def test_child_field_cost_defined_in_directive_is_multiplied_by_values_from_literal ( schema_with_costs , ) : [EOL] query = [string] [EOL] ast = parse ( query ) [EOL] rule = cost_validator ( maximum_cost = [number] ) [EOL] result = validate ( schema_with_costs , ast , [ rule ] ) [EOL] assert result == [ GraphQLError ( [string] , extensions = { [string] : { [string] : [number] , [string] : [number] } } , ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from ariadne import exceptions , load_schema_from_path [EOL] [EOL] FIRST_SCHEMA = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def single_file_schema ( tmpdir_factory ) : [EOL] f = tmpdir_factory . mktemp ( [string] ) . join ( [string] ) [EOL] f . write ( FIRST_SCHEMA ) [EOL] return f [EOL] [EOL] [EOL] def test_load_schema_from_single_file ( single_file_schema ) : [EOL] assert load_schema_from_path ( str ( single_file_schema ) ) == FIRST_SCHEMA [EOL] [EOL] [EOL] INCORRECT_SCHEMA = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def incorrect_schema_file ( tmpdir_factory ) : [EOL] f = tmpdir_factory . mktemp ( [string] ) . join ( [string] ) [EOL] f . write ( INCORRECT_SCHEMA ) [EOL] return f [EOL] [EOL] [EOL] def test_loading_schema_fails_on_bad_syntax ( incorrect_schema_file ) : [EOL] with pytest . raises ( exceptions . GraphQLFileSyntaxError ) as e : [EOL] load_schema_from_path ( str ( incorrect_schema_file ) ) [EOL] assert str ( incorrect_schema_file ) in str ( e . value ) [EOL] [EOL] [EOL] SECOND_SCHEMA = [string] [EOL] [EOL] [EOL] @ pytest . fixture def schema_directory ( tmpdir_factory ) : [EOL] directory = tmpdir_factory . mktemp ( [string] ) [EOL] first_file = directory . join ( [string] ) [EOL] first_file . write ( FIRST_SCHEMA ) [EOL] second_file = directory . join ( [string] ) [EOL] second_file . write ( SECOND_SCHEMA ) [EOL] return directory [EOL] [EOL] [EOL] def test_loading_schema_from_directory ( schema_directory ) : [EOL] assert load_schema_from_path ( str ( schema_directory ) ) == [string] . join ( [ FIRST_SCHEMA , SECOND_SCHEMA ] ) [EOL] [EOL] [EOL] @ pytest . fixture def schema_nested_directories ( tmp_path_factory ) : [EOL] directory = tmp_path_factory . mktemp ( [string] ) [EOL] nested_dir = pathlib . Path ( directory . resolve ( ) , [string] ) [EOL] nested_dir . mkdir ( ) [EOL] first_file = pathlib . Path ( directory . resolve ( ) , [string] ) [EOL] first_file . write_text ( FIRST_SCHEMA ) [EOL] second_file = pathlib . Path ( nested_dir . resolve ( ) , [string] ) [EOL] second_file . write_text ( SECOND_SCHEMA ) [EOL] return directory [EOL] [EOL] [EOL] def test_loading_schema_from_nested_directories ( schema_nested_directories ) : [EOL] assert load_schema_from_path ( str ( schema_nested_directories ) ) == [string] . join ( [ FIRST_SCHEMA , SECOND_SCHEMA ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0
from typing import Any , Callable [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from graphql import default_field_resolver [EOL] [EOL] from ariadne . resolvers import is_default_resolver , resolve_to [EOL] [EOL] [EOL] def test_alias_resolver_supports_callable_return_value ( ) : [EOL] def callable_resolver ( * _ ) : [EOL] return True [EOL] [EOL] obj = Mock ( test = callable_resolver ) [EOL] alias_resolver = resolve_to ( [string] ) [EOL] assert alias_resolver ( obj , None ) [EOL] [EOL] [EOL] def test_alias_resolver_passess_field_args_to_callable_return_value ( ) : [EOL] def callable_resolver ( * _ , test ) : [EOL] return test [EOL] [EOL] obj = Mock ( test = callable_resolver ) [EOL] alias_resolver = resolve_to ( [string] ) [EOL] assert alias_resolver ( obj , None , test = True ) [EOL] [EOL] [EOL] def test_alias_resolver_passess_default_resolver_check ( ) : [EOL] alias_resolver = resolve_to ( [string] ) [EOL] assert is_default_resolver ( alias_resolver ) [EOL] [EOL] [EOL] def test_graphql_core_default_resolver_passess_default_resolver_check ( ) : [EOL] assert is_default_resolver ( default_field_resolver ) [EOL] [EOL] [EOL] def test_custom_resolver_fails_default_resolver_check ( ) : [EOL] def custom_resolver ( * _ ) : [EOL] ... [comment] [EOL] [EOL] assert not is_default_resolver ( custom_resolver ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from ariadne import convert_camel_case_to_snake [EOL] [EOL] [EOL] def test_lower_case_name_is_not_changed ( ) : [EOL] test_str = [string] [EOL] assert convert_camel_case_to_snake ( test_str ) == test_str [EOL] [EOL] [EOL] def test_two_words_snake_case_name_is_not_changed ( ) : [EOL] test_str = [string] [EOL] assert convert_camel_case_to_snake ( test_str ) == test_str [EOL] [EOL] [EOL] def test_three_words_snake_case_name_is_not_changed ( ) : [EOL] test_str = [string] [EOL] assert convert_camel_case_to_snake ( test_str ) == test_str [EOL] [EOL] [EOL] def test_pascal_case_name_is_lowercased ( ) : [EOL] assert convert_camel_case_to_snake ( [string] ) == [string] [EOL] [EOL] [EOL] def test_two_words_pascal_case_name_is_converted ( ) : [EOL] assert convert_camel_case_to_snake ( [string] ) == [string] [EOL] [EOL] [EOL] def test_two_words_camel_case_name_is_converted ( ) : [EOL] assert convert_camel_case_to_snake ( [string] ) == [string] [EOL] [EOL] [EOL] def test_three_words_pascal_case_name_is_converted ( ) : [EOL] assert convert_camel_case_to_snake ( [string] ) == [string] [EOL] [EOL] [EOL] def test_three_words_camel_case_name_is_converted ( ) : [EOL] assert convert_camel_case_to_snake ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import ariadne [EOL] import unittest [EOL] from reprlib import repr [comment] [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from graphql import graphql_sync [EOL] [EOL] from ariadne import QueryType , make_executable_schema [EOL] from ariadne . format_error import ( format_error , get_error_extension , get_formatted_error_context , ) [EOL] [EOL] [EOL] @ pytest . fixture def failing_repr_mock ( ) : [EOL] return Mock ( __repr__ = Mock ( side_effect = KeyError ( [string] ) ) , spec = [ [string] ] ) [EOL] [EOL] [EOL] @ pytest . fixture def erroring_resolvers ( failing_repr_mock ) : [EOL] query = QueryType ( ) [EOL] [EOL] @ query . field ( [string] ) def resolve_hello_with_context_and_attribute_error ( * _ ) : [EOL] [comment] [EOL] test_int = [number] [EOL] test_str = [string] [EOL] test_dict = { [string] : [string] } [EOL] test_obj = query [EOL] test_failing_repr = failing_repr_mock [EOL] test_undefined . error ( ) [comment] [EOL] [EOL] return query [EOL] [EOL] [EOL] @ pytest . fixture def schema ( type_defs , resolvers , erroring_resolvers , subscriptions ) : [EOL] return make_executable_schema ( type_defs , [ resolvers , erroring_resolvers , subscriptions ] ) [EOL] [EOL] [EOL] def test_default_formatter_is_not_extending_error_by_default ( schema ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] error = format_error ( result . errors [ [number] ] ) [EOL] assert not error . get ( [string] ) [EOL] [EOL] [EOL] def test_default_formatter_extends_error_with_stacktrace ( schema ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] error = format_error ( result . errors [ [number] ] , debug = True ) [EOL] assert error [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_default_formatter_extends_error_with_context ( schema ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] error = format_error ( result . errors [ [number] ] , debug = True ) [EOL] assert error [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_default_formatter_fills_context_with_reprs_of_python_context ( schema , erroring_resolvers , failing_repr_mock ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] error = format_error ( result . errors [ [number] ] , debug = True ) [EOL] context = error [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] assert context [ [string] ] == repr ( [number] ) [EOL] assert context [ [string] ] == repr ( [string] ) [EOL] assert context [ [string] ] == repr ( { [string] : [string] } ) [EOL] assert context [ [string] ] == repr ( failing_repr_mock ) [EOL] assert context [ [string] ] == repr ( erroring_resolvers ) [EOL] [EOL] [EOL] def test_default_formatter_is_not_extending_plain_graphql_error ( schema ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] error = format_error ( result . errors [ [number] ] , debug = True ) [EOL] assert error [ [string] ] [ [string] ] is None [EOL] [EOL] [EOL] def test_error_extension_is_not_available_for_error_without_traceback ( ) : [EOL] error = Mock ( __traceback__ = None , spec = [ [string] ] ) [EOL] assert get_error_extension ( error ) is None [EOL] [EOL] [EOL] def test_incomplete_traceback_is_handled_by_context_extractor ( ) : [EOL] error = Mock ( __traceback__ = None , spec = [ [string] ] ) [EOL] assert get_formatted_error_context ( error ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import ariadne [EOL] import pytest [EOL] from graphql import graphql_sync , build_schema [EOL] [EOL] from ariadne import ObjectType , fallback_resolvers , snake_case_fallback_resolvers [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return build_schema ( [string] ) [EOL] [EOL] [EOL] query = [string] [EOL] [EOL] [EOL] def test_default_fallback_resolves_fields_by_exact_names ( schema ) : [EOL] fallback_resolvers . bind_to_schema ( schema ) [EOL] query_root = { [string] : True , [string] : True , [string] : True , [string] : True } [EOL] result = graphql_sync ( schema , query , root_value = query_root ) [EOL] assert result . data == query_root [EOL] [EOL] [EOL] def test_default_fallback_is_not_converting_field_name_case_to_snake_case ( schema ) : [EOL] fallback_resolvers . bind_to_schema ( schema ) [EOL] query_root = { [string] : True , [string] : True , [string] : True , [string] : True } [EOL] result = graphql_sync ( schema , query , root_value = query_root ) [EOL] assert result . data == { [string] : True , [string] : True , [string] : None , [string] : None , } [EOL] [EOL] [EOL] def test_default_fallback_is_not_replacing_already_set_resolvers ( schema ) : [EOL] resolvers_map = ObjectType ( [string] ) [EOL] resolvers_map . set_field ( [string] , lambda * _ : False ) [EOL] resolvers_map . set_field ( [string] , lambda * _ : False ) [EOL] resolvers_map . bind_to_schema ( schema ) [EOL] fallback_resolvers . bind_to_schema ( schema ) [EOL] query_root = { [string] : True , [string] : True , [string] : True , [string] : True } [EOL] result = graphql_sync ( schema , query , root_value = query_root ) [EOL] assert result . data == { [string] : False , [string] : False , [string] : None , [string] : None , } [EOL] [EOL] [EOL] def test_snake_case_fallback_resolves_fields_names_to_snake_case_counterparts ( schema ) : [EOL] snake_case_fallback_resolvers . bind_to_schema ( schema ) [EOL] query_root = { [string] : True , [string] : True , [string] : True , [string] : True } [EOL] result = graphql_sync ( schema , query , root_value = query_root ) [EOL] assert result . data == { [string] : True , [string] : True , [string] : True , [string] : True , } [EOL] [EOL] [EOL] def test_snake_case_fallback_is_not_resolving_fields_by_exact_names ( schema ) : [EOL] snake_case_fallback_resolvers . bind_to_schema ( schema ) [EOL] query_root = { [string] : True , [string] : True , [string] : True , [string] : True } [EOL] result = graphql_sync ( schema , query , root_value = query_root ) [EOL] assert result . data == { [string] : True , [string] : True , [string] : None , [string] : None , } [EOL] [EOL] [EOL] def test_snake_case_fallback_is_not_replacing_already_set_resolvers ( schema ) : [EOL] resolvers_map = ObjectType ( [string] ) [EOL] resolvers_map . set_field ( [string] , lambda * _ : False ) [EOL] resolvers_map . set_field ( [string] , lambda * _ : False ) [EOL] resolvers_map . bind_to_schema ( schema ) [EOL] snake_case_fallback_resolvers . bind_to_schema ( schema ) [EOL] query_root = { [string] : True , [string] : True , [string] : True , [string] : True } [EOL] result = graphql_sync ( schema , query , root_value = query_root ) [EOL] assert result . data == { [string] : False , [string] : True , [string] : False , [string] : True , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from graphql import graphql_sync [EOL] [EOL] from ariadne import MutationType , make_executable_schema [EOL] [EOL] [EOL] def test_executing_mutation_takes_scalar_args_and_returns_scalar_sum ( ) : [EOL] type_defs = [string] [EOL] [EOL] mutation = MutationType ( ) [EOL] mutation . set_field ( [string] , lambda * _ , a , b : a + b ) [EOL] [EOL] schema = make_executable_schema ( type_defs , mutation ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [number] } [EOL] [EOL] [EOL] def test_executing_mutation_takes_scalar_arg_and_returns_type ( ) : [EOL] type_defs = [string] [EOL] [EOL] mutation = MutationType ( ) [EOL] [EOL] @ mutation . field ( [string] ) def resolve_add_staff ( * _ , name ) : [comment] [EOL] assert name == [string] [EOL] return { [string] : name } [EOL] [EOL] schema = make_executable_schema ( type_defs , mutation ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_executing_mutation_using_input_type ( ) : [EOL] type_defs = [string] [EOL] [EOL] mutation = MutationType ( ) [EOL] [EOL] @ mutation . field ( [string] ) def resolve_add_staff ( * _ , data ) : [comment] [EOL] assert data == { [string] : [string] } [EOL] return data [EOL] [EOL] schema = make_executable_schema ( type_defs , mutation ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List , Union [EOL] import typing [EOL] import pytest [EOL] [EOL] from ariadne . exceptions import HttpBadRequestError [EOL] from ariadne . file_uploads import combine_multipart_data , upload_scalar [EOL] [EOL] [EOL] def test_file_is_set_in_variable ( ) : [EOL] operations = { [string] : { [string] : None } } [EOL] files_map = { [string] : [ [string] ] } [EOL] files = { [string] : True } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : True } } [EOL] [EOL] [EOL] def test_files_are_set_in_multiple_variables ( ) : [EOL] operations = { [string] : { [string] : None , [string] : None } } [EOL] files_map = { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] files = { [string] : [string] , [string] : [string] } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] def test_single_file_is_set_in_multiple_variables ( ) : [EOL] operations = { [string] : { [string] : None , [string] : None } } [EOL] files_map = { [string] : [ [string] , [string] ] } [EOL] files = { [string] : True } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : True , [string] : True } } [EOL] [EOL] [EOL] def test_file_is_set_in_list_variable ( ) : [EOL] operations = { [string] : { [string] : [ None ] } } [EOL] files_map = { [string] : [ [string] ] } [EOL] files = { [string] : True } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : [ True ] } } [EOL] [EOL] [EOL] def test_files_are_set_in_list_variable ( ) : [EOL] operations = { [string] : { [string] : [ None , None ] } } [EOL] files_map = { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] files = { [string] : [string] , [string] : [string] } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : [ [string] , [string] ] } } [EOL] [EOL] [EOL] def test_file_is_set_in_input_variable ( ) : [EOL] operations = { [string] : { [string] : { [string] : None } } } [EOL] files_map = { [string] : [ [string] ] } [EOL] files = { [string] : True } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : { [string] : True } } } [EOL] [EOL] [EOL] def test_files_are_set_in_input_list_variable ( ) : [EOL] operations = { [string] : { [string] : { [string] : [ None , None ] } } } [EOL] files_map = { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] files = { [string] : [string] , [string] : [string] } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : { [string] : [ [string] , [string] ] } } } [EOL] [EOL] [EOL] def test_files_are_set_in_list_of_inputs_variable ( ) : [EOL] operations = { [string] : { [string] : [ { [string] : None } , { [string] : None } ] } } [EOL] files_map = { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] files = { [string] : [string] , [string] : [string] } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : [ { [string] : [string] } , { [string] : [string] } ] } } [EOL] [EOL] [EOL] def test_file_is_set_in_one_operation_variable ( ) : [EOL] operations = [ { } , { [string] : { [string] : None , [string] : [string] } } ] [EOL] files_map = { [string] : [ [string] ] } [EOL] files = { [string] : True } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == [ { } , { [string] : { [string] : True , [string] : [string] } } , ] [EOL] [EOL] [EOL] def test_setting_file_value_in_variables_leaves_other_variables_unchanged ( ) : [EOL] operations = { [string] : { [string] : None , [string] : [string] } } [EOL] files_map = { [string] : [ [string] ] } [EOL] files = { [string] : True } [EOL] [EOL] assert combine_multipart_data ( operations , files_map , files ) == { [string] : { [string] : True , [string] : [string] } } [EOL] [EOL] [EOL] def test_error_is_raised_if_operations_value_is_not_a_list_or_dict ( ) : [EOL] with pytest . raises ( HttpBadRequestError ) : [EOL] assert combine_multipart_data ( None , { } , { } ) [EOL] [EOL] [EOL] def test_error_is_raised_if_map_value_is_not_a_list_or_dict ( ) : [EOL] with pytest . raises ( HttpBadRequestError ) : [EOL] assert combine_multipart_data ( { } , None , { } ) [EOL] [EOL] [EOL] def test_error_is_raised_if_file_paths_value_is_not_a_list ( ) : [EOL] operations = { [string] : { [string] : None } } [EOL] files_map = { [string] : [string] } [EOL] files = { [string] : True } [EOL] [EOL] with pytest . raises ( HttpBadRequestError ) : [EOL] assert combine_multipart_data ( operations , files_map , files ) [EOL] [EOL] [EOL] def test_error_is_raised_if_file_paths_list_item_is_not_a_str ( ) : [EOL] operations = { [string] : { [string] : None } } [EOL] files_map = { [string] : [ [number] ] } [EOL] files = { [string] : True } [EOL] [EOL] with pytest . raises ( HttpBadRequestError ) : [EOL] assert combine_multipart_data ( operations , files_map , files ) [EOL] [EOL] [EOL] def test_error_is_raised_if_file_described_in_map_is_not_found ( ) : [EOL] operations = { [string] : { [string] : None } } [EOL] files_map = { [string] : [ [string] ] } [EOL] files = { } [EOL] [EOL] with pytest . raises ( HttpBadRequestError ) : [EOL] assert combine_multipart_data ( operations , files_map , files ) [EOL] [EOL] [EOL] def test_default_upload_scalar_doesnt_support_serialization ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] upload_scalar . _serialize ( True ) [comment] [EOL] [EOL] [EOL] def test_default_upload_scalar_doesnt_support_literals ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] upload_scalar . _parse_literal ( True ) [comment] [EOL] [EOL] [EOL] def test_default_upload_scalar_passes_variable_value_as_is ( ) : [EOL] assert upload_scalar . _parse_value ( True ) is True [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from graphql import build_schema , graphql_sync [EOL] [EOL] from ariadne import QueryType , UnionType , make_executable_schema [EOL] [EOL] type_defs = [string] [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return build_schema ( type_defs ) [EOL] [EOL] [EOL] def test_attempt_to_bind_union_to_undefined_type_raises_error ( schema ) : [EOL] union = UnionType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] union . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_attempt_to_bind_union_to_invalid_type_raises_error ( schema ) : [EOL] union = UnionType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] union . bind_to_schema ( schema ) [EOL] [EOL] [EOL] test_query = [string] [EOL] [EOL] User = Mock ( username = [string] ) [EOL] Thread = Mock ( title = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def query ( ) : [EOL] return QueryType ( ) [EOL] [EOL] [EOL] @ pytest . fixture def query_with_user_item ( query ) : [EOL] query . set_field ( [string] , lambda * _ : User ) [EOL] return query [EOL] [EOL] [EOL] @ pytest . fixture def query_with_thread_item ( query ) : [EOL] query . set_field ( [string] , lambda * _ : Thread ) [EOL] return query [EOL] [EOL] [EOL] @ pytest . fixture def query_with_invalid_item ( query ) : [EOL] query . set_field ( [string] , lambda * _ : True ) [EOL] return query [EOL] [EOL] [EOL] def test_union_type_resolver_may_be_set_on_initialization ( query_with_user_item ) : [EOL] union = UnionType ( [string] , type_resolver = lambda * _ : [string] ) [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_item , union ] ) [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_union_type_resolver_may_be_set_using_setter ( query_with_user_item ) : [EOL] def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] union = UnionType ( [string] ) [EOL] union . set_type_resolver ( resolve_result_type ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_item , union ] ) [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_union_type_resolver_may_be_set_using_decorator ( query_with_user_item ) : [EOL] union = UnionType ( [string] ) [EOL] [EOL] @ union . type_resolver def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_item , union ] ) [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def resolve_result_type ( obj , * _ ) : [EOL] if obj == User : [EOL] return [string] [EOL] if obj == Thread : [EOL] return [string] [EOL] return None [EOL] [EOL] [EOL] def test_result_is_username_if_union_resolves_type_to_user ( query_with_user_item ) : [EOL] union = UnionType ( [string] , type_resolver = resolve_result_type ) [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_item , union ] ) [EOL] result = graphql_sync ( schema , test_query ) [EOL] assert result . data == { [string] : { [string] : [string] , [string] : User . username } } [EOL] [EOL] [EOL] def test_result_is_thread_title_if_union_resolves_type_to_thread ( query_with_thread_item , ) : [EOL] union = UnionType ( [string] , type_resolver = resolve_result_type ) [EOL] schema = make_executable_schema ( type_defs , [ query_with_thread_item , union ] ) [EOL] result = graphql_sync ( schema , test_query ) [EOL] assert result . data == { [string] : { [string] : [string] , [string] : Thread . title } } [EOL] [EOL] [EOL] def test_result_is_none_if_union_didnt_resolve_the_type ( query_with_invalid_item ) : [EOL] union = UnionType ( [string] , type_resolver = resolve_result_type ) [EOL] schema = make_executable_schema ( type_defs , [ query_with_invalid_item , union ] ) [EOL] result = graphql_sync ( schema , test_query ) [EOL] assert result . data == { [string] : None } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] import pytest [EOL] from graphql import graphql_sync , build_schema [EOL] [EOL] from ariadne import ObjectType [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return build_schema ( [string] ) [EOL] [EOL] [EOL] def test_attempt_bind_object_type_to_undefined_type_raises_error ( schema ) : [EOL] query = ObjectType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] query . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_attempt_bind_object_type_to_invalid_type_raises_error ( schema ) : [EOL] query = ObjectType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] query . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_attempt_bind_object_type_field_to_undefined_field_raises_error ( schema ) : [EOL] query = ObjectType ( [string] ) [EOL] query . set_alias ( [string] , [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] query . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_field_resolver_can_be_set_using_decorator ( schema ) : [EOL] query = ObjectType ( [string] ) [EOL] query . field ( [string] ) ( lambda * _ : [string] ) [EOL] query . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_value_error_is_raised_if_field_decorator_was_used_without_argument ( ) : [EOL] query = ObjectType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] query . field ( lambda * _ : [string] ) [EOL] [EOL] [EOL] def test_field_resolver_can_be_set_using_setter ( schema ) : [EOL] query = ObjectType ( [string] ) [EOL] query . set_field ( [string] , lambda * _ : [string] ) [EOL] query . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_set_alias_method_creates_resolver_for_specified_attribute ( schema ) : [EOL] query = ObjectType ( [string] ) [EOL] query . set_alias ( [string] , [string] ) [EOL] query . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] , root_value = { [string] : [string] } ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import tests [EOL] from typing import List [EOL] [EOL] from graphql . type import GraphQLObjectType , GraphQLSchema [EOL] [EOL] from ariadne import make_executable_schema [EOL] from ariadne . schema_visitor import SchemaVisitor , visit_schema [EOL] [EOL] TYPE_DEFS = [string] [EOL] [EOL] [EOL] def test_visitor ( ) : [EOL] class SimpleVisitor ( SchemaVisitor ) : [EOL] visitCount = [number] [EOL] names = [ ] [EOL] [EOL] def __init__ ( self , schema ) : [EOL] self . schema = schema [EOL] [EOL] def visit ( self ) : [EOL] visit_schema ( self . schema , lambda * _ : [ self ] ) [EOL] [EOL] def visit_object ( self , object_ ) : [EOL] assert self . schema . get_type ( object_ . name ) == object_ [EOL] self . names . append ( object_ . name ) [EOL] [EOL] schema = make_executable_schema ( TYPE_DEFS ) [EOL] [EOL] visitor = SimpleVisitor ( schema ) [EOL] visitor . visit ( ) [EOL] assert sorted ( visitor . names ) == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_can_check_if_a_visitor_method_is_implemented ( ) : [EOL] class Visitor ( SchemaVisitor ) : [EOL] def not_visitor_method ( self ) : [EOL] return [EOL] [EOL] def visit_object ( self , object_ ) : [EOL] return object_ [EOL] [EOL] assert Visitor . implements_visitor_method ( [string] ) is False [EOL] [EOL] assert Visitor . implements_visitor_method ( [string] ) is True [EOL] [EOL] assert Visitor . implements_visitor_method ( [string] ) is False [EOL] [EOL] assert Visitor . implements_visitor_method ( [string] ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from ariadne import make_executable_schema [EOL] [EOL] [EOL] def test_executable_schema_creation_errors_if_type_defs_is_graphql_query ( ) : [EOL] type_defs = [string] [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] make_executable_schema ( type_defs ) [EOL] [EOL] [EOL] def test_executable_schema_creation_errors_if_type_defs_is_invalid_schema ( ) : [EOL] type_defs = [string] [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] make_executable_schema ( type_defs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union [EOL] import graphql [EOL] import typing [EOL] import builtins [EOL] import ariadne [EOL] import hashlib [EOL] from functools import partial [EOL] from typing import Union [EOL] [EOL] import pytest [EOL] from graphql import default_field_resolver , graphql_sync [EOL] from graphql . type import ( GraphQLEnumType , GraphQLEnumValue , GraphQLField , GraphQLID , GraphQLInt , GraphQLInterfaceType , GraphQLObjectType , GraphQLSchema , GraphQLUnionType , ) [EOL] [EOL] from ariadne import ( ObjectType , QueryType , SchemaDirectiveVisitor , UnionType , make_executable_schema , ) [EOL] [EOL] [EOL] class UpperDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_field_definition ( self , field , object_type , ) : [EOL] original_resolver = field . resolve or default_field_resolver [EOL] [EOL] def resolve_upper ( obj , info , ** kwargs ) : [EOL] result = original_resolver ( obj , info , ** kwargs ) [EOL] return result . upper ( ) [EOL] [EOL] field . resolve = resolve_upper [EOL] return field [EOL] [EOL] [EOL] class ReverseDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_field_definition ( self , field , object_type , ) : [EOL] original_resolver = field . resolve or default_field_resolver [EOL] [EOL] def resolve_reverse ( obj , info , ** kwargs ) : [EOL] result = original_resolver ( obj , info , ** kwargs ) [EOL] return result [ : : - [number] ] [EOL] [EOL] field . resolve = resolve_reverse [EOL] return field [EOL] [EOL] [EOL] def test_field_definition_directive_replaces_field_resolver_with_custom_one ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : { [string] : [string] , [string] : [string] } ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query ] , directives = { [string] : UpperDirective , [string] : ReverseDirective } , ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] def test_multiple_field_definition_directives_replace_field_resolver_with_chainable_resolvers ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query ] , directives = { [string] : UpperDirective , [string] : ReverseDirective } , ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] class ReturnValueDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_field_definition ( self , field , object_type , ) : [EOL] def resolver ( * _ ) : [EOL] return self . args . get ( [string] ) [EOL] [EOL] field . resolve = resolver [EOL] return field [EOL] [EOL] [EOL] def test_directive_can_have_optional_argument ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query ] , directives = { [string] : ReturnValueDirective } ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : None } [EOL] [EOL] [EOL] def test_directive_can_have_required_argument ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query ] , directives = { [string] : ReturnValueDirective } ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_directive_raises_type_error_if_required_argument_is_not_given ( ) : [EOL] type_defs = [string] [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] make_executable_schema ( type_defs , directives = { [string] : ReturnValueDirective } ) [EOL] [EOL] [EOL] def test_can_implement_unique_id_directive ( ) : [EOL] type_defs = [string] [EOL] [EOL] class UniqueIDDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_object ( self , object_ ) : [EOL] name , from_ = self . args . values ( ) [EOL] [EOL] def _field_resolver ( field , _ ) : [EOL] hash_ = hashlib . sha1 ( object_ . name . encode ( ) ) [EOL] for field_name in from_ : [EOL] hash_ . update ( str ( field [ field_name ] ) . encode ( ) ) [EOL] [EOL] return hash_ . hexdigest ( ) [EOL] [EOL] object_ . fields [ name ] = GraphQLField ( description = [string] , type_ = GraphQLID , resolve = _field_resolver ) [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : [ { [string] : [number] , [string] : [string] } ] ) [EOL] query . set_field ( [string] , lambda * _ : [ { [string] : [number] , [string] : [string] } ] ) [EOL] schema = make_executable_schema ( type_defs , [ query ] , directives = { [string] : UniqueIDDirective } ) [EOL] [EOL] result = graphql_sync ( schema , [string] , ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , } ] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , } ] , } [EOL] [EOL] [EOL] def test_can_implement_remove_enum_values_directive ( ) : [EOL] type_defs = [string] [EOL] [EOL] class RemoveEnumDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_enum_value ( self , value , enum_type ) : [EOL] if self . args [ [string] ] : [EOL] return False [EOL] return None [EOL] [EOL] schema = make_executable_schema ( type_defs , directives = { [string] : RemoveEnumDirective } ) [EOL] [EOL] enum_type = schema . get_type ( [string] ) [EOL] assert list ( enum_type . values . keys ( ) ) == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_can_swap_names_of_GraphQLNamedType_objects ( ) : [EOL] class RenameTypeDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_object ( self , object_ ) : [EOL] object_ . name = self . args [ [string] ] [EOL] [EOL] type_defs = [string] [EOL] [EOL] schema = make_executable_schema ( type_defs , directives = { [string] : RenameTypeDirective } ) [EOL] [EOL] Human = schema . get_type ( [string] ) [EOL] [EOL] assert Human . name == [string] [EOL] assert Human . fields [ [string] ] . type == GraphQLInt [EOL] [EOL] Person = schema . get_type ( [string] ) [EOL] assert Person . name == [string] [EOL] assert Person . fields [ [string] ] . type == schema . get_type ( [string] ) [EOL] [EOL] Query = schema . get_type ( [string] ) [EOL] people_type = Query . fields [ [string] ] . type [EOL] assert people_type . of_type == Human [EOL] [EOL] [EOL] def test_defining_non_callable_visitor_attribute_raises_error ( ) : [EOL] type_defs = [string] [EOL] [EOL] class Visitor ( SchemaDirectiveVisitor ) : [EOL] visit_schema = True [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] make_executable_schema ( type_defs , directives = { [string] : Visitor } ) [EOL] [EOL] [EOL] def test_returning_value_from_visit_schema_raises_error ( ) : [EOL] type_defs = [string] [EOL] [EOL] class Visitor ( SchemaDirectiveVisitor ) : [EOL] def visit_schema ( self , schema ) : [EOL] return schema [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] make_executable_schema ( type_defs , directives = { [string] : Visitor } ) [EOL] [EOL] [EOL] def test_visitor_missing_method_raises_error ( ) : [EOL] type_defs = [string] [EOL] [EOL] class Visitor ( SchemaDirectiveVisitor ) : [EOL] def visit_object ( self , object_ ) : [EOL] return object_ [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] make_executable_schema ( type_defs , directives = { [string] : Visitor } ) [EOL] [EOL] [EOL] def test_can_be_used_to_implement_auth_example ( ) : [EOL] roles = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] class User : [EOL] def __init__ ( self , token ) : [EOL] self . token_index = roles . index ( token ) [EOL] [EOL] def has_role ( self , role ) : [EOL] role_index = roles . index ( role ) [EOL] return self . token_index >= role_index >= [number] [EOL] [EOL] def _get_user ( token ) : [EOL] return User ( token ) [EOL] [EOL] class AuthDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_object ( self , object_ ) : [EOL] self . ensure_fields_wrapped ( object_ ) [EOL] setattr ( object_ , [string] , self . args [ [string] ] ) [EOL] [EOL] def visit_field_definition ( self , field , object_type , ) : [EOL] self . ensure_fields_wrapped ( object_type ) [EOL] setattr ( field , [string] , self . args [ [string] ] ) [EOL] [EOL] def ensure_fields_wrapped ( self , object_type ) : [EOL] if hasattr ( object_type , [string] ) : [EOL] return [EOL] setattr ( object_type , [string] , True ) [EOL] [EOL] def _resolver ( _ , info , * , f = None , o = None ) : [EOL] required_role = getattr ( f , [string] , None ) or getattr ( o , [string] , None ) [EOL] [EOL] if not required_role : [EOL] return original_resolver ( _ , info ) [EOL] [EOL] context = info . context [EOL] [EOL] user = _get_user ( context [ [string] ] [ [string] ] ) [EOL] if not user . has_role ( required_role ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] return original_resolver ( _ , info ) [EOL] [EOL] for _ , field in object_type . fields . items ( ) : [EOL] original_resolver = field . resolve or default_field_resolver [EOL] field . resolve = partial ( _resolver , f = field , o = object_type ) [EOL] [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] [EOL] @ query . field ( [string] ) def _users_resolver ( _ , __ ) : [EOL] return [ { [string] : True , [string] : False , [string] : [string] } ] [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query ] , directives = { [string] : AuthDirective } ) [EOL] [EOL] def exec_with_role ( role ) : [EOL] return graphql_sync ( schema , [string] , context_value = { [string] : { [string] : role } } , ) [EOL] [EOL] def _check_results ( result , * , data = None , errors = None ) : [EOL] if errors and result . errors : [EOL] assert len ( errors ) == len ( result . errors ) [EOL] for e in result . errors : [EOL] assert e . message == [string] [EOL] assert e . path [ - [number] ] in errors [EOL] [EOL] assert result . data == data [EOL] [EOL] _check_results ( exec_with_role ( [string] ) , data = { [string] : [ { [string] : None , [string] : None , [string] : None } ] } , errors = ( [string] , [string] , [string] ) , ) [EOL] _check_results ( exec_with_role ( [string] ) , data = { [string] : [ { [string] : [string] , [string] : None , [string] : None } ] } , errors = ( [string] , [string] ) , ) [EOL] _check_results ( exec_with_role ( [string] ) , data = { [string] : [ { [string] : [string] , [string] : None , [string] : False } ] } , errors = ( [string] , ) , ) [EOL] _check_results ( exec_with_role ( [string] ) , data = { [string] : [ { [string] : [string] , [string] : True , [string] : False } ] } , ) [EOL] [EOL] [EOL] def test_directive_can_add_new_type_to_schema ( ) : [EOL] type_defs = [string] [EOL] [EOL] class Visitor ( SchemaDirectiveVisitor ) : [EOL] def visit_object ( self , object_ ) : [EOL] try : [EOL] types = self . schema . type_map [ [string] ] . types [EOL] except KeyError : [EOL] u = self . schema . type_map [ [string] ] = GraphQLUnionType ( [string] , [ ] ) [EOL] types = u . types [EOL] types . append ( object_ ) [EOL] [EOL] schema = make_executable_schema ( type_defs , directives = { [string] : Visitor } ) [EOL] assert { t . name for t in schema . get_type ( [string] ) . types } == { [string] , [string] } [EOL] [EOL] [EOL] def test_directive_can_be_defined_without_being_used ( ) : [EOL] type_defs = [string] [EOL] [EOL] class CustomDirective ( SchemaDirectiveVisitor ) : [EOL] def visit_object ( self , object_ ) : [EOL] pass [EOL] [EOL] def visit_interface ( self , interface ) : [EOL] pass [EOL] [EOL] type_1 = ObjectType ( [string] ) [EOL] type_2 = ObjectType ( [string] ) [EOL] [EOL] def resolve_union_test_type ( * _ ) : [EOL] return [string] [comment] [EOL] [EOL] query = QueryType ( ) [EOL] union_test = UnionType ( [string] , resolve_union_test_type ) [EOL] [EOL] make_executable_schema ( type_defs , [ query , union_test , type_1 , type_2 ] , directives = { [string] : CustomDirective } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 $graphql.type.GraphQLField$ 0 $typing.Union[graphql.type.GraphQLObjectType,graphql.type.GraphQLInt.erfaceType]$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 $graphql.type.GraphQLField$ 0 $typing.Union[graphql.type.GraphQLObjectType,graphql.type.GraphQLInt.erfaceType]$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 $graphql.type.GraphQLField$ 0 $typing.Union[graphql.type.GraphQLObjectType,graphql.type.GraphQLInt.erfaceType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLEnumValue$ 0 $graphql.type.GraphQLEnumType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 $graphql.type.GraphQLSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 $graphql.type.GraphQLField$ 0 $typing.Union[graphql.type.GraphQLObjectType,graphql.type.GraphQLInt.erfaceType]$ 0 0 0 0 0 0 0 0 $typing.Union[graphql.type.GraphQLObjectType,graphql.type.GraphQLInt.erfaceType]$ 0 0 0 0 $graphql.type.GraphQLField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.type.GraphQLObjectType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict [EOL] import typing [EOL] import datetime [EOL] import ariadne [EOL] from datetime import date , datetime [EOL] [EOL] import pytest [EOL] from graphql import build_schema , graphql_sync [EOL] from graphql . language . ast import StringValueNode [EOL] [EOL] from ariadne import QueryType , ScalarType , make_executable_schema [EOL] [EOL] TEST_DATE = date ( [number] , [number] , [number] ) [EOL] TEST_DATE_SERIALIZED = TEST_DATE . strftime ( [string] ) [EOL] [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] [EOL] [EOL] @ query . field ( [string] ) def resolve_test_serialize ( * _ ) : [EOL] return TEST_DATE [EOL] [EOL] [EOL] @ query . field ( [string] ) def resolve_test_input ( * _ , value ) : [EOL] assert value == TEST_DATE [EOL] return True [EOL] [EOL] [EOL] @ query . field ( [string] ) def resolve_test_input_type ( * _ , value ) : [EOL] return value [EOL] [EOL] [EOL] datereadonly = ScalarType ( [string] ) [EOL] [EOL] [EOL] @ datereadonly . serializer def serialize_date ( date ) : [EOL] return date . strftime ( [string] ) [EOL] [EOL] [EOL] dateinput = ScalarType ( [string] ) [EOL] [EOL] [EOL] @ dateinput . value_parser def parse_date_value ( formatted_date ) : [EOL] parsed_datetime = datetime . strptime ( formatted_date , [string] ) [EOL] return parsed_datetime . date ( ) [EOL] [EOL] [EOL] @ dateinput . literal_parser def parse_date_literal ( ast , variable_values = None ) : [comment] [EOL] if not isinstance ( ast , StringValueNode ) : [EOL] raise ValueError ( ) [EOL] [EOL] formatted_date = ast . value [EOL] parsed_datetime = datetime . strptime ( formatted_date , [string] ) [EOL] return parsed_datetime . date ( ) [EOL] [EOL] [EOL] scalar_with_default_parser = ScalarType ( [string] ) [EOL] [EOL] [EOL] @ scalar_with_default_parser . value_parser def parse_value_from_default_literal_parser ( value ) : [EOL] return type ( value ) . __name__ [EOL] [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query , datereadonly , dateinput , scalar_with_default_parser ] ) [EOL] [EOL] [EOL] def test_attempt_bind_scalar_to_undefined_type_raises_error ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_attempt_bind_scalar_to_invalid_schema_type_raises_error ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_python_date_is_serialized_by_scalar ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : TEST_DATE_SERIALIZED } [EOL] [EOL] [EOL] def test_literal_with_valid_date_str_is_deserialized_to_python_date ( ) : [EOL] test_input = TEST_DATE_SERIALIZED [EOL] result = graphql_sync ( schema , [string] % test_input ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : True } [EOL] [EOL] [EOL] def test_attempt_deserialize_str_literal_without_valid_date_raises_error ( ) : [EOL] test_input = [string] [EOL] result = graphql_sync ( schema , [string] % test_input ) [EOL] assert result . errors is not None [EOL] assert str ( result . errors [ [number] ] ) . splitlines ( ) [ : [number] ] == [ [string] [string] ] [EOL] [EOL] [EOL] def test_attempt_deserialize_wrong_type_literal_raises_error ( ) : [EOL] test_input = [number] [EOL] result = graphql_sync ( schema , [string] % test_input ) [EOL] assert result . errors is not None [EOL] assert str ( result . errors [ [number] ] ) . splitlines ( ) [ : [number] ] == [ [string] ] [EOL] [EOL] [EOL] def test_default_literal_parser_is_used_to_extract_value_str_from_ast_node ( ) : [EOL] dateinput = ScalarType ( [string] ) [EOL] dateinput . set_value_parser ( parse_date_value ) [EOL] schema = make_executable_schema ( type_defs , query , dateinput ) [EOL] [EOL] result = graphql_sync ( schema , [string] % TEST_DATE_SERIALIZED ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : True } [EOL] [EOL] [EOL] parametrized_query = [string] [EOL] [EOL] [EOL] def test_variable_with_valid_date_string_is_deserialized_to_python_date ( ) : [EOL] variables = { [string] : TEST_DATE_SERIALIZED } [EOL] result = graphql_sync ( schema , parametrized_query , variable_values = variables ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : True } [EOL] [EOL] [EOL] def test_attempt_deserialize_str_variable_without_valid_date_raises_error ( ) : [EOL] variables = { [string] : [string] } [EOL] result = graphql_sync ( schema , parametrized_query , variable_values = variables ) [EOL] assert result . errors is not None [EOL] assert str ( result . errors [ [number] ] ) . splitlines ( ) [ : [number] ] == [ [string] [string] [string] ] [EOL] [EOL] [EOL] def test_attempt_deserialize_wrong_type_variable_raises_error ( ) : [EOL] variables = { [string] : [number] } [EOL] result = graphql_sync ( schema , parametrized_query , variable_values = variables ) [EOL] assert result . errors is not None [EOL] assert str ( result . errors [ [number] ] ) . splitlines ( ) [ : [number] ] == [ [string] [string] ] [EOL] [EOL] [EOL] def test_scalar_serializer_can_be_set_on_initialization ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] , serializer = serialize_date ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . serialize is serialize_date [EOL] [EOL] [EOL] def test_scalar_serializer_can_be_set_with_setter ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] ) [EOL] scalar . set_serializer ( serialize_date ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . serialize is serialize_date [EOL] [EOL] [EOL] def test_scalar_value_parser_can_be_set_on_initialization ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] , value_parser = parse_date_value ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . parse_value is parse_date_value [EOL] [EOL] [EOL] def test_scalar_value_parser_can_be_set_with_setter ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] ) [EOL] scalar . set_value_parser ( parse_date_value ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . parse_value is parse_date_value [EOL] [EOL] [EOL] def test_scalar_literal_parser_can_be_set_on_initialization ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] , literal_parser = parse_date_literal ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . parse_literal is parse_date_literal [EOL] [EOL] [EOL] def test_scalar_literal_parser_can_be_set_with_setter ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] ) [EOL] scalar . set_literal_parser ( parse_date_literal ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . parse_literal is parse_date_literal [EOL] [EOL] [EOL] def test_setting_scalar_value_parser_sets_default_literal_parsers_if_none_is_set ( ) : [EOL] schema = build_schema ( type_defs ) [EOL] scalar = ScalarType ( [string] ) [EOL] scalar . set_value_parser ( parse_date_value ) [EOL] scalar . bind_to_schema ( schema ) [EOL] [EOL] schema_scalar = schema . type_map . get ( [string] ) [EOL] assert schema_scalar . parse_value is parse_date_value [EOL] assert schema_scalar . parse_literal [EOL] [EOL] [EOL] def test_literal_string_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_literal_int_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_literal_float_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_literal_bool_true_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_literal_bool_false_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_literal_object_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL] [EOL] [EOL] def test_literal_list_is_deserialized_by_default_parser ( ) : [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 $ariadne.scalars.ScalarType$ 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ariadne.scalars.ScalarType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import ariadne [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from graphql import graphql_sync [EOL] [EOL] from ariadne import ObjectType , QueryType , make_executable_schema [EOL] [EOL] root_typedef = [string] [EOL] [EOL] module_typedef = [string] [EOL] [EOL] duplicate_typedef = [string] [EOL] [EOL] extend_typedef = [string] [EOL] [EOL] [EOL] def test_list_of_type_defs_is_merged_into_executable_schema ( ) : [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : { [string] : [string] } ) [EOL] [EOL] type_defs = [ root_typedef , module_typedef ] [EOL] schema = make_executable_schema ( type_defs , query ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_redefining_existing_type_causes_type_error ( ) : [EOL] type_defs = [ root_typedef , module_typedef , duplicate_typedef ] [EOL] with pytest . raises ( TypeError ) : [EOL] make_executable_schema ( type_defs ) [EOL] [EOL] [EOL] def test_same_type_resolver_maps_are_merged_into_executable_schema ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : [string] ) [EOL] [EOL] extending_query = QueryType ( ) [EOL] [EOL] @ extending_query . field ( [string] ) def resolve_test ( * _ , data ) : [comment] [EOL] assert data == [number] [EOL] return True [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query , extending_query ] ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : [string] , [string] : True } [EOL] [EOL] [EOL] def test_different_types_resolver_maps_are_merged_into_executable_schema ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : Mock ( first_name = [string] ) ) [EOL] [EOL] user = ObjectType ( [string] ) [EOL] user . set_alias ( [string] , [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query , user ] ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_defined_type_can_be_extended_with_new_field ( ) : [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : Mock ( username = [string] ) ) [EOL] [EOL] type_defs = [ root_typedef , module_typedef , extend_typedef ] [EOL] schema = make_executable_schema ( type_defs , query ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_multiple_bindables_can_be_passed_as_separate_args ( ) : [EOL] type_defs = [string] [EOL] [EOL] query = QueryType ( ) [EOL] query . set_field ( [string] , lambda * _ : Mock ( first_name = [string] ) ) [EOL] [EOL] user = ObjectType ( [string] ) [EOL] user . set_alias ( [string] , [string] ) [EOL] [EOL] schema = make_executable_schema ( type_defs , query , user ) [EOL] [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . errors is None [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from ariadne import convert_kwargs_to_snake_case [EOL] [EOL] [EOL] def test_decorator_converts_kwargs_to_camel_case ( ) : [EOL] @ convert_kwargs_to_snake_case def my_func ( * _ , ** kwargs ) : [EOL] assert kwargs == { [string] : True , [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , } [EOL] [EOL] my_func ( firstParameter = True , secondParameter = [string] , nestedParameter = { [string] : [number] , [string] : [number] } , ) [EOL] [EOL] [EOL] def test_decorator_leaves_snake_case_kwargs_unchanged ( ) : [EOL] @ convert_kwargs_to_snake_case def my_func ( * _ , ** kwargs ) : [EOL] assert kwargs == { [string] : True , [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , } [EOL] [EOL] my_func ( first_parameter = True , second_parameter = [string] , nested_parameter = { [string] : [number] , [string] : [number] } , ) [EOL] [EOL] [EOL] def test_decorator_converts_objects_in_lists_to_camel_case ( ) : [EOL] @ convert_kwargs_to_snake_case def my_func ( * _ , ** kwargs ) : [EOL] assert kwargs == { [string] : True , [string] : [ { [string] : [number] , [string] : [number] } , ] , } [EOL] [EOL] my_func ( firstParameter = True , listOfItems = [ { [string] : [number] , [string] : [number] } ] , ) [EOL] [EOL] [EOL] def test_decorator_leaves_primitives_in_lists_unchanged ( ) : [EOL] @ convert_kwargs_to_snake_case def my_func ( * _ , ** kwargs ) : [EOL] assert kwargs == { [string] : True , [string] : [ [string] , [string] ] , } [EOL] [EOL] my_func ( firstParameter = True , listOfItems = [ [string] , [string] ] , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_decorator_converts_kwargs_to_camel_case_for_async_resolver ( ) : [EOL] @ convert_kwargs_to_snake_case async def my_func ( * _ , ** kwargs ) : [EOL] assert kwargs == { [string] : True , [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , } [EOL] [EOL] await my_func ( firstParameter = True , secondParameter = [string] , nestedParameter = { [string] : [number] , [string] : [number] } , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_decorator_leaves_snake_case_kwargs_unchanged_for_async_resolver ( ) : [EOL] @ convert_kwargs_to_snake_case async def my_func ( * _ , ** kwargs ) : [EOL] assert kwargs == { [string] : True , [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , } [EOL] [EOL] await my_func ( first_parameter = True , second_parameter = [string] , nested_parameter = { [string] : [number] , [string] : [number] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from graphql import build_schema , graphql_sync [EOL] [EOL] from ariadne import InterfaceType , ObjectType , QueryType , make_executable_schema [EOL] [EOL] type_defs = [string] [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return build_schema ( type_defs ) [EOL] [EOL] [EOL] def test_attempt_to_bind_interface_to_undefined_type_raises_error ( schema ) : [EOL] interface = InterfaceType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_attempt_to_bind_interface_to_invalid_type_raises_error ( schema ) : [EOL] interface = InterfaceType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] [EOL] test_query = [string] [EOL] [EOL] User = Mock ( username = [string] , summary = [string] ) [EOL] Thread = Mock ( title = [string] , summary = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def query ( ) : [EOL] return QueryType ( ) [EOL] [EOL] [EOL] @ pytest . fixture def query_with_user_result ( query ) : [EOL] query . set_field ( [string] , lambda * _ : User ) [EOL] return query [EOL] [EOL] [EOL] @ pytest . fixture def query_with_thread_result ( query ) : [EOL] query . set_field ( [string] , lambda * _ : Thread ) [EOL] return query [EOL] [EOL] [EOL] @ pytest . fixture def query_with_invalid_result ( query ) : [EOL] query . set_field ( [string] , lambda * _ : True ) [EOL] return query [EOL] [EOL] [EOL] def test_interface_type_resolver_may_be_set_on_initialization ( query_with_user_result ) : [EOL] interface = InterfaceType ( [string] , type_resolver = lambda * _ : [string] ) [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_result , interface ] ) [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_interface_type_resolver_may_be_set_using_setter ( query_with_user_result ) : [EOL] def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] interface = InterfaceType ( [string] ) [EOL] interface . set_type_resolver ( resolve_result_type ) [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_result , interface ] ) [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_interface_type_resolver_may_be_set_using_decorator ( query_with_user_result ) : [EOL] interface = InterfaceType ( [string] ) [EOL] [EOL] @ interface . type_resolver def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_result , interface ] ) [EOL] result = graphql_sync ( schema , [string] ) [EOL] assert result . data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def resolve_result_type ( obj , * _ ) : [EOL] if obj == User : [EOL] return [string] [EOL] if obj == Thread : [EOL] return [string] [EOL] return None [EOL] [EOL] [EOL] @ pytest . fixture def interface ( ) : [EOL] return InterfaceType ( [string] , type_resolver = resolve_result_type ) [EOL] [EOL] [EOL] def test_result_is_username_if_interface_resolves_type_to_user ( query_with_user_result , interface ) : [EOL] schema = make_executable_schema ( type_defs , [ query_with_user_result , interface ] ) [EOL] result = graphql_sync ( schema , test_query ) [EOL] assert result . data == { [string] : { [string] : [string] , [string] : User . username , [string] : User . summary , } } [EOL] [EOL] [EOL] def test_result_is_thread_title_if_interface_resolves_type_to_thread ( query_with_thread_result , interface ) : [EOL] schema = make_executable_schema ( type_defs , [ query_with_thread_result , interface ] ) [EOL] result = graphql_sync ( schema , test_query ) [EOL] assert result . data == { [string] : { [string] : [string] , [string] : Thread . title , [string] : Thread . summary , } } [EOL] [EOL] [EOL] def test_query_errors_if_interface_didnt_resolve_the_type ( query_with_invalid_result , interface ) : [EOL] schema = make_executable_schema ( type_defs , [ query_with_invalid_result , interface ] ) [EOL] result = graphql_sync ( schema , test_query ) [EOL] assert result . data == { [string] : None } [EOL] [EOL] [EOL] def test_attempt_bind_interface_field_to_undefined_field_raises_error ( schema , interface ) : [EOL] interface . set_alias ( [string] , [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_resolver ( * _ ) : [EOL] pass [EOL] [EOL] [EOL] def test_field_decorator_assigns_decorated_function_as_field_resolver ( schema , query_with_user_result , interface ) : [EOL] interface . field ( [string] ) ( test_resolver ) [EOL] interface . bind_to_schema ( schema ) [EOL] query_with_user_result . bind_to_schema ( schema ) [EOL] [EOL] field = schema . type_map . get ( interface . name ) . fields [ [string] ] [EOL] assert field . resolve is test_resolver [EOL] [EOL] [EOL] def test_set_field_method_assigns_function_as_field_resolver ( schema , query_with_user_result , interface ) : [EOL] interface . set_field ( [string] , test_resolver ) [EOL] interface . bind_to_schema ( schema ) [EOL] query_with_user_result . bind_to_schema ( schema ) [EOL] [EOL] field = schema . type_map . get ( interface . name ) . fields [ [string] ] [EOL] assert field . resolve is test_resolver [EOL] [EOL] [EOL] def test_alias_method_creates_resolver_for_specified_attribute ( schema , query_with_user_result , interface ) : [EOL] interface . set_alias ( [string] , [string] ) [EOL] interface . bind_to_schema ( schema ) [EOL] query_with_user_result . bind_to_schema ( schema ) [EOL] [EOL] field = schema . type_map . get ( interface . name ) . fields [ [string] ] [EOL] assert field . resolve [EOL] [EOL] [EOL] def test_interface_doesnt_set_resolver_for_type_not_implementing_it ( schema , interface ) : [EOL] interface . set_field ( [string] , lambda * _ : [string] ) [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] field = schema . type_map . get ( [string] ) . fields [ [string] ] [EOL] assert field . resolve is None [EOL] [EOL] [EOL] def test_interface_sets_resolver_on_implementing_types ( schema , interface ) : [EOL] interface . set_field ( [string] , test_resolver ) [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] user_field = schema . type_map . get ( [string] ) . fields [ [string] ] [EOL] assert user_field . resolve is test_resolver [EOL] thread_field = schema . type_map . get ( [string] ) . fields [ [string] ] [EOL] assert thread_field . resolve is test_resolver [EOL] [EOL] [EOL] def test_interface_resolver_doesnt_override_existing_resolver ( schema , interface ) : [EOL] user = ObjectType ( [string] ) [EOL] user . set_field ( [string] , test_resolver ) [EOL] user . bind_to_schema ( schema ) [EOL] [EOL] def interface_resolver ( * _ ) : [EOL] pass [comment] [EOL] [EOL] interface . set_field ( [string] , interface_resolver ) [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] field = schema . type_map . get ( [string] ) . fields [ [string] ] [EOL] assert field . resolve is test_resolver [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from ariadne . contrib . tracing . utils import ( format_path , is_introspection_field , should_trace , ) [EOL] [EOL] [EOL] def test_util_formats_info_path_value_into_reversed_list ( ) : [EOL] path = Mock ( key = [string] , prev = Mock ( key = [string] , prev = Mock ( key = [string] , prev = None ) ) ) [EOL] assert format_path ( path ) == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_introspection_check_returns_true_for_introspection_field ( ) : [EOL] path = Mock ( key = [string] ) [EOL] info = Mock ( path = path ) [EOL] assert is_introspection_field ( info ) [EOL] [EOL] [EOL] def test_introspection_check_returns_true_for_child_field_of_introspection_field ( ) : [EOL] path = Mock ( key = [string] , prev = Mock ( key = [string] ) ) [EOL] info = Mock ( path = path ) [EOL] assert is_introspection_field ( info ) [EOL] [EOL] [EOL] def test_introspection_check_returns_false_for_non_introspection_field ( ) : [EOL] path = Mock ( key = [string] ) [EOL] info = Mock ( path = path ) [EOL] assert is_introspection_field ( info ) [EOL] [EOL] [EOL] def test_introspection_check_returns_false_for__field ( ) : [EOL] path = Mock ( key = [string] , prev = Mock ( key = [string] , prev = None ) ) [EOL] info = Mock ( path = path ) [EOL] assert not is_introspection_field ( info ) [EOL] [EOL] [EOL] def test_introspection_field_is_excluded_from_tracing ( ) : [EOL] path = Mock ( key = [string] ) [EOL] info = Mock ( field_name = [string] , path = path , parent_type = Mock ( fields = { [string] : Mock ( resolve = True ) } ) , ) [EOL] assert not should_trace ( info ) [EOL] [EOL] [EOL] def test_field_with_default_resolver_is_excluded_from_tracing ( ) : [EOL] path = Mock ( key = [string] , prev = Mock ( key = [string] , prev = None ) ) [EOL] info = Mock ( field_name = [string] , path = path , parent_type = Mock ( fields = { [string] : Mock ( resolve = None ) } ) , ) [EOL] assert not should_trace ( info ) [EOL] [EOL] [EOL] def test_field_with_custom_resolver_is_included_in_tracing ( ) : [EOL] path = Mock ( key = [string] , prev = Mock ( key = [string] , prev = None ) ) [EOL] info = Mock ( field_name = [string] , path = path , parent_type = Mock ( fields = { [string] : Mock ( resolve = True ) } ) , ) [EOL] assert should_trace ( info ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from freezegun import freeze_time [EOL] from graphql import get_introspection_query [EOL] [EOL] from ariadne import graphql [EOL] from ariadne . contrib . tracing . apollotracing import ApolloTracingExtension [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_apollotracing_extension_causes_no_errors_in_query_execution ( schema ) : [EOL] _ , result = await graphql ( schema , { [string] : [string] } , extensions = [ ApolloTracingExtension ] ) [EOL] assert result [ [string] ] == { [string] : True } [EOL] [EOL] [EOL] @ pytest . fixture def freeze_microtime ( mocker ) : [EOL] mocker . patch ( [string] , return_value = [number] ) [EOL] [EOL] [EOL] @ freeze_time ( [string] ) @ pytest . mark . asyncio async def test_apollotracing_extension_adds_tracing_data_to_result_extensions ( schema , freeze_microtime , snapshot ) : [EOL] _ , result = await graphql ( schema , { [string] : [string] } , extensions = [ ApolloTracingExtension ] ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] @ freeze_time ( [string] ) @ pytest . mark . asyncio async def test_apollotracing_extension_handles_exceptions_in_resolvers ( schema , freeze_microtime , snapshot ) : [EOL] _ , result = await graphql ( schema , { [string] : [string] } , extensions = [ ApolloTracingExtension ] ) [EOL] snapshot . assert_match ( result [ [string] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_apollotracing_extension_doesnt_break_introspection ( schema ) : [EOL] introspection_query = get_introspection_query ( descriptions = True ) [EOL] _ , result = await graphql ( schema , { [string] : introspection_query } , extensions = [ ApolloTracingExtension ] ) [EOL] assert [string] not in result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest . mock import ANY , call [EOL] [EOL] import pytest [EOL] from graphql import get_introspection_query [EOL] from opentracing . ext import tags [EOL] [EOL] from ariadne import graphql [EOL] from ariadne . contrib . tracing . opentracing import ( OpenTracingExtension , opentracing_extension , ) [EOL] [EOL] [EOL] @ pytest . fixture def global_tracer_mock ( mocker ) : [EOL] return mocker . patch ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def active_span_mock ( global_tracer_mock ) : [EOL] return global_tracer_mock . return_value . start_active_span . return_value [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_causes_no_errors_in_query_execution ( schema ) : [EOL] _ , result = await graphql ( schema , { [string] : [string] } , extensions = [ OpenTracingExtension ] , ) [EOL] assert result == { [string] : { [string] : [string] , [string] : True } } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_uses_global_tracer ( schema , global_tracer_mock ) : [EOL] await graphql ( schema , { [string] : [string] } , extensions = [ OpenTracingExtension ] , ) [EOL] global_tracer_mock . assert_called_once ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_creates_span_for_query_root ( schema , global_tracer_mock ) : [EOL] await graphql ( schema , { [string] : [string] } , extensions = [ OpenTracingExtension ] ) [EOL] global_tracer_mock . return_value . start_active_span . assert_any_call ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_creates_span_for_field ( schema , global_tracer_mock ) : [EOL] await graphql ( schema , { [string] : [string] } , extensions = [ OpenTracingExtension ] ) [EOL] global_tracer_mock . return_value . start_active_span . assert_any_call ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_sets_graphql_component_tag_on_root_span ( schema , active_span_mock ) : [EOL] await graphql ( schema , { [string] : [string] } , extensions = [ OpenTracingExtension ] , ) [EOL] active_span_mock . span . set_tag . assert_called_once_with ( tags . COMPONENT , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_calls_custom_arg_filter ( schema , mocker ) : [EOL] arg_filter = mocker . Mock ( return_value = { } ) [EOL] await graphql ( schema , { [string] : [string] } , extensions = [ opentracing_extension ( arg_filter = arg_filter ) ] , ) [EOL] arg_filter . assert_called_once_with ( { [string] : [string] } , ANY ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_sets_filtered_args_on_span ( schema , active_span_mock , mocker ) : [EOL] arg_filter = mocker . Mock ( return_value = { [string] : [string] } ) [EOL] await graphql ( schema , { [string] : [string] } , extensions = [ opentracing_extension ( arg_filter = arg_filter ) ] , ) [EOL] [EOL] span_mock = active_span_mock . __enter__ . return_value . span [EOL] span_mock . set_tag . assert_has_calls ( [ call ( [string] , [string] ) , call ( [string] , [string] ) , call ( [string] , [string] ) , call ( [string] , [string] ) , ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_handles_errors_in_resolvers ( schema ) : [EOL] _ , result = await graphql ( schema , { [string] : [string] } , extensions = [ OpenTracingExtension ] ) [EOL] assert result [ [string] ] == { [string] : None , [string] : True } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_opentracing_extension_doesnt_break_introspection ( schema ) : [EOL] introspection_query = get_introspection_query ( descriptions = True ) [EOL] _ , result = await graphql ( schema , { [string] : introspection_query } , extensions = [ OpenTracingExtension ] ) [EOL] assert [string] not in result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from ariadne . contrib . django . views import GraphQLView [EOL] [EOL] [EOL] def test_playground_html_is_served_on_get_request ( request_factory , snapshot ) : [EOL] view = GraphQLView . as_view ( ) [EOL] response = view ( request_factory . get ( [string] ) ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_playground_options_can_be_set_on_view_init ( request_factory , snapshot ) : [EOL] view = GraphQLView . as_view ( playground_options = { [string] : True } ) [EOL] response = view ( request_factory . get ( [string] ) ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import unittest [EOL] import json [EOL] from unittest . mock import ANY , Mock [EOL] [EOL] import pytest [EOL] from django . test import override_settings [EOL] [EOL] from ariadne . contrib . django . views import GraphQLView [EOL] from ariadne . types import ExtensionSync [EOL] [EOL] [EOL] def execute_query ( request_factory , schema , query , ** kwargs ) : [EOL] view = GraphQLView . as_view ( schema = schema , ** kwargs ) [EOL] request = request_factory . post ( [string] , data = query , content_type = [string] ) [EOL] response = view ( request ) [EOL] return json . loads ( response . content ) [EOL] [EOL] [EOL] def test_value_error_is_raised_when_view_was_initialized_without_schema ( request_factory , ) : [EOL] with pytest . raises ( ValueError ) : [EOL] execute_query ( request_factory , None , { [string] : [string] } ) [EOL] [EOL] [EOL] def test_custom_context_value_is_passed_to_resolvers ( request_factory , schema ) : [EOL] data = execute_query ( request_factory , schema , { [string] : [string] } , context_value = { [string] : [string] } , ) [EOL] assert data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_context_value_function_is_set_and_called_by_app ( request_factory , schema ) : [EOL] get_context_value = Mock ( return_value = True ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , context_value = get_context_value , ) [EOL] get_context_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_context_value_function_result_is_passed_to_resolvers ( request_factory , schema ) : [EOL] get_context_value = Mock ( return_value = { [string] : [string] } ) [EOL] data = execute_query ( request_factory , schema , { [string] : [string] } , context_value = get_context_value , ) [EOL] assert data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_is_passed_to_resolvers ( request_factory , schema ) : [EOL] data = execute_query ( request_factory , schema , { [string] : [string] } , root_value = { [string] : [string] } , ) [EOL] assert data == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_function_is_set_and_called_by_app ( request_factory , schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , root_value = get_root_value ) [EOL] get_root_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_root_value_function_is_called_with_context_value ( request_factory , schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , context_value = { [string] : [string] } , root_value = get_root_value , ) [EOL] get_root_value . assert_called_once_with ( { [string] : [string] } , ANY ) [EOL] [EOL] [EOL] def test_custom_validation_rule_is_called_by_query_validation ( mocker , request_factory , schema , validation_rule ) : [EOL] spy_validation_rule = mocker . spy ( validation_rule , [string] ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , validation_rules = [ validation_rule ] , ) [EOL] spy_validation_rule . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_validation_rules_function_is_set_and_called_on_query_execution ( mocker , request_factory , schema , validation_rule ) : [EOL] spy_validation_rule = mocker . spy ( validation_rule , [string] ) [EOL] get_validation_rules = Mock ( return_value = [ validation_rule ] ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , validation_rules = get_validation_rules , ) [EOL] get_validation_rules . assert_called_once ( ) [EOL] spy_validation_rule . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_validation_rules_function_is_called_with_context_value ( request_factory , schema , validation_rule ) : [EOL] get_validation_rules = Mock ( return_value = [ validation_rule ] ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , context_value = { [string] : [string] } , validation_rules = get_validation_rules , ) [EOL] get_validation_rules . assert_called_once_with ( { [string] : [string] } , ANY , ANY ) [EOL] [EOL] [EOL] def test_extensions_function_result_is_passed_to_query_executor ( request_factory , schema ) : [EOL] context = { [string] : [string] } [EOL] extension = Mock ( spec = ExtensionSync , format = Mock ( return_value = { } ) ) [EOL] get_extensions = Mock ( return_value = [ Mock ( return_value = extension ) ] ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , context_value = context , extensions = get_extensions , ) [EOL] get_extensions . assert_called_once ( ) [EOL] extension . request_started . assert_called_once_with ( context ) [EOL] extension . request_finished . assert_called_once_with ( context ) [EOL] [EOL] [EOL] def test_extension_from_option_is_passed_to_query_executor ( request_factory , schema ) : [EOL] context = { [string] : [string] } [EOL] extension = Mock ( spec = ExtensionSync , format = Mock ( return_value = { } ) ) [EOL] execute_query ( request_factory , schema , { [string] : [string] } , context_value = context , extensions = [ Mock ( return_value = extension ) ] , ) [EOL] extension . request_started . assert_called_once_with ( context ) [EOL] extension . request_finished . assert_called_once_with ( context ) [EOL] [EOL] [EOL] def execute_failing_query ( request_factory , schema , ** kwargs ) : [EOL] return execute_query ( request_factory , schema , { [string] : [string] } , ** kwargs ) [EOL] [EOL] [EOL] def test_default_logger_is_used_to_log_error_if_custom_is_not_set ( request_factory , schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] execute_failing_query ( request_factory , schema ) [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_logger_is_used_to_log_query_error ( request_factory , schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] execute_failing_query ( request_factory , schema , logger = [string] ) [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_error_formatter_is_used_to_format_error ( request_factory , schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] execute_failing_query ( request_factory , schema , error_formatter = error_formatter ) [EOL] error_formatter . assert_called_once ( ) [EOL] [EOL] [EOL] @ override_settings ( DEBUG = True ) def test_error_formatter_is_called_with_debug_enabled_flag ( request_factory , schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] execute_failing_query ( request_factory , schema , error_formatter = error_formatter ) [EOL] error_formatter . assert_called_once_with ( ANY , True ) [EOL] [EOL] [EOL] @ override_settings ( DEBUG = False ) def test_error_formatter_is_called_with_debug_disabled_flag ( request_factory , schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] execute_failing_query ( request_factory , schema , error_formatter = error_formatter ) [EOL] error_formatter . assert_called_once_with ( ANY , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] from django . utils import timezone [EOL] [EOL] from ariadne . contrib . django . scalars import ( date_scalar , datetime_scalar , parse_date_value , parse_datetime_value , serialize_date , serialize_datetime , ) [EOL] [EOL] [EOL] @ pytest . fixture def datetime ( ) : [EOL] return timezone . now ( ) [EOL] [EOL] [EOL] @ pytest . fixture def date ( datetime ) : [EOL] return datetime . date ( ) [EOL] [EOL] [EOL] def test_date_serializer_serializes_datetime ( datetime , date ) : [EOL] assert serialize_date ( datetime ) == date . isoformat ( ) [EOL] [EOL] [EOL] def test_date_serializer_serializes_date ( date ) : [EOL] assert serialize_date ( date ) == date . isoformat ( ) [EOL] [EOL] [EOL] def test_date_parser_returns_valid_date_from_datetime_iso8601_str ( datetime , date ) : [EOL] assert parse_date_value ( datetime . isoformat ( ) ) == date [EOL] [EOL] [EOL] def test_date_parser_returns_valid_date_from_date_iso8601_str ( date ) : [EOL] assert parse_date_value ( date . isoformat ( ) ) == date [EOL] [EOL] [EOL] def test_date_parser_returns_valid_date_from_other_date_str ( date ) : [EOL] assert parse_date_value ( date . strftime ( [string] ) ) == date [EOL] [EOL] [EOL] def test_date_parser_raises_value_error_on_invalid_data ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] parse_date_value ( [string] ) [EOL] [EOL] [EOL] def test_datetime_serializer_serializes_datetime ( datetime ) : [EOL] assert serialize_datetime ( datetime ) == datetime . isoformat ( ) [EOL] [EOL] [EOL] def test_datetime_serializer_serializes_date ( datetime , date ) : [EOL] assert serialize_datetime ( date ) == datetime . date ( ) . isoformat ( ) [EOL] [EOL] [EOL] def test_datetime_parser_returns_valid_date_from_datetime_iso8601_str ( datetime ) : [EOL] assert parse_datetime_value ( datetime . isoformat ( ) ) == datetime [EOL] [EOL] [EOL] def test_datetime_parser_returns_valid_date_from_date_iso8601_str ( date ) : [EOL] [comment] [EOL] assert parse_datetime_value ( date . isoformat ( ) ) . date ( ) == date [EOL] [EOL] [EOL] def test_datetime_parser_returns_valid_date_from_other_date_str ( date ) : [EOL] [comment] [EOL] assert parse_datetime_value ( date . strftime ( [string] ) ) . date ( ) == date [EOL] [EOL] [EOL] def test_datetime_parser_raises_value_error_on_invalid_data ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] parse_datetime_value ( [string] ) [EOL] [EOL] [EOL] def test_date_scalar_has_serializer_set ( ) : [EOL] assert date_scalar . _serialize == serialize_date [EOL] [EOL] [EOL] def test_date_scalar_has_value_parser_set ( ) : [EOL] assert date_scalar . _parse_value == parse_date_value [EOL] [EOL] [EOL] def test_datetime_scalar_has_serializer_set ( ) : [EOL] assert datetime_scalar . _serialize == serialize_datetime [EOL] [EOL] [EOL] def test_datetime_scalar_has_value_parser_set ( ) : [EOL] assert datetime_scalar . _parse_value == parse_datetime_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] [EOL] import pytest [EOL] from django . core . files . uploadedfile import SimpleUploadedFile [EOL] [EOL] from ariadne . contrib . django . views import GraphQLView [EOL] [EOL] [EOL] @ pytest . fixture def view ( schema ) : [EOL] return GraphQLView . as_view ( schema = schema ) [EOL] [EOL] [EOL] def test_post_request_fails_if_request_content_type_is_not_json ( view , request_factory , snapshot ) : [EOL] request = request_factory . post ( [string] , content_type = [string] ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_post_request_fails_if_request_data_is_malformed_json ( view , request_factory , snapshot ) : [EOL] request = request_factory . post ( [string] , data = [string] , content_type = [string] ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_query_in_valid_post_request_is_executed ( view , request_factory , snapshot ) : [EOL] request = request_factory . post ( [string] , data = { [string] : [string] } , content_type = [string] ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_query_is_executed_for_multipart_form_request_with_file ( view , request_factory , snapshot ) : [EOL] request = request_factory . post ( [string] , { [string] : json . dumps ( { [string] : [string] , [string] : { [string] : None } , } ) , [string] : json . dumps ( { [string] : [ [string] ] } ) , [string] : SimpleUploadedFile ( [string] , [string] ) , } , ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_multipart_form_request_fails_if_operations_is_not_valid_json ( view , request_factory , snapshot ) : [EOL] request = request_factory . post ( [string] , { [string] : [string] , [string] : json . dumps ( { [string] : [ [string] ] } ) , [string] : SimpleUploadedFile ( [string] , [string] ) , } , ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_multipart_form_request_fails_if_map_is_not_valid_json ( view , request_factory , snapshot ) : [EOL] request = request_factory . post ( [string] , { [string] : json . dumps ( { [string] : [string] , [string] : { [string] : None } , } ) , [string] : [string] , [string] : SimpleUploadedFile ( [string] , [string] ) , } , ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_post_request_fails_for_introspection_when_disabled ( schema , request_factory , snapshot ) : [EOL] view = GraphQLView . as_view ( schema = schema , introspection = False ) [EOL] request = request_factory . post ( [string] , data = { [string] : [string] } , content_type = [string] , ) [EOL] response = view ( request ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] from django . conf import settings [EOL] from django . test import RequestFactory [EOL] [EOL] [EOL] def pytest_configure ( ) : [EOL] settings . configure ( USE_TZ = True , TIME_ZONE = [string] , INSTALLED_APPS = [ [string] ] , TEMPLATES = [ { [string] : [string] , [string] : True , } ] , ) [EOL] [EOL] [EOL] @ pytest . fixture def request_factory ( ) : [EOL] return RequestFactory ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from snapshottest import Snapshot [EOL] [EOL] [EOL] snapshots = Snapshot ( ) [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from snapshottest import Snapshot [EOL] [EOL] [EOL] snapshots = Snapshot ( ) [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from graphql import graphql_sync [EOL] [EOL] import pytest [EOL] [EOL] from ariadne . contrib . federation import ( FederatedInterfaceType , FederatedObjectType , make_federated_schema , ) [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return make_federated_schema ( [string] ) [EOL] [EOL] [EOL] def test_bind_interface_to_undefined_type_raises_error ( schema ) : [EOL] interface = FederatedInterfaceType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_bind_interface_to_invalid_type_raises_error ( schema ) : [EOL] interface = FederatedInterfaceType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_reference_resolver_can_be_set_using_decorator ( schema ) : [EOL] def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] interface = FederatedInterfaceType ( [string] ) [EOL] interface . set_type_resolver ( resolve_result_type ) [EOL] interface . reference_resolver ( ) ( lambda * _ : { [string] : [string] } ) [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] obj = FederatedObjectType ( [string] ) [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] } ] } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] == [ { [string] : [string] } ] [EOL] [EOL] [EOL] def test_reference_resolver_can_be_set_using_setter ( schema ) : [EOL] def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] interface = FederatedInterfaceType ( [string] ) [EOL] interface . set_type_resolver ( resolve_result_type ) [EOL] interface . reference_resolver ( lambda * _ : { [string] : [string] } ) [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] obj = FederatedObjectType ( [string] ) [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] } ] } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] == [ { [string] : [string] } ] [EOL] [EOL] [EOL] def test_reference_resolver_can_be_set_on_both_interface_and_type ( schema ) : [EOL] def resolve_result_type ( * _ ) : [comment] [EOL] return [string] [EOL] [EOL] interface = FederatedInterfaceType ( [string] ) [EOL] interface . set_type_resolver ( resolve_result_type ) [EOL] interface . reference_resolver ( ) ( lambda * _ : { [string] : [string] } ) [EOL] interface . bind_to_schema ( schema ) [EOL] [EOL] obj = FederatedObjectType ( [string] ) [EOL] obj . reference_resolver ( ) ( lambda * _ : { [string] : [string] } ) [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] } ] } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] == [ { [string] : [string] } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from graphql . utilities import strip_ignored_characters as sic [EOL] [EOL] from ariadne . contrib . federation import make_federated_schema [EOL] from ariadne . contrib . federation . utils import ( add_typename_to_possible_return , gather_directives , get_entity_types , includes_directive , purge_schema_directives , ) [EOL] [EOL] [EOL] def test_purge_directives_retain_federation_directives ( ) : [EOL] type_defs = [string] [EOL] [EOL] assert sic ( purge_schema_directives ( type_defs ) ) == sic ( type_defs ) [EOL] [EOL] [EOL] def test_purge_directives_retain_builtin_directives ( ) : [EOL] type_defs = [string] [EOL] [EOL] assert sic ( purge_schema_directives ( type_defs ) ) == sic ( type_defs ) [EOL] [EOL] [EOL] def test_purge_directives_remove_custom_directives ( ) : [EOL] type_defs = [string] [EOL] [EOL] assert sic ( purge_schema_directives ( type_defs ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_get_entity_types_with_key_directive ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] entity_types_with_key_directive = get_entity_types ( schema ) [EOL] [EOL] assert len ( entity_types_with_key_directive ) == [number] [EOL] assert schema . get_type ( [string] ) in entity_types_with_key_directive [EOL] assert schema . get_type ( [string] ) in entity_types_with_key_directive [EOL] [EOL] [EOL] def test_includes_directive ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] assert not includes_directive ( schema . get_type ( [string] ) , [string] ) [EOL] assert not includes_directive ( schema . get_type ( [string] ) , [string] ) [EOL] assert includes_directive ( schema . get_type ( [string] ) , [string] ) [EOL] assert includes_directive ( schema . get_type ( [string] ) , [string] ) [EOL] [EOL] [EOL] def test_gather_directives ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] product = schema . get_type ( [string] ) [EOL] directives = gather_directives ( product ) [EOL] [EOL] assert len ( directives ) == [number] [EOL] assert { d . name . value for d in directives } == { [string] , [string] } [EOL] [EOL] [EOL] def test_add_typename_to_dict ( ) : [EOL] resolver_return = { [string] : [string] } [EOL] [EOL] add_typename_to_possible_return ( resolver_return , [string] ) [EOL] [EOL] assert resolver_return . get ( [string] ) == [string] [EOL] [EOL] [EOL] def test_add_typename_to_object ( ) : [EOL] resolver_return = Mock ( name = [string] ) [EOL] [EOL] add_typename_to_possible_return ( resolver_return , [string] ) [EOL] [EOL] assert getattr ( resolver_return , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from graphql import graphql_sync [EOL] [EOL] import pytest [EOL] [EOL] from ariadne . contrib . federation import ( FederatedObjectType , make_federated_schema , ) [EOL] [EOL] [EOL] @ pytest . fixture def schema ( ) : [EOL] return make_federated_schema ( [string] ) [EOL] [EOL] [EOL] def test_bind_federated_object_type_to_undefined_type_raises_error ( schema ) : [EOL] obj = FederatedObjectType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_bind_federated_object_type_to_invalid_type_raises_error ( schema ) : [EOL] obj = FederatedObjectType ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] [EOL] def test_reference_resolver_can_be_set_using_decorator ( schema ) : [EOL] obj = FederatedObjectType ( [string] ) [EOL] obj . reference_resolver ( ) ( lambda * _ : { [string] : [string] } ) [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] } ] } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] == [ { [string] : [string] } ] [EOL] [EOL] [EOL] def test_reference_resolver_can_be_set_using_setter ( schema ) : [EOL] obj = FederatedObjectType ( [string] ) [EOL] obj . reference_resolver ( lambda * _ : { [string] : [string] } ) [EOL] obj . bind_to_schema ( schema ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] } ] } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] == [ { [string] : [string] } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from graphql import graphql , graphql_sync [EOL] from graphql . utilities import strip_ignored_characters as sic [EOL] from graphql . utilities . print_schema import ( print_interface , print_object , print_union , ) [EOL] [EOL] from ariadne . contrib . federation import ( FederatedInterfaceType , FederatedObjectType , make_federated_schema , ) [EOL] [EOL] [EOL] def test_federated_schema_mark_type_with_key ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] schema = make_federated_schema ( type_defs , product ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] assert sic ( print_union ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_mark_type_with_key_split_type_defs ( ) : [EOL] query_type_defs = [string] [EOL] [EOL] product_type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] schema = make_federated_schema ( [ query_type_defs , product_type_defs ] , product , ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] assert sic ( print_union ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_mark_type_with_multiple_keys ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] schema = make_federated_schema ( type_defs , product ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] assert sic ( print_union ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_not_mark_type_with_no_keys ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] schema = make_federated_schema ( type_defs , product ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] assert schema . get_type ( [string] ) is None [EOL] [EOL] [EOL] def test_federated_schema_mark_interface_with_key ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedInterfaceType ( [string] ) [EOL] schema = make_federated_schema ( type_defs , product ) [EOL] [EOL] assert sic ( print_interface ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] assert schema . get_type ( [string] ) is None [EOL] [EOL] [EOL] def test_federated_schema_mark_interface_with_multiple_keys ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedInterfaceType ( [string] ) [EOL] schema = make_federated_schema ( type_defs , product ) [EOL] [EOL] assert sic ( print_interface ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] assert schema . get_type ( [string] ) is None [EOL] [EOL] [EOL] def test_federated_schema_augment_root_query_with_type_key ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_augment_root_query_with_interface_key ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_augment_root_query_with_no_keys ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] assert sic ( print_object ( schema . get_type ( [string] ) ) ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_execute_reference_resolver ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] [EOL] @ product . reference_resolver ( ) def product_reference_resolver ( _obj , _info , reference ) : [EOL] assert reference [ [string] ] == [number] [EOL] return { [string] : [string] } [EOL] [EOL] user = FederatedObjectType ( [string] ) [EOL] [EOL] @ user . reference_resolver ( ) def user_reference_resolver ( _obj , _info , reference ) : [EOL] assert reference [ [string] ] == [number] [EOL] return Mock ( firstName = [string] ) [EOL] [EOL] schema = make_federated_schema ( type_defs , [ product , user ] ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [number] , } , ] , } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_federated_schema_execute_async_reference_resolver ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] [EOL] @ product . reference_resolver ( ) async def product_reference_resolver ( _obj , _info , reference ) : [EOL] assert reference [ [string] ] == [number] [EOL] return { [string] : [string] } [EOL] [EOL] user = FederatedObjectType ( [string] ) [EOL] [EOL] @ user . reference_resolver ( ) async def user_reference_resolver ( _obj , _info , reference ) : [EOL] assert reference [ [string] ] == [number] [EOL] return Mock ( firstName = [string] ) [EOL] [EOL] schema = make_federated_schema ( type_defs , [ product , user ] ) [EOL] [EOL] result = await graphql ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [number] , } , ] , } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_federated_schema_execute_default_reference_resolver ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , } , ] , } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_federated_schema_execute_reference_resolver_that_returns_none ( ) : [EOL] type_defs = [string] [EOL] [EOL] product = FederatedObjectType ( [string] ) [EOL] [EOL] @ product . reference_resolver ( ) def product_reference_resolver ( _obj , _info , reference ) : [EOL] assert reference [ [string] ] == [number] [EOL] [comment] [EOL] [EOL] schema = make_federated_schema ( type_defs , product ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] , } , ] , } , ) [EOL] [EOL] assert result . errors is None [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result . data [ [string] ] [ [number] ] [ [string] ] is None [EOL] [EOL] [EOL] def test_federated_schema_raises_error_on_missing_type ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] result = graphql_sync ( schema , [string] , variable_values = { [string] : [ { [string] : [string] , [string] : [number] , } , ] , } , ) [EOL] [EOL] assert result . errors is not None [EOL] [EOL] [EOL] def test_federated_schema_query_service_with_key ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] result = graphql_sync ( schema , [string] , ) [EOL] [EOL] assert result . errors is None [EOL] assert sic ( result . data [ [string] ] [ [string] ] ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_query_service_with_multiple_keys ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] result = graphql_sync ( schema , [string] , ) [EOL] [EOL] assert result . errors is None [EOL] assert sic ( result . data [ [string] ] [ [string] ] ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_query_service_provide_federation_directives ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] result = graphql_sync ( schema , [string] , ) [EOL] [EOL] assert result . errors is None [EOL] assert sic ( result . data [ [string] ] [ [string] ] ) == sic ( [string] ) [EOL] [EOL] [EOL] def test_federated_schema_query_service_ignore_custom_directives ( ) : [EOL] type_defs = [string] [EOL] [EOL] schema = make_federated_schema ( type_defs ) [EOL] [EOL] result = graphql_sync ( schema , [string] , ) [EOL] [EOL] assert result . errors is None [EOL] assert sic ( result . data [ [string] ] [ [string] ] ) == sic ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from starlette . testclient import TestClient [EOL] [EOL] from ariadne . asgi import GraphQL [EOL] [EOL] [EOL] @ pytest . fixture def app ( schema ) : [EOL] return GraphQL ( schema ) [EOL] [EOL] [EOL] @ pytest . fixture def client ( app ) : [EOL] return TestClient ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] [EOL] [EOL] def test_attempt_parse_request_missing_content_type_raises_bad_request_error ( client , snapshot ) : [EOL] response = client . post ( [string] , data = [string] ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . text ) [EOL] [EOL] [EOL] def test_attempt_parse_non_json_request_raises_bad_request_error ( client , snapshot ) : [EOL] response = client . post ( [string] , data = [string] , headers = { [string] : [string] } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . text ) [EOL] [EOL] [EOL] def test_attempt_parse_non_json_request_body_raises_bad_request_error ( client , snapshot ) : [EOL] response = client . post ( [string] , data = [string] , headers = { [string] : [string] } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . text ) [EOL] [EOL] [EOL] def test_attempt_parse_json_scalar_request_raises_graphql_bad_request_error ( client , snapshot ) : [EOL] response = client . post ( [string] , json = [string] ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . text ) [EOL] [EOL] [EOL] def test_attempt_parse_json_array_request_raises_graphql_bad_request_error ( client , snapshot ) : [EOL] response = client . post ( [string] , json = [ [number] , [number] , [number] ] ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . text ) [EOL] [EOL] [EOL] def test_multipart_form_request_fails_if_operations_is_not_valid_json ( client , snapshot ) : [EOL] response = client . post ( [string] , data = { [string] : [string] , [string] : json . dumps ( { [string] : [ [string] ] } ) , } , files = { [string] : ( [string] , [string] ) } , ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL] [EOL] [EOL] def test_multipart_form_request_fails_if_map_is_not_valid_json ( client , snapshot ) : [EOL] response = client . post ( [string] , data = { [string] : json . dumps ( { [string] : [string] , [string] : { [string] : None } , } ) , [string] : [string] , } , files = { [string] : ( [string] , [string] ) } , ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import ariadne [EOL] import unittest [EOL] from unittest . mock import ANY , Mock [EOL] [EOL] from starlette . testclient import TestClient [EOL] [EOL] from ariadne . asgi import ( GQL_CONNECTION_ACK , GQL_CONNECTION_INIT , GQL_DATA , GQL_ERROR , GQL_START , GraphQL , ) [EOL] from ariadne . types import Extension [EOL] [EOL] [EOL] def test_custom_context_value_is_passed_to_resolvers ( schema ) : [EOL] app = GraphQL ( schema , context_value = { [string] : [string] } ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_context_value_function_is_set_and_called_by_app ( schema ) : [EOL] get_context_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , context_value = get_context_value ) [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] get_context_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_context_value_function_result_is_passed_to_resolvers ( schema ) : [EOL] get_context_value = Mock ( return_value = { [string] : [string] } ) [EOL] app = GraphQL ( schema , context_value = get_context_value ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_async_context_value_function_result_is_awaited_before_passing_to_resolvers ( schema , ) : [EOL] async def get_context_value ( * _ ) : [EOL] return { [string] : [string] } [EOL] [EOL] app = GraphQL ( schema , context_value = get_context_value ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_is_passed_to_query_resolvers ( schema ) : [EOL] app = GraphQL ( schema , root_value = { [string] : [string] } ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_is_passed_to_subscription_resolvers ( schema ) : [EOL] app = GraphQL ( schema , root_value = { [string] : [string] } ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] assert response [ [string] ] == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_function_is_called_by_query ( schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , root_value = get_root_value ) [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] get_root_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_root_value_function_is_called_by_subscription ( schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , root_value = get_root_value ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] get_root_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_root_value_function_is_called_with_context_value ( schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , context_value = { [string] : [string] } , root_value = get_root_value ) [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] get_root_value . assert_called_once_with ( { [string] : [string] } , ANY ) [EOL] [EOL] [EOL] def test_custom_validation_rule_is_called_by_query_validation ( mocker , schema , validation_rule ) : [EOL] spy_validation_rule = mocker . spy ( validation_rule , [string] ) [EOL] app = GraphQL ( schema , validation_rules = [ validation_rule ] ) [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] spy_validation_rule . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_validation_rules_function_is_set_and_called_on_query_execution ( mocker , schema , validation_rule ) : [EOL] spy_validation_rule = mocker . spy ( validation_rule , [string] ) [EOL] get_validation_rules = Mock ( return_value = [ validation_rule ] ) [EOL] app = GraphQL ( schema , validation_rules = get_validation_rules ) [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] get_validation_rules . assert_called_once ( ) [EOL] spy_validation_rule . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_validation_rules_function_is_called_with_context_value ( schema , validation_rule ) : [EOL] get_validation_rules = Mock ( return_value = [ validation_rule ] ) [EOL] app = GraphQL ( schema , context_value = { [string] : [string] } , validation_rules = get_validation_rules , ) [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] get_validation_rules . assert_called_once_with ( { [string] : [string] } , ANY , ANY ) [EOL] [EOL] [EOL] def execute_failing_query ( app ) : [EOL] client = TestClient ( app ) [EOL] client . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] [EOL] def test_default_logger_is_used_to_log_error_if_custom_is_not_set ( schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] app = GraphQL ( schema ) [EOL] execute_failing_query ( app ) [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_logger_is_used_to_log_query_error ( schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] app = GraphQL ( schema , logger = [string] ) [EOL] execute_failing_query ( app ) [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_logger_is_used_to_log_subscription_source_error ( schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] app = GraphQL ( schema , logger = [string] ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_logger_is_used_to_log_subscription_resolver_error ( schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] app = GraphQL ( schema , logger = [string] ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_error_formatter_is_used_to_format_query_error ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , error_formatter = error_formatter ) [EOL] execute_failing_query ( app ) [EOL] error_formatter . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_error_formatter_is_used_to_format_subscription_syntax_error ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , error_formatter = error_formatter ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_ERROR [EOL] assert response [ [string] ] == [string] [EOL] error_formatter . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_error_formatter_is_used_to_format_subscription_source_error ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , error_formatter = error_formatter ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] assert response [ [string] ] == [string] [EOL] error_formatter . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_error_formatter_is_used_to_format_subscription_resolver_error ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , error_formatter = error_formatter ) [EOL] client = TestClient ( app ) [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] assert response [ [string] ] == [string] [EOL] error_formatter . assert_called_once ( ) [EOL] [EOL] [EOL] def test_error_formatter_is_called_with_debug_enabled ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , debug = True , error_formatter = error_formatter ) [EOL] execute_failing_query ( app ) [EOL] error_formatter . assert_called_once_with ( ANY , True ) [EOL] [EOL] [EOL] def test_error_formatter_is_called_with_debug_disabled ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , debug = False , error_formatter = error_formatter ) [EOL] execute_failing_query ( app ) [EOL] error_formatter . assert_called_once_with ( ANY , False ) [EOL] [EOL] [EOL] class CustomExtension ( Extension ) : [EOL] async def resolve ( self , next_ , parent , info , ** kwargs ) : [EOL] return next_ ( parent , info , ** kwargs ) . lower ( ) [EOL] [EOL] [EOL] def test_extension_from_option_are_passed_to_query_executor ( schema ) : [EOL] app = GraphQL ( schema , extensions = [ CustomExtension ] ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_extensions_function_result_is_passed_to_query_executor ( schema ) : [EOL] def get_extensions ( * _ ) : [EOL] return [ CustomExtension ] [EOL] [EOL] app = GraphQL ( schema , extensions = get_extensions ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_async_extensions_function_result_is_passed_to_query_executor ( schema ) : [EOL] async def get_extensions ( * _ ) : [EOL] return [ CustomExtension ] [EOL] [EOL] app = GraphQL ( schema , extensions = get_extensions ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def middleware ( next_fn , * args , ** kwargs ) : [EOL] value = next_fn ( * args , ** kwargs ) [EOL] return f" [string] { value } [string] " [EOL] [EOL] [EOL] def test_middlewares_are_passed_to_query_executor ( schema ) : [EOL] app = GraphQL ( schema , middleware = [ middleware ] ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_middleware_function_result_is_passed_to_query_executor ( schema ) : [EOL] def get_middleware ( * _ ) : [EOL] return [ middleware ] [EOL] [EOL] app = GraphQL ( schema , middleware = get_middleware ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_async_middleware_function_result_is_passed_to_query_executor ( schema ) : [EOL] async def get_middleware ( * _ ) : [EOL] return [ middleware ] [EOL] [EOL] app = GraphQL ( schema , middleware = get_middleware ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from starlette . testclient import TestClient [EOL] [EOL] from ariadne . asgi import GraphQL [EOL] [EOL] [EOL] def test_playground_html_is_served_on_get_request ( schema , snapshot ) : [EOL] app = GraphQL ( schema ) [EOL] client = TestClient ( app ) [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def test_unsupported_patch ( client ) : [EOL] response = client . patch ( [string] , json = { } ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_unsupported_put ( client ) : [EOL] response = client . patch ( [string] , json = { } ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import ariadne [EOL] import json [EOL] [EOL] from starlette . testclient import TestClient [EOL] [EOL] from ariadne . asgi import ( GQL_CONNECTION_ACK , GQL_ERROR , GQL_CONNECTION_INIT , GQL_START , GraphQL , ) [EOL] from ariadne . types import Extension [EOL] [EOL] [EOL] operation_name = [string] [EOL] variables = { [string] : [string] } [EOL] complex_query = [string] [EOL] [EOL] [EOL] def test_query_is_executed_for_post_json_request ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_complex_query_is_executed_for_post_json_request ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : complex_query , [string] : variables , [string] : operation_name , } , ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_complex_query_without_operation_name_executes_successfully ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : complex_query , [string] : variables } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_complex_query_without_variables_returns_error_json ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : complex_query , [string] : operation_name } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_query_without_query_entry_returns_error_json ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : variables } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_query_with_non_string_query_returns_error_json ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : { [string] : [string] } } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_query_with_invalid_variables_returns_error_json ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : complex_query , [string] : [string] } ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_query_with_invalid_operation_name_string_returns_error_json ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : complex_query , [string] : variables , [string] : [string] , } , ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_query_with_invalid_operation_name_type_returns_error_json ( client , snapshot ) : [EOL] response = client . post ( [string] , json = { [string] : complex_query , [string] : variables , [string] : [ [number] , [number] , [number] ] , } , ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] def test_attempt_execute_subscription_with_invalid_query_returns_error_json ( client , snapshot ) : [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_ERROR [EOL] snapshot . assert_match ( response [ [string] ] ) [EOL] [EOL] [EOL] def test_query_is_executed_for_multipart_form_request_with_file ( client , snapshot ) : [EOL] response = client . post ( [string] , data = { [string] : json . dumps ( { [string] : [string] , [string] : { [string] : None } , } ) , [string] : json . dumps ( { [string] : [ [string] ] } ) , } , files = { [string] : ( [string] , [string] ) } , ) [EOL] assert response . status_code == [number] [EOL] snapshot . assert_match ( response . json ( ) ) [EOL] [EOL] [EOL] class CustomExtension ( Extension ) : [EOL] async def resolve ( self , next_ , parent , info , ** kwargs ) : [EOL] value = next_ ( parent , info , ** kwargs ) [EOL] return f" [string] { value } [string] " [EOL] [EOL] [EOL] def test_middlewares_and_extensions_are_combined_in_correct_order ( schema ) : [EOL] def test_middleware ( next_fn , * args , ** kwargs ) : [EOL] value = next_fn ( * args , ** kwargs ) [EOL] return f" [string] { value } [string] " [EOL] [EOL] app = GraphQL ( schema , extensions = [ CustomExtension ] , middleware = [ test_middleware ] ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from ariadne . asgi import ( GQL_CONNECTION_INIT , GQL_CONNECTION_ACK , GQL_START , GQL_DATA , GQL_STOP , GQL_COMPLETE , GQL_CONNECTION_TERMINATE , ) [EOL] [EOL] [EOL] def test_field_can_be_subscribed_using_websocket_connection ( client ) : [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] assert response [ [string] ] == [string] [EOL] assert response [ [string] ] [ [string] ] == { [string] : [string] } [EOL] ws . send_json ( { [string] : GQL_STOP , [string] : [string] } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_COMPLETE [EOL] assert response [ [string] ] == [string] [EOL] ws . send_json ( { [string] : GQL_CONNECTION_TERMINATE } ) [EOL] [EOL] [EOL] def test_field_can_be_subscribed_using_unnamed_operation_in_websocket_connection ( client , ) : [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : None , [string] : [string] , } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] assert response [ [string] ] == [string] [EOL] assert response [ [string] ] [ [string] ] == { [string] : [string] } [EOL] ws . send_json ( { [string] : GQL_STOP , [string] : [string] } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_COMPLETE [EOL] assert response [ [string] ] == [string] [EOL] ws . send_json ( { [string] : GQL_CONNECTION_TERMINATE } ) [EOL] [EOL] [EOL] def test_field_can_be_subscribed_using_named_operation_in_websocket_connection ( client ) : [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_DATA [EOL] assert response [ [string] ] == [string] [EOL] assert response [ [string] ] [ [string] ] == { [string] : [string] } [EOL] ws . send_json ( { [string] : GQL_STOP , [string] : [string] } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_COMPLETE [EOL] assert response [ [string] ] == [string] [EOL] ws . send_json ( { [string] : GQL_CONNECTION_TERMINATE } ) [EOL] [EOL] [EOL] def test_immediate_disconnect ( client ) : [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] ws . send_json ( { [string] : GQL_CONNECTION_TERMINATE } ) [EOL] [EOL] [EOL] def test_stop ( client ) : [EOL] with client . websocket_connect ( [string] , [string] ) as ws : [EOL] ws . send_json ( { [string] : GQL_CONNECTION_INIT } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_CONNECTION_ACK [EOL] ws . send_json ( { [string] : GQL_START , [string] : [string] , [string] : { [string] : [string] } , } ) [EOL] ws . send_json ( { [string] : GQL_STOP , [string] : [string] } ) [EOL] response = ws . receive_json ( ) [EOL] assert response [ [string] ] == GQL_COMPLETE [EOL] assert response [ [string] ] == [string] [EOL] ws . send_json ( { [string] : GQL_CONNECTION_TERMINATE } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from snapshottest import Snapshot [EOL] [EOL] [EOL] snapshots = Snapshot ( ) [EOL] [EOL] snapshots [ [string] ] = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from snapshottest import Snapshot [EOL] [EOL] [EOL] snapshots = Snapshot ( ) [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL] [EOL] snapshots [ [string] ] = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] from ariadne . wsgi import GraphQLMiddleware [EOL] [EOL] [EOL] def test_initializing_middleware_without_path_raises_value_error ( schema ) : [EOL] with pytest . raises ( Exception ) as excinfo : [EOL] GraphQLMiddleware ( lambda * _ : None , schema , path = [string] ) [EOL] [EOL] assert isinstance ( excinfo . value , ValueError ) [EOL] assert excinfo . value . args [ [number] ] == [string] [EOL] [EOL] [EOL] def test_initializing_middleware_with_non_callable_app_raises_type_error ( schema ) : [EOL] with pytest . raises ( Exception ) as excinfo : [EOL] GraphQLMiddleware ( True , schema , path = [string] ) [EOL] assert isinstance ( excinfo . value , TypeError ) [EOL] assert excinfo . value . args [ [number] ] == [string] [EOL] [EOL] [EOL] def test_initializing_middleware_without_app_raises_type_error ( schema ) : [EOL] with pytest . raises ( Exception ) as excinfo : [EOL] GraphQLMiddleware ( None , schema ) [EOL] assert isinstance ( excinfo . value , TypeError ) [EOL] assert excinfo . value . args [ [number] ] == ( [string] ) [EOL] [EOL] [EOL] def test_initializing_middleware_with_app_and_root_path_raises_value_error ( app_mock , schema ) : [EOL] with pytest . raises ( Exception ) as excinfo : [EOL] GraphQLMiddleware ( app_mock , schema , path = [string] ) [EOL] assert isinstance ( excinfo . value , ValueError ) [EOL] assert excinfo . value . args [ [number] ] == ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import ariadne [EOL] from unittest . mock import Mock [EOL] [EOL] from ariadne . exceptions import HttpError , HttpBadRequestError , HttpMethodNotAllowedError [EOL] [EOL] [EOL] def test_http_errors_raised_in_handle_request_are_passed_to_http_error_handler ( middleware , middleware_request , start_response ) : [EOL] exception = HttpError ( ) [EOL] middleware . graphql_app . handle_request = Mock ( side_effect = exception ) [EOL] handle_error = middleware . graphql_app . handle_http_error = Mock ( ) [EOL] middleware ( middleware_request , start_response ) [EOL] [EOL] handle_error . assert_called_once_with ( exception , start_response ) [EOL] [EOL] [EOL] def test_http_error_400_is_converted_to_http_response_in_http_error_handler ( middleware , middleware_request , start_response , error_response_headers ) : [EOL] exception = HttpBadRequestError ( ) [EOL] middleware . graphql_app . handle_request = Mock ( side_effect = exception ) [EOL] [EOL] response = middleware ( middleware_request , start_response ) [EOL] start_response . assert_called_once_with ( exception . status , error_response_headers ) [EOL] assert response == [ exception . status . encode ( [string] ) ] [EOL] [EOL] [EOL] def test_http_error_400_with_message_is_converted_to_http_response_in_http_error_handler ( middleware , middleware_request , start_response , error_response_headers ) : [EOL] message = [string] [EOL] exception = HttpBadRequestError ( message ) [EOL] middleware . graphql_app . handle_request = Mock ( side_effect = exception ) [EOL] [EOL] response = middleware ( middleware_request , start_response ) [EOL] start_response . assert_called_once_with ( exception . status , error_response_headers ) [EOL] assert response == [ message . encode ( [string] ) ] [EOL] [EOL] [EOL] def test_http_error_405_is_converted_to_http_response_in_http_error_handler ( middleware , middleware_request , start_response , error_response_headers ) : [EOL] exception = HttpMethodNotAllowedError ( ) [EOL] middleware . graphql_app . handle_request = Mock ( side_effect = exception ) [EOL] [EOL] response = middleware ( middleware_request , start_response ) [EOL] start_response . assert_called_once_with ( exception . status , error_response_headers ) [EOL] assert response == [ exception . status . encode ( [string] ) ] [EOL] [EOL] [EOL] def test_http_error_405_with_message_is_converted_to_http_response_in_http_error_handler ( middleware , middleware_request , start_response , error_response_headers ) : [EOL] message = [string] [EOL] exception = HttpMethodNotAllowedError ( message ) [EOL] middleware . graphql_app . handle_request = Mock ( side_effect = exception ) [EOL] [EOL] response = middleware ( middleware_request , start_response ) [EOL] start_response . assert_called_once_with ( exception . status , error_response_headers ) [EOL] assert response == [ message . encode ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] from io import BytesIO [EOL] [EOL] from ariadne . constants import HTTP_STATUS_400_BAD_REQUEST [EOL] from ariadne . exceptions import HttpBadRequestError [EOL] [EOL] from . factories import create_multipart_request [EOL] [EOL] [EOL] def test_attempt_parse_request_missing_content_type_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( ) [EOL] request . pop ( [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_parse_non_json_request_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( content_type = [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_get_content_length_from_missing_header_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( ) [EOL] request . pop ( [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_get_content_length_from_malformed_header_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( content_length = [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_get_request_body_from_missing_wsgi_input_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( ) [EOL] request . pop ( [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_get_request_body_from_empty_wsgi_input_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( ) [EOL] request [ [string] ] = BytesIO ( [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_parse_non_json_request_body_raises_bad_request_error ( middleware , start_response , snapshot , graphql_query_request_factory , error_response_headers , ) : [EOL] request = graphql_query_request_factory ( raw_data = [string] ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_attempt_parse_json_scalar_request_raises_graphql_bad_request_error ( middleware , start_response , graphql_query_request_factory , graphql_response_headers , assert_json_response_equals_snapshot , ) : [EOL] request = graphql_query_request_factory ( raw_data = json . dumps ( [string] ) ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , graphql_response_headers ) [EOL] assert_json_response_equals_snapshot ( result ) [EOL] [EOL] [EOL] def test_attempt_parse_json_array_request_raises_graphql_bad_request_error ( middleware , start_response , graphql_query_request_factory , graphql_response_headers , assert_json_response_equals_snapshot , ) : [EOL] request = graphql_query_request_factory ( raw_data = json . dumps ( [ [number] , [number] , [number] ] ) ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HttpBadRequestError . status , graphql_response_headers ) [EOL] assert_json_response_equals_snapshot ( result ) [EOL] [EOL] [EOL] def test_multipart_form_request_fails_if_operations_is_not_valid_json ( middleware , snapshot , start_response , error_response_headers ) : [EOL] data = [string] . strip ( ) [EOL] [EOL] request = create_multipart_request ( data ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HTTP_STATUS_400_BAD_REQUEST , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL] [EOL] [EOL] def test_multipart_form_request_fails_if_map_is_not_valid_json ( middleware , snapshot , start_response , error_response_headers ) : [EOL] data = [string] . strip ( ) [EOL] [EOL] request = create_multipart_request ( data ) [EOL] result = middleware ( request , start_response ) [EOL] start_response . assert_called_once_with ( HTTP_STATUS_400_BAD_REQUEST , error_response_headers ) [EOL] snapshot . assert_match ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] from ariadne . constants import HTTP_STATUS_200_OK [EOL] [EOL] playground_response_headers = [ ( [string] , [string] ) ] [EOL] [EOL] [EOL] def test_playground_html_is_served_on_get_request ( middleware , middleware_request , snapshot , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] response = middleware ( middleware_request , start_response ) [EOL] start_response . assert_called_once_with ( HTTP_STATUS_200_OK , playground_response_headers ) [EOL] snapshot . assert_match ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import tests [EOL] import typing [EOL] import ariadne [EOL] import unittest [EOL] import json [EOL] from io import BytesIO [EOL] from unittest . mock import ANY , Mock [EOL] [EOL] from werkzeug . test import Client [EOL] from werkzeug . wrappers import BaseResponse [EOL] [EOL] from ariadne . constants import DATA_TYPE_JSON [EOL] from ariadne . types import ExtensionSync [EOL] from ariadne . wsgi import GraphQL [EOL] [EOL] [EOL] [comment] [EOL] class Response ( BaseResponse ) : [EOL] def json ( self ) : [EOL] return json . loads ( self . data ) [EOL] [EOL] [EOL] [comment] [EOL] class TestClient ( Client ) : [EOL] __test__ = False [EOL] [EOL] def __init__ ( self , app ) : [EOL] super ( ) . __init__ ( app , Response ) [EOL] [EOL] [EOL] def test_custom_context_value_is_passed_to_resolvers ( schema ) : [EOL] app = GraphQL ( schema , context_value = { [string] : [string] } ) [EOL] _ , result = app . execute_query ( { } , { [string] : [string] } ) [EOL] assert result == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_context_value_function_is_set_and_called_by_app ( schema ) : [EOL] get_context_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , context_value = get_context_value ) [EOL] app . execute_query ( { } , { [string] : [string] } ) [EOL] get_context_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_context_value_function_is_called_with_request_value ( schema ) : [EOL] get_context_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , context_value = get_context_value ) [EOL] request = { [string] : DATA_TYPE_JSON } [EOL] app . execute_query ( request , { [string] : [string] } ) [EOL] get_context_value . assert_called_once_with ( request ) [EOL] [EOL] [EOL] def test_custom_context_value_function_result_is_passed_to_resolvers ( schema ) : [EOL] get_context_value = Mock ( return_value = { [string] : [string] } ) [EOL] app = GraphQL ( schema , context_value = get_context_value ) [EOL] _ , result = app . execute_query ( { } , { [string] : [string] } ) [EOL] assert result == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_is_passed_to_resolvers ( schema ) : [EOL] app = GraphQL ( schema , root_value = { [string] : [string] } ) [EOL] _ , result = app . execute_query ( { } , { [string] : [string] } ) [EOL] assert result == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_custom_root_value_function_is_set_and_called_by_app ( schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , root_value = get_root_value ) [EOL] app . execute_query ( { } , { [string] : [string] } ) [EOL] get_root_value . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_root_value_function_is_called_with_context_value ( schema ) : [EOL] get_root_value = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , context_value = { [string] : [string] } , root_value = get_root_value ) [EOL] app . execute_query ( { } , { [string] : [string] } ) [EOL] get_root_value . assert_called_once_with ( { [string] : [string] } , ANY ) [EOL] [EOL] [EOL] def test_custom_validation_rule_is_called_by_query_validation ( mocker , schema , validation_rule ) : [EOL] spy_validation_rule = mocker . spy ( validation_rule , [string] ) [EOL] app = GraphQL ( schema , validation_rules = [ validation_rule ] ) [EOL] app . execute_query ( { } , { [string] : [string] } ) [EOL] spy_validation_rule . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_validation_rules_function_is_set_and_called_on_query_execution ( mocker , schema , validation_rule ) : [EOL] spy_validation_rule = mocker . spy ( validation_rule , [string] ) [EOL] get_validation_rules = Mock ( return_value = [ validation_rule ] ) [EOL] app = GraphQL ( schema , validation_rules = get_validation_rules ) [EOL] app . execute_query ( { } , { [string] : [string] } ) [EOL] get_validation_rules . assert_called_once ( ) [EOL] spy_validation_rule . assert_called_once ( ) [EOL] [EOL] [EOL] def test_custom_validation_rules_function_is_called_with_context_value ( schema , validation_rule ) : [EOL] get_validation_rules = Mock ( return_value = [ validation_rule ] ) [EOL] app = GraphQL ( schema , context_value = { [string] : [string] } , validation_rules = get_validation_rules , ) [EOL] app . execute_query ( { } , { [string] : [string] } ) [EOL] get_validation_rules . assert_called_once_with ( { [string] : [string] } , ANY , ANY ) [EOL] [EOL] [EOL] def execute_failing_query ( app ) : [EOL] data = json . dumps ( { [string] : [string] } ) [EOL] app ( { [string] : [string] , [string] : DATA_TYPE_JSON , [string] : len ( data ) , [string] : BytesIO ( data . encode ( [string] ) ) , } , Mock ( ) , ) [EOL] [EOL] [EOL] def test_default_logger_is_used_to_log_error_if_custom_is_not_set ( schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] app = GraphQL ( schema ) [EOL] execute_failing_query ( app ) [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_logger_is_used_to_log_error ( schema , mocker ) : [EOL] logging_mock = mocker . patch ( [string] ) [EOL] app = GraphQL ( schema , logger = [string] ) [EOL] execute_failing_query ( app ) [EOL] logging_mock . getLogger . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_custom_error_formatter_is_used_to_format_error ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , error_formatter = error_formatter ) [EOL] execute_failing_query ( app ) [EOL] error_formatter . assert_called_once ( ) [EOL] [EOL] [EOL] def test_error_formatter_is_called_with_debug_enabled_flag ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , debug = True , error_formatter = error_formatter ) [EOL] execute_failing_query ( app ) [EOL] error_formatter . assert_called_once_with ( ANY , True ) [EOL] [EOL] [EOL] def test_error_formatter_is_called_with_debug_disabled_flag ( schema ) : [EOL] error_formatter = Mock ( return_value = True ) [EOL] app = GraphQL ( schema , debug = False , error_formatter = error_formatter ) [EOL] execute_failing_query ( app ) [EOL] error_formatter . assert_called_once_with ( ANY , False ) [EOL] [EOL] [EOL] class CustomExtension ( ExtensionSync ) : [EOL] def resolve ( self , next_ , parent , info , ** kwargs ) : [EOL] return next_ ( parent , info , ** kwargs ) . lower ( ) [EOL] [EOL] [EOL] def test_extension_from_option_are_passed_to_query_executor ( schema ) : [EOL] app = GraphQL ( schema , extensions = [ CustomExtension ] ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_extensions_function_result_is_passed_to_query_executor ( schema ) : [EOL] def get_extensions ( * _ ) : [EOL] return [ CustomExtension ] [EOL] [EOL] app = GraphQL ( schema , extensions = get_extensions ) [EOL] client = TestClient ( app ) [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . json ( ) == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def middleware ( next_fn , * args , ** kwargs ) : [EOL] value = next_fn ( * args , ** kwargs ) [EOL] return f" [string] { value } [string] " [EOL] [EOL] [EOL] def test_middlewares_are_passed_to_query_executor ( schema ) : [EOL] app = GraphQL ( schema , middleware = [ middleware ] ) [EOL] _ , result = app . execute_query ( { } , { [string] : [string] } ) [EOL] assert result == { [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def test_middleware_function_result_is_passed_to_query_executor ( schema ) : [EOL] def get_middleware ( * _ ) : [EOL] return [ middleware ] [EOL] [EOL] app = GraphQL ( schema , middleware = get_middleware ) [EOL] _ , result = app . execute_query ( { } , { [string] : [string] } ) [EOL] assert result == { [string] : { [string] : [string] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from io import BytesIO [EOL] [EOL] [EOL] def create_multipart_request ( data ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : ( [string] ) , [string] : len ( data ) , [string] : BytesIO ( data . encode ( [string] ) ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import ariadne [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] [EOL] from ariadne . exceptions import HttpMethodNotAllowedError [EOL] from ariadne . wsgi import GraphQLMiddleware [EOL] [EOL] [EOL] def test_request_to_app_root_path_is_forwarded ( app_mock , middleware ) : [EOL] middleware ( { [string] : [string] } , Mock ( ) ) [EOL] assert app_mock . called [EOL] [EOL] [EOL] def test_request_to_app_sub_path_is_forwarded ( app_mock , middleware ) : [EOL] middleware ( { [string] : [string] } , Mock ( ) ) [EOL] assert app_mock . called [EOL] [EOL] [EOL] def test_request_to_graphql_path_is_handled ( app_mock , middleware ) : [EOL] handle_request = middleware . graphql_app . handle_request = Mock ( ) [EOL] middleware ( { [string] : [string] } , Mock ( ) ) [EOL] assert handle_request . called [EOL] assert not app_mock . called [EOL] [EOL] [EOL] def test_request_to_graphql_server_root_path_is_handled ( server ) : [EOL] server . handle_request = Mock ( ) [EOL] server ( { [string] : [string] } , Mock ( ) ) [EOL] assert server . handle_request . called [EOL] [EOL] [EOL] def test_request_to_graphql_server_sub_path_is_handled ( server ) : [EOL] server . handle_request = Mock ( ) [EOL] server ( { [string] : [string] } , Mock ( ) ) [EOL] assert server . handle_request . called [EOL] [EOL] [EOL] def test_app_exceptions_are_not_handled ( app_mock , schema ) : [EOL] exception = Exception ( [string] ) [EOL] app_mock = Mock ( side_effect = exception ) [EOL] middleware = GraphQLMiddleware ( app_mock , schema ) [EOL] handle_request = middleware . graphql_app . handle_request = Mock ( ) [EOL] [EOL] with pytest . raises ( Exception ) as excinfo : [EOL] middleware ( { [string] : [string] } , Mock ( ) ) [EOL] assert excinfo . value is exception [EOL] assert not handle_request . called [EOL] [EOL] [EOL] def test_get_handler_is_called_for_get_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_get = middleware . graphql_app . handle_get = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_get . assert_called_once_with ( start_response ) [EOL] [EOL] [EOL] def test_post_handler_is_called_for_post_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_post = middleware . graphql_app . handle_post = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_post . assert_called_once_with ( middleware_request , start_response ) [EOL] [EOL] [EOL] class InstanceOfHttpMethodNotAllowedError : [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , HttpMethodNotAllowedError ) [EOL] [EOL] [EOL] def test_http_not_allowed_error_is_thrown_for_delete_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_error = middleware . graphql_app . handle_http_error = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_error . assert_called_once_with ( InstanceOfHttpMethodNotAllowedError ( ) , start_response ) [EOL] [EOL] [EOL] def test_http_not_allowed_error_is_thrown_for_head_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_error = middleware . graphql_app . handle_http_error = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_error . assert_called_once_with ( InstanceOfHttpMethodNotAllowedError ( ) , start_response ) [EOL] [EOL] [EOL] def test_http_not_allowed_error_is_thrown_for_patch_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_error = middleware . graphql_app . handle_http_error = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_error . assert_called_once_with ( InstanceOfHttpMethodNotAllowedError ( ) , start_response ) [EOL] [EOL] [EOL] def test_http_not_allowed_error_is_thrown_for_put_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_error = middleware . graphql_app . handle_http_error = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_error . assert_called_once_with ( InstanceOfHttpMethodNotAllowedError ( ) , start_response ) [EOL] [EOL] [EOL] def test_http_not_allowed_error_is_thrown_for_options_request ( middleware , middleware_request , start_response ) : [EOL] middleware_request [ [string] ] = [string] [EOL] handle_error = middleware . graphql_app . handle_http_error = Mock ( ) [EOL] [EOL] middleware ( middleware_request , start_response ) [EOL] handle_error . assert_called_once_with ( InstanceOfHttpMethodNotAllowedError ( ) , start_response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from snapshottest import Snapshot [EOL] [EOL] [EOL] snapshots = Snapshot ( ) [EOL] [EOL] snapshots [ [string] ] = { [string] : { [string] : True } } [EOL] [EOL] snapshots [ [string] ] = { [string] : { [string] : [string] } } [EOL] [EOL] snapshots [ [string] ] = { [string] : { [string] : [string] } } [EOL] [EOL] snapshots [ [string] ] = { [string] : None , [string] : [ { [string] : [ { [string] : [number] , [string] : [number] } ] , [string] : [string] , [string] : None } ] } [EOL] [EOL] snapshots [ [string] ] = { [string] : [ { [string] : None , [string] : [string] , [string] : None } ] } [EOL] [EOL] snapshots [ [string] ] = { [string] : [ { [string] : None , [string] : [string] , [string] : None } ] } [EOL] [EOL] snapshots [ [string] ] = { [string] : [ { [string] : None , [string] : [string] , [string] : None } ] } [EOL] [EOL] snapshots [ [string] ] = { [string] : None , [string] : [ { [string] : None , [string] : [string] , [string] : None } ] } [EOL] [EOL] snapshots [ [string] ] = { [string] : [ { [string] : None , [string] : [string] , [string] : None } ] } [EOL] [EOL] snapshots [ [string] ] = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from snapshottest import Snapshot [EOL] [EOL] [EOL] snapshots = Snapshot ( ) [EOL] [EOL] snapshots [ [string] ] = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
	0