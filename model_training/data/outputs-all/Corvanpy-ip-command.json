	0
from ip_command import IP [EOL] [EOL] if __name__ == [string] : [EOL] print ( IP . addr . show ( True ) ) [EOL] print ( IP . neigh . show ( True ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable , List [EOL] import typing [EOL] import subprocess [EOL] import ip_command [EOL] import builtins [EOL] from __future__ import annotations [EOL] import subprocess [EOL] from typing import Iterable [EOL] [EOL] from ip_command . subcommands import Addr , Neigh [EOL] [EOL] [EOL] def run ( command ) : [EOL] try : [EOL] subprocess_result = subprocess . run ( [ [string] , [string] ] , capture_output = True ) [EOL] if subprocess_result . returncode == [number] : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] ip_path = subprocess_result . stdout . decode ( ) . strip ( ) [EOL] argv = list ( [ ip_path ] ) [EOL] argv . extend ( command ) [EOL] return subprocess . run ( argv , capture_output = True ) [EOL] except subprocess . SubprocessError as e : [EOL] print ( e ) [EOL] exit ( [number] ) [EOL] [EOL] [EOL] class IP : [EOL] [EOL] addr = Addr ( ) [EOL] neigh = Neigh ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ip_command.subcommands.Addr$ 0 0 0 0 0 $ip_command.subcommands.Neigh$ 0 0 0 0 0
from . ip import * [EOL] from . model import Interface , Link , Neighbour [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from __future__ import annotations [EOL] import ipaddress [EOL] from dataclasses import dataclass , field [EOL] from typing import List , Union [EOL] [EOL] [EOL] @ dataclass class Interface : [EOL] [docstring] [EOL] [EOL] number = ... [EOL] name = ... [EOL] flags = ... [EOL] mtu = ... [EOL] qdisc = ... [EOL] state = ... [EOL] group = ... [EOL] qlen = ... [EOL] link = ... [EOL] addresses = ... [EOL] [EOL] [EOL] @ dataclass class Link : [EOL] [docstring] [EOL] type = ... [EOL] mac_address = ... [EOL] mac_broadcast = ... [EOL] [EOL] [EOL] @ dataclass class Neighbour : [EOL] [docstring] [EOL] address = ... [EOL] status = ... [EOL] device = ... [EOL] mac_address = field ( default = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $Link$ 0 0 0 $typing.List[typing.Union[ipaddress.IPv4Interface,ipaddress.IPv6Interface]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[ipaddress.IPv4Address,ipaddress.IPv6Address]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Pattern , Dict [EOL] import ipaddress [EOL] import typing [EOL] import ip_command [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import dataclasses [EOL] import ipaddress [EOL] import re [EOL] from typing import Dict , List , Pattern , Union [EOL] [EOL] from ip_command . model import Interface , Link [EOL] [EOL] [EOL] class Addr : [EOL] _regexes = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] _all_pattern = re . compile ( str ( ) . join ( _regexes . values ( ) ) ) [EOL] [EOL] @ staticmethod def show ( as_dict = False ) : [EOL] [docstring] [EOL] from ip_command . ip import run [EOL] output = run ( [ [string] , [string] ] ) . stdout . decode ( ) [EOL] [EOL] interfaces = list ( ) [EOL] for find in re . finditer ( Addr . _all_pattern , output ) : [EOL] interfaces . append ( Interface ( number = int ( find . group ( [string] ) ) , name = find . group ( [string] ) , flags = find . group ( [string] ) . split ( [string] ) , mtu = int ( find . group ( [string] ) ) , qdisc = find . group ( [string] ) , state = find . group ( [string] ) , group = find . group ( [string] ) , qlen = find . group ( [string] ) , link = Link ( type = find . group ( [string] ) , mac_address = find . group ( [string] ) , mac_broadcast = find . group ( [string] ) ) , addresses = Addr . _parse_addresses ( find . group ( [string] ) ) ) ) [EOL] if as_dict : [EOL] return { interface . number : dataclasses . asdict ( interface ) for interface in interfaces } [EOL] [EOL] return interfaces [EOL] [EOL] @ staticmethod def _parse_addresses ( address_definitions ) : [EOL] regexes = { [string] : [string] , [string] : [string] [string] } [EOL] [EOL] all_pattern = re . compile ( str ( ) . join ( regexes . values ( ) ) ) [EOL] [EOL] addresses = list ( ) [EOL] for find in re . finditer ( all_pattern , address_definitions ) : [EOL] addresses . append ( ipaddress . ip_interface ( find . group ( [string] ) ) ) [EOL] return addresses [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[ip_command.model.Interface],typing.Dict]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ip_command.model.Interface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[ip_command.model.Interface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ip_command.model.Interface]$ 0 0 0 0 $typing.List[ip_command.model.Interface]$ 0 0 0 0 0 $typing.List[typing.Union[ipaddress.IPv4Interface,ipaddress.IPv6Interface]]$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0
from typing import Any , Union , Type , List , Dict [EOL] import typing [EOL] import ip_command [EOL] import builtins [EOL] from __future__ import annotations [EOL] import dataclasses [EOL] import re [EOL] import ipaddress [EOL] from typing import Dict , List , Union [EOL] [EOL] from ip_command . model import Neighbour [EOL] [EOL] [EOL] class Neigh : [EOL] [EOL] _regexes = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] _all_pattern = re . compile ( str ( ) . join ( _regexes . values ( ) ) ) [EOL] [EOL] @ staticmethod def show ( as_dict = False ) : [EOL] from ip_command . ip import run [EOL] output = run ( [ [string] , [string] ] ) . stdout . decode ( ) [EOL] [EOL] neighbours = list ( ) [EOL] for find in re . finditer ( Neigh . _all_pattern , output ) : [EOL] [EOL] neighbour = Neighbour ( address = ipaddress . ip_address ( find . group ( [string] ) ) , device = find . group ( [string] ) , status = find . group ( [string] ) ) [EOL] if find . group ( [string] ) : [EOL] neighbour . mac_address = find . group ( [string] ) [EOL] [EOL] neighbours . append ( neighbour ) [EOL] [EOL] if as_dict : [EOL] return [ dataclasses . asdict ( neighbour ) for neighbour in neighbours ] [EOL] return neighbours [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Dict],typing.List[ip_command.model.Neighbour]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . addr import Addr [EOL] from . neigh import Neigh [EOL]	0 0 0 0 0 0 0 0 0 0 0 0