from typing import Optional , Match [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] import re [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] def get_version ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] version_regex = [string] [EOL] result = re . search ( version_regex , f . read ( ) , re . MULTILINE ) [EOL] if result : [EOL] return result . group ( [number] ) [EOL] return None [EOL] [EOL] [EOL] setup ( name = [string] , version = get_version ( ) , url = [string] , author = [string] , author_email = [string] , description = [string] , packages = find_packages ( exclude = [ [string] ] ) , include_package_data = True , zip_safe = False , keywords = [ [string] , [string] , [string] ] , classifiers = [ [string] , [string] , [string] , [string] , [string] ] , install_requires = [ [string] , [string] , [string] , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] from datetime import datetime [EOL] [EOL] from relayer import utils [EOL] [EOL] from . import BaseTestCase [EOL] [EOL] [EOL] class TestUtils ( BaseTestCase ) : [EOL] def test_elapsed_time_in_milliseconds ( self ) : [EOL] start_time = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] end_time = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] milliseconds = utils . get_elapsed_time_in_milliseconds ( start_time , end_time ) [EOL] assert milliseconds == [number] [EOL] end_time = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] milliseconds = utils . get_elapsed_time_in_milliseconds ( start_time , end_time ) [EOL] assert milliseconds == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import relayer [EOL] from relayer import Relayer [EOL] from relayer . exceptions import ConfigurationError [EOL] [EOL] from . import BaseTestCase [EOL] [EOL] [EOL] class TestRelayer ( BaseTestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . relayer = Relayer ( [string] , kafka_hosts = [string] ) [EOL] [EOL] def test_requires_kafka_hosts ( self ) : [EOL] self . assertRaises ( ConfigurationError , Relayer , [string] ) [EOL] [EOL] def test_emit ( self ) : [EOL] self . relayer . emit ( [string] , [string] , [string] ) [EOL] [EOL] def test_emit_with_partition_key ( self ) : [EOL] self . relayer . emit ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def test_source_not_present ( self ) : [EOL] relayer = Relayer ( [string] , kafka_hosts = [string] , topic_prefix = [string] , topic_suffix = [string] ) [EOL] assert relayer . source == [string] [EOL] [EOL] def test_source ( self ) : [EOL] relayer = Relayer ( [string] , kafka_hosts = [string] , source = [string] ) [EOL] assert relayer . source == [string] [EOL] [EOL] def test_emit_raw ( self ) : [EOL] self . relayer . emit_raw ( [string] , { [string] : [string] } , [string] ) [EOL] [EOL] def test_flush ( self ) : [EOL] self . relayer . flush ( ) [EOL] assert self . relayer . _producer . flushed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import relayer [EOL] from typing import List , Any [EOL] import sure [comment] [EOL] from unittest import TestCase [EOL] [EOL] from relayer . test import RelayerPatch [EOL] [EOL] [EOL] class BaseTestCase ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . relayer_patch = RelayerPatch ( ) [EOL] self . relayer_patch . start ( ) [EOL] self . producer = self . relayer_patch . mocked_producer [EOL] [EOL] def tearDown ( self ) : [EOL] if hasattr ( self , [string] ) : [EOL] self . relayer_patch . stop ( ) [EOL] [EOL] def _get_topic_messages ( self , topic ) : [EOL] return self . producer . produced_messages [ topic ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $relayer.test.relayer_patch.RelayerPatch$ 0 0 0 0 0 0 0 $relayer.test.relayer_patch.RelayerPatch$ 0 0 0 0 0 0 0 0 0 0 0 $relayer.test.relayer_patch.RelayerPatch$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import relayer [EOL] import json [EOL] [EOL] import flask [EOL] [EOL] from relayer . flask import FlaskRelayer [EOL] [EOL] from . import BaseTestCase [EOL] [EOL] TEST_KEY = [string] [EOL] TEST_VAL = [string] [EOL] [EOL] [EOL] class FlaskRelayerTestCase ( BaseTestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] app = flask . Flask ( __name__ ) [EOL] self . app = app [EOL] self . client = self . app . test_client ( ) [EOL] self . relayer = FlaskRelayer ( app , [string] , [string] , topic_prefix = [string] , topic_suffix = [string] ) [EOL] [EOL] @ app . route ( [string] ) def test_emit ( ) : [EOL] self . relayer . emit ( [string] , [string] , [string] ) [EOL] self . relayer . log ( [string] , [string] ) [EOL] return [string] [EOL] [EOL] @ app . route ( [string] ) def test_emit_raw ( ) : [EOL] self . relayer . emit_raw ( [string] , { TEST_KEY : TEST_VAL } ) [EOL] return [string] [EOL] [EOL] @ app . route ( [string] ) def test_log_and_flush ( ) : [EOL] self . relayer . log ( [string] , [string] ) [EOL] self . relayer . flush ( ) [EOL] return [string] [EOL] [EOL] def test_request_works_fine ( self ) : [EOL] assert self . client . get ( [string] ) . status_code == [number] [EOL] [EOL] def test_emitted_messages ( self ) : [EOL] self . client . get ( [string] ) [EOL] messages = self . _get_topic_messages ( [string] ) [EOL] assert len ( messages ) == [number] [EOL] message = json . loads ( messages [ [number] ] [ [number] ] . decode ( [string] ) ) [EOL] [EOL] assert [string] in message [EOL] assert message [ [string] ] == [string] [EOL] assert [string] in message [EOL] assert message [ [string] ] == [string] [EOL] assert [string] in message [EOL] assert message [ [string] ] == [string] [EOL] [EOL] def test_emitted_raw_messages ( self ) : [EOL] self . client . get ( [string] ) [EOL] messages = self . _get_topic_messages ( [string] ) [EOL] assert len ( messages ) == [number] [EOL] message = json . loads ( messages [ [number] ] [ [number] ] . decode ( [string] ) ) [EOL] assert TEST_KEY in message [EOL] assert message [ TEST_KEY ] == TEST_VAL [EOL] [EOL] def test_flush ( self ) : [EOL] self . client . get ( [string] ) [EOL] assert self . producer . flushed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $relayer.flask.FlaskRelayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import uuid [EOL] import relayer [EOL] from uuid import uuid4 [EOL] from datetime import datetime [EOL] import json [EOL] [EOL] from relayer import EventEmitter [EOL] from relayer . test import MockedProducer [EOL] from relayer . exceptions import NonJSONSerializableMessageError , UnsupportedPartitionKeyTypeError [EOL] [EOL] from . import BaseTestCase [EOL] [EOL] [EOL] class TestEventEmitter ( BaseTestCase ) : [EOL] def setUp ( self ) : [EOL] self . producer = MockedProducer ( ) [EOL] self . emitter = EventEmitter ( self . producer ) [EOL] [EOL] def test_sending_message ( self ) : [EOL] self . emitter . emit ( [string] , { [string] : [string] } ) [EOL] messages = self . _get_topic_messages ( [string] ) [EOL] assert len ( messages ) == [number] [EOL] message = json . loads ( messages [ [number] ] [ [number] ] . decode ( [string] ) ) [EOL] assert [string] in message [EOL] assert message [ [string] ] == [string] [EOL] [EOL] def test_throws_if_not_sending_json_serializable ( self ) : [EOL] self . assertRaises ( NonJSONSerializableMessageError , self . emitter . emit , [string] , datetime . utcnow ( ) ) [EOL] [EOL] def test_incorrect_partition_key ( self ) : [EOL] self . assertRaises ( UnsupportedPartitionKeyTypeError , self . emitter . emit , [string] , [string] , datetime . utcnow ( ) ) [EOL] [comment] [EOL] [EOL] def test_string_partition_key ( self ) : [EOL] self . emitter . emit ( [string] , { [string] : [string] } , partition_key = [string] ) [EOL] messages = self . _get_topic_messages ( [string] ) [EOL] assert len ( messages ) == [number] [EOL] assert [string] in messages [ [number] ] [ [number] ] [EOL] [EOL] def test_uuid_partition_key ( self ) : [EOL] key = uuid4 ( ) [EOL] self . emitter . emit ( [string] , { [string] : [string] } , partition_key = key ) [EOL] messages = self . _get_topic_messages ( [string] ) [EOL] assert len ( messages ) == [number] [EOL] assert key . bytes in messages [ [number] ] [ [number] ] [EOL] [EOL] def test_flush ( self ) : [EOL] self . emitter . flush ( ) [EOL] assert self . producer . flushed [EOL] [EOL] def test_message_prefix ( self ) : [EOL] self . emitter = EventEmitter ( self . producer , topic_prefix = [string] ) [EOL] self . emitter . emit ( [string] , { [string] : [string] } ) [EOL] assert len ( self . _get_topic_messages ( [string] ) ) == [number] [EOL] [EOL] def test_message_suffix ( self ) : [EOL] self . emitter = EventEmitter ( self . producer , topic_suffix = [string] ) [EOL] self . emitter . emit ( [string] , { [string] : [string] } ) [EOL] assert len ( self . _get_topic_messages ( [string] ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $relayer.test.mocked_producer.MockedProducer$ 0 0 0 0 0 0 0 $relayer.event_emitter.EventEmitter$ 0 0 0 0 0 $relayer.test.mocked_producer.MockedProducer$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $relayer.event_emitter.EventEmitter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $relayer.event_emitter.EventEmitter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $relayer.event_emitter.EventEmitter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $relayer.event_emitter.EventEmitter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import relayer [EOL] import json [EOL] [EOL] from relayer import Relayer [EOL] from relayer . rpc import make_rpc_relayer [EOL] [EOL] from . import BaseTestCase [EOL] [EOL] [EOL] class TestRPCRelayer ( BaseTestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . relayer_decorator = make_rpc_relayer ( [string] , kafka_hosts = [string] , topic_prefix = [string] , topic_suffix = [string] ) [EOL] self . logger = None [EOL] [EOL] def third_party_method ( ) : [EOL] if self . logger : [EOL] self . logger . log ( [string] , [string] ) [EOL] [EOL] @ self . relayer_decorator def rpc_method ( value , relayer ) : [EOL] relayer . emit ( [string] , [string] , [string] ) [EOL] relayer . log ( [string] , [string] ) [EOL] return value [EOL] [EOL] @ self . relayer_decorator def rpc_payload_method ( value , relayer ) : [EOL] relayer . emit ( [string] , [string] , [string] ) [EOL] relayer . log ( [string] , { [string] : [string] } ) [EOL] return value [EOL] [EOL] @ self . relayer_decorator def method_with_third_party ( relayer = None ) : [EOL] third_party_method ( ) [EOL] [EOL] self . rpc_method = rpc_method [EOL] self . rpc_payload_method = rpc_payload_method [EOL] self . method_with_third_party = method_with_third_party [EOL] [EOL] def test_input_and_output_works ( self ) : [EOL] assert self . rpc_payload_method ( True ) [EOL] assert not self . rpc_payload_method ( False ) [EOL] [EOL] def test_input_and_output_with_payload_works ( self ) : [EOL] assert self . rpc_method ( True ) [EOL] assert not self . rpc_method ( False ) [EOL] [EOL] def test_emitted_messages ( self ) : [EOL] self . rpc_method ( True ) [EOL] messages = self . _get_topic_messages ( [string] ) [EOL] assert len ( messages ) == [number] [EOL] message = json . loads ( messages [ [number] ] [ [number] ] . decode ( [string] ) ) [EOL] [EOL] assert [string] in message [EOL] assert [string] in message [EOL] assert [string] in message [EOL] assert message [ [string] ] == [string] [EOL] assert message [ [string] ] == [string] [EOL] assert message [ [string] ] == [string] [EOL] [EOL] def test_decorator_expose_instance ( self ) : [EOL] assert hasattr ( self . relayer_decorator , [string] ) [EOL] assert isinstance ( self . relayer_decorator . instance , Relayer ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $relayer.Relayer$ 0 0 0 $relayer.Relayer$ 0 0 0 0 0 0 0 0 0 0 $relayer.Relayer$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $relayer.Relayer$ 0 0 0 $relayer.Relayer$ 0 0 0 0 0 0 0 0 0 0 $relayer.Relayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $None$ 0 $relayer.Relayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import structlog [EOL] [EOL] [EOL] logger = structlog . get_logger ( [string] ) [EOL] [EOL] [EOL] def log_deprecation_notice ( source = None ) : [EOL] logger . warn ( [string] , source = source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import kafka [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Dict [EOL] from datetime import datetime [EOL] from uuid import UUID [EOL] import json [EOL] [EOL] from kafka import KafkaProducer [EOL] [EOL] from . exceptions import NonJSONSerializableMessageError , UnsupportedPartitionKeyTypeError [EOL] from . logger import log_kafka_message [EOL] [EOL] [EOL] class EventEmitter ( object ) : [EOL] [EOL] def __init__ ( self , producer , topic_prefix = [string] , topic_suffix = [string] ) : [EOL] self . producer = producer [EOL] self . topic_prefix = topic_prefix [EOL] self . topic_suffix = topic_suffix [EOL] [EOL] def emit ( self , topic , message , partition_key = None ) : [EOL] [EOL] topic = [string] . format ( self . topic_prefix , topic , self . topic_suffix ) [EOL] [EOL] log_kafka_message ( topic , message , partition_key = partition_key ) [EOL] [EOL] if isinstance ( partition_key , str ) : [EOL] partition_key = partition_key . encode ( [string] ) [EOL] elif isinstance ( partition_key , UUID ) : [EOL] partition_key = partition_key . bytes [EOL] elif partition_key is not None : [EOL] raise UnsupportedPartitionKeyTypeError ( partition_key . __class__ ) [EOL] [EOL] try : [EOL] message . update ( { [string] : [string] . format ( datetime . utcnow ( ) . isoformat ( ) ) } ) [EOL] msg = json . dumps ( message ) . encode ( [string] ) [EOL] except ( TypeError , AttributeError ) as error : [EOL] raise NonJSONSerializableMessageError ( str ( error ) ) [EOL] [EOL] self . producer . send ( topic , key = partition_key , value = msg ) [EOL] [EOL] def flush ( self ) : [EOL] self . producer . flush ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] from uuid import UUID [EOL] [EOL] [EOL] class RelayerError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class NonJSONSerializableMessageError ( RelayerError ) : [EOL] pass [EOL] [EOL] [EOL] class ConfigurationError ( RelayerError ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [EOL] class UnsupportedPartitionKeyTypeError ( RelayerError ) : [EOL] def __init__ ( self , provided_type ) : [EOL] super ( ) . __init__ ( [string] . format ( provided_type . __name__ , str . __name__ , UUID . __name__ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Any , Union [EOL] from . logging import logger [EOL] [EOL] [EOL] def log_kafka_message ( topic , payload , partition_key = None ) : [EOL] if not isinstance ( payload , dict ) : [EOL] payload = { [string] : payload } [EOL] logger . debug ( [string] , topic = topic , partition_key = partition_key , ** payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import builtins [EOL] from datetime import datetime [EOL] [EOL] [EOL] def get_elapsed_time_in_milliseconds ( start_time , end_time ) : [EOL] elapsed_time = end_time - start_time [EOL] return elapsed_time . microseconds / [number] + elapsed_time . seconds * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . relayer_patch import RelayerPatch [EOL] from . mocked_producer import MockedProducer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Any , List , Tuple [EOL] from collections import defaultdict [EOL] [EOL] [EOL] class MockedProducer ( object ) : [EOL] def __init__ ( self ) : [EOL] self . produced_messages = defaultdict ( list ) [EOL] self . flushed = False [EOL] [EOL] def send ( self , topic , value = None , key = None ) : [EOL] self . produced_messages [ topic ] . append ( ( value , key ) ) [EOL] [EOL] def flush ( self ) : [EOL] self . flushed = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Tuple[typing.Any,...]]]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import mock [EOL] [EOL] from . mocked_producer import MockedProducer [EOL] [EOL] [EOL] class RelayerPatch ( object ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . patcher = mock . patch ( [string] ) [EOL] [EOL] def start ( self ) : [EOL] kafka_producer_mock = self . patcher . start ( ) [EOL] self . mocked_producer = MockedProducer ( ) [EOL] kafka_producer_mock . return_value = self . mocked_producer [EOL] [EOL] def stop ( self ) : [EOL] self . patcher . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Any [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import relayer [EOL] from typing import Any , Callable [EOL] [EOL] from datetime import datetime [EOL] [EOL] from relayer import Relayer , utils [EOL] from relayer . logging import logger [EOL] [EOL] [EOL] def make_rpc_relayer ( logging_topic , kafka_hosts = [string] , ** kwargs ) : [EOL] [EOL] event_relayer = Relayer ( logging_topic , kafka_hosts = kafka_hosts , ** kwargs , ) [EOL] [EOL] def decorator ( function ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] start_time = datetime . utcnow ( ) [EOL] kwargs [ [string] ] = event_relayer [EOL] service_response = function ( * args , ** kwargs ) [EOL] request_log = { [string] : event_relayer . source , [string] : logging_topic , [string] : start_time . isoformat ( ) , [string] : function . __qualname__ , [string] : utils . get_elapsed_time_in_milliseconds ( start_time , datetime . utcnow ( ) ) } [EOL] logger . info ( [string] , ** request_log ) [EOL] return service_response [EOL] return wrapper [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] decorator . instance = event_relayer [comment] [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0