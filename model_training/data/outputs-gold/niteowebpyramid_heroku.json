from typing import Dict , Optional , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from ast import literal_eval [EOL] from expandvars import expandvars [EOL] [EOL] import sys [EOL] import typing as t [EOL] [EOL] [EOL] def safe_eval ( text ) : [EOL] [docstring] [EOL] if not isinstance ( text , str ) : [EOL] raise ValueError ( f" [string] { type ( text ) } [string] " ) [EOL] [EOL] if len ( text ) == [number] : [EOL] return text [EOL] [EOL] try : [EOL] return literal_eval ( text [ [number] ] . upper ( ) + text [ [number] : ] ) [EOL] except ( ValueError , SyntaxError ) : [EOL] return text [EOL] [EOL] [EOL] def expandvars_dict ( settings ) : [EOL] [docstring] [EOL] return { k : safe_eval ( expandvars ( expandvars ( v ) ) ) for k , v in settings . items ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def includeme ( config ) : [EOL] config . add_tween ( [string] ) [EOL] [EOL] [EOL] class ClientAddr ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , handler , registry ) : [EOL] self . handler = handler [EOL] self . registry = registry [EOL] [EOL] def __call__ ( self , request ) : [EOL] if request . headers . get ( [string] ) : [EOL] request . headers [ [string] ] = ( request . headers [ [string] ] . split ( [string] ) [ - [number] ] . strip ( ) ) [EOL] return self . handler ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] from pyramid . response import Response [EOL] [EOL] import logging [EOL] [EOL] [EOL] def includeme ( config ) : [EOL] config . add_tween ( [string] ) [EOL] [EOL] [EOL] class HerokuappAccess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , handler , registry ) : [EOL] self . handler = handler [EOL] self . registry = registry [EOL] self . settings = getattr ( registry , [string] , { } ) [EOL] [EOL] def __call__ ( self , request ) : [EOL] whitelisted_ips = request . registry . settings . get ( [string] ) [EOL] if not whitelisted_ips : [EOL] return self . handler ( request ) [EOL] [EOL] if ( [string] in request . headers [ [string] ] [EOL] and request . client_addr not in whitelisted_ips ) : [EOL] if request . registry . settings . get ( [string] ) : [EOL] import structlog [EOL] [EOL] logger = structlog . getLogger ( __name__ ) [EOL] logger . info ( [string] , user_ip = request . client_addr , host = request . headers [ [string] ] , ) [EOL] else : [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . info ( f' [string] { request . headers [ [string] ] }' f" [string] { request . client_addr }" ) [EOL] [EOL] resp = Response ( [string] , status = [number] , content_type = [string] ) [EOL] resp . status = [string] [EOL] return resp [EOL] [EOL] return self . handler ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Optional , Any [EOL] import typing [EOL] import builtins [EOL] import subprocess [EOL] import requests [EOL] import argparse [EOL] [docstring] [EOL] [EOL] from requests import Response [EOL] from requests import Session [EOL] from time import sleep [EOL] from typing import Optional [EOL] [EOL] import argparse [EOL] import os [EOL] import shlex [EOL] import subprocess [EOL] import sys [EOL] [EOL] [EOL] class Heroku ( object ) : [EOL] [EOL] api_endpoint = [string] [EOL] [EOL] def __init__ ( self , app_name , ini_file ) : [EOL] [docstring] [EOL] self . _formation = None [EOL] self . app_name = app_name [EOL] self . ini_file = ini_file [EOL] [EOL] headers = { [string] : f" [string] { self . auth_key }" , [string] : [string] , [string] : [string] , } [EOL] self . session = Session ( ) [EOL] self . session . headers . update ( headers ) [EOL] [EOL] @ property def auth_key ( self ) : [EOL] [docstring] [EOL] return os . environ . get ( [string] ) [EOL] [EOL] def scale_down ( self ) : [EOL] [docstring] [EOL] updates = [ dict ( type = t , quantity = [number] ) for t in self . formation . keys ( ) ] [EOL] res = self . session . patch ( f"{ self . api_endpoint } [string] { self . app_name } [string] " , json = dict ( updates = updates ) , ) [EOL] self . parse_response ( res ) [EOL] print ( [string] ) [EOL] for x in res . json ( ) : [EOL] print ( f'{ x [ [string] ] } [string] { x [ [string] ] }' ) [EOL] [EOL] def scale_up ( self ) : [EOL] [docstring] [EOL] updates = [ dict ( type = t , quantity = s ) for t , s in self . formation . items ( ) ] [EOL] res = self . session . patch ( f"{ self . api_endpoint } [string] { self . app_name } [string] " , json = dict ( updates = updates ) , ) [EOL] self . parse_response ( res ) [EOL] print ( [string] ) [EOL] for x in res . json ( ) : [EOL] print ( f'{ x [ [string] ] } [string] { x [ [string] ] }' ) [EOL] [EOL] @ property def formation ( self ) : [EOL] [docstring] [EOL] if not self . _formation : [EOL] res = self . session . get ( f"{ self . api_endpoint } [string] { self . app_name } [string] " ) [EOL] self . parse_response ( res ) [EOL] self . _formation = { x [ [string] ] : x [ [string] ] for x in res . json ( ) } [EOL] return self . _formation [EOL] [EOL] def shell ( self , cmd ) : [EOL] [docstring] [EOL] [EOL] p = subprocess . run ( shlex . split ( cmd ) , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] print ( p . stdout . decode ( ) ) [EOL] print ( p . stderr . decode ( ) , file = sys . stderr ) [EOL] p . check_returncode ( ) [EOL] return p . stdout . decode ( ) [EOL] [EOL] def needs_migrate ( self ) : [EOL] [docstring] [EOL] cmd = self . shell ( f" [string] { self . ini_file } [string] " ) [EOL] return [string] not in cmd [EOL] [EOL] def alembic ( self ) : [EOL] [docstring] [EOL] self . shell ( f" [string] { self . ini_file } [string] " ) [EOL] [EOL] def set_maintenance ( self , state ) : [EOL] res = self . session . patch ( f"{ self . api_endpoint } [string] { self . app_name }" , json = dict ( maintenance = state ) ) [EOL] if self . parse_response ( res ) : [EOL] print ( [string] . format ( [string] if state else [string] ) ) [EOL] [EOL] def parse_response ( self , res ) : [EOL] [docstring] [EOL] if res . status_code != [number] : [EOL] print ( res . json ( ) ) [EOL] res . raise_for_status ( ) [EOL] return True [EOL] [EOL] def migrate ( self ) : [EOL] [docstring] [EOL] print ( self . app_name ) [EOL] print ( self . ini_file ) [EOL] [EOL] if self . needs_migrate ( ) : [EOL] self . set_maintenance ( True ) [EOL] self . scale_down ( ) [EOL] sleep ( [number] ) [EOL] self . alembic ( ) [EOL] self . scale_up ( ) [EOL] sleep ( [number] ) [EOL] self . set_maintenance ( False ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter , usage = ( [string] [string] ) , ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , default = [string] , help = [string] , ) [EOL] [EOL] options = parser . parse_args ( ) [EOL] [EOL] Heroku ( options . app_name , options . ini_file ) . migrate ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $requests.Response$ 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import mock [EOL] import pyramid_heroku [EOL] import typing [EOL] [docstring] [EOL] [EOL] from mock import call [EOL] [EOL] import mock [EOL] import pytest [EOL] import responses [EOL] import unittest [EOL] [EOL] [EOL] class TestHerokuMigrate ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] from pyramid_heroku . migrate import Heroku [EOL] [EOL] self . Heroku = Heroku [EOL] [EOL] def test_default_values ( self ) : [EOL] from pyramid_heroku . migrate import main [EOL] [EOL] def assert_args ( args , called_with ) : [EOL] with mock . patch ( [string] , [ [string] ] + args ) , mock . patch ( [string] ) as heroku : [EOL] main ( ) [EOL] heroku . assert_called_with ( * called_with ) [EOL] [EOL] [comment] [EOL] assert_args ( [ [string] ] , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] assert_args ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_default_formation ( self , out ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] h . _formation = { [string] : [string] , [string] : [number] } [EOL] responses . add ( responses . PATCH , [string] , status = [number] , json = [ { [string] : [string] , [string] : [number] } ] , ) [EOL] h . scale_up ( ) [EOL] out . assert_has_calls ( [ call ( [string] ) , call ( [string] ) ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_scale_down ( self , out ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] responses . add ( responses . GET , [string] , status = [number] , json = [ { [string] : [string] , [string] : [number] } ] , ) [EOL] responses . add ( responses . PATCH , [string] , status = [number] , json = [ { [string] : [string] , [string] : [number] } ] , ) [EOL] h . scale_down ( ) [EOL] out . assert_has_calls ( [ call ( [string] ) , call ( [string] ) ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_scale_up ( self , out ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] responses . add ( responses . GET , [string] , status = [number] , json = [ { [string] : [string] , [string] : [number] } ] , ) [EOL] responses . add ( responses . PATCH , [string] , status = [number] , json = [ { [string] : [string] , [string] : [number] } ] , ) [EOL] h . scale_up ( ) [EOL] out . assert_has_calls ( [ call ( [string] ) , call ( [string] ) ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_maintenance_on ( self , out ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] responses . add ( responses . PATCH , [string] , status = [number] ) [EOL] h . set_maintenance ( True ) [EOL] out . assert_has_calls ( [ call ( [string] ) ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_maintenance_off ( self , out ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] responses . add ( responses . PATCH , [string] , status = [number] ) [EOL] h . set_maintenance ( False ) [EOL] out . assert_has_calls ( [ call ( [string] ) ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , return_value = False ) def test_set_maintanence_fail ( self , pr , out ) : [EOL] [docstring] [EOL] h = self . Heroku ( [string] , [string] ) [EOL] h . set_maintenance ( True ) [EOL] out . assert_not_called ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_needs_migrate ( self , sub ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] sub . run . stdout . return_value = [string] [EOL] self . assertTrue ( h . needs_migrate ( ) ) [EOL] sub . run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = mock . ANY , stderr = mock . ANY , ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_does_not_need_migrate ( self , sub ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] p = mock . Mock ( ) [EOL] p . stdout = [string] [EOL] sub . run . return_value = p [EOL] self . assertFalse ( h . needs_migrate ( ) ) [EOL] sub . run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = mock . ANY , stderr = mock . ANY , ) [EOL] [EOL] @ mock . patch ( [string] ) @ responses . activate def test_alembic ( self , sub ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] p = mock . Mock ( ) [EOL] p . stdout = [string] [EOL] sub . run . return_value = p [EOL] h . alembic ( ) [EOL] [comment] [EOL] sub . run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = mock . ANY , stderr = mock . ANY , ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ responses . activate def test_migrate_skip ( self , sleep , out , sub ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] p = mock . Mock ( ) [EOL] p . stdout = [string] [EOL] sub . run . return_value = p [EOL] h . migrate ( ) [EOL] sub . run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = mock . ANY , stderr = mock . ANY , ) [EOL] out . assert_has_calls ( [ call ( [string] ) , call ( [string] ) ] , any_order = True ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ responses . activate def test_migrate ( self , ses , sleep , out , sub ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] h . migrate ( ) [EOL] sub . run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , stdout = mock . ANY , stderr = mock . ANY , ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ responses . activate def test_migrate_non_zero ( self , ses , sleep , out , sub ) : [EOL] h = self . Heroku ( [string] , [string] ) [EOL] p = mock . Mock ( ) [EOL] p . stdout = [string] [EOL] p . stderr = [string] [EOL] p . check_returncode . side_effect = Exception [EOL] sub . run . return_value = p [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] h . migrate ( ) [EOL] [EOL] out . assert_has_calls ( [ call ( [string] ) , call ( [string] , file = mock . ANY ) ] , any_order = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[pyramid_heroku.migrate.Heroku]$ 0 0 0 0 $typing.Type[pyramid_heroku.migrate.Heroku]$ 0 $typing.Type[pyramid_heroku.migrate.Heroku]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 $mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 $mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 $mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 $mock.Mock$ 0 $typing.Any$ 0 0 0 $mock.Mock$ 0 $typing.Any$ 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $pyramid_heroku.migrate.Heroku$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def test_safe_eval ( ) : [EOL] [docstring] [EOL] from pyramid_heroku import safe_eval [EOL] [EOL] assert safe_eval ( [string] ) is False [EOL] assert safe_eval ( [string] ) is True [EOL] assert safe_eval ( [string] ) is False [EOL] assert safe_eval ( [string] ) is True [EOL] assert safe_eval ( [string] ) == [number] [EOL] assert safe_eval ( [string] ) == [number] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert ( safe_eval ( [string] ) == [string] ) [EOL] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert safe_eval ( [string] ) is None [EOL] assert safe_eval ( [string] ) == ( [string] , [string] ) [EOL] assert safe_eval ( [string] ) == ( ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] assert safe_eval ( [string] ) == [string] [EOL] assert safe_eval ( [string] ) == [ ] [EOL] with pytest . raises ( ValueError ) : [EOL] assert safe_eval ( None ) == [ ] [EOL] with pytest . raises ( ValueError ) : [EOL] assert safe_eval ( [ [number] , [number] , [number] ] ) == [ ] [EOL] [EOL] [EOL] def test_expandvars_dict ( ) : [EOL] [docstring] [EOL] from pyramid_heroku import expandvars_dict [EOL] import os [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] os . environ [ [string] ] = [string] [EOL] os . environ [ [string] ] = [string] [EOL] settings = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] expanded_settings = { [string] : True , [string] : [number] , [string] : [string] , [string] : None , [string] : ( [string] , [string] ) , [string] : ( ( [string] , [string] ) , ( [string] , [string] ) ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert expanded_settings == expandvars_dict ( settings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import mock [EOL] [docstring] [EOL] [EOL] from pyramid import testing [EOL] from zope . testing . loggingsupport import InstalledHandler [EOL] [EOL] import logging [EOL] import mock [EOL] import structlog [EOL] import unittest [EOL] [EOL] tweens_handler = InstalledHandler ( [string] ) [EOL] [EOL] [EOL] class TestHerokuappAccessTween ( unittest . TestCase ) : [EOL] def wrap_logger ( self , _ , __ , event_dict ) : [EOL] [docstring] [EOL] wrapped_logger = logging . getLogger ( [string] ) [EOL] wrapped_logger . info ( event_dict [ [string] ] ) [EOL] return event_dict [ [string] ] [EOL] [EOL] def setUp ( self ) : [EOL] tweens_handler . clear ( ) [EOL] self . config = testing . setUp ( ) [EOL] self . handler = mock . Mock ( ) [EOL] self . request = testing . DummyRequest ( ) [EOL] self . request . registry . settings = { [string] : [ [string] ] , [string] : [number] , } [EOL] structlog . configure ( processors = [ self . wrap_logger ] , context_class = dict ) [EOL] [EOL] def tearDown ( self ) : [EOL] tweens_handler . clear ( ) [EOL] testing . tearDown ( ) [EOL] [EOL] def test_whitelisted_ip ( self ) : [EOL] from pyramid_heroku . herokuapp_access import HerokuappAccess [EOL] [EOL] self . request . client_addr = [string] [EOL] self . request . headers = { [string] : [string] } [EOL] [EOL] HerokuappAccess ( self . handler , self . request . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL] [EOL] def test_non_whitelisted_ip ( self ) : [EOL] from pyramid_heroku . herokuapp_access import HerokuappAccess [EOL] [EOL] self . request . client_addr = [string] [EOL] self . request . headers = { [string] : [string] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] response = HerokuappAccess ( self . handler , self . request . registry ) ( self . request ) [EOL] assert not self . handler . called , [string] [EOL] self . assertEqual ( len ( tweens_handler . records ) , [number] ) [EOL] self . assertEqual ( [string] , tweens_handler . records [ [number] ] . msg ) [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] [EOL] [comment] [EOL] self . request . registry . settings [ [string] ] = False [EOL] tweens_handler . clear ( ) [EOL] response = HerokuappAccess ( self . handler , self . request . registry ) ( self . request ) [EOL] assert not self . handler . called , [string] [EOL] self . assertEqual ( len ( tweens_handler . records ) , [number] ) [EOL] self . assertEqual ( [string] , tweens_handler . records [ [number] ] . msg , ) [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] [EOL] def test_other_hostname ( self ) : [EOL] from pyramid_heroku . herokuapp_access import HerokuappAccess [EOL] [EOL] self . request . client_addr = [string] [EOL] self . request . headers = { [string] : [string] } [EOL] [EOL] HerokuappAccess ( self . handler , self . request . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL] [EOL] def test_herokuapp_whitelist_not_set ( self ) : [EOL] from pyramid_heroku . herokuapp_access import HerokuappAccess [EOL] [EOL] self . request . client_addr = [string] [EOL] self . request . headers = { [string] : [string] } [EOL] self . request . registry . settings = { } [EOL] [EOL] HerokuappAccess ( self . handler , self . request . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL] [EOL] def test_herokuapp_whitelist_empty ( self ) : [EOL] from pyramid_heroku . herokuapp_access import HerokuappAccess [EOL] [EOL] self . request . client_addr = [string] [EOL] self . request . headers = { [string] : [string] } [EOL] self . request . registry . settings = { [string] : [ ] } [EOL] [EOL] HerokuappAccess ( self . handler , self . request . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import mock [EOL] [docstring] [EOL] [EOL] from pyramid import request [EOL] from pyramid import testing [EOL] [EOL] import mock [EOL] import unittest [EOL] [EOL] [EOL] class TestClientAddrTween ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . config = testing . setUp ( ) [EOL] self . request = request . Request ( { } ) [EOL] [EOL] self . handler = mock . Mock ( ) [EOL] self . registry = None [EOL] [EOL] def tearDown ( self ) : [EOL] testing . tearDown ( ) [EOL] [EOL] def test_direct_access ( self ) : [EOL] from pyramid_heroku . client_addr import ClientAddr [EOL] [EOL] self . request . environ [ [string] ] = [string] [EOL] ClientAddr ( self . handler , self . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL] self . assertEqual ( self . request . client_addr , [string] ) [EOL] [EOL] def test_proxy_access ( self ) : [EOL] from pyramid_heroku . client_addr import ClientAddr [EOL] [EOL] self . request . environ [ [string] ] = [string] [comment] [EOL] self . request . headers [ [string] ] = [string] [EOL] [EOL] ClientAddr ( self . handler , self . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL] self . assertEqual ( self . request . client_addr , [string] ) [EOL] [EOL] def test_spaces ( self ) : [EOL] from pyramid_heroku . client_addr import ClientAddr [EOL] [EOL] self . request . environ [ [string] ] = [string] [comment] [EOL] self . request . headers [ [string] ] = [string] [EOL] [EOL] ClientAddr ( self . handler , self . registry ) ( self . request ) [EOL] self . handler . assert_called_with ( self . request ) [EOL] self . assertEqual ( self . request . client_addr , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0