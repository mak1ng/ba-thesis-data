[EOL] from typing import Any [EOL] import typing [EOL] def Figura ( x1 , y1 , x2 = None , y2 = None ) : [EOL] return [ x1 , y1 , x2 , y2 ] [EOL] [EOL] [EOL] def narysuj ( f ) : [EOL] [comment] [EOL] if ( f [ [number] ] , f [ [number] ] ) == ( None , None ) : [EOL] print ( f [ : [number] ] ) [EOL] [EOL] [comment] [EOL] elif f [ [number] ] is None : [EOL] print ( f [ : [number] ] ) [EOL] [EOL] [comment] [EOL] else : [EOL] print ( f ) [EOL] [EOL] [EOL] def przesun ( f , x , y ) : [EOL] [comment] [EOL] if f [ [number] ] == None : [EOL] f [ [number] ] += x [EOL] f [ [number] ] += y [EOL] [EOL] [comment] [EOL] else : [EOL] f [ [number] ] += x [EOL] f [ [number] ] += x [EOL] f [ [number] ] += y [EOL] f [ [number] ] += y [EOL] [EOL] [EOL] def zawiera ( f , x , y ) : [EOL] [comment] [EOL] if ( f [ [number] ] , f [ [number] ] ) == ( None , None ) : [EOL] return ( x , y ) == ( f [ [number] ] , f [ [number] ] ) [EOL] [EOL] [comment] [EOL] elif f [ [number] ] is None : [EOL] return ( abs ( x - f [ [number] ] ) <= f [ [number] ] and abs ( y - f [ [number] ] ) <= f [ [number] ] ) [EOL] [EOL] [comment] [EOL] else : [EOL] return ( x >= f [ [number] ] and y >= f [ [number] ] and x <= f [ [number] ] and y <= f [ [number] ] ) [EOL] [EOL] [EOL] def Point ( x , y ) : [EOL] return Figura ( x , y ) [EOL] [EOL] [EOL] def Circle ( x , y , r ) : [EOL] return Figura ( x , y , r ) [EOL] [EOL] [EOL] def Square ( x1 , y1 , x2 , y2 ) : [EOL] return Figura ( x1 , y1 , x2 , y2 ) [EOL] [EOL] [EOL] def test_przesun ( ) : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] f = Figura ( [number] , [number] , [number] , [number] ) [EOL] narysuj ( f ) [EOL] przesun ( f , [number] , [number] ) [EOL] narysuj ( f ) [EOL] [EOL] print ( [string] ) [EOL] f = Figura ( [number] , [number] , [number] ) [EOL] narysuj ( f ) [EOL] przesun ( f , [number] , [number] ) [EOL] narysuj ( f ) [EOL] [EOL] print ( [string] ) [EOL] f = Figura ( [number] , [number] ) [EOL] narysuj ( f ) [EOL] przesun ( f , [number] , [number] ) [EOL] narysuj ( f ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def test_zawiera ( ) : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] f = Figura ( [number] , [number] , [number] , [number] ) [EOL] narysuj ( f ) [EOL] print ( [string] ) [EOL] print ( zawiera ( f , [number] , [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] f = Figura ( [number] , [number] , [number] ) [EOL] narysuj ( f ) [EOL] print ( [string] ) [EOL] print ( zawiera ( f , [number] , [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] f = Figura ( [number] , [number] ) [EOL] narysuj ( f ) [EOL] print ( [string] ) [EOL] print ( zawiera ( f , [number] , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test_przesun ( ) [EOL] test_zawiera ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Any [EOL] import typing [EOL] def torba ( ) : [EOL] return [ ] [EOL] [EOL] [EOL] def zbior ( ) : [EOL] return ( ) [EOL] [EOL] [EOL] def wstaw ( k , e ) : [EOL] if isinstance ( k , list ) : [EOL] k . append ( e ) [EOL] else : [EOL] [comment] [EOL] k = set ( k ) [EOL] k . add ( e ) [EOL] return tuple ( k ) [EOL] [EOL] [EOL] def rozmiar ( k ) : [EOL] return len ( k ) [EOL] [EOL] [EOL] def szukaj ( k , e ) : [EOL] return k . count ( e ) [EOL] [EOL] [EOL] def szukaj_v2 ( k , e ) : [EOL] [comment] [EOL] from collections import Counter [EOL] return Counter ( k ) [ e ] [EOL] [EOL] [EOL] def test ( ) : [EOL] print ( [string] ) [EOL] t = torba ( ) [EOL] print ( t ) [EOL] wstaw ( t , [number] ) ; wstaw ( t , [number] ) ; wstaw ( t , [number] ) [EOL] print ( t ) [EOL] print ( rozmiar ( t ) ) [EOL] print ( szukaj ( t , [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] z = zbior ( ) [EOL] print ( z ) [EOL] z = wstaw ( z , [number] ) [EOL] z = wstaw ( z , [number] ) [EOL] z = wstaw ( z , [number] ) [EOL] print ( z ) [EOL] print ( rozmiar ( z ) ) [EOL] print ( szukaj ( z , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple , Literal , Callable [EOL] import datetime [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] import sys [EOL] import typing as t [EOL] from datetime import datetime [EOL] [EOL] import psycopg2 [EOL] from toolz . functoolz import compose as C [EOL] from effect import ( sync_perform , sync_performer , TypeDispatcher , ComposedDispatcher , base_dispatcher ) [EOL] [EOL] import api [EOL] import exceptions as exs [EOL] from requests import * [EOL] [EOL] [EOL] DEBUG = [number] [EOL] db_conn = None [EOL] db_cursor = None [EOL] [EOL] [EOL] def execute_sql_query ( sqlquery ) : [EOL] if DEBUG : [EOL] print ( sqlquery ) [EOL] assert db_cursor is not None , [string] [EOL] db_cursor . execute ( sqlquery . q , sqlquery . params ) [EOL] db_conn . commit ( ) [EOL] return db_cursor . fetchall [EOL] [EOL] [EOL] @ sync_performer def perform_sql_query ( dispatcher , sqlquery ) : [EOL] return execute_sql_query ( sqlquery ) [EOL] [EOL] [EOL] @ sync_performer def perform_current_datetime ( * args ) : [EOL] return datetime . now ( ) [EOL] [EOL] [EOL] @ sync_performer def perform_open_db ( dispatcher , intent ) : [EOL] global db_conn , db_cursor [EOL] if DEBUG : [EOL] print ( intent ) [EOL] db_conn = psycopg2 . connect ( dbname = intent . db , user = intent . login , password = intent . password ) [EOL] db_cursor = db_conn . cursor ( ) [EOL] [EOL] [EOL] def process_request ( request ) : [EOL] api_dispatcher = { [string] : api . open_conn , [string] : api . leader , [string] : api . support , [string] : api . protest , [string] : api . upvote , [string] : api . downvote , [string] : api . actions , [string] : api . projects , [string] : api . votes , [string] : api . trolls , } [EOL] action = req_action ( request ) [EOL] try : [EOL] effect = api_dispatcher [ action ] ( ** request [ action ] ) [EOL] except KeyError : [EOL] raise exs . CommandNotSupported [EOL] eff_dispatcher = ComposedDispatcher ( [ TypeDispatcher ( { SQLQuery : perform_sql_query , OpenDatabase : perform_open_db , CurrentDatetime : perform_current_datetime , } ) , base_dispatcher , ] ) [EOL] sync_perform ( eff_dispatcher , effect ) [EOL] assert db_cursor is not None and db_conn is not None , [string] [EOL] [EOL] try : [EOL] data = db_cursor . fetchall ( ) [EOL] return ResponseType ( { [string] : [string] , [string] : list ( map ( list , data ) ) , } ) [EOL] except psycopg2 . ProgrammingError : [EOL] [comment] [EOL] return ResponseType ( { [string] : [string] } ) [EOL] [EOL] [EOL] def close_db_conn ( ) : [EOL] assert db_cursor is not None and db_conn is not None , [string] [EOL] db_cursor . close ( ) [EOL] db_conn . close ( ) [EOL] [EOL] [EOL] @ curry def get_response ( validate , request ) : [EOL] try : [EOL] return C ( process_request , validate ) ( request ) [EOL] except psycopg2 . Error as e : [EOL] execute_sql_query ( SQLQuery ( [string] ) ) [EOL] return ResponseType ( { [string] : [string] , [string] : type ( e ) . __name__ } ) [EOL] except ( exs . InternalException , AssertionError ) as e : [EOL] return ResponseType ( { [string] : [string] , [string] : str ( e ) } ) [EOL] [EOL] [EOL] def init_db ( ) : [EOL] init_files = ( [string] , ) [EOL] for filename in init_files : [EOL] with open ( filename , [string] ) as f : [EOL] q = [string] . join ( f . readlines ( ) ) [EOL] execute_sql_query ( SQLQuery ( q , { } ) ) [EOL] [EOL] [EOL] def run ( is_init = False ) : [EOL] C ( output_response , get_response ( validate_req_action ( [string] ) ) , read_request ) ( ) [EOL] [EOL] if is_init : [EOL] init_db ( ) [EOL] [EOL] while True : [EOL] try : [EOL] C ( output_response , get_response ( validate_req ( is_init ) ) , read_request ) ( ) [EOL] except EOFError : [EOL] close_db_conn ( ) [EOL] break [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) == [number] and sys . argv [ [number] ] == [string] : [EOL] run ( is_init = True ) [EOL] elif len ( sys . argv ) == [number] : [EOL] run ( ) [EOL] else : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class InternalException ( Exception ) : [EOL] def __str__ ( self ) : [EOL] return type ( self ) . __name__ [EOL] [EOL] [EOL] class UserIsFrozenError ( InternalException ) : [EOL] pass [EOL] [EOL] [EOL] class DoesNotExist ( InternalException ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidInputError ( InternalException ) : [EOL] pass [EOL] [EOL] [EOL] class IncorrectCredentials ( InternalException ) : [EOL] pass [EOL] [EOL] [EOL] class CommandNotSupported ( InternalException ) : [EOL] pass [EOL] [EOL] [EOL] class Forbidden ( InternalException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , List , Any , Union , Generator [EOL] import Databases [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] from collections import namedtuple [EOL] [EOL] from mytypes import * [EOL] from myhash import hash_password , verify_password [EOL] import exceptions as exs [EOL] from orm import Model [EOL] from effect import Effect [EOL] [EOL] LA_THRESHOLD = [number] * [number] [comment] [EOL] MemberData = namedtuple ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class Member ( Model ) : [EOL] @ classmethod def get_or_create ( cls , _fields = None , ** kwargs ) : [EOL] kwargs [ [string] ] = hash_password ( str ( kwargs [ [string] ] ) ) [EOL] return super ( ) . get_or_create ( _fields , ** kwargs ) [EOL] [EOL] @ classmethod def create ( cls , ** kwargs ) : [EOL] kwargs [ [string] ] = hash_password ( str ( kwargs [ [string] ] ) ) [EOL] return super ( ) . create ( ** kwargs ) [EOL] [EOL] @ staticmethod def is_frozen ( member ) : [EOL] current_date = yield Effect ( CurrentDatetime ( ) ) [comment] [EOL] threshold = int ( ( current_date - datetime . timedelta ( days = LA_THRESHOLD ) ) . timestamp ( ) ) [EOL] return member . last_active < threshold [EOL] [EOL] @ classmethod def set_last_active ( cls , member_id , timestamp ) : [EOL] return cls . update ( [string] , [string] , timestamp , { [string] : member_id } ) [EOL] [EOL] @ classmethod def set_is_active ( cls , member_id , is_active ) : [EOL] is_active_v = str ( is_active ) . lower ( ) [EOL] params = [ [string] , [string] , is_active_v , { [string] : member_id } ] [EOL] yield Effect ( cls . update ( * params ) ) [comment] [EOL] yield Effect ( UserActionVote . update ( * params ) ) [comment] [EOL] [EOL] @ classmethod def auth ( cls , member_id , password , timestamp ) : [EOL] fields = [ [string] , [string] , [string] , [string] ] [EOL] member_f = yield Effect ( Member . get ( _fields = fields , id = member_id ) ) [EOL] member = MemberData ( * member_f ( ) [ [number] ] ) [EOL] is_frozen = yield from cls . is_frozen ( member ) [EOL] if not verify_password ( member . password , password ) : [EOL] raise exs . IncorrectCredentials [EOL] if is_frozen : [EOL] raise exs . UserIsFrozenError [EOL] if is_frozen != member . is_active : [EOL] yield from cls . set_is_active ( member_id , not is_frozen ) [EOL] yield Effect ( cls . set_last_active ( member_id , timestamp ) ) [EOL] return member [EOL] [EOL] @ classmethod def auth_as_leader ( cls , member_id , password , timestamp ) : [EOL] member = yield from cls . auth ( member_id , password , timestamp ) [EOL] if not member . is_leader : [EOL] raise exs . Forbidden [EOL] [EOL] @ classmethod def custom_get_or_create ( cls , member , password , timestamp , ) : [EOL] user_f = yield Effect ( Member . get ( id = member ) ) [EOL] if len ( user_f ( ) ) == [number] : [comment] [EOL] yield Effect ( Member . create ( id = member , password = password , last_active = timestamp ) ) [EOL] else : [EOL] yield from Member . auth ( member , password , timestamp ) [EOL] [EOL] [EOL] class Project ( Model ) : [EOL] @ staticmethod def custom_get_or_create ( project , timestamp , authority = None ) : [EOL] project_f = yield Effect ( Project . get ( id = project ) ) [EOL] if len ( project_f ( ) ) == [number] : [comment] [EOL] if authority is None : [EOL] raise exs . InvalidInputError [EOL] yield Effect ( Project . create ( id = project , authority = authority , timestamp = timestamp ) ) [EOL] [EOL] @ classmethod def get_list ( cls , ** kwargs ) : [EOL] _fields = [ [string] , [string] ] [EOL] return cls . list ( _fields , ** kwargs ) [EOL] [EOL] [EOL] class Action ( Model ) : [EOL] @ classmethod def get_list ( cls , * args , ** kwargs ) : [EOL] groupby_fields = [ [string] , [string] , [string] , [string] ] [EOL] result_fields = [string] . join ( groupby_fields + [ cls . count ( [string] , [string] , [string] ) , cls . count ( [string] , [string] , [string] ) , ] ) [EOL] q = ( f" [string] { result_fields } [string] " f" [string] " f" [string] " f"{ cls . get_conds ( ** kwargs ) } [string] " f" [string] { [string] . join ( groupby_fields ) } [string] " ) [EOL] return SQLQuery ( q , kwargs ) [EOL] [EOL] [EOL] class Vote ( Model ) : [EOL] @ classmethod def get_members_votes ( cls , ** kwargs ) : [EOL] fields = [string] . join ( [ [string] , cls . count ( [string] , [string] , [string] ) , cls . count ( [string] , [string] , [string] ) , ] ) [EOL] q = ( f" [string] { fields } [string] " f" [string] " f" [string] " f"{ cls . get_conds ( ** kwargs ) } [string] " f" [string] " ) [EOL] return SQLQuery ( q , kwargs ) [EOL] [EOL] [EOL] class UserActionVote ( Model ) : [EOL] @ classmethod def table_name ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def get_list ( cls , ** kwargs ) : [EOL] _fields = [ [string] , [string] , [string] , [string] ] [EOL] _order_by = [ [string] , [string] ] [EOL] _conds = [ [string] ] [EOL] return cls . list ( _fields , _order_by , _conds , ** kwargs ) [EOL] [EOL] @ classmethod def add_vote ( cls , member_id , action_id , vote_type ) : [EOL] assert ( vote_type in [ VOTE_UP , VOTE_DOWN ] ) [EOL] col = f"{ vote_type } [string] " [EOL] params = { [string] : member_id , [string] : action_id } [EOL] conds = cls . get_conds ( ** params ) [EOL] return SQLQuery ( f" [string] { cls . table_name ( ) } [string] { col } [string] { col } [string] { conds } [string] " , params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SQLQuery$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
import builtins [EOL] import json [EOL] [EOL] from toolz . functoolz import compose as C , curry [EOL] from mytypes import * [EOL] [EOL] [EOL] def req_action ( request ) : [EOL] assert len ( request . keys ( ) ) == [number] , [string] [EOL] return list ( request . keys ( ) ) [ [number] ] [EOL] [EOL] [EOL] def read_request ( ) : [EOL] return C ( RequestType , json . loads , input ) ( [string] ) [EOL] [EOL] [EOL] def output_response ( response ) : [EOL] C ( print , json . dumps ) ( response ) [EOL] [EOL] [EOL] @ curry def validate_req ( is_init , request ) : [EOL] action = req_action ( request ) [EOL] if is_init : [EOL] assert action in [ [string] ] , [string] [EOL] else : [EOL] assert action not in [ [string] , [string] ] , [string] [EOL] return request [EOL] [EOL] [EOL] @ curry def validate_req_action ( action , request ) : [EOL] assert req_action ( request ) == action , f" [string] { action }" [EOL] return request [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RequestType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RequestType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RequestType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Callable , Optional , Generator [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from effect import Effect [EOL] from effect . do import do [EOL] [EOL] from models import * [EOL] from exceptions import * [EOL] [EOL] [EOL] def transaction ( f ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] yield Effect ( SQLQuery ( [string] ) ) [EOL] yield from f ( * args , ** kwargs ) [EOL] yield Effect ( SQLQuery ( [string] ) ) [EOL] return wrapper [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ do def open_conn ( database , login , password ) : [EOL] yield Effect ( OpenDatabase ( database , login , password ) ) [EOL] [EOL] [EOL] @ do def leader ( password , member , timestamp ) : [EOL] yield Effect ( Member . create ( id = member , password = password , is_leader = True , last_active = timestamp ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ do @ transaction def _action ( action_type , timestamp , member , password , action , project , authority = None , ) : [EOL] assert ( action_type in [ SUPPORT , PROTEST ] ) [EOL] yield from Member . custom_get_or_create ( member , password , timestamp ) [EOL] yield from Project . custom_get_or_create ( project , timestamp , authority ) [EOL] yield Effect ( Action . create ( id = action , timestamp = timestamp , atype = action_type , project_id = project , member_id = member ) ) [EOL] yield Effect ( UserActionVote . create ( member_id = member , action_id = action ) ) [EOL] [EOL] [EOL] def support ( ** kwargs ) : [EOL] return _action ( SUPPORT , ** kwargs ) [EOL] [EOL] [EOL] def protest ( ** kwargs ) : [EOL] return _action ( PROTEST , ** kwargs ) [EOL] [EOL] [EOL] @ do @ transaction def _vote ( vote_type , timestamp , member , password , action , ) : [EOL] assert ( vote_type in [ VOTE_UP , VOTE_DOWN ] ) [EOL] yield from Member . custom_get_or_create ( member , password , timestamp ) [EOL] action_f = yield Effect ( Action . get ( id = action , _fields = [ [string] ] ) ) [EOL] actions = action_f ( ) [comment] [EOL] if len ( actions ) == [number] : [EOL] raise exs . DoesNotExist [EOL] action_member_id = actions [ [number] ] [ [number] ] [EOL] yield Effect ( Vote . create ( timestamp = timestamp , vtype = vote_type , member_id = member , action_id = action ) ) [EOL] yield Effect ( UserActionVote . add_vote ( action_member_id , action , vote_type ) ) [EOL] [EOL] [EOL] def upvote ( ** kwargs ) : [EOL] return _vote ( VOTE_UP , ** kwargs ) [EOL] [EOL] [EOL] def downvote ( ** kwargs ) : [EOL] return _vote ( VOTE_DOWN , ** kwargs ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ do def actions ( timestamp , member , password , type = None , project = None , authority = None , ) : [EOL] yield from Member . auth_as_leader ( member , password , timestamp ) [EOL] yield Effect ( Action . get_list ( atype = type , project_id = project , authority = authority , ) ) [EOL] [EOL] [EOL] @ do def projects ( timestamp , member , password , authority = None , ) : [EOL] yield from Member . auth_as_leader ( member , password , timestamp ) [EOL] yield Effect ( Project . get_list ( authority = authority ) ) [EOL] [EOL] [EOL] @ do def votes ( timestamp , member , password , action = None , project = None , ) : [EOL] yield from Member . auth_as_leader ( member , password , timestamp ) [EOL] params = { [string] : action , [string] : project } [EOL] yield Effect ( Vote . get_members_votes ( ** params ) ) [EOL] [EOL] [EOL] @ do def trolls ( timestamp ) : [EOL] yield Effect ( UserActionVote . get_list ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import hashlib [EOL] import binascii [EOL] import os [EOL] [EOL] HASHING_ALG = [string] [EOL] SALT_LEN = [number] [EOL] ITERATIONS = [number] [EOL] [EOL] [EOL] def hash_password ( password ) : [EOL] salt = hashlib . sha256 ( os . urandom ( [number] ) ) . hexdigest ( ) . encode ( [string] ) [EOL] pwdhash = hashlib . pbkdf2_hmac ( HASHING_ALG , password . encode ( [string] ) , salt , ITERATIONS ) [EOL] pwdhash = binascii . hexlify ( pwdhash ) [EOL] return ( salt + pwdhash ) . decode ( [string] ) [EOL] [EOL] [EOL] def verify_password ( stored_password , provided_password ) : [EOL] salt = stored_password [ : SALT_LEN ] [EOL] stored_password = stored_password [ SALT_LEN : ] [EOL] pwdhashb = hashlib . pbkdf2_hmac ( HASHING_ALG , provided_password . encode ( [string] ) , salt . encode ( [string] ) , ITERATIONS ) [EOL] pwdhash = binascii . hexlify ( pwdhashb ) . decode ( [string] ) [EOL] return pwdhash == stored_password [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , Union [EOL] import typing [EOL] from models import Member , Project , Vote , Action [EOL] [EOL] [EOL] class TestMember : [EOL] def test_table_name ( self ) : [EOL] assert Member . table_name ( ) == [string] [EOL] [EOL] def test_list ( self ) : [EOL] params = { [string] : [string] , [string] : [number] } [EOL] res = Member . list ( ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] [EOL] class TestProject : [EOL] def test_get ( self ) : [EOL] params = { [string] : [number] } [EOL] res = Project . get ( ** params ) [EOL] assert res . q == ( [string] [string] ) [EOL] assert res . params == params [EOL] [EOL] def test_get_list ( self ) : [EOL] params = { [string] : [number] } [EOL] res = Project . get_list ( ** params ) [EOL] assert res . q == ( [string] [string] ) [EOL] assert res . params == params [EOL] [EOL] def test_get_list__none_param ( self ) : [EOL] params = { [string] : None } [EOL] res = Project . get_list ( ** params ) [EOL] assert res . q == ( [string] ) [EOL] assert res . params == { } [EOL] [EOL] def test_list ( self ) : [EOL] res = Project . list ( ) [EOL] assert res . q == ( [string] ) [EOL] assert res . params == { } [EOL] [EOL] [EOL] class TestVotes : [EOL] BASE = ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] def test_get_members_votes ( self ) : [EOL] res = Vote . get_members_votes ( ) [EOL] assert res . q == self . BASE . format ( [string] ) [EOL] assert res . params == { } [EOL] [EOL] def test_get_members_votes__filter ( self ) : [EOL] params = { [string] : [number] } [EOL] res = Vote . get_members_votes ( ** params ) [EOL] assert res . q == self . BASE . format ( [string] ) [EOL] assert res . params == { [string] : [number] } [EOL] [EOL] [EOL] class TestAction : [EOL] BASE = ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] def test_get_list ( self ) : [EOL] res = Action . get_list ( ) [EOL] assert res . q == self . BASE . format ( [string] ) [EOL] assert res . params == { } [EOL] [EOL] def test_get_list__filter ( self ) : [EOL] params = { [string] : [string] } [EOL] res = Action . get_list ( ** params ) [EOL] assert res . q == self . BASE . format ( [string] ) [EOL] assert res . params == params [EOL] [EOL] def test_get_list__filter_two_conds ( self ) : [EOL] params = { [string] : [string] , [string] : [number] } [EOL] res = Action . get_list ( ** params ) [EOL] assert res . q == self . BASE . format ( [string] ) [EOL] assert res . params == params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0
from typing import Any , Dict , Union [EOL] import typing [EOL] from mytypes import SQLQuery [EOL] from orm import Model , join_queries , append_to_query [EOL] [EOL] [EOL] def test_joining_queries ( ) : [EOL] q1 = SQLQuery ( [string] , { [string] : [string] } ) [EOL] q2 = SQLQuery ( [string] , { [string] : [string] } ) [EOL] res = join_queries ( q2 ) ( q1 ) [EOL] assert res . q == [string] [EOL] assert res . params == { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def test_append_to_query ( ) : [EOL] q = SQLQuery ( [string] , { [string] : [string] } ) [EOL] res = append_to_query ( [string] ) ( q ) [EOL] assert res . q == [string] [EOL] assert res . params == { [string] : [string] } [EOL] [EOL] [EOL] class TestORM : [EOL] def test_table_name ( self ) : [EOL] assert Model . table_name ( ) == [string] [EOL] [EOL] def test_list__zero_params ( self ) : [EOL] res = Model . list ( ) [EOL] assert res . q == [string] [EOL] assert res . params == { } [EOL] [EOL] def test_list__one_params ( self ) : [EOL] params = { [string] : [string] } [EOL] res = Model . list ( ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] def test_list__three_params ( self ) : [EOL] params = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] res = Model . list ( ** params ) [EOL] assert res . q == ( [string] ) [EOL] assert res . params == params [EOL] [EOL] def test_list__fields ( self ) : [EOL] params = { [string] : [string] } [EOL] res = Model . list ( _fields = ( [string] , [string] ) , ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] def test_list__ordering ( self ) : [EOL] params = { [string] : [string] } [EOL] res = Model . list ( _order_by = ( [string] , [string] ) , ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] def test_get ( self ) : [EOL] params = { [string] : [string] } [EOL] res = Model . get ( ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] def test_get__fields ( self ) : [EOL] params = { [string] : [string] } [EOL] res = Model . get ( _fields = ( [string] , [string] ) , ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] def test_create ( self ) : [EOL] params = { [string] : [string] , [string] : [number] } [EOL] res = Model . create ( ** params ) [EOL] assert res . q == [string] [EOL] assert res . params == params [EOL] [EOL] def test_get_or_create ( self ) : [EOL] params = { [string] : [string] , [string] : [number] } [EOL] res = Model . get_or_create ( ** params ) [EOL] assert res . q == ( [string] [string] ) [EOL] assert res . params == params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0
from typing import Any [EOL] import typing [EOL] from random import randint [EOL] MAX_SIZE = [number] [EOL] MAX_N = [number] ** [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] with open ( [string] , [string] ) as out : [EOL] n = MAX_N [EOL] number_of_ops = MAX_N - [number] * MAX_SIZE [EOL] [EOL] f . write ( [string] . format ( n ) ) [EOL] [EOL] for i in range ( MAX_SIZE ) : [EOL] f . write ( [string] . format ( i ) ) [EOL] [EOL] for i in range ( number_of_ops // [number] ) : [EOL] random_int = randint ( [number] , MAX_SIZE - [number] ) [EOL] f . write ( [string] . format ( random_int ) ) [EOL] f . write ( [string] . format ( random_int ) ) [EOL] out . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] N = [number] ** [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( [string] . format ( N , [number] ) ) [EOL] [EOL] for i in range ( [number] , N ) : [EOL] f . write ( [string] . format ( [number] ) ) [EOL] [EOL] f . write ( [string] . format ( N ) ) [EOL] f . write ( [string] . format ( N ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import subprocess [EOL] import typing [EOL] import os [EOL] import argparse [EOL] import Compiler_Construction [EOL] import lang [EOL] import argparse [EOL] import glob [EOL] import os [EOL] import sys [EOL] import subprocess [EOL] import shutil [EOL] [EOL] class Configuration : [EOL] def __init__ ( self , xic , testdir , spim , workdir , registers_description , plugin ) : [EOL] self . xic = xic [EOL] self . testdir = testdir [EOL] self . spim = spim [EOL] self . workdir = workdir [EOL] self . registers_description = registers_description [EOL] self . plugin = plugin [EOL] [EOL] def printself ( self ) : [EOL] print ( [string] ) [EOL] print ( [string] , self . xic ) [EOL] print ( [string] , self . testdir ) [EOL] print ( [string] , self . spim ) [EOL] print ( [string] , self . workdir ) [EOL] if self . registers_description is not None : [EOL] print ( [string] , self . registers_description ) [EOL] if self . plugin : [EOL] print ( [string] , self . plugin ) [EOL] [EOL] class TestOutput : [EOL] class Status : [EOL] COMPILER_FAILURE = [number] [EOL] COMPILER_SUCCES = [number] [EOL] SPIM_FAILURE = [number] [EOL] SPIM_SUCCESS = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . status = None [EOL] self . compiler_stdout = None [EOL] self . compiler_stderr = None [EOL] self . compiler_ok = None [EOL] self . spim_stdout = None [EOL] self . spim_stderr = None [EOL] self . spim_ok = None [EOL] [EOL] [EOL] class TestInstrumentation : [EOL] def __init__ ( self , test ) : [EOL] self . test = test [EOL] self . instrumented = False [EOL] self . expected_output = [ ] [EOL] self . should_parse = True [EOL] self . stop_after = None [EOL] self . should_typecheck = True [EOL] self . typechecking_errors = [ ] [EOL] self . selftest = None [EOL] self . env = { } [EOL] [EOL] self . parse ( ) [EOL] self . validate ( ) [EOL] [EOL] def content ( self ) : [EOL] [comment] [EOL] lines = open ( self . test ) . readlines ( ) [EOL] lines = [ line . strip ( ) for line in lines ] [EOL] lines = [ line for line in lines if line . startswith ( [string] ) ] [EOL] lines = [ line [ [number] : ] for line in lines ] [EOL] return lines [EOL] [EOL] def parse ( self ) : [EOL] content = self . content ( ) [EOL] self . instrumented = [string] in content [EOL] if not self . instrumented : [EOL] raise Exception ( [string] % self . test ) [EOL] [EOL] for line in content : [EOL] if line . startswith ( [string] ) : [EOL] self . expected_output . append ( line [ [number] : ] ) [EOL] elif line == [string] : [EOL] self . should_parse = False [EOL] elif line == [string] : [EOL] self . should_typecheck = False [EOL] elif line . startswith ( [string] ) : [EOL] self . typechecking_errors . append ( line [ len ( [string] ) : ] ) [EOL] elif line . startswith ( [string] ) : [EOL] self . stop_after = line [ len ( [string] ) : ] [EOL] elif line . startswith ( [string] ) : [EOL] keyvalue = line [ len ( [string] ) : ] [EOL] keyvalue = keyvalue . split ( [string] ) [EOL] self . env [ keyvalue [ [number] ] ] = keyvalue [ [number] ] [EOL] elif line . startswith ( [string] ) : [EOL] arg = line [ len ( [string] ) : ] . strip ( ) [EOL] if arg == [string] : [EOL] self . selftest = True [EOL] elif arg == [string] : [EOL] self . selftest = False [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] elif line == [string] : [EOL] pass [EOL] else : [EOL] raise Exception ( [string] + line ) [EOL] [EOL] def validate ( self ) : [EOL] if not self . instrumented : [EOL] return [EOL] [EOL] if not self . should_parse : [EOL] if len ( self . expected_output ) > [number] : [EOL] raise Exception ( [string] % self . test ) [EOL] if len ( self . typechecking_errors ) > [number] : [EOL] raise Exception ( [string] % self . test ) [EOL] if not self . should_typecheck : [EOL] raise Exception ( [string] % self . test ) [EOL] [EOL] if not self . should_typecheck : [EOL] if len ( self . expected_output ) > [number] : [EOL] raise Exception ( [string] % self . test ) [EOL] [EOL] if len ( self . typechecking_errors ) : [EOL] if len ( self . expected_output ) > [number] : [EOL] raise Exception ( [string] % self . test ) [EOL] self . should_typecheck = False [EOL] [EOL] class Test : [EOL] def __init__ ( self , test , instrumentation ) : [EOL] self . test = test [EOL] self . instrumentation = instrumentation [EOL] [EOL] def expecting_parsing_error ( self ) : [EOL] return not self . instrumentation . should_parse [EOL] [EOL] def expecting_typechecking_error ( self ) : [EOL] return not self . instrumentation . should_typecheck [EOL] [EOL] def expecting_compilation_failure ( self ) : [EOL] return self . expecting_parsing_error ( ) or self . expecting_typechecking_error ( ) [EOL] [EOL] def expecting_runtime_output ( self ) : [EOL] return not self . expecting_compilation_failure ( ) and not self . instrumentation . stop_after [EOL] [EOL] class ExpectationMatcher : [EOL] def __init__ ( self , test , output ) : [EOL] self . test = test [EOL] self . output = output [EOL] [EOL] def __match_output ( self , stdout , expected ) : [EOL] actual = list ( reversed ( stdout ) ) [EOL] expected = list ( reversed ( expected ) ) [EOL] [EOL] for i in range ( [number] , len ( expected ) ) : [EOL] if len ( actual ) <= i : [EOL] [comment] [EOL] [comment] [EOL] return False , [string] % ( len ( actual ) , len ( expected ) ) [EOL] [EOL] expected_line = expected [ i ] [EOL] actual_line = actual [ i ] [EOL] if expected_line != actual_line : [EOL] explanation = [string] % ( i + [number] , expected_line , actual_line ) [EOL] return False , explanation [EOL] return True , [string] [EOL] [EOL] def __real_match ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . test . expecting_compilation_failure ( ) : [EOL] xic_stderr = self . output . compiler_stderr . decode ( [string] ) [EOL] xic_stderr = xic_stderr . splitlines ( ) [EOL] if len ( xic_stderr ) == [number] : [EOL] xic_last_line_stderr = None [EOL] else : [EOL] xic_last_line_stderr = xic_stderr [ - [number] ] . strip ( ) [EOL] if self . output . compiler_ok : [EOL] return False , [string] [EOL] if self . test . expecting_parsing_error ( ) : [EOL] if xic_last_line_stderr == [string] : [EOL] return True , [string] [EOL] return False , [string] [EOL] if self . test . expecting_typechecking_error ( ) : [EOL] if xic_last_line_stderr == [string] : [EOL] return True , [string] [EOL] return False , [string] [EOL] else : [EOL] if not self . output . compiler_ok : [EOL] return False , [string] [EOL] [EOL] if self . test . instrumentation . stop_after : [EOL] return True , [string] [EOL] [EOL] if len ( self . output . spim_stderr ) > [number] : [EOL] return False , [string] [EOL] [EOL] [EOL] if self . test . expecting_runtime_output ( ) : [EOL] if not self . output . spim_ok : [EOL] return False , [string] [EOL] [EOL] if len ( self . test . instrumentation . expected_output ) > [number] : [EOL] spim_stdout = self . output . spim_stdout . decode ( [string] ) [EOL] spim_stdout = spim_stdout . splitlines ( ) [EOL] spim_stdout = [ line . strip ( ) for line in spim_stdout ] [EOL] return self . __match_output ( spim_stdout , self . test . instrumentation . expected_output ) [EOL] [EOL] return True , [string] [EOL] [EOL] return None , [string] [EOL] [EOL] def match ( self ) : [EOL] x_result , x_explanation = self . __real_match ( ) [EOL] [EOL] if self . test . instrumentation . selftest == None : [EOL] result , explanation = x_result , x_explanation [EOL] else : [EOL] result = x_result == self . test . instrumentation . selftest [EOL] if result : [EOL] explanation = [string] [EOL] else : [EOL] explanation = [string] % ( self . test . instrumentation . selftest , x_result , x_explanation ) [EOL] [EOL] return result , explanation [EOL] [EOL] class TestRawExecutor : [EOL] [EOL] def __init__ ( self , conf , test , env , run_spim , stop_point ) : [EOL] self . conf = conf [EOL] self . test = test [EOL] self . env = env [EOL] self . output_file = os . path . join ( conf . workdir , [string] ) [EOL] self . test_output = TestOutput ( ) [EOL] self . run_spim = run_spim [EOL] self . stop_point = stop_point [EOL] [EOL] def execute ( self ) : [EOL] self . prepare_env ( ) [EOL] ok , stdout , stderr = self . compile_program ( ) [EOL] self . test_output . compiler_stdout = stdout [EOL] self . test_output . compiler_stderr = stderr [EOL] self . test_output . compiler_ok = ok [EOL] if not ok or not self . run_spim or self . stop_point : [EOL] self . clean_env ( ) [EOL] return self . test_output [EOL] [EOL] ok , stdout , stderr = self . execute_program ( ) [EOL] self . test_output . spim_stdout = stdout [EOL] self . test_output . spim_stderr = stderr [EOL] self . test_output . spim_ok = ok [EOL] self . clean_env ( ) [EOL] [EOL] return self . test_output [EOL] [EOL] def compile_program ( self ) : [EOL] xs = [ self . conf . xic , [string] , self . output_file ] [EOL] if self . stop_point : [EOL] xs . append ( [string] ) [EOL] xs . append ( self . stop_point ) [EOL] if self . conf . registers_description is not None : [EOL] xs . append ( [string] ) [EOL] xs . append ( self . conf . registers_description ) [EOL] if self . conf . plugin is not None : [EOL] xs . append ( [string] ) [EOL] xs . append ( self . conf . plugin ) [EOL] [EOL] xs . append ( [string] ) [EOL] xs . append ( os . path . join ( self . conf . workdir , [string] ) ) [EOL] xs . append ( self . test ) [EOL] env = dict ( self . env ) [EOL] return self . __call ( xs , env ) [EOL] [EOL] def execute_program ( self ) : [EOL] return self . __call ( [ self . conf . spim , [string] , self . output_file ] ) [EOL] [EOL] def prepare_env ( self ) : [EOL] shutil . rmtree ( self . conf . workdir , ignore_errors = True ) [EOL] os . makedirs ( self . conf . workdir ) [EOL] [EOL] def clean_env ( self ) : [EOL] shutil . rmtree ( self . conf . workdir , ignore_errors = True ) [EOL] [EOL] def __call ( self , xs , extenv = { } ) : [EOL] env = os . environ [EOL] for k in extenv : [EOL] env [ k ] = extenv [ k ] [EOL] [EOL] try : [EOL] p = subprocess . Popen ( xs , stdin = None , stdout = subprocess . PIPE , stderr = subprocess . PIPE , env = env ) [EOL] stdin , stdout = p . communicate ( timeout = [number] ) [EOL] status = p . returncode == [number] [EOL] return ( status , stdin , stdout ) [EOL] except subprocess . TimeoutExpired : [EOL] return ( False , [ ] , [ ] ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] return ( False , [ ] , [ ] ) [EOL] [EOL] class TestExecutor : [EOL] def __init__ ( self , test , conf ) : [EOL] self . test = test [EOL] self . conf = conf [EOL] [EOL] def execute ( self ) : [EOL] try : [EOL] run_spim = self . test . expecting_runtime_output ( ) [EOL] stop_point = None [EOL] if not run_spim : [EOL] if self . test . expecting_parsing_error ( ) : [EOL] stop_point = [string] [EOL] elif self . test . expecting_typechecking_error ( ) : [EOL] stop_point = [string] [EOL] elif self . test . instrumentation . stop_after : [EOL] stop_point = self . test . instrumentation . stop_after [EOL] [EOL] rawExecutor = TestRawExecutor ( self . conf , self . test . test , self . test . instrumentation . env , run_spim , stop_point ) [EOL] test_output = rawExecutor . execute ( ) [EOL] matcher = ExpectationMatcher ( self . test , test_output ) [EOL] return matcher . match ( ) [EOL] except Exception as e : [EOL] raise e [EOL] return None , [string] + str ( e ) [EOL] [EOL] [EOL] class TestRepository : [EOL] def __init__ ( self , testdirs ) : [EOL] self . tests = [ ] [EOL] self . collect_tests ( testdirs ) [EOL] [EOL] def collect_tests ( self , testdirs ) : [EOL] testfiles = [ ] [EOL] for testdir in testdirs : [EOL] for path , _ , files in os . walk ( testdir ) : [EOL] for file in files : [EOL] if file . endswith ( [string] ) : [EOL] testfiles . append ( os . path . join ( path , file ) ) [EOL] testfiles = list ( sorted ( testfiles ) ) [EOL] [EOL] for testfile in testfiles : [EOL] instrumentation = TestInstrumentation ( testfile ) [EOL] test = Test ( testfile , instrumentation ) [EOL] self . tests . append ( test ) [EOL] [EOL] def gen ( self ) : [EOL] for t in self . tests : [EOL] yield t [EOL] [EOL] class Application : [EOL] def __init__ ( self ) : [EOL] args = self . create_argparse ( ) . parse_args ( ) [EOL] self . conf = Configuration ( xic = args . xic , testdir = args . testdir , spim = args . spim , workdir = args . workdir , registers_description = args . registers_description , plugin = args . plugin ) [EOL] [EOL] [EOL] def create_argparse ( self ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , type = str ) [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , type = str ) [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , type = str ) [EOL] parser . add_argument ( [string] , help = [string] , default = [string] , type = str ) [EOL] parser . add_argument ( [string] , help = [string] , default = None , type = str ) [EOL] parser . add_argument ( [string] , help = [string] , type = str ) [EOL] return parser [EOL] [EOL] def run ( self ) : [EOL] print ( [string] ) [EOL] self . conf . printself ( ) [EOL] self . test_repository = TestRepository ( [ self . conf . testdir ] ) [EOL] passed_tests = [ ] [EOL] failed_tests = [ ] [EOL] inconclusive_tests = [ ] [EOL] for test in self . test_repository . gen ( ) : [EOL] print ( [string] , test . test ) [EOL] executor = TestExecutor ( test , self . conf ) [EOL] result , explanation = executor . execute ( ) [EOL] [EOL] if result == None : [EOL] inconclusive_tests . append ( test ) [EOL] status = [string] + explanation [EOL] elif result : [EOL] passed_tests . append ( test ) [EOL] status = [string] [EOL] elif not result : [EOL] failed_tests . append ( test ) [EOL] status = [string] + explanation [EOL] [EOL] print ( [string] , status ) [EOL] [EOL] total = len ( passed_tests ) + len ( failed_tests ) + len ( inconclusive_tests ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] , total ) [EOL] print ( [string] , len ( passed_tests ) ) [EOL] print ( [string] , len ( inconclusive_tests ) ) [EOL] print ( [string] , len ( failed_tests ) ) [EOL] for test in failed_tests : [EOL] print ( [string] , test . test ) [EOL] [EOL] [EOL] Application ( ) . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.TestOutput$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.list$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.TestRawExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $Compiler_Construction.xi-lang.tools.tester.TestRawExecutor$ 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.ExpectationMatcher$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Compiler_Construction.xi-lang.tools.tester.ExpectationMatcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $Compiler_Construction.xi-lang.tools.tester.TestInstrumentation$ 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.Test$ 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.TestInstrumentation$ 0 0 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.Test$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.Configuration$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.TestExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Compiler_Construction.xi-lang.tools.tester.TestExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import cryptography [EOL] import ApplicationSecurity [EOL] import timeit [EOL] import typing [EOL] import timeit [EOL] import random [EOL] [EOL] from Crypto import Random [EOL] from Crypto . Cipher import PKCS1_OAEP [EOL] from Crypto . PublicKey import RSA [EOL] from cryptography . fernet import Fernet [EOL] [EOL] [EOL] class SymmetricEncryption ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , secret_key , msg ) : [EOL] self . secret_key = secret_key [EOL] self . msg = msg [EOL] [EOL] def __call__ ( self ) : [EOL] return self . encrypt ( ) [EOL] [EOL] def encrypt ( self ) : [EOL] f = Fernet ( self . secret_key ) [EOL] ciphertext = f . encrypt ( bytes ( self . msg ) ) [EOL] return ciphertext [EOL] [EOL] @ staticmethod def gen_key ( k = [number] ) : [EOL] return Fernet . generate_key ( ) [EOL] [EOL] [EOL] class AsymmetricEncryption ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , key , msg ) : [EOL] self . key = key [EOL] self . msg = bytes ( msg ) [EOL] [EOL] def __call__ ( self ) : [EOL] return self . encrypt ( ) [EOL] [EOL] def encrypt ( self ) : [EOL] publickey = self . key . publickey ( ) [EOL] ciphertext = publickey . encrypt ( self . msg , random . randint ( [number] , [number] ) ) [EOL] return ciphertext [EOL] [EOL] @ staticmethod def gen_key ( key = [number] ) : [EOL] random_generator = Random . new ( ) . read [EOL] key = RSA . generate ( key , random_generator ) [EOL] return key [EOL] [EOL] [EOL] class EncryptionReport ( object ) : [EOL] [docstring] [EOL] def _get_message ( self , k = [number] ) : [EOL] return [string] * k [EOL] [EOL] def _EncryptorFactory ( self , encryptor_class , k = [number] , key_len = [number] ) : [EOL] return encryptor_class ( encryptor_class . gen_key ( key_len ) , self . _get_message ( k ) ) [EOL] [EOL] def report_results ( self ) : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] encryptor = self . _EncryptorFactory ( SymmetricEncryption ) [EOL] print ( encryptor . encrypt ( ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] encryptor = self . _EncryptorFactory ( AsymmetricEncryption ) [EOL] print ( encryptor . encrypt ( ) ) [EOL] print ( [string] ) [EOL] [EOL] def measure_performance ( self ) : [EOL] ITERATIONS = [number] [EOL] [EOL] print ( [string] ) [EOL] print ( [string] . format ( ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( SymmetricEncryption ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( SymmetricEncryption , [number] ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( AsymmetricEncryption , [number] ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( AsymmetricEncryption , [number] ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( AsymmetricEncryption , [number] , [number] ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( AsymmetricEncryption , [number] , [number] ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] t = timeit . Timer ( self . _EncryptorFactory ( AsymmetricEncryption , [number] , [number] ) . encrypt ) [EOL] print ( t . timeit ( number = ITERATIONS ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def report ( self ) : [EOL] self . report_results ( ) [EOL] self . measure_performance ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] reporter = EncryptionReport ( ) [EOL] reporter . report ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.fernet.Fernet$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $cryptography.fernet.Fernet$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $timeit.Timer$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ApplicationSecurity.Solutions.set1.task2.EncryptionReport$ 0 0 0 0 0 $ApplicationSecurity.Solutions.set1.task2.EncryptionReport$ 0 0 0 0 0
import hashlib [EOL] import timeit [EOL] import hashlib [EOL] import argon2 [EOL] import bcrypt [EOL] [EOL] [EOL] password = [string] * [number] [EOL] salt = [string] [EOL] [EOL] iterations = [number] [EOL] [EOL] [EOL] def md5_test ( ) : [EOL] m = hashlib . md5 ( ) [EOL] m . update ( password + salt ) [EOL] [EOL] [EOL] def bcrypt_test ( ) : [EOL] bcrypt . hashpw ( password , salt ) [EOL] [EOL] [EOL] def sha256_test ( ) : [EOL] hashlib . sha256 ( password + salt ) [EOL] [EOL] [EOL] def argon_test ( ) : [EOL] argon2 . argon2_hash ( password = password , salt = salt ) [EOL] [EOL] [EOL] def measure_md5 ( ) : [EOL] print ( [string] ) [EOL] print ( [string] . format ( timeit . timeit ( [string] , setup = [string] , number = iterations ) , [number] ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def measure_argon ( ) : [EOL] print ( [string] ) [EOL] print ( timeit . timeit ( [string] , setup = [string] , number = iterations ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def measure_sha256 ( ) : [EOL] print ( [string] ) [EOL] print ( timeit . timeit ( [string] , setup = [string] , number = iterations ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def measure_bcrypt ( ) : [EOL] print ( [string] ) [EOL] print ( timeit . timeit ( [string] , setup = [string] , number = iterations ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def measure ( ) : [EOL] print ( [string] ) [EOL] print ( [string] . format ( iterations ) ) [EOL] print ( [string] . format ( len ( password + salt ) ) ) [EOL] print ( [string] ) [EOL] measure_md5 ( ) [EOL] measure_sha256 ( ) [EOL] measure_argon ( ) [EOL] measure_bcrypt ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] measure ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0