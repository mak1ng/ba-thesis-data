from setuptools import setup [EOL] [EOL] setup ( use_scm_version = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , Any , List [EOL] import typing [EOL] import builtins [EOL] import click [EOL] import src [EOL] import pendulum [EOL] import sys [EOL] [EOL] import click [EOL] import pendulum [EOL] from deploy_tools . cli import ( auto_nonce_option , connect_to_json_rpc , gas_option , gas_price_option , get_nonce , jsonrpc_option , keystore_option , nonce_option , retrieve_private_key , ) [EOL] from deploy_tools . deploy import build_transaction_options [EOL] from eth_utils import encode_hex , is_checksum_address , to_canonical_address [EOL] [EOL] from . airdrop import get_balance , get_item , to_items [EOL] from . deploy import deploy_merkle_drop , sum_of_airdropped_tokens [EOL] from . load_csv import load_airdrop_file [EOL] from . merkle_tree import build_tree , compute_merkle_root , create_proof [EOL] from . status import get_merkle_drop_status [EOL] [EOL] [EOL] def validate_address ( ctx , param , value ) : [EOL] if not is_checksum_address ( value ) : [EOL] raise click . BadParameter ( [string] ) [EOL] return to_canonical_address ( value ) [EOL] [EOL] [EOL] def validate_date ( ctx , param , value ) : [EOL] if value is None : [EOL] return None [EOL] try : [EOL] return pendulum . parse ( value ) [EOL] except pendulum . parsing . exceptions . ParserError as e : [EOL] raise click . BadParameter ( f' [string] { value } [string] ' ) from e [EOL] [EOL] [EOL] airdrop_file_argument = click . argument ( [string] , type = click . Path ( exists = True , dir_okay = False ) ) [EOL] [EOL] [EOL] merkle_drop_address_option = click . option ( [string] , help = [string] , type = str , required = True , callback = validate_address , ) [EOL] [EOL] [EOL] EXIT_OK_CODE = [number] [EOL] EXIT_ERROR_CODE = [number] [EOL] [EOL] [EOL] @ click . group ( ) def main ( ) : [EOL] pass [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ airdrop_file_argument def root ( airdrop_file_name ) : [EOL] [EOL] airdrop_data = load_airdrop_file ( airdrop_file_name ) [EOL] merkle_root = compute_merkle_root ( to_items ( airdrop_data ) ) [EOL] [EOL] click . echo ( f"{ encode_hex ( merkle_root ) }" ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , callback = validate_address ) @ airdrop_file_argument def balance ( address , airdrop_file_name ) : [EOL] [EOL] airdrop_data = load_airdrop_file ( airdrop_file_name ) [EOL] balance = get_balance ( address , airdrop_data ) [EOL] [EOL] click . echo ( f"{ balance }" ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ click . argument ( [string] , callback = validate_address ) @ airdrop_file_argument def proof ( address , airdrop_file_name ) : [EOL] airdrop_data = load_airdrop_file ( airdrop_file_name ) [EOL] try : [EOL] proof = create_proof ( get_item ( address , airdrop_data ) , build_tree ( to_items ( airdrop_data ) ) ) [EOL] click . echo ( [string] . join ( encode_hex ( hash_ ) for hash_ in proof ) ) [EOL] except KeyError as e : [EOL] raise click . BadParameter ( f" [string] " ) from e [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ keystore_option @ gas_option @ gas_price_option @ nonce_option @ auto_nonce_option @ jsonrpc_option @ click . option ( [string] , help = [string] , type = str , required = True , callback = validate_address , ) @ click . option ( [string] , [string] , help = [string] , type = click . Path ( exists = True , dir_okay = False ) , required = True , ) @ click . option ( [string] , [string] , help = [string] , type = int , required = False , ) @ click . option ( [string] , [string] , help = [string] , type = str , required = False , metavar = [string] , callback = validate_date , ) @ click . option ( [string] , [string] , help = [string] , type = int , required = False , default = [number] , ) def deploy ( keystore , jsonrpc , gas , gas_price , nonce , auto_nonce , token_address , airdrop_file_name , decay_start_time , decay_start_date , decay_duration , ) : [EOL] [EOL] if decay_start_date is not None and decay_start_time is not None : [EOL] raise click . BadParameter ( f" [string] " ) [EOL] if decay_start_date is None and decay_start_time is None : [EOL] raise click . BadParameter ( f" [string] " ) [EOL] [EOL] if decay_start_date is not None : [EOL] decay_start_time = int ( decay_start_date . timestamp ( ) ) [EOL] [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] private_key = retrieve_private_key ( keystore ) [EOL] [EOL] nonce = get_nonce ( web3 = web3 , nonce = nonce , auto_nonce = auto_nonce , private_key = private_key ) [EOL] transaction_options = build_transaction_options ( gas = gas , gas_price = gas_price , nonce = nonce ) [EOL] [EOL] airdrop_data = load_airdrop_file ( airdrop_file_name ) [EOL] airdrop_items = to_items ( airdrop_data ) [EOL] merkle_root = compute_merkle_root ( airdrop_items ) [EOL] [EOL] constructor_args = ( token_address , sum_of_airdropped_tokens ( airdrop_items ) , merkle_root , decay_start_time , decay_duration , ) [EOL] [EOL] merkle_drop = deploy_merkle_drop ( web3 = web3 , transaction_options = transaction_options , private_key = private_key , constructor_args = constructor_args , ) [EOL] [EOL] click . echo ( f" [string] { merkle_drop . address }" ) [EOL] click . echo ( f" [string] { encode_hex ( merkle_root ) }" ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ jsonrpc_option @ merkle_drop_address_option def status ( jsonrpc , merkle_drop_address ) : [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] [EOL] exit_code = EXIT_OK_CODE [EOL] status_dict = get_merkle_drop_status ( web3 , merkle_drop_address ) [EOL] [EOL] click . echo ( f" [string] { status_dict [ [string] ] }" ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] } [string] { status_dict [ [string] ] } [string] " ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] / [number] ** status_dict [ [string] ] }" ) [EOL] [EOL] click . echo ( [string] ) [EOL] [EOL] click . echo ( f" [string] { status_dict [ [string] ] }" ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] . hex ( ) }" ) [EOL] [EOL] click . echo ( [string] ) [EOL] [EOL] click . echo ( f" [string] { status_dict [ [string] ] / [number] ** status_dict [ [string] ] }" ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] / [number] ** status_dict [ [string] ] }" ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] / [number] ** status_dict [ [string] ] }" ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] / [number] ** status_dict [ [string] ] }" ) [EOL] [EOL] if status_dict [ [string] ] < status_dict [ [string] ] : [EOL] click . secho ( [string] , fg = [string] ) [EOL] exit_code = EXIT_ERROR_CODE [EOL] [EOL] click . echo ( [string] ) [EOL] [EOL] click . echo ( f" [string] { pendulum . from_timestamp ( status_dict [ [string] ] ) }" f" [string] { pendulum . from_timestamp ( status_dict [ [string] ] ) . diff_for_humans ( ) } [string] " ) [EOL] click . echo ( f" [string] { status_dict [ [string] ] }" f" [string] { pendulum . now ( ) . add ( seconds = status_dict [ [string] ] ) . diff_for_humans ( absolute = True ) } [string] " ) [EOL] [EOL] end_timestamp = pendulum . from_timestamp ( status_dict [ [string] ] + status_dict [ [string] ] ) [EOL] click . echo ( f" [string] " f"{ end_timestamp }" f" [string] { end_timestamp . diff_for_humans ( ) } [string] " ) [EOL] [EOL] remaining_seconds = ( status_dict [ [string] ] + status_dict [ [string] ] ) - pendulum . now ( ) . int_timestamp [EOL] click . echo ( f" [string] " f"{ remaining_seconds }" f" [string] { pendulum . now ( ) . add ( seconds = remaining_seconds ) . diff_for_humans ( absolute = True ) } [string] " ) [EOL] [EOL] sys . exit ( exit_code ) [EOL] [EOL] [EOL] @ main . command ( short_help = [string] ) @ jsonrpc_option @ merkle_drop_address_option @ airdrop_file_argument def check_root ( jsonrpc , merkle_drop_address , airdrop_file_name ) : [EOL] click . echo ( [string] ) [EOL] web3 = connect_to_json_rpc ( jsonrpc ) [EOL] status = get_merkle_drop_status ( web3 , merkle_drop_address ) [EOL] merkle_root_contract = status [ [string] ] . hex ( ) [EOL] click . echo ( f" [string] { merkle_root_contract } [string] " ) [EOL] [EOL] click . echo ( [string] ) [EOL] airdrop_data = load_airdrop_file ( airdrop_file_name ) [EOL] merkle_root_file = compute_merkle_root ( to_items ( airdrop_data ) ) . hex ( ) [EOL] click . echo ( f" [string] { merkle_root_file } [string] " ) [EOL] [EOL] if merkle_root_contract == merkle_root_file : [EOL] click . secho ( [string] , fg = [string] ) [EOL] else : [EOL] click . secho ( [string] , fg = [string] ) [EOL] sys . exit ( EXIT_ERROR_CODE ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
import builtins [EOL] from typing import Dict , Any [EOL] import typing [EOL] import web3 [EOL] from typing import Dict [EOL] [EOL] from deploy_tools . deploy import deploy_compiled_contract , load_contracts_json [EOL] from web3 . contract import Contract [EOL] [EOL] [EOL] def deploy_merkle_drop ( * , web3 , transaction_options = None , private_key = None , constructor_args ) : [EOL] [EOL] if transaction_options is None : [EOL] transaction_options = { } [EOL] [EOL] compiled_contracts = load_contracts_json ( __name__ ) [EOL] [EOL] merkle_drop_abi = compiled_contracts [ [string] ] [ [string] ] [EOL] merkle_drop_bin = compiled_contracts [ [string] ] [ [string] ] [EOL] [EOL] merkle_drop_contract = deploy_compiled_contract ( abi = merkle_drop_abi , bytecode = merkle_drop_bin , constructor_args = constructor_args , web3 = web3 , transaction_options = transaction_options , private_key = private_key , ) [EOL] [EOL] return merkle_drop_contract [EOL] [EOL] [EOL] def sum_of_airdropped_tokens ( airdrop_data ) : [EOL] sum = [number] [EOL] for item in airdrop_data : [EOL] sum += item . value [EOL] return sum [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import flask [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import math [EOL] import time [EOL] [EOL] import pendulum [EOL] from eth_utils import encode_hex , is_address , to_canonical_address , to_checksum_address [EOL] from flask import Flask , abort , jsonify [EOL] from flask_cors import CORS [EOL] [EOL] from merkle_drop . airdrop import get_balance , get_item , to_items [EOL] from merkle_drop . load_csv import load_airdrop_file [EOL] from merkle_drop . merkle_tree import build_tree , create_proof [EOL] [EOL] app = Flask ( [string] ) [EOL] [EOL] airdrop_dict = None [EOL] airdrop_tree = None [EOL] decay_start_time = - [number] [EOL] decay_duration_in_seconds = - [number] [EOL] [EOL] [EOL] def init_gunicorn_logging ( ) : [EOL] gunicorn_logger = logging . getLogger ( [string] ) [EOL] app . logger . handlers = gunicorn_logger . handlers [EOL] app . logger . setLevel ( gunicorn_logger . level ) [EOL] [EOL] [EOL] def init_cors ( ** kwargs ) : [EOL] [docstring] [EOL] CORS ( app = app , ** kwargs ) [EOL] [EOL] [EOL] def init ( airdrop_filename , decay_start_time_param , decay_duration_in_seconds_param , ) : [EOL] global airdrop_dict [EOL] global airdrop_tree [EOL] global decay_start_time [EOL] global decay_duration_in_seconds [EOL] decay_start = pendulum . from_timestamp ( decay_start_time_param ) [EOL] decay_end = pendulum . from_timestamp ( decay_start_time_param + decay_duration_in_seconds_param ) [EOL] [EOL] app . logger . info ( f" [string] { airdrop_filename }" ) [EOL] app . logger . info ( f" [string] { decay_start } [string] { decay_end }" ) [EOL] airdrop_dict = load_airdrop_file ( airdrop_filename ) [EOL] app . logger . info ( f" [string] { len ( airdrop_dict ) } [string] " ) [EOL] airdrop_tree = build_tree ( to_items ( airdrop_dict ) ) [EOL] decay_start_time = decay_start_time_param [EOL] decay_duration_in_seconds = decay_duration_in_seconds_param [EOL] [EOL] [EOL] @ app . errorhandler ( [number] ) def not_found ( e ) : [EOL] return jsonify ( error = [number] , message = [string] ) , [number] [EOL] [EOL] [EOL] @ app . errorhandler ( [number] ) def bad_request ( e ) : [EOL] return jsonify ( error = [number] , message = e . description ) , [number] [EOL] [EOL] [EOL] @ app . errorhandler ( [number] ) def internal_server_error ( e ) : [EOL] return jsonify ( error = [number] , message = [string] ) , [number] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def get_entitlement_for ( address ) : [EOL] if not is_address ( address ) : [EOL] abort ( [number] , [string] ) [EOL] canonical_address = to_canonical_address ( address ) [EOL] [EOL] eligible_tokens = get_balance ( canonical_address , airdrop_dict ) [EOL] if eligible_tokens == [number] : [EOL] proof = [ ] [EOL] decayed_tokens = [number] [EOL] else : [EOL] proof = create_proof ( get_item ( canonical_address , airdrop_dict ) , airdrop_tree ) [EOL] decayed_tokens = decay_tokens ( eligible_tokens ) [EOL] return jsonify ( { [string] : to_checksum_address ( address ) , [string] : str ( eligible_tokens ) , [string] : str ( decayed_tokens ) , [string] : [ encode_hex ( hash_ ) for hash_ in proof ] , } ) [EOL] [EOL] [EOL] [comment] [EOL] def decay_tokens ( tokens ) : [EOL] now = int ( time . time ( ) ) [EOL] if now <= decay_start_time : [EOL] return tokens [EOL] elif now >= decay_start_time + decay_duration_in_seconds : [EOL] return [number] [EOL] else : [EOL] time_decayed = now - decay_start_time [EOL] decay = math . ceil ( tokens * time_decayed / decay_duration_in_seconds ) [EOL] assert decay <= tokens [EOL] return tokens - decay [EOL] [EOL] [EOL] [comment] [EOL] if __name__ == [string] : [EOL] init_cors ( origins = [string] ) [EOL] init ( [string] , int ( time . time ( ) ) , [number] ) [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import _csv [EOL] import csv [EOL] from typing import Dict [EOL] [EOL] from eth_utils import is_address , to_canonical_address [EOL] [EOL] [EOL] def load_airdrop_file ( airdrop_file ) : [EOL] with open ( airdrop_file ) as file : [EOL] reader = csv . reader ( file ) [EOL] address_value_pairs = list ( reader ) [EOL] [EOL] validate_address_value_pairs ( address_value_pairs ) [EOL] return { to_canonical_address ( address ) : int ( value ) for address , value in address_value_pairs } [EOL] [EOL] [EOL] def validate_address_value_pairs ( address_value_pairs ) : [EOL] addresses = set ( ) [EOL] for address_value_pair in address_value_pairs : [EOL] if len ( address_value_pair ) != [number] : [EOL] raise ValueError ( f" [string] { len ( address_value_pairs ) }" ) [EOL] [EOL] address , value = address_value_pair [EOL] if not is_address ( address ) : [EOL] raise ValueError ( f" [string] { address }" ) [EOL] [EOL] if not value . isdigit ( ) : [EOL] raise ValueError ( f" [string] { value }" ) [EOL] [EOL] canonical_address = to_canonical_address ( address ) [EOL] if canonical_address in addresses : [EOL] raise ValueError ( f" [string] { address } [string] " ) [EOL] addresses . add ( canonical_address ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pendulum [EOL] from deploy_tools . deploy import load_contracts_json [EOL] from eth_utils import to_checksum_address [EOL] [EOL] [EOL] def get_merkle_drop_status ( web3 , contract_address ) : [EOL] [EOL] compiled_contracts = load_contracts_json ( __name__ ) [EOL] [EOL] merkle_drop_contract = web3 . eth . contract ( address = contract_address , abi = compiled_contracts [ [string] ] [ [string] ] ) [EOL] [EOL] token_contract = web3 . eth . contract ( address = merkle_drop_contract . functions . droppedToken ( ) . call ( ) , abi = compiled_contracts [ [string] ] [ [string] ] , ) [EOL] [EOL] return { [string] : to_checksum_address ( merkle_drop_contract . address ) , [string] : merkle_drop_contract . functions . root ( ) . call ( ) , [string] : merkle_drop_contract . functions . decayStartTime ( ) . call ( ) , [string] : merkle_drop_contract . functions . decayDurationInSeconds ( ) . call ( ) , [string] : merkle_drop_contract . functions . initialBalance ( ) . call ( ) , [string] : merkle_drop_contract . functions . remainingValue ( ) . call ( ) , [string] : merkle_drop_contract . functions . spentTokens ( ) . call ( ) , [string] : to_checksum_address ( token_contract . address ) , [string] : token_contract . functions . name ( ) . call ( ) , [string] : token_contract . functions . symbol ( ) . call ( ) , [string] : token_contract . functions . decimals ( ) . call ( ) , [string] : token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) , [string] : merkle_drop_contract . functions . decayedEntitlementAtTime ( merkle_drop_contract . functions . remainingValue ( ) . call ( ) , pendulum . now ( ) . int_timestamp , True , ) . call ( ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from typing import List , NamedTuple , Optional [EOL] [EOL] from eth_utils import is_canonical_address , keccak [EOL] [EOL] [EOL] class Item ( NamedTuple ) : [EOL] address = ... [EOL] value = ... [EOL] [EOL] [EOL] class Tree : [EOL] def __init__ ( self , root , leaves ) : [EOL] self . root = root [EOL] self . leaves = leaves [EOL] [EOL] [EOL] class Node : [EOL] def __init__ ( self , hash , * , parent = None , left_child = None , right_child = None , ) : [EOL] self . hash = hash [EOL] self . parent = parent [EOL] self . left_child = left_child [EOL] self . right_child = right_child [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . hash !r} [string] { self . parent !r} [string] { self . left_child !r} [string] { self . right_child !r} [string] " [EOL] [EOL] [EOL] def compute_merkle_root ( items ) : [EOL] [EOL] return build_tree ( items ) . root . hash [EOL] [EOL] [EOL] def build_tree ( items ) : [EOL] [EOL] current_nodes = leaves = _build_leaves ( items ) [EOL] next_nodes = [ ] [EOL] [EOL] while len ( current_nodes ) > [number] : [EOL] [EOL] for ( node1 , node2 ) in zip ( current_nodes [ [number] : : [number] ] , current_nodes [ [number] : : [number] ] ) : [EOL] parent = Node ( compute_parent_hash ( node1 . hash , node2 . hash ) , left_child = node1 , right_child = node2 , ) [EOL] node1 . parent = parent [EOL] node2 . parent = parent [EOL] next_nodes . append ( parent ) [EOL] [EOL] if len ( current_nodes ) % [number] != [number] : [EOL] next_nodes . append ( current_nodes [ - [number] ] ) [EOL] [EOL] current_nodes = next_nodes [EOL] next_nodes = [ ] [EOL] [EOL] tree = Tree ( current_nodes [ [number] ] , leaves ) [EOL] [EOL] return tree [EOL] [EOL] [EOL] def compute_leaf_hash ( item ) : [EOL] address , value = item [EOL] if not is_canonical_address ( address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if value < [number] or value >= [number] ** [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return keccak ( address + value . to_bytes ( [number] , [string] ) ) [EOL] [EOL] [EOL] def _build_leaves ( items ) : [EOL] sorted_items = sorted ( items ) [EOL] hashes = [ compute_leaf_hash ( item ) for item in sorted_items ] [EOL] return [ Node ( h ) for h in hashes ] [EOL] [EOL] [EOL] def compute_parent_hash ( left_hash , right_hash ) : [EOL] little_child_hash , big_child_hash = sorted ( ( left_hash , right_hash ) ) [EOL] return keccak ( little_child_hash + big_child_hash ) [EOL] [EOL] [EOL] def in_tree ( item , root ) : [EOL] def _in_tree ( item_hash , root ) : [EOL] [EOL] if root is None : [EOL] return False [EOL] [EOL] if root . hash == item_hash : [EOL] return True [EOL] [EOL] return _in_tree ( item_hash , root . left_child ) or _in_tree ( item_hash , root . right_child ) [EOL] [EOL] return _in_tree ( compute_leaf_hash ( item ) , root ) [EOL] [EOL] [EOL] def create_proof ( item , tree ) : [EOL] [EOL] leaf_hash = compute_leaf_hash ( item ) [EOL] leaf = next ( ( leave for leave in tree . leaves if leave . hash == leaf_hash ) , None ) [EOL] [EOL] proof = [ ] [EOL] [EOL] if leaf is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] while leaf . parent is not None : [EOL] parent = leaf . parent [EOL] [EOL] if parent . left_child == leaf : [EOL] if parent . right_child is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] proof . append ( parent . right_child . hash ) [EOL] elif parent . right_child == leaf : [EOL] if parent . left_child is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] proof . append ( parent . left_child . hash ) [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] leaf = leaf . parent [EOL] [EOL] return proof [EOL] [EOL] [EOL] def validate_proof ( item , proof , root_hash ) : [EOL] [EOL] hash = compute_leaf_hash ( item ) [EOL] [EOL] for h in proof : [EOL] hash = compute_parent_hash ( hash , h ) [EOL] [EOL] return hash == root_hash [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.merkle_drop.merkle_tree.Node]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.merkle_drop.merkle_tree.Node]$ 0 $typing.List[src.merkle_drop.merkle_tree.Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $src.merkle_drop.merkle_tree.Node$ 0 0 0 $src.merkle_drop.merkle_tree.Node$ 0 0 0 $src.merkle_drop.merkle_tree.Node$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $src.merkle_drop.merkle_tree.Node$ 0 $src.merkle_drop.merkle_tree.Node$ 0 0 0 $src.merkle_drop.merkle_tree.Node$ 0 $src.merkle_drop.merkle_tree.Node$ 0 0 0 $src.merkle_drop.merkle_tree.Node$ 0 $src.merkle_drop.merkle_tree.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Tree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , List [EOL] import merkle_tree [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List [EOL] [EOL] from . merkle_tree import Item [EOL] [EOL] AirdropData = Dict [ bytes , int ] [EOL] [EOL] [EOL] def get_item ( address , airdrop_data ) : [EOL] return Item ( address , airdrop_data [ address ] ) [EOL] [EOL] [EOL] def to_items ( airdrop_data ) : [EOL] return [ Item ( address , value ) for address , value in airdrop_data . items ( ) ] [EOL] [EOL] [EOL] def get_balance ( address , airdrop_data ) : [EOL] return airdrop_data . get ( address , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $merkle_tree.Item$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[merkle_tree.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from merkle_drop . status import get_merkle_drop_status [EOL] [EOL] [EOL] def test_status ( web3 , merkle_drop_contract , dropped_token_contract , root_hash_for_tree_data , decay_start_time , decay_duration , premint_token_value , ) : [EOL] status = get_merkle_drop_status ( web3 , merkle_drop_contract . address ) [EOL] [EOL] assert status [ [string] ] == merkle_drop_contract . address [EOL] assert status [ [string] ] == dropped_token_contract . address [EOL] assert status [ [string] ] == root_hash_for_tree_data [EOL] assert status [ [string] ] == decay_start_time [EOL] assert status [ [string] ] == decay_duration [EOL] assert status [ [string] ] == premint_token_value [EOL] assert status [ [string] ] == premint_token_value [EOL] assert status [ [string] ] == [number] [EOL] assert status [ [string] ] == premint_token_value [EOL] assert status [ [string] ] == [string] [EOL] assert status [ [string] ] == [string] [EOL] assert status [ [string] ] == [number] [EOL] assert status [ [string] ] <= premint_token_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import eth_tester [EOL] import pytest [EOL] from eth_utils import to_canonical_address [EOL] [EOL] from merkle_drop . merkle_tree import Item , build_tree , create_proof , validate_proof [EOL] [EOL] [comment] [EOL] assert eth_tester . backends . pyevm . main . GENESIS_GAS_LIMIT < [number] * [number] ** [number] [EOL] eth_tester . backends . pyevm . main . GENESIS_GAS_LIMIT = [number] * [number] ** [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def canonical_addresses ( accounts ) : [EOL] [docstring] [EOL] return [ to_canonical_address ( account ) for account in accounts ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tree_data ( canonical_addresses ) : [EOL] [comment] [EOL] return [ Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) , ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tree_data_small_values ( canonical_addresses ) : [EOL] [comment] [EOL] return [ Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) , ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def other_data ( canonical_addresses ) : [EOL] [comment] [EOL] return [ Item ( canonical_addresses [ [number] ] , [number] ) , Item ( canonical_addresses [ [number] ] , [number] ) ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def proofs_for_tree_data ( tree_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] proofs = [ create_proof ( item , tree ) for item in tree_data ] [EOL] [EOL] assert all ( validate_proof ( item , proof , tree . root . hash ) for item , proof in zip ( tree_data , proofs ) ) [EOL] [EOL] return proofs [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def proofs_for_tree_data_small_values ( tree_data_small_values ) : [EOL] tree = build_tree ( tree_data_small_values ) [EOL] proofs = [ create_proof ( item , tree ) for item in tree_data_small_values ] [EOL] [EOL] assert all ( validate_proof ( item , proof , tree . root . hash ) for item , proof in zip ( tree_data_small_values , proofs ) ) [EOL] [EOL] return proofs [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def eligible_address_0 ( tree_data ) : [EOL] return tree_data [ [number] ] . address [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def eligible_value_0 ( tree_data ) : [EOL] return tree_data [ [number] ] . value [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def proof_0 ( proofs_for_tree_data ) : [EOL] return proofs_for_tree_data [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def root_hash_for_tree_data ( tree_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] return tree . root . hash [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def root_hash_for_tree_data_small_values ( tree_data_small_values ) : [EOL] tree = build_tree ( tree_data_small_values ) [EOL] return tree . root . hash [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def premint_token_owner ( accounts ) : [EOL] return accounts [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def premint_token_value ( ) : [EOL] [comment] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def premint_token_small_value ( ) : [EOL] [comment] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def dropped_token_contract ( deploy_contract , premint_token_owner , premint_token_value , premint_token_small_value ) : [EOL] [comment] [EOL] [comment] [EOL] contract = deploy_contract ( [string] , constructor_args = ( [string] , [string] , [number] , premint_token_owner , premint_token_value + premint_token_small_value , ) , ) [EOL] [EOL] return contract [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def decay_start_time ( ) : [EOL] [comment] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def decay_duration ( ) : [EOL] [comment] [EOL] return [number] * [number] * [number] * [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def merkle_drop_contract ( deploy_contract , root_hash_for_tree_data , dropped_token_contract , premint_token_owner , premint_token_value , decay_start_time , decay_duration , ) : [EOL] [comment] [EOL] contract = deploy_contract ( [string] , constructor_args = ( dropped_token_contract . address , premint_token_value , root_hash_for_tree_data , decay_start_time , decay_duration , ) , ) [EOL] [EOL] dropped_token_contract . functions . storeAddressOfMerkleDrop ( contract . address ) . transact ( ) [EOL] [EOL] dropped_token_contract . functions . transfer ( contract . address , premint_token_value ) . transact ( { [string] : premint_token_owner } ) [EOL] assert ( dropped_token_contract . functions . balanceOf ( contract . address ) . call ( ) == premint_token_value ) [EOL] [EOL] return contract [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def merkle_drop_contract_small_values ( deploy_contract , root_hash_for_tree_data_small_values , dropped_token_contract , premint_token_owner , premint_token_small_value , decay_start_time , decay_duration , ) : [EOL] [comment] [EOL] contract = deploy_contract ( [string] , constructor_args = ( dropped_token_contract . address , premint_token_small_value , root_hash_for_tree_data_small_values , decay_start_time , decay_duration , ) , ) [EOL] [EOL] dropped_token_contract . functions . transfer ( contract . address , premint_token_small_value ) . transact ( { [string] : premint_token_owner } ) [EOL] assert ( dropped_token_contract . functions . balanceOf ( contract . address ) . call ( ) == premint_token_small_value ) [EOL] return contract [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import math [EOL] [EOL] import eth_tester . exceptions [EOL] import pytest [EOL] from eth_utils import to_checksum_address [EOL] from web3 . exceptions import BadFunctionCallOutput [EOL] [EOL] [EOL] @ pytest . fixture ( ) def merkle_drop_contract_already_withdrawn ( merkle_drop_contract , dropped_token_contract , eligible_address_0 , eligible_value_0 , proof_0 , ) : [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] assert ( dropped_token_contract . functions . balanceOf ( eligible_address_0 ) . call ( ) == eligible_value_0 ) [EOL] [EOL] return merkle_drop_contract [EOL] [EOL] [EOL] @ pytest . fixture ( ) def time_travel_chain_to_decay_multiplier ( chain , decay_start_time , decay_duration ) : [EOL] def time_travel ( decay_multiplier ) : [EOL] time = int ( decay_start_time + decay_duration * decay_multiplier ) [EOL] chain . time_travel ( time ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] return time_travel [EOL] [EOL] [EOL] @ pytest . fixture ( ) def time_travel_chain_past_decay_multiplier ( chain , decay_start_time , decay_duration ) : [EOL] def time_travel ( decay_multiplier ) : [EOL] time = int ( decay_start_time + decay_duration * decay_multiplier ) [EOL] chain . time_travel ( time ) [EOL] chain . mine_block ( ) [EOL] chain . mine_block ( ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] return time_travel [EOL] [EOL] [EOL] def decayed_value ( value , decay_multiplier , round_up ) : [EOL] decayed_value = value * ( [number] - decay_multiplier ) [EOL] if round_up : [EOL] decayed_value = math . ceil ( decayed_value ) [EOL] decayed_value = math . floor ( decayed_value ) [EOL] return decayed_value [EOL] [EOL] [EOL] def test_proof_entitlement ( merkle_drop_contract , tree_data , proofs_for_tree_data ) : [EOL] [EOL] for i in range ( len ( proofs_for_tree_data ) ) : [EOL] address = tree_data [ i ] . address [EOL] value = tree_data [ i ] . value [EOL] proof = proofs_for_tree_data [ i ] [EOL] assert merkle_drop_contract . functions . verifyEntitled ( address , value , proof ) . call ( ) [EOL] [EOL] [EOL] def test_incorrect_value_entitlement ( merkle_drop_contract , tree_data , proofs_for_tree_data ) : [EOL] address = tree_data [ [number] ] . address [EOL] incorrect_value = tree_data [ [number] ] . value + [number] [EOL] proof = proofs_for_tree_data [ [number] ] [EOL] [EOL] assert ( merkle_drop_contract . functions . verifyEntitled ( address , incorrect_value , proof ) . call ( ) is False ) [EOL] [EOL] [EOL] def test_incorrect_proof_entitlement ( merkle_drop_contract , other_data , proofs_for_tree_data ) : [EOL] address = other_data [ [number] ] . address [EOL] value = other_data [ [number] ] . value [EOL] incorrect_proof = proofs_for_tree_data [ [number] ] [EOL] [EOL] assert ( merkle_drop_contract . functions . verifyEntitled ( address , value , incorrect_proof ) . call ( ) is False ) [EOL] [EOL] [EOL] def test_withdraw ( merkle_drop_contract , tree_data , proofs_for_tree_data , dropped_token_contract ) : [EOL] for i in range ( len ( proofs_for_tree_data ) ) : [EOL] [EOL] merkle_drop_balance = dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) [EOL] [EOL] address = tree_data [ i ] . address [EOL] value = tree_data [ i ] . value [EOL] proof = proofs_for_tree_data [ i ] [EOL] merkle_drop_contract . functions . withdraw ( value , proof ) . transact ( { [string] : address } ) [EOL] [EOL] assert dropped_token_contract . functions . balanceOf ( address ) . call ( ) == value [EOL] assert ( dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) == merkle_drop_balance - value ) [EOL] [EOL] [EOL] def test_withdraw_already_withdrawn ( merkle_drop_contract_already_withdrawn , eligible_address_0 , eligible_value_0 , proof_0 , ) : [EOL] with pytest . raises ( eth_tester . exceptions . TransactionFailed ) : [EOL] merkle_drop_contract_already_withdrawn . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] [EOL] def test_withdraw_wrong_proof ( merkle_drop_contract_already_withdrawn , other_data , proof_0 ) : [EOL] with pytest . raises ( eth_tester . exceptions . TransactionFailed ) : [EOL] merkle_drop_contract_already_withdrawn . functions . withdraw ( other_data [ [number] ] . value , proof_0 ) . transact ( { [string] : other_data [ [number] ] . address } ) [EOL] [EOL] [EOL] def test_withdraw_event ( merkle_drop_contract , web3 , eligible_address_0 , eligible_value_0 , proof_0 ) : [EOL] [EOL] latest_block_number = web3 . eth . blockNumber [EOL] [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] event = merkle_drop_contract . events . Withdraw . createFilter ( fromBlock = latest_block_number ) . get_all_entries ( ) [ [number] ] [ [string] ] [EOL] [EOL] assert event [ [string] ] == to_checksum_address ( eligible_address_0 ) [EOL] assert event [ [string] ] == eligible_value_0 [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , True ) , ( [number] , True ) , ( [number] , True ) , ( [number] , True ) , ( [number] , True ) , ( [number] , False ) , ( [number] , False ) , ( [number] , False ) , ( [number] , False ) , ( [number] , False ) , ] , ) def test_entitlement_with_decay ( merkle_drop_contract , decay_start_time , decay_duration , decay_multiplier , round_up ) : [EOL] value = [number] [EOL] time = int ( decay_start_time + decay_duration * decay_multiplier ) [EOL] [EOL] expected_entitlement = decayed_value ( value , decay_multiplier , round_up ) [EOL] [EOL] assert ( merkle_drop_contract . functions . decayedEntitlementAtTime ( value , time , round_up ) . call ( ) == expected_entitlement ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_withdraw_with_decay ( merkle_drop_contract , dropped_token_contract , time_travel_chain_to_decay_multiplier , decay_multiplier , eligible_address_0 , eligible_value_0 , proof_0 , ) : [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] assert dropped_token_contract . functions . balanceOf ( eligible_address_0 ) . call ( ) == decayed_value ( eligible_value_0 , decay_multiplier , False ) [EOL] [EOL] [EOL] def test_entitlement_after_decay ( merkle_drop_contract , decay_start_time , decay_duration ) : [EOL] value = [number] [EOL] decay_multiplier = [number] [EOL] time = int ( decay_start_time + decay_duration * decay_multiplier ) [EOL] assert ( merkle_drop_contract . functions . decayedEntitlementAtTime ( value , time , True ) . call ( ) == [number] ) [EOL] [EOL] [EOL] def test_withdraw_after_decay ( merkle_drop_contract , time_travel_chain_past_decay_multiplier , eligible_address_0 , eligible_value_0 , proof_0 , ) : [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_past_decay_multiplier ( decay_multiplier ) [EOL] [EOL] with pytest . raises ( eth_tester . exceptions . TransactionFailed ) : [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , [number] ] ) def test_burn_unusable_tokens ( merkle_drop_contract , dropped_token_contract , time_travel_chain_to_decay_multiplier , decay_multiplier , ) : [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] [EOL] balance_before = dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] balance_after = dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) [EOL] [EOL] assert balance_after == ( [number] - decay_multiplier ) * balance_before [EOL] [EOL] [EOL] def test_burn_tokens_after_decay_duration ( merkle_drop_contract , dropped_token_contract , time_travel_chain_to_decay_multiplier ) : [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] balance = dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) [EOL] [EOL] assert balance == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] ] ) def test_withdraw_after_burn ( merkle_drop_contract , dropped_token_contract , time_travel_chain_to_decay_multiplier , decay_multiplier , eligible_address_0 , eligible_value_0 , proof_0 , ) : [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] expected_balance = decayed_value ( eligible_value_0 , decay_multiplier , False ) [EOL] [EOL] [comment] [EOL] assert dropped_token_contract . functions . balanceOf ( eligible_address_0 ) . call ( ) == pytest . approx ( expected_balance , abs = [number] ) [EOL] [EOL] [EOL] def test_balance_null_after_withdraw_and_burn ( merkle_drop_contract , dropped_token_contract , eligible_address_0 , eligible_value_0 , proof_0 , time_travel_chain_to_decay_multiplier , ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] assert ( dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) == [number] ) [EOL] [EOL] [EOL] def test_everyone_can_withdraw_after_burns ( merkle_drop_contract , dropped_token_contract , eligible_address_0 , eligible_value_0 , proof_0 , tree_data , proofs_for_tree_data , time_travel_chain_to_decay_multiplier , ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] for i in range ( [number] , len ( proofs_for_tree_data ) ) : [EOL] address = tree_data [ i ] . address [EOL] value = tree_data [ i ] . value [EOL] proof = proofs_for_tree_data [ i ] [EOL] [EOL] merkle_drop_contract . functions . withdraw ( value , proof ) . transact ( { [string] : address } ) [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] assert ( dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) == [number] ) [EOL] [EOL] [EOL] def test_burn_enough_token ( merkle_drop_contract , dropped_token_contract , eligible_address_0 , eligible_value_0 , proof_0 , time_travel_chain_to_decay_multiplier , premint_token_value , ) : [EOL] [comment] [EOL] [EOL] decay_multiplier = [number] [EOL] time_travel_chain_to_decay_multiplier ( decay_multiplier ) [EOL] merkle_drop_contract . functions . withdraw ( eligible_value_0 , proof_0 ) . transact ( { [string] : eligible_address_0 } ) [EOL] [EOL] merkle_drop_contract . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] assert ( dropped_token_contract . functions . balanceOf ( merkle_drop_contract . address ) . call ( ) == ( premint_token_value - eligible_value_0 ) * [number] ) [EOL] [EOL] [EOL] def test_self_destruct ( merkle_drop_contract_already_withdrawn , eligible_address_0 , time_travel_chain_past_decay_multiplier , ) : [EOL] time_travel_chain_past_decay_multiplier ( [number] ) [EOL] assert ( merkle_drop_contract_already_withdrawn . functions . withdrawn ( eligible_address_0 ) . call ( ) is True ) [EOL] [EOL] merkle_drop_contract_already_withdrawn . functions . deleteContract ( ) . transact ( ) [EOL] [EOL] with pytest . raises ( BadFunctionCallOutput ) : [EOL] [comment] [EOL] merkle_drop_contract_already_withdrawn . functions . withdrawn ( eligible_address_0 ) . call ( ) [EOL] [EOL] [EOL] def test_self_destruct_too_soon ( merkle_drop_contract ) : [EOL] with pytest . raises ( eth_tester . exceptions . TransactionFailed ) : [EOL] merkle_drop_contract . functions . deleteContract ( ) . transact ( ) [EOL] [EOL] [EOL] def test_yoichis_finding ( merkle_drop_contract_small_values , time_travel_chain_to_decay_multiplier , dropped_token_contract , proofs_for_tree_data_small_values , tree_data_small_values , ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] merkle_drop = merkle_drop_contract_small_values [EOL] time_travel_chain_to_decay_multiplier ( [number] ) [EOL] [EOL] merkle_drop . functions . burnUnusableTokens ( ) . transact ( ) [EOL] [EOL] assert dropped_token_contract . functions . balanceOf ( merkle_drop . address ) . call ( ) == [number] [EOL] [EOL] for i in range ( [number] , len ( proofs_for_tree_data_small_values ) ) : [EOL] address = tree_data_small_values [ i ] . address [EOL] value = tree_data_small_values [ i ] . value [EOL] proof = proofs_for_tree_data_small_values [ i ] [EOL] merkle_drop . functions . withdraw ( value , proof ) . transact ( { [string] : address } ) [EOL] assert dropped_token_contract . functions . balanceOf ( address ) . call ( ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Tuple , Any [EOL] import typing [EOL] import typing_extensions [EOL] from merkle_drop . deploy import deploy_merkle_drop [EOL] [EOL] [EOL] def test_deploy ( web3 ) : [EOL] zero_address = [string] [EOL] initial_balance = [number] [EOL] root = [string] [EOL] decay_start = [number] [EOL] decay_duration = [number] [EOL] constructor_args = ( zero_address , initial_balance , root , decay_start , decay_duration , ) [EOL] merkle_drop = deploy_merkle_drop ( web3 = web3 , constructor_args = constructor_args ) [EOL] [EOL] assert merkle_drop . functions . initialBalance ( ) . call ( ) == initial_balance [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] from eth_utils import keccak [EOL] [EOL] from merkle_drop . merkle_tree import ( Item , build_tree , compute_leaf_hash , compute_merkle_root , compute_parent_hash , create_proof , in_tree , validate_proof , ) [EOL] [EOL] [EOL] @ pytest . fixture def tree_data ( ) : [EOL] return [ Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , [number] ) , ] [EOL] [EOL] [EOL] @ pytest . fixture def other_data ( ) : [EOL] return [ Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , [number] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] , [string] , [string] ) , [ ( [string] , [string] , keccak ( [string] ) ) , ( [string] , [string] , keccak ( [string] ) ) ] , ) def test_parent_hash ( left_hash , right_hash , parent_hash ) : [EOL] assert compute_parent_hash ( left_hash , right_hash ) == parent_hash [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] , [string] ) , ( ( Item ( [string] * [number] , [number] ) , keccak ( [string] * [number] + [string] * [number] + [string] ) ) , ( Item ( [string] * [number] , [number] ) , keccak ( [string] * [number] + [string] * [number] + [string] ) ) , ( Item ( [string] * [number] , [number] ) , keccak ( [string] * [number] + [string] * [number] + [string] ) ) , ) , ) def test_leaf_hash ( item , leaf_hash ) : [EOL] assert compute_leaf_hash ( item ) == leaf_hash [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , [number] ) , Item ( [string] * [number] , - [number] ) , Item ( [string] * [number] , [number] ** [number] ) , ) , ) def test_invalid_leaf_hash ( item ) : [EOL] with pytest . raises ( ValueError ) : [EOL] compute_leaf_hash ( item ) [EOL] [EOL] [EOL] def test_in_tree ( tree_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] [EOL] assert all ( in_tree ( item , tree . root ) for item in tree_data ) [EOL] [EOL] [EOL] def test_not_in_tree ( tree_data , other_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] [EOL] assert not any ( in_tree ( item , tree . root ) for item in other_data ) [EOL] [EOL] [EOL] def test_valid_proof ( tree_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] proofs = [ create_proof ( item , tree ) for item in tree_data ] [EOL] [EOL] assert all ( validate_proof ( item , proof , tree . root . hash ) for item , proof in zip ( tree_data , proofs ) ) [EOL] [EOL] [EOL] def test_invalid_proof ( tree_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] [EOL] item = next ( iter ( tree_data ) ) [EOL] assert not validate_proof ( item , [ ] , tree . root . hash ) [EOL] [EOL] [EOL] def test_wrong_proof ( tree_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] proofs = [ create_proof ( item , tree ) for item in tree_data ] [EOL] [EOL] item = next ( iter ( tree_data ) ) [EOL] assert not validate_proof ( item , proofs [ [number] ] , tree . root . hash ) [EOL] [EOL] [EOL] def test_wrong_value ( tree_data , other_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] proofs = [ create_proof ( item , tree ) for item in tree_data ] [EOL] [EOL] item = next ( iter ( other_data ) ) [EOL] assert not validate_proof ( item , proofs [ [number] ] , tree . root . hash ) [EOL] [EOL] [EOL] def test_can_not_create_proof_for_missing_item ( tree_data , other_data ) : [EOL] tree = build_tree ( tree_data ) [EOL] with pytest . raises ( ValueError ) : [EOL] create_proof ( other_data [ [number] ] , tree ) [EOL] [EOL] [EOL] def test_tree_is_sorted ( tree_data ) : [EOL] root = compute_merkle_root ( tree_data ) [EOL] [EOL] reversed_tree_data = list ( reversed ( tree_data ) ) [EOL] assert reversed_tree_data != tree_data [EOL] reversed_root = compute_merkle_root ( reversed_tree_data ) [EOL] [EOL] assert reversed_root == root [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0