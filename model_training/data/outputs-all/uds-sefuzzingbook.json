[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import random [EOL] [EOL] def set_fixed_seed ( seed = [number] ) : [EOL] [comment] [EOL] random . seed ( seed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] [EOL] from IPython import get_ipython [EOL] from IPython . core . interactiveshell import InteractiveShell [EOL] [EOL] import nbformat [EOL] import argparse [EOL] [EOL] from graphviz import Digraph , Source [EOL] [EOL] RE_IMPORT = re . compile ( [string] , re . MULTILINE ) [EOL] RE_FROM = re . compile ( [string] , re . MULTILINE ) [EOL] [EOL] [EOL] def notebook_dependencies ( notebook_name , include_minor_dependencies = True , path = None ) : [EOL] [comment] [EOL] notebook_path = notebook_name [EOL] [EOL] [comment] [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] shell = InteractiveShell . instance ( ) [EOL] [EOL] modules = set ( ) [EOL] for cell in notebook . cells : [EOL] if cell . cell_type == [string] : [EOL] [comment] [EOL] code = shell . input_transformer_manager . transform_cell ( cell . source ) [EOL] if not include_minor_dependencies and code . find ( [string] ) >= [number] : [EOL] continue [EOL] for match in re . finditer ( RE_IMPORT , code ) : [EOL] modules . add ( match . group ( [number] ) ) [EOL] for match in re . finditer ( RE_FROM , code ) : [EOL] modules . add ( match . group ( [number] ) ) [EOL] [EOL] return modules [EOL] [EOL] def print_notebook_dependencies ( notebooks ) : [EOL] for notebook_name in notebooks : [EOL] for module in notebook_dependencies ( notebook_name ) : [EOL] print ( module ) [EOL] [EOL] [EOL] def get_title ( notebook ) : [EOL] [docstring] [EOL] contents = get_text_contents ( notebook ) [EOL] match = re . search ( [string] , contents , re . MULTILINE ) [EOL] if match is None : [EOL] print ( notebook + [string] , file = sys . stderr ) [EOL] return notebook [EOL] [EOL] title = match . group ( [number] ) . replace ( [string] , [string] ) [EOL] [comment] [EOL] return title [EOL] [EOL] def get_text_contents ( notebook ) : [EOL] with io . open ( notebook , [string] , encoding = [string] ) as f : [EOL] nb = nbformat . read ( f , as_version = [number] ) [EOL] [EOL] contents = [string] [EOL] for cell in nb . cells : [EOL] if cell . cell_type == [string] : [EOL] contents += [string] . join ( cell . source ) + [string] [EOL] [EOL] [comment] [EOL] [EOL] return contents [EOL] [EOL] [EOL] def draw_notebook_dependencies ( notebooks , format = [string] , transitive_reduction = True , clusters = True ) : [EOL] dot = Digraph ( comment = [string] ) [EOL] [comment] [EOL] [EOL] node_attrs = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] cluster = None [EOL] [EOL] cluster_attrs = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] for notebook_name in notebooks : [EOL] dirname = os . path . dirname ( notebook_name ) [EOL] basename = os . path . splitext ( os . path . basename ( notebook_name ) ) [ [number] ] [EOL] title = get_title ( notebook_name ) [EOL] if clusters : [EOL] if title . startswith ( [string] ) : [EOL] if cluster is not None : [EOL] cluster . attr ( ** cluster_attrs ) [EOL] dot . subgraph ( cluster ) [EOL] [EOL] cluster = Digraph ( name = [string] + basename ) [EOL] cluster . node ( basename , label = title , URL = [string] % basename , tooltip = basename , shape = [string] , fontname = [string] ) [EOL] [EOL] elif cluster is not None : [EOL] cluster . node ( basename ) [EOL] [EOL] for module in notebook_dependencies ( notebook_name , include_minor_dependencies = False ) : [EOL] module_file = os . path . join ( dirname , module + [string] ) [EOL] if module_file in notebooks : [EOL] module_title = get_title ( module_file ) [EOL] dot . node ( basename , URL = [string] % basename , label = title , tooltip = basename , ** node_attrs ) [EOL] dot . node ( module , URL = [string] % module , label = module_title , tooltip = module , ** node_attrs ) [EOL] dot . edge ( module , basename ) [EOL] [EOL] if cluster is not None : [EOL] cluster . attr ( ** cluster_attrs ) [EOL] dot . subgraph ( cluster ) [EOL] [EOL] if transitive_reduction : [EOL] dot . format = [string] [EOL] dot . save ( [string] ) [EOL] os . system ( [string] ) [EOL] dot = Source . from_file ( [string] ) [EOL] os . remove ( [string] ) [EOL] [EOL] dot . format = format [EOL] dot . render ( [string] ) [EOL] os . system ( [string] + format ) [EOL] os . remove ( [string] ) [EOL] os . remove ( [string] + format ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . graph : [EOL] draw_notebook_dependencies ( args . notebooks , args . graph_format , args . transitive_reduction , args . cluster_by_parts ) [EOL] else : [EOL] print_notebook_dependencies ( args . notebooks ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] [EOL] from IPython import get_ipython [EOL] from IPython . core . interactiveshell import InteractiveShell [EOL] [EOL] import nbformat [EOL] import argparse [EOL] import base64 [EOL] [EOL] SYNOPSIS_TITLE = [string] [EOL] SUMMARY_TITLE = [string] [EOL] [EOL] img_count = [number] [EOL] [EOL] def cell_to_text ( cell , notebook_path , notebook_basename ) : [EOL] [docstring] [EOL] if cell . cell_type != [string] : [EOL] return cell . source + [string] [EOL] [EOL] [comment] [EOL] synopsis = [string] + cell . source . replace ( [string] , [string] ) + [string] [EOL] output_text = [string] [EOL] [EOL] for output in cell . outputs : [EOL] text = None [EOL] [EOL] [comment] [EOL] if text is None : [EOL] svg = None [EOL] try : [EOL] svg = output . data [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] except AttributeError : [EOL] pass [EOL] if svg is not None : [EOL] global img_count [EOL] [EOL] svg_basename = ( notebook_basename + [string] + repr ( img_count ) + [string] ) [EOL] png_basename = ( notebook_basename + [string] + repr ( img_count ) + [string] ) [EOL] img_count += [number] [EOL] [EOL] svg_filename = os . path . join ( os . path . dirname ( notebook_path ) , [string] , svg_basename ) [EOL] png_filename = os . path . join ( os . path . dirname ( notebook_path ) , [string] , png_basename ) [EOL] [EOL] print ( [string] , svg_filename ) [EOL] with open ( svg_filename , [string] ) as f : [EOL] f . write ( svg ) [EOL] [EOL] print ( [string] , png_filename ) [EOL] os . system ( [string] + svg_filename + [string] + png_filename ) [EOL] [EOL] if [string] in os . environ : [EOL] [comment] [EOL] text = [string] + [string] + png_basename + [string] [EOL] else : [EOL] text = [string] + [string] + svg_basename + [string] [EOL] [EOL] [comment] [EOL] if text is None : [EOL] png = None [EOL] try : [EOL] png = output . data [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] except AttributeError : [EOL] pass [EOL] if png is not None : [EOL] png_basename = ( notebook_basename + [string] + repr ( img_count ) + [string] ) [EOL] img_count += [number] [EOL] [EOL] png_filename = os . path . join ( os . path . dirname ( notebook_path ) , [string] , png_basename ) [EOL] [EOL] print ( [string] , png_filename ) [EOL] with open ( png_filename , [string] ) as f : [EOL] f . write ( base64 . b64decode ( png , validate = True ) ) [EOL] text = [string] + [string] + png_basename + [string] [EOL] [EOL] [comment] [EOL] if text is None : [EOL] try : [EOL] text = output . text [EOL] except AttributeError : [EOL] pass [EOL] [EOL] [comment] [EOL] if text is None : [EOL] try : [EOL] text = output . data [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] if text is not None : [EOL] output_text += text + [string] [EOL] [EOL] if output_text : [EOL] if output_text . startswith ( [string] ) : [EOL] synopsis += [string] + output_text + [string] [EOL] else : [EOL] synopsis += [string] + output_text + [string] [EOL] [EOL] return synopsis [EOL] [EOL] [EOL] def notebook_synopsis ( notebook_name ) : [EOL] notebook_path = notebook_name [EOL] [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] synopsis = [string] [EOL] in_synopsis = False [EOL] first_synopsis = True [EOL] img_count = [number] [EOL] [EOL] notebook_noext = os . path . splitext ( notebook_path ) [ [number] ] [EOL] notebook_basename = os . path . basename ( notebook_noext ) [EOL] [EOL] for cell in notebook . cells : [EOL] if not first_synopsis and cell . source . startswith ( SYNOPSIS_TITLE ) : [EOL] in_synopsis = True [EOL] synopsis = SYNOPSIS_TITLE + [string] % notebook_basename [EOL] synopsis += cell . source [ len ( SYNOPSIS_TITLE ) : ] + [string] [EOL] continue [EOL] elif cell . source . startswith ( [string] ) : [EOL] in_synopsis = False [EOL] first_synopsis = False [EOL] [EOL] if in_synopsis : [EOL] synopsis += cell_to_text ( cell , notebook_path , notebook_basename ) [EOL] [EOL] synopsis = synopsis . replace ( [string] , [string] ) [EOL] [EOL] return synopsis [EOL] [EOL] [EOL] def update_synopsis ( notebook_name , synopsis ) : [EOL] notebook_path = notebook_name [EOL] global img_count [EOL] img_count = [number] [EOL] [EOL] [comment] [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] for i , cell in enumerate ( notebook . cells ) : [EOL] if cell . source . startswith ( [string] ) : [EOL] [comment] [EOL] if cell . source == synopsis : [EOL] return [EOL] cell . source = synopsis [EOL] break [EOL] elif cell . source . startswith ( [string] ) : [EOL] [comment] [EOL] new_cell = nbformat . v4 . new_markdown_cell ( source = synopsis ) [EOL] notebook . cells = ( notebook . cells [ : i ] + [ new_cell ] + notebook . cells [ i : ] ) [EOL] break [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] f . write ( nbformat . writes ( notebook ) ) [EOL] [EOL] print ( [string] + notebook_path ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] for notebook in args . notebooks : [EOL] synopsis = notebook_synopsis ( notebook ) [EOL] if not synopsis : [EOL] continue [EOL] [EOL] if args . update : [EOL] update_synopsis ( notebook , synopsis ) [EOL] else : [EOL] print ( synopsis , end = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] import string [EOL] import nbformat [EOL] [EOL] [comment] [EOL] from spellchecker import SpellChecker [EOL] [EOL] KNOWN_WORDS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] spell = SpellChecker ( ) [EOL] spell . word_frequency . load_words ( KNOWN_WORDS ) [EOL] [EOL] def print_utf8 ( s ) : [EOL] sys . stdout . buffer . write ( s . encode ( [string] ) ) [EOL] [EOL] def normalize ( word ) : [EOL] [comment] [EOL] word = word . lower ( ) [EOL] word = [string] . join ( [ c for c in word if c in string . ascii_letters + [string] ] ) [EOL] return word [EOL] [EOL] def get_words ( text ) : [EOL] words = text . split ( ) [EOL] ws = [ ] [EOL] for word in words : [EOL] w = normalize ( word ) [EOL] if w == [string] or len ( w ) > [number] : [EOL] continue [EOL] ws . append ( w ) [EOL] return ws [EOL] [EOL] RE_STUFF = re . compile ( [string] ) [EOL] [EOL] def strip_stuff ( text ) : [EOL] return re . sub ( RE_STUFF , [string] , text ) [EOL] [EOL] def spellcheck_notebook ( notebook_path ) : [EOL] [comment] [EOL] if notebook_path == [string] : [EOL] notebook = nbformat . read ( sys . stdin , [number] ) [EOL] else : [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] for cell in notebook . cells : [EOL] if cell . cell_type != [string] : [EOL] continue [EOL] [EOL] text = strip_stuff ( cell . source ) [EOL] words = get_words ( text ) [EOL] misspelled = spell . unknown ( words ) [EOL] if len ( misspelled ) > [number] : [EOL] [comment] [EOL] for word in misspelled : [EOL] correction = spell . correction ( word ) [EOL] if word == correction : [EOL] print ( [string] % ( notebook_path , repr ( word ) ) ) [EOL] else : [EOL] print ( [string] % ( notebook_path , repr ( word ) , repr ( correction ) ) ) [EOL] [EOL] if __name__ == [string] : [EOL] for notebook in sys . argv [ [number] : ] : [EOL] spellcheck_notebook ( notebook ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import argparse [EOL] import os . path [EOL] import time [EOL] import datetime [EOL] import re [EOL] import sys [EOL] import io [EOL] import html [EOL] [EOL] try : [EOL] import nbformat [EOL] have_nbformat = True [EOL] except : [EOL] have_nbformat = False [EOL] [EOL] [EOL] [EOL] [comment] [EOL] booktitle = [string] [EOL] authors = [string] [EOL] site_html = [string] [EOL] github_html = [string] [EOL] notebook_html = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] menu_start = [string] [EOL] [EOL] menu_end = [string] [EOL] [EOL] site_header_template = menu_start + [string] + menu_end [EOL] [EOL] [comment] [EOL] chapter_header_template = menu_start + [string] + menu_end [EOL] [EOL] [EOL] [comment] [EOL] site_citation_template = [string] [EOL] [EOL] chapter_citation_template = [string] [EOL] [EOL] common_footer_template = [string] [EOL] [EOL] chapter_footer_template = common_footer_template + chapter_citation_template [EOL] site_footer_template = common_footer_template + site_citation_template [EOL] [EOL] from nbdepend import get_text_contents , get_title [EOL] [EOL] def get_description ( notebook ) : [EOL] [docstring] [EOL] contents = get_text_contents ( notebook ) [EOL] match = re . search ( [string] , contents , re . MULTILINE ) [EOL] if match is None : [EOL] desc = contents [EOL] else : [EOL] desc = match . group ( [number] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] desc = re . sub ( [string] , [string] , desc ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] desc = re . sub ( [string] , [string] , desc ) [EOL] [comment] [EOL] return desc [EOL] [EOL] def get_sections ( notebook ) : [EOL] [docstring] [EOL] contents = get_text_contents ( notebook ) [EOL] matches = re . findall ( [string] , contents , re . MULTILINE ) [EOL] if len ( matches ) >= [number] : [EOL] [comment] [EOL] pass [EOL] else : [EOL] [comment] [EOL] matches = re . findall ( [string] , contents , re . MULTILINE ) [EOL] [EOL] sections = [ match . replace ( [string] , [string] ) for match in matches ] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if [string] in sections : [EOL] sections = [ [string] ] + [ sec for sec in sections if sec != [string] ] [EOL] return sections [EOL] [EOL] [EOL] def anchor ( title ) : [EOL] [docstring] [EOL] return [string] + title . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def decorate ( section , depth ) : [EOL] if depth != [number] : [EOL] return section [EOL] [EOL] if section == [string] : [EOL] section = [string] + section [EOL] elif section == [string] : [EOL] section = [string] + section [EOL] elif section == [string] : [EOL] section = [string] + section [EOL] elif section == [string] : [EOL] section = [string] + section [EOL] elif section == [string] : [EOL] section = [string] + section [EOL] else : [EOL] section = [string] + section [EOL] [EOL] return section [EOL] [EOL] [comment] [EOL] def bibtex_escape ( authors ) : [EOL] [docstring] [EOL] tex_escape_table = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return [string] . join ( tex_escape_table . get ( c , c ) for c in authors ) [EOL] [EOL] assert bibtex_escape ( [string] ) == [string] [EOL] [EOL] authors_bibtex = bibtex_escape ( authors ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def bibtex_unescape ( contents ) : [EOL] [docstring] [EOL] tex_unescape_table = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for key in tex_unescape_table : [EOL] contents = contents . replace ( key , tex_unescape_table [ key ] ) [EOL] return contents [EOL] [EOL] assert bibtex_unescape ( [string] ) == [string] [EOL] assert bibtex_unescape ( [string] ) == [string] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] RE_IMPORT = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] def add_links_to_imports ( contents ) : [EOL] imports = re . findall ( RE_IMPORT , contents ) [EOL] for module in imports : [EOL] link = None [EOL] if module . startswith ( [string] ) : [EOL] link = [string] [EOL] elif module == [string] : [EOL] link = [string] [EOL] elif module . startswith ( [string] ) : [EOL] [comment] [EOL] link = [string] + module + [string] [EOL] elif module . startswith ( [string] ) : [EOL] [comment] [EOL] link = [string] [EOL] elif module . startswith ( [string] ) : [EOL] [comment] [EOL] link = module [ module . find ( [string] ) + [number] : ] + [string] [EOL] elif module [ [number] ] . islower ( ) : [EOL] [comment] [EOL] link = [string] + module + [string] [EOL] else : [EOL] [comment] [EOL] link = module + [string] [EOL] [EOL] if link is not None : [EOL] contents = contents . replace ( [string] + module + [string] , [string] + link + [string] + module + [string] + [string] ) [EOL] [EOL] return contents [EOL] [EOL] [EOL] [comment] [EOL] def cgi_escape ( text ) : [EOL] [docstring] [EOL] cgi_escape_table = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] return [string] . join ( cgi_escape_table . get ( c , c ) for c in text ) [EOL] [EOL] [EOL] [comment] [EOL] def highlight_synopsis ( text ) : [EOL] synopsis_start = text . find ( [string] ) [EOL] if synopsis_start < [number] : [EOL] return text [comment] [EOL] [EOL] synopsis_end = text . find ( [string] , synopsis_start + [number] ) [EOL] if synopsis_end < [number] : [EOL] return text [comment] [EOL] [EOL] text = ( text [ : synopsis_start ] + [string] + text [ synopsis_start : synopsis_end ] + [string] + text [ synopsis_end : ] ) [EOL] [EOL] [comment] [EOL] orig_synopsis_start = text . find ( [string] , synopsis_end + [number] ) [EOL] orig_synopsis_end = text . find ( [string] , orig_synopsis_start + [number] ) [EOL] [EOL] text = ( text [ : orig_synopsis_start ] + text [ orig_synopsis_end : ] ) [EOL] [EOL] return text [EOL] [EOL] [comment] [EOL] def fix_css ( text ) : [EOL] [comment] [EOL] return text . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] RE_BEGIN_EXCURSION = re . compile ( [string] , re . DOTALL | re . VERBOSE ) [EOL] [EOL] RE_END_EXCURSION = re . compile ( [string] , re . DOTALL | re . VERBOSE ) [EOL] [EOL] def add_excursion_switchers ( text ) : [EOL] text = RE_BEGIN_EXCURSION . sub ( [string] , text ) [EOL] text = RE_END_EXCURSION . sub ( [string] , text ) [EOL] return text [EOL] [EOL] text1 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [number] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] [comment] [EOL] chapter_html_file = args . chapter [ [number] ] [EOL] chapter = os . path . splitext ( os . path . basename ( chapter_html_file ) ) [ [number] ] [EOL] chapter_notebook_file = os . path . join ( [string] , chapter + [string] ) [EOL] notebook_modification_time = os . path . getmtime ( chapter_notebook_file ) [EOL] notebook_modification_datetime = datetime . datetime . fromtimestamp ( notebook_modification_time ) . astimezone ( ) . isoformat ( sep = [string] , timespec = [string] ) [EOL] notebook_modification_year = repr ( datetime . datetime . fromtimestamp ( notebook_modification_time ) . year ) [EOL] [EOL] [comment] [EOL] if args . public_chapters is not None : [EOL] public_chapters = args . public_chapters . split ( ) [EOL] else : [EOL] public_chapters = [ ] [EOL] [EOL] if args . include_ready and args . ready_chapters is not None : [EOL] ready_chapters = args . ready_chapters . split ( ) [EOL] else : [EOL] ready_chapters = [ ] [EOL] [EOL] if args . include_todo and args . todo_chapters is not None : [EOL] todo_chapters = args . todo_chapters . split ( ) [EOL] else : [EOL] todo_chapters = [ ] [EOL] [EOL] new_chapters = args . new_chapters . split ( ) [EOL] beta_chapters = ready_chapters + todo_chapters [EOL] all_chapters = public_chapters [comment] [EOL] include_beta = args . include_ready or args . include_todo [EOL] [EOL] new_suffix = [string] [EOL] todo_suffix = [string] [EOL] ready_suffix = [string] [EOL] [EOL] booktitle_beta = booktitle [EOL] if include_beta : [EOL] booktitle_beta += [string] + todo_suffix [EOL] [EOL] menu_prefix = args . menu_prefix [EOL] if menu_prefix is None : [EOL] menu_prefix = [string] [EOL] [EOL] if args . home : [EOL] header_template = site_header_template [EOL] footer_template = site_footer_template [EOL] else : [EOL] header_template = chapter_header_template [EOL] footer_template = chapter_footer_template [EOL] [EOL] [comment] [EOL] twitter_onclick = [string] [EOL] facebook_onclick = [string] [EOL] if args . home : [EOL] [comment] [EOL] twitter_onclick = [string] [EOL] [EOL] [comment] [EOL] if include_beta : [EOL] site_html += [string] [EOL] [EOL] [comment] [EOL] bookimage = site_html + [string] [EOL] [EOL] [comment] [EOL] if include_beta : [EOL] notebook_html += [string] [EOL] notebook_html += [string] [EOL] [EOL] [comment] [EOL] [EOL] basename = os . path . splitext ( os . path . basename ( chapter_html_file ) ) [ [number] ] [EOL] chapter_ipynb_file = os . path . join ( [string] , basename + [string] ) [EOL] [EOL] all_sections_menu = [string] [EOL] sections = get_sections ( chapter_ipynb_file ) [EOL] current_depth = [number] [EOL] [EOL] for section in sections : [EOL] depth = section . count ( [string] ) [EOL] while section . startswith ( [string] ) or section . startswith ( [string] ) : [EOL] section = section [ [number] : ] [EOL] [EOL] if depth == current_depth : [EOL] all_sections_menu += [string] [EOL] [EOL] if depth > current_depth : [EOL] all_sections_menu += [string] * ( depth - current_depth ) [EOL] [EOL] if depth < current_depth : [EOL] all_sections_menu += [string] * ( current_depth - depth ) [EOL] [EOL] all_sections_menu += [string] % ( anchor ( section ) , decorate ( section , depth ) ) [EOL] current_depth = depth [EOL] [EOL] while current_depth > [number] : [EOL] all_sections_menu += [string] [EOL] current_depth -= [number] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if args . home : [EOL] chapter_html = site_html [EOL] chapter_notebook_ipynb = notebook_html + [string] [EOL] else : [EOL] chapter_html = site_html + [string] + basename + [string] [EOL] chapter_notebook_ipynb = notebook_html + basename + [string] [EOL] [EOL] chapter_title = get_title ( chapter_ipynb_file ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] chapter_title_beta = chapter_title [EOL] is_todo_chapter = include_beta and chapter_ipynb_file in todo_chapters [EOL] is_ready_chapter = include_beta and chapter_ipynb_file in ready_chapters [EOL] if is_todo_chapter : [EOL] chapter_title_beta += [string] + todo_suffix [EOL] if is_ready_chapter : [EOL] chapter_title_beta += [string] + ready_suffix [EOL] [EOL] if args . home : [EOL] link_class = [string] [EOL] else : [EOL] link_class = [string] [EOL] all_chapters_menu = [string] % ( site_html , link_class ) [EOL] structured_all_chapters_menu = all_chapters_menu [EOL] [EOL] this_chapter_counter = [number] [EOL] for counter , menu_ipynb_file in enumerate ( all_chapters ) : [EOL] if menu_ipynb_file == chapter_ipynb_file : [EOL] this_chapter_counter = counter [EOL] [EOL] in_sublist = False [EOL] for counter , menu_ipynb_file in enumerate ( all_chapters ) : [EOL] basename = os . path . splitext ( os . path . basename ( menu_ipynb_file ) ) [ [number] ] [EOL] structured_title = [string] [comment] [EOL] title = [string] [EOL] [EOL] if menu_ipynb_file == chapter_ipynb_file : [EOL] link_class = [string] [EOL] else : [EOL] link_class = [string] [EOL] file_title = get_title ( menu_ipynb_file ) [EOL] [EOL] if menu_ipynb_file in new_chapters : [EOL] file_title += new_suffix [EOL] [EOL] is_part = file_title . startswith ( [string] ) or file_title . startswith ( [string] ) [EOL] if file_title . startswith ( [string] ) : [EOL] file_title = [string] + file_title . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] title += file_title [EOL] structured_title += file_title [EOL] [EOL] beta_indicator = [string] [EOL] if menu_ipynb_file in ready_chapters : [EOL] beta_indicator = [string] + ready_suffix [EOL] if menu_ipynb_file in todo_chapters : [EOL] beta_indicator = [string] + todo_suffix [EOL] menu_html_file = menu_prefix + basename + [string] [EOL] [EOL] if is_part : [EOL] [comment] [EOL] if in_sublist : [EOL] structured_all_chapters_menu += [string] [EOL] in_sublist = False [EOL] structured_all_chapters_menu += [string] % ( menu_html_file , file_title , beta_indicator ) [EOL] structured_all_chapters_menu += [string] [EOL] in_sublist = True [EOL] else : [EOL] structured_item = [string] % ( menu_html_file , link_class , structured_title , beta_indicator ) [EOL] structured_all_chapters_menu += structured_item [EOL] [EOL] item = [string] % ( menu_html_file , link_class , title , beta_indicator ) [EOL] all_chapters_menu += item [EOL] [EOL] if in_sublist : [EOL] structured_all_chapters_menu += [string] [EOL] in_sublist = False [EOL] [EOL] [comment] [EOL] description = html . escape ( get_description ( chapter_ipynb_file ) ) [EOL] [EOL] [comment] [EOL] end_of_exercise = [string] [EOL] [EOL] if args . home : [EOL] share_message = ( [string] + booktitle + [string] + site_html ) [EOL] share_title = booktitle [EOL] else : [EOL] share_message = ( [string] + chapter_title + [string] + chapter_html ) [EOL] share_title = chapter_title [EOL] [EOL] share_twitter = [string] + cgi_escape ( share_message ) [EOL] share_facebook = [string] + cgi_escape ( chapter_html ) [EOL] share_mail = ( [string] + cgi_escape ( share_title ) + [string] + cgi_escape ( share_message ) ) [EOL] [EOL] [comment] [EOL] if args . home : [EOL] page_title = booktitle [EOL] else : [EOL] page_title = chapter_title + [string] + booktitle [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] print ( [string] , chapter_html_file ) [EOL] chapter_contents = open ( chapter_html_file , encoding = [string] ) . read ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] chapter_contents = chapter_contents . replace ( [string] , [string] ) . replace ( [string] , header_template ) . replace ( [string] , footer_template ) . replace ( [string] , all_chapters_menu ) . replace ( [string] , structured_all_chapters_menu ) . replace ( [string] , all_sections_menu ) . replace ( [string] , end_of_exercise ) . replace ( [string] , page_title ) . replace ( [string] , booktitle_beta ) . replace ( [string] , booktitle ) . replace ( [string] , bookimage ) . replace ( [string] , description ) . replace ( [string] , authors ) . replace ( [string] , chapter ) . replace ( [string] , chapter_title ) . replace ( [string] , chapter_title_beta ) . replace ( [string] , chapter_html ) . replace ( [string] , site_html ) . replace ( [string] , notebook_html ) . replace ( [string] , chapter_notebook_ipynb ) . replace ( [string] , github_html ) . replace ( [string] , twitter_onclick ) . replace ( [string] , facebook_onclick ) . replace ( [string] , share_twitter ) . replace ( [string] , share_facebook ) . replace ( [string] , share_mail ) . replace ( [string] , notebook_modification_datetime ) . replace ( [string] , notebook_modification_year ) [EOL] [EOL] [comment] [EOL] chapter_contents = add_links_to_imports ( chapter_contents ) [EOL] [EOL] [comment] [EOL] if args . home : [EOL] chapter_contents = re . sub ( [string] , [string] , chapter_contents ) [EOL] else : [EOL] chapter_contents = re . sub ( [string] , [string] , chapter_contents ) [EOL] [EOL] [comment] [EOL] chapter_contents = bibtex_unescape ( chapter_contents ) [EOL] [EOL] [comment] [EOL] chapter_contents = chapter_contents . replace ( [string] , authors_bibtex ) [EOL] [EOL] [comment] [EOL] chapter_contents = add_excursion_switchers ( chapter_contents ) [EOL] [EOL] [comment] [EOL] chapter_contents = fix_css ( chapter_contents ) [EOL] [EOL] [comment] [EOL] chapter_contents = highlight_synopsis ( chapter_contents ) [EOL] [EOL] [comment] [EOL] if args . home : [EOL] chapter_contents = chapter_contents . replace ( [string] , menu_prefix + [string] ) [EOL] chapter_contents = chapter_contents . replace ( [string] , menu_prefix + [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] chapter_contents = re . sub ( [string] , [string] + page_title + [string] , chapter_contents , [number] ) [EOL] [EOL] beta_warning = None [EOL] if is_todo_chapter : [EOL] beta_warning = [string] + todo_suffix + [string] [EOL] elif is_ready_chapter : [EOL] beta_warning = [string] + ready_suffix + [string] [EOL] [EOL] if beta_warning is not None : [EOL] chapter_contents = chapter_contents . replace ( [string] , [string] + beta_warning ) [EOL] [EOL] [comment] [EOL] print ( [string] , chapter_html_file ) [EOL] open ( chapter_html_file , mode = [string] , encoding = [string] ) . write ( chapter_contents ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import asyncio [EOL] import tempfile [EOL] import sys [EOL] import os [EOL] [EOL] [comment] [EOL] [EOL] import asyncio [EOL] import json [EOL] import os [EOL] import tempfile [EOL] import concurrent . futures [EOL] import nbconvert [EOL] [EOL] from pyppeteer import launch [EOL] from traitlets import default [EOL] import pikepdf [EOL] from nbconvert . exporters import Exporter [EOL] [EOL] import re [EOL] [EOL] RE_HTML_LINK = re . compile ( [string] ) [EOL] [EOL] def fix_html ( contents ) : [EOL] [comment] [EOL] return RE_HTML_LINK . sub ( [string] , contents ) [EOL] [EOL] RE_PDF_LINK = re . compile ( [string] ) [EOL] [EOL] def fix_pdf ( contents ) : [EOL] [comment] [EOL] return RE_PDF_LINK . sub ( [string] , contents ) [EOL] [EOL] [EOL] async def html_to_pdf ( html_file , pdf_file ) : [EOL] [docstring] [EOL] browser = await launch ( handleSIGINT = False , handleSIGTERM = False , handleSIGHUP = False ) [EOL] page = await browser . newPage ( ) [EOL] await page . setViewport ( dict ( width = [number] , height = [number] ) ) [EOL] [EOL] [comment] [EOL] await page . emulateMedia ( [string] ) [EOL] [EOL] await page . goto ( f" [string] { html_file }" , { [string] : [ [string] ] } ) [EOL] [EOL] page_margins = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] dimensions = await page . evaluate ( [string] ) [EOL] width = dimensions [ [string] ] [EOL] height = dimensions [ [string] ] [EOL] [EOL] await page . addStyleTag ( { [string] : [string] } ) [EOL] [EOL] await page . pdf ( { [string] : pdf_file , [string] : width , [string] : min ( height , [number] * [number] ) , [string] : True , [string] : page_margins , } ) [EOL] [EOL] await browser . close ( ) [EOL] [EOL] [EOL] def attach_notebook ( pdf_in , pdf_out , notebook ) : [EOL] N = pikepdf . Name [EOL] [EOL] main_pdf = pikepdf . open ( pdf_in ) [EOL] [EOL] the_file = pikepdf . Stream ( main_pdf , notebook [ [string] ] ) [EOL] the_file [ N ( [string] ) ] = N ( [string] ) [EOL] [EOL] file_wrapper = pikepdf . Dictionary ( F = the_file ) [EOL] [EOL] fname = notebook [ [string] ] [EOL] embedded_file = pikepdf . Dictionary ( Type = N ( [string] ) , UF = fname , F = fname , EF = file_wrapper ) [EOL] [EOL] name_tree = pikepdf . Array ( [ pikepdf . String ( fname ) , embedded_file ] ) [EOL] [EOL] embedded_files = pikepdf . Dictionary ( Names = name_tree ) [EOL] [EOL] names = pikepdf . Dictionary ( EmbeddedFiles = embedded_files ) [EOL] [EOL] main_pdf . Root [ N ( [string] ) ] = names [EOL] [EOL] main_pdf . save ( pdf_out ) [EOL] [EOL] [EOL] async def notebook_to_pdf ( notebook , pdf_path , config = None , resources = None , ** kwargs ) : [EOL] [docstring] [EOL] if config is None : [EOL] config = { } [EOL] exporter = nbconvert . HTMLExporter ( config = config ) [EOL] exported_html , _ = exporter . from_notebook_node ( notebook , resources = resources , ** kwargs ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( suffix = [string] ) as f : [EOL] f . write ( exported_html . encode ( ) ) [EOL] f . flush ( ) [EOL] await html_to_pdf ( f . name , pdf_path ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( loop ) [EOL] [EOL] html_contents = open ( args . html , encoding = [string] ) . read ( ) [EOL] if args . fix_html_links : [EOL] html_contents = fix_html ( html_contents ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( suffix = [string] , dir = os . path . dirname ( args . html ) ) as f_html : [EOL] f_html . write ( html_contents . encode ( [string] ) ) [EOL] f_html . flush ( ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( suffix = [string] ) as f_pdf : [EOL] loop . run_until_complete ( html_to_pdf ( f_html . name , f_pdf . name ) ) [EOL] [EOL] if args . fix_pdf_links : [EOL] [comment] [EOL] pdf_contents = open ( f_pdf . name , encoding = [string] ) . read ( ) [EOL] pdf_contents = fix_pdf ( pdf_contents ) [EOL] open ( f_pdf . name , [string] ) . write ( pdf_contents . encode ( [string] ) ) [EOL] [EOL] if args . attach : [EOL] notebook = { } [EOL] notebook [ [string] ] = args . notebook [EOL] notebook [ [string] ] = open ( args . notebook , [string] ) . read ( ) [EOL] [EOL] attach_notebook ( f_pdf . name , args . pdf , notebook ) [EOL] else : [EOL] [comment] [EOL] open ( args . pdf , [string] ) . write ( open ( f_pdf . name , [string] ) . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] [EOL] import nbformat [EOL] import argparse [EOL] [EOL] [EOL] def get_text_contents ( notebook ) : [EOL] with io . open ( notebook , [string] , encoding = [string] ) as f : [EOL] nb = nbformat . read ( f , as_version = [number] ) [EOL] [EOL] contents = [string] [EOL] for cell in nb . cells : [EOL] if cell . cell_type == [string] : [EOL] contents += [string] . join ( cell . source ) + [string] [EOL] [EOL] [comment] [EOL] [EOL] return contents [EOL] [EOL] def get_title ( notebook ) : [EOL] [docstring] [EOL] contents = get_text_contents ( notebook ) [EOL] match = re . search ( [string] , contents , re . MULTILINE ) [EOL] title = match . group ( [number] ) . replace ( [string] , [string] ) [EOL] [comment] [EOL] return title [EOL] [EOL] def notebook_toc_entry ( notebook_name , prefix , path = None ) : [EOL] [comment] [EOL] notebook_path = notebook_name [EOL] notebook_title = get_title ( notebook_path ) [EOL] notebook_base = os . path . basename ( notebook_path ) [EOL] [EOL] return prefix + [string] + notebook_title + [string] + notebook_base + [string] [EOL] [EOL] def notebook_toc ( public_chapters , appendices ) : [EOL] title = [string] [EOL] [EOL] chapter_toc = [string] [EOL] counter = [number] [EOL] for notebook in public_chapters + appendices : [EOL] notebook_title = get_title ( notebook ) [EOL] if ( notebook_title . startswith ( [string] ) or notebook_title . startswith ( [string] ) ) : [EOL] [comment] [EOL] chapter_toc += [string] + notebook_toc_entry ( notebook , [string] ) + [string] [EOL] else : [EOL] chapter_toc += notebook_toc_entry ( notebook , [string] ) [comment] [EOL] counter += [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] sitemap = [string] [EOL] [EOL] sitemap_code_1 = [string] [EOL] sitemap_code_2 = [string] [EOL] [EOL] toc_notebook = nbformat . v4 . new_notebook ( cells = [ nbformat . v4 . new_markdown_cell ( source = title ) , nbformat . v4 . new_markdown_cell ( source = sitemap ) , nbformat . v4 . new_code_cell ( source = sitemap_code_1 ) , nbformat . v4 . new_code_cell ( source = sitemap_code_2 ) , nbformat . v4 . new_markdown_cell ( source = chapter_toc ) ] ) [EOL] [EOL] [comment] [EOL] toc_notebook . metadata [ [string] ] = { [string] : [number] , [string] : { } , [string] : False , [string] : False , [string] : False , [string] : [string] , [string] : [string] , [string] : False , [string] : { } , [string] : False , [string] : False } [EOL] [EOL] [comment] [EOL] toc_notebook . metadata [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] toc_notebook . metadata [ [string] ] = { [string] : { [string] : [string] , [string] : [number] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] return toc_notebook [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] public_chapters = args . chapters . split ( ) [EOL] appendices = args . appendices . split ( ) [EOL] [EOL] toc_notebook = notebook_toc ( public_chapters , appendices ) [EOL] sys . stdout . buffer . write ( nbformat . writes ( toc_notebook ) . encode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] [EOL] import nbformat [EOL] [EOL] def notebook_stats ( notebook_name , path = None ) : [EOL] [comment] [EOL] notebook_path = notebook_name [EOL] [EOL] [comment] [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] notebook_loc = [number] [EOL] notebook_words = [number] [EOL] [EOL] for cell in notebook . cells : [EOL] if cell . cell_type == [string] : [EOL] cell_loc = cell . source . replace ( [string] , [string] ) . strip ( ) . count ( [string] ) + [number] [EOL] [comment] [EOL] notebook_loc += cell_loc [EOL] else : [EOL] cell_words = len ( cell . source . split ( ) ) [EOL] [comment] [EOL] notebook_words += cell_words [EOL] [EOL] return notebook_loc , notebook_words [EOL] [EOL] FORMAT = [string] [EOL] [EOL] if __name__ == [string] : [EOL] total_loc = [number] [EOL] total_words = [number] [EOL] for notebook in sys . argv [ [number] : ] : [EOL] notebook_loc , notebook_words = notebook_stats ( notebook ) [EOL] print ( FORMAT % ( notebook , notebook_loc , notebook_words ) ) [EOL] total_loc += notebook_loc [EOL] total_words += notebook_words [EOL] [EOL] if len ( sys . argv ) > [number] : [EOL] print ( FORMAT % ( [string] , total_loc , total_words ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] import argparse [EOL] import nbformat [EOL] [EOL] def prefix_code ( code , prefix ) : [EOL] return prefix + code . replace ( [string] , [string] + prefix ) [EOL] [EOL] def print_utf8 ( s ) : [EOL] sys . stdout . buffer . write ( s . encode ( [string] ) ) [EOL] [EOL] def title_to_anchor ( title ) : [EOL] return title . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] def link ( site_prefix , notebook_path , title ) : [EOL] notebook_basename = os . path . splitext ( os . path . basename ( notebook_path ) ) [ [number] ] [EOL] anchor = [string] + title_to_anchor ( title ) [EOL] return site_prefix + notebook_basename + [string] + anchor [EOL] [EOL] RE_NOTEBOOK_TITLE = re . compile ( [string] , re . DOTALL ) [EOL] RE_BEGIN_EXCURSION = re . compile ( [string] ) [EOL] RE_END_EXCURSION = re . compile ( [string] ) [EOL] [EOL] def shorten_notebook ( notebook_path , args ) : [EOL] [comment] [EOL] if notebook_path == [string] : [EOL] notebook = nbformat . read ( sys . stdin , [number] ) [EOL] else : [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] in_excursion = False [EOL] skipped_cells = [number] [EOL] new_cells = [ ] [EOL] notebook_title = None [EOL] [EOL] for cell in notebook . cells : [EOL] skip_this_cell = in_excursion [EOL] [EOL] if notebook_title is None : [EOL] match_notebook_title = RE_NOTEBOOK_TITLE . match ( cell . source ) [EOL] if match_notebook_title : [EOL] notebook_title = match_notebook_title . group ( [string] ) [EOL] [EOL] if cell . cell_type == [string] : [EOL] match_begin_excursion = RE_BEGIN_EXCURSION . match ( cell . source ) [EOL] match_end_excursion = RE_END_EXCURSION . match ( cell . source ) [EOL] [EOL] if match_begin_excursion : [EOL] skip_this_cell = True [EOL] in_excursion = True [EOL] [EOL] if args . link_to : [EOL] [comment] [EOL] title = match_begin_excursion . group ( [string] ) [EOL] cell . source = f' [string] { title } [string] { notebook_title } [string] { link ( args . link_to , notebook_path , title ) } [string] ' [EOL] skip_this_cell = False [EOL] [EOL] elif match_end_excursion : [EOL] skip_this_cell = True [EOL] in_excursion = False [EOL] [EOL] if skip_this_cell : [EOL] skipped_cells += [number] [EOL] [EOL] if args . skip_slides : [EOL] [comment] [EOL] if [string] not in cell : [EOL] cell [ [string] ] = { } [EOL] if [string] not in cell . metadata : [EOL] cell . metadata [ [string] ] = { } [EOL] if [string] not in cell . metadata . slideshow : [EOL] cell . metadata . slideshow [ [string] ] = [string] [EOL] [EOL] else : [EOL] new_cells . append ( cell ) [EOL] [EOL] notebook . cells = new_cells [EOL] notebook_contents = ( nbformat . writes ( notebook ) + [string] ) . encode ( [string] ) [EOL] [EOL] if args . in_place : [EOL] if skipped_cells > [number] : [EOL] temp_notebook_path = notebook_path + [string] [EOL] with io . open ( temp_notebook_path , [string] ) as f : [EOL] f . write ( notebook_contents ) [EOL] os . rename ( temp_notebook_path , notebook_path ) [EOL] print ( [string] % ( notebook_path , skipped_cells ) ) [EOL] else : [EOL] print ( [string] % notebook_path ) [EOL] else : [EOL] sys . stdout . buffer . write ( notebook_contents ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] for notebook in args . notebooks : [EOL] shorten_notebook ( notebook , args )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] import io , os , sys , types , re [EOL] import argparse [EOL] import nbformat [EOL] [EOL] [EOL] def prefix_code ( code , prefix ) : [EOL] return prefix + code . replace ( [string] , [string] + prefix ) [EOL] [EOL] def print_utf8 ( s ) : [EOL] sys . stdout . buffer . write ( s . encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] SLIDE = [string] [EOL] SUBSLIDE = [string] [EOL] FRAGMENT = [string] [EOL] SKIP = [string] [EOL] NO_SLIDE = [string] [EOL] [EOL] CHARS_PER_LINE = [number] [EOL] LINES_PER_SLIDE = [number] [EOL] [EOL] def estimate_lines ( cell ) : [EOL] lines = [number] [EOL] if cell . cell_type == [string] : [EOL] code = cell . source [EOL] lines = code . count ( [string] ) + [number] [EOL] [EOL] if cell . cell_type == [string] : [EOL] text = cell . source [EOL] lines = int ( len ( text ) / CHARS_PER_LINE ) + text . count ( [string] ) + [number] [EOL] [EOL] if [string] in cell : [EOL] for output in cell . outputs : [EOL] if [string] in output : [EOL] data = output . data [EOL] if [string] in data : [EOL] text_data = data [ [string] ] [EOL] lines += text_data . count ( [string] ) + [number] [EOL] elif [string] in output : [EOL] text_data = output . text [EOL] lines += text_data . count ( [string] ) + [number] [EOL] else : [EOL] [comment] [EOL] lines = LINES_PER_SLIDE [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] return lines [EOL] [EOL] def autoslide_notebook ( notebook_path , args ) : [EOL] [comment] [EOL] if notebook_path == [string] : [EOL] notebook = nbformat . read ( sys . stdin , [number] ) [EOL] else : [EOL] with io . open ( notebook_path , [string] , encoding = [string] ) as f : [EOL] notebook = nbformat . read ( f , [number] ) [EOL] [EOL] changed_cells = [number] [EOL] prev_cell = None [EOL] lines = [number] [EOL] [EOL] for cell in notebook . cells : [EOL] slide_type = FRAGMENT [comment] [EOL] [EOL] if cell . cell_type == [string] : [EOL] if cell . source . startswith ( [string] ) or cell . source . startswith ( [string] ) : [EOL] [comment] [EOL] slide_type = SLIDE [EOL] elif cell . source . startswith ( [string] ) or cell . source . startswith ( [string] ) : [EOL] [comment] [EOL] slide_type = SUBSLIDE [EOL] [EOL] elif cell . cell_type == [string] : [EOL] if cell . source . startswith ( [string] ) or cell . source . startswith ( [string] ) : [EOL] [comment] [EOL] slide_type = SKIP [EOL] [EOL] else : [EOL] [comment] [EOL] slide_type = SKIP [EOL] [EOL] [comment] [EOL] cell_lines = estimate_lines ( cell ) [EOL] if slide_type == FRAGMENT : [EOL] if lines + cell_lines > LINES_PER_SLIDE : [EOL] slide_type = SUBSLIDE [EOL] lines = cell_lines [EOL] else : [EOL] lines += cell_lines [EOL] elif slide_type == SLIDE or slide_type == SUBSLIDE : [EOL] lines = cell_lines [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if args . reset or [string] not in cell or [string] not in cell . metadata : [EOL] if [string] not in cell : [EOL] cell [ [string] ] = { } [EOL] if [string] not in cell . metadata : [EOL] cell . metadata [ [string] ] = { } [EOL] if [string] not in cell . metadata . slideshow : [EOL] cell . metadata . slideshow [ [string] ] = NO_SLIDE [EOL] [EOL] old_slide_type = cell . metadata . slideshow . slide_type [EOL] [EOL] if slide_type != old_slide_type : [EOL] changed_cells += [number] [EOL] cell . metadata . slideshow . slide_type = slide_type [EOL] [EOL] [comment] [EOL] last_cell = cell [EOL] [EOL] [EOL] notebook_contents = ( nbformat . writes ( notebook ) + [string] ) . encode ( [string] ) [EOL] [EOL] if args . in_place : [EOL] if changed_cells > [number] : [EOL] temp_notebook_path = notebook_path + [string] [EOL] with io . open ( temp_notebook_path , [string] ) as f : [EOL] f . write ( notebook_contents ) [EOL] os . rename ( temp_notebook_path , notebook_path ) [EOL] print ( [string] % ( notebook_path , changed_cells ) ) [EOL] else : [EOL] print ( [string] % notebook_path ) [EOL] else : [EOL] sys . stdout . buffer . write ( notebook_contents ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] for notebook in args . notebooks : [EOL] autoslide_notebook ( notebook , args )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] import random [EOL] random . seed ( [number] ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GreyboxFuzzer import Mutator , Seed , PowerSchedule , MutationFuzzer , GreyboxFuzzer [EOL] else : [EOL] from . GreyboxFuzzer import Mutator , Seed , PowerSchedule , MutationFuzzer , GreyboxFuzzer [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from MutationFuzzer import FunctionCoverageRunner [EOL] else : [EOL] from . MutationFuzzer import FunctionCoverageRunner [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] Mutator ( ) . mutate ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] population = [ Seed ( [string] ) , Seed ( [string] ) , Seed ( [string] ) ] [EOL] schedule = PowerSchedule ( ) [EOL] hits = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] for i in range ( [number] ) : [EOL] seed = schedule . choose ( population ) [EOL] hits [ seed . data ] += [number] [EOL] [EOL] hits [EOL] [EOL] [EOL] from html . parser import HTMLParser [EOL] [EOL] def my_parser ( inp ) : [EOL] parser = HTMLParser ( ) [EOL] parser . feed ( inp ) [EOL] [EOL] if __name__ == [string] : [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] runner . run ( [string] ) [EOL] cov = runner . coverage ( ) [EOL] [EOL] list ( cov ) [ : [number] ] [comment] [EOL] [EOL] [EOL] import time [EOL] import random [EOL] [EOL] if __name__ == [string] : [EOL] n = [number] [EOL] seed_input = [string] [comment] [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] fuzzer = GreyboxFuzzer ( [ seed_input ] , Mutator ( ) , PowerSchedule ( ) ) [EOL] [EOL] start = time . time ( ) [EOL] fuzzer . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [string] % len ( runner . coverage ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class DictMutator ( Mutator ) : [EOL] def __init__ ( self , dictionary ) : [EOL] super ( ) . __init__ ( ) [EOL] self . dictionary = dictionary [EOL] self . mutators . append ( self . insert_from_dictionary ) [EOL] [EOL] def insert_from_dictionary ( self , s ) : [EOL] [docstring] [EOL] pos = random . randint ( [number] , len ( s ) ) [EOL] random_keyword = random . choice ( self . dictionary ) [EOL] return s [ : pos ] + random_keyword + s [ pos : ] [EOL] [EOL] if __name__ == [string] : [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] dict_mutator = DictMutator ( [ [string] , [string] , [string] , [string] ] ) [EOL] dict_fuzzer = GreyboxFuzzer ( [ seed_input ] , dict_mutator , PowerSchedule ( ) ) [EOL] [EOL] start = time . time ( ) [EOL] dict_fuzzer . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [string] % len ( runner . coverage ( ) ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Coverage import population_coverage [EOL] else : [EOL] from . Coverage import population_coverage [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] _ , dict_cov = population_coverage ( dict_fuzzer . inputs , my_parser ) [EOL] _ , fuzz_cov = population_coverage ( fuzzer . inputs , my_parser ) [EOL] line_dict , = plt . plot ( dict_cov , label = [string] ) [EOL] line_fuzz , = plt . plot ( fuzz_cov , label = [string] ) [EOL] plt . legend ( handles = [ line_dict , line_fuzz ] ) [EOL] plt . xlim ( [number] , n ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) ; [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] import string [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import is_valid_grammar , srange [EOL] else : [EOL] from . Grammars import is_valid_grammar , srange [EOL] [EOL] [EOL] XML_TOKENS = { [string] , [string] } [EOL] [EOL] XML_GRAMMAR = { [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : srange ( string . ascii_letters + string . digits + [string] + [string] + [string] ) , [string] : srange ( string . ascii_letters + string . digits + [string] + [string] + [string] + [string] ) , } [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_grammar ( XML_GRAMMAR ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Parser import EarleyParser [EOL] else : [EOL] from . Parser import EarleyParser [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import display_tree [EOL] else : [EOL] from . GrammarFuzzer import display_tree [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) [EOL] [EOL] for tree in parser . parse ( [string] ) : [EOL] display_tree ( tree ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class FragmentMutator ( Mutator ) : [EOL] def __init__ ( self , parser ) : [EOL] [docstring] [EOL] self . parser = parser [EOL] self . fragments = { k : [ ] for k in self . parser . cgrammar } [EOL] super ( ) . __init__ ( ) [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Parser import terminals [EOL] else : [EOL] from . Parser import terminals [EOL] [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def add_fragment ( self , fragment ) : [EOL] [docstring] [EOL] ( symbol , children ) = fragment [EOL] if not self . is_excluded ( symbol ) : [EOL] self . fragments [ symbol ] . append ( fragment ) [EOL] for subfragment in children : [EOL] self . add_fragment ( subfragment ) [EOL] [EOL] def is_excluded ( self , symbol ) : [EOL] [docstring] [EOL] return ( ( not symbol in self . parser . grammar ( ) ) or symbol in self . parser . tokens or symbol in terminals ( self . parser . grammar ( ) ) ) [EOL] [EOL] import signal [EOL] [EOL] class Timeout ( Exception ) : pass [EOL] def timeout ( signum , frame ) : [EOL] raise Timeout ( ) [EOL] [EOL] [comment] [EOL] signal . signal ( signal . SIGALRM , timeout ) ; [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def add_to_fragment_pool ( self , seed ) : [EOL] [docstring] [EOL] try : [comment] [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [EOL] seed . structure = next ( self . parser . parse ( seed . data ) ) [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [EOL] [EOL] self . add_fragment ( seed . structure ) [EOL] seed . has_structure = True [EOL] except ( SyntaxError , Timeout ) : [EOL] seed . has_structure = False [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import tree_to_string [EOL] else : [EOL] from . GrammarFuzzer import tree_to_string [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] valid_seed = Seed ( [string] ) [EOL] fragment_mutator = FragmentMutator ( EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] fragment_mutator . add_to_fragment_pool ( valid_seed ) [EOL] [EOL] for key in fragment_mutator . fragments : [EOL] print ( key ) [EOL] for f in fragment_mutator . fragments [ key ] : [EOL] print ( [string] % tree_to_string ( f ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def __init__ ( self , parser ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( parser ) [EOL] self . seen_seeds = [ ] [EOL] [EOL] def mutate ( self , seed ) : [EOL] [docstring] [EOL] if not seed in self . seen_seeds : [EOL] self . seen_seeds . append ( seed ) [EOL] self . add_to_fragment_pool ( seed ) [EOL] return super ( ) . mutate ( seed ) [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def count_nodes ( self , fragment ) : [EOL] [docstring] [EOL] symbol , children = fragment [EOL] if self . is_excluded ( symbol ) : [EOL] return [number] [EOL] return [number] + sum ( map ( self . count_nodes , children ) ) [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def recursive_swap ( self , fragment ) : [EOL] [docstring] [EOL] symbol , children = fragment [EOL] if self . is_excluded ( symbol ) : [EOL] return symbol , children [EOL] [EOL] self . to_swap -= [number] [EOL] if self . to_swap == [number] : [EOL] return random . choice ( list ( self . fragments [ symbol ] ) ) [EOL] return symbol , list ( map ( self . recursive_swap , children ) ) [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def __init__ ( self , parser ) : [EOL] super ( ) . __init__ ( parser ) [EOL] self . mutators = [ self . swap_fragment ] [EOL] [EOL] def swap_fragment ( self , seed ) : [EOL] [docstring] [EOL] if seed . has_structure : [EOL] n_nodes = self . count_nodes ( seed . structure ) [EOL] self . to_swap = random . randint ( [number] , n_nodes ) [EOL] new_structure = self . recursive_swap ( seed . structure ) [EOL] [EOL] new_seed = Seed ( tree_to_string ( new_structure ) ) [EOL] new_seed . has_structure = True [EOL] new_seed . structure = new_structure [EOL] return new_seed [EOL] return seed [EOL] [EOL] if __name__ == [string] : [EOL] valid_seed = Seed ( [string] ) [EOL] lf_mutator = FragmentMutator ( parser ) [EOL] print ( valid_seed ) [EOL] lf_mutator . mutate ( valid_seed ) [EOL] [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def recursive_delete ( self , fragment ) : [EOL] [docstring] [EOL] symbol , children = fragment [EOL] if self . is_excluded ( symbol ) : [EOL] return symbol , children [EOL] [EOL] self . to_delete -= [number] [EOL] if self . to_delete == [number] : [EOL] return symbol , [ ] [EOL] return symbol , list ( map ( self . recursive_delete , children ) ) [EOL] [EOL] class FragmentMutator ( FragmentMutator ) : [EOL] def __init__ ( self , parser ) : [EOL] super ( ) . __init__ ( parser ) [EOL] self . mutators . append ( self . delete_fragment ) [EOL] [EOL] def delete_fragment ( self , seed ) : [EOL] [docstring] [EOL] if seed . has_structure : [EOL] n_nodes = self . count_nodes ( seed . structure ) [EOL] self . to_delete = random . randint ( [number] , n_nodes ) [EOL] new_structure = self . recursive_delete ( seed . structure ) [EOL] [EOL] new_seed = Seed ( tree_to_string ( new_structure ) ) [EOL] new_seed . has_structure = True [EOL] new_seed . structure = new_structure [EOL] [comment] [EOL] if not new_seed . data : return seed [EOL] else : return new_seed [EOL] return seed [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class LangFuzzer ( MutationFuzzer ) : [EOL] def create_candidate ( self ) : [EOL] [docstring] [EOL] candidate = self . schedule . choose ( self . population ) [EOL] trials = random . randint ( [number] , [number] ) [EOL] for i in range ( trials ) : [EOL] candidate = self . mutator . mutate ( candidate ) [EOL] return candidate [EOL] [EOL] if __name__ == [string] : [EOL] n = [number] [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] mutator = FragmentMutator ( EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] schedule = PowerSchedule ( ) [EOL] [EOL] langFuzzer = LangFuzzer ( [ valid_seed . data ] , mutator , schedule ) [EOL] [EOL] start = time . time ( ) [EOL] langFuzzer . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] mutator = Mutator ( ) [EOL] schedule = PowerSchedule ( ) [EOL] [EOL] blackFuzzer = MutationFuzzer ( [ valid_seed . data ] , mutator , schedule ) [EOL] [EOL] start = time . time ( ) [EOL] blackFuzzer . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] blackbox_coverage = len ( runner . coverage ( ) ) [EOL] [string] % blackbox_coverage [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Coverage import population_coverage [EOL] else : [EOL] from . Coverage import population_coverage [EOL] [EOL] [EOL] def print_stats ( fuzzer , parser ) : [EOL] coverage , _ = population_coverage ( fuzzer . inputs , my_parser ) [EOL] [EOL] has_structure = [number] [EOL] for seed in fuzzer . inputs : [EOL] [comment] [EOL] if hasattr ( seed , [string] ) : [EOL] if seed . has_structure : [EOL] has_structure += [number] [EOL] else : [EOL] if isinstance ( seed , str ) : [EOL] seed = Seed ( seed ) [EOL] try : [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [EOL] next ( parser . parse ( seed . data ) ) [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [EOL] has_structure += [number] [EOL] except ( SyntaxError , Timeout ) : [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [EOL] [EOL] print ( [string] [string] % ( len ( fuzzer . inputs ) , has_structure , [number] * has_structure / len ( fuzzer . inputs ) , len ( coverage ) ) ) [EOL] [EOL] if __name__ == [string] : [EOL] print_stats ( langFuzzer , EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print_stats ( blackFuzzer , EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class GreyboxGrammarFuzzer ( GreyboxFuzzer ) : [EOL] def __init__ ( self , seeds , byte_mutator , tree_mutator , schedule ) : [EOL] super ( ) . __init__ ( seeds , byte_mutator , schedule ) [EOL] self . tree_mutator = tree_mutator [EOL] [EOL] def create_candidate ( self ) : [EOL] [docstring] [EOL] seed = self . schedule . choose ( self . population ) [EOL] [EOL] [comment] [EOL] trials = random . randint ( [number] , [number] ) [EOL] for i in range ( trials ) : [EOL] seed = self . tree_mutator . mutate ( seed ) [EOL] [EOL] [comment] [EOL] candidate = seed . data [EOL] if trials == [number] or not seed . has_structure or [number] == random . randint ( [number] , [number] ) : [EOL] dumb_trials = min ( len ( seed . data ) , [number] << random . randint ( [number] , [number] ) ) [EOL] for i in range ( dumb_trials ) : [EOL] candidate = self . mutator . mutate ( candidate ) [EOL] return candidate [EOL] [EOL] if __name__ == [string] : [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] byte_mutator = Mutator ( ) [EOL] tree_mutator = FragmentMutator ( EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] schedule = PowerSchedule ( ) [EOL] [EOL] gg_fuzzer = GreyboxGrammarFuzzer ( [ valid_seed . data ] , byte_mutator , tree_mutator , schedule ) [EOL] [EOL] start = time . time ( ) [EOL] gg_fuzzer . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print_stats ( gg_fuzzer , EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] invalid_seed = Seed ( [string] ) [EOL] parser = EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) [EOL] table = parser . chart_parse ( invalid_seed . data , parser . start_symbol ( ) ) [EOL] for column in table : [EOL] print ( column ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cols = [ col for col in table if col . states ] [EOL] parsable = invalid_seed . data [ : len ( cols ) - [number] ] [EOL] [EOL] print ( [string] % invalid_seed ) [EOL] parsable [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] validity = [number] * len ( parsable ) / len ( invalid_seed . data ) [EOL] [EOL] [string] % validity [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class RegionMutator ( FragmentMutator ) : [EOL] def add_to_fragment_pool ( self , seed ) : [EOL] [docstring] [EOL] super ( ) . add_to_fragment_pool ( seed ) [EOL] if not seed . has_structure : [EOL] try : [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [comment] [EOL] seed . regions = { k : set ( ) for k in self . parser . cgrammar } [EOL] for column in self . parser . chart_parse ( seed . data , self . parser . start_symbol ( ) ) : [EOL] for state in column . states : [EOL] if ( not self . is_excluded ( state . name ) and state . e_col . index - state . s_col . index > [number] and state . finished ( ) ) : [EOL] seed . regions [ state . name ] . add ( ( state . s_col . index , state . e_col . index ) ) [EOL] signal . setitimer ( signal . ITIMER_REAL , [number] ) [comment] [EOL] seed . has_regions = True [EOL] except Timeout : [EOL] seed . has_regions = False [EOL] else : [EOL] seed . has_regions = False [EOL] [EOL] if __name__ == [string] : [EOL] mutator = RegionMutator ( parser ) [EOL] mutator . add_to_fragment_pool ( invalid_seed ) [EOL] for symbol in invalid_seed . regions : [EOL] print ( symbol ) [EOL] for ( s , e ) in invalid_seed . regions [ symbol ] : [EOL] print ( [string] % ( s , e , invalid_seed . data [ s : e ] ) ) [EOL] [EOL] [EOL] class RegionMutator ( RegionMutator ) : [EOL] def swap_fragment ( self , seed ) : [EOL] [docstring] [EOL] if not seed . has_structure and seed . has_regions : [EOL] regions = [ r for r in seed . regions if ( len ( seed . regions [ r ] ) > [number] and len ( self . fragments [ r ] ) > [number] ) ] [EOL] if len ( regions ) == [number] : return seed [EOL] [EOL] key = random . choice ( list ( regions ) ) [EOL] s , e = random . choice ( list ( seed . regions [ key ] ) ) [EOL] swap_structure = random . choice ( self . fragments [ key ] ) [EOL] swap_string = tree_to_string ( swap_structure ) [EOL] new_seed = Seed ( seed . data [ : s ] + swap_string + seed . data [ e : ] ) [EOL] new_seed . has_structure = False [EOL] new_seed . has_regions = False [EOL] return new_seed [EOL] else : [EOL] return super ( ) . swap_fragment ( seed ) [EOL] [EOL] class RegionMutator ( RegionMutator ) : [EOL] def delete_fragment ( self , seed ) : [EOL] [docstring] [EOL] if not seed . has_structure and seed . has_regions : [EOL] regions = [ r for r in seed . regions if len ( seed . regions [ r ] ) > [number] ] [EOL] if len ( regions ) == [number] : return seed [EOL] [EOL] key = random . choice ( list ( regions ) ) [EOL] s , e = ( [number] , [number] ) [EOL] while ( e - s < [number] ) : [EOL] s , e = random . choice ( list ( seed . regions [ key ] ) ) [EOL] new_seed = Seed ( seed . data [ : s ] + seed . data [ e : ] ) [EOL] new_seed . has_structure = False [EOL] new_seed . has_regions = False [EOL] return new_seed [EOL] else : [EOL] return super ( ) . delete_fragment ( seed ) [EOL] [EOL] if __name__ == [string] : [EOL] simple_seed = Seed ( [string] ) [EOL] mutator = RegionMutator ( parser ) [EOL] mutator . add_to_fragment_pool ( simple_seed ) [EOL] [EOL] print ( invalid_seed ) [EOL] mutator . mutate ( invalid_seed ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] byte_mutator = Mutator ( ) [EOL] tree_mutator = RegionMutator ( EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] schedule = PowerSchedule ( ) [EOL] [EOL] regionFuzzer = GreyboxGrammarFuzzer ( [ valid_seed . data ] , byte_mutator , tree_mutator , schedule ) [EOL] [EOL] start = time . time ( ) [EOL] regionFuzzer . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] def print_more_stats ( fuzzer , parser ) : [EOL] print_stats ( fuzzer , parser ) [EOL] validity = [number] [EOL] total = [number] [EOL] for seed in fuzzer . population : [EOL] if not seed . data : continue [EOL] table = parser . chart_parse ( seed . data , parser . start_symbol ( ) ) [EOL] cols = [ col for col in table if col . states ] [EOL] parsable = invalid_seed . data [ : len ( cols ) - [number] ] [EOL] validity += len ( parsable ) / len ( seed . data ) [EOL] total += [number] [EOL] print ( [string] % ( [number] * validity / total ) ) [EOL] [EOL] if __name__ == [string] : [EOL] print_more_stats ( regionFuzzer , parser ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] import math [EOL] [EOL] class AFLSmartSchedule ( PowerSchedule ) : [EOL] [EOL] def __init__ ( self , parser , exponent ) : [EOL] self . parser = parser [EOL] self . exponent = exponent [EOL] [EOL] def parsable ( self , seed ) : [EOL] [docstring] [EOL] table = self . parser . chart_parse ( seed . data , self . parser . start_symbol ( ) ) [EOL] cols = [ col for col in table if col . states ] [EOL] return seed . data [ : len ( cols ) - [number] ] [EOL] [EOL] def degree_of_validity ( self , seed ) : [EOL] [docstring] [EOL] if hasattr ( seed , [string] ) : return seed . validity [EOL] seed . validity = ( len ( self . parsable ( seed ) ) / len ( seed . data ) [EOL] if len ( seed . data ) > [number] else [number] ) [EOL] return seed . validity [EOL] [EOL] def assignEnergy ( self , population ) : [EOL] [docstring] [EOL] for seed in population : [EOL] seed . energy = ( ( self . degree_of_validity ( seed ) / math . log ( len ( seed . data ) ) ) ** self . exponent [EOL] if len ( seed . data ) > [number] else [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] smart_schedule = AFLSmartSchedule ( parser , [number] ) [EOL] print ( [string] % ( [string] , simple_seed ) ) [EOL] print ( [string] % ( [string] , smart_schedule . parsable ( simple_seed ) ) ) [EOL] [EOL] [string] % ( [number] * smart_schedule . degree_of_validity ( simple_seed ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] % ( [string] , invalid_seed ) ) [EOL] print ( [string] % ( [string] , smart_schedule . parsable ( invalid_seed ) ) ) [EOL] [EOL] [string] % ( [number] * smart_schedule . degree_of_validity ( invalid_seed ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] runner = FunctionCoverageRunner ( my_parser ) [EOL] byte_mutator = Mutator ( ) [EOL] tree_mutator = RegionMutator ( EarleyParser ( XML_GRAMMAR , tokens = XML_TOKENS ) ) [EOL] schedule = AFLSmartSchedule ( parser , [number] ) [EOL] [EOL] aflsmart = GreyboxGrammarFuzzer ( [ valid_seed . data ] , byte_mutator , tree_mutator , schedule ) [EOL] [EOL] start = time . time ( ) [EOL] aflsmart . runs ( runner , trials = n ) [EOL] end = time . time ( ) [EOL] [EOL] [string] % ( end - start , n ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print_more_stats ( aflsmart , parser ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] import random [EOL] random . seed ( [number] ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import EXPR_GRAMMAR , CGI_GRAMMAR , URL_GRAMMAR , START_SYMBOL [EOL] else : [EOL] from . Grammars import EXPR_GRAMMAR , CGI_GRAMMAR , URL_GRAMMAR , START_SYMBOL [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import is_valid_grammar , extend_grammar [EOL] else : [EOL] from . Grammars import is_valid_grammar , extend_grammar [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] EXPR_GRAMMAR [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import GrammarFuzzer , all_terminals , nonterminals , display_tree [EOL] else : [EOL] from . GrammarFuzzer import GrammarFuzzer , all_terminals , nonterminals , display_tree [EOL] [EOL] [EOL] import random [EOL] [EOL] class TrackingGrammarCoverageFuzzer ( GrammarFuzzer ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [comment] [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . reset_coverage ( ) [EOL] [EOL] def reset_coverage ( self ) : [EOL] self . covered_expansions = set ( ) [EOL] [EOL] def expansion_coverage ( self ) : [EOL] return self . covered_expansions [EOL] [EOL] def expansion_key ( symbol , expansion ) : [EOL] [docstring] [EOL] if isinstance ( expansion , tuple ) : [EOL] expansion = expansion [ [number] ] [EOL] if not isinstance ( expansion , str ) : [EOL] children = expansion [EOL] expansion = all_terminals ( ( symbol , children ) ) [EOL] return symbol + [string] + expansion [EOL] [EOL] if __name__ == [string] : [EOL] expansion_key ( START_SYMBOL , EXPR_GRAMMAR [ START_SYMBOL ] [ [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] children = [ ( [string] , None ) , ( [string] , [ ] ) , ( [string] , None ) ] [EOL] expansion_key ( [string] , children ) [EOL] [EOL] [EOL] class TrackingGrammarCoverageFuzzer ( TrackingGrammarCoverageFuzzer ) : [EOL] def _max_expansion_coverage ( self , symbol , max_depth ) : [EOL] if max_depth <= [number] : [EOL] return set ( ) [EOL] [EOL] self . _symbols_seen . add ( symbol ) [EOL] [EOL] expansions = set ( ) [EOL] for expansion in self . grammar [ symbol ] : [EOL] expansions . add ( expansion_key ( symbol , expansion ) ) [EOL] for nonterminal in nonterminals ( expansion ) : [EOL] if nonterminal not in self . _symbols_seen : [EOL] expansions |= self . _max_expansion_coverage ( nonterminal , max_depth - [number] ) [EOL] [EOL] return expansions [EOL] [EOL] def max_expansion_coverage ( self , symbol = None , max_depth = float ( [string] ) ) : [EOL] [docstring] [EOL] if symbol is None : [EOL] symbol = self . start_symbol [EOL] [EOL] self . _symbols_seen = set ( ) [EOL] cov = self . _max_expansion_coverage ( symbol , max_depth ) [EOL] [EOL] if symbol == START_SYMBOL : [EOL] assert len ( self . _symbols_seen ) == len ( self . grammar ) [EOL] [EOL] return cov [EOL] [EOL] if __name__ == [string] : [EOL] expr_fuzzer = TrackingGrammarCoverageFuzzer ( EXPR_GRAMMAR ) [EOL] expr_fuzzer . max_expansion_coverage ( ) [EOL] [EOL] [EOL] class TrackingGrammarCoverageFuzzer ( TrackingGrammarCoverageFuzzer ) : [EOL] def add_coverage ( self , symbol , new_children ) : [EOL] key = expansion_key ( symbol , new_children ) [EOL] [EOL] if self . log and key not in self . covered_expansions : [EOL] print ( [string] , key ) [EOL] self . covered_expansions . add ( key ) [EOL] [EOL] def choose_node_expansion ( self , node , possible_children ) : [EOL] ( symbol , children ) = node [EOL] index = super ( ) . choose_node_expansion ( node , possible_children ) [EOL] self . add_coverage ( symbol , possible_children [ index ] ) [EOL] return index [EOL] [EOL] class TrackingGrammarCoverageFuzzer ( TrackingGrammarCoverageFuzzer ) : [EOL] def missing_expansion_coverage ( self ) : [EOL] return self . max_expansion_coverage ( ) - self . expansion_coverage ( ) [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer = TrackingGrammarCoverageFuzzer ( EXPR_GRAMMAR , start_symbol = [string] , log = True ) [EOL] digit_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer . expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer . max_expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer . missing_expansion_coverage ( ) [EOL] [EOL] [EOL] def average_length_until_full_coverage ( fuzzer ) : [EOL] trials = [number] [EOL] [EOL] sum = [number] [EOL] for trial in range ( trials ) : [EOL] [comment] [EOL] fuzzer . reset_coverage ( ) [EOL] while len ( fuzzer . missing_expansion_coverage ( ) ) > [number] : [EOL] s = fuzzer . fuzz ( ) [EOL] sum += len ( s ) [EOL] [EOL] return sum / trials [EOL] [EOL] if __name__ == [string] : [EOL] digit_fuzzer . log = False [EOL] average_length_until_full_coverage ( digit_fuzzer ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] expr_fuzzer = TrackingGrammarCoverageFuzzer ( EXPR_GRAMMAR ) [EOL] average_length_until_full_coverage ( expr_fuzzer ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class SimpleGrammarCoverageFuzzer ( TrackingGrammarCoverageFuzzer ) : [EOL] def choose_node_expansion ( self , node , possible_children ) : [EOL] [comment] [EOL] ( symbol , children ) = node [EOL] uncovered_children = [ c for ( i , c ) in enumerate ( possible_children ) if expansion_key ( symbol , c ) not in self . covered_expansions ] [EOL] index_map = [ i for ( i , c ) in enumerate ( possible_children ) if c in uncovered_children ] [EOL] [EOL] if len ( uncovered_children ) == [number] : [EOL] [comment] [EOL] return self . choose_covered_node_expansion ( node , possible_children ) [EOL] [EOL] [comment] [EOL] index = self . choose_uncovered_node_expansion ( node , uncovered_children ) [EOL] [EOL] return index_map [ index ] [EOL] [EOL] class SimpleGrammarCoverageFuzzer ( SimpleGrammarCoverageFuzzer ) : [EOL] def choose_uncovered_node_expansion ( self , node , possible_children ) : [EOL] return TrackingGrammarCoverageFuzzer . choose_node_expansion ( self , node , possible_children ) [EOL] [EOL] def choose_covered_node_expansion ( self , node , possible_children ) : [EOL] return TrackingGrammarCoverageFuzzer . choose_node_expansion ( self , node , possible_children ) [EOL] [EOL] if __name__ == [string] : [EOL] f = SimpleGrammarCoverageFuzzer ( EXPR_GRAMMAR , start_symbol = [string] ) [EOL] f . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for i in range ( [number] ) : [EOL] print ( f . fuzz ( ) , end = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . missing_expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = SimpleGrammarCoverageFuzzer ( EXPR_GRAMMAR ) [EOL] for i in range ( [number] ) : [EOL] print ( f . fuzz ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . missing_expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] average_length_until_full_coverage ( SimpleGrammarCoverageFuzzer ( EXPR_GRAMMAR ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] CGI_GRAMMAR [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = SimpleGrammarCoverageFuzzer ( CGI_GRAMMAR ) [EOL] for i in range ( [number] ) : [EOL] print ( f . fuzz ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . missing_expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] CGI_GRAMMAR [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = SimpleGrammarCoverageFuzzer ( EXPR_GRAMMAR ) [EOL] f . max_expansion_coverage ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . max_expansion_coverage ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class GrammarCoverageFuzzer ( SimpleGrammarCoverageFuzzer ) : [EOL] def _new_child_coverage ( self , children , max_depth ) : [EOL] new_cov = set ( ) [EOL] for ( c_symbol , _ ) in children : [EOL] if c_symbol in self . grammar : [EOL] new_cov |= self . max_expansion_coverage ( c_symbol , max_depth ) [EOL] return new_cov [EOL] [EOL] def new_child_coverage ( self , symbol , children , max_depth = float ( [string] ) ) : [EOL] [docstring] [EOL] new_cov = self . _new_child_coverage ( children , max_depth ) [EOL] new_cov . add ( expansion_key ( symbol , children ) ) [EOL] new_cov -= self . expansion_coverage ( ) [comment] [EOL] return new_cov [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( EXPR_GRAMMAR , start_symbol = [string] , log = True ) [EOL] f . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for expansion in EXPR_GRAMMAR [ [string] ] : [EOL] children = f . expansion_to_children ( expansion ) [EOL] print ( expansion , f . new_child_coverage ( [string] , children ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class GrammarCoverageFuzzer ( GrammarCoverageFuzzer ) : [EOL] def new_coverages ( self , node , possible_children ) : [EOL] [docstring] [EOL] ( symbol , children ) = node [EOL] for max_depth in range ( len ( self . grammar ) ) : [EOL] new_coverages = [ self . new_child_coverage ( symbol , c , max_depth ) for c in possible_children ] [EOL] max_new_coverage = max ( len ( new_coverage ) for new_coverage in new_coverages ) [EOL] if max_new_coverage > [number] : [EOL] [comment] [EOL] return new_coverages [EOL] [EOL] [comment] [EOL] return None [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class GrammarCoverageFuzzer ( GrammarCoverageFuzzer ) : [EOL] def choose_node_expansion ( self , node , possible_children ) : [EOL] ( symbol , children ) = node [EOL] new_coverages = self . new_coverages ( node , possible_children ) [EOL] [EOL] if new_coverages is None : [EOL] [comment] [EOL] return self . choose_covered_node_expansion ( node , possible_children ) [EOL] [EOL] max_new_coverage = max ( len ( cov ) for cov in new_coverages ) [EOL] [EOL] children_with_max_new_coverage = [ c for ( i , c ) in enumerate ( possible_children ) if len ( new_coverages [ i ] ) == max_new_coverage ] [EOL] index_map = [ i for ( i , c ) in enumerate ( possible_children ) if len ( new_coverages [ i ] ) == max_new_coverage ] [EOL] [EOL] [comment] [EOL] new_children_index = self . choose_uncovered_node_expansion ( node , children_with_max_new_coverage ) [EOL] new_children = children_with_max_new_coverage [ new_children_index ] [EOL] [EOL] [comment] [EOL] key = expansion_key ( symbol , new_children ) [EOL] [EOL] if self . log : [EOL] print ( [string] , key ) [EOL] self . covered_expansions . add ( key ) [EOL] [EOL] return index_map [ new_children_index ] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( EXPR_GRAMMAR , min_nonterminals = [number] ) [EOL] f . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f . max_expansion_coverage ( ) - f . expansion_coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] average_length_until_full_coverage ( GrammarCoverageFuzzer ( EXPR_GRAMMAR ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( CGI_GRAMMAR , min_nonterminals = [number] ) [EOL] while len ( f . max_expansion_coverage ( ) - f . expansion_coverage ( ) ) > [number] : [EOL] print ( f . fuzz ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] average_length_until_full_coverage ( TrackingGrammarCoverageFuzzer ( CGI_GRAMMAR ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] average_length_until_full_coverage ( SimpleGrammarCoverageFuzzer ( CGI_GRAMMAR ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] average_length_until_full_coverage ( GrammarCoverageFuzzer ( CGI_GRAMMAR ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] EXPR_GRAMMAR [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar = extend_grammar ( EXPR_GRAMMAR , { [string] : [ [string] , [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_grammar ( dup_expr_grammar ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( dup_expr_grammar , start_symbol = [string] ) [EOL] for i in range ( [number] ) : [EOL] print ( f . fuzz ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import new_symbol , unreachable_nonterminals [EOL] else : [EOL] from . Grammars import new_symbol , unreachable_nonterminals [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import expansion_to_children [EOL] else : [EOL] from . GrammarFuzzer import expansion_to_children [EOL] [EOL] [EOL] def duplicate_context ( grammar , symbol , expansion = None , depth = float ( [string] ) ) : [EOL] [docstring] [EOL] orig_grammar = extend_grammar ( grammar ) [EOL] _duplicate_context ( grammar , orig_grammar , symbol , expansion , depth , seen = { } ) [EOL] [EOL] [comment] [EOL] for nonterminal in unreachable_nonterminals ( grammar ) : [EOL] del grammar [ nonterminal ] [EOL] [EOL] import copy [EOL] [EOL] def _duplicate_context ( grammar , orig_grammar , symbol , expansion , depth , seen ) : [EOL] for i in range ( len ( grammar [ symbol ] ) ) : [EOL] if expansion is None or grammar [ symbol ] [ i ] == expansion : [EOL] new_expansion = [string] [EOL] for ( s , c ) in expansion_to_children ( grammar [ symbol ] [ i ] ) : [EOL] if s in seen : [comment] [EOL] new_expansion += seen [ s ] [EOL] elif c == [ ] or depth == [number] : [comment] [EOL] new_expansion += s [EOL] else : [comment] [EOL] [comment] [EOL] new_s = new_symbol ( grammar , s ) [EOL] grammar [ new_s ] = copy . deepcopy ( orig_grammar [ s ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] _duplicate_context ( grammar , orig_grammar , new_s , expansion = None , depth = depth - [number] , seen = { ** seen , ** { s : new_s } } ) [EOL] new_expansion += new_s [EOL] [EOL] grammar [ symbol ] [ i ] = new_expansion [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar = extend_grammar ( EXPR_GRAMMAR ) [EOL] duplicate_context ( dup_expr_grammar , [string] , [string] ) [EOL] dup_expr_grammar [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( dup_expr_grammar , start_symbol = [string] ) [EOL] for i in range ( [number] ) : [EOL] print ( f . fuzz ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar = extend_grammar ( EXPR_GRAMMAR ) [EOL] duplicate_context ( dup_expr_grammar , [string] , [string] , depth = [number] ) [EOL] dup_expr_grammar [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_grammar ( dup_expr_grammar ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar = extend_grammar ( EXPR_GRAMMAR ) [EOL] duplicate_context ( dup_expr_grammar , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_grammar ( dup_expr_grammar ) [EOL] len ( dup_expr_grammar ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( dup_expr_grammar ) [EOL] len ( f . max_expansion_coverage ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar = extend_grammar ( EXPR_GRAMMAR ) [EOL] duplicate_context ( dup_expr_grammar , [string] ) [EOL] duplicate_context ( dup_expr_grammar , [string] ) [EOL] len ( dup_expr_grammar ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( dup_expr_grammar ) [EOL] len ( f . max_expansion_coverage ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar [ [string] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar [ [string] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] dup_expr_grammar [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Coverage import Coverage , cgi_decode [EOL] else : [EOL] from . Coverage import Coverage , cgi_decode [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov_max : [EOL] cgi_decode ( [string] ) [EOL] cgi_decode ( [string] ) [EOL] cgi_decode ( [string] ) [EOL] try : [EOL] cgi_decode ( [string] ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( CGI_GRAMMAR , max_nonterminals = [number] ) [EOL] coverages = { } [EOL] [EOL] trials = [number] [EOL] for trial in range ( trials ) : [EOL] f . reset_coverage ( ) [EOL] overall_cov = set ( ) [EOL] max_cov = [number] [EOL] [EOL] for i in range ( [number] ) : [EOL] s = f . fuzz ( ) [EOL] with Coverage ( ) as cov : [EOL] cgi_decode ( s ) [EOL] overall_cov |= cov . coverage ( ) [EOL] [EOL] x = len ( f . expansion_coverage ( ) ) * [number] / len ( f . max_expansion_coverage ( ) ) [EOL] y = len ( overall_cov ) * [number] / len ( cov_max . coverage ( ) ) [EOL] if x not in coverages : [EOL] coverages [ x ] = [ ] [EOL] coverages [ x ] . append ( y ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] xs = list ( coverages . keys ( ) ) [EOL] ys = [ sum ( coverages [ x ] ) / len ( coverages [ x ] ) for x in coverages ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import matplotlib . ticker as mtick [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ax = plt . axes ( label = [string] ) [EOL] ax . yaxis . set_major_formatter ( mtick . PercentFormatter ( ) ) [EOL] ax . xaxis . set_major_formatter ( mtick . PercentFormatter ( ) ) [EOL] [EOL] plt . xlim ( [number] , max ( xs ) ) [EOL] plt . ylim ( [number] , max ( ys ) ) [EOL] [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . scatter ( xs , ys ) ; [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import numpy as np [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] np . corrcoef ( xs , ys ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from scipy . stats import spearmanr [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] spearmanr ( xs , ys ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] from urlparse import urlparse [comment] [EOL] except ImportError : [EOL] from urllib . parse import urlparse [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov_max : [EOL] urlparse ( [string] ) [EOL] urlparse ( [string] ) [EOL] urlparse ( [string] ) [EOL] urlparse ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( URL_GRAMMAR , max_nonterminals = [number] ) [EOL] coverages = { } [EOL] [EOL] trials = [number] [EOL] for trial in range ( trials ) : [EOL] f . reset_coverage ( ) [EOL] overall_cov = set ( ) [EOL] [EOL] for i in range ( [number] ) : [EOL] s = f . fuzz ( ) [EOL] with Coverage ( ) as cov : [EOL] urlparse ( s ) [EOL] overall_cov |= cov . coverage ( ) [EOL] [EOL] x = len ( f . expansion_coverage ( ) ) * [number] / len ( f . max_expansion_coverage ( ) ) [EOL] y = len ( overall_cov ) * [number] / len ( cov_max . coverage ( ) ) [EOL] if x not in coverages : [EOL] coverages [ x ] = [ ] [EOL] coverages [ x ] . append ( y ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] xs = list ( coverages . keys ( ) ) [EOL] ys = [ sum ( coverages [ x ] ) / len ( coverages [ x ] ) for x in coverages ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ax = plt . axes ( label = [string] ) [EOL] ax . yaxis . set_major_formatter ( mtick . PercentFormatter ( ) ) [EOL] ax . xaxis . set_major_formatter ( mtick . PercentFormatter ( ) ) [EOL] [EOL] plt . xlim ( [number] , max ( xs ) ) [EOL] plt . ylim ( [number] , max ( ys ) ) [EOL] [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . scatter ( xs , ys ) ; [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] np . corrcoef ( xs , ys ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] spearmanr ( xs , ys ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import US_PHONE_GRAMMAR [EOL] else : [EOL] from . Grammars import US_PHONE_GRAMMAR [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] phone_fuzzer = GrammarCoverageFuzzer ( US_PHONE_GRAMMAR ) [EOL] phone_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] phone_fuzzer . expansion_coverage ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] LS_EBNF_GRAMMAR = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , ] } [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_grammar ( LS_EBNF_GRAMMAR ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import convert_ebnf_grammar , srange [EOL] else : [EOL] from . Grammars import convert_ebnf_grammar , srange [EOL] [EOL] [EOL] LS_EBNF_GRAMMAR = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : srange ( [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_grammar ( LS_EBNF_GRAMMAR ) [EOL] [EOL] [EOL] LS_GRAMMAR = convert_ebnf_grammar ( LS_EBNF_GRAMMAR ) [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import ProgramRunner [EOL] else : [EOL] from . Fuzzer import ProgramRunner [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] f = GrammarCoverageFuzzer ( LS_GRAMMAR , max_nonterminals = [number] ) [EOL] while len ( f . max_expansion_coverage ( ) - f . expansion_coverage ( ) ) > [number] : [EOL] invocation = f . fuzz ( ) [EOL] print ( [string] , invocation , end = [string] ) [EOL] args = invocation . split ( ) [EOL] ls = ProgramRunner ( [ [string] ] + args ) [EOL] ls . run ( ) [EOL] print ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] import random [EOL] random . seed ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] from urlparse import urlparse [comment] [EOL] except ImportError : [EOL] from urllib . parse import urlparse [comment] [EOL] [EOL] urlparse ( [string] ) [EOL] [EOL] [EOL] def http_program ( url ) : [EOL] supported_schemes = [ [string] , [string] ] [EOL] result = urlparse ( url ) [EOL] if result . scheme not in supported_schemes : [EOL] raise ValueError ( [string] + repr ( supported_schemes ) ) [EOL] if result . netloc == [string] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [comment] [EOL] return True [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import fuzzer [EOL] else : [EOL] from . Fuzzer import fuzzer [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] fuzzer ( char_start = [number] , char_range = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for i in range ( [number] ) : [EOL] try : [EOL] url = fuzzer ( ) [EOL] result = http_program ( url ) [EOL] print ( [string] ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [number] ** [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [number] ** [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] likelihood = [number] / ( [number] ** [number] ) + [number] / ( [number] ** [number] ) [EOL] likelihood [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [number] / likelihood [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Timer import Timer [EOL] else : [EOL] from . Timer import Timer [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] trials = [number] [EOL] with Timer ( ) as t : [EOL] for i in range ( trials ) : [EOL] try : [EOL] url = fuzzer ( ) [EOL] result = http_program ( url ) [EOL] print ( [string] ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] duration_per_run_in_seconds = t . elapsed_time ( ) / trials [EOL] duration_per_run_in_seconds [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] seconds_until_success = duration_per_run_in_seconds * ( [number] / likelihood ) [EOL] seconds_until_success [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] hours_until_success = seconds_until_success / [number] [EOL] days_until_success = hours_until_success / [number] [EOL] years_until_success = days_until_success / [number] [EOL] years_until_success [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] import random [EOL] [EOL] def delete_random_character ( s ) : [EOL] [docstring] [EOL] if s == [string] : [EOL] return s [EOL] [EOL] pos = random . randint ( [number] , len ( s ) - [number] ) [EOL] [comment] [EOL] return s [ : pos ] + s [ pos + [number] : ] [EOL] [EOL] if __name__ == [string] : [EOL] seed_input = [string] [EOL] for i in range ( [number] ) : [EOL] x = delete_random_character ( seed_input ) [EOL] print ( repr ( x ) ) [EOL] [EOL] [EOL] def insert_random_character ( s ) : [EOL] [docstring] [EOL] pos = random . randint ( [number] , len ( s ) ) [EOL] random_character = chr ( random . randrange ( [number] , [number] ) ) [EOL] [comment] [EOL] return s [ : pos ] + random_character + s [ pos : ] [EOL] [EOL] if __name__ == [string] : [EOL] for i in range ( [number] ) : [EOL] print ( repr ( insert_random_character ( seed_input ) ) ) [EOL] [EOL] [EOL] def flip_random_character ( s ) : [EOL] [docstring] [EOL] if s == [string] : [EOL] return s [EOL] [EOL] pos = random . randint ( [number] , len ( s ) - [number] ) [EOL] c = s [ pos ] [EOL] bit = [number] << random . randint ( [number] , [number] ) [EOL] new_c = chr ( ord ( c ) ^ bit ) [EOL] [comment] [EOL] return s [ : pos ] + new_c + s [ pos + [number] : ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for i in range ( [number] ) : [EOL] print ( repr ( flip_random_character ( seed_input ) ) ) [EOL] [EOL] [EOL] def mutate ( s ) : [EOL] [docstring] [EOL] mutators = [ delete_random_character , insert_random_character , flip_random_character ] [EOL] mutator = random . choice ( mutators ) [EOL] [comment] [EOL] return mutator ( s ) [EOL] [EOL] if __name__ == [string] : [EOL] for i in range ( [number] ) : [EOL] print ( repr ( mutate ( [string] ) ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] def is_valid_url ( url ) : [EOL] try : [EOL] result = http_program ( url ) [EOL] return True [EOL] except ValueError : [EOL] return False [EOL] [EOL] if __name__ == [string] : [EOL] assert is_valid_url ( [string] ) [EOL] assert not is_valid_url ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] seed_input = [string] [EOL] valid_inputs = set ( ) [EOL] trials = [number] [EOL] [EOL] for i in range ( trials ) : [EOL] inp = mutate ( seed_input ) [EOL] if is_valid_url ( inp ) : [EOL] valid_inputs . add ( inp ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] len ( valid_inputs ) / trials [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] trials = [number] * [number] * len ( seed_input ) [EOL] trials [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Timer import Timer [EOL] else : [EOL] from . Timer import Timer [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] trials = [number] [EOL] with Timer ( ) as t : [EOL] while True : [EOL] trials += [number] [EOL] inp = mutate ( seed_input ) [EOL] if inp . startswith ( [string] ) : [EOL] print ( [string] , trials , [string] , t . elapsed_time ( ) , [string] ) [EOL] break [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] seed_input = [string] [EOL] mutations = [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] inp = seed_input [EOL] for i in range ( mutations ) : [EOL] if i % [number] == [number] : [EOL] print ( i , [string] , repr ( inp ) ) [EOL] inp = mutate ( inp ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import Fuzzer [EOL] else : [EOL] from . Fuzzer import Fuzzer [EOL] [EOL] [EOL] class MutationFuzzer ( Fuzzer ) : [EOL] def __init__ ( self , seed , min_mutations = [number] , max_mutations = [number] ) : [EOL] self . seed = seed [EOL] self . min_mutations = min_mutations [EOL] self . max_mutations = max_mutations [EOL] self . reset ( ) [EOL] [EOL] def reset ( self ) : [EOL] self . population = self . seed [EOL] self . seed_index = [number] [EOL] [EOL] class MutationFuzzer ( MutationFuzzer ) : [EOL] def mutate ( self , inp ) : [EOL] return mutate ( inp ) [EOL] [EOL] class MutationFuzzer ( MutationFuzzer ) : [EOL] def create_candidate ( self ) : [EOL] candidate = random . choice ( self . population ) [EOL] trials = random . randint ( self . min_mutations , self . max_mutations ) [EOL] for i in range ( trials ) : [EOL] candidate = self . mutate ( candidate ) [EOL] return candidate [EOL] [EOL] class MutationFuzzer ( MutationFuzzer ) : [EOL] def fuzz ( self ) : [EOL] if self . seed_index < len ( self . seed ) : [EOL] [comment] [EOL] self . inp = self . seed [ self . seed_index ] [EOL] self . seed_index += [number] [EOL] else : [EOL] [comment] [EOL] self . inp = self . create_candidate ( ) [EOL] return self . inp [EOL] [EOL] if __name__ == [string] : [EOL] seed_input = [string] [EOL] mutation_fuzzer = MutationFuzzer ( seed = [ seed_input ] ) [EOL] mutation_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mutation_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mutation_fuzzer . fuzz ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import Runner [EOL] else : [EOL] from . Fuzzer import Runner [EOL] [EOL] [EOL] class FunctionRunner ( Runner ) : [EOL] def __init__ ( self , function ) : [EOL] [docstring] [EOL] self . function = function [EOL] [EOL] def run_function ( self , inp ) : [EOL] return self . function ( inp ) [EOL] [EOL] def run ( self , inp ) : [EOL] try : [EOL] result = self . run_function ( inp ) [EOL] outcome = self . PASS [EOL] except Exception : [EOL] result = None [EOL] outcome = self . FAIL [EOL] [EOL] return result , outcome [EOL] [EOL] if __name__ == [string] : [EOL] http_runner = FunctionRunner ( http_program ) [EOL] http_runner . run ( [string] ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Coverage import Coverage , population_coverage [EOL] else : [EOL] from . Coverage import Coverage , population_coverage [EOL] [EOL] [EOL] class FunctionCoverageRunner ( FunctionRunner ) : [EOL] def run_function ( self , inp ) : [EOL] with Coverage ( ) as cov : [EOL] try : [EOL] result = super ( ) . run_function ( inp ) [EOL] except Exception as exc : [EOL] self . _coverage = cov . coverage ( ) [EOL] raise exc [EOL] [EOL] self . _coverage = cov . coverage ( ) [EOL] return result [EOL] [EOL] def coverage ( self ) : [EOL] return self . _coverage [EOL] [EOL] if __name__ == [string] : [EOL] http_runner = FunctionCoverageRunner ( http_program ) [EOL] http_runner . run ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( list ( http_runner . coverage ( ) ) [ : [number] ] ) [EOL] [EOL] [EOL] class MutationCoverageFuzzer ( MutationFuzzer ) : [EOL] def reset ( self ) : [EOL] super ( ) . reset ( ) [EOL] self . coverages_seen = set ( ) [EOL] [comment] [EOL] self . population = [ ] [EOL] [EOL] def run ( self , runner ) : [EOL] [docstring] [EOL] result , outcome = super ( ) . run ( runner ) [EOL] new_coverage = frozenset ( runner . coverage ( ) ) [EOL] if outcome == Runner . PASS and new_coverage not in self . coverages_seen : [EOL] [comment] [EOL] self . population . append ( self . inp ) [EOL] self . coverages_seen . add ( new_coverage ) [EOL] [EOL] return result [EOL] [EOL] if __name__ == [string] : [EOL] seed_input = [string] [EOL] mutation_fuzzer = MutationCoverageFuzzer ( seed = [ seed_input ] ) [EOL] mutation_fuzzer . runs ( http_runner , trials = [number] ) [EOL] mutation_fuzzer . population [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] all_coverage , cumulative_coverage = population_coverage ( mutation_fuzzer . population , http_program ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] plt . plot ( cumulative_coverage ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) ; [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] seed_input = [string] [EOL] mutation_fuzzer = MutationFuzzer ( seed = [ seed_input ] ) [EOL] [ mutation_fuzzer . fuzz ( ) for i in range ( [number] ) ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mutation_fuzzer = MutationCoverageFuzzer ( seed = [ seed_input ] ) [EOL] mutation_fuzzer . runs ( http_runner , trials = [number] ) [EOL] mutation_fuzzer . population [ : [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Coverage import cgi_decode [EOL] else : [EOL] from . Coverage import cgi_decode [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] seed = [ [string] ] [EOL] cgi_runner = FunctionCoverageRunner ( cgi_decode ) [EOL] m = MutationCoverageFuzzer ( seed ) [EOL] results = m . runs ( cgi_runner , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] m . population [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_runner . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] all_coverage , cumulative_coverage = population_coverage ( m . population , cgi_decode ) [EOL] [EOL] import matplotlib . pyplot as plt [EOL] plt . plot ( cumulative_coverage ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) ; [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import ProgramRunner [EOL] else : [EOL] from . Fuzzer import ProgramRunner [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] seed = [ [string] ] [EOL] bc = ProgramRunner ( program = [string] ) [EOL] m = MutationFuzzer ( seed ) [EOL] outcomes = m . runs ( bc , trials = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] outcomes [ : [number] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sum ( [number] for completed_process , outcome in outcomes if completed_process . stderr == [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import random [EOL] [EOL] def set_fixed_seed ( seed = [number] ) : [EOL] [comment] [EOL] random . seed ( seed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import random [EOL] [EOL] def set_fixed_seed ( seed = [number] ) : [EOL] [comment] [EOL] random . seed ( seed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import random [EOL] [EOL] def set_fixed_seed ( seed = [number] ) : [EOL] [comment] [EOL] random . seed ( seed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import random [EOL] [EOL] def set_fixed_seed ( seed = [number] ) : [EOL] [comment] [EOL] random . seed ( seed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Set , Dict , Any , List [EOL] import typing [EOL] import docs [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] import random [EOL] random . seed ( [number] ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Parser import PEGParser [EOL] else : [EOL] from . Parser import PEGParser [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import GrammarFuzzer [EOL] else : [EOL] from . GrammarFuzzer import GrammarFuzzer [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] import string [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import crange , syntax_diagram [EOL] else : [EOL] from . Grammars import crange , syntax_diagram [EOL] [EOL] [EOL] VAR_GRAMMAR = { [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : list ( string . ascii_letters ) , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : crange ( [string] , [string] ) } [EOL] [EOL] if __name__ == [string] : [EOL] syntax_diagram ( VAR_GRAMMAR ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mystring = [string] [EOL] [EOL] [EOL] def hl_predicate ( _d , _n , symbol , _a ) : return symbol in { [string] , [string] } [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Parser import PEGParser , highlight_node [EOL] else : [EOL] from . Parser import PEGParser , highlight_node [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import display_tree [EOL] else : [EOL] from . GrammarFuzzer import display_tree [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = PEGParser ( VAR_GRAMMAR ) [EOL] for tree in parser . parse ( mystring ) : [EOL] display_tree ( tree , node_attr = highlight_node ( hl_predicate ) ) [EOL] [EOL] [EOL] VAR_TOKENS = { [string] , [string] } [EOL] [EOL] if __name__ == [string] : [EOL] mystring = [string] [EOL] parser = PEGParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) [EOL] for tree in parser . parse ( mystring ) : [EOL] display_tree ( tree , node_attr = highlight_node ( hl_predicate ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mystrings = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import Fuzzer [EOL] else : [EOL] from . Fuzzer import Fuzzer [EOL] [EOL] [EOL] class LangFuzzer ( Fuzzer ) : [EOL] def __init__ ( self , parser ) : [EOL] self . parser = parser [EOL] self . fragments = { k : [ ] for k in self . parser . cgrammar } [EOL] [EOL] def traverse_tree ( self , node ) : [EOL] counter = [number] [EOL] nodes = { } [EOL] [EOL] def helper ( node , id ) : [EOL] nonlocal counter [EOL] name , children = node [EOL] new_children = [ ] [EOL] nodes [ id ] = node [EOL] for child in children : [EOL] counter += [number] [EOL] new_children . append ( helper ( child , counter ) ) [EOL] return name , new_children , id [EOL] [EOL] return helper ( node , counter ) , nodes [EOL] [EOL] def fragment ( self , strings ) : [EOL] self . trees = [ ] [EOL] for string in strings : [EOL] for tree in self . parser . parse ( string ) : [EOL] tree , nodes = self . traverse_tree ( tree ) [EOL] self . trees . append ( ( tree , nodes ) ) [EOL] for node in nodes : [EOL] symbol = nodes [ node ] [ [number] ] [EOL] if symbol in self . fragments : [EOL] self . fragments [ symbol ] . append ( nodes [ node ] ) [EOL] return self . fragments [EOL] [EOL] if __name__ == [string] : [EOL] lf = LangFuzzer ( PEGParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) ) [EOL] fragments = lf . fragment ( mystrings ) [EOL] for key in fragments : [EOL] print ( [string] % ( key , len ( fragments [ key ] ) ) ) [EOL] [EOL] [EOL] import random [EOL] [EOL] class LangFuzzer ( LangFuzzer ) : [EOL] def __init__ ( self , parser , strings ) : [EOL] self . parser = parser [EOL] self . fragments = { k : [ ] for k in self . parser . cgrammar } [EOL] self . fragment ( strings ) [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class LangFuzzer ( LangFuzzer ) : [EOL] def candidate ( self ) : [EOL] tree , nodes = random . choice ( self . trees ) [EOL] interesting_nodes = [ n for n in nodes if nodes [ n ] [ [number] ] in self . fragments [EOL] and len ( self . fragments [ nodes [ n ] [ [number] ] ] ) > [number] ] [EOL] node = random . choice ( interesting_nodes ) [EOL] return tree , node [EOL] [EOL] if __name__ == [string] : [EOL] random . seed ( [number] ) [EOL] lf = LangFuzzer ( PEGParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) , mystrings ) [EOL] tree , node = lf . candidate ( ) [EOL] [EOL] [EOL] def hl_predicate ( _d , nid , _s , _a ) : return nid in { node } [EOL] [EOL] if __name__ == [string] : [EOL] display_tree ( tree , node_attr = highlight_node ( hl_predicate ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class LangFuzzer ( LangFuzzer ) : [EOL] def generate_new_tree ( self , node , choice ) : [EOL] name , children , id = node [EOL] if id == choice : [EOL] return random . choice ( self . fragments [ name ] ) [EOL] else : [EOL] return ( name , [ self . generate_new_tree ( c , choice ) for c in children ] ) [EOL] [EOL] if __name__ == [string] : [EOL] random . seed ( [number] ) [EOL] lf = LangFuzzer ( PEGParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) , mystrings ) [EOL] tree , node = lf . candidate ( ) [EOL] [EOL] [EOL] def hl_predicate ( _d , nid , _s , _a ) : return nid in { node } [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import tree_to_string [EOL] else : [EOL] from . GrammarFuzzer import tree_to_string [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] new_tree = lf . generate_new_tree ( tree , node ) [EOL] for s in [ tree_to_string ( i ) for i in [ tree , new_tree ] ] : [EOL] print ( s ) [EOL] display_tree ( new_tree , node_attr = highlight_node ( hl_predicate ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class LangFuzzer ( LangFuzzer ) : [EOL] def fuzz ( self ) : [EOL] tree , node = self . candidate ( ) [EOL] modified = self . generate_new_tree ( tree , node ) [EOL] return tree_to_string ( modified ) [EOL] [EOL] if __name__ == [string] : [EOL] lf = LangFuzzer ( PEGParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) , mystrings ) [EOL] for i in range ( [number] ) : [EOL] print ( lf . fuzz ( ) ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Timer import Timer [EOL] else : [EOL] from . Timer import Timer [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] trials = [number] [EOL] [EOL] lf = LangFuzzer ( PEGParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) , mystrings ) [EOL] valid = [ ] [EOL] time = [number] [EOL] for i in range ( trials ) : [EOL] with Timer ( ) as t : [EOL] s = lf . fuzz ( ) [EOL] try : [EOL] exec ( s , { } , { } ) [EOL] valid . append ( ( s , t . elapsed_time ( ) ) ) [EOL] except : [EOL] pass [EOL] time += t . elapsed_time ( ) [EOL] print ( [string] % ( len ( valid ) , len ( valid ) * [number] / trials ) ) [EOL] print ( [string] % time ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] gf = GrammarFuzzer ( VAR_GRAMMAR ) [EOL] valid = [ ] [EOL] time = [number] [EOL] for i in range ( trials ) : [EOL] with Timer ( ) as t : [EOL] s = gf . fuzz ( ) [EOL] try : [EOL] exec ( s , { } , { } ) [EOL] valid . append ( s ) [EOL] except : [EOL] pass [EOL] time += t . elapsed_time ( ) [EOL] print ( [string] % ( len ( valid ) , len ( valid ) * [number] / trials ) ) [EOL] print ( [string] % time ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Grammars import EXPR_GRAMMAR [EOL] else : [EOL] from . Grammars import EXPR_GRAMMAR [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from GrammarFuzzer import display_tree [EOL] else : [EOL] from . GrammarFuzzer import display_tree [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Parser import EarleyParser [EOL] else : [EOL] from . Parser import EarleyParser [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = EarleyParser ( EXPR_GRAMMAR ) [EOL] tree , * _ = parser . parse ( [string] ) [EOL] display_tree ( tree ) [EOL] [EOL] [EOL] def mutate_tree ( tree , grammar ) : [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class LangFuzzer2 ( LangFuzzer ) : [EOL] def __init__ ( self , parser , strings ) : [EOL] super ( ) . __init__ ( parser , strings ) [EOL] self . gfuzz = GrammarFuzzer ( parser . grammar ( ) ) [EOL] [EOL] def check_diversity ( self , pool ) : [EOL] return len ( pool ) > [number] [EOL] [EOL] def candidate ( self ) : [EOL] tree , nodes = random . choice ( self . trees ) [EOL] interesting_nodes = [ n for n in nodes if nodes [ n ] [ [number] ] in self . fragments [EOL] and nodes [ n ] [ [number] ] is not self . parser . start_symbol ( ) [EOL] and len ( self . fragments [ nodes [ n ] [ [number] ] ] ) > [number] ] [EOL] node = random . choice ( interesting_nodes ) [EOL] return tree , node [EOL] [EOL] def generate_new_tree ( self , node , choice ) : [EOL] name , children , id = node [EOL] if id == choice : [EOL] pool = self . fragments [ name ] [EOL] if self . check_diversity ( pool ) : [EOL] return random . choice ( self . fragments [ name ] ) [EOL] else : [EOL] return None [EOL] else : [EOL] return ( name , [ self . generate_new_tree ( c , choice ) for c in children ] ) [EOL] [EOL] def fuzz ( self ) : [EOL] tree , node = self . candidate ( ) [EOL] tree_with_a_hole = self . generate_new_tree ( tree , node ) [EOL] modified = self . gfuzz . expand_tree ( tree_with_a_hole ) [EOL] return tree_to_string ( modified ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = EarleyParser ( VAR_GRAMMAR , tokens = VAR_TOKENS ) [EOL] lf = LangFuzzer2 ( parser , mystrings ) [EOL] for i in range ( [number] ) : [EOL] print ( lf . fuzz ( ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Any$ 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $docs.code.LangFuzzer.LangFuzzer$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Set , Dict , Any , List [EOL] import typing [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] def cgi_decode ( s ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] hex_values = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] t = [string] [EOL] i = [number] [EOL] while i < len ( s ) : [EOL] c = s [ i ] [EOL] if c == [string] : [EOL] t += [string] [EOL] elif c == [string] : [EOL] digit_high , digit_low = s [ i + [number] ] , s [ i + [number] ] [EOL] i += [number] [EOL] if digit_high in hex_values and digit_low in hex_values : [EOL] v = hex_values [ digit_high ] * [number] + hex_values [ digit_low ] [EOL] t += chr ( v ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] t += c [EOL] i += [number] [EOL] return t [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert cgi_decode ( [string] ) == [string] [EOL] assert cgi_decode ( [string] ) == [string] [EOL] assert cgi_decode ( [string] ) == [string] [EOL] [EOL] try : [EOL] cgi_decode ( [string] ) [EOL] assert False [EOL] except ValueError : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] coverage = [ ] [EOL] [EOL] [EOL] def traceit ( frame , event , arg ) : [EOL] if event == [string] : [EOL] global coverage [EOL] function_name = frame . f_code . co_name [EOL] lineno = frame . f_lineno [EOL] coverage . append ( lineno ) [EOL] return traceit [EOL] [EOL] import sys [EOL] [EOL] def cgi_decode_traced ( s ) : [EOL] global coverage [EOL] coverage = [ ] [EOL] sys . settrace ( traceit ) [comment] [EOL] cgi_decode ( s ) [EOL] sys . settrace ( None ) [comment] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode_traced ( [string] ) [EOL] print ( coverage ) [EOL] [EOL] [EOL] import inspect [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode_code = inspect . getsource ( cgi_decode ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from fuzzingbook_utils import print_content , print_file [EOL] else : [EOL] from . fuzzingbook_utils import print_content , print_file [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print_content ( cgi_decode_code [ : [number] ] + [string] , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode_lines = [ [string] ] + cgi_decode_code . splitlines ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode_lines [ [number] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode_lines [ [number] : [number] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_decode_lines [ [number] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] covered_lines = set ( coverage ) [EOL] print ( covered_lines ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for lineno in range ( [number] , len ( cgi_decode_lines ) ) : [EOL] if lineno not in covered_lines : [EOL] print ( [string] , end = [string] ) [EOL] else : [EOL] print ( [string] , end = [string] ) [EOL] print ( [string] % lineno , end = [string] ) [EOL] print_content ( cgi_decode_lines [ lineno ] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class Coverage ( object ) : [EOL] [comment] [EOL] def traceit ( self , frame , event , arg ) : [EOL] if self . original_trace_function is not None : [EOL] self . original_trace_function ( frame , event , arg ) [EOL] [EOL] if event == [string] : [EOL] function_name = frame . f_code . co_name [EOL] lineno = frame . f_lineno [EOL] self . _trace . append ( ( function_name , lineno ) ) [EOL] [EOL] return self . traceit [EOL] [EOL] def __init__ ( self ) : [EOL] self . _trace = [ ] [EOL] [EOL] [comment] [EOL] def __enter__ ( self ) : [EOL] self . original_trace_function = sys . gettrace ( ) [EOL] sys . settrace ( self . traceit ) [EOL] return self [EOL] [EOL] [comment] [EOL] def __exit__ ( self , exc_type , exc_value , tb ) : [EOL] sys . settrace ( self . original_trace_function ) [EOL] [EOL] def trace ( self ) : [EOL] [docstring] [EOL] return self . _trace [EOL] [EOL] def coverage ( self ) : [EOL] [docstring] [EOL] return set ( self . trace ( ) ) [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov : [EOL] cgi_decode ( [string] ) [EOL] [EOL] print ( cov . coverage ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov_plus : [EOL] cgi_decode ( [string] ) [EOL] with Coverage ( ) as cov_standard : [EOL] cgi_decode ( [string] ) [EOL] [EOL] cov_plus . coverage ( ) - cov_standard . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] import random [EOL] random . seed ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov_max : [EOL] cgi_decode ( [string] ) [EOL] cgi_decode ( [string] ) [EOL] cgi_decode ( [string] ) [EOL] try : [EOL] cgi_decode ( [string] ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cov_max . coverage ( ) - cov_plus . coverage ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from Fuzzer import fuzzer [EOL] else : [EOL] from . Fuzzer import fuzzer [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sample = fuzzer ( ) [EOL] sample [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov_fuzz : [EOL] try : [EOL] cgi_decode ( sample ) [EOL] except : [EOL] pass [EOL] cov_fuzz . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cov_max . coverage ( ) - cov_fuzz . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] trials = [number] [EOL] [EOL] [EOL] def population_coverage ( population , function ) : [EOL] cumulative_coverage = [ ] [EOL] all_coverage = set ( ) [EOL] [EOL] for s in population : [EOL] with Coverage ( ) as cov : [EOL] try : [EOL] function ( s ) [EOL] except : [EOL] pass [EOL] all_coverage |= cov . coverage ( ) [EOL] cumulative_coverage . append ( len ( all_coverage ) ) [EOL] [EOL] return all_coverage , cumulative_coverage [EOL] [EOL] def hundred_inputs ( ) : [EOL] population = [ ] [EOL] for i in range ( trials ) : [EOL] population . append ( fuzzer ( ) ) [EOL] return population [EOL] [EOL] if __name__ == [string] : [EOL] all_coverage , cumulative_coverage = population_coverage ( hundred_inputs ( ) , cgi_decode ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] plt . plot ( cumulative_coverage ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] runs = [number] [EOL] [EOL] [comment] [EOL] sum_coverage = [ [number] ] * trials [EOL] [EOL] for run in range ( runs ) : [EOL] all_coverage , coverage = population_coverage ( hundred_inputs ( ) , cgi_decode ) [EOL] assert len ( coverage ) == trials [EOL] for i in range ( trials ) : [EOL] sum_coverage [ i ] += coverage [ i ] [EOL] [EOL] average_coverage = [ ] [EOL] for i in range ( trials ) : [EOL] average_coverage . append ( sum_coverage [ i ] / runs ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] plt . plot ( average_coverage ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_c_code = [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_c_code += [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_c_code += [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_c_code += [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( cgi_c_code ) [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from fuzzingbook_utils import print_file [EOL] else : [EOL] from . fuzzingbook_utils import print_file [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print_file ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import os [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] lines = open ( [string] ) . readlines ( ) [EOL] for i in range ( [number] , [number] ) : [EOL] print ( lines [ i ] , end = [string] ) [EOL] [EOL] [EOL] def read_gcov_coverage ( c_file ) : [EOL] gcov_file = c_file + [string] [EOL] coverage = set ( ) [EOL] with open ( gcov_file ) as file : [EOL] for line in file . readlines ( ) : [EOL] elems = line . split ( [string] ) [EOL] covered = elems [ [number] ] . strip ( ) [EOL] line_number = int ( elems [ [number] ] . strip ( ) ) [EOL] if covered . startswith ( [string] ) or covered . startswith ( [string] ) : [EOL] continue [EOL] coverage . add ( ( c_file , line_number ) ) [EOL] return coverage [EOL] [EOL] if __name__ == [string] : [EOL] coverage = read_gcov_coverage ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] list ( coverage ) [ : [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __package__ is None or __package__ == [string] : [EOL] from ExpectError import ExpectError [EOL] else : [EOL] from . ExpectError import ExpectError [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with ExpectError ( ) : [EOL] for i in range ( trials ) : [EOL] try : [EOL] s = fuzzer ( ) [EOL] cgi_decode ( s ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] s [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov : [EOL] cgi_decode ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( cov . trace ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( cov . coverage ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] import os [EOL] import glob [EOL] [EOL] if __name__ == [string] : [EOL] for file in glob . glob ( [string] ) + glob . glob ( [string] ) : [EOL] os . remove ( file ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with ExpectError ( ) : [EOL] assert cgi_decode ( [string] ) == [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with ExpectError ( ) : [EOL] assert cgi_decode ( [string] ) == [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert cgi_decode ( [string] ) == [string] [EOL] [EOL] [EOL] def fixed_cgi_decode ( s ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] hex_values = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] t = [string] [EOL] i = [number] [EOL] while i < len ( s ) : [EOL] c = s [ i ] [EOL] if c == [string] : [EOL] t += [string] [EOL] elif c == [string] and i + [number] < len ( s ) : [comment] [EOL] digit_high , digit_low = s [ i + [number] ] , s [ i + [number] ] [EOL] i += [number] [EOL] if digit_high in hex_values and digit_low in hex_values : [EOL] v = hex_values [ digit_high ] * [number] + hex_values [ digit_low ] [EOL] t += chr ( v ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] t += c [EOL] i += [number] [EOL] return t [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert fixed_cgi_decode ( [string] ) == [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert fixed_cgi_decode ( [string] ) == [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] assert fixed_cgi_decode ( [string] ) == [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for i in range ( trials ) : [EOL] try : [EOL] s = fuzzer ( ) [EOL] fixed_cgi_decode ( s ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cgi_c_code = cgi_c_code . replace ( [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with Coverage ( ) as cov : [EOL] cgi_decode ( [string] ) [EOL] trace = cov . trace ( ) [EOL] trace [ : [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] def branch_coverage ( trace ) : [EOL] coverage = set ( ) [EOL] past_line = None [EOL] for line in trace : [EOL] if past_line is not None : [EOL] coverage . add ( ( past_line , line ) ) [EOL] past_line = line [EOL] [EOL] return coverage [EOL] [EOL] if __name__ == [string] : [EOL] branch_coverage ( trace ) [EOL] [EOL] [EOL] class BranchCoverage ( Coverage ) : [EOL] def coverage ( self ) : [EOL] [docstring] [EOL] coverage = set ( ) [EOL] past_line = None [EOL] for line in self . trace ( ) : [EOL] if past_line is not None : [EOL] coverage . add ( ( past_line , line ) ) [EOL] past_line = line [EOL] [EOL] return coverage [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with BranchCoverage ( ) as cov : [EOL] cgi_decode ( [string] ) [EOL] [EOL] print ( cov . coverage ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with BranchCoverage ( ) as cov_plus : [EOL] cgi_decode ( [string] ) [EOL] with BranchCoverage ( ) as cov_standard : [EOL] cgi_decode ( [string] ) [EOL] [EOL] cov_plus . coverage ( ) - cov_standard . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with BranchCoverage ( ) as cov_max : [EOL] cgi_decode ( [string] ) [EOL] cgi_decode ( [string] ) [EOL] cgi_decode ( [string] ) [EOL] try : [EOL] cgi_decode ( [string] ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cov_max . coverage ( ) - cov_plus . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sample [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with BranchCoverage ( ) as cov_fuzz : [EOL] try : [EOL] cgi_decode ( s ) [EOL] except : [EOL] pass [EOL] cov_fuzz . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cov_max . coverage ( ) - cov_fuzz . coverage ( ) [EOL] [EOL] [EOL] def population_branch_coverage ( population , function ) : [EOL] cumulative_coverage = [ ] [EOL] all_coverage = set ( ) [EOL] [EOL] for s in population : [EOL] with BranchCoverage ( ) as cov : [EOL] try : [EOL] function ( s ) [EOL] except : [EOL] pass [EOL] all_coverage |= cov . coverage ( ) [EOL] cumulative_coverage . append ( len ( all_coverage ) ) [EOL] [EOL] return all_coverage , cumulative_coverage [EOL] [EOL] if __name__ == [string] : [EOL] all_branch_coverage , cumulative_branch_coverage = population_branch_coverage ( hundred_inputs ( ) , cgi_decode ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] import matplotlib . pyplot as plt [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] plt . plot ( cumulative_branch_coverage ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] len ( cov_max . coverage ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] all_branch_coverage - cov_max . coverage ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cov_max . coverage ( ) - all_branch_coverage [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] runs = [number] [EOL] [EOL] [comment] [EOL] sum_coverage = [ [number] ] * trials [EOL] [EOL] for run in range ( runs ) : [EOL] all_branch_coverage , coverage = population_branch_coverage ( hundred_inputs ( ) , cgi_decode ) [EOL] assert len ( coverage ) == trials [EOL] for i in range ( trials ) : [EOL] sum_coverage [ i ] += coverage [ i ] [EOL] [EOL] average_coverage = [ ] [EOL] for i in range ( trials ) : [EOL] average_coverage . append ( sum_coverage [ i ] / runs ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] plt . plot ( average_coverage ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import random [EOL] [EOL] def set_fixed_seed ( seed = [number] ) : [EOL] [comment] [EOL] random . seed ( seed )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0