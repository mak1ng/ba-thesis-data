from typing import Any [EOL] import python [EOL] import typing [EOL] import task [EOL] import pathos . multiprocessing as mp [EOL] import pathos . helpers as mph [EOL] import glog as log [EOL] import psutil [EOL] [EOL] from . task import Task [EOL] from . result import Result [EOL] [EOL] class Worker ( mph . mp . Process ) : [EOL] wid = [number] [EOL] def __init__ ( self , result_queue ) : [EOL] super ( Worker , self ) . __init__ ( ) [EOL] self . task_queue = mph . mp . Queue ( ) [EOL] self . result_queue = result_queue [EOL] self . id = Worker . wid [EOL] Worker . wid += [number] [EOL] [EOL] self . running = False [EOL] [EOL] def run ( self ) : [EOL] while True : [EOL] task = self . task_queue . get ( ) [EOL] if task is None : [EOL] [comment] [EOL] log . info ( [string] % self . id ) [EOL] break [EOL] data = task . func ( * task . args , ** task . kwargs ) [EOL] result = Result ( task . id , data ) [EOL] self . result_queue . put ( result ) [EOL] return [EOL] [EOL] def start ( self ) : [EOL] if not self . running : [EOL] super ( Worker , self ) . start ( ) [EOL] self . process = psutil . Process ( self . pid ) [EOL] self . running = True [EOL] else : [EOL] log . warn ( [string] % self . id ) [EOL] [EOL] def stop ( self ) : [EOL] if self . running : [EOL] self . task_queue . put ( None ) [EOL] self . running = False [EOL] else : [EOL] log . warn ( [string] % self . id ) [EOL] [EOL] def suspend ( self ) : [EOL] self . process . suspend ( ) [EOL] [EOL] def resume ( self ) : [EOL] self . process . resume ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Task$ 0 0 0 0 0 0 0 0 0 0 $Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $Task$ 0 0 0 0 $Task$ 0 0 0 0 $Task$ 0 0 0 0 $python.dino.result.Result$ 0 0 0 $Task$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $python.dino.result.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] [EOL] class Result : [EOL] rid = [number] [EOL] def __init__ ( self , tid , data ) : [EOL] self . id = Result . rid [EOL] self . tid = tid [EOL] self . data = data [EOL] [EOL] Result . rid += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] vname = str [EOL] argname = str [EOL]	0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 $typing.Type[builtins.str]$ 0 0 0
import builtins [EOL] from typing import Set , Dict , Callable , Any , List [EOL] import python [EOL] import types [EOL] import vertex [EOL] import typing [EOL] import typing [EOL] from . vertex import Vertex [EOL] from . types import vname , argname [EOL] [EOL] from collections import deque [EOL] [EOL] GRAY , BLACK = [number] , [number] [EOL] [EOL] def topological ( graph ) : [EOL] order , enter , state = deque ( ) , set ( graph ) , { } [EOL] [EOL] def dfs ( node ) : [EOL] state [ node ] = GRAY [EOL] for k in graph . get ( node , ( ) ) : [EOL] sk = state . get ( k , None ) [EOL] if sk == GRAY : raise ValueError ( [string] ) [EOL] if sk == BLACK : continue [EOL] enter . discard ( k ) [EOL] dfs ( k ) [EOL] order . appendleft ( node ) [EOL] state [ node ] = BLACK [EOL] [EOL] while enter : dfs ( enter . pop ( ) ) [EOL] return order [EOL] [EOL] class Graph : [EOL] def __init__ ( self ) : [EOL] self . vertices = { } [EOL] self . edges = { } [EOL] [EOL] def addVertex ( self , name , function ) : [EOL] assert name not in self . vertices , [string] % name [EOL] [EOL] self . vertices [ name ] = Vertex ( name , function ) [EOL] [EOL] [comment] [EOL] if name not in self . edges : [EOL] self . edges [ name ] = { } [EOL] [EOL] def removeVertex ( self , name ) : [EOL] self . checkVertex ( name ) [EOL] for src in self . edges : [EOL] self . removeEdge ( src , name ) [EOL] [EOL] del self . vertices [ name ] [EOL] del self . edges [ name ] [EOL] [EOL] def removeVertices ( self , * names ) : [EOL] for name in names : [EOL] self . removeVertex ( name ) [EOL] [EOL] def addEdge ( self , src , dst , arg ) : [EOL] self . checkVertex ( src ) [EOL] self . checkVertex ( dst ) [EOL] [EOL] assert arg in self . vertices [ dst ] . args , [string] % ( src , dst , arg ) [EOL] assert arg not in self . getFulfilledArgs ( dst ) , [string] % ( arg , dst ) [EOL] [EOL] if dst not in self . edges [ src ] : [EOL] self . edges [ src ] [ dst ] = arg [EOL] [EOL] def removeEdge ( self , src , dst ) : [EOL] self . checkVertex ( src ) [EOL] self . checkVertex ( dst ) [EOL] [EOL] [comment] [EOL] if src in self . edges and dst in self . edges [ src ] : [EOL] del self . edges [ src ] [ dst ] [EOL] [EOL] def checkVertex ( self , name ) : [EOL] assert name in self . vertices , [string] % name [EOL] [EOL] [comment] [EOL] def getSources ( self ) : [EOL] sources = { } [EOL] names = set ( ) [EOL] [EOL] for name in self . edges : [EOL] names . update ( self . edges [ name ] . keys ( ) ) [EOL] [EOL] names = set ( self . vertices . keys ( ) ) . difference ( names ) [EOL] [EOL] sources = { name : self . vertices [ name ] for name in names } [EOL] return sources [EOL] [EOL] [comment] [EOL] def getSinks ( self ) : [EOL] sinks = { } [EOL] [EOL] for vname in self . vertices : [EOL] if vname not in self . edges or len ( self . edges [ vname ] ) == [number] : [EOL] sinks [ vname ] = self . vertices [ vname ] [EOL] [EOL] assert len ( sinks ) == [number] , [string] [EOL] [EOL] return sinks [EOL] [EOL] [comment] [EOL] def getDependencies ( self , dst ) : [EOL] dependencies = [ ] [EOL] [EOL] for src in self . edges : [EOL] if dst in self . edges [ src ] : [EOL] dependencies . append ( src ) [EOL] [EOL] return dependencies [EOL] [EOL] def getFulfilledArgs ( self , dst ) : [EOL] fulfilled = [ ] [EOL] [EOL] for src in self . edges : [EOL] if dst in self . edges [ src ] : [EOL] fulfilled . append ( self . edges [ src ] [ dst ] ) [EOL] [EOL] return fulfilled [EOL] [EOL] def getTopological ( self ) : [EOL] return [ self . vertices [ vid ] for vid in topological ( self . edges ) ] [EOL] [EOL] def run ( self , data ) : [EOL] [comment] [EOL] sources = self . getSources ( ) [EOL] [EOL] for name in sources : [EOL] assert name in data , [string] % name [EOL] [EOL] results = { } [EOL] [EOL] [comment] [EOL] order = topological ( self . edges ) [EOL] [EOL] for dst in order : [EOL] args = { } [EOL] if dst in sources : [EOL] args = data [ dst ] [EOL] else : [EOL] srcs = self . getDependencies ( dst ) [EOL] for src in srcs : [EOL] args [ self . edges [ src ] [ dst ] ] = results [ src ] [EOL] results [ dst ] = self . vertices [ dst ] . run ( ** args ) [EOL] [EOL] return results [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( [ [string] % ( src , [string] . join ( [ str ( dst ) for dst in self . edges [ src ] ] ) ) for src in self . edges ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import dino [EOL] import time [EOL] import click [EOL] import typing [EOL] import glog as log [EOL] import pathos . multiprocessing as mp [EOL] import pathos . helpers as mph [EOL] import numpy as np [EOL] [EOL] import dino . examples [EOL] [EOL] @ click . group ( context_settings = dict ( help_option_names = [ [string] , [string] ] ) ) def cli ( ) : [EOL] [docstring] [EOL] [EOL] @ cli . command ( ) def graph ( ) : [EOL] [docstring] [EOL] [EOL] dino . examples . graph_simple ( ) [EOL] [EOL] [EOL] @ cli . command ( ) @ click . option ( [string] , [string] , default = [number] , type = int , help = [string] ) def worker ( num_workers ) : [EOL] [docstring] [EOL] click . echo ( [string] % num_workers ) [EOL] [EOL] scheduler = dino . Scheduler ( num_workers ) [EOL] scheduler . start ( ) [EOL] [EOL] def test ( * args , ** kwargs ) : [EOL] for arg in args : [EOL] print ( arg ) [EOL] for kwarg in kwargs : [EOL] print ( [string] % ( str ( kwarg ) , str ( kwargs [ kwarg ] ) ) ) [EOL] [EOL] return [number] [EOL] [EOL] args = [ [number] , [number] , [number] ] [EOL] kwargs = { [string] : [number] , [string] : [number] } [EOL] task1 = dino . Task ( test , * args , ** kwargs ) [EOL] task2 = dino . Task ( lambda x : x * [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] scheduler . schedule ( task1 , task2 ) [EOL] scheduler . stop ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import glog as log [EOL] import typing [EOL] import json [EOL] [EOL] from . vertex import Vertex [EOL] from . graph import Graph [EOL] from . worker import Worker [EOL] from . scheduler import Scheduler [EOL] from . task import Task [EOL] from . result import Result [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class Task : [EOL] tid = [number] [EOL] def __init__ ( self , func , * args , ** kwargs ) : [EOL] self . id = Task . tid [EOL] [EOL] self . func = func [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] [EOL] Task . tid += [number] [EOL]	0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable [EOL] import types [EOL] import typing [EOL] import builtins [EOL] import time [EOL] import typing [EOL] import inspect [EOL] import glog as log [EOL] [EOL] from . types import vname , argname [EOL] [EOL] [comment] [EOL] class Vertex : [EOL] vid = [number] [EOL] [EOL] def __init__ ( self , name , function ) : [EOL] self . name = name [EOL] self . function = function [EOL] self . args = inspect . getfullargspec ( self . function ) . args [EOL] self . id = Vertex . vid [EOL] Vertex . vid += [number] [EOL] [EOL] def run ( self , * args , ** kwargs ) : [EOL] log . error ( [string] % self . name ) [EOL] beg = time . time ( ) [EOL] result = self . function ( * args , ** kwargs ) [EOL] end = time . time ( ) [EOL] log . info ( [string] % ( self . name , [string] . format ( ( end - beg ) * [number] ) ) ) [EOL] return result [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import threading [EOL] import task [EOL] import worker [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] import select [EOL] import threading [EOL] import pathos . helpers as mph [EOL] [EOL] from . worker import Worker [EOL] from . task import Task [EOL] [EOL] class Scheduler : [EOL] def __init__ ( self , num_workers = [number] ) : [EOL] self . num_workers = num_workers [EOL] [EOL] self . result_queue = mph . mp . Queue ( ) [EOL] self . result_thread = threading . Thread ( target = self . handle_results ) [EOL] [EOL] self . workers = [ ] [EOL] for _ in range ( num_workers ) : [EOL] self . workers . append ( Worker ( self . result_queue ) ) [EOL] [EOL] self . next_queue = [number] [EOL] [EOL] self . tids = set ( ) [EOL] [EOL] def schedule ( self , * tasks ) : [EOL] [comment] [EOL] for task in tasks : [EOL] self . workers [ self . next_queue ] . task_queue . put ( task ) [EOL] self . next_queue = ( self . next_queue + [number] ) % self . num_workers [EOL] self . tids . add ( task . id ) [EOL] [EOL] [comment] [EOL] def start ( self ) : [EOL] for worker in self . workers : [EOL] worker . start ( ) [EOL] [EOL] self . result_thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] for worker in self . workers : [EOL] worker . stop ( ) [EOL] [EOL] self . result_queue . put ( None ) [EOL] [EOL] [comment] [EOL] self . result_thread . join ( ) [EOL] [EOL] def handle_results ( self ) : [EOL] received_poison = False [EOL] while True : [EOL] result = self . result_queue . get ( ) [EOL] if result is None : [EOL] if not self . tids : [EOL] break [EOL] else : [EOL] received_poison = True [EOL] else : [EOL] self . tids . remove ( result . tid ) [EOL] print ( result . tid , result . data ) [EOL] [EOL] if received_poison and not self . tids : [EOL] break [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[worker.Worker]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[worker.Worker]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 $task.Task$ 0 0 0 0 0 0 0 0 $task.Task$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from . graph_simple import graph_simple [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import numpy [EOL] import dino [EOL] import numpy as np [EOL] [EOL] def forwardMatrix ( mat ) : [EOL] return mat [EOL] [EOL] def createMatrix ( n ) : [EOL] return np . random . rand ( n , n ) [EOL] [EOL] def transposeMatrix ( mat ) : [EOL] return np . transpose ( mat ) [EOL] [EOL] def multiplyMatrix ( mat1 , mat2 ) : [EOL] return np . matmul ( mat1 , mat2 ) [EOL] [EOL] def graph_simple ( ) : [EOL] g = dino . Graph ( ) [EOL] g . addVertex ( [string] , forwardMatrix ) [EOL] g . addVertex ( [string] , transposeMatrix ) [EOL] g . addVertex ( [string] , multiplyMatrix ) [EOL] g . addEdge ( [string] , [string] , [string] ) [EOL] g . addEdge ( [string] , [string] , [string] ) [EOL] g . addEdge ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] return g [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0