from typing import Dict , Pattern , Optional , List , Union , Any , TypeVar , Type [EOL] import jsonget [EOL] import builtins [EOL] import typing [EOL] import re [EOL] from typing import Any , Union , Type , List , Dict , Optional , TypeVar , cast , overload [EOL] [EOL] JsonType = Union [ Type [ str ] , Type [ int ] , Type [ float ] , Type [ bool ] , Type [ list ] , Type [ dict ] , None ] [EOL] JsonCheckType = Union [ JsonType , [string] ] [EOL] JsonValue = Union [ str , int , float , bool , list , dict , None ] [EOL] JsonPathElement = Union [ str , int ] [EOL] JsonPath = List [ JsonPathElement ] [EOL] [EOL] _JT = TypeVar ( [string] , str , int , float , bool ) [EOL] [EOL] [EOL] class JList : [EOL] def __init__ ( self , value_type ) : [EOL] self . value_type = value_type [EOL] [EOL] [EOL] def assert_json_type ( value , expected_type ) : [EOL] [docstring] [EOL] [EOL] def type_name ( t ) : [EOL] if t is None : [EOL] return [string] [EOL] if isinstance ( t , JList ) : [EOL] return [string] [EOL] return t . __name__ [EOL] [EOL] if expected_type is None : [EOL] if value is None : [EOL] return [EOL] elif expected_type == float : [EOL] if isinstance ( value , float ) or isinstance ( value , int ) : [EOL] return [EOL] elif expected_type in [ str , int , bool , list , dict ] : [EOL] if isinstance ( value , expected_type ) : [comment] [EOL] return [EOL] elif isinstance ( expected_type , JList ) : [EOL] if isinstance ( value , list ) : [EOL] for v in value : [EOL] assert_json_type ( v , expected_type . value_type ) [EOL] return [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] raise TypeError ( [string] . format ( type_name ( expected_type ) , type_name ( type ( value ) ) ) ) [EOL] [EOL] [EOL] def _parse_json_path ( path ) : [EOL] index_re = re . compile ( [string] ) [EOL] full_index_re = re . compile ( [string] ) [EOL] element_re = re . compile ( [string] ) [EOL] [EOL] def parse_element ( s ) : [EOL] m = element_re . match ( s ) [EOL] if not m : [EOL] raise ValueError ( [string] . format ( path ) ) [EOL] indexes = parse_indexes ( m . group ( [number] ) ) if m . group ( [number] ) else [ ] [EOL] return cast ( JsonPath , [ m . group ( [number] ) ] ) + indexes [EOL] [EOL] def parse_indexes ( s ) : [EOL] return [ int ( i ) for i in index_re . findall ( s ) ] [EOL] [EOL] if path in [ [string] , [string] ] : [EOL] return [ ] [EOL] [EOL] if path [ [number] ] not in [ [string] , [string] ] : [EOL] path = [string] + path [EOL] [EOL] elements = path . split ( [string] ) [EOL] if elements [ [number] ] and not full_index_re . match ( elements [ [number] ] ) : [EOL] raise ValueError ( [string] . format ( path ) ) [EOL] parsed = parse_indexes ( elements [ [number] ] ) [EOL] for element in elements [ [number] : ] : [EOL] parsed . extend ( parse_element ( element ) ) [EOL] return parsed [EOL] [EOL] [EOL] ANY = [string] [EOL] [EOL] [EOL] @ overload def json_get ( json , path , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get ( json , path , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get ( json , path , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get ( json , path , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get ( json , path , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get ( json , path , expected_type = ANY ) : [EOL] ... [EOL] [EOL] [EOL] def json_get ( json , path , expected_type = ANY ) : [EOL] [docstring] [EOL] [EOL] elements = _parse_json_path ( path ) [EOL] [EOL] current = json [EOL] current_path = [string] [EOL] for i , element in enumerate ( elements ) : [EOL] if isinstance ( element , str ) : [EOL] if not isinstance ( current , dict ) : [EOL] msg = [string] . format ( current_path ) [EOL] raise TypeError ( msg ) from None [EOL] if element not in current : [EOL] raise ValueError ( [string] . format ( path ) ) [EOL] current_path += [string] + element [EOL] current = current [ element ] [EOL] else : [EOL] if not isinstance ( current , list ) : [EOL] msg = [string] . format ( current_path ) [EOL] raise TypeError ( msg ) from None [EOL] if element >= len ( current ) : [EOL] msg = [string] . format ( current_path , len ( current ) , element ) [EOL] raise IndexError ( msg ) [EOL] current_path += [string] . format ( i ) [EOL] current = current [ element ] [EOL] if expected_type != ANY : [EOL] assert_json_type ( current , cast ( JsonType , expected_type ) ) [EOL] return current [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type ) : [EOL] ... [EOL] [EOL] [EOL] @ overload def json_get_default ( json , path , default , expected_type = ANY ) : [EOL] ... [EOL] [EOL] [EOL] def json_get_default ( json , path , default , expected_type = ANY ) : [EOL] [docstring] [EOL] try : [EOL] return json_get ( json , path , expected_type ) [EOL] except ( ValueError , IndexError ) : [EOL] return default [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[None,typing.Type[typing.Dict[typing.Any,typing.Any]],typing.Type[typing.List[typing.Any]],typing.Type[builtins.bool],typing.Type[builtins.float],typing.Type[builtins.int],typing.Type[builtins.str],jsonget.JList]$ 0 0 0 0 0 $typing.Union[None,typing.Type[typing.Dict[typing.Any,typing.Any]],typing.Type[typing.List[typing.Any]],typing.Type[builtins.bool],typing.Type[builtins.float],typing.Type[builtins.int],typing.Type[builtins.str],jsonget.JList]$ 0 $typing.Union[None,typing.Type[typing.Dict[typing.Any,typing.Any]],typing.Type[typing.List[typing.Any]],typing.Type[builtins.bool],typing.Type[builtins.float],typing.Type[builtins.int],typing.Type[builtins.str],jsonget.JList]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JsonPath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JsonPath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JsonPath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0