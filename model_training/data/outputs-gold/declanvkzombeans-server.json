from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging , functools , time [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] class PeriodicTimer : [EOL] def __init__ ( self , interval , sleepfunc , function , args = None , kwargs = None ) : [EOL] self . interval = interval [EOL] self . function = function [EOL] self . args = args if args is not None else [ ] [EOL] self . kwargs = kwargs if kwargs is not None else { } [EOL] self . sleepfunc = sleepfunc [EOL] [EOL] def run ( self ) : [EOL] next_call = time . time ( ) + self . interval [EOL] should_cancel = False [EOL] [EOL] self . sleepfunc ( self . interval ) [EOL] [EOL] while not should_cancel : [EOL] should_cancel = self . function ( * self . args , ** self . kwargs ) [EOL] [EOL] next_call = next_call + self . interval [EOL] to_wait = max ( next_call - time . time ( ) , [number] ) [EOL] self . sleepfunc ( to_wait ) [EOL] [EOL] def start_timer ( timer ) : [EOL] timer . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] from flask import request [EOL] from flask_socketio import Namespace , emit [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class HostNamespace ( Namespace ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( HostNamespace , self ) . __init__ ( * args , ** { key : kwargs [ key ] for key in kwargs if key != [string] } ) [EOL] [EOL] if [string] not in kwargs : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . parent = kwargs [ [string] ] [EOL] [EOL] def on_connect ( self ) : [EOL] self . parent . register_host_connect ( request . sid ) [EOL] [EOL] def on_disconnect ( self ) : [EOL] self . parent . register_host_disconnect ( request . sid ) [EOL] [EOL] def send_room_code ( self , host_id , room_code ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : room_code } , room = host_id ) [EOL] [EOL] def send_player_joined ( self , host_id , players , new_player_name ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : list ( players ) , [string] : new_player_name } , room = host_id ) [EOL] [EOL] def on_request_start_game ( self , data ) : [EOL] host_id = request . sid [EOL] self . parent . register_request_start_game ( host_id ) [EOL] [EOL] class ViewerNamespace ( Namespace ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ViewerNamespace , self ) . __init__ ( * args , ** { key : kwargs [ key ] for key in kwargs if key != [string] } ) [EOL] [EOL] if [string] not in kwargs : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . parent = kwargs [ [string] ] [EOL] [EOL] def on_connect ( self ) : [EOL] self . parent . register_viewer_connect ( request . sid ) [EOL] [EOL] def on_disconnect ( self ) : [EOL] self . parent . register_viewer_disconnect ( request . sid ) [EOL] [EOL] def broadcast_game_starting ( self , room_id ) : [EOL] self . emit ( [string] , { [string] : [string] , } , room = room_id ) [EOL] [EOL] def broadcast_game_over ( self , room_id , winner ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : winner } , room = room_id ) [EOL] [EOL] def broadcast_game_tick ( self , room_id , player_pos_data ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : player_pos_data } , room = room_id ) [EOL] [EOL] def send_game_view_response ( self , viewer_id , view_status , aux_data ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : view_status , [string] : aux_data } , room = viewer_id ) [EOL] [EOL] def on_request_game_view ( self , payload ) : [EOL] viewer_id = request . sid [EOL] room_code = payload [ [string] ] [EOL] [EOL] self . parent . register_request_game_view ( viewer_id , room_code ) [EOL] [EOL] class PlayerNamespace ( Namespace ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( PlayerNamespace , self ) . __init__ ( * args , ** { key : kwargs [ key ] for key in kwargs if key != [string] } ) [EOL] [EOL] if [string] not in kwargs : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . parent = kwargs [ [string] ] [EOL] [EOL] def on_connect ( self ) : [EOL] self . parent . register_player_connect ( request . sid ) [EOL] [EOL] def on_disconnect ( self ) : [EOL] self . parent . register_player_disconnect ( request . sid ) [EOL] [EOL] def send_player_join_response ( self , player_id , status , aux_data ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : status , [string] : aux_data } , room = player_id ) [EOL] [EOL] def broadcast_game_starting ( self , room_id ) : [EOL] self . emit ( [string] , { [string] : [string] } , room = room_id ) [EOL] [EOL] def broadcast_game_over ( self , room_id , winner ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : winner } , room = room_id ) [EOL] [EOL] def broadcast_game_tick ( self , room_id , god_spells ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : god_spells } , room = room_id ) [EOL] [EOL] def send_status_change ( self , player_id , type , data ) : [EOL] self . emit ( [string] , { [string] : [string] , [string] : type , type : data } , room = player_id ) [EOL] [EOL] def on_player_join_request ( self , payload ) : [EOL] room_code = payload [ [string] ] [EOL] user_name = payload [ [string] ] [EOL] player_id = request . sid [EOL] [EOL] self . parent . register_player_join_request ( player_id , room_code , user_name ) [EOL] [EOL] def on_make_move ( self , payload ) : [EOL] player_id = request . sid [EOL] origin = payload [ [string] ] [EOL] action = payload [ [string] ] [EOL] [EOL] self . parent . register_make_move ( player_id , origin , action ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
from typing import List , Any , Set , Dict , Tuple [EOL] import typing [EOL] import pymunk [EOL] from enum import Enum [EOL] class Game : [EOL] [EOL] types = { [string] : [number] , [string] : [number] } [EOL] MAX_VELOCITY = [number] [EOL] ACCELERATION = [number] [EOL] INTERNAL_TICK_TIME = [number] [EOL] EXTERNAL_TICK_TIME = [number] [EOL] MAX_TICKS = [number] [EOL] [EOL] def __init__ ( self , max_players = [number] , min_players = [number] , width = [number] , height = [number] ) : [EOL] [EOL] self . starting_positions = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] self . max_players = max_players [EOL] self . min_players = min_players [EOL] self . players = dict ( ) [EOL] self . width = width [EOL] self . height = height [EOL] self . space = pymunk . Space ( ) [EOL] self . add_static_scenery ( ) [EOL] self . zombie_collision_handler = self . space . add_collision_handler ( Game . types [ [string] ] , Game . types [ [string] ] ) [EOL] self . started = False [EOL] self . ended = False [EOL] self . winner = None [EOL] self . space . damping = [number] [EOL] self . god = None [EOL] self . time_left = Game . MAX_TICKS [EOL] self . effects = set ( ) [EOL] self . player_count = [number] [EOL] [EOL] def turn_zombie ( arbiter , space , data ) : [EOL] if self . god is not None and GodAction . IMMUNE in self . god . current_actions : [EOL] return True [EOL] [EOL] player = self . players [ arbiter . shapes [ [number] ] . id ] [EOL] player . shape . collision_type = Game . types [ [string] ] [EOL] ended = True [EOL] for player in self . players . values ( ) : [EOL] if player . shape . collision_type == Game . types [ [string] ] : [EOL] ended = False [EOL] self . ended = ended [EOL] if ended : [EOL] self . winner = Game . types [ [string] ] [EOL] return True [EOL] [EOL] self . zombie_collision_handler . begin = turn_zombie [EOL] self . space . damping = [number] [EOL] [EOL] def add_player ( self , id ) : [EOL] if self . player_count == [number] : [EOL] self . players [ id ] = Player ( id , self . space , self . starting_positions . pop ( ) , self , isZombie = True ) [EOL] elif self . player_count == [number] and self . god is None : [EOL] self . add_god ( id ) [EOL] else : [EOL] self . players [ id ] = Player ( id , self . space , self . starting_positions . pop ( ) , self ) [EOL] self . player_count += [number] [EOL] [EOL] def add_god ( self , id ) : [EOL] self . god = God ( id ) [EOL] [EOL] def add_static_scenery ( self ) : [EOL] static_body = self . space . static_body [EOL] static_lines = [ pymunk . Segment ( static_body , ( [number] , [number] ) , ( self . width , [number] ) , [number] ) , pymunk . Segment ( static_body , ( self . width , [number] ) , ( self . width , self . height ) , [number] ) , pymunk . Segment ( static_body , ( self . width , self . height ) , ( [number] , self . height ) , [number] ) , pymunk . Segment ( static_body , ( [number] , self . height ) , ( [number] , [number] ) , [number] ) ] [EOL] for line in static_lines : [EOL] line . elasticity = [number] [EOL] line . friction = [number] [EOL] self . space . add ( static_lines ) [EOL] [EOL] def input ( self , id , key , action ) : [EOL] if action == [string] : [EOL] self . players [ id ] . current_accel_dirs . add ( key [ [number] ] ) [EOL] else : [EOL] self . players [ id ] . current_accel_dirs . remove ( key [ [number] ] ) [EOL] [EOL] def god_input ( self , id , code ) : [EOL] if self . god is not None and id == self . god . id : [EOL] if code in self . god . possible_actions : [EOL] self . god . current_actions [ code ] = self . god . possible_actions [ code ] [EOL] self . god . cooldown_actions [ code ] = self . god . possible_actions [ code ] [EOL] del self . god . possible_actions [ code ] [EOL] [EOL] def cure_player ( self ) : [EOL] zombie_count = [number] [EOL] zombie_obj = None [EOL] for obj in self . players . values ( ) : [EOL] if obj . shape . collision_type == Game . types [ [string] ] : [EOL] print ( obj . id ) [EOL] zombie_count += [number] [EOL] zombie_obj = obj [EOL] if zombie_count > [number] : [EOL] zombie_obj . shape . collision_type = Game . types [ [string] ] [EOL] else : [EOL] self . god . possible_actions [ GodAction . CURE ] = self . god . cooldown_actions [ GodAction . CURE ] [EOL] del self . god . cooldown_actions [ GodAction . CURE ] [EOL] [comment] [EOL] [EOL] def tick ( self ) : [EOL] self . space . step ( Game . INTERNAL_TICK_TIME ) [EOL] if self . god is not None and GodAction . CURE in self . god . current_actions : [EOL] self . cure_player ( ) [EOL] self . time_left -= Game . INTERNAL_TICK_TIME [EOL] if self . god is not None : [EOL] self . god . tick ( ) [EOL] if self . time_left <= [number] : [EOL] self . ended = True [EOL] self . winner = Game . types [ [string] ] [EOL] data = dict ( ) [EOL] for player in self . players . items ( ) : [EOL] data [ player [ [number] ] ] = dict ( ) [EOL] data [ player [ [number] ] ] [ [string] ] = dict ( ) [EOL] data [ player [ [number] ] ] [ [string] ] [ [string] ] = player [ [number] ] . body . position [ [number] ] [EOL] data [ player [ [number] ] ] [ [string] ] [ [string] ] = player [ [number] ] . body . position [ [number] ] [EOL] self . space . reindex_shapes_for_body ( player [ [number] ] . body ) [EOL] data [ player [ [number] ] ] [ [string] ] = player [ [number] ] . shape . collision_type == Game . types [ [string] ] [EOL] if self . god is not None : [EOL] data [ [string] ] = { [string] : list ( self . god . possible_actions . keys ( ) ) , [string] : { x . id : x . cooldown for x in self . god . cooldown_actions . values ( ) } } [EOL] return data , self . ended , self . winner [EOL] [EOL] [EOL] def start ( self ) : [EOL] self . started = True [EOL] return { [string] : self . width , [string] : self . height } [EOL] [EOL] [EOL] class Player : [EOL] RADIUS = [number] [EOL] [EOL] def __init__ ( self , id , space , pos , game , isZombie = False ) : [EOL] self . id = id [EOL] self . body = pymunk . Body ( [number] ) [EOL] self . space = space [EOL] self . body . position = pos [EOL] self . shape = pymunk . Circle ( self . body , Player . RADIUS ) [EOL] self . shape . density = [number] [EOL] self . space . add ( self . body , self . shape ) [EOL] self . shape . collision_type = Game . types [ [string] ] [EOL] if isZombie : [EOL] self . shape . collision_type = Game . types [ [string] ] [EOL] else : [EOL] self . shape . collision_type = Game . types [ [string] ] [EOL] self . current_accel_dirs = set ( ) [EOL] self . shape . id = id [EOL] self . game = game [EOL] [EOL] def velocity_cb ( body , gravity , damping , dt ) : [EOL] velocity_vector = [ body . velocity [ [number] ] , body . velocity [ [number] ] ] [EOL] accel_modifier = [number] [EOL] max_vel_mod = [number] [EOL] if self . shape . collision_type == Game . types [ [string] ] and self . game . god is not None and GodAction . FREEZE in self . game . god . current_actions : [EOL] body . velocity = [ [number] , [number] ] [EOL] if self . shape . collision_type == Game . types [ [string] ] and self . game . god is not None and GodAction . SPEED_UP in self . game . god . current_actions : [EOL] accel_modifier = [number] [EOL] max_vel_mod = [number] [EOL] [EOL] if body . velocity [ [number] ] < Game . MAX_VELOCITY * max_vel_mod and [string] in self . current_accel_dirs : [EOL] velocity_vector [ [number] ] = min ( Game . MAX_VELOCITY * max_vel_mod , body . velocity [ [number] ] + Game . ACCELERATION * accel_modifier ) [EOL] if body . velocity [ [number] ] > - Game . MAX_VELOCITY * max_vel_mod and [string] in self . current_accel_dirs : [EOL] velocity_vector [ [number] ] = max ( - Game . MAX_VELOCITY * max_vel_mod , body . velocity [ [number] ] - Game . ACCELERATION * accel_modifier ) [EOL] if body . velocity [ [number] ] < Game . MAX_VELOCITY * max_vel_mod and [string] in self . current_accel_dirs : [EOL] velocity_vector [ [number] ] = min ( Game . MAX_VELOCITY * max_vel_mod , body . velocity [ [number] ] + Game . ACCELERATION * accel_modifier ) [EOL] if body . velocity [ [number] ] > - Game . MAX_VELOCITY * max_vel_mod and [string] in self . current_accel_dirs : [EOL] velocity_vector [ [number] ] = max ( - Game . MAX_VELOCITY * max_vel_mod , body . velocity [ [number] ] - Game . ACCELERATION * accel_modifier ) [EOL] body . velocity = velocity_vector [EOL] [EOL] self . body . velocity_func = velocity_cb [EOL] [EOL] class God : [EOL] def __init__ ( self , id ) : [EOL] self . id = id [EOL] self . current_actions = dict ( ) [EOL] self . possible_actions = { GodAction . FREEZE : GodAction ( GodAction . FREEZE , [number] , [number] ) , GodAction . SPEED_UP : GodAction ( GodAction . SPEED_UP , [number] , [number] ) , GodAction . IMMUNE : GodAction ( GodAction . IMMUNE , [number] , [number] ) } [EOL] self . cooldown_actions = { GodAction . CURE : GodAction ( GodAction . CURE , [number] , [number] ) } [EOL] [EOL] def tick ( self ) : [EOL] to_splice = set ( ) [EOL] for ( act , obj ) in self . cooldown_actions . items ( ) : [EOL] obj . cooldown -= Game . INTERNAL_TICK_TIME [EOL] if obj . cooldown <= [number] : [EOL] to_splice . add ( act ) [EOL] self . possible_actions [ act ] = obj [EOL] obj . cooldown = obj . full_cooldown [EOL] for i in to_splice : [EOL] self . cooldown_actions . pop ( i ) [EOL] [EOL] to_splice = set ( ) [EOL] for ( act , obj ) in self . current_actions . items ( ) : [EOL] obj . duration -= Game . INTERNAL_TICK_TIME [EOL] if obj . duration <= [number] : [EOL] to_splice . add ( act ) [EOL] self . cooldown_actions [ act ] = obj [EOL] obj . duration = obj . full_duration [EOL] for i in to_splice : [EOL] self . current_actions . pop ( i ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] class GodAction : [EOL] FREEZE = [number] [EOL] SPEED_UP = [number] [EOL] IMMUNE = [number] [EOL] CURE = [number] [EOL] def __init__ ( self , id , duration , cooldown ) : [EOL] self . id = id [EOL] self . full_duration = duration [EOL] self . full_cooldown = cooldown [EOL] self . duration = duration [EOL] self . cooldown = cooldown [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0