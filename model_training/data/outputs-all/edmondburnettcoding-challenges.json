[comment] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with open ( [string] ) as words : [EOL] for word in words : [EOL] word = word . strip ( ) [EOL] print ( word )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] phrase = [string] [EOL] exceptions = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def titlecase ( phrase , exceptions ) : [EOL] [docstring] [EOL] phrase_list = phrase . split ( ) [EOL] for i in range ( len ( phrase_list ) ) : [EOL] if phrase_list [ i ] not in exceptions or i == [number] : [EOL] print ( phrase_list [ i ] . capitalize ( ) ) , [EOL] else : [EOL] print ( phrase_list [ i ] . lower ( ) ) , [EOL] [EOL] [EOL] titlecase ( phrase , exceptions ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] import sys [EOL] [EOL] def grid ( size ) : [EOL] [docstring] [EOL] container = [ ] [EOL] for x in range ( size ) : [EOL] l = list ( range ( size ) ) [EOL] container . append ( l ) [EOL] for n in container : [EOL] for item in n : [EOL] print ( item , end = [string] ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] grid ( int ( sys . argv [ [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class Solution : [EOL] def findComplement ( self , num ) : [EOL] binary = str ( bin ( num ) ) [ [number] : ] [EOL] flipped = [string] [EOL] for i in range ( len ( binary ) ) : [EOL] if binary [ i ] == [string] : [EOL] flipped = flipped + [string] [EOL] elif binary [ i ] == [string] : [EOL] flipped = flipped + [string] [EOL] return int ( flipped , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . findComplement ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def sortArrayByParityII ( self , A ) : [EOL] newlist = [ None ] * len ( A ) [EOL] [EOL] index = [number] [EOL] for num in A : [EOL] if num % [number] == [number] : [EOL] newlist [ index ] = num [EOL] index += [number] [EOL] [EOL] index = [number] [EOL] for num in A : [EOL] if num % [number] == [number] : [EOL] newlist [ index ] = num [EOL] index += [number] [EOL] [EOL] return newlist [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . sortArrayByParityII ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] print ( sol . sortArrayByParityII ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class Solution : [EOL] def numJewelsInStones ( self , J , S ) : [EOL] count = [number] [EOL] for jewel in J : [EOL] count += S . count ( jewel ) [EOL] return count [EOL] [EOL] def numJewelsInStones2 ( self , J , S ) : [EOL] count = [number] [EOL] for jewel in J : [EOL] for stone in S : [EOL] if jewel == stone : [EOL] count += [number] [EOL] return count [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] jewels = sol . numJewelsInStones ( [string] , [string] ) [EOL] [comment] [EOL] print ( jewels ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $'int'$ 0 0 0 $'str'$ 0 $'str'$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $'str'$ 0 0 $builtins.int$ 0 $'str'$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $'int'$ 0 0 0 $'str'$ 0 $'str'$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $'str'$ 0 0 0 0 0 $'str'$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import List [EOL] import typing [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def numUniqueEmails ( self , emails ) : [EOL] fixed_emails = [ ] [EOL] for email in emails : [EOL] at = email . find ( [string] ) [EOL] username = email [ [number] : at ] [EOL] domain = email [ at : ] [EOL] plus = email . find ( [string] ) [EOL] if plus != - [number] : [EOL] username = username [ [number] : plus ] [EOL] fixed_email = username . replace ( [string] , [string] ) + domain [EOL] if fixed_email not in fixed_emails : [EOL] fixed_emails . append ( fixed_email ) [EOL] return len ( fixed_emails ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] email_list = [ [string] , [string] , [string] , [string] , [string] ] [EOL] sol = Solution ( ) [EOL] n = sol . numUniqueEmails ( email_list ) [EOL] print ( [string] , n ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'int'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def sortArrayByParity ( self , A ) : [EOL] parity = [ ] [EOL] for n in A : [EOL] if n % [number] == [number] : [EOL] parity . append ( n ) [EOL] for x in A : [EOL] if x % [number] != [number] : [EOL] parity . append ( x ) [EOL] return parity [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . sortArrayByParity ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'List[int]'$ 0 0 0 $'List[int]'$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $'List[int]'$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $'List[int]'$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class Solution : [EOL] def repeatedStringMatch ( self , A , B ) : [EOL] repeat_count = [number] [EOL] repeated = [string] [EOL] while len ( repeated ) <= [number] : [EOL] if B in repeated : [EOL] return repeat_count [EOL] else : [EOL] repeated = repeated + A [EOL] repeat_count += [number] [EOL] return - [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . repeatedStringMatch ( [string] , [string] ) ) [comment] [EOL] print ( [string] ) [EOL] print ( sol . repeatedStringMatch ( [string] , [string] ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Counter [EOL] import collections [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] from functools import reduce [EOL] from collections import Counter [EOL] [EOL] [EOL] class Solution : [EOL] def commonChars ( self , A ) : [EOL] result = reduce ( lambda x , y : x & y , map ( lambda x : Counter ( x ) , A ) ) [EOL] return list ( result . elements ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] l1 = [ [string] , [string] , [string] ] [EOL] l2 = [ [string] , [string] , [string] ] [EOL] s = Solution ( ) [EOL] print ( s . commonChars ( l1 ) ) [EOL] print ( s . commonChars ( l2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def repeatedNTimes ( self , A ) : [EOL] numlist = [ ] [EOL] for num in A : [EOL] if num in numlist : [EOL] return num [EOL] else : [EOL] numlist . append ( num ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . repeatedNTimes ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List , Set , Dict [EOL] import typing [EOL] import string [EOL] from typing import List [EOL] [EOL] morse_codes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] alphabet = string . ascii_lowercase [comment] [EOL] [EOL] [EOL] class Solution : [EOL] def __init__ ( self ) : [EOL] self . morse_dict = self . create_dict ( alphabet , morse_codes ) [EOL] [EOL] def create_dict ( self , alphabet , morse_codes ) : [EOL] dictionary = { } [EOL] for i in range ( len ( alphabet ) ) : [EOL] dictionary [ alphabet [ i ] ] = morse_codes [ i ] [EOL] return dictionary [EOL] [EOL] def uniqueMorseRepresentations ( self , words ) : [EOL] morse_set = set ( ) [EOL] for word in words : [EOL] morse_word = [string] [EOL] for letter in word : [EOL] morse_word = morse_word + self . morse_dict [ letter ] [EOL] morse_set . add ( morse_word ) [EOL] return len ( morse_set ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] result = sol . uniqueMorseRepresentations ( [ [string] , [string] , [string] , [string] ] ) [EOL] print ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $'dict'$ 0 0 0 $'str'$ 0 $'List[str]'$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $'str'$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $'str'$ 0 0 0 0 0 $'List[str]'$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $'int'$ 0 0 0 $'List[str]'$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $'List[str]'$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class Solution : [EOL] def judgeCircle ( self , moves ) : [EOL] x = [number] [EOL] y = [number] [EOL] for dir in moves : [EOL] if dir == [string] : [EOL] y += [number] [EOL] if dir == [string] : [EOL] y -= [number] [EOL] if dir == [string] : [EOL] x -= [number] [EOL] if dir == [string] : [EOL] x += [number] [EOL] if x == [number] and y == [number] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . judgeCircle ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $'bool'$ 0 0 0 $'str'$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $'str'$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def maxIncreaseKeepingSkyline ( self , grid ) : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] grid = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] sol = Solution ( ) [EOL] sol . maxIncreaseKeepingSkyline ( grid ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'int'$ 0 0 0 $'List[List[int]]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def flipAndInvertImage ( self , A ) : [EOL] for row in A : [EOL] [comment] [EOL] row . reverse ( ) [EOL] for i in range ( len ( row ) ) : [EOL] [comment] [EOL] if row [ i ] == [number] : [EOL] row [ i ] = [number] [EOL] else : [EOL] row [ i ] = [number] [EOL] return A [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . flipAndInvertImage ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) ) [EOL] print ( sol . flipAndInvertImage ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def sortedSquares ( self , A ) : [EOL] squares = [ ] [EOL] for i in A : [EOL] squares . append ( i ** [number] ) [EOL] squares . sort ( ) [EOL] return squares [EOL] [EOL] def sortedSquares2 ( self , A ) : [EOL] return sorted ( i * i for i in A ) [EOL] [EOL] def sortedSquares3 ( self , A ) : [EOL] squares = [ [number] ] * len ( A ) [EOL] l = [number] [EOL] r = len ( A ) - [number] [EOL] while l <= r : [EOL] left = abs ( A [ l ] ) [EOL] right = abs ( A [ r ] ) [EOL] print ( f" [string] { left } [string] { right } [string] { l } [string] { r }" ) [EOL] if left > right : [EOL] squares [ r - l ] = left * left [EOL] l += [number] [EOL] else : [EOL] squares [ r - l ] = right * right [EOL] r -= [number] [EOL] return squares [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . sortedSquares ( [ - [number] , - [number] , [number] , [number] , [number] ] ) ) [EOL] print ( sol . sortedSquares ( [ - [number] , - [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] print ( sol . sortedSquares2 ( [ - [number] , - [number] , [number] , [number] , [number] ] ) ) [EOL] print ( sol . sortedSquares2 ( [ - [number] , - [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] print ( sol . sortedSquares3 ( [ - [number] , - [number] , [number] , [number] , [number] ] ) ) [EOL] print ( sol . sortedSquares3 ( [ - [number] , - [number] , [number] , [number] , [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'List[int]'$ 0 0 0 $'List[int]'$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $'List[int]'$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $'List[int]'$ 0 0 0 $'List[int]'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'List[int]'$ 0 0 0 0 $'List[int]'$ 0 0 0 $'List[int]'$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $'List[int]'$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $'List[int]'$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $'List[int]'$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $'List[int]'$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class Solution : [EOL] def defangIPaddr ( self , address ) : [EOL] defanged = list ( address ) [EOL] count = [number] [EOL] for index , char in enumerate ( address ) : [EOL] if char == [string] : [EOL] defanged . insert ( index + count , [string] ) [EOL] defanged . insert ( index + count + [number] , [string] ) [EOL] count = count + [number] [EOL] return [string] . join ( defanged ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] s = Solution ( ) [EOL] print ( s . defangIPaddr ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class TreeNode : [EOL] [docstring] [EOL] def __init__ ( self , x ) : [EOL] self . val = x [EOL] self . left = None [EOL] self . right = None [EOL] [EOL] [EOL] class Solution : [EOL] def isUnivalTree ( self , root ) : [EOL] return self . search ( root , root . val ) [EOL] [EOL] def search ( self , node , value ) : [EOL] if not node : [EOL] [comment] [EOL] return True [EOL] [EOL] if node . val != value : [EOL] [comment] [EOL] return False [EOL] [EOL] if self . search ( node . left , value ) and self . search ( node . right , value ) : [EOL] [comment] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] [EOL] tree1 = TreeNode ( [number] ) [EOL] tree1 . left = TreeNode ( [number] ) [EOL] tree1 . right = TreeNode ( [number] ) [EOL] tree1 . left . left = TreeNode ( [number] ) [EOL] tree1 . left . right = TreeNode ( [number] ) [EOL] tree1 . right . right = TreeNode ( [number] ) [EOL] print ( sol . isUnivalTree ( tree1 ) ) [EOL] [EOL] tree2 = TreeNode ( [number] ) [EOL] tree2 . left = TreeNode ( [number] ) [EOL] tree2 . right = TreeNode ( [number] ) [EOL] tree2 . left . left = TreeNode ( [number] ) [EOL] tree2 . left . right = TreeNode ( [number] ) [EOL] print ( sol . isUnivalTree ( tree2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $TreeNode$ 0 0 0 0 0 0 0 0 $TreeNode$ 0 $TreeNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Optional [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List , Optional [EOL] from time import perf_counter [EOL] import itertools as it [EOL] [EOL] [EOL] class Solution : [EOL] def TwoSum ( self , nums , target ) : [EOL] [docstring] [EOL] for i in range ( len ( nums ) ) : [EOL] for x in range ( len ( nums ) ) : [EOL] if i == x : [EOL] continue [EOL] if nums [ i ] + nums [ x ] == target : [EOL] return [ i , x ] [EOL] return None [EOL] [EOL] def TwoSum2 ( self , nums , target ) : [EOL] [docstring] [EOL] length = len ( nums ) [EOL] for i , x , in it . combinations ( range ( length ) , r = [number] ) : [EOL] if nums [ i ] + nums [ x ] == target : [EOL] return [ i , x ] [EOL] return None [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] list1 = [ [number] , [number] , [number] , [number] ] [comment] [EOL] list2 = [ [number] , [number] , [number] , [number] , [number] ] [comment] [EOL] list3 = [ [number] , [number] , [number] ] [comment] [EOL] list4 = [ [number] , [number] , [number] , [number] , [number] ] [comment] [EOL] [EOL] sol = Solution ( ) [EOL] start = perf_counter ( ) [EOL] [comment] [EOL] print ( sol . TwoSum2 ( list3 , [number] ) ) [EOL] end = perf_counter ( ) [EOL] print ( end - start ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Solution : [EOL] def __init__ ( self ) : [EOL] self . row1 = [string] [EOL] self . row2 = [string] [EOL] self . row3 = [string] [EOL] [EOL] def findWords ( self , words ) : [EOL] one_row_words = [ ] [EOL] for word in words : [EOL] r1 = [number] [EOL] r2 = [number] [EOL] r3 = [number] [EOL] for letter in word : [EOL] if letter in self . row1 : [EOL] r1 += [number] [EOL] elif letter in self . row2 : [EOL] r2 += [number] [EOL] elif letter in self . row3 : [EOL] r3 += [number] [EOL] print ( word , r1 , r2 , r3 ) [EOL] if len ( word ) == r1 or len ( word ) == r2 or len ( word ) == r3 : [EOL] one_row_words . append ( word ) [EOL] return one_row_words [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . findWords ( [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] print ( sol . findWords ( [ [string] , [string] , [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] import builtins [EOL] class Solution : [EOL] def isPalindrome ( self , x ) : [EOL] s = str ( x ) [EOL] r = [string] . join ( reversed ( str ( x ) ) ) [EOL] if s == r : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sol = Solution ( ) [EOL] print ( sol . isPalindrome ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0