from typing import Any [EOL] import typing [EOL] import asyncio [EOL] from escrow . post_close_escrow_wallet import build_generate_close_escrow_wallet_transaction [EOL] from escrow . get_escrow_wallet import get_escrow_wallet_detail [EOL] [EOL] async def debug ( ) : [EOL] address = [string] [EOL] escrow_wallet = await get_escrow_wallet_detail ( address ) [EOL] res = await build_generate_close_escrow_wallet_transaction ( escrow_wallet ) [EOL] print ( res ) [EOL] [EOL] import asyncio [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( debug ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] from aiohttp import web [EOL] from controller import handle [EOL] [EOL] ROUTER = { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } , } [EOL] [EOL] [EOL] def generate_routes ( ) : [EOL] routes = [ ] [EOL] for key , value in ROUTER . items ( ) : [EOL] [EOL] if [string] in value : [EOL] handler = value [ [string] ] [EOL] routes . append ( web . get ( value [ [string] ] , object_at_end_of_path ( handler ) , name = f' [string] { key }' ) ) [EOL] [EOL] if [string] in value : [EOL] handler = value [ [string] ] [EOL] routes . append ( web . put ( value [ [string] ] , object_at_end_of_path ( handler ) , name = f' [string] { key }' ) ) [EOL] [EOL] if [string] in value : [EOL] handler = value [ [string] ] [EOL] routes . append ( web . post ( value [ [string] ] , object_at_end_of_path ( handler ) , name = f' [string] { key }' ) ) [EOL] return routes [EOL] [EOL] [EOL] def reverse ( name , ** kwargs ) : [EOL] return ROUTER [ name ] [ [string] ] . format ( ** kwargs ) [EOL] [EOL] [EOL] def object_at_end_of_path ( path ) : [EOL] [docstring] [EOL] access_path = path . split ( [string] ) [EOL] module = None [EOL] for index in range ( [number] , len ( access_path ) ) : [EOL] try : [EOL] [comment] [EOL] module_name = [string] . join ( access_path [ : - index ] ) [EOL] module = __import__ ( module_name ) [EOL] except ImportError : [EOL] continue [EOL] else : [EOL] for step in access_path [ [number] : - [number] ] : [comment] [EOL] module = getattr ( module , step ) [EOL] break [EOL] if module : [EOL] return getattr ( module , access_path [ - [number] ] ) [EOL] else : [EOL] return globals ( ) [ [string] ] [ path ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from server import init_app [EOL] import pytest [EOL] [EOL] @ pytest . fixture def cli ( loop , aiohttp_client ) : [EOL] app = loop . run_until_complete ( init_app ( ) ) [EOL] return loop . run_until_complete ( aiohttp_client ( app ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from aiohttp import web [EOL] [EOL] [EOL] async def handle ( request ) : [EOL] app = request . app [EOL] response = { } [EOL] [EOL] for name , resource in app . router . items ( ) : [EOL] if [string] in resource . get_info ( ) : [EOL] path = resource . get_info ( ) [ [string] ] [EOL] n = name . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] if n not in response : [EOL] response [ n ] = f'{ path }' [EOL] return web . json_response ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Any [EOL] [EOL] import os [EOL] [EOL] settings = dict ( ) [EOL] [EOL] settings [ [string] ] = os . getenv ( [string] , [string] ) [EOL] settings [ [string] ] = os . environ [ [string] ] [EOL] settings [ [string] ] = [string] [EOL] settings [ [string] ] = os . environ [ [string] ] [EOL] settings [ [string] ] = os . environ [ [string] ] [EOL] settings [ [string] ] = os . environ [ [string] ] [EOL] settings [ [string] ] = os . environ [ [string] ] [EOL] [EOL] settings [ [string] ] = { [string] : [string] } [EOL] [EOL] settings [ [string] ] = os . getenv ( [string] , False )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from conf import settings [EOL] from raven import Client [EOL] [EOL] client = None [EOL] if settings [ [string] ] : [EOL] client = Client ( settings [ [string] ] ) [EOL] [EOL] def capture_exception ( ) : [EOL] if client : [EOL] client . captureException ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] import logging [EOL] from logging import config [EOL] [EOL] from aiohttp import ClientSession , web [EOL] from aiohttp . test_utils import AioHTTPTestCase , unittest_run_loop [EOL] [EOL] from controller import handle [EOL] from middlewares import exception [EOL] from request_tracking import metrics [EOL] from log import log , log_conf [EOL] from router import generate_routes [EOL] [EOL] [EOL] async def init_app ( ) : [EOL] [docstring] [EOL] app = web . Application ( middlewares = [ log . handle_log , exception . handle_error , metrics . metrics_increasing ] ) [EOL] app . add_routes ( generate_routes ( ) ) [EOL] return app [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] loop = asyncio . get_event_loop ( ) [EOL] app = loop . run_until_complete ( init_app ( ) ) [EOL] config . dictConfig ( log_conf . log_setting ) [EOL] web . run_app ( app , port = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $typing.Any$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
from typing import Type , Any , List , Dict , Union [EOL] import typing [EOL] import builtins [EOL] import aiohttp [EOL] from base64 import b64decode [EOL] from functools import reduce [EOL] from typing import Any , Dict , List , Mapping , NewType , Optional , Union [EOL] [EOL] from aiohttp import web [EOL] [EOL] [EOL] from conf import settings [EOL] from wallet . wallet import build_generate_trust_wallet_transaction , get_wallet , wallet_address_is_duplicate [EOL] from router import reverse [EOL] [EOL] [EOL] JSONType = Union [ str , int , float , bool , None , Dict [ str , Any ] , List [ Any ] ] [EOL] STELLAR_BALANCE = Dict [ str , str ] [EOL] STELLAR_BALANCES = List [ STELLAR_BALANCE ] [EOL] BALANCE_RESPONSE = Union [ Dict [ str , str ] , Dict ] [EOL] SIGNERS = List [ Dict [ str , str ] ] [EOL] THRESHOLDS = Dict [ str , int ] [EOL] [EOL] [EOL] async def get_wallet_from_request ( request ) : [EOL] [docstring] [EOL] wallet_address = request . match_info . get ( [string] , [string] ) [EOL] result = await get_wallet_detail ( wallet_address ) [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def get_wallet_detail ( wallet_address ) : [EOL] [docstring] [EOL] [EOL] def _format_balance ( balance ) : [EOL] [docstring] [EOL] if balance [ [string] ] == [string] : [EOL] return { [string] : balance [ [string] ] } [EOL] elif balance [ [string] ] == settings [ [string] ] and balance [ [string] ] == settings [ [string] ] : [EOL] return { [string] : balance [ [string] ] , settings [ [string] ] : balance [ [string] ] } [EOL] return { } [EOL] [EOL] def _merge_balance ( balances ) : [EOL] [docstring] [EOL] asset = { } [EOL] for balance in balances : [EOL] asset . update ( _format_balance ( balance ) ) [EOL] return asset [EOL] [EOL] def _trusted_hot ( balances ) : [EOL] [docstring] [EOL] if ( len ( list ( filter ( lambda b : b . get ( [string] , None ) == settings [ [string] ] [EOL] and b . get ( [string] , None ) == settings [ [string] ] , balances , ) ) ) == [number] ) : [EOL] return { [string] : f"{ settings [ [string] ] }{ reverse ( [string] , wallet_address = wallet_address ) }" } [EOL] return { } [EOL] [EOL] def _format_data ( data ) : [EOL] [docstring] [EOL] return { k : b64decode ( v ) . decode ( [string] ) for k , v in data . items ( ) } [EOL] [EOL] wallet = await get_wallet ( wallet_address ) [EOL] result = { [string] : reverse ( [string] , wallet_address = wallet_address ) , [string] : wallet . address , [string] : _merge_balance ( wallet . balances ) , [string] : wallet . sequence , [string] : _format_data ( wallet . data ) , } [EOL] [EOL] result . update ( _trusted_hot ( wallet . balances ) ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $BALANCE_RESPONSE$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import aiohttp [EOL] import builtins [EOL] import typing [EOL] from aiohttp import web [EOL] [EOL] from conf import settings [EOL] from transaction . transaction import get_current_sequence_number [EOL] [EOL] [EOL] async def get_current_tx_sequence_from_request ( request ) : [EOL] [docstring] [EOL] wallet_address = request . match_info . get ( [string] ) [EOL] sequence = await get_current_sequence_number ( wallet_address ) [EOL] [EOL] if sequence is None : [EOL] msg = ( f' [string] { wallet_address } [string] ' ) [EOL] raise web . HTTPNotFound ( reason = msg ) [EOL] return web . json_response ( { [string] : sequence } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import decimal [EOL] import stellar [EOL] from decimal import Decimal [EOL] from typing import Tuple [EOL] [EOL] from aiohttp import web [EOL] from stellar_base . builder import Builder [EOL] from stellar_base . exceptions import AccountNotExistError , HorizonError [EOL] from stellar_base . utils import DecodeError [EOL] [EOL] from conf import settings [EOL] from stellar . wallet import Wallet , get_stellar_wallet [EOL] [EOL] [EOL] async def get_wallet ( wallet_address ) : [EOL] [docstring] [EOL] try : [EOL] wallet = await get_stellar_wallet ( wallet_address ) [EOL] except ( web . HTTPNotFound ) as ex : [EOL] msg = [string] . format ( str ( ex ) , wallet_address ) [EOL] raise web . HTTPNotFound ( reason = msg ) [EOL] return wallet [EOL] [EOL] [EOL] async def wallet_address_is_duplicate ( destination_address ) : [EOL] [docstring] [EOL] try : [EOL] wallet = await get_wallet ( destination_address ) [EOL] return True [EOL] except ( web . HTTPNotFound ) as ex : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def build_generate_trust_wallet_transaction ( transaction_source_address , source_address , destination_address , xlm_amount , hot_amount = Decimal ( [number] ) , sequence = None , ) : [EOL] [docstring] [EOL] builder = Builder ( address = transaction_source_address , horizon = settings [ [string] ] , network = settings [ [string] ] , sequence = sequence , ) [EOL] builder . append_create_account_op ( source = source_address , destination = destination_address , starting_balance = xlm_amount ) [EOL] try : [EOL] builder . append_trust_op ( source = destination_address , destination = settings [ [string] ] , code = settings [ [string] ] , limit = settings [ [string] ] , ) [EOL] except DecodeError : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] except Exception as e : [EOL] msg = str ( e ) [EOL] raise web . HTTPInternalServerError ( reason = msg ) [EOL] [EOL] if hot_amount > [number] : [EOL] builder . append_payment_op ( source = source_address , destination = destination_address , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , amount = hot_amount , ) [EOL] [EOL] try : [EOL] unsigned_xdr = builder . gen_xdr ( ) [EOL] except Exception as e : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] [EOL] return unsigned_xdr , tx_hash [EOL] [EOL] [EOL] def build_generate_wallet_transaction ( transaction_source_address , source_address , destination_address , amount , sequence = None ) : [EOL] [docstring] [EOL] [EOL] builder = Builder ( address = transaction_source_address , horizon = settings [ [string] ] , network = settings [ [string] ] , sequence = sequence , ) [EOL] [EOL] try : [EOL] builder . append_create_account_op ( source = source_address , destination = destination_address , starting_balance = amount ) [EOL] except DecodeError : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] except Exception as e : [EOL] msg = str ( e ) [EOL] raise web . HTTPInternalServerError ( reason = msg ) [EOL] [EOL] try : [EOL] unsigned_xdr = builder . gen_xdr ( ) [EOL] except Exception as e : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] [EOL] return unsigned_xdr , tx_hash [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $stellar.wallet.Wallet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bytes,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bytes,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import aiohttp [EOL] import builtins [EOL] import decimal [EOL] import typing [EOL] import binascii [EOL] from decimal import Decimal , InvalidOperation [EOL] from json import JSONDecodeError [EOL] [EOL] from aiohttp import web [EOL] from conf import settings [EOL] from router import reverse [EOL] from transaction . transaction import get_signers [EOL] from wallet . wallet import ( build_generate_wallet_transaction , get_wallet , wallet_address_is_duplicate ) [EOL] [EOL] async def post_generate_wallet_from_request ( request ) : [EOL] [docstring] [EOL] try : [EOL] json_response = await request . json ( ) [EOL] except JSONDecodeError : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] source_address = request . match_info . get ( [string] ) [EOL] [EOL] destination_address = json_response [ [string] ] [EOL] [EOL] transaction_source_address = json_response [ [string] ] [EOL] try : [EOL] balance = Decimal ( json_response . get ( [string] , [number] ) ) [EOL] except InvalidOperation : [EOL] raise web . HTTPBadRequest ( reason = f"{ json_response . get ( [string] ) } [string] " ) [EOL] [EOL] if balance == [number] : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] duplicate = await wallet_address_is_duplicate ( destination_address ) [EOL] if duplicate : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] wallet = await get_wallet ( transaction_source_address ) [EOL] unsigned_xdr_byte , tx_hash_byte = build_generate_wallet_transaction ( transaction_source_address , source_address , destination_address , balance , sequence = wallet . sequence ) [EOL] [EOL] unsigned_xdr = unsigned_xdr_byte . decode ( ) [EOL] tx_hash = binascii . hexlify ( tx_hash_byte ) . decode ( ) [EOL] [EOL] host = settings [ [string] ] [EOL] [EOL] signers = await get_signers ( source_address ) [EOL] [EOL] result = { [string] : source_address , [string] : signers , [string] : unsigned_xdr , [string] : f"{ host }{ reverse ( [string] , transaction_hash = tx_hash ) }" , [string] : tx_hash , [string] : f'{ host }{ request . path }' } [EOL] [EOL] return web . json_response ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import asyncio [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import make_mocked_request [EOL] from asynctest import patch [EOL] from stellar_base . exceptions import AccountNotExistError , HorizonError [EOL] [EOL] from conf import settings [EOL] from wallet . wallet import get_wallet [EOL] from wallet . get_wallet import get_wallet_detail , get_wallet_from_request [EOL] from wallet . tests . factory . wallet import StellarWallet [EOL] from router import reverse [EOL] from stellar . wallet import Wallet [EOL] [EOL] [EOL] @ patch ( [string] ) async def test_get_wallet_from_request ( mock_get_wallet ) : [EOL] mock_get_wallet . return_value = { } [EOL] wallet_address = [string] [EOL] req = make_mocked_request ( [string] , reverse ( [string] , wallet_address = wallet_address ) , match_info = { [string] : wallet_address } ) [EOL] await get_wallet_from_request ( req ) [EOL] assert mock_get_wallet . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine @ patch ( [string] ) async def test_get_wallet_success_trusted_hot ( mock_address ) : [EOL] [EOL] balances = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : settings [ [string] ] , [string] : settings [ [string] ] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : settings [ [string] ] , } , { [string] : [string] , [string] : [string] } , ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] [EOL] result = await get_wallet_detail ( [string] ) [EOL] [EOL] host = settings . get ( [string] , None ) [EOL] url = reverse ( [string] , wallet_address = [string] ) [EOL] expect_data = { [string] : [string] , [string] : f'{ host }{ url }' , [string] : { settings [ [string] ] : [string] , [string] : [string] } , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , } [EOL] [EOL] assert result == expect_data [EOL] [EOL] [EOL] @ asyncio . coroutine @ patch ( [string] ) async def test_get_wallet_success_not_trust_hot ( mock_address ) : [EOL] [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] [EOL] result = await get_wallet_detail ( [string] ) [EOL] [EOL] host = host = settings . get ( [string] , None ) [EOL] url = reverse ( [string] , wallet_address = [string] ) [EOL] expect_data = { [string] : [string] , [string] : f'{ host }{ url }' , [string] : f"{ settings [ [string] ] }{ reverse ( [string] , wallet_address = [string] ) }" , [string] : { [string] : [string] } , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , } [EOL] assert result == expect_data [EOL] [EOL] [EOL] @ asyncio . coroutine @ patch ( [string] ) async def test_get_wallet_success ( mock_address ) : [EOL] address = [string] [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] sequence = [number] [EOL] data = { [string] : [string] , [string] : [string] } [EOL] thresholds = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] signers = [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] mock_address . return_value = Wallet ( address , balances , sequence , data , signers , thresholds , { } ) [EOL] [EOL] result = await get_wallet ( address ) [EOL] expect_result = { [string] : address , [string] : balances , [string] : signers , [string] : thresholds , [string] : data , [string] : sequence , [string] : { } , } [EOL] assert result . __dict__ == expect_result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from router import reverse [EOL] from wallet . get_wallet_history import get_wallet_history , format_history [EOL] [EOL] [EOL] class TestGetWalletHistoryFromRequest ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_wallet_history_from_request_with_minimum_params_success ( self , history , format_history ) : [EOL] format_history . return_value = history . return_value = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] get_wallet_history_url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , get_wallet_history_url ) [EOL] assert resp . status == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_wallet_history_from_request_with_all_params_success ( self , history , format_history ) : [EOL] format_history . return_value = history . return_value = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] params = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] get_wallet_history_url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , get_wallet_history_url , params = params ) [EOL] assert resp . status == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_wallet_history_from_request_fail_date_wrong_format ( self , history , format_history ) : [EOL] format_history . return_value = history . return_value = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] params = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] get_wallet_history_url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , get_wallet_history_url , params = params ) [EOL] assert resp . status == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_wallet_history_from_request_fail_invalid_sort_value ( self , history , format_history ) : [EOL] format_history . return_value = history . return_value = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] params = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] get_wallet_history_url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , get_wallet_history_url , params = params ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] class TestGetWalletHistory ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . limit = [string] [EOL] self . offset = [string] [EOL] self . mock_get_wallet_effect_value = { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : [ { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } ] } } [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_history_success ( self , mock_get_wallet_effect ) : [EOL] [EOL] mock_get_wallet_effect . return_value = self . mock_get_wallet_effect_value [EOL] [EOL] history = await get_wallet_history ( wallet_address = self . wallet_address , limit = self . limit ) [EOL] [EOL] expect = [string] [EOL] assert expect in history [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_history_with_specific_start_position ( self , mock_get_wallet_effect ) : [EOL] [EOL] mock_get_wallet_effect . return_value = self . mock_get_wallet_effect_value [EOL] [EOL] history = await get_wallet_history ( wallet_address = self . wallet_address , limit = self . limit , offset = self . offset ) [EOL] [EOL] expect = [string] [EOL] assert expect in history [EOL] [EOL] [EOL] class TestFormatHistory ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . history = { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : [ { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } ] } } [EOL] self . limit = [number] [EOL] [EOL] @ unittest_run_loop async def test_format_history_sort_asc_success ( self ) : [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] n_offset = self . history [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] p_offset = self . history [ [string] ] [ [string] ] [ - [number] ] [ [string] ] [EOL] expect = { [string] : url , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] , [string] : f'{ url } [string] { p_offset } [string] { self . limit } [string] ' , [string] : f'{ url } [string] { n_offset } [string] { self . limit } [string] ' } [EOL] actual = await format_history ( history = self . history , wallet_address = self . wallet_address , limit = self . limit , sort = [string] ) [EOL] assert actual == expect [EOL] [EOL] @ unittest_run_loop async def test_format_history_sort_desc_success ( self ) : [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] n_offset = self . history [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] p_offset = self . history [ [string] ] [ [string] ] [ - [number] ] [ [string] ] [EOL] expect = { [string] : url , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] , [string] : f'{ url } [string] { p_offset } [string] { self . limit } [string] ' , [string] : f'{ url } [string] { n_offset } [string] { self . limit } [string] ' } [EOL] actual = await format_history ( history = self . history , wallet_address = self . wallet_address , limit = [number] , sort = [string] ) [EOL] assert actual == expect [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0
from typing import Literal , Any , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import token_platform [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from stellar_base . utils import DecodeError [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from conf import settings [EOL] from wallet . wallet import build_generate_trust_wallet_transaction , build_generate_wallet_transaction [EOL] [EOL] [EOL] class TestBuildCreateTrustWalletTx ( BaseTestClass ) : [EOL] [EOL] async def setUpAsync ( self ) : [EOL] self . source_address = [string] [EOL] self . destination_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . starting_amount = [number] [EOL] [EOL] class TeMock ( ) : [EOL] def hash_meta ( self ) : [EOL] return [string] [EOL] [EOL] class BuilderMock ( ) : [EOL] [EOL] def __init__ ( self , te ) : [EOL] self . te = te [EOL] [EOL] def append_create_account_op ( self , source , destination , starting_balance ) : [EOL] pass [EOL] [EOL] def append_trust_op ( self , source , destination , code , limit ) : [EOL] if ( source == [string] or destination == [string] ) : [EOL] raise DecodeError ( [string] ) [EOL] if ( source == [string] or destination == [string] ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] def gen_xdr ( self ) : [EOL] return [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_trust_wallet_transaction_success ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] actual = build_generate_trust_wallet_transaction ( self . transaction_source_address , self . source_address , self . destination_address , self . starting_amount ) [EOL] expect = ( [string] , [string] ) [EOL] assert actual == expect [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_trust_wallet_transaction_with_wrong_parameter ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] build_generate_trust_wallet_transaction ( [string] , [string] , [string] , self . starting_amount ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_trust_wallet_transaction_without_issuer_setting ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] build_generate_trust_wallet_transaction ( [string] , [string] , [string] , self . starting_amount ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_trust_wallet_transaction_with_fake_source_and_destination ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr = Exception ( [string] ) [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] build_generate_trust_wallet_transaction ( self . transaction_source_address , self . source_address , self . destination_address , self . starting_amount ) [EOL] [EOL] [EOL] class TestBuildCreateWalletTx ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . source_address = [string] [EOL] self . destination_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . starting_amount = [number] [EOL] [EOL] class TeMock ( ) : [EOL] def hash_meta ( self ) : [EOL] return [string] [EOL] [EOL] class BuilderMock ( ) : [EOL] [EOL] def __init__ ( self , te ) : [EOL] self . te = te [EOL] [EOL] def append_create_account_op ( self , source , destination , starting_balance ) : [EOL] if ( source == [string] or destination == [string] ) : [EOL] raise DecodeError ( [string] ) [EOL] if ( source == [string] or destination == [string] ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def gen_xdr ( self ) : [EOL] return [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_wallet_transaction_success ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] actual = build_generate_wallet_transaction ( self . transaction_source_address , self . source_address , self . destination_address , self . starting_amount ) [EOL] expect = ( [string] , [string] ) [EOL] assert actual == expect [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_wallet_transaction_with_wrong_parameter ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] build_generate_wallet_transaction ( [string] , [string] , [string] , self . starting_amount ) [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_wallet_transaction_another_issuer ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] build_generate_wallet_transaction ( [string] , [string] , [string] , self . starting_amount ) [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_wallet_transaction_with_fake_source_and_destination ( self , mock_builder ) : [EOL] te = self . TeMock ( ) [EOL] mock_builder . return_value = self . BuilderMock ( te ) [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr = Exception ( [string] ) [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] build_generate_wallet_transaction ( self . transaction_source_address , self . source_address , self . destination_address , self . starting_amount ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateTrustWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $token_platform.wallet.tests.test_wallet.TestBuildCreateWalletTx.TeMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import binascii [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from stellar_base . exceptions import AccountNotExistError , HorizonError [EOL] from stellar_base . keypair import Keypair [EOL] from stellar_base . utils import StellarMnemonic [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from conf import settings [EOL] from router import reverse [EOL] from stellar . wallet import Wallet [EOL] from wallet . wallet import ( build_generate_trust_wallet_transaction , wallet_address_is_duplicate ) [EOL] [EOL] [EOL] class TestCreateTrustWallet ( BaseTestClass ) : [EOL] [docstring] [EOL] async def setUpAsync ( self ) : [EOL] sm = StellarMnemonic ( [string] ) [EOL] secret_phrase = sm . generate ( ) [EOL] kp = Keypair . deterministic ( secret_phrase , lang = [string] ) [EOL] self . wallet_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . target_address = kp . address ( ) . decode ( ) [EOL] self . xlm_amount = [number] [EOL] self . host = settings [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_post_generate_trust_wallet_from_request_success ( self , mock_xdr , get_wallet , mock_check ) : [EOL] mock_xdr . return_value = ( [string] , [string] ) [EOL] get_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] mock_check . return_value = False [EOL] [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] json_request = { [string] : self . target_address , [string] : self . transaction_source_address , [string] : self . xlm_amount } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = json_request ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] expect_tx_hash = binascii . hexlify ( mock_xdr . return_value [ [number] ] ) . decode ( ) [EOL] expect_unsigned_xdr = mock_xdr . return_value [ [number] ] . decode ( ) [EOL] expect = { [string] : self . wallet_address , [string] : self . transaction_source_address , [string] : [ self . wallet_address , self . target_address , self . transaction_source_address ] , [string] : expect_unsigned_xdr , [string] : f"{ self . host }{ reverse ( [string] , transaction_hash = expect_tx_hash ) }" , [string] : expect_tx_hash , [string] : f'{ self . host }{ url }' } [EOL] assert text == expect [EOL] [EOL] @ unittest_run_loop async def test_post_generate_trust_wallet_from_request_json_data_missing ( self ) : [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [ [string] ] [EOL] [EOL] @ unittest_run_loop async def test_post_generate_trust_wallet_from_request_missing_param ( self ) : [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , url , json = { [string] : [string] , [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert text [ [string] ] == [string] [EOL] [EOL] @ unittest_run_loop async def test_post_generate_trust_wallet_from_request_use_wrong_parameter ( self ) : [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , url , json = { [string] : [string] , [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [ [string] ] [EOL] [EOL] resp = await self . client . request ( [string] , url , json = { [string] : [string] , [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [ [string] ] [EOL] [EOL] resp = await self . client . request ( [string] , url , json = { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [ [string] ] [EOL] [EOL] resp = await self . client . request ( [string] , url , json = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [ [string] ] [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] , ** { [string] : True } ) async def test_post_generate_trust_wallet_from_request_is_duplicate_wallet_address ( self , mock ) : [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] json_request = { [string] : self . target_address , [string] : self . transaction_source_address , [string] : self . xlm_amount } [EOL] [EOL] result = await self . client . request ( [string] , url , json = json_request ) [EOL] assert result . status == [number] [EOL] text = await result . json ( ) [EOL] assert [string] in text [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests . test_utils import BaseTestClass [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from wallet . get_current_tx_sequence import get_current_tx_sequence_from_request [EOL] from asynctest import patch [EOL] from router import reverse [EOL] [comment] [EOL] [EOL] class TestGetcurrentTransactionNumber ( BaseTestClass ) : [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_current_tx_sequence_from_request_success ( self , mock_seq_no ) : [EOL] mock_seq_no . return_value = [number] [EOL] wallet_address = [string] [EOL] url = reverse ( [string] , wallet_address = wallet_address ) [EOL] [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] [EOL] message = await resp . json ( ) [EOL] seq_number = message . get ( [string] , ) [EOL] assert isinstance ( seq_number , int ) [EOL] mock_seq_no . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_current_tx_sequence_not_found ( self , mock_seq_no ) : [EOL] mock_seq_no . return_value = None [EOL] wallet_address = [string] [EOL] url = reverse ( [string] , wallet_address = wallet_address ) [EOL] [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] [EOL] message = await resp . json ( ) [EOL] expect = f" [string] { wallet_address } [string] " [EOL] assert message [ [string] ] == expect [EOL] [EOL] mock_seq_no . assert_called_once_with ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List [EOL] import typing [EOL] class StellarWallet ( object ) : [EOL] def __init__ ( self , balances ) : [EOL] [comment] [EOL] [comment] [EOL] self . address = [string] [EOL] self . balances = balances [EOL] self . signers = [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } ] [EOL] self . thresholds = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] self . data = { [string] : [string] , [string] : [string] } [EOL] self . sequence = [string] [EOL] [EOL] def get ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] import json [EOL] import logging [EOL] import traceback [EOL] from datetime import datetime [EOL] [EOL] from aiohttp import web [EOL] [EOL] [EOL] @ web . middleware async def handle_log ( request , handler ) : [EOL] start_time = datetime . utcnow ( ) [EOL] response = await handler ( request ) [EOL] write_access_log ( request , response , start_time ) [EOL] [EOL] if response . status != [number] and response . text : [EOL] body = json . loads ( response . text ) [EOL] error_message = body . get ( [string] ) or body . get ( [string] ) [EOL] traceback = [string] . join ( body . get ( [string] ) ) if body . get ( [string] ) else None [EOL] if error_message and traceback : [EOL] write_error_log ( error_message , traceback ) [EOL] return response [EOL] [EOL] [EOL] def write_access_log ( request , response , time ) : [EOL] request_name = request . path_qs [EOL] if request_name == [string] : [EOL] return None [EOL] [EOL] now = datetime . utcnow ( ) [EOL] diff_time = now - time [EOL] diff_time_seconds = diff_time . total_seconds ( ) [EOL] [EOL] user_agent = request . headers . get ( [string] , [string] ) [EOL] referer = request . headers . get ( [string] , [string] ) [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . info ( f'{ request . remote } [string] { request . method } [string] { request . path_qs } [string] { request . version . major } [string] { request . version . minor } [string] { referer } [string] { user_agent } [string] { response . status } [string] { diff_time_seconds } [string] ' ) [EOL] [EOL] [EOL] def write_error_log ( error_message , traceback_stack ) : [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . error ( error_message ) [EOL] logger . error ( traceback_stack ) [EOL] [EOL] [EOL] def format_error ( e ) : [EOL] return { [string] : str ( e ) , [string] : traceback . format_exc ( chain = False ) . split ( [string] ) } [EOL] [EOL] [EOL] def write_audit_log ( request , response , operation , message ) : [EOL] user_agent = request . headers . get ( [string] , [string] ) [EOL] referer = request . headers . get ( [string] , [string] ) [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] log_message = f'{ operation } [string] { request . remote } [string] { request . method } [string] { request . path_qs } [string] { referer } [string] { user_agent } [string] { message }' [EOL] logger . info ( log_message )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List [EOL] import typing [EOL] import logging [EOL] [EOL] log_setting = { [string] : [number] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] , [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , } , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import aiohttp [EOL] import typing [EOL] import prometheus_client [EOL] from prometheus_client import CONTENT_TYPE_LATEST , Counter , Gauge , Histogram [EOL] [EOL] from aiohttp import web [EOL] [EOL] metric = dict ( ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] metric [ [string] ] = Gauge ( [string] , [string] ) [EOL] [EOL] async def get_metrics ( request ) : [EOL] response = web . Response ( body = prometheus_client . generate_latest ( ) ) [EOL] response . content_type = CONTENT_TYPE_LATEST [EOL] return response [EOL] [EOL] [EOL] @ web . middleware async def metrics_increasing ( request , handler ) : [EOL] response = await handler ( request ) [EOL] [EOL] if ( response . status == [number] or response . status == [number] ) : [EOL] resource_name = request . match_info . route . resource . name [EOL] resource_name = str ( resource_name ) . upper ( ) [EOL] resource_name = resource_name . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] if resource_name != [string] and resource_name != [string] : [EOL] metric [ resource_name ] . inc ( ) [EOL] [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from request_tracking . metrics import metric [EOL] from router import ROUTER [EOL] [EOL] [EOL] class TestMetricsName ( BaseTestClass ) : [EOL] [EOL] def test_metrics_name ( self ) : [EOL] ROUTER_KEY = [ ] [EOL] for key , value in ROUTER . items ( ) : [EOL] if key == [string] or key == [string] : [EOL] continue [EOL] key_upper = key . upper ( ) [EOL] key_upper = key_upper . replace ( [string] , [string] ) [EOL] for k , v in value . items ( ) : [EOL] if k != [string] : [EOL] resource_name = f'{ k } [string] { key_upper }' [EOL] ROUTER_KEY . append ( resource_name ) [EOL] [EOL] assert len ( metric ) == len ( ROUTER_KEY ) [EOL] [EOL] for item in ROUTER_KEY : [EOL] assert item in metric [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import token_platform [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from conf import settings [EOL] from stellar . wallet import ( get_stellar_wallet , get_transaction , get_wallet_effect , get_operations_of_transaction , get_transaction_by_wallet , submit_transaction , ) [EOL] [EOL] HORIZON_URL = settings [ [string] ] [EOL] [EOL] [EOL] class TestHorizonApi ( BaseTestClass ) : [EOL] class SuccessResponse : [EOL] def __init__ ( self , content_type ) : [EOL] self . status = [number] [EOL] self . content_type = content_type [EOL] [EOL] async def json ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] class GetOperationsOfTransactionSuccess : [EOL] def __init__ ( self , content_type ) : [EOL] self . status = [number] [EOL] self . operation_records = [ { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] self . content_type = content_type [EOL] [EOL] async def json ( self ) : [EOL] return { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : self . operation_records } , } [EOL] [EOL] class GetTransactionBywalletSuccess : [EOL] def __init__ ( self , content_type ) : [EOL] self . status = [number] [EOL] self . transaction_records = [ { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : True } , [string] : { [string] : [string] , [string] : True } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } ] [EOL] self . content_type = content_type [EOL] [EOL] async def json ( self ) : [EOL] return { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : self . transaction_records } , } [EOL] [EOL] class NotFoundResponse : [EOL] def __init__ ( self , content_type ) : [EOL] self . status = [number] [EOL] self . content_type = content_type [EOL] [EOL] async def json ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] [EOL] class BadRequestResponse : [EOL] def __init__ ( self , content_type ) : [EOL] self . status = [number] [EOL] self . content_type = content_type [EOL] [EOL] async def json ( self ) : [EOL] return { [string] : [string] } [EOL] [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . transaction_hash = [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_stellar_wallet_success ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . SuccessResponse ( [string] ) [EOL] wallet = await get_stellar_wallet ( self . wallet_address ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address }' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_stellar_wallet_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] wallet = await get_stellar_wallet ( self . wallet_address ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address }' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_stellar_wallet_upstream_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] wallet = await get_stellar_wallet ( self . wallet_address ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address }' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_success ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . SuccessResponse ( [string] ) [EOL] transaction = await get_transaction ( self . transaction_hash ) [EOL] url = f'{ HORIZON_URL } [string] { self . transaction_hash }' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] transaction = await get_transaction ( self . transaction_hash ) [EOL] url = f'{ HORIZON_URL } [string] { self . transaction_hash }' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_upstream_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] transaction = await get_transaction ( self . transaction_hash ) [EOL] url = f'{ HORIZON_URL } [string] { self . transaction_hash }' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_effect_success ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . SuccessResponse ( [string] ) [EOL] effect = await get_wallet_effect ( self . wallet_address , limit = [number] , offset = [string] ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address } [string] ' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_effect_not_found ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] effect = await get_wallet_effect ( self . wallet_address ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address } [string] ' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_effect_bad_request ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . BadRequestResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] effect = await get_wallet_effect ( self . wallet_address ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address } [string] ' [EOL] mock_get . assert_called_once_with ( url ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_effect_wrong_parameter ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . BadRequestResponse ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] effect = await get_wallet_effect ( self . wallet_address , sort = [string] ) [EOL] mock_get . assert_not_called ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_wallet_effect_upstream_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . BadRequestResponse ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] effect = await get_wallet_effect ( self . wallet_address , sort = [string] ) [EOL] mock_get . assert_not_called ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_get_transaction_by_wallet_success ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . GetTransactionBywalletSuccess ( [string] ) [EOL] transactions = await get_transaction_by_wallet ( self . wallet_address , limit = [number] , offset = [string] ) [EOL] url = f'{ HORIZON_URL } [string] { self . wallet_address } [string] ' [EOL] mock_get . assert_called_once_with ( url ) [EOL] assert transactions == session . __aenter__ . return_value . transaction_records [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_get_transaction_by_wallet_not_found ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] transactions = await get_transaction_by_wallet ( self . wallet_address ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_get_transaction_by_wallet_upstream_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] transactions = await get_transaction_by_wallet ( self . wallet_address ) [EOL] [EOL] @ unittest_run_loop async def test_get_get_transaction_by_wallet_wrong_parameter ( self ) : [EOL] with pytest . raises ( ValueError ) : [EOL] transactions = await get_transaction_by_wallet ( self . wallet_address , sort = [string] ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_operations_of_transaction_success ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . GetOperationsOfTransactionSuccess ( [string] ) [EOL] transactions = await get_operations_of_transaction ( self . transaction_hash , limit = [number] , offset = [string] ) [EOL] url = f'{ HORIZON_URL } [string] { self . transaction_hash } [string] ' [EOL] mock_get . assert_called_once_with ( url ) [EOL] assert transactions == session . __aenter__ . return_value . operation_records [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_operations_of_transaction_not_found ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] transactions = await get_operations_of_transaction ( self . wallet_address ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_operations_of_transaction_upstream_fail ( self , mock_get ) : [EOL] session = mock_get . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] transactions = await get_operations_of_transaction ( self . wallet_address ) [EOL] [EOL] @ unittest_run_loop async def test_get_operations_of_transaction_wrong_parameter ( self ) : [EOL] with pytest . raises ( ValueError ) : [EOL] transactions = await get_operations_of_transaction ( self . wallet_address , sort = [string] ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_submit_transaction_success ( self , mock_post ) : [EOL] session = mock_post . return_value [EOL] session . __aenter__ . return_value = self . SuccessResponse ( [string] ) [EOL] signed_xdr = [string] [EOL] result = await submit_transaction ( signed_xdr ) [EOL] expect = self . SuccessResponse ( [string] ) [EOL] assert result == await expect . json ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_submit_transaction_fail_not_found ( self , mock_post ) : [EOL] session = mock_post . return_value [EOL] session . __aenter__ . return_value = self . BadRequestResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] signed_xdr = [string] [EOL] result = await submit_transaction ( signed_xdr ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_submit_transaction_fail_bad_request ( self , mock_post ) : [EOL] session = mock_post . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] signed_xdr = [string] [EOL] result = await submit_transaction ( signed_xdr ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_submit_transaction_upstream_fail ( self , mock_post ) : [EOL] session = mock_post . return_value [EOL] session . __aenter__ . return_value = self . NotFoundResponse ( [string] ) [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] signed_xdr = [string] [EOL] result = await submit_transaction ( signed_xdr ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]],typing.List[builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $token_platform.stellar.tests.test_stellar_wallet.TestHorizonApi.SuccessResponse$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $token_platform.stellar.tests.test_stellar_wallet.TestHorizonApi.SuccessResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0
	0
from aiohttp . test_utils import AioHTTPTestCase [EOL] from aiohttp import web [EOL] from server import init_app [EOL] [EOL] class BaseTestClass ( AioHTTPTestCase ) : [EOL] [docstring] [EOL] async def get_application ( self ) : [EOL] return await init_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import traceback [EOL] from json import JSONDecodeError [EOL] [EOL] from aiohttp import web [EOL] from stellar_base . utils import DecodeError [EOL] from stellar_base . exceptions import AccountNotExistError , HorizonError [EOL] from typing import Dict [EOL] from sentry import capture_exception [EOL] [EOL] @ web . middleware async def handle_error ( request , handler ) : [EOL] try : [EOL] response = await handler ( request ) [EOL] except JSONDecodeError : [EOL] message = [string] [EOL] return web . json_response ( format_error ( message ) , status = [number] ) [EOL] except KeyError as ex : [EOL] message = [string] . format ( str ( ex ) ) [EOL] return web . json_response ( format_error ( message ) , status = [number] ) [EOL] except TypeError as ex : [EOL] message = [string] . format ( str ( ex ) ) [EOL] return web . json_response ( format_error ( message ) , status = [number] ) [EOL] except ( ValueError , HorizonError , AccountNotExistError , web . HTTPBadRequest , DecodeError ) as ex : [EOL] return web . json_response ( format_error ( ex ) , status = [number] ) [EOL] except web . HTTPNotFound as ex : [EOL] return web . json_response ( format_error ( ex ) , status = [number] ) [EOL] except web . HTTPInternalServerError as ex : [EOL] capture_exception ( ) [EOL] return web . json_response ( format_error_5xx ( ex ) , status = [number] ) [EOL] except web . HTTPConflict as ex : [EOL] return web . json_response ( format_error ( ex ) , status = [number] ) [EOL] except Exception as ex : [EOL] return web . json_response ( format_error ( ex ) , status = [number] ) [EOL] return response [EOL] [EOL] [EOL] def format_error ( e ) : [EOL] try : [EOL] body = e . reason [EOL] if isinstance ( body , Dict ) : [EOL] e = body [ [string] ] [EOL] except : [EOL] pass [EOL] [EOL] return { [string] : str ( e ) } [EOL] [EOL] def format_error_5xx ( e ) : [EOL] try : [EOL] body = e . reason [EOL] if isinstance ( body , Dict ) : [EOL] e = body [ [string] ] [EOL] except : [EOL] pass [EOL] [EOL] return { [string] : str ( e ) , [string] : traceback . format_exc ( chain = False ) . split ( [string] ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] from transaction . transaction import is_duplicate_transaction , submit_transaction , get_transaction [EOL] from aiohttp import web [EOL] from log import log_conf [EOL] from conf import settings [EOL] from log . log import write_audit_log [EOL] [EOL] [EOL] async def put_transaction_from_request ( request ) : [EOL] [docstring] [EOL] [EOL] signed_xdr = await request . text ( ) [EOL] tx_hash = request . match_info . get ( [string] ) [EOL] [EOL] if not signed_xdr or not tx_hash : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] if await is_duplicate_transaction ( tx_hash ) : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] response = await submit_transaction ( signed_xdr ) [EOL] [EOL] [comment] [EOL] operation = settings [ [string] ] [ [string] ] [EOL] message = f' [string] { signed_xdr }' [EOL] write_audit_log ( request , response , operation , message ) [EOL] [EOL] return web . json_response ( response , status = [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple , List [EOL] import typing [EOL] import builtins [EOL] import stellar_base [EOL] import decimal [EOL] from typing import Dict , Tuple , Any , List [EOL] from stellar_base . builder import Builder [EOL] from escrow . get_escrow_wallet import get_escrow_wallet_detail [EOL] from router import reverse [EOL] from decimal import Decimal [EOL] from conf import settings [EOL] from aiohttp import web [EOL] from stellar . wallet import get_stellar_wallet , get_transaction_by_wallet [EOL] import binascii [EOL] [EOL] [EOL] async def generate_merge_transaction ( transaction_source_address , wallet_address , parties_wallet = None ) : [EOL] [docstring] [EOL] wallet_detail = await get_escrow_wallet_detail ( wallet_address ) [EOL] wallet = await get_stellar_wallet ( transaction_source_address ) [EOL] unsigned_xdr , tx_hash = await build_generate_merge_transaction ( transaction_source_address , wallet_detail , parties_wallet , wallet . sequence ) [EOL] [EOL] return { [string] : wallet_address , [string] : reverse ( [string] , transaction_hash = tx_hash ) , [string] : wallet_detail [ [string] ] , [string] : unsigned_xdr , [string] : tx_hash , } [EOL] [EOL] [EOL] async def build_generate_merge_transaction ( transaction_source_address , wallet_detail , parties_wallet = None , sequence = None ) : [EOL] [docstring] [EOL] [EOL] wallet_address = wallet_detail [ [string] ] [EOL] wallet_data = wallet_detail [ [string] ] [EOL] creator_address = ( wallet_data [ [string] ] [EOL] if wallet_data and [string] in wallet_data . keys ( ) [EOL] else await get_creator_address ( wallet_address ) ) [EOL] [EOL] builder = Builder ( address = transaction_source_address , horizon = settings [ [string] ] , network = settings [ [string] ] , sequence = sequence , ) [EOL] [EOL] if not parties_wallet : [EOL] parties_wallet = await generate_parties_wallet ( wallet_detail ) [EOL] [EOL] balance = Decimal ( wallet_detail [ [string] ] [ settings [ [string] ] ] ) [EOL] if not await is_match_balance ( parties_wallet , balance ) : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] await build_payment_operation ( builder , wallet_address , parties_wallet ) [EOL] await build_remove_trustlines_operation ( builder , wallet_address ) [EOL] await build_remove_manage_data_operation ( builder , wallet_address , wallet_data . keys ( ) ) [EOL] await build_account_merge_operation ( builder , wallet_address , creator_address ) [EOL] [EOL] try : [EOL] xdr = builder . gen_xdr ( ) [EOL] except Exception as e : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] [EOL] return xdr . decode ( ) , binascii . hexlify ( tx_hash ) . decode ( ) [EOL] [EOL] [EOL] async def get_creator_address ( wallet_address ) : [EOL] [docstring] [EOL] transactions = await get_transaction_by_wallet ( wallet_address , limit = [number] , sort = [string] ) [EOL] result = transactions [ [number] ] [EOL] return result [ [string] ] [EOL] [EOL] [EOL] async def generate_parties_wallet ( wallet_detail ) : [EOL] [docstring] [EOL] parties_wallet = [ ] [EOL] wallet = { [string] : wallet_detail [ [string] ] [ [string] ] , [string] : wallet_detail [ [string] ] [ settings [ [string] ] ] , } [EOL] parties_wallet . append ( wallet ) [EOL] return parties_wallet [EOL] [EOL] [EOL] async def is_match_balance ( parties_wallet , balance ) : [EOL] [docstring] [EOL] amount = Decimal ( [number] ) [EOL] [EOL] for wallet in parties_wallet : [EOL] amount += Decimal ( wallet [ [string] ] ) [EOL] [EOL] return amount == balance [EOL] [EOL] [EOL] async def build_payment_operation ( builder , source , parties_wallet ) : [EOL] [EOL] for wallet in parties_wallet : [EOL] destination = wallet [ [string] ] [EOL] amount = Decimal ( wallet [ [string] ] ) [EOL] if amount > [number] : [EOL] builder . append_payment_op ( destination = destination , amount = amount , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source , ) [EOL] [EOL] [EOL] async def build_remove_trustlines_operation ( builder , source ) : [EOL] builder . append_trust_op ( settings [ [string] ] , settings [ [string] ] , limit = [number] , source = source ) [EOL] [EOL] [EOL] async def build_remove_manage_data_operation ( builder , source , list_name ) : [EOL] for name in list_name : [EOL] builder . append_manage_data_op ( name , None , source = source ) [EOL] [EOL] [EOL] async def build_account_merge_operation ( builder , source , destination ) : [EOL] builder . append_account_merge_op ( destination = destination , source = source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import builtins [EOL] import copy [EOL] from typing import Any , Dict , List , Mapping , NewType , Optional , Union [EOL] [EOL] import aiohttp [EOL] import stellar [EOL] from conf import settings [EOL] from router import reverse [EOL] from wallet . wallet import get_wallet [EOL] [EOL] JSONType = Union [ str , int , float , bool , None , Dict [ str , Any ] , List [ Any ] ] [EOL] HORIZON_URL = settings [ [string] ] [EOL] [EOL] [EOL] async def is_duplicate_transaction ( transaction_hash ) : [EOL] [docstring] [EOL] try : [EOL] transaction = await stellar . wallet . get_transaction ( transaction_hash ) [EOL] id = transaction . get ( [string] ) [EOL] return True if id else False [EOL] except : [EOL] return False [EOL] [EOL] [EOL] async def submit_transaction ( xdr ) : [EOL] [docstring] [EOL] resp = await stellar . wallet . submit_transaction ( xdr ) [EOL] return resp [EOL] [EOL] [EOL] async def get_current_sequence_number ( wallet_address ) : [EOL] [docstring] [EOL] wallet = await stellar . wallet . get_stellar_wallet ( wallet_address ) [EOL] return wallet . sequence [EOL] [EOL] [EOL] async def get_transaction_hash ( address , memo ) : [EOL] [docstring] [EOL] transaction = await get_transaction_by_memo ( address , memo ) [EOL] [EOL] if isinstance ( transaction , Dict ) and [string] in transaction : [EOL] return transaction [ [string] ] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] async def get_transaction ( tx_hash ) : [EOL] [docstring] [EOL] [EOL] def _format_transaction ( tx_detail ) : [EOL] [docstring] [EOL] return { [string] : reverse ( [string] , transaction_hash = tx_detail . get ( [string] ) ) , [string] : tx_detail . get ( [string] , None ) , [string] : tx_detail . get ( [string] ) , [string] : tx_detail . get ( [string] ) , [string] : tx_detail . get ( [string] , None ) , [string] : tx_detail . get ( [string] , None ) , [string] : tx_detail . get ( [string] , None ) , [string] : tx_detail . get ( [string] , None ) , [string] : tx_detail . get ( [string] , None ) , [string] : tx_detail . get ( [string] , None ) , } [EOL] [EOL] async def _get_operation_data_of_transaction ( tx_hash ) : [EOL] [docstring] [EOL] operations = await stellar . wallet . get_operations_of_transaction ( tx_hash ) [EOL] for operation in operations : [EOL] operation . pop ( [string] ) [EOL] return operations [EOL] [EOL] transaction = await stellar . wallet . get_transaction ( tx_hash ) [EOL] [EOL] tx_detail = _format_transaction ( transaction ) [EOL] [EOL] tx_detail [ [string] ] = await _get_operation_data_of_transaction ( tx_hash ) [EOL] [EOL] return tx_detail [EOL] [EOL] [EOL] async def get_signers ( wallet_address ) : [EOL] [docstring] [EOL] wallet = await get_wallet ( wallet_address ) [EOL] signers = list ( filter ( lambda signer : signer [ [string] ] > [number] , wallet . signers ) ) [EOL] formated = list ( map ( lambda signer : { [string] : signer [ [string] ] , [string] : signer [ [string] ] } , signers ) ) [EOL] return formated [EOL] [EOL] [EOL] async def get_threshold_weight ( wallet_address , operation_type ) : [EOL] [docstring] [EOL] [EOL] def _get_threshould_level ( operation_type ) : [EOL] [docstring] [EOL] low = [ [string] ] [EOL] high = [ [string] , [string] ] [EOL] [EOL] if operation_type in low : [EOL] return [string] [EOL] elif operation_type in high : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] wallet = await get_wallet ( wallet_address ) [EOL] [EOL] level = _get_threshould_level ( operation_type ) [EOL] return wallet . thresholds [ level ] [EOL] [EOL] [EOL] async def get_transaction_by_memo ( source_account , memo , cursor = None ) : [EOL] [EOL] [comment] [EOL] transactions = await stellar . wallet . get_transaction_by_wallet ( wallet_address = source_account , limit = [number] , sort = [string] , offset = cursor ) [EOL] [EOL] [comment] [EOL] transactions_filter = list ( [ transaction for transaction in transactions if transaction [ [string] ] == [string] ] ) [EOL] [EOL] for transaction in transactions_filter : [EOL] [EOL] if transaction [ [string] ] == memo : [EOL] return { [string] : [string] , [string] : [string] . format ( transaction [ [string] ] ) , [string] : transaction [ [string] ] , } [EOL] [EOL] if len ( transactions ) > [number] : [EOL] transaction_paging_token = transactions [ - [number] ] [ [string] ] [EOL] return await get_transaction_by_memo ( source_account , memo , transaction_paging_token ) [EOL] return { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,typing.List[typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import decimal [EOL] import aiohttp [EOL] import binascii [EOL] from decimal import Decimal , InvalidOperation [EOL] from typing import Any , Dict , List , Mapping , NewType , Optional , Tuple , Union [EOL] [EOL] from aiohttp import web [EOL] from stellar_base . builder import Builder [EOL] [EOL] from conf import settings [EOL] from router import reverse [EOL] from transaction . transaction import get_signers , get_threshold_weight [EOL] from wallet . wallet import get_wallet [EOL] from stellar . wallet import get_stellar_wallet [EOL] [EOL] [EOL] async def get_unsigned_add_trust_and_hot_from_request ( request ) : [EOL] [docstring] [EOL] source_account = request . match_info . get ( [string] , [string] ) [EOL] transaction_source_address = request . query [ [string] ] [EOL] hot_amount = request . query [ [string] ] [EOL] try : [EOL] hot_amount = Decimal ( hot_amount ) [EOL] except InvalidOperation : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] trust = await does_wallet_have_trust ( source_account ) [EOL] if trust : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] result = await get_unsigned_add_trust_and_hot ( source_account , transaction_source_address , hot_amount ) [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def does_wallet_have_trust ( wallet_address ) : [EOL] [docstring] [EOL] try : [EOL] wallet = await get_wallet ( wallet_address ) [EOL] if ( len ( list ( filter ( lambda b : b . get ( [string] , None ) == settings [ [string] ] [EOL] and b . get ( [string] , None ) == settings [ [string] ] , wallet . balances , ) ) ) == [number] ) : [EOL] return False [EOL] return True [EOL] except ( web . HTTPNotFound ) : [EOL] return False [EOL] [EOL] [EOL] async def get_unsigned_add_trust_and_hot ( source_address , transaction_source_address , hot_amount ) : [EOL] [docstring] [EOL] wallet = await get_stellar_wallet ( transaction_source_address ) [EOL] unsigned_xdr , tx_hash = await build_unsigned_add_trust_and_hot ( source_address , transaction_source_address , hot_amount , wallet . sequence ) [EOL] host = settings [ [string] ] [EOL] result = { [string] : reverse ( [string] , wallet_address = source_address ) , [string] : reverse ( [string] , transaction_hash = tx_hash ) , [string] : await get_threshold_weight ( source_address , [string] ) , [string] : await get_signers ( source_address ) , [string] : unsigned_xdr , [string] : tx_hash , } [EOL] return result [EOL] [EOL] [EOL] async def build_unsigned_add_trust_and_hot ( source_address , transaction_source_address , hot_amount , sequence = None ) : [EOL] [docstring] [EOL] builder = Builder ( address = transaction_source_address , horizon = settings [ [string] ] , network = settings [ [string] ] , sequence = sequence , ) [EOL] builder . append_trust_op ( settings [ [string] ] , settings [ [string] ] , source = source_address , limit = settings [ [string] ] ) [EOL] [EOL] if hot_amount > [number] : [EOL] builder . append_payment_op ( source = transaction_source_address , destination = source_address , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , amount = hot_amount , ) [EOL] [EOL] try : [EOL] unsigned_xdr = builder . gen_xdr ( ) [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] except Exception as ex : [EOL] raise web . HTTPNotFound ( text = str ( ex ) ) [EOL] return unsigned_xdr . decode ( [string] ) , binascii . hexlify ( tx_hash ) . decode ( ) [EOL] [EOL] [EOL] async def get_unsigned_change_trust_from_request ( request ) : [EOL] [docstring] [EOL] source_account = request . match_info . get ( [string] , [string] ) [EOL] transaction_source_address = request . query [ [string] ] [EOL] [EOL] result = await get_unsigned_change_trust ( source_account , transaction_source_address ) [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def get_unsigned_change_trust ( source_address , transaction_source_address ) : [EOL] [docstring] [EOL] wallet = await get_stellar_wallet ( transaction_source_address ) [EOL] unsigned_xdr , tx_hash = build_unsigned_change_trust ( source_address , transaction_source_address , wallet . sequence ) [EOL] host = settings [ [string] ] [EOL] result = { [string] : reverse ( [string] , wallet_address = source_address ) , [string] : reverse ( [string] , transaction_hash = tx_hash ) , [string] : await get_threshold_weight ( source_address , [string] ) , [string] : await get_signers ( source_address ) , [string] : unsigned_xdr , [string] : tx_hash , } [EOL] return result [EOL] [EOL] [EOL] def build_unsigned_change_trust ( source_address , transaction_source_address , sequence = None ) : [EOL] [docstring] [EOL] builder = Builder ( address = transaction_source_address , horizon = settings [ [string] ] , network = settings [ [string] ] , sequence = sequence , ) [EOL] builder . append_trust_op ( settings [ [string] ] , settings [ [string] ] , source = source_address , limit = settings [ [string] ] ) [EOL] [EOL] try : [EOL] unsigned_xdr = builder . gen_xdr ( ) [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] except Exception as ex : [EOL] raise web . HTTPNotFound ( text = str ( ex ) ) [EOL] [EOL] return unsigned_xdr . decode ( [string] ) , binascii . hexlify ( tx_hash ) . decode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import decimal [EOL] import aiohttp [EOL] import binascii [EOL] from decimal import Decimal [EOL] from typing import Any , Dict , List , Mapping , NewType , Optional , Tuple , Union [EOL] [EOL] from stellar_base . builder import Builder [EOL] from stellar_base . utils import DecodeError , decode_check [EOL] [EOL] from aiohttp import web [EOL] from conf import settings [EOL] from router import reverse [EOL] from transaction . transaction import get_signers , get_threshold_weight , get_transaction_by_memo [EOL] from wallet . get_wallet import get_wallet_detail [EOL] from wallet . wallet import get_wallet [EOL] from stellar . wallet import get_stellar_wallet [EOL] [EOL] [EOL] async def generate_payment_from_request ( request ) : [EOL] [docstring] [EOL] [EOL] body = await request . json ( ) [EOL] source_account = request . match_info . get ( [string] , [string] ) [EOL] transaction_source_address = body [ [string] ] [EOL] target_address = body [ [string] ] [EOL] amount_hot = body . get ( [string] ) [EOL] amount_xlm = body . get ( [string] ) [EOL] tax_amount_hot = body . get ( [string] , None ) [EOL] sequence_number = body . get ( [string] , None ) [EOL] memo = body . get ( [string] , None ) [EOL] memo_on = body . get ( [string] , [string] ) [EOL] await get_wallet ( source_account ) [EOL] [EOL] if memo_on not in [ [string] , [string] ] : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] try : [EOL] decode_check ( [string] , target_address ) [EOL] except DecodeError as e : [EOL] raise web . HTTPBadRequest ( reason = [string] . format ( target_address ) ) [EOL] [EOL] if memo : [EOL] focus_address = target_address if memo_on == [string] else source_account [EOL] url_get_transaction = await get_transaction_by_memo ( focus_address , memo ) [EOL] if url_get_transaction : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] if not sequence_number : [EOL] wallet = await get_stellar_wallet ( transaction_source_address ) [EOL] sequence_number = wallet . sequence [EOL] [EOL] result = await generate_payment ( transaction_source_address , source_account , target_address , amount_hot , amount_xlm , tax_amount_hot , sequence_number , memo , ) [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def generate_payment ( transaction_source_address , source_address , destination , amount_hot , amount_xlm , tax_amount_hot = None , sequence = None , memo = None , ) : [EOL] [docstring] [EOL] unsigned_xdr , tx_hash = await build_unsigned_transfer ( transaction_source_address , source_address , destination , amount_hot , amount_xlm , tax_amount_hot , sequence , memo ) [EOL] host = settings [ [string] ] [EOL] result = { [string] : reverse ( [string] , wallet_address = source_address ) , [string] : reverse ( [string] , transaction_hash = tx_hash ) , [string] : await get_threshold_weight ( source_address , [string] ) , [string] : await get_signers ( source_address ) , [string] : unsigned_xdr , [string] : tx_hash , } [EOL] return result [EOL] [EOL] [EOL] async def build_unsigned_transfer ( transaction_source_address , source_address , destination_address , amount_hot , amount_xlm , tax_amount_hot = None , sequence = None , memo_text = None , ) : [EOL] [docstring] [EOL] builder = Builder ( address = transaction_source_address , sequence = sequence , horizon = settings [ [string] ] , network = settings [ [string] ] , ) [EOL] [EOL] wallet = await get_wallet_detail ( destination_address ) [EOL] [EOL] if amount_hot and not wallet [ [string] ] . get ( settings [ [string] ] , False ) : [EOL] raise web . HTTPBadRequest ( reason = [string] . format ( destination_address , settings [ [string] ] ) ) [EOL] [EOL] if amount_xlm : [EOL] builder . append_payment_op ( destination_address , amount_xlm , source = source_address ) [EOL] [EOL] if amount_hot and wallet [ [string] ] . get ( settings [ [string] ] , False ) : [EOL] builder . append_payment_op ( destination_address , amount_hot , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source_address , ) [EOL] [EOL] if tax_amount_hot and Decimal ( tax_amount_hot ) > [number] : [EOL] builder . append_payment_op ( settings [ [string] ] , Decimal ( tax_amount_hot ) , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source_address , ) [EOL] [EOL] if memo_text : [EOL] builder . add_text_memo ( memo_text ) [EOL] [EOL] unsigned_xdr = builder . gen_xdr ( ) [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] return unsigned_xdr . decode ( [string] ) , binascii . hexlify ( tx_hash ) . decode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import aiohttp [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] from aiohttp import web , web_request , web_response [EOL] from conf import settings [EOL] from transaction . transaction import ( get_transaction , get_transaction_hash , get_transaction_by_memo ) [EOL] [EOL] [EOL] async def get_transaction_from_request ( request ) : [EOL] [docstring] [EOL] tx_hash = request . match_info . get ( [string] , [string] ) [EOL] result = await get_transaction ( tx_hash ) [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def get_transaction_hash_from_request ( request ) : [EOL] [docstring] [EOL] address = request . match_info . get ( [string] ) [EOL] memo = request . rel_url . query [ [string] ] [EOL] status = [number] [EOL] [EOL] result = await get_transaction_hash ( address , memo ) [EOL] if not result : [EOL] status = [number] [EOL] result = [string] [EOL] [EOL] return web . json_response ( { [string] : result } , status = status ) [EOL] [EOL] [EOL] async def get_transaction_hash_by_memo_from_reqeust ( request ) : [EOL] [docstring] [EOL] address = request . match_info . get ( [string] ) [EOL] memo = request . match_info . get ( [string] ) [EOL] transaction = await get_transaction_by_memo ( address , memo ) [EOL] if not transaction : [EOL] return web . Response ( status = [number] ) [EOL] return web . json_response ( transaction ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web_response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Literal , Any , List , Dict , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import decimal [EOL] import pytest [EOL] [EOL] from tests . test_utils import BaseTestClass [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from aiohttp import web [EOL] from asynctest import patch [EOL] from conf import settings [EOL] from router import reverse [EOL] from decimal import Decimal [EOL] from typing import List [EOL] from stellar_base . builder import Builder [EOL] from stellar_base . stellarxdr import StellarXDR_const as const [EOL] from transaction . generate_merge_transaction import ( generate_merge_transaction , build_payment_operation , build_remove_trustlines_operation , build_remove_manage_data_operation , build_account_merge_operation , build_generate_merge_transaction , generate_parties_wallet , is_match_balance , get_creator_address , ) [EOL] from stellar . wallet import Wallet [EOL] [EOL] [EOL] class TestGenerateMergeTransaction ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . custom_asset = settings [ [string] ] [EOL] self . remain_custom_asset = [string] [EOL] self . provider_address = [string] [EOL] self . creator_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . tx_hash = [string] [EOL] self . unsigned_xdr = [string] [EOL] self . parties_wallet = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] self . wallet_detail = { [string] : reverse ( [string] , escrow_address = self . wallet_address ) , [string] : { self . custom_asset : self . remain_custom_asset } , [string] : reverse ( [string] , escrow_address = self . wallet_address ) , [string] : { [string] : self . provider_address , [string] : self . creator_address } , [string] : [ self . provider_address , self . creator_address ] , } [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_generate_merge_transaction_success ( self , mock_wallet_detail , mock_merge_transaction , mock_get_stellar_wallet ) : [EOL] mock_wallet_detail . return_value = self . wallet_detail [EOL] mock_merge_transaction . return_value = self . unsigned_xdr , self . tx_hash [EOL] [EOL] result = await generate_merge_transaction ( self . transaction_source_address , self . wallet_address , self . parties_wallet ) [EOL] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] [EOL] expect = { [string] : self . wallet_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : self . wallet_detail [ [string] ] , [string] : self . unsigned_xdr , [string] : self . tx_hash , } [EOL] [EOL] assert result == expect [EOL] [EOL] [EOL] class TestBuildGenerateMergeTransaction ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . provider_address = [string] [EOL] self . creator_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . parties_wallet = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] self . wallet_detail = { [string] : self . wallet_address , [string] : reverse ( [string] , escrow_address = self . wallet_address ) , [string] : { settings [ [string] ] : [string] } , [string] : reverse ( [string] , escrow_address = self . wallet_address ) , [string] : { [string] : self . provider_address , [string] : self . creator_address } , [string] : [ self . provider_address , self . creator_address ] , } [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_generate_merge_transaction_success ( self , mock_builder , mock_is_match ) : [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] mock_is_match . return_value = True [EOL] [EOL] result = await build_generate_merge_transaction ( self . transaction_source_address , self . wallet_detail , self . parties_wallet ) [EOL] expect = ( [string] , [string] ) [EOL] assert result == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_build_generate_merge_transaction_creator_is_none ( self , mock_builder , mock_is_match , mock_get_creator ) : [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] mock_is_match . return_value = True [EOL] mock_get_creator . return_value = self . creator_address [EOL] self . wallet_detail [ [string] ] = { } [EOL] [EOL] result = await build_generate_merge_transaction ( self . transaction_source_address , self . wallet_detail , self . parties_wallet ) [EOL] expect = ( [string] , [string] ) [EOL] assert result == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_generate_merge_transaction_none_parties ( self , mock_builder , mock_is_match ) : [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] mock_is_match . return_value = True [EOL] [EOL] result = await build_generate_merge_transaction ( self . transaction_source_address , self . wallet_detail ) [EOL] expect = ( [string] , [string] ) [EOL] assert result == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_generate_merge_transaction_cannot_gen_xdr ( self , mock_builder , mock_is_match ) : [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr = Exception ( [string] ) [EOL] instance . te . hash_meta . return_value = [string] [EOL] mock_is_match . return_value = True [EOL] [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] await build_generate_merge_transaction ( self . transaction_source_address , self . wallet_detail , self . parties_wallet ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_merge_transaction_balance_not_match ( self , mock_is_match ) : [EOL] [EOL] mock_is_match . return_value = False [EOL] [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] await build_generate_merge_transaction ( self . transaction_source_address , self . wallet_detail , self . parties_wallet ) [EOL] [EOL] [EOL] class TestGetCreatorAddress ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_creator_address_success ( self , mock_wallet ) : [EOL] mock_wallet . return_value = [ { [string] : [string] } ] [EOL] result = await get_creator_address ( [string] ) [EOL] assert result == [string] [EOL] [EOL] [EOL] class TestGeneratePartiesWallet ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . provider_address = [string] [EOL] self . creator_address = [string] [EOL] self . wallet_detail = { [string] : reverse ( [string] , escrow_address = self . wallet_address ) , [string] : { settings [ [string] ] : [string] } , [string] : reverse ( [string] , escrow_address = self . wallet_address ) , [string] : { [string] : self . provider_address , [string] : self . creator_address } , [string] : [ self . provider_address , self . creator_address ] , } [EOL] [EOL] @ unittest_run_loop async def test_generate_parties_wallet_success ( self ) : [EOL] result = await generate_parties_wallet ( self . wallet_detail ) [EOL] expect = [ { [string] : self . provider_address , [string] : self . wallet_detail [ [string] ] [ settings [ [string] ] ] } ] [EOL] [EOL] assert isinstance ( result , List ) [EOL] assert result == expect [EOL] [EOL] [EOL] class TestIsMatchBalance ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . parties_wallet = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] [EOL] @ unittest_run_loop async def test_is_match_balance_success ( self ) : [EOL] balance = Decimal ( [string] ) [EOL] result = await is_match_balance ( self . parties_wallet , balance ) [EOL] [EOL] assert result is True [EOL] [EOL] @ unittest_run_loop async def test_is_match_balance_fail ( self ) : [EOL] balance = Decimal ( [string] ) [EOL] result = await is_match_balance ( self . parties_wallet , balance ) [EOL] [EOL] assert result is False [EOL] [EOL] [EOL] class TestBuildPaymentOperation ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . builder = Builder ( address = [string] , horizon = settings [ [string] ] ) [EOL] self . source_address = [string] [EOL] self . destination_address = [string] [EOL] [EOL] @ unittest_run_loop async def test_build_payment_operation_success ( self ) : [EOL] parties_wallet = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL] [EOL] await build_payment_operation ( self . builder , self . source_address , parties_wallet ) [EOL] operation = self . builder . ops [ - [number] ] . to_xdr_object ( ) [EOL] [EOL] assert len ( self . builder . ops ) == len ( parties_wallet ) [EOL] assert operation . type == const . PAYMENT [EOL] [EOL] @ unittest_run_loop async def test_build_payment_operation_fail ( self ) : [EOL] [EOL] parties_wallet = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL] await build_payment_operation ( self . builder , self . source_address , parties_wallet ) [EOL] [EOL] assert len ( self . builder . ops ) == [number] [EOL] assert self . builder . ops == [ ] [EOL] [EOL] [EOL] class TestBuildRemoveTrustlinesOperation ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . builder = Builder ( address = [string] , horizon = settings [ [string] ] ) [EOL] self . source_address = [string] [EOL] [EOL] @ unittest_run_loop async def test_build_remove_trustlins_operation_success ( self ) : [EOL] await build_remove_trustlines_operation ( self . builder , self . source_address ) [EOL] operation = self . builder . ops [ - [number] ] . to_xdr_object ( ) [EOL] [EOL] assert operation . type == const . CHANGE_TRUST [EOL] [EOL] [EOL] class TestBuildRemoveManageDataOperation ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . builder = Builder ( address = [string] , horizon = settings [ [string] ] ) [EOL] self . source_address = [string] [EOL] self . key_list = [ [string] , [string] , [string] ] [EOL] [EOL] @ unittest_run_loop async def test_build_remove_manage_data_operation_success ( self ) : [EOL] await build_remove_manage_data_operation ( self . builder , self . source_address , self . key_list ) [EOL] operation = self . builder . ops [ - [number] ] . to_xdr_object ( ) [EOL] [EOL] assert len ( self . builder . ops ) == len ( self . key_list ) [EOL] assert operation . type == const . MANAGE_DATA [EOL] [EOL] [EOL] class TestBuildAccountMergeOperation ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . builder = Builder ( address = [string] , horizon = settings [ [string] ] ) [EOL] self . source_address = [string] [EOL] self . destination_address = [string] [EOL] [EOL] @ unittest_run_loop async def test_build_account_merge_operation_success ( self ) : [EOL] await build_account_merge_operation ( self . builder , self . source_address , self . destination_address ) [EOL] operation = self . builder . ops [ - [number] ] . to_xdr_object ( ) [EOL] [EOL] assert operation . type == const . ACCOUNT_MERGE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from tests . test_utils import BaseTestClass [EOL] from aiohttp import web [EOL] from router import reverse [EOL] [EOL] class TestSubmitTransactionFromRequest ( BaseTestClass ) : [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_put_transaction_from_request_success ( self , mock_tx , mock_dup ) : [EOL] [EOL] mock_dup . return_value = False [EOL] mock_tx . return_value = { [string] : [number] } [EOL] url = reverse ( [string] , transaction_hash = [string] ) [EOL] resp = await self . client . request ( [string] , url , data = [string] ) [EOL] assert resp . status == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_put_transaction_from_request_with_no_xdr ( self , mock_tx , mock_dup ) : [EOL] mock_dup . return_value = False [EOL] mock_tx . return_value = { [string] : [number] } [EOL] url = reverse ( [string] , transaction_hash = [string] ) [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_put_transaction_from_request_with_duplicate_transaction ( self , mock_tx , mock_dup ) : [EOL] mock_dup . return_value = True [EOL] mock_tx . return_value = { [string] : [number] } [EOL] url = reverse ( [string] , transaction_hash = [string] ) [EOL] resp = await self . client . request ( [string] , url , data = [string] ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert [string] in text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import pytest [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from aiohttp . web_exceptions import HTTPBadRequest , HTTPInternalServerError , HTTPNotFound [EOL] from aioresponses import aioresponses [EOL] from asynctest import patch [EOL] from stellar_base . builder import Builder [EOL] from stellar_base . keypair import Keypair [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from conf import settings [EOL] from transaction . transaction import ( get_current_sequence_number , get_signers , get_threshold_weight , get_transaction_by_memo , get_transaction_hash , is_duplicate_transaction , ) [EOL] from wallet . tests . factory . wallet import StellarWallet [EOL] from stellar . wallet import Wallet [EOL] [EOL] [EOL] class TestDuplicateTransaction ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_is_duplicate_transaction_duplicate_when_id_exist ( self , mock_data ) : [EOL] mock_data . return_value = { [string] : [string] } [EOL] tx_hash = [string] [EOL] result = await is_duplicate_transaction ( tx_hash ) [EOL] assert result == True [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_is_duplicate_transaction_not_duplicate_when_get_not_found ( self , mock_data ) : [EOL] mock_data . return_value = { [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] tx_hash = [string] [EOL] result = await is_duplicate_transaction ( tx_hash ) [EOL] assert result == False [EOL] [EOL] [EOL] class TestGetTransactionHash ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . address = [string] [EOL] self . tx_hash = [string] [EOL] self . memo = [string] [EOL] self . result = { [string] : [string] } [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_hash_success ( self , mock_transaction_by_memo ) : [EOL] mock_transaction_by_memo . return_value = self . result [EOL] [EOL] result = await get_transaction_hash ( self . address , self . memo ) [EOL] assert result == self . result [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_hash_fail ( self , mock_transaction_by_memo ) : [EOL] mock_transaction_by_memo . return_value = False [EOL] [EOL] result = await get_transaction_hash ( self . address , self . memo ) [EOL] assert not result [EOL] [EOL] [EOL] class TestGetcurrentSequenceNumber ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_sequence_number_success ( self , mock_wallet ) : [EOL] instance = mock_wallet . return_value [EOL] instance . sequence = [string] [EOL] [EOL] wallet_address = [string] [EOL] result = await get_current_sequence_number ( wallet_address ) [EOL] assert isinstance ( result , str ) [EOL] assert result == [string] [EOL] [EOL] [EOL] class TestGetSigner ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_signers ( self , mock_address ) : [EOL] [EOL] signers = [ { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] mock_address . return_value = Wallet ( [string] , [string] , [string] , { } , signers , { } , { } ) [EOL] [EOL] result = await get_signers ( [string] ) [EOL] expect_result = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] [EOL] [EOL] assert result == expect_result [EOL] [EOL] [EOL] class TestGetThreshold ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_threshold_weight_low_threshold ( self , mock_address ) : [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] [EOL] result = await get_threshold_weight ( [string] , [string] ) [EOL] assert result == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_threshold_weight_med_threshold ( self , mock_address ) : [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] [EOL] result = await get_threshold_weight ( [string] , [string] ) [EOL] assert result == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_threshold_weight_high_threshold ( self , mock_address ) : [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] [EOL] result = await get_threshold_weight ( [string] , [string] ) [EOL] assert result == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_by_memo_success ( self , mock_get_transaction ) : [EOL] mock_get_transaction . return_value = [ { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] [EOL] result = await get_transaction_by_memo ( [string] , [string] ) [EOL] assert [string] in result . keys ( ) [EOL] assert [string] in result . keys ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_by_memo_not_found ( self , mock_get_transaction ) : [EOL] mock_get_transaction . return_value = [ ] [EOL] [EOL] result = await get_transaction_by_memo ( [string] , [string] ) [EOL] assert not result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import asyncio [EOL] import json [EOL] [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import make_mocked_request , unittest_run_loop [EOL] from asynctest import patch [EOL] from transaction . get_transaction import get_transaction_from_request [EOL] from transaction . transaction import get_transaction [EOL] from conf import settings [EOL] from router import reverse [EOL] [EOL] [EOL] class TestGetTransactionFromRequest ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_from_request ( self , mock_get_transaction ) : [EOL] mock_get_transaction . return_value = { } [EOL] tx_hash = [string] [EOL] resp = await self . client . request ( [string] , reverse ( [string] , transaction_hash = tx_hash ) ) [EOL] assert resp . status == [number] [EOL] mock_get_transaction . assert_called_once_with ( tx_hash ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_transaction_success ( self , mock_transaction , mock_operations ) : [EOL] mock_transaction . return_value = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] , } [EOL] [EOL] mock_operations . return_value = [ { [string] : { } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : { } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] result = await get_transaction ( [string] ) [EOL] host = settings . get ( [string] , None ) [EOL] expect_data = { [string] : [string] , [string] : f"{ host }{ reverse ( [string] , transaction_hash = [string] ) }" , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] , [string] , ] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , } [EOL] assert result == expect_data [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_not_found ( self , mock_transaction ) : [EOL] [EOL] mock_transaction . side_effect = web . HTTPNotFound ( reason = [string] ) [EOL] [EOL] with pytest . raises ( web . HTTPNotFound ) as context : [EOL] await get_transaction ( [string] ) [EOL] assert ( str ( context . value ) == [string] ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_hash_by_memo_from_reqeust_can_get_tx ( self , mock_get_transaction ) : [EOL] mock_get_transaction . return_value = { [string] : [string] } [EOL] resp = await self . client . request ( [string] , reverse ( [string] , wallet_address = [string] , memo = [string] ) ) [EOL] assert resp . status == [number] [EOL] mock_get_transaction . assert_called_once_with ( [string] , [string] ) [EOL] assert await resp . json ( ) == { [string] : [string] } [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_hash_by_memo_from_reqeust ( self , mock_get_transaction ) : [EOL] mock_get_transaction . return_value = { } [EOL] resp = await self . client . request ( [string] , reverse ( [string] , wallet_address = [string] , memo = [string] ) ) [EOL] assert resp . status == [number] [EOL] mock_get_transaction . assert_called_once_with ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch , call [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from stellar_base . transaction import Transaction [EOL] from stellar_base . transaction_envelope import TransactionEnvelope [EOL] [EOL] from conf import settings [EOL] from transaction . generate_payment import get_signers , get_threshold_weight , generate_payment , build_unsigned_transfer [EOL] from transaction . transaction import get_transaction_by_memo [EOL] from wallet . tests . factory . wallet import StellarWallet [EOL] from router import reverse [EOL] from decimal import Decimal [EOL] [EOL] [EOL] class TestGetUnsignedTransaction ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_get_transaction_from_request ( self , mock_generate_payment , mock_stellar_wallet , mock_address ) : [EOL] mock_generate_payment . return_value = { } [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] source_address = [string] [EOL] destination_address = [string] [EOL] transaction_source_address = [string] [EOL] [EOL] instance = mock_stellar_wallet . return_value [EOL] instance . sequence = [number] [EOL] [EOL] data = { [string] : destination_address , [string] : transaction_source_address , [string] : [number] , [string] : [number] , } [EOL] url = reverse ( [string] , wallet_address = source_address ) [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] mock_generate_payment . assert_called_once_with ( transaction_source_address , source_address , destination_address , [number] , [number] , None , [number] , None ) [EOL] mock_stellar_wallet . assert_called_once ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_transaction_from_request_with_invalid_target ( self , mock_generate_payment , mock_address ) : [EOL] mock_generate_payment . return_value = { } [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] source_address = [string] [EOL] destination_address = [string] [EOL] transaction_source_address = [string] [EOL] [EOL] data = { [string] : [string] , [string] : transaction_source_address , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] url = reverse ( [string] , wallet_address = source_address ) [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] mock_generate_payment . assert_not_called ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_transaction_from_request_with_invalid_memo_on ( self , mock_generate_payment , mock_address ) : [EOL] mock_generate_payment . return_value = { } [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] source_address = [string] [EOL] destination_address = [string] [EOL] transaction_source_address = [string] [EOL] [EOL] data = { [string] : [string] , [string] : transaction_source_address , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , } [EOL] url = reverse ( [string] , wallet_address = source_address ) [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] mock_generate_payment . assert_not_called ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_transaction_from_request_already_submitted ( self , mock_address , mock_transaction_by_memo ) : [EOL] balances = [ { [string] : [string] , [string] : [string] } ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] source_address = [string] [EOL] transaction_source_address = [string] [EOL] destination_address = [string] [EOL] memo = [string] [EOL] [EOL] data = { [string] : destination_address , [string] : transaction_source_address , [string] : [number] , [string] : [number] , [string] : memo , [string] : [number] , } [EOL] url = reverse ( [string] , wallet_address = source_address ) [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] mock_transaction_by_memo . assert_called_once_with ( source_address , memo ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_transaction_from_request_invalid_parameter ( self , mock_generate_payment ) : [EOL] mock_generate_payment . return_value = { } [EOL] source_address = [string] [EOL] destination_address = [string] [EOL] transaction_source_address = [string] [EOL] [EOL] data = { [string] : destination_address , [string] : [number] } [EOL] url = reverse ( [string] , wallet_address = source_address ) [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] print ( resp ) [EOL] assert resp . status == [number] [EOL] assert resp . reason == [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_transaction_from_request_account_does_not_exist ( self , mock_generate_payment , mock_address ) : [EOL] source_address = [string] [EOL] destination_address = [string] [EOL] transaction_source_address = [string] [EOL] [EOL] data = { [string] : destination_address , [string] : transaction_source_address , [string] : [number] , } [EOL] url = reverse ( [string] , wallet_address = source_address ) [EOL] [EOL] mock_address . side_effect = web . HTTPNotFound ( ) [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] assert resp . reason == [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_generate_payment ( self , mock_get_threshold_weight , mock_get_signer , mock_build ) : [EOL] mock_get_threshold_weight . return_value = [number] [EOL] mock_get_signer . return_value = [ { [string] : [string] , [string] : [number] } ] [EOL] mock_build . return_value = ( [string] , [string] ) [EOL] [EOL] result = await generate_payment ( [string] , [string] , [string] , [string] , [string] , None , None , None , ) [EOL] [EOL] expect_data = { [string] : reverse ( [string] , wallet_address = [string] ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [number] , [string] : [ { [string] : [string] , [string] : [number] } ] , [string] : [string] , [string] : [string] , } [EOL] assert result == expect_data [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_unsigned_transfer_with_memo ( self , mock_wallet , mock_builder ) : [EOL] mock_wallet . return_value = { [string] : { settings [ [string] ] : [number] } } [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] amount_hot = [number] [EOL] amount_xlm = [number] [EOL] destination_address = [string] [EOL] source_address = [string] [EOL] [EOL] result = await build_unsigned_transfer ( transaction_source_address = [string] , source_address = [string] , destination_address = destination_address , amount_hot = amount_hot , amount_xlm = amount_xlm , tax_amount_hot = [number] , sequence = [number] , memo_text = [string] , ) [EOL] mock_builder . assert_called_once ( ) [EOL] instance . gen_xdr . assert_called_once ( ) [EOL] instance . te . hash_meta . assert_called_once ( ) [EOL] instance . append_payment_op . assert_called_once_with ( destination_address , amount_hot , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source_address , ) [EOL] instance . add_text_memo . assert_called_once ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_unsigned_transfer_with_xlm_amount ( self , mock_wallet , mock_builder ) : [EOL] mock_wallet . return_value = { [string] : { } } [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] amount_hot = [number] [EOL] amount_xlm = [number] [EOL] destination_address = [string] [EOL] source_address = [string] [EOL] [EOL] result = await build_unsigned_transfer ( transaction_source_address = [string] , source_address = source_address , destination_address = destination_address , amount_hot = amount_hot , amount_xlm = amount_xlm , tax_amount_hot = [number] , sequence = [number] , memo_text = [string] , ) [EOL] [EOL] mock_builder . assert_called_once ( ) [EOL] instance . gen_xdr . assert_called_once ( ) [EOL] instance . te . hash_meta . assert_called_once ( ) [EOL] instance . append_payment_op . assert_called_once_with ( destination_address , amount_xlm , source = source_address ) [EOL] instance . add_text_memo . assert_called_once ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_unsigned_transfer_with_xlm_and_hot_amount_with_trust ( self , mock_wallet , mock_builder ) : [EOL] mock_wallet . return_value = { [string] : { settings [ [string] ] : [number] } } [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] amount_hot = [number] [EOL] amount_xlm = [number] [EOL] destination_address = [string] [EOL] source_address = [string] [EOL] [EOL] result = await build_unsigned_transfer ( transaction_source_address = [string] , source_address = source_address , destination_address = destination_address , amount_hot = amount_hot , amount_xlm = amount_xlm , tax_amount_hot = [number] , sequence = [number] , memo_text = [string] , ) [EOL] [EOL] mock_builder . assert_called_once ( ) [EOL] instance . gen_xdr . assert_called_once ( ) [EOL] instance . te . hash_meta . assert_called_once ( ) [EOL] calls = [ call . append_payment_op ( destination_address , amount_hot , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source_address , ) , call . append_payment_op ( destination_address , amount_xlm , source = source_address ) , ] [EOL] instance . assert_has_calls ( calls , any_order = True ) [EOL] instance . add_text_memo . assert_called_once ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_usigned_transfer_with_tax_amount ( self , mock_wallet , mock_builder ) : [EOL] mock_wallet . return_value = { [string] : { settings [ [string] ] : [number] } } [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] amount_hot = [number] [EOL] amount_xlm = [number] [EOL] destination_address = [string] [EOL] source_address = [string] [EOL] tax_amount_hot = [number] [EOL] [EOL] result = await build_unsigned_transfer ( transaction_source_address = [string] , source_address = source_address , destination_address = destination_address , amount_hot = amount_hot , amount_xlm = amount_xlm , tax_amount_hot = tax_amount_hot , sequence = [number] , memo_text = [string] , ) [EOL] [EOL] mock_builder . assert_called_once ( ) [EOL] instance . gen_xdr . assert_called_once ( ) [EOL] instance . te . hash_meta . assert_called_once ( ) [EOL] calls = [ call . append_payment_op ( destination_address , amount_hot , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source_address , ) , call . append_payment_op ( destination_address , amount_xlm , source = source_address ) , call . append_payment_op ( settings [ [string] ] , tax_amount_hot , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , source = source_address , ) , ] [EOL] instance . assert_has_calls ( calls , any_order = True ) [EOL] instance . add_text_memo . assert_called_once ( ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_unsigned_transfer_with_invalid_hot ( self , mock_wallet ) : [EOL] mock_wallet . return_value = { [string] : { } } [EOL] with pytest . raises ( web . HTTPBadRequest ) as context : [EOL] result = await build_unsigned_transfer ( [string] , [string] , [string] , [number] , [number] , [number] , [number] , [string] , ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_unsigned_transfer_with_target_not_created ( self , mock_wallet ) : [EOL] mock_wallet . side_effect = web . HTTPNotFound ( ) [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] result = await build_unsigned_transfer ( [string] , [string] , [string] , [number] , [number] , [number] , [number] , [string] , ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests . test_utils import BaseTestClass [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from router import reverse [EOL] [EOL] import asynctest [EOL] [EOL] [EOL] class TestGetTransactionHashFromRequest ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . address = [string] [EOL] self . transaction_url = reverse ( [string] , wallet_address = self . address ) [EOL] self . params = { [string] : [string] } [EOL] self . tx_hash = [string] [EOL] [EOL] @ unittest_run_loop @ asynctest . patch ( [string] ) async def test_get_transaction_hash_from_request_success ( self , mock_get_transaction_hash ) : [EOL] mock_get_transaction_hash . return_value = self . tx_hash [EOL] [EOL] response = await self . client . get ( self . transaction_url , params = self . params ) [EOL] resp = await response . json ( ) [EOL] assert response . status == [number] [EOL] assert resp [ [string] ] == self . tx_hash [EOL] [EOL] @ unittest_run_loop @ asynctest . patch ( [string] ) async def test_get_transacion_hash_form_request_not_found ( self , mock_get_transaction_hash ) : [EOL] mock_get_transaction_hash . return_value = None [EOL] [EOL] response = await self . client . get ( self . transaction_url , params = self . params ) [EOL] resp = await response . json ( ) [EOL] assert response . status == [number] [EOL] [EOL] @ unittest_run_loop async def test_get_transaction_hash_form_request_with_no_memo ( self ) : [EOL] response = await self . client . get ( self . transaction_url ) [EOL] assert response . status == [number] [EOL] resp = await response . json ( ) [EOL] assert [string] in resp . keys ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from conf import settings [EOL] from transaction . get_unsigned_change_trust import ( get_signers , get_threshold_weight , get_unsigned_change_trust , get_unsigned_change_trust_from_request , build_unsigned_change_trust , build_unsigned_add_trust_and_hot , ) [EOL] from wallet . tests . factory . wallet import StellarWallet [EOL] from router import reverse [EOL] from decimal import Decimal [EOL] from stellar . wallet import Wallet [EOL] [EOL] [EOL] class TestGetUnsignedChangeTrust ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_get_change_trust_from_request_success ( self , mock_get_unsigned_change_trust ) : [EOL] mock_get_unsigned_change_trust . return_value = { } [EOL] wallet_address = [string] [EOL] transaction_source_address = [string] [EOL] transaction_url = reverse ( [string] , wallet_address = wallet_address ) [EOL] params = [string] . format ( transaction_source_address ) [EOL] url = f'{ transaction_url } [string] { params }' [EOL] [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] mock_get_unsigned_change_trust . assert_called_once_with ( wallet_address , transaction_source_address ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_get_unsigned_change_trust_success ( self , mock_get_threshold_weight , mock_get_signer , mock_get_stellar_wallet ) : [EOL] mock_get_threshold_weight . return_value = [number] [EOL] mock_get_signer . return_value = [ { [string] : [string] , [string] : [number] } ] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] result = await get_unsigned_change_trust ( [string] , [string] , ) [EOL] [EOL] assert [string] in result [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_change_trust_transaction_with_wrong_parameter ( self , mock_builder ) : [EOL] instance = mock_builder . return_value [EOL] instance . append_trust_op . return_value = { } [EOL] [EOL] instance . gen_xdr = Exception ( [string] ) [EOL] [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] build_unsigned_change_trust ( [string] , [string] , ) [EOL] [EOL] [EOL] class TestGetUnsignedAddTrustAddHot ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_unsigned_add_trust_and_hot_from_request_success ( self , mock_has_wallet , mock_get_unsigned_add_trust_and_hot ) : [EOL] mock_get_unsigned_add_trust_and_hot . return_value = { } [EOL] mock_has_wallet . return_value = False [EOL] wallet_address = [string] [EOL] transaction_source_address = [string] [EOL] transaction_url = reverse ( [string] , wallet_address = wallet_address ) [EOL] hot_amount = [string] [EOL] param1 = [string] . format ( transaction_source_address ) [EOL] param2 = [string] . format ( [string] ) [EOL] params = f'{ param1 } [string] { param2 }' [EOL] url = f'{ transaction_url } [string] { params }' [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] mock_get_unsigned_add_trust_and_hot . assert_called_once_with ( wallet_address , transaction_source_address , Decimal ( hot_amount ) ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_unsigned_add_trust_and_hot_from_request_error_not_enough_parameter ( self , mock_has_wallet , mock_get_unsigned_add_trust_and_hot ) : [EOL] mock_get_unsigned_add_trust_and_hot . return_value = { } [EOL] mock_has_wallet . return_value = False [EOL] wallet_address = [string] [EOL] transaction_source_address = [string] [EOL] transaction_url = reverse ( [string] , wallet_address = wallet_address ) [EOL] hot_amount = [string] [EOL] param1 = [string] . format ( transaction_source_address ) [EOL] url = f'{ transaction_url } [string] { param1 }' [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] [EOL] param2 = [string] . format ( [string] ) [EOL] url = f'{ transaction_url } [string] { param2 }' [EOL] resp = await self . client . request ( [string] , url ) [EOL] assert resp . status == [number] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_unsigned_add_trust_and_hot ( self , mock_builder ) : [EOL] instance = mock_builder . return_value [EOL] instance . append_trust_op . return_value = { } [EOL] instance . append_payment_op . return_value = { } [EOL] [EOL] instance . gen_xdr = Exception ( [string] ) [EOL] [EOL] with pytest . raises ( web . HTTPNotFound ) : [EOL] await build_unsigned_add_trust_and_hot ( [string] , [string] , Decimal ( [number] ) , ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import aiohttp [EOL] import typing [EOL] from aiohttp import web [EOL] from transaction . generate_merge_transaction import generate_merge_transaction [EOL] from router import reverse [EOL] [EOL] async def post_close_joint_wallet_from_request ( request ) : [EOL] wallet_address = request . match_info [ [string] ] [EOL] body = await request . json ( ) [EOL] parties = body [ [string] ] [EOL] transaction_source_address = body [ [string] ] [EOL] [EOL] resp = await generate_merge_transaction ( transaction_source_address , wallet_address , parties ) [EOL] resp [ [string] ] = reverse ( [string] , wallet_address = wallet_address ) [EOL] [EOL] return web . json_response ( resp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from tests . test_utils import BaseTestClass [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from router import reverse [EOL] from conf import settings [EOL] [EOL] [EOL] class TestPostCloseJointWalletFromRequest ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . wallet_address = [string] [EOL] self . tx_hash = [string] [EOL] self . singers = [ [string] , [string] ] [EOL] self . unsigned_xdr = [string] [EOL] self . parties_wallet = { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] , [string] : [string] } [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_post_close_joint_wallet_from_request_success ( self , mock_generate_merge_transaction ) : [EOL] [EOL] mock_generate_merge_transaction . return_value = { [string] : self . wallet_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : self . singers , [string] : self . unsigned_xdr , [string] : self . tx_hash } [EOL] [EOL] expect = { [string] : reverse ( [string] , wallet_address = self . wallet_address ) , [string] : self . wallet_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : self . singers , [string] : self . unsigned_xdr , [string] : self . tx_hash } [EOL] [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , url , json = self . parties_wallet ) [EOL] [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert text == expect [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_post_close_joint_wallet_from_request_missing_param ( self , mock_generate_merge_transaction ) : [EOL] [EOL] mock_generate_merge_transaction . return_value = { [string] : self . wallet_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : self . singers , [string] : self . unsigned_xdr , [string] : self . tx_hash } [EOL] [EOL] self . missing_param_parties_wallet = { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] , } [EOL] [EOL] url = reverse ( [string] , wallet_address = self . wallet_address ) [EOL] resp = await self . client . request ( [string] , url , json = self . missing_param_parties_wallet ) [EOL] [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert text [ [string] ] == [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import patch [EOL] from conf import settings [EOL] from joint_wallet . generate_joint_wallet import ( build_joint_wallet , generate_joint_wallet ) [EOL] from router import reverse [EOL] from stellar . wallet import Wallet [EOL] [EOL] class TestGenerateJointWallet ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . host = settings [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_generate_jount_wallet_from_request ( self , mock_joint_wallet ) : [EOL] mock_joint_wallet . return_value = { } [EOL] deal_address = [string] [EOL] transaction_source_address = [string] [EOL] url = reverse ( [string] , wallet_address = deal_address ) [EOL] data = { [string] : [ { [string] : [string] , [string] : [number] } ] , [string] : [string] , [string] : [number] , [string] : transaction_source_address } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] mock_joint_wallet . assert_called_once_with ( transaction_source_address , deal_address , data [ [string] ] , data [ [string] ] , [number] , None ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_generate_joint_wallet_with_out_meta ( self , mock_build , mock_get_stellar_wallet ) : [EOL] deal_address = [string] [EOL] parties = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] [EOL] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] [EOL] creator = [string] [EOL] transaction_source_address = [string] [EOL] mock_build . return_value = ( [string] , [string] ) [EOL] result = await generate_joint_wallet ( transaction_source_address , deal_address , parties , creator , [number] ) [EOL] [EOL] expect = { [string] : reverse ( [string] , wallet_address = [string] ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] , [string] : [string] , [string] : [string] } [EOL] assert result == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_generate_joint_wallet_with_meta ( self , mock_build , mock_get_stellar_wallet ) : [EOL] deal_address = [string] [EOL] parties = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] creator = [string] [EOL] meta = { [string] : [string] } [EOL] transaction_source_address = [string] [EOL] mock_build . return_value = ( [string] , [string] ) [EOL] result = await generate_joint_wallet ( transaction_source_address , deal_address , parties , creator , [number] , meta ) [EOL] [EOL] expect = { [string] : reverse ( [string] , wallet_address = [string] ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] , [string] : [string] , [string] : [string] } [EOL] assert result == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_joint_wallet ( self , mock_builder , mock_get_stellar_wallet ) : [EOL] instance = mock_builder . return_value [EOL] instance . append_create_account_op . return_value = [string] [EOL] instance . append_trust_op . return_value = [string] [EOL] instance . append_set_options_op . return_value = [string] [EOL] instance . append_payment_op . return_value = [string] [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] transaction_source_address = [string] [EOL] deal_address = [string] [EOL] creator = [string] [EOL] parties = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] result_xdr , result_hash = await build_joint_wallet ( transaction_source_address , deal_address , parties , creator , [number] ) [EOL] assert result_xdr == [string] [EOL] assert result_hash == [string] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_build_joint_wallet_with_meta ( self , mock_builder , mock_get_stellar_wallet ) : [EOL] instance = mock_builder . return_value [EOL] instance . append_create_account_op . return_value = [string] [EOL] instance . append_trust_op . return_value = [string] [EOL] instance . append_set_options_op . return_value = [string] [EOL] instance . append_payment_op . return_value = [string] [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] transaction_source_address = [string] [EOL] deal_address = [string] [EOL] creator = [string] [EOL] parties = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] [EOL] meta = { [string] : [string] } [EOL] result_xdr , result_hash = await build_joint_wallet ( transaction_source_address , deal_address , parties , creator , [number] , meta ) [EOL] assert result_xdr == [string] [EOL] assert result_hash == [string]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.int,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.int,builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , Tuple [EOL] import typing [EOL] import aiohttp [EOL] import datetime [EOL] import builtins [EOL] import decimal [EOL] import binascii [EOL] from datetime import datetime [EOL] from decimal import ROUND_UP , Decimal , InvalidOperation [EOL] from typing import Dict , List , Tuple , Any [EOL] [EOL] from aiohttp import web [EOL] from dateutil import parser [EOL] from stellar_base . builder import Builder [EOL] from stellar_base . utils import DecodeError [EOL] [EOL] from conf import settings [EOL] from transaction . transaction import get_signers , get_threshold_weight [EOL] from router import reverse [EOL] from stellar . wallet import get_stellar_wallet [EOL] [EOL] [EOL] async def post_generate_escrow_wallet_from_request ( request ) : [EOL] [docstring] [EOL] body = await request . json ( ) [EOL] [EOL] escrow_address = request . match_info [ [string] ] [EOL] transaction_source_address = body [ [string] ] [EOL] provider_address = body [ [string] ] [EOL] creator_address = body [ [string] ] [EOL] destination_address = body [ [string] ] [EOL] starting_balance = body [ [string] ] [EOL] cost_per_transaction = body [ [string] ] [EOL] expiration_date = body . get ( [string] , None ) [EOL] [EOL] try : [EOL] int_cost = Decimal ( cost_per_transaction ) [EOL] decimal_starting_balance = Decimal ( starting_balance ) [EOL] except InvalidOperation : [EOL] raise web . HTTPBadRequest ( reason = f" [string] " ) [EOL] [EOL] if int_cost <= [number] : [EOL] raise web . HTTPBadRequest ( reason = f' [string] ' ) [EOL] [EOL] if Decimal ( starting_balance ) % Decimal ( cost_per_transaction ) != [number] : [EOL] raise web . HTTPBadRequest ( reason = f' [string] ' ) [EOL] [EOL] if expiration_date : [EOL] datetime = parser . isoparse ( expiration_date ) [comment] [EOL] [EOL] timezone_offset = datetime . utcoffset ( ) [EOL] if timezone_offset is None : [EOL] raise web . HTTPBadRequest ( reason = f' [string] ' ) [EOL] [EOL] result = await generate_escrow_wallet ( escrow_address , transaction_source_address , creator_address , destination_address , provider_address , starting_balance , cost_per_transaction , expiration_date , ) [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def generate_escrow_wallet ( escrow_address , transaction_source_address , creator_address , destination_address , provider_address , starting_balance , cost_per_transaction , expiration_date = None , ) : [EOL] [docstring] [EOL] starting_custom_asset = Decimal ( starting_balance ) [EOL] cost_per_tx_decimal = Decimal ( cost_per_transaction ) [EOL] [EOL] number_of_transaction = ( starting_custom_asset / cost_per_tx_decimal ) + [number] [EOL] starting_xlm = calculate_initial_xlm ( Decimal ( [number] ) , number_of_transaction ) [EOL] [EOL] wallet = await get_stellar_wallet ( transaction_source_address ) [EOL] xdr , tx_hash = await build_generate_escrow_wallet_transaction ( escrow_address = escrow_address , transaction_source_address = transaction_source_address , provider_address = provider_address , creator_address = creator_address , destination_address = destination_address , cost_per_transaction = cost_per_tx_decimal , expiration_date = expiration_date , starting_native_asset = starting_xlm , starting_custom_asset = starting_custom_asset , sequence = wallet . sequence , ) [EOL] [EOL] host = settings [ [string] ] [EOL] return { [string] : reverse ( [string] , escrow_address = escrow_address ) , [string] : f"{ host }{ reverse ( [string] , transaction_hash = tx_hash ) }" , [string] : [ escrow_address , creator_address , provider_address ] , [string] : xdr , [string] : tx_hash , } [EOL] [EOL] [EOL] def calculate_initial_xlm ( number_of_entries , number_of_transaction ) : [EOL] [docstring] [EOL] if number_of_entries < [number] or number_of_transaction < [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] transaction_fee = Decimal ( [string] ) [EOL] base_reserve = Decimal ( [string] ) [EOL] minumum_balance_raw = ( ( [number] + number_of_entries ) * base_reserve ) + ( number_of_transaction * transaction_fee ) [EOL] our_value = Decimal ( minumum_balance_raw ) [EOL] result = Decimal ( our_value . quantize ( Decimal ( [string] ) , rounding = ROUND_UP ) ) [EOL] return result [EOL] [EOL] [EOL] async def build_generate_escrow_wallet_transaction ( escrow_address , transaction_source_address , creator_address , destination_address , provider_address , cost_per_transaction , starting_native_asset , starting_custom_asset , expiration_date = None , sequence = None , ) : [EOL] [docstring] [EOL] [EOL] builder = Builder ( address = transaction_source_address , horizon = settings [ [string] ] , network = settings [ [string] ] , sequence = sequence , ) [EOL] builder . append_create_account_op ( source = creator_address , destination = escrow_address , starting_balance = starting_native_asset ) [EOL] [EOL] try : [EOL] builder . append_trust_op ( source = escrow_address , destination = settings [ [string] ] , code = settings [ [string] ] , limit = settings [ [string] ] , ) [EOL] except DecodeError : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] except Exception as e : [EOL] msg = str ( e ) [EOL] raise web . HTTPInternalServerError ( reason = msg ) [EOL] [EOL] builder . append_manage_data_op ( source = escrow_address , data_name = [string] , data_value = creator_address ) [EOL] builder . append_manage_data_op ( source = escrow_address , data_name = [string] , data_value = destination_address ) [EOL] builder . append_manage_data_op ( source = escrow_address , data_name = [string] , data_value = provider_address ) [EOL] [EOL] if expiration_date : [EOL] builder . append_manage_data_op ( source = escrow_address , data_name = [string] , data_value = expiration_date ) [EOL] builder . append_manage_data_op ( source = escrow_address , data_name = [string] , data_value = str ( cost_per_transaction ) ) [EOL] [EOL] builder . append_set_options_op ( source = escrow_address , signer_address = creator_address , signer_type = [string] , signer_weight = [number] ) [EOL] builder . append_set_options_op ( source = escrow_address , signer_address = provider_address , signer_type = [string] , signer_weight = [number] ) [EOL] builder . append_set_options_op ( source = escrow_address , master_weight = [number] , low_threshold = [number] , med_threshold = [number] , high_threshold = [number] ) [EOL] [EOL] builder . append_payment_op ( source = provider_address , destination = escrow_address , asset_code = settings [ [string] ] , asset_issuer = settings [ [string] ] , amount = starting_custom_asset , ) [EOL] [EOL] try : [EOL] xdr = builder . gen_xdr ( ) [EOL] except Exception as e : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] tx_hash = builder . te . hash_meta ( ) [EOL] [EOL] return xdr . decode ( ) , binascii . hexlify ( tx_hash ) . decode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import aiohttp [EOL] import typing [EOL] from aiohttp import web [EOL] [EOL] from router import reverse [EOL] from transaction . generate_merge_transaction import generate_merge_transaction [EOL] [EOL] [EOL] async def post_close_escrow_wallet_from_request ( request ) : [EOL] [docstring] [EOL] escrow_address = request . match_info [ [string] ] [EOL] body = await request . json ( ) [EOL] transaction_source_address = body [ [string] ] [EOL] [EOL] result = await generate_merge_transaction ( transaction_source_address , escrow_address ) [EOL] result [ [string] ] = reverse ( [string] , escrow_address = escrow_address ) [EOL] [EOL] return web . json_response ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] import decimal [EOL] import aiohttp [EOL] from decimal import Decimal [EOL] from json import JSONDecodeError [EOL] from typing import Dict , List [EOL] [EOL] from aiohttp import web [EOL] from conf import settings [EOL] from escrow . get_escrow_wallet import get_escrow_wallet_detail [EOL] from router import reverse [EOL] from transaction . generate_payment import build_unsigned_transfer [EOL] from transaction . transaction import ( get_current_sequence_number , get_signers , get_threshold_weight ) [EOL] [EOL] [EOL] async def get_presigned_tx_xdr_from_request ( request ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] json_response = await request . json ( ) [EOL] except JSONDecodeError : [EOL] raise web . HTTPBadRequest ( reason = [string] ) [EOL] [EOL] escrow_address = request . match_info . get ( [string] ) [EOL] transaction_source_address = json_response . get ( [string] , escrow_address ) [EOL] escrow = await get_escrow_wallet_detail ( escrow_address ) [EOL] [EOL] destination_address = escrow [ [string] ] [ [string] ] [EOL] cost_per_tx = escrow [ [string] ] [ [string] ] [EOL] balance = escrow [ [string] ] [ settings [ [string] ] ] [EOL] [EOL] result = await get_presigned_tx_xdr ( escrow_address , transaction_source_address , destination_address , Decimal ( balance ) , Decimal ( cost_per_tx ) ) [EOL] [EOL] return web . json_response ( result ) [EOL] [EOL] [EOL] async def get_presigned_tx_xdr ( escrow_address , transaction_source_address , destination_address , starting_balance , cost_per_tx ) : [EOL] [docstring] [EOL] [EOL] tx_count = int ( starting_balance / cost_per_tx ) [EOL] sequence_number = await get_current_sequence_number ( escrow_address ) [EOL] [EOL] async def _get_unsigned_transfer ( source_address , transaction_source_address , destination , amount , sequence ) : [EOL] [docstring] [EOL] [EOL] unsigned_xdr , tx_hash = await build_unsigned_transfer ( transaction_source_address , source_address , destination , amount , Decimal ( [number] ) , None , sequence = sequence ) [EOL] host = settings [ [string] ] [EOL] result = { [string] : reverse ( [string] , transaction_hash = tx_hash ) , [string] : unsigned_xdr , [string] : sequence + [number] , [string] : tx_hash } [EOL] return result [EOL] [EOL] presigneds = [ ] [EOL] for i in range ( [number] , tx_count ) : [EOL] presigneds . append ( await _get_unsigned_transfer ( escrow_address , transaction_source_address , destination_address , cost_per_tx , sequence = int ( sequence_number ) + i ) ) [EOL] [EOL] result = { [string] : await get_threshold_weight ( escrow_address , [string] ) , [string] : await get_signers ( escrow_address ) , [string] : presigneds } [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , Literal , Any , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] from decimal import Decimal [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from asynctest import Mock , patch [EOL] from stellar_base . utils import DecodeError [EOL] from tests . test_utils import BaseTestClass [EOL] from router import reverse [EOL] [EOL] from conf import settings [EOL] from escrow . post_generate_escrow_wallet import ( build_generate_escrow_wallet_transaction , calculate_initial_xlm , generate_escrow_wallet , post_generate_escrow_wallet_from_request ) [EOL] from stellar . wallet import Wallet [EOL] [EOL] class TestGetCreateEscrowWalletFromRequest ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . destination_address = [string] [EOL] self . creator_address = [string] [EOL] self . escrow_address = [string] [EOL] self . provider_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . expiration_date = [string] [EOL] self . cost_per_transaction = [string] [EOL] self . starting_balance = [string] [EOL] self . host = settings [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_post_generate_escrow_wallet_from_request_success ( self , mock_wallet ) : [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : self . starting_balance , [string] : self . cost_per_transaction } [EOL] [EOL] expect = { [string] : reverse ( [string] , escrow_address = self . escrow_address ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ self . escrow_address , self . creator_address , self . provider_address ] , [string] : [string] , [string] : [string] } [EOL] [EOL] mock_wallet . return_value = { [string] : reverse ( [string] , escrow_address = self . escrow_address ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ self . escrow_address , self . creator_address , self . provider_address ] , [string] : [string] , [string] : [string] } [EOL] [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_post_generate_escrow_wallet_from_request_success_with_expiration_date ( self , mock_wallet ) : [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : self . starting_balance , [string] : self . cost_per_transaction , [string] : self . expiration_date } [EOL] [EOL] expect = { [string] : reverse ( [string] , escrow_address = self . escrow_address ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ self . escrow_address , self . creator_address , self . provider_address ] , [string] : [string] , [string] : [string] } [EOL] [EOL] mock_wallet . return_value = { [string] : reverse ( [string] , escrow_address = self . escrow_address ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ self . escrow_address , self . creator_address , self . provider_address ] , [string] : [string] , [string] : [string] } [EOL] [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body == expect [EOL] [EOL] @ unittest_run_loop async def test_post_generate_escrow_wallet_from_request_with_plain_text_data ( self ) : [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [string] , [string] : [number] , [string] : self . expiration_date , } [EOL] [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] [EOL] resp = await self . client . request ( [string] , url , data = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] @ unittest_run_loop async def test_post_generate_escrow_wallet_from_request_missing_parameter ( self ) : [EOL] [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] [EOL] data = { [string] : self . destination_address , [string] : self . transaction_source_address , [string] : self . creator_address , [string] : self . starting_balance , [string] : [number] , [string] : self . expiration_date , } [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . creator_address , [string] : self . starting_balance , [string] : [number] , [string] : self . expiration_date , } [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . starting_balance , [string] : [number] , [string] : self . expiration_date , } [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : self . expiration_date , } [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . starting_balance , [string] : self . creator_address , [string] : self . expiration_date , } [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [string] , [string] : [number] , [string] : self . expiration_date , } [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] @ unittest_run_loop async def test_post_generate_escrow_wallet_from_request_wrong_cost_per_transaction ( self ) : [EOL] [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : [string] , [string] : self . expiration_date , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : [number] , [string] : self . expiration_date , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : - [number] , [string] : self . expiration_date , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] [EOL] @ unittest_run_loop async def test_post_generate_escrow_wallet_from_request_wrong_expiration_date ( self ) : [EOL] [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : [number] , [string] : [string] , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : [number] , [string] : [string] , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] [EOL] @ unittest_run_loop async def test_post_generate_escrow_wallet_from_request_wrong_starting_balance ( self ) : [EOL] url = reverse ( [string] , escrow_address = self . escrow_address ) [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [string] , [string] : [number] , [string] : self . expiration_date , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] data = { [string] : self . provider_address , [string] : self . transaction_source_address , [string] : self . destination_address , [string] : self . creator_address , [string] : [number] , [string] : [number] , [string] : self . expiration_date , } [EOL] [EOL] resp = await self . client . request ( [string] , url , json = data ) [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body [ [string] ] == [string] [EOL] [EOL] [EOL] class TestGetCreateWallet ( BaseTestClass ) : [EOL] [EOL] async def setUpAsync ( self ) : [EOL] self . tx_hash = [string] [EOL] self . xdr = [string] [EOL] self . destination_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . creator_address = [string] [EOL] self . escrow_address = [string] [EOL] self . provider_address = [string] [EOL] self . expiration_date = [string] [EOL] self . cost_per_transaction = [number] [EOL] self . starting_balance = [number] [EOL] self . host = settings [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_generate_escrow_wallet_success ( self , mock_build , mock_cal , mock_get_stellar_wallet ) : [EOL] [EOL] mock_build . return_value = [ [string] , [string] ] [EOL] mock_cal . return_value = [number] [EOL] mock_get_stellar_wallet . return_value = Wallet ( [string] , [ ] , [string] , { } , [ ] , { } , { } ) [EOL] expect = { [string] : reverse ( [string] , escrow_address = self . escrow_address ) , [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [ self . escrow_address , self . creator_address , self . provider_address ] , [string] : [string] , [string] : [string] } [EOL] [EOL] result = await generate_escrow_wallet ( escrow_address = self . escrow_address , transaction_source_address = self . transaction_source_address , creator_address = self . creator_address , provider_address = self . provider_address , destination_address = self . destination_address , starting_balance = self . starting_balance , expiration_date = self . expiration_date , cost_per_transaction = self . cost_per_transaction ) [EOL] [EOL] assert result == expect [EOL] number_of_transaction = [number] / [number] + [number] [EOL] mock_cal . assert_called_once_with ( [number] , number_of_transaction ) [EOL] [EOL] [EOL] class TestBuildCreateEscrowWalletTransaction ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . tx_hash = [string] [EOL] self . xdr = [string] [EOL] self . destination_address = [string] [EOL] self . creator_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . escrow_address = [string] [EOL] self . provider_address = [string] [EOL] self . expiration_date = [string] [EOL] self . cost_per_transaction = [number] [EOL] self . starting_native_asset = [number] [EOL] self . starting_custom_asset = [number] [EOL] self . host = settings [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_escrow_wallet_transaction_success ( self , mock_builder ) : [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . append_create_account_op . return_value = [string] [EOL] instance . append_trust_op . return_value = [string] [EOL] instance . append_set_options_op . return_value = [string] [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] result = await build_generate_escrow_wallet_transaction ( escrow_address = self . escrow_address , transaction_source_address = self . transaction_source_address , creator_address = self . creator_address , provider_address = self . provider_address , destination_address = self . destination_address , expiration_date = self . expiration_date , cost_per_transaction = self . cost_per_transaction , starting_native_asset = self . starting_native_asset , starting_custom_asset = self . starting_custom_asset ) [EOL] [EOL] expect = ( [string] , [string] ) [EOL] [EOL] assert result == expect [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_escrow_wallet_cannot_optain_trust_op ( self , mock_builder ) : [EOL] [EOL] def _raiseDecodeError ( source , destination , code , limit ) : [EOL] raise DecodeError ( [string] ) [EOL] [EOL] def _raiseError ( source , destination , code ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . append_create_account_op . return_value = [string] [EOL] instance . append_set_options_op . return_value = [string] [EOL] instance . gen_xdr . return_value = [string] [EOL] instance . te . hash_meta . return_value = [string] [EOL] instance . append_trust_op = _raiseDecodeError [EOL] [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] await build_generate_escrow_wallet_transaction ( escrow_address = self . escrow_address , transaction_source_address = self . transaction_source_address , creator_address = self . creator_address , provider_address = self . provider_address , destination_address = self . destination_address , expiration_date = self . expiration_date , cost_per_transaction = self . cost_per_transaction , starting_native_asset = self . starting_native_asset , starting_custom_asset = self . starting_custom_asset ) [EOL] [EOL] instance . append_trust_op = _raiseError [EOL] with pytest . raises ( web . HTTPInternalServerError ) : [EOL] await build_generate_escrow_wallet_transaction ( escrow_address = self . escrow_address , transaction_source_address = self . transaction_source_address , creator_address = self . creator_address , provider_address = self . provider_address , destination_address = self . destination_address , expiration_date = self . expiration_date , cost_per_transaction = self . cost_per_transaction , starting_native_asset = self . starting_native_asset , starting_custom_asset = self . starting_custom_asset ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_build_generate_escrow_wallet_cannot_gen_xdr ( self , mock_builder ) : [EOL] [EOL] instance = mock_builder . return_value [EOL] instance . append_create_account_op . return_value = [string] [EOL] instance . append_trust_op . return_value = [string] [EOL] instance . append_set_options_op . return_value = [string] [EOL] instance . gen_xdr = Exception ( [string] ) [EOL] instance . te . hash_meta . return_value = [string] [EOL] [EOL] with pytest . raises ( web . HTTPBadRequest ) : [EOL] await build_generate_escrow_wallet_transaction ( escrow_address = self . escrow_address , transaction_source_address = self . transaction_source_address , creator_address = self . creator_address , provider_address = self . provider_address , destination_address = self . destination_address , expiration_date = self . expiration_date , cost_per_transaction = self . cost_per_transaction , starting_native_asset = self . starting_native_asset , starting_custom_asset = self . starting_custom_asset ) [EOL] [EOL] [EOL] class TestCalculateInitialXLM ( ) : [EOL] async def test_calculate_initial_xlm_success ( self ) : [EOL] result = calculate_initial_xlm ( [number] , [number] ) [EOL] assert result == Decimal ( [string] ) [EOL] [EOL] async def test_calculate_initial_xlm_wrong_parameter ( self ) : [EOL] with pytest . raises ( ValueError ) : [EOL] calculate_initial_xlm ( - [number] , - [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import decimal [EOL] from decimal import Decimal [EOL] [EOL] from tests . test_utils import BaseTestClass [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import make_mocked_request , unittest_run_loop [EOL] from asynctest import patch [EOL] from conf import settings [EOL] from escrow . generate_pre_signed_tx_xdr import ( get_current_sequence_number , get_presigned_tx_xdr , get_presigned_tx_xdr_from_request , get_signers , get_threshold_weight ) [EOL] from router import reverse [EOL] [EOL] [EOL] class TestGeneratePreSignedTxXDR ( BaseTestClass ) : [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_presigned_tx_xdr_from_request ( self , mock_get_transaction , mock_get_wallet ) : [EOL] escrow_address = [string] [EOL] transaction_source_address = [string] [EOL] mock_get_transaction . return_value = { } [EOL] host = settings . get ( [string] , None ) [EOL] mock_get_wallet . return_value = { [string] : reverse ( [string] , escrow_address = [string] ) , [string] : { [string] : [string] , [string] : [string] } , [string] : reverse ( [string] , escrow_address = [string] ) , [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] resp = await self . client . request ( [string] , reverse ( [string] , escrow_address = escrow_address ) , json = { [string] : transaction_source_address } ) [EOL] assert resp . status == [number] [EOL] [EOL] mock_get_wallet . assert_called_once_with ( escrow_address ) [EOL] [EOL] destination_address = [string] [EOL] balance = Decimal ( [string] ) [EOL] cost_per_tx = Decimal ( [string] ) [EOL] [EOL] mock_get_transaction . assert_called_once_with ( escrow_address , transaction_source_address , destination_address , balance , cost_per_tx ) [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_presigned_tx_xdr_cannot_get_value_in_data ( self , mock_get_transaction , mock_get_wallet ) : [EOL] host = settings . get ( [string] , None ) [EOL] escrow_address = [string] [EOL] transaction_source_address = [string] [EOL] mock_get_transaction . return_value = { } [EOL] [EOL] mock_get_wallet . return_value = { [string] : reverse ( [string] , escrow_address = [string] ) , [string] : { [string] : [string] , [string] : [string] } , [string] : reverse ( [string] , escrow_address = [string] ) , [string] : { [string] : [string] } } [EOL] [EOL] resp = await self . client . request ( [string] , reverse ( [string] , escrow_address = escrow_address ) , json = { [string] : transaction_source_address } ) [EOL] [EOL] error_message = await resp . json ( ) [EOL] error_message = error_message [ [string] ] [EOL] assert error_message == [string] [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) async def test_get_presigned_tx_xdr ( self , mock_biulder , mock_sequence , mock_signer , mock_threshold ) : [EOL] mock_biulder . return_value = ( [string] , [string] ) [EOL] mock_sequence . return_value = [string] [EOL] mock_signer . return_value = [ ] [EOL] mock_threshold . return_value = [number] [EOL] result = await get_presigned_tx_xdr ( [string] , [string] , [string] , Decimal ( [string] ) , Decimal ( [string] ) ) [EOL] [EOL] expect = { [string] : [number] , [string] : [ ] , [string] : [ { [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [string] , [string] : [number] , [string] : [string] } , { [string] : reverse ( [string] , transaction_hash = [string] ) , [string] : [string] , [string] : [number] , [string] : [string] } ] } [EOL] assert result == expect [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) @ patch ( [string] ) async def test_get_presigned_tx_xdr_from_request_when_dont_have_payload ( self , mock_get_transaction , mock_get_wallet ) : [EOL] escrow_address = [string] [EOL] mock_get_transaction . return_value = { } [EOL] host = settings . get ( [string] , None ) [EOL] mock_get_wallet . return_value = { [string] : reverse ( [string] , escrow_address = [string] ) , [string] : { [string] : [string] , [string] : [string] } , [string] : reverse ( [string] , escrow_address = [string] ) , [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] resp = await self . client . request ( [string] , reverse ( [string] , escrow_address = escrow_address ) ) [EOL] assert resp . status == [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $decimal.Decimal$ 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.Dict[builtins.str,typing.Any]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.Dict[builtins.str,typing.Any]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] from tests . test_utils import BaseTestClass [EOL] from asynctest import patch [EOL] from router import reverse [EOL] from conf import settings [EOL] from decimal import Decimal [EOL] [comment] [EOL] [EOL] class TestPostCloseEscrowWalletFromRequest ( BaseTestClass ) : [EOL] async def setUpAsync ( self ) : [EOL] self . escrow_address = [string] [EOL] self . provider_address = [string] [EOL] self . creator_address = [string] [EOL] self . transaction_source_address = [string] [EOL] self . tx_hash = [string] [EOL] self . unsigned_xdr = [string] [EOL] self . host = settings [ [string] ] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_post_close_escrow_wallet_from_request_success ( self , mock_generate_claose_escrow_wallet ) : [EOL] [EOL] mock_generate_claose_escrow_wallet . return_value = { [string] : self . escrow_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : [ self . provider_address , self . creator_address ] , [string] : self . unsigned_xdr , [string] : self . tx_hash } [EOL] [EOL] expect = { [string] : reverse ( [string] , escrow_address = self . escrow_address ) , [string] : self . escrow_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : [ self . provider_address , self . creator_address ] , [string] : self . unsigned_xdr , [string] : self . tx_hash } [EOL] [EOL] json = { [string] : self . transaction_source_address } [EOL] [EOL] url = f"{ self . host }{ reverse ( [string] , escrow_address = self . escrow_address ) }" [EOL] resp = await self . client . request ( [string] , url , json = json ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert text == expect [EOL] [EOL] [EOL] @ unittest_run_loop @ patch ( [string] ) async def test_post_close_escrow_wallet_from_request_dont_have_payload ( self , mock_generate_claose_escrow_wallet ) : [EOL] [EOL] mock_generate_claose_escrow_wallet . return_value = { [string] : self . escrow_address , [string] : reverse ( [string] , transaction_hash = self . tx_hash ) , [string] : [ self . provider_address , self . creator_address ] , [string] : self . unsigned_xdr , [string] : self . tx_hash } [EOL] [EOL] url = f"{ self . host }{ reverse ( [string] , escrow_address = self . escrow_address ) }" [EOL] resp = await self . client . request ( [string] , url , json = { } ) [EOL] assert resp . status == [number] [EOL] text = await resp . json ( ) [EOL] assert text [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import asyncio [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import make_mocked_request [EOL] from asynctest import patch [EOL] from stellar_base . exceptions import AccountNotExistError , HorizonError [EOL] [EOL] from conf import settings [EOL] from escrow . get_escrow_wallet import get_escrow_wallet_detail , get_escrow_wallet_from_request [EOL] from wallet . tests . factory . wallet import StellarWallet [EOL] from wallet . wallet import get_wallet [EOL] from router import reverse [EOL] [EOL] [EOL] @ patch ( [string] ) async def test_get_escrow_wallet_from_request ( mock_get_escrow_wallet ) : [EOL] mock_get_escrow_wallet . return_value = { [string] : [string] } [EOL] wallet_address = [string] [EOL] req = make_mocked_request ( [string] , reverse ( [string] , escrow_address = wallet_address ) , match_info = { [string] : wallet_address } ) [EOL] await get_escrow_wallet_from_request ( req ) [EOL] assert mock_get_escrow_wallet . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine @ patch ( [string] ) async def test_get_escrow_wallet_success_trusted_hot ( mock_address ) : [EOL] [EOL] balances = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : settings [ [string] ] , [string] : settings [ [string] ] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : settings [ [string] ] , } , { [string] : [string] , [string] : [string] } , ] [EOL] mock_address . return_value = StellarWallet ( balances ) [EOL] instance = mock_address . return_value [EOL] instance . signers = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] [EOL] [EOL] actual_data = await get_escrow_wallet_detail ( [string] ) [EOL] host = settings . get ( [string] , None ) [EOL] expect_data = { [string] : reverse ( [string] , escrow_address = [string] ) , [string] : [string] , [string] : { settings [ [string] ] : [string] , [string] : [string] } , [string] : [string] , [string] : f"{ host }{ reverse ( [string] , escrow_address = [string] ) }" , [string] : { [string] : [string] , [string] : [string] } , [string] : [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } ] , } [EOL] assert actual_data == expect_data [EOL] [EOL] [EOL] @ asyncio . coroutine @ patch ( [string] ) async def test_get_escrow_wallet_not_found ( mock_address ) : [EOL] mock_address . side_effect = web . HTTPNotFound ( ) [EOL] [EOL] with pytest . raises ( web . HTTPNotFound ) as context : [EOL] await get_escrow_wallet_detail ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0