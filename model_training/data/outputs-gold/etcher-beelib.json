[comment] [EOL] from typing import Iterator , List , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] requirements = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] test_requirements = [ [string] , [string] , [string] , ] [EOL] [EOL] CLASSIFIERS = filter ( None , map ( str . strip , [string] . splitlines ( ) ) ) [EOL] [EOL] [EOL] def read_local_files ( * file_paths ) : [EOL] [docstring] [EOL] [EOL] def _read_single_file ( file_path ) : [EOL] with open ( file_path ) as f : [EOL] filename = os . path . splitext ( file_path ) [ [number] ] [EOL] title = f'{ filename } [string] { [string] * len ( filename ) }' [EOL] return [string] . join ( ( title , f . read ( ) ) ) [EOL] [EOL] return [string] + [string] . join ( map ( _read_single_file , file_paths ) ) [EOL] [EOL] [EOL] setup ( name = [string] , zip_safe = False , install_requires = requirements , tests_require = test_requirements , package_dir = { [string] : [string] } , package_data = { } , test_suite = [string] , packages = find_packages ( ) , python_requires = [string] , use_scm_version = True , setup_requires = [ [string] ] , license = [string] , classifiers = CLASSIFIERS , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import hashlib [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def get_hash ( data , method = [string] ) : [EOL] [docstring] [EOL] if not isinstance ( data , bytes ) : [EOL] try : [EOL] data = bytes ( data , [string] ) [EOL] except ValueError : [EOL] raise ValueError ( f' [string] { type ( data ) } [string] ' ) [EOL] [EOL] try : [EOL] func = getattr ( hashlib , method ) [EOL] except AttributeError : [EOL] raise AttributeError ( [string] . format ( method ) ) [EOL] else : [EOL] hash_ = func ( data ) . hexdigest ( ) [EOL] LOGGER . debug ( [string] , hash_ ) [EOL] [EOL] return hash_ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import inspect [EOL] import logging [EOL] import sys [EOL] import typing [EOL] [EOL] import certifi [EOL] import raven [EOL] import raven . breadcrumbs [EOL] import raven . conf [EOL] import raven . handlers . logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class SentryContext : [EOL] [docstring] [EOL] [EOL] def get_context ( self ) : [EOL] [docstring] [EOL] return { member : value for member , value in inspect . getmembers ( self , lambda a : not inspect . ismethod ( a ) ) if not member . startswith ( [string] ) } [EOL] [EOL] [EOL] class Sentry ( raven . Client ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , dsn , version , logger_name = None ) : [EOL] LOGGER . info ( [string] ) [EOL] self . registered_contexts = { } [EOL] self . _version = version [EOL] raven . Client . __init__ ( self , f'{ dsn } [string] { certifi . where ( ) }' , release = version , ) [EOL] if self . is_enabled ( ) : [EOL] LOGGER . info ( [string] ) [EOL] if logger_name : [EOL] raven . breadcrumbs . register_special_log_handler ( logger_name , filter_breadcrumbs ) [EOL] else : [EOL] LOGGER . error ( [string] ) [EOL] [EOL] def set_context ( self ) : [EOL] [docstring] [EOL] self . tags_context ( dict ( platform = sys . platform , version = self . _version , ) ) [EOL] try : [EOL] self . tags_context ( dict ( windows_version = sys . getwindowsversion ( ) ) ) [EOL] except AttributeError : [EOL] pass [EOL] [EOL] def register_context ( self , context_name , context_provider ) : [EOL] [docstring] [EOL] LOGGER . debug ( [string] , context_name ) [EOL] self . registered_contexts [ context_name ] = context_provider [EOL] [EOL] @ staticmethod def add_crumb ( message , category , level ) : [EOL] [docstring] [EOL] raven . breadcrumbs . record ( message = message , category = category , level = level ) [EOL] [EOL] def captureMessage ( self , message , ** kwargs ) : [comment] [EOL] [docstring] [EOL] self . set_context ( ) [EOL] if kwargs . get ( [string] ) is None : [EOL] kwargs [ [string] ] = { } [EOL] if kwargs [ [string] ] . get ( [string] ) is None : [EOL] kwargs [ [string] ] [ [string] ] = logging . DEBUG [EOL] for context_name , context_provider in self . registered_contexts . items ( ) : [EOL] self . extra_context ( { context_name : context_provider . get_context ( ) } ) [EOL] super ( Sentry , self ) . captureMessage ( message , ** kwargs ) [EOL] [EOL] def captureException ( self , exc_info = None , ** kwargs ) : [EOL] [docstring] [EOL] self . set_context ( ) [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] for k , context_provider in self . registered_contexts . items ( ) : [EOL] self . extra_context ( { k : context_provider . get_context ( ) } ) [EOL] super ( Sentry , self ) . captureException ( exc_info , ** kwargs ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def filter_breadcrumbs ( _logger , level , msg , * args , ** kwargs ) : [comment] [EOL] [docstring] [EOL] skip_lvl = [ ] [EOL] skip_msg = [ ] [EOL] [EOL] if level in skip_lvl or msg in skip_msg : [EOL] return False [EOL] [EOL] if _logger == [string] : [EOL] return False [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,SentryContext]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] import pprint [EOL] [EOL] [EOL] def _indent ( text , indent = [number] ) : [EOL] fstring = [string] * indent + [string] [EOL] return [string] . join ( [ fstring . format ( l ) for l in text . splitlines ( True ) ] ) [EOL] [EOL] [EOL] def pretty_format ( obj , indent = [number] ) : [EOL] [docstring] [EOL] return _indent ( pprint . pformat ( obj , width = [number] ) , indent = indent ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import ctypes [EOL] [EOL] import click [EOL] [EOL] from elib . settings import ELIBSettings [EOL] [EOL] [EOL] def set_title ( title ) : [comment] [EOL] [docstring] [EOL] ctypes . windll . kernel32 . SetConsoleTitleW ( title ) [EOL] [EOL] [EOL] def _sanitize ( input_ , prefix = True ) : [EOL] if prefix : [EOL] input_ = f' [string] { input_ }' [EOL] return input_ . encode ( [string] , [string] ) . decode ( ) [EOL] [EOL] [EOL] def _output ( txt , color , ** kwargs ) : [EOL] if not ELIBSettings . quiet : [EOL] click . secho ( txt , fg = color , ** kwargs ) [EOL] return txt [EOL] [EOL] [EOL] def info ( txt , ** kwargs ) : [EOL] [docstring] [EOL] txt = _sanitize ( txt ) [EOL] _output ( txt , ELIBSettings . color_info , ** kwargs ) [EOL] [EOL] [EOL] def error ( txt , ** kwargs ) : [EOL] [docstring] [EOL] txt = _sanitize ( txt ) [EOL] _output ( txt , ELIBSettings . color_error , err = True , ** kwargs ) [EOL] [EOL] [EOL] def cmd_start ( txt , ** kwargs ) : [EOL] [docstring] [EOL] txt = _sanitize ( txt ) [EOL] _output ( txt , ELIBSettings . color_cmd , nl = False , ** kwargs ) [EOL] [EOL] [EOL] def cmd_end ( txt , ** kwargs ) : [EOL] [docstring] [EOL] txt = _sanitize ( txt , prefix = False ) [EOL] _output ( txt , ELIBSettings . color_cmd , ** kwargs ) [EOL] [EOL] [EOL] def std_out ( txt , ** kwargs ) : [EOL] [docstring] [EOL] txt = _sanitize ( f'{ txt }' , prefix = False ) [EOL] _output ( txt , ELIBSettings . color_stdout , nl = False , ** kwargs ) [EOL] [EOL] [EOL] def std_err ( txt , ** kwargs ) : [EOL] [docstring] [EOL] txt = _sanitize ( txt , prefix = False ) [EOL] _output ( txt , ELIBSettings . color_stderr , err = True , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Optional , List , Any [EOL] import typing [EOL] import builtins [EOL] import git [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import sys [EOL] import typing [EOL] [EOL] import git [EOL] from git . exc import GitCommandError [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] class Repo : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . stashed = False [EOL] self . repo = git . Repo ( ) [EOL] [EOL] def get_current_branch ( self ) : [EOL] [docstring] [EOL] current_branch = self . repo . active_branch . name [EOL] LOGGER . debug ( [string] , current_branch ) [EOL] return current_branch [EOL] [EOL] def tag ( self , tag , overwrite = False ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , tag ) [EOL] try : [EOL] self . repo . create_tag ( tag ) [EOL] except GitCommandError as exc : [EOL] if [string] in exc . stderr and overwrite : [EOL] LOGGER . info ( [string] ) [EOL] self . remove_tag ( tag ) [EOL] self . repo . create_tag ( tag ) [EOL] else : [EOL] LOGGER . exception ( [string] ) [EOL] raise [EOL] [EOL] def list_tags ( self , pattern = None ) : [EOL] [docstring] [EOL] tags = [ str ( tag ) for tag in self . repo . tags ] [EOL] if not pattern : [EOL] LOGGER . debug ( [string] , tags ) [EOL] return tags [EOL] [EOL] LOGGER . debug ( [string] , pattern ) [EOL] filtered_tags = [ tag for tag in tags if pattern in tag ] [EOL] LOGGER . debug ( [string] , filtered_tags ) [EOL] return filtered_tags [EOL] [EOL] def remove_tag ( self , * tag ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , tag ) [EOL] [EOL] self . repo . delete_tag ( * tag ) [EOL] [EOL] def get_latest_tag ( self ) : [EOL] [docstring] [EOL] try : [EOL] latest_tag = self . repo . git . describe ( tags = True , abbrev = [number] ) [EOL] LOGGER . debug ( [string] , latest_tag ) [EOL] return latest_tag [EOL] except GitCommandError as exc : [EOL] if [string] in exc . stderr : [EOL] LOGGER . debug ( [string] ) [EOL] return None [EOL] raise [comment] [EOL] [EOL] def latest_commit ( self ) : [EOL] [docstring] [EOL] latest_commit = self . repo . head . commit [EOL] LOGGER . debug ( [string] , latest_commit ) [EOL] return latest_commit [EOL] [EOL] def is_on_tag ( self ) : [EOL] [docstring] [EOL] if self . get_current_tag ( ) : [EOL] LOGGER . debug ( [string] ) [EOL] return True [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] return False [EOL] [EOL] def get_current_tag ( self ) : [EOL] [docstring] [EOL] tags = list ( self . repo . tags ) [EOL] if not tags : [EOL] LOGGER . debug ( [string] ) [EOL] return None [EOL] for tag in tags : [EOL] LOGGER . debug ( [string] , tag ) [EOL] if tag . commit == self . latest_commit ( ) : [EOL] tag_name = tag . name [EOL] LOGGER . debug ( [string] , tag_name ) [EOL] return tag_name [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] return None [EOL] [EOL] def stash ( self , stash_name ) : [EOL] [docstring] [EOL] if self . stashed : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] else : [EOL] if not self . index_is_empty ( ) : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] if self . untracked_files ( ) : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] if self . changed_files ( ) : [EOL] LOGGER . info ( [string] ) [EOL] self . repo . git . stash ( [string] , [string] , [string] , [string] , f' [string] { stash_name } [string] ' ) [EOL] self . stashed = True [EOL] else : [EOL] LOGGER . info ( [string] ) [EOL] [EOL] def unstash ( self ) : [EOL] [docstring] [EOL] if not self . stashed : [EOL] LOGGER . error ( [string] ) [EOL] else : [EOL] LOGGER . info ( [string] ) [EOL] self . repo . git . stash ( [string] ) [EOL] self . stashed = False [EOL] [EOL] @ staticmethod def ensure ( ) : [EOL] [docstring] [EOL] LOGGER . debug ( [string] ) [EOL] if not os . path . exists ( [string] ) : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] LOGGER . debug ( [string] ) [EOL] [EOL] def last_commit_msg ( self ) : [EOL] [docstring] [EOL] last_msg = self . latest_commit ( ) . message . rstrip ( ) [EOL] LOGGER . debug ( [string] , last_msg ) [EOL] return last_msg [EOL] [EOL] def untracked_files ( self ) : [EOL] [docstring] [EOL] untracked_files = list ( self . repo . untracked_files ) [EOL] LOGGER . debug ( [string] , untracked_files ) [EOL] return untracked_files [EOL] [EOL] def status ( self ) : [EOL] [docstring] [EOL] status = self . repo . git . status ( ) [EOL] LOGGER . debug ( [string] , status ) [EOL] return status [EOL] [EOL] def list_staged_files ( self ) : [EOL] [docstring] [EOL] staged_files = [ x . a_path for x in self . repo . index . diff ( [string] ) ] [EOL] LOGGER . debug ( [string] , staged_files ) [EOL] return staged_files [EOL] [EOL] def index_is_empty ( self ) : [EOL] [docstring] [EOL] index_empty = len ( self . repo . index . diff ( self . repo . head . commit ) ) == [number] [EOL] LOGGER . debug ( [string] , index_empty ) [EOL] return index_empty [EOL] [EOL] def changed_files ( self ) : [EOL] [docstring] [EOL] changed_files = [ x . a_path for x in self . repo . index . diff ( None ) ] [EOL] LOGGER . debug ( [string] , changed_files ) [EOL] return changed_files [EOL] [EOL] def reset_index ( self ) : [EOL] [docstring] [EOL] LOGGER . warning ( [string] ) [EOL] self . repo . index . reset ( ) [EOL] [EOL] def stage_all ( self ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] ) [EOL] self . repo . git . add ( A = True ) [EOL] [EOL] def stage_modified ( self ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] ) [EOL] self . repo . git . add ( u = True ) [EOL] [EOL] def stage_subset ( self , * files_to_add ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , files_to_add ) [EOL] self . repo . git . add ( * files_to_add , A = True ) [EOL] [EOL] @ staticmethod def add_skip_ci_to_commit_msg ( message ) : [EOL] [docstring] [EOL] first_line_index = message . find ( [string] ) [EOL] if first_line_index == - [number] : [EOL] edited_message = message + [string] [EOL] else : [EOL] edited_message = message [ : first_line_index ] + [string] + message [ first_line_index : ] [EOL] LOGGER . debug ( [string] , edited_message ) [EOL] return edited_message [EOL] [EOL] @ staticmethod def _sanitize_files_to_add ( files_to_add = None ) : [EOL] [EOL] if not files_to_add : [EOL] return None [EOL] [EOL] if isinstance ( files_to_add , str ) : [EOL] return [ files_to_add ] [EOL] [EOL] return files_to_add [EOL] [EOL] def commit ( self , message , files_to_add = None , allow_empty = False , ) : [EOL] [docstring] [EOL] message = str ( message ) [EOL] LOGGER . debug ( [string] , message ) [EOL] [EOL] files_to_add = self . _sanitize_files_to_add ( files_to_add ) [EOL] LOGGER . debug ( [string] , files_to_add ) [EOL] [EOL] if not message : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] [EOL] if os . getenv ( [string] ) : [EOL] LOGGER . info ( [string] ) [EOL] message = self . add_skip_ci_to_commit_msg ( message ) [EOL] [EOL] if files_to_add is None : [EOL] self . stage_all ( ) [EOL] else : [EOL] self . reset_index ( ) [EOL] self . stage_subset ( * files_to_add ) [EOL] [EOL] if self . index_is_empty ( ) and not allow_empty : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] [EOL] self . repo . index . commit ( message = message ) [EOL] [EOL] def _sanitize_amend_commit_message ( self , append_to_msg = None , new_message = None , previous_message = None , ) : [EOL] message = None [EOL] if new_message : [EOL] message = new_message [EOL] if append_to_msg : [EOL] last_commit_msg = previous_message or self . repo . head . commit . message [EOL] last_commit_msg = last_commit_msg . rstrip ( ) [EOL] if append_to_msg not in last_commit_msg : [EOL] if [string] not in last_commit_msg : [EOL] last_commit_msg = f'{ last_commit_msg } [string] ' [EOL] message = [string] . join ( ( last_commit_msg , append_to_msg ) ) [EOL] else : [EOL] message = last_commit_msg [EOL] if message is None : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] return message [EOL] [EOL] def amend_commit ( self , append_to_msg = None , new_message = None , files_to_add = None , ) : [EOL] [docstring] [EOL] [EOL] if new_message and append_to_msg : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] [EOL] files_to_add = self . _sanitize_files_to_add ( files_to_add ) [EOL] [EOL] message = self . _sanitize_amend_commit_message ( append_to_msg , new_message ) [EOL] [EOL] if os . getenv ( [string] ) : [EOL] message = f'{ message } [string] ' [EOL] [EOL] LOGGER . info ( [string] , message ) [EOL] latest_tag = self . get_current_tag ( ) [EOL] [EOL] if latest_tag : [EOL] LOGGER . info ( [string] , latest_tag ) [EOL] self . remove_tag ( latest_tag ) [EOL] [EOL] LOGGER . info ( [string] ) [EOL] branch = self . repo . head . reference [EOL] try : [EOL] branch . commit = self . repo . head . commit . parents [ [number] ] [EOL] except IndexError : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] if files_to_add : [EOL] self . stage_subset ( * files_to_add ) [EOL] else : [EOL] self . stage_all ( ) [EOL] self . repo . index . commit ( message , skip_hooks = True ) [EOL] if latest_tag : [EOL] LOGGER . info ( [string] , latest_tag ) [EOL] self . tag ( latest_tag ) [EOL] [EOL] def merge ( self , ref_name ) : [EOL] [docstring] [EOL] if self . is_dirty ( ) : [EOL] LOGGER . error ( [string] , ref_name ) [EOL] sys . exit ( - [number] ) [EOL] LOGGER . info ( [string] , ref_name , self . get_current_branch ( ) ) [EOL] self . repo . git . merge ( ref_name ) [EOL] [EOL] def push ( self , set_upstream = True ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] ) [EOL] [EOL] try : [EOL] self . repo . git . push ( ) [EOL] except GitCommandError as error : [EOL] if [string] in error . stderr and set_upstream : [EOL] self . repo . git . push ( f' [string] { self . get_current_branch ( ) }' ) [EOL] else : [EOL] raise [EOL] self . push_tags ( ) [EOL] [EOL] def push_tags ( self ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] ) [EOL] [EOL] self . repo . git . push ( [string] ) [EOL] [EOL] def list_branches ( self ) : [EOL] [docstring] [EOL] branches = [ head . name for head in self . repo . heads ] [EOL] LOGGER . debug ( [string] , branches ) [EOL] return branches [EOL] [EOL] def get_sha ( self ) : [EOL] [docstring] [EOL] current_sha = self . repo . head . commit . hexsha [EOL] LOGGER . debug ( [string] , current_sha ) [EOL] return current_sha [EOL] [EOL] def get_short_sha ( self ) : [EOL] [docstring] [EOL] short_sha = self . get_sha ( ) [ : [number] ] [EOL] LOGGER . debug ( [string] , short_sha ) [EOL] return short_sha [EOL] [EOL] def _validate_branch_name ( self , branch_name ) : [EOL] try : [EOL] self . repo . git . check_ref_format ( [string] , branch_name ) [EOL] except git . exc . GitCommandError : [comment] [EOL] LOGGER . error ( [string] , branch_name ) [EOL] sys . exit ( - [number] ) [EOL] [EOL] def checkout ( self , reference ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , reference ) [EOL] if not self . index_is_empty ( ) : [EOL] LOGGER . error ( [string] , self . status ( ) ) [EOL] sys . exit ( - [number] ) [EOL] if self . is_dirty ( untracked = True ) : [EOL] LOGGER . error ( [string] , reference ) [EOL] LOGGER . error ( [string] , self . status ( ) ) [EOL] sys . exit ( - [number] ) [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] for head in self . repo . heads : [EOL] if head . name == reference : [EOL] LOGGER . debug ( [string] , reference ) [EOL] self . repo . head . reference = head [EOL] self . repo . head . reset ( index = True , working_tree = True ) [EOL] break [EOL] else : [EOL] LOGGER . error ( [string] , reference ) [EOL] sys . exit ( - [number] ) [EOL] [EOL] def create_branch ( self , branch_name ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , branch_name ) [EOL] self . _validate_branch_name ( branch_name ) [EOL] if branch_name in self . list_branches ( ) : [EOL] LOGGER . error ( [string] ) [EOL] sys . exit ( - [number] ) [EOL] new_branch = self . repo . create_head ( branch_name ) [EOL] new_branch . commit = self . repo . head . commit [EOL] [EOL] def create_branch_and_checkout ( self , branch_name ) : [EOL] [docstring] [EOL] self . create_branch ( branch_name ) [EOL] self . checkout ( branch_name ) [EOL] [EOL] def is_dirty ( self , untracked = False ) : [EOL] [docstring] [EOL] result = False [EOL] if not self . index_is_empty ( ) : [EOL] LOGGER . error ( [string] ) [EOL] result = True [EOL] changed_files = self . changed_files ( ) [EOL] if bool ( changed_files ) : [EOL] [EOL] LOGGER . error ( f' [string] ' , len ( changed_files ) , changed_files ) [EOL] result = True [EOL] if untracked : [EOL] result = result or bool ( self . untracked_files ( ) ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $git.Repo$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $git.Commit$ 0 0 0 0 0 0 0 $git.Commit$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $git.Commit$ 0 0 0 $git.Commit$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0
[comment] [EOL] from typing import Type , List , Dict , Any [EOL] import typing [EOL] import requests [EOL] import elib [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import json [EOL] import typing [EOL] from collections import namedtuple [EOL] [EOL] import requests [EOL] [EOL] BASE_URL = [string] [EOL] [EOL] PasteContent = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class PasteError ( requests . HTTPError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def create_new_paste ( title , files , public = False , language = [string] ) : [EOL] [docstring] [EOL] headers = { [string] : [string] , } [EOL] data = { [string] : language , [string] : title , [string] : public , [string] : [ { [string] : file . filename , [string] : file . content } for file in files ] , } [EOL] req = requests . post ( BASE_URL , json = data , headers = headers ) [EOL] if req . ok : [EOL] resp = json . loads ( req . text ) [EOL] url = resp [ [string] ] . replace ( [string] , [string] ) [EOL] return url [EOL] [EOL] raise PasteError ( f' [string] { req . reason }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[elib.paste.PasteContent]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Dict , Any [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import requests [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import time [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import certifi [EOL] import requests [EOL] import tqdm [EOL] import urllib3 [comment] [EOL] [EOL] from . hash_ import get_hash [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] REQUESTS_HEADERS = { [string] : [string] } [EOL] [EOL] [EOL] def _get_http_pool ( ) : [EOL] return urllib3 . PoolManager ( cert_reqs = str ( [string] ) , ca_certs = certifi . where ( ) ) [EOL] [EOL] [EOL] class Downloader : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url , filename , content_length = None , hexdigest = None , download_retries = [number] , block_size = [number] * [number] , hash_method = [string] , ) : [EOL] [EOL] self . url = url [EOL] self . filename = filename [EOL] self . content_length = content_length or None [EOL] self . max_download_retries = download_retries [EOL] self . block_size = block_size [EOL] self . http_pool = _get_http_pool ( ) [EOL] self . hexdigest = hexdigest [EOL] self . file_binary_data = None [EOL] [EOL] self . hash_method = hash_method [EOL] [EOL] def _write_to_file ( self ) : [EOL] [EOL] with open ( self . filename , [string] ) as outfile : [EOL] outfile . write ( self . file_binary_data ) [EOL] [EOL] def _check_hash ( self ) : [EOL] [EOL] if self . hexdigest is None : [EOL] LOGGER . debug ( [string] ) [EOL] return None [EOL] [EOL] if self . file_binary_data is None : [EOL] LOGGER . debug ( [string] ) [EOL] return False [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] LOGGER . debug ( [string] , self . hexdigest ) [EOL] [EOL] file_hash = get_hash ( self . file_binary_data , self . hash_method ) [EOL] [EOL] if file_hash . upper ( ) == self . hexdigest . upper ( ) : [EOL] LOGGER . debug ( [string] ) [EOL] return True [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] return False [EOL] [EOL] @ staticmethod def _calc_eta ( start , now , total , current ) : [comment] [EOL] [EOL] if total is None : [EOL] return [string] [EOL] [EOL] dif = now - start [EOL] if current == [number] or dif < [number] : [EOL] return [string] [EOL] [EOL] rate = float ( current ) / dif [EOL] eta = int ( ( float ( total ) - float ( current ) ) / rate ) [EOL] ( eta_mins , eta_secs ) = divmod ( eta , [number] ) [EOL] [EOL] if eta_mins > [number] : [EOL] return [string] [EOL] [EOL] return [string] % ( eta_mins , eta_secs ) [EOL] [EOL] @ staticmethod def _calc_progress_percent ( received , total ) : [comment] [EOL] [EOL] if total is None : [EOL] return [string] [EOL] [EOL] percent = float ( received ) / total * [number] [EOL] percent = [string] % percent [EOL] [EOL] return percent [EOL] [EOL] @ staticmethod def _get_content_length ( data ) : [comment] [EOL] [EOL] content_length = data . headers . get ( [string] ) [EOL] [EOL] if content_length is not None : [EOL] content_length = int ( content_length ) [EOL] [EOL] LOGGER . debug ( [string] , content_length ) [EOL] [EOL] return content_length [EOL] [EOL] @ staticmethod def _best_block_size ( time_ , chunk ) : [comment] [EOL] [EOL] new_min = max ( chunk / [number] , [number] ) [EOL] new_max = min ( max ( chunk * [number] , [number] ) , [number] ) [comment] [EOL] [EOL] if time_ < [number] : [EOL] return int ( new_max ) [EOL] [EOL] rate = chunk / time_ [EOL] [EOL] if rate > new_max : [EOL] return int ( new_max ) [EOL] [EOL] if rate < new_min : [EOL] return int ( new_min ) [EOL] [EOL] return int ( rate ) [EOL] [EOL] def _create_response ( self ) : [comment] [EOL] data = None [EOL] LOGGER . debug ( [string] , self . url ) [EOL] [EOL] try : [EOL] data = self . http_pool . urlopen ( [string] , self . url , preload_content = False , retries = self . max_download_retries , ) [EOL] [EOL] except urllib3 . exceptions . SSLError : [EOL] LOGGER . debug ( [string] ) [EOL] [EOL] except urllib3 . exceptions . MaxRetryError : [EOL] LOGGER . debug ( [string] ) [EOL] [EOL] except Exception as exc : [comment] [EOL] LOGGER . debug ( str ( exc ) , exc_info = True ) [EOL] [EOL] if data is not None : [EOL] LOGGER . debug ( [string] , self . url ) [EOL] else : [EOL] LOGGER . debug ( [string] ) [EOL] return data [EOL] [EOL] def download_to_memory ( self ) : [EOL] [docstring] [EOL] [EOL] data = self . _create_response ( ) [EOL] [EOL] if data is None : [EOL] return None [EOL] [EOL] self . content_length = self . _get_content_length ( data ) [EOL] [EOL] if self . content_length is None : [comment] [EOL] LOGGER . debug ( [string] ) [EOL] LOGGER . debug ( [string] [string] ) [EOL] [EOL] received_data = [number] [EOL] [EOL] start_download = time . time ( ) [EOL] block = data . read ( [number] ) [EOL] received_data += len ( block ) [EOL] self . file_binary_data = block [EOL] percent = self . _calc_progress_percent ( [number] , self . content_length ) [EOL] [EOL] [comment] [EOL] with tqdm . tqdm ( total = self . content_length , unit_scale = True , unit = [string] , desc = f' [string] { self . url }' ) as progress : [EOL] [EOL] current = [number] [EOL] [EOL] def _progress_hook ( data_ ) : [EOL] nonlocal current [EOL] progress . update ( data_ [ [string] ] - current ) [EOL] current = data_ [ [string] ] [EOL] [comment] [EOL] [EOL] while [number] : [EOL] [EOL] start_block = time . time ( ) [EOL] [EOL] block = data . read ( self . block_size ) [EOL] [EOL] end_block = time . time ( ) [EOL] [EOL] if not block : [EOL] break [EOL] [EOL] self . block_size = self . _best_block_size ( end_block - start_block , len ( block ) ) [EOL] [EOL] self . file_binary_data += block [EOL] [EOL] received_data += len ( block ) [EOL] [EOL] percent = self . _calc_progress_percent ( received_data , self . content_length ) [EOL] [EOL] time_left = self . _calc_eta ( start_download , time . time ( ) , self . content_length , received_data ) [EOL] [EOL] status = { [string] : self . content_length , [string] : received_data , [string] : [string] , [string] : percent , [string] : time_left } [EOL] [EOL] _progress_hook ( status ) [EOL] [EOL] status = { [string] : self . content_length , [string] : received_data , [string] : [string] , [string] : percent , [string] : [string] } [EOL] [EOL] _progress_hook ( status ) [EOL] LOGGER . debug ( [string] ) [EOL] [EOL] def download ( self ) : [EOL] [docstring] [EOL] LOGGER . debug ( [string] ) [EOL] self . download_to_memory ( ) [EOL] [EOL] check = self . _check_hash ( ) [EOL] [EOL] if check is True or check is None : [EOL] LOGGER . debug ( [string] ) [EOL] self . _write_to_file ( ) [EOL] return True [EOL] [EOL] del self . file_binary_data [EOL] if os . path . exists ( self . filename ) : [EOL] try : [EOL] os . remove ( self . filename ) [EOL] except OSError : [comment] [EOL] pass [EOL] return False [EOL] [EOL] [EOL] def download ( url , outfile , hexdigest = None , ) : [EOL] [docstring] [EOL] outfile = Path ( outfile ) . absolute ( ) [EOL] LOGGER . info ( [string] , locals ( ) ) [EOL] resp = requests . head ( url , headers = REQUESTS_HEADERS , timeout = [number] ) [EOL] if not resp . ok : [EOL] if resp . reason not in [ [string] ] : [EOL] LOGGER . error ( [string] , resp . reason ) [EOL] return False [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] [EOL] return Downloader ( url = url , filename = str ( outfile ) , hexdigest = hexdigest , ) . download ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Optional , Any [EOL] import typing [EOL] import elib [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] import traceback [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import pefile [EOL] [EOL] [EOL] def _low_word ( dword ) : [comment] [EOL] return dword & [number] [EOL] [EOL] [EOL] def _high_word ( dword ) : [comment] [EOL] return dword >> [number] [EOL] [EOL] [EOL] class VersionInfo : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file_version , full_version ) : [EOL] self . _file_version = file_version [EOL] self . _full_version = full_version [EOL] [EOL] @ property def file_version ( self ) : [EOL] [docstring] [EOL] return self . _file_version [EOL] [EOL] @ property def full_version ( self ) : [EOL] [docstring] [EOL] return self . _full_version [EOL] [EOL] def __repr__ ( self ) : [EOL] return f'{ self . __class__ . __name__ } [string] { self . file_version } [string] { self . full_version } [string] ' [EOL] [EOL] def __str__ ( self ) : [EOL] return self . file_version [EOL] [EOL] [EOL] def _parse_file_info ( file_info_list ) : [EOL] for _file_info in file_info_list : [EOL] if _file_info . Key == [string] : [comment] [EOL] for string in _file_info . StringTable : [comment] [EOL] if [string] in string . entries . keys ( ) : [comment] [EOL] file_version = string . entries [ [string] ] . decode ( [string] ) [EOL] full_version = string . entries [ [string] ] . decode ( [string] ) [EOL] return VersionInfo ( file_version , full_version ) [EOL] return None [EOL] [EOL] [EOL] def get_product_version ( path ) : [comment] [EOL] [docstring] [EOL] path = Path ( path ) . absolute ( ) [EOL] pe_info = pefile . PE ( str ( path ) ) [EOL] [EOL] try : [EOL] for file_info in pe_info . FileInfo : [comment] [EOL] if isinstance ( file_info , list ) : [EOL] result = _parse_file_info ( file_info ) [EOL] if result : [EOL] return result [EOL] else : [EOL] result = _parse_file_info ( pe_info . FileInfo ) [EOL] if result : [EOL] return result [EOL] [EOL] raise RuntimeError ( f' [string] { path }' ) [EOL] except ( KeyError , AttributeError ) as exc : [EOL] traceback . print_exc ( ) [EOL] raise RuntimeError ( f' [string] { path }' ) from exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['VersionInfo']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] import random [EOL] import string [EOL] [EOL] [EOL] def random_string ( size = [number] , chars = string . ascii_uppercase + string . digits ) : [EOL] [docstring] [EOL] return [string] . join ( random . choice ( chars ) for _ in range ( size ) ) [comment] [EOL] [EOL] [EOL] def random_bytes ( length = [number] ) : [EOL] [docstring] [EOL] return os . urandom ( length ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Any , Union , List , Iterable , Tuple [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import click [EOL] import delegator [EOL] [EOL] from elib . console import cmd_end , cmd_start , error , info , std_err , std_out [EOL] from elib . settings import ELIBSettings [EOL] [EOL] [EOL] def _append_exe ( executable ) : [EOL] if not executable . endswith ( [string] ) : [EOL] return f'{ executable } [string] ' [EOL] [EOL] return executable [EOL] [EOL] [EOL] def _set_paths ( * paths ) : [EOL] if not paths : [EOL] path = os . environ [ [string] ] [EOL] paths = ( str ( Path ( sys . exec_prefix , [string] ) . absolute ( ) ) , ) + tuple ( path . split ( os . pathsep ) ) [EOL] [EOL] return paths [EOL] [EOL] [EOL] def _search_paths ( paths , executable ) : [EOL] for path_ in paths : [EOL] executable_path = Path ( path_ , executable ) . absolute ( ) [EOL] if executable_path . is_file ( ) : [EOL] break [EOL] else : [EOL] cmd_end ( f' [string] ' ) [EOL] return None [EOL] [EOL] return executable_path [EOL] [EOL] [EOL] def find_executable ( executable , * paths ) : [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] executable = _append_exe ( executable ) [EOL] [EOL] if executable in ELIBSettings . known_executables : [comment] [EOL] return ELIBSettings . known_executables [ executable ] [comment] [EOL] [EOL] cmd_start ( f' [string] { executable }' ) [EOL] [EOL] paths = _set_paths ( * paths ) [EOL] [EOL] executable_path = Path ( executable ) [EOL] if not executable_path . is_file ( ) : [EOL] executable_path = _search_paths ( paths , executable ) [EOL] [EOL] if executable_path is None : [EOL] cmd_end ( f' [string] ' ) [EOL] return None [EOL] [EOL] ELIBSettings . known_executables [ executable ] = executable_path [EOL] cmd_end ( f' [string] { click . format_filename ( str ( executable_path ) ) }' ) [EOL] return executable_path [EOL] [EOL] [EOL] def filter_line ( line , filters ) : [EOL] [docstring] [EOL] if filters is not None : [EOL] for filter_ in filters : [EOL] if filter_ in line : [EOL] return None [EOL] return line [EOL] [EOL] [EOL] def _parse_output ( process , filters ) : [EOL] result = [ ] [EOL] for line in process . out . splitlines ( ) : [EOL] if filter_line ( line , filters ) : [EOL] result . append ( line ) [EOL] for line in process . err . splitlines ( ) : [comment] [EOL] if filter_line ( line , filters ) : [EOL] result . append ( line ) [EOL] [EOL] return [string] . join ( result ) [EOL] [EOL] [EOL] def _process_run_error ( mute , result , failure_ok , process , exe_short ) : [EOL] if mute : [EOL] cmd_end ( [string] ) [EOL] error ( f' [string] { exe_short } [string] { process . return_code }' ) [EOL] if result : [EOL] std_err ( f'{ exe_short } [string] { result }' ) [EOL] if not result . endswith ( [string] ) : [comment] [EOL] print ( ) [EOL] if not failure_ok : [EOL] exit ( process . return_code ) [EOL] [EOL] [EOL] def _process_run_success ( mute , result , process , exe_short ) : [EOL] if mute : [EOL] cmd_end ( f' [string] { process . return_code }' ) [EOL] else : [EOL] std_out ( result ) [EOL] if not result . endswith ( [string] ) : [comment] [EOL] print ( ) [EOL] info ( f'{ exe_short } [string] { process . return_code }' ) [EOL] [EOL] [EOL] def _process_run_result ( process , mute , exe_short , failure_ok , result ) : [EOL] if process . return_code : [EOL] _process_run_error ( mute = mute , result = result , failure_ok = failure_ok , process = process , exe_short = exe_short , ) [EOL] else : [EOL] _process_run_success ( mute = mute , result = result , process = process , exe_short = exe_short , ) [EOL] [EOL] return result , process . return_code [EOL] [EOL] [EOL] def _prepare_run_setup_filters ( filters ) : [EOL] if filters and isinstance ( filters , str ) : [EOL] filters = [ filters ] [EOL] [EOL] return filters [EOL] [EOL] [EOL] def _prepare_run_find_exe ( cmd , * paths ) : [EOL] exe = find_executable ( cmd . split ( [string] ) [ [number] ] , * paths ) [EOL] if not exe : [EOL] exit ( - [number] ) [EOL] return exe [EOL] [EOL] [EOL] def _prepare_run_advertise ( mute , cmd ) : [EOL] mute = mute and not ELIBSettings . verbose [EOL] [EOL] if mute : [EOL] cmd_start ( f' [string] { cmd }' ) [EOL] else : [EOL] info ( f' [string] { cmd }' ) [EOL] [EOL] [EOL] def run ( cmd , * paths , cwd = [string] , mute = False , filters = None , failure_ok = False , ) : [EOL] [docstring] [EOL] [EOL] filters = _prepare_run_setup_filters ( filters ) [EOL] [EOL] exe = _prepare_run_find_exe ( cmd , * paths ) [EOL] exe_short = exe . name [EOL] [EOL] cmd = [string] . join ( [ f' [string] { exe . absolute ( ) } [string] ' ] + cmd . split ( [string] ) [ [number] : ] ) [EOL] [EOL] _prepare_run_advertise ( mute , cmd ) [EOL] [EOL] process = delegator . run ( cmd , block = True , cwd = cwd , binary = False ) [EOL] result = _parse_output ( process , filters ) [EOL] [EOL] return _process_run_result ( process , mute , exe_short , failure_ok , result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class ELIBSettings : [EOL] [docstring] [EOL] [EOL] mute = False [EOL] quiet = False [EOL] verbose = False [EOL] known_executables = { } [EOL] [EOL] color_info = [string] [EOL] color_error = [string] [EOL] color_cmd = [string] [EOL] color_stdout = [string] [EOL] color_stderr = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Union [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] [EOL] def ensure_path ( * path , must_exist = True ) : [EOL] [docstring] [EOL] _path = Path ( * path ) . absolute ( ) [EOL] if must_exist and not _path . exists ( ) : [EOL] raise FileNotFoundError ( str ( _path ) ) [EOL] return _path . absolute ( ) [EOL] [EOL] [EOL] def ensure_file ( * file_path , must_exist = True ) : [EOL] [docstring] [EOL] _file_path = ensure_path ( * file_path , must_exist = must_exist ) [EOL] if _file_path . exists ( ) : [EOL] if not _file_path . is_file ( ) : [EOL] raise TypeError ( f' [string] { str ( _file_path . absolute ( ) ) }' ) [EOL] return _file_path [EOL] [EOL] [EOL] def ensure_dir ( * dir_path , must_exist = True , create = False ) : [EOL] [docstring] [EOL] must_exist = not create if create else must_exist [EOL] _dir_path = ensure_path ( * dir_path , must_exist = must_exist ) [EOL] if _dir_path . exists ( ) : [EOL] if not _dir_path . is_dir ( ) : [EOL] raise TypeError ( f' [string] { str ( _dir_path . absolute ( ) ) }' ) [EOL] else : [EOL] if create : [EOL] _dir_path . mkdir ( parents = True ) [EOL] return _dir_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Optional , Match , Any [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import requests [EOL] import builtins [EOL] [docstring] [EOL] import calendar [EOL] import logging [EOL] import math [EOL] import re [EOL] import time [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import gtts [EOL] import requests [EOL] from gtts_token . gtts_token import Token [EOL] [EOL] import elib . path [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def _patch_faulty_function ( self ) : [EOL] if self . token_key is not None : [EOL] return self . token_key [EOL] [EOL] timestamp = calendar . timegm ( time . gmtime ( ) ) [EOL] hours = int ( math . floor ( timestamp / [number] ) ) [EOL] [EOL] response = requests . get ( [string] ) [EOL] line = response . text . split ( [string] ) [ - [number] ] [EOL] [EOL] parsed = re . search ( [string] , line ) [EOL] tok1 , tok2 = parsed . groups ( ) [EOL] [EOL] result = str ( hours ) + [string] + str ( int ( tok1 ) + int ( tok2 ) ) [EOL] self . token_key = result [EOL] return result [EOL] [EOL] [EOL] [comment] [EOL] Token . _get_token_key = _patch_faulty_function [comment] [EOL] [EOL] [EOL] def text_to_speech ( text , file_path , overwrite = False ) : [EOL] [docstring] [EOL] LOGGER . debug ( [string] , text , file_path ) [EOL] file_path = elib . path . ensure_path ( file_path , must_exist = False ) [EOL] if file_path . exists ( ) and not overwrite : [EOL] LOGGER . error ( [string] , file_path ) [EOL] raise FileExistsError ( file_path ) [EOL] LOGGER . debug ( [string] ) [EOL] tts = gtts . gTTS ( text = text ) [EOL] LOGGER . debug ( [string] ) [EOL] tts . save ( str ( file_path ) ) [EOL] return file_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , MutableMapping , Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import collections [EOL] [docstring] [EOL] import collections [EOL] import os [EOL] import typing [EOL] [EOL] import everett [EOL] import everett . manager [EOL] import yaml [EOL] [EOL] [EOL] def update_nested_dict ( target_dict , source_dict ) : [EOL] [docstring] [EOL] if source_dict is None : [EOL] return target_dict [EOL] for key , value in source_dict . items ( ) : [EOL] if isinstance ( value , collections . MutableMapping ) : [EOL] target_dict [ key . upper ( ) ] = update_nested_dict ( target_dict . get ( key , { } ) , value ) [EOL] else : [EOL] target_dict [ key . upper ( ) ] = source_dict [ key ] [EOL] return target_dict [EOL] [EOL] [EOL] def flatten_dict ( source_dict , parent_key = [string] , sep = [string] ) : [EOL] [docstring] [EOL] items = [ ] [EOL] for key , value in source_dict . items ( ) : [EOL] new_key = parent_key + sep + key if parent_key else key [EOL] if isinstance ( value , collections . MutableMapping ) : [EOL] items . extend ( flatten_dict ( value , new_key , sep = sep ) . items ( ) ) [EOL] else : [EOL] items . append ( ( new_key , value ) ) [EOL] return dict ( items ) [EOL] [EOL] [EOL] class YAMLConfig : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , possible_paths ) : [EOL] self . cfg = { } [EOL] possible_paths = everett . manager . listify ( possible_paths ) [EOL] [EOL] for path in possible_paths : [EOL] if not path : [EOL] continue [EOL] [EOL] path = os . path . abspath ( os . path . expanduser ( path . strip ( ) ) ) [EOL] if path and os . path . isfile ( path ) : [EOL] self . cfg = update_nested_dict ( self . cfg , self . parse_yaml_file ( path ) ) [EOL] [EOL] self . cfg = flatten_dict ( self . cfg ) [EOL] [EOL] @ staticmethod def parse_yaml_file ( path ) : [EOL] [docstring] [EOL] with open ( path ) as stream : [EOL] return yaml . safe_load ( stream ) [EOL] [EOL] def get ( self , key , namespace = None ) : [EOL] [docstring] [EOL] value = everett . manager . get_key_from_envs ( self . cfg , key , namespace ) [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [docstring] [EOL] [EOL] from . config import BaseConfig [EOL] from . property import ConfigProp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from . config import BaseConfig [EOL] [EOL] [EOL] class ConfigProp : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parser , default = [string] , namespace = None ) : [EOL] [docstring] [EOL] self . default = default [EOL] self . parser = parser [EOL] self . namespace = namespace [EOL] [EOL] @ property def _name_without_namespace ( self ) : [EOL] if self . namespace is None : [EOL] return self . name [EOL] [EOL] return self . name . upper ( ) . replace ( f'{ self . namespace . upper ( ) } [string] ' , [string] ) [EOL] [EOL] def _value ( self , instance ) : [EOL] return getattr ( instance , [string] ) ( self . _name_without_namespace , default = self . default , parser = self . parser , namespace = self . namespace ) [EOL] [EOL] def _no_default ( self , instance ) : [EOL] return getattr ( instance , [string] ) ( self . _name_without_namespace , parser = self . parser , namespace = self . namespace ) [EOL] [EOL] def __get__ ( self , instance , owner = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if instance is None : [EOL] [comment] [EOL] return self [EOL] [EOL] if not isinstance ( instance , BaseConfig ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if self . default == [string] : [EOL] return self . _no_default ( instance ) [EOL] [EOL] return self . _value ( instance ) [EOL] [EOL] [comment] [EOL] def __set_name__ ( self , owner , name ) : [EOL] self . owner = owner [EOL] self . name = name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.object$ 0 $builtins.object$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 $builtins.object$ 0 0 0 $builtins.object$ 0 $builtins.object$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [EOL] import os [EOL] [EOL] import everett [EOL] import everett . manager [EOL] [EOL] from . yaml_config import YAMLConfig [EOL] [EOL] [EOL] class BaseConfig : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , package_name , default_dict = None ) : [EOL] if default_dict is None : [EOL] default_dict = { } [EOL] self . _config = everett . manager . ConfigManager ( [ everett . manager . ConfigEnvFileEnv ( [string] ) , everett . manager . ConfigOSEnv ( ) , YAMLConfig ( [ os . environ . get ( f'{ package_name . upper ( ) } [string] ' ) , os . path . join ( os . path . expanduser ( [string] ) , f'{ package_name } [string] ' ) , os . path . join ( os . path . expanduser ( [string] ) , f'{ package_name } [string] ' ) , f' [string] { package_name } [string] ' , f' [string] { package_name } [string] ' , ] ) , everett . manager . ConfigIniEnv ( [ os . environ . get ( f'{ package_name . upper ( ) } [string] ' ) , os . path . join ( os . path . expanduser ( [string] ) , f'{ package_name } [string] ' ) , f' [string] { package_name } [string] ' , ] ) , everett . manager . ConfigDictEnv ( default_dict ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0
[comment] [EOL] from typing import Union , Optional , List , Any [EOL] import elib [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import _github [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] import subprocess [comment] [EOL] import sys [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] from packaging import version [EOL] [EOL] from . _github import Release , get_latest_release [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Updater : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , repo , current_version , local_executable ) : [EOL] self . _repo = repo [EOL] self . _current_version = current_version [EOL] self . _local_executable = Path ( local_executable ) . absolute ( ) [EOL] self . _latest_release = None [EOL] [EOL] @ staticmethod def _write_bat ( local_executable ) : [EOL] LOGGER . debug ( [string] ) [EOL] update_bat = Path ( [string] ) . absolute ( ) [EOL] update_bat . write_text ( f""" [string] { local_executable . name } [string] { local_executable . name } [string] """ ) [EOL] [EOL] @ staticmethod def _write_vbs ( ) : [EOL] LOGGER . debug ( [string] ) [EOL] update_vbs = Path ( [string] ) . absolute ( ) [EOL] [comment] [EOL] update_vbs . write_text ( [string] ) [EOL] [EOL] def _install_latest_version ( self ) : [EOL] LOGGER . info ( f' [string] ' ) [EOL] [EOL] local_executable = Path ( self . _local_executable ) . absolute ( ) [EOL] LOGGER . debug ( [string] , local_executable ) [EOL] [EOL] self . _write_bat ( local_executable ) [EOL] self . _write_vbs ( ) [EOL] [EOL] LOGGER . debug ( [string] ) [EOL] args = [ [string] , [string] , [string] ] [EOL] subprocess . Popen ( args ) [comment] [EOL] [EOL] sys . exit ( [number] ) [EOL] [EOL] def _download_latest_release ( self ) : [EOL] LOGGER . debug ( [string] ) [EOL] latest_release = self . _latest_release [EOL] if latest_release : [EOL] for asset in latest_release . assets : [EOL] if asset . name . endswith ( [string] ) : [EOL] LOGGER . debug ( [string] , asset . name ) [EOL] return asset . download ( [string] ) [EOL] [EOL] LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _latest_release = get_latest_release ( self . _repo ) [EOL] if not self . _latest_release : [EOL] LOGGER . error ( [string] ) [EOL] return [EOL] LOGGER . debug ( [string] , self . _latest_release ) [EOL] latest_version = version . parse ( self . _latest_release . tag_name ) [EOL] LOGGER . debug ( [string] , latest_version ) [EOL] current_version = version . parse ( self . _current_version ) [EOL] LOGGER . debug ( [string] , current_version ) [EOL] if latest_version > current_version : [EOL] LOGGER . info ( [string] ) [EOL] if self . _download_latest_release ( ) : [EOL] self . _install_latest_version ( ) [EOL] else : [EOL] LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Union[pathlib.Path,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Union[pathlib.Path,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[_github.Release]$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[elib.updater._github.Release]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] from . _updater import Updater [EOL]	0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Dict , Any , Union , List [EOL] import elib [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import requests [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import requests [EOL] import requests . exceptions [EOL] from humanize import naturalsize [EOL] [EOL] from . . custom_random import random_string [EOL] from . . downloader import Downloader , download [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class _Val : [EOL] [EOL] def __init__ ( self ) : [EOL] self . name = None [EOL] self . owner = None [EOL] [EOL] def __get__ ( self , instance , _ ) : [EOL] if not instance : [EOL] return self [EOL] [EOL] if self . name == [string] : [EOL] return [ Asset ( asset , instance ) for asset in getattr ( instance , [string] ) [ [string] ] ] [EOL] [EOL] return getattr ( instance , [string] ) [ self . name ] [EOL] [EOL] def __set_name__ ( self , owner , name ) : [EOL] self . owner = owner [EOL] self . name = name [EOL] [EOL] [EOL] class Asset : [EOL] [docstring] [EOL] name = _Val ( ) [comment] [EOL] browser_download_url = _Val ( ) [comment] [EOL] size = _Val ( ) [comment] [EOL] state = _Val ( ) [comment] [EOL] [EOL] def __init__ ( self , json , release ) : [EOL] self . _json = json [EOL] self . _release = release [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . name } [string] { naturalsize ( self . size ) } [string] { self . state } [string] { self . browser_download_url }' [EOL] [EOL] def _get_hexdigest ( self ) : [EOL] for asset in self . _release . assets : [EOL] if asset . name == f'{ self . name } [string] ' : [EOL] hexdigest = Downloader ( asset . browser_download_url , random_string ( ) ) [EOL] hexdigest . download_to_memory ( ) [EOL] data = hexdigest . file_binary_data [EOL] if data : [EOL] return data . decode ( [string] ) . strip ( ) [EOL] [EOL] return None [EOL] [EOL] def download ( self , outfile ) : [EOL] [docstring] [EOL] hexdigest = self . _get_hexdigest ( ) [EOL] return download ( self . browser_download_url , outfile , hexdigest = hexdigest ) [EOL] [EOL] [EOL] class Release : [EOL] [docstring] [EOL] tag_name = _Val ( ) [comment] [EOL] body = _Val ( ) [comment] [EOL] assets = _Val ( ) [comment] [EOL] [EOL] def __init__ ( self , json ) : [EOL] self . _json = json [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . tag_name } [string] { len ( self . assets ) } [string] ' [EOL] [EOL] [EOL] def get_latest_release ( repo ) : [EOL] [docstring] [EOL] LOGGER . debug ( [string] , repo ) [EOL] try : [EOL] req = requests . get ( rf' [string] { repo } [string] ' , timeout = [number] ) [EOL] except requests . exceptions . Timeout : [EOL] LOGGER . exception ( [string] ) [EOL] return None [EOL] [EOL] if not req . ok : [EOL] LOGGER . error ( [string] , req . reason ) [EOL] return None [EOL] [EOL] return Release ( req . json ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 $'Release'$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 $elib.updater._github.Release$ 0 $'Release'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib.downloader.Downloader$ 0 0 0 0 0 0 0 0 0 0 0 0 $elib.downloader.Downloader$ 0 0 0 0 0 0 0 $elib.downloader.Downloader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Union[builtins.str,pathlib.Path]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,pathlib.Path]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[Asset]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Release]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import requests [EOL] from mockito import mock , verifyStubbedInvocationsAreUsed , when [EOL] [EOL] from elib import downloader [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] def test_download ( ) : [EOL] assert downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] assert Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_wrong_digest ( ) : [EOL] assert not downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] assert not Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_no_digest ( ) : [EOL] assert downloader . download ( url = URL , outfile = [string] ) [EOL] assert Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_no_data ( ) : [EOL] when ( downloader . Downloader ) . download_to_memory ( ... ) [EOL] assert not downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] assert not Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_to_memory_no_data ( ) : [EOL] when ( downloader . Downloader ) . _create_response ( ) . thenReturn ( None ) [EOL] assert not downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] assert not Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_delete_failed ( ) : [EOL] Path ( [string] ) . touch ( ) [EOL] assert Path ( [string] ) . exists ( ) [EOL] when ( downloader . Downloader ) . _create_response ( ) . thenReturn ( None ) [EOL] assert not downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] assert not Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_request_failed ( ) : [EOL] req = mock ( ) [EOL] req . ok = False [EOL] req . reason = [string] [EOL] when ( requests ) . head ( ... ) . thenReturn ( req ) [EOL] assert not downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] assert not Path ( [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_download_method_not_allowed ( ) : [EOL] req = mock ( ) [EOL] req . ok = False [EOL] req . reason = [string] [EOL] when ( requests ) . head ( ... ) . thenReturn ( req ) [EOL] when ( downloader . Downloader ) . download ( ... ) . thenReturn ( True ) [EOL] assert downloader . download ( url = URL , outfile = [string] , hexdigest = [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] assert not Path ( [string] ) . exists ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from elib . tts import text_to_speech [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_tts_correct ( ) : [EOL] file = Path ( [string] ) [EOL] assert not file . exists ( ) [EOL] text_to_speech ( [string] , file ) [EOL] assert ( file . exists ( ) ) [EOL] with pytest . raises ( FileExistsError ) : [EOL] text_to_speech ( [string] , file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] import elib . path [EOL] [EOL] [EOL] def test_path ( ) : [EOL] path_str = [string] [EOL] path_test = Path ( [string] ) [EOL] assert elib . path . ensure_path ( path_str , must_exist = False ) == elib . path . ensure_path ( path_test , must_exist = False ) [EOL] with pytest . raises ( FileNotFoundError ) : [EOL] elib . path . ensure_path ( path_str ) [EOL] with pytest . raises ( FileNotFoundError ) : [EOL] elib . path . ensure_path ( path_test ) [EOL] [EOL] [EOL] def test_dir ( ) : [EOL] test = Path ( [string] ) [EOL] assert isinstance ( elib . path . ensure_dir ( test , must_exist = False ) , Path ) [EOL] test . touch ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] elib . path . ensure_dir ( test ) [EOL] test . unlink ( ) [EOL] test . mkdir ( ) [EOL] assert isinstance ( elib . path . ensure_dir ( test ) , Path ) [EOL] [EOL] [EOL] def test_file ( ) : [EOL] test = Path ( [string] ) [EOL] assert isinstance ( elib . path . ensure_file ( test , must_exist = False ) , Path ) [EOL] test . mkdir ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] elib . path . ensure_file ( test ) [EOL] test . rmdir ( ) [EOL] test . touch ( ) [EOL] assert isinstance ( elib . path . ensure_file ( test ) , Path ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , Path ( [string] ) ] ) @ pytest . mark . parametrize ( [string] , [ [string] , Path ( [string] ) ] ) @ pytest . mark . parametrize ( [string] , [ [string] , Path ( [string] ) ] ) def test_args ( first , second , third ) : [EOL] test = elib . path . ensure_path ( first , second , third , must_exist = False ) [EOL] assert isinstance ( test , Path ) [EOL] assert test == Path ( [string] ) . absolute ( ) [EOL] [EOL] [EOL] def test_dir_create ( ) : [EOL] path = [string] [EOL] test = Path ( path ) . absolute ( ) [EOL] assert not test . exists ( ) [EOL] result = elib . path . ensure_dir ( path , must_exist = False , create = True ) [EOL] assert test . exists ( ) [EOL] assert test == result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] import elib [EOL] [EOL] [EOL] def test_get_hash_from_string ( ) : [EOL] test_string = [string] [EOL] assert elib . hash_ . get_hash ( test_string ) == [string] [EOL] assert elib . hash_ . get_hash ( test_string , [string] ) == [string] [EOL] [EOL] [EOL] def test_get_hash_from_file ( ) : [EOL] test_file = Path ( [string] ) [EOL] test_file . write_text ( [string] ) [EOL] assert elib . hash_ . get_hash ( test_file . read_bytes ( ) ) == [string] [EOL] assert elib . hash_ . get_hash ( test_file . read_bytes ( ) , [string] ) == [string] [EOL] [EOL] [EOL] def test_get_hash_wrong_method ( ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] elib . hash_ . get_hash ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from elib import exe_version [EOL] [EOL] HERE = Path ( [string] ) . absolute ( ) [EOL] [EOL] [EOL] def test_exe_version ( ) : [EOL] version = exe_version . get_product_version ( HERE . joinpath ( [string] ) ) [EOL] assert isinstance ( version , exe_version . VersionInfo ) [EOL] assert version . file_version == [string] [EOL] assert version . full_version == [string] [EOL] assert str ( version ) == [string] [EOL] [EOL] [EOL] def test_exe_no_version ( ) : [EOL] with pytest . raises ( RuntimeError ) : [EOL] exe_version . get_product_version ( HERE . joinpath ( [string] ) ) [EOL] [EOL] [EOL] def test_exe_missing_attrib ( ) : [EOL] with pytest . raises ( RuntimeError ) : [EOL] exe_version . get_product_version ( HERE . joinpath ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import string [EOL] [EOL] import delegator [EOL] import pexpect [EOL] import pytest [EOL] from hypothesis import given , strategies as st [EOL] from mockito import mock , unstub , verify , when [EOL] [EOL] import elib . run [EOL] from elib . run import filter_line [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] , autouse = True ) def _process ( ) : [EOL] process = mock ( ) [EOL] subprocess = mock ( ) [EOL] process . out = [string] [EOL] process . err = [string] [EOL] process . name = [string] [EOL] process . return_code = [number] [EOL] process . subprocess = subprocess [EOL] when ( delegator ) . run ( ... ) . thenReturn ( process ) [EOL] when ( elib . run ) . find_executable ( [string] ) . thenReturn ( process ) [EOL] when ( elib . run ) . cmd_start ( ... ) [EOL] when ( elib . run ) . cmd_end ( ... ) [EOL] when ( elib . run ) . info ( ... ) [EOL] when ( elib . run ) . error ( ... ) [EOL] when ( elib . run ) . std_out ( ... ) [EOL] when ( elib . run ) . std_err ( ... ) [EOL] yield process [EOL] [EOL] [EOL] @ given ( text = st . text ( alphabet = string . printable ) ) def test_filter_line_raw ( text ) : [EOL] assert filter_line ( text , None ) == text [EOL] [EOL] [EOL] def test_filter_line ( ) : [EOL] text = [string] [EOL] assert filter_line ( text , None ) == text [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) == text [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) is None [EOL] assert filter_line ( text , [ [string] ] ) == text [EOL] [EOL] [EOL] def test_exe_not_found ( ) : [EOL] when ( elib . run ) . find_executable ( ... ) . thenReturn ( None ) [EOL] with pytest . raises ( SystemExit ) : [EOL] elib . run . run ( [string] ) [EOL] [EOL] [EOL] def _basic_check ( output , code ) : [EOL] verify ( elib . run ) . info ( [string] ) [EOL] verify ( elib . run , times = [number] ) . cmd_start ( ... ) [EOL] verify ( elib . run , times = [number] ) . cmd_end ( ... ) [EOL] verify ( elib . run , times = [number] ) . std_err ( ... ) [EOL] verify ( elib . run ) . std_out ( output ) [EOL] verify ( elib . run , times = [number] ) . error ( ... ) [EOL] assert code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) def test_output ( process , input_ , output ) : [EOL] process . out = input_ [EOL] out , code = elib . run . run ( [string] ) [EOL] _basic_check ( out , code ) [EOL] assert out == output [EOL] [EOL] [EOL] def test_no_output ( process ) : [EOL] process . out = [string] [EOL] out , code = elib . run . run ( [string] ) [EOL] _basic_check ( out , code ) [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_filtered_output ( ) : [EOL] out , code = elib . run . run ( [string] , filters = [ [string] ] ) [EOL] _basic_check ( out , code ) [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_mute_output ( ) : [EOL] out , code = elib . run . run ( [string] , mute = True ) [EOL] verify ( elib . run , times = [number] ) . info ( ... ) [EOL] verify ( elib . run , times = [number] ) . error ( ... ) [EOL] verify ( elib . run ) . cmd_end ( [string] ) [EOL] verify ( elib . run , times = [number] ) . std_err ( ... ) [EOL] verify ( elib . run , times = [number] ) . std_out ( ... ) [EOL] assert code == [number] [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_filter_as_str ( process ) : [EOL] process . out = [string] [EOL] out , code = elib . run . run ( [string] , mute = True , filters = [string] ) [EOL] verify ( elib . run , times = [number] ) . info ( ... ) [EOL] verify ( elib . run , times = [number] ) . error ( ... ) [EOL] verify ( elib . run ) . cmd_end ( [string] ) [EOL] verify ( elib . run , times = [number] ) . std_err ( ... ) [EOL] verify ( elib . run , times = [number] ) . std_out ( ... ) [EOL] assert code == [number] [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_error ( process ) : [EOL] process . return_code = [number] [EOL] process . out = [string] [EOL] out , code = elib . run . run ( [string] , filters = [ [string] ] , failure_ok = True ) [EOL] verify ( elib . run , times = [number] ) . cmd_start ( ... ) [EOL] verify ( elib . run , times = [number] ) . cmd_end ( ... ) [EOL] verify ( elib . run ) . std_err ( [string] ) [EOL] verify ( elib . run , times = [number] ) . std_out ( ... ) [EOL] verify ( elib . run , times = [number] ) . error ( [string] ) [EOL] assert code == [number] [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_error_no_result ( process ) : [EOL] process . return_code = [number] [EOL] process . out = [string] [EOL] out , code = elib . run . run ( [string] , filters = [ [string] ] , failure_ok = True ) [EOL] verify ( elib . run , times = [number] ) . cmd_start ( ... ) [EOL] verify ( elib . run , times = [number] ) . cmd_end ( ... ) [EOL] verify ( elib . run , times = [number] ) . std_err ( ... ) [EOL] verify ( elib . run , times = [number] ) . std_out ( ... ) [EOL] verify ( elib . run ) . error ( [string] ) [EOL] assert code == [number] [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_error_muted ( process ) : [EOL] process . return_code = [number] [EOL] unstub ( process . subprocess ) [EOL] when ( process . subprocess ) . read_nonblocking ( [number] , None ) . thenReturn ( [string] ) . thenRaise ( pexpect . exceptions . EOF ( None ) ) [EOL] out , code = elib . run . run ( [string] , filters = [ [string] ] , failure_ok = True , mute = True ) [EOL] verify ( elib . run , times = [number] ) . info ( ... ) [EOL] verify ( elib . run ) . cmd_end ( [string] ) [EOL] verify ( elib . run , times = [number] ) . std_err ( ... ) [EOL] verify ( elib . run , times = [number] ) . std_out ( ... ) [EOL] verify ( elib . run ) . error ( [string] ) [EOL] assert code == [number] [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_failure ( process ) : [EOL] process . return_code = [number] [EOL] process . out = [string] [EOL] with pytest . raises ( SystemExit ) : [EOL] elib . run . run ( [string] , filters = [ [string] ] ) [EOL] verify ( elib . run , times = [number] ) . cmd_start ( ... ) [EOL] verify ( elib . run , times = [number] ) . cmd_end ( ... ) [EOL] verify ( elib . run ) . std_err ( [string] ) [EOL] verify ( elib . run , times = [number] ) . std_out ( ... ) [EOL] verify ( elib . run ) . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] import string [EOL] [EOL] import pytest [EOL] from hypothesis import given , strategies as st [EOL] [EOL] import elib . console [EOL] from elib . settings import ELIBSettings [EOL] [EOL] [EOL] @ given ( text = st . text ( ) ) def test_sanitize ( text ) : [EOL] result = elib . console . _sanitize ( text ) [EOL] assert isinstance ( result , str ) [EOL] result . encode ( [string] ) [EOL] [EOL] [EOL] @ given ( text = st . text ( alphabet = string . printable ) ) def test_info ( text , capsys ) : [EOL] elib . console . info ( text ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert out == [string] . format ( text ) [EOL] assert err == [string] [EOL] [EOL] [EOL] @ given ( text = st . text ( alphabet = string . printable ) ) def test_cmd_end ( text , capsys ) : [EOL] elib . console . cmd_end ( text ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert out == [string] . format ( text ) [EOL] assert err == [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( elib . console . info , [string] , [string] ) , ( elib . console . error , [string] , [string] ) , ( elib . console . cmd_start , [string] , [string] ) , ( elib . console . cmd_end , [string] , [string] ) , ( elib . console . std_err , [string] , [string] ) , ( elib . console . std_out , [string] , [string] ) , ] , ids = [ [string] , [string] , [string] , [string] , [string] , [string] ] ) @ given ( text = st . text ( alphabet = string . printable ) ) def test_quiet ( func , out , err , text , capsys ) : [EOL] ELIBSettings . quiet = False [EOL] func ( text ) [EOL] _out , _err = capsys . readouterr ( ) [EOL] assert _out == out . format ( text ) [EOL] assert _err == err . format ( text ) [EOL] ELIBSettings . quiet = True [EOL] func ( text ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert out == [string] [EOL] assert err == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pathlib [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from mockito import verifyStubbedInvocationsAreUsed , when [EOL] [EOL] import elib [EOL] [EOL] HERE = Path ( [string] ) . absolute ( ) [EOL] [EOL] [EOL] def test_from_dev ( ) : [EOL] assert elib . resource_path . get_resource_path ( HERE . joinpath ( [string] ) , [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_from_sys ( ) : [EOL] setattr ( sys , [string] , str ( HERE ) ) [EOL] assert elib . resource_path . get_resource_path ( [string] , [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_from_package ( ) : [EOL] when ( elib . resource_path ) . _get_from_package ( [string] , Path ( [string] ) ) . thenReturn ( Path ( HERE , [string] ) ) [EOL] assert elib . resource_path . get_resource_path ( [string] , [string] ) . exists ( ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_not_found ( ) : [EOL] with pytest . raises ( FileNotFoundError ) : [EOL] elib . resource_path . get_resource_path ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Dict , Any [EOL] import typing [EOL] import pathlib [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] import elib . run [EOL] from elib . settings import ELIBSettings [EOL] [EOL] [EOL] def test_find_executable ( ) : [EOL] python = elib . run . find_executable ( [string] ) [EOL] assert elib . run . find_executable ( [string] ) == python [EOL] assert elib . run . find_executable ( [string] , f'{ sys . prefix } [string] ' ) == python [EOL] assert elib . run . find_executable ( [string] ) is None [EOL] [EOL] [EOL] def test_context ( ) : [EOL] assert elib . run . find_executable ( [string] ) is None [EOL] ELIBSettings . known_executables [ [string] ] = [string] [EOL] assert elib . run . find_executable ( [string] ) == [string] [EOL] [EOL] [EOL] def test_paths ( ) : [EOL] assert elib . run . find_executable ( [string] ) [EOL] assert elib . run . find_executable ( [string] , [string] ) [EOL] ELIBSettings . known_executables = { } [EOL] assert elib . run . find_executable ( [string] , [string] ) is None [EOL] [EOL] [EOL] def test_immediate ( ) : [EOL] Path ( [string] ) . touch ( ) [EOL] assert elib . run . find_executable ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , Dict , Any [EOL] import typing [EOL] import elib [EOL] [EOL] [EOL] def test_pretty ( ) : [EOL] obj = { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] out = elib . pretty . pretty_format ( obj ) [EOL] print ( out ) [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_pretty_no_indent ( ) : [EOL] obj = { [string] : [string] } [EOL] out = elib . pretty . pretty_format ( obj , indent = [number] ) [EOL] assert out == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , Dict , Any [EOL] import typing [EOL] import elib [EOL] import test [EOL] import sys [EOL] [EOL] import raven [EOL] import raven . breadcrumbs [EOL] from mockito import ANY , mock , verify , verifyStubbedInvocationsAreUsed , when [EOL] [EOL] from elib . sentry import Sentry , SentryContext [EOL] [EOL] [EOL] class DummyContext ( SentryContext ) : [EOL] [docstring] [EOL] string = [string] [EOL] integer = [number] [EOL] [EOL] [EOL] def test_init ( caplog ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] assert sentry . _version == [string] [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_init_with_logger ( caplog ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] when ( raven . breadcrumbs ) . register_special_log_handler ( ANY , ANY ) [EOL] when ( raven . breadcrumbs ) . register_special_log_handler ( [string] , ANY ) [EOL] sentry = Sentry ( [string] , [string] , [string] ) [EOL] assert sentry . _version == [string] [EOL] assert [string] in caplog . text [EOL] verify ( raven . Client ) . set_dsn ( ... ) [EOL] verify ( Sentry , atleast = [number] ) . is_enabled ( ) [EOL] verify ( raven . breadcrumbs , atleast = [number] ) . register_special_log_handler ( [string] , ANY ) [EOL] [EOL] [EOL] def test_init_failed ( caplog ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( False ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] assert sentry . _version == [string] [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_add_context ( ) : [EOL] dummy_context = DummyContext ( ) [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] sentry . register_context ( [string] , dummy_context ) [EOL] assert [string] in sentry . registered_contexts [EOL] assert sentry . registered_contexts [ [string] ] is dummy_context [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_set_context ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] assert [string] not in sentry . context [EOL] sentry . set_context ( ) [EOL] assert sentry . context [ [string] ] [EOL] assert sentry . context [ [string] ] == { [string] : sys . platform , [string] : [string] , [string] : sys . getwindowsversion ( ) , } [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_set_context_missing_win_version ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] when ( sys ) . getwindowsversion ( ) . thenRaise ( AttributeError ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] assert [string] not in sentry . context [EOL] sentry . set_context ( ) [EOL] assert sentry . context [ [string] ] [EOL] assert sentry . context [ [string] ] == { [string] : sys . platform , [string] : [string] , } [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_capture_message ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] when ( raven . Client ) . capture ( [string] , message = [string] , data = { [string] : [number] } ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] sentry . captureMessage ( [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_capture_message_with_data ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] when ( raven . Client ) . capture ( [string] , message = [string] , data = { [string] : [string] , [string] : [number] , [string] : [number] } ) [EOL] data = { [string] : [string] , [string] : [number] } [EOL] sentry = Sentry ( [string] , [string] ) [EOL] sentry . captureMessage ( [string] , data = data ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_capture_message_with_level ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] when ( raven . Client ) . capture ( [string] , message = [string] , data = { [string] : [number] } ) [EOL] data = { [string] : [number] , } [EOL] sentry = Sentry ( [string] , [string] ) [EOL] sentry . captureMessage ( [string] , data = data ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_capture_message_with_context_provider ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] when ( raven . Client ) . capture ( [string] , message = [string] , data = { [string] : [number] } ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] dummy_context = DummyContext ( ) [EOL] sentry . register_context ( [string] , dummy_context ) [EOL] sentry . captureMessage ( [string] ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_capture_exception ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] exc_info = mock ( ) [EOL] when ( raven . Client ) . capture ( [string] , exc_info = exc_info ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] sentry . captureException ( exc_info ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_capture_exception_with_context_provider ( ) : [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] exc_info = mock ( ) [EOL] when ( raven . Client ) . capture ( [string] , exc_info = exc_info ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] dummy_context = DummyContext ( ) [EOL] sentry . register_context ( [string] , dummy_context ) [EOL] sentry . captureException ( exc_info ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_breadcrumbs ( ) : [EOL] message = mock ( ) [EOL] category = mock ( ) [EOL] level = mock ( ) [EOL] when ( raven . Client ) . set_dsn ( ... ) [EOL] when ( Sentry ) . is_enabled ( ) . thenReturn ( True ) [EOL] sentry = Sentry ( [string] , [string] ) [EOL] when ( raven . breadcrumbs ) . record ( message = message , category = category , level = level ) [EOL] sentry . add_crumb ( message , category , level ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Set , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from hypothesis import given , strategies as st [EOL] [EOL] from elib . custom_random import random_bytes , random_string [EOL] [EOL] [EOL] def test_random_str ( ) : [EOL] res = set ( ) [EOL] for _ in range ( [number] ) : [EOL] rand = random_string ( ) [EOL] assert len ( rand ) == [number] [EOL] assert rand not in res [EOL] res . add ( rand ) [EOL] [EOL] [EOL] def test_random_bytes ( ) : [EOL] res = set ( ) [EOL] for _ in range ( [number] ) : [EOL] rand = random_bytes ( ) [EOL] assert len ( rand ) == [number] [EOL] assert rand not in res [EOL] res . add ( rand ) [EOL] [EOL] [EOL] @ given ( length = st . integers ( min_value = [number] , max_value = [number] ) ) def test_random_string_length ( length ) : [EOL] assert len ( random_string ( length ) ) == length [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import elib [EOL] [docstring] [EOL] [EOL] import pytest [EOL] from httmock import HTTMock , all_requests , response [EOL] [EOL] from elib . paste import PasteContent , PasteError , create_new_paste [EOL] [EOL] [EOL] @ all_requests def correct_response ( * _ ) : [EOL] [docstring] [EOL] return response ( [number] , content = { [string] : [string] } ) [EOL] [EOL] [EOL] @ all_requests def bad_response ( * _ ) : [EOL] [docstring] [EOL] return response ( [number] , content = { [string] : [string] } ) [EOL] [EOL] [EOL] def test_pastebin_correct ( ) : [EOL] with HTTMock ( correct_response ) : [EOL] content = PasteContent ( [string] , [string] ) [EOL] resp = create_new_paste ( [string] , [ content ] ) [EOL] assert resp == [string] [EOL] [EOL] [EOL] def test_pastebin_bad ( ) : [EOL] with HTTMock ( bad_response ) : [EOL] content = PasteContent ( [string] , [string] ) [EOL] with pytest . raises ( PasteError ) : [EOL] create_new_paste ( [string] , [ content ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import os [EOL] import sys [EOL] [EOL] import pytest [EOL] from mockito import unstub [EOL] [EOL] [EOL] [comment] [EOL] def pytest_configure ( config ) : [EOL] [docstring] [EOL] sys . _called_from_test = True [EOL] [EOL] [EOL] [comment] [EOL] def pytest_unconfigure ( config ) : [EOL] [docstring] [EOL] [comment] [EOL] del sys . _called_from_test [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def cleandir ( request , tmpdir ) : [EOL] [docstring] [EOL] if [string] in request . keywords : [EOL] yield [EOL] else : [EOL] current_dir = os . getcwd ( ) [EOL] os . chdir ( str ( tmpdir ) ) [EOL] yield os . getcwd ( ) [EOL] os . chdir ( current_dir ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _clean_os_env ( ) : [EOL] env = os . environ . copy ( ) [EOL] yield [EOL] for key , value in env . items ( ) : [EOL] os . environ [ key ] = value [EOL] for key in os . environ . keys ( ) : [EOL] if key not in env . keys ( ) : [EOL] del os . environ [ key ] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _unstub ( ) : [EOL] unstub ( ) [EOL] yield [EOL] unstub ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _setup_logging ( ) : [EOL] import logging [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] yield [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] [docstring] [EOL] parser . addoption ( [string] , action = [string] , help = [string] ) [EOL] [EOL] [EOL] def pytest_runtest_setup ( item ) : [EOL] [docstring] [EOL] long_marker = item . get_marker ( [string] ) [EOL] if long_marker is not None and not item . config . getoption ( [string] ) : [EOL] pytest . skip ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] import git [EOL] import mimesis [EOL] import pytest [EOL] [EOL] [EOL] def _dummy_commit ( repo ) : [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] [EOL] [EOL] def test_commit ( repo ) : [EOL] Path ( [string] ) . touch ( ) [EOL] message = [string] . join ( [ mimesis . Text ( ) . sentence ( ) , mimesis . Text ( ) . text ( ) ] ) [EOL] repo . commit ( message ) [EOL] assert repo . last_commit_msg ( ) == message [EOL] [EOL] [EOL] def test_empty_commit_message ( repo ) : [EOL] Path ( [string] ) . touch ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . commit ( [string] ) [EOL] [EOL] [EOL] def test_empty_commit ( repo ) : [EOL] assert not git . Repo ( ) . index . diff ( git . Repo ( ) . head . commit ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . commit ( [string] ) [EOL] repo . commit ( [string] , allow_empty = True ) [EOL] [EOL] [EOL] def test_commit_appveyor ( repo ) : [EOL] os . environ [ [string] ] = [string] [EOL] repo . commit ( [string] , allow_empty = True ) [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] [EOL] [EOL] def test_commit_subset ( repo , file_set ) : [EOL] assert not repo . changed_files ( ) [EOL] for file_ in file_set : [EOL] assert str ( file_ ) in repo . untracked_files ( ) [EOL] [EOL] first_file = str ( file_set [ [number] ] ) [EOL] rest = file_set [ [number] : ] [EOL] repo . commit ( [string] , files_to_add = [ first_file ] ) [EOL] untracked_files = repo . untracked_files ( ) [EOL] assert untracked_files [EOL] assert first_file not in untracked_files [EOL] for other in rest : [EOL] assert str ( other ) in untracked_files [EOL] [EOL] [EOL] def test_commit_amend_new_message ( repo ) : [EOL] _dummy_commit ( repo ) [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] repo . amend_commit ( new_message = [string] ) [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] [EOL] [EOL] def test_commit_amend_append_message ( repo ) : [EOL] _dummy_commit ( repo ) [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] repo . amend_commit ( append_to_msg = [string] ) [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] repo . amend_commit ( append_to_msg = [string] ) [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] [EOL] [EOL] def test_commit_amend_with_tag ( repo ) : [EOL] _dummy_commit ( repo ) [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] repo . tag ( [string] ) [EOL] assert repo . get_current_tag ( ) == [string] [EOL] assert repo . get_latest_tag ( ) == [string] [EOL] assert repo . is_on_tag ( ) [EOL] repo . amend_commit ( new_message = [string] ) [EOL] assert repo . get_current_tag ( ) == [string] [EOL] assert repo . get_latest_tag ( ) == [string] [EOL] assert repo . is_on_tag ( ) [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] repo . amend_commit ( append_to_msg = [string] ) [EOL] [EOL] [EOL] def test_amend_commit_add_files ( repo ) : [EOL] _dummy_commit ( repo ) [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] Path ( [string] ) . touch ( ) [EOL] Path ( [string] ) . touch ( ) [EOL] assert repo . is_dirty ( untracked = True ) [EOL] assert len ( repo . untracked_files ( ) ) == [number] [EOL] repo . amend_commit ( new_message = [string] , files_to_add = [string] ) [EOL] assert repo . is_dirty ( untracked = True ) [EOL] assert len ( repo . untracked_files ( ) ) == [number] [EOL] assert [string] in repo . untracked_files ( ) [EOL] [EOL] [EOL] def test_commit_amend_root_commit ( repo ) : [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . amend_commit ( new_message = [string] ) [EOL] [EOL] [EOL] def test_commit_amend_wrong_params ( repo ) : [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . amend_commit ( new_message = [string] , append_to_msg = [string] ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . amend_commit ( ) [EOL] [EOL] [EOL] def test_commit_amend_appveyor ( repo ) : [EOL] _dummy_commit ( repo ) [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] os . environ [ [string] ] = [string] [EOL] repo . amend_commit ( new_message = [string] ) [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] assert len ( list ( repo . repo . iter_commits ( ) ) ) == [number] [EOL] [EOL] [EOL] def test__sanitize_amend_commit_message ( repo ) : [EOL] assert repo . last_commit_msg ( ) == [string] [EOL] assert repo . _sanitize_amend_commit_message ( new_message = [string] ) == [string] [EOL] assert repo . _sanitize_amend_commit_message ( append_to_msg = [string] ) == [string] [EOL] assert repo . _sanitize_amend_commit_message ( previous_message = [string] , append_to_msg = [string] ) == [string] [EOL] assert repo . _sanitize_amend_commit_message ( previous_message = [string] , append_to_msg = [string] ) == [string] [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . _sanitize_amend_commit_message ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Dict [EOL] import elib [EOL] import pathlib [EOL] import typing [EOL] import os [EOL] import io [EOL] import os [EOL] import subprocess [EOL] from pathlib import Path [EOL] [EOL] import mimesis [EOL] import pytest [EOL] [EOL] import elib [EOL] [EOL] [EOL] class _CTX : [EOL] obj = { [string] : False } [EOL] [EOL] [EOL] def pytest_collection_modifyitems ( items ) : [EOL] for item in items : [EOL] if [string] in item . nodeid : [EOL] item . add_marker ( pytest . mark . long ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def repo ( dummy_git_repo ) : [EOL] dummy_git_repo . create ( ) [EOL] _repo = elib . repo . Repo ( ) [EOL] yield _repo [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [ mimesis . File ( ) . file_name ( ) for _ in range ( [number] ) ] for _ in range ( [number] ) ] ) def file_set ( request ) : [EOL] file_set_ = list ( map ( Path , request . param ) ) [EOL] for file_ in file_set_ : [EOL] file_ . touch ( ) [EOL] yield file_set_ [EOL] [EOL] [EOL] @ pytest . fixture ( ) def dummy_git_repo ( ) : [EOL] null = open ( os . devnull , [string] ) [EOL] [EOL] def create ( ) : [EOL] subprocess . check_call ( ( [string] , [string] ) , stdout = null ) [EOL] Path ( [string] ) . touch ( ) [EOL] subprocess . check_call ( ( [string] , [string] , [string] ) , stdout = null ) [EOL] subprocess . check_call ( ( [string] , [string] , [string] , [string] ) , stdout = null ) [EOL] [EOL] dummy_git_repo . create = create [EOL] [EOL] yield dummy_git_repo [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _global_tear_down ( tmpdir ) : [EOL] [docstring] [EOL] environ = dict ( os . environ ) [EOL] try : [EOL] del os . environ [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] current_dir = os . getcwd ( ) [EOL] folder = Path ( tmpdir ) . absolute ( ) [EOL] os . chdir ( folder ) [EOL] yield [EOL] os . chdir ( current_dir ) [EOL] os . environ = environ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] def test_stage_all ( repo , file_set ) : [EOL] for file_ in file_set : [EOL] assert file_ . name in repo . untracked_files ( ) [EOL] repo . stage_all ( ) [EOL] assert not repo . untracked_files ( ) [EOL] for file_ in file_set : [EOL] assert file_ . name in repo . list_staged_files ( ) [EOL] [EOL] [EOL] def test_stage_subset ( repo , file_set ) : [EOL] for file_ in file_set : [EOL] assert file_ . name in repo . untracked_files ( ) [EOL] repo . stage_subset ( file_set [ : [number] ] ) [EOL] assert repo . untracked_files ( ) [EOL] for file_ in file_set [ : [number] ] : [EOL] assert file_ . name in repo . list_staged_files ( ) [EOL] for file_ in file_set [ [number] : ] : [EOL] assert file_ . name not in repo . list_staged_files ( ) [EOL] [EOL] [EOL] def test_stage_updated ( repo , file_set ) : [EOL] for file in file_set : [EOL] assert file . name in repo . untracked_files ( ) [EOL] repo . stage_subset ( file_set [ : [number] ] ) [EOL] repo . repo . index . commit ( message = [string] ) [EOL] for file in file_set [ [number] : ] : [EOL] assert file . name not in repo . list_staged_files ( ) [EOL] assert file . name in repo . untracked_files ( ) [EOL] file_set [ [number] ] . write_text ( [string] ) [EOL] repo . stage_modified ( ) [EOL] assert repo . list_staged_files ( ) == [ file_set [ [number] ] . name ] [EOL] [EOL] [EOL] def test__sanitize_files_to_add ( repo ) : [EOL] assert repo . _sanitize_files_to_add ( [ ] ) is None [EOL] assert repo . _sanitize_files_to_add ( [string] ) == [ [string] ] [EOL] assert repo . _sanitize_files_to_add ( [ [string] ] ) == [ [string] ] [EOL] assert repo . _sanitize_files_to_add ( [ [string] , [string] ] ) == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def test_checkout ( repo ) : [EOL] repo . checkout ( [string] ) [EOL] assert repo . get_current_branch ( ) == [string] [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . checkout ( [string] ) [EOL] repo . create_branch ( [string] ) [EOL] repo . checkout ( [string] ) [EOL] assert repo . get_current_branch ( ) == [string] [EOL] [EOL] [EOL] def test_checkout_dirty ( repo ) : [EOL] repo . create_branch_and_checkout ( [string] ) [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] Path ( [string] ) . write_text ( [string] ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . checkout ( [string] ) [EOL] assert repo . index_is_empty ( ) [EOL] repo . stage_all ( ) [EOL] assert not repo . index_is_empty ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . checkout ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def test_stash ( repo , caplog ) : [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] Path ( [string] ) . write_text ( [string] ) [EOL] assert [string] in repo . changed_files ( ) [EOL] repo . stash ( [string] ) [EOL] assert [string] in caplog . text [EOL] assert not repo . changed_files ( ) [EOL] [EOL] [EOL] def test_unstash ( repo , caplog ) : [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] Path ( [string] ) . write_text ( [string] ) [EOL] assert [string] in repo . changed_files ( ) [EOL] repo . stash ( [string] ) [EOL] assert [string] in caplog . text [EOL] assert not repo . changed_files ( ) [EOL] repo . unstash ( ) [EOL] assert [string] in caplog . text [EOL] assert [string] in repo . changed_files ( ) [EOL] [EOL] [EOL] def test_unstash_no_stash ( repo , caplog ) : [EOL] repo . unstash ( ) [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_stash_no_changes ( repo , caplog ) : [EOL] repo . stash ( [string] ) [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_stash_untracked_files ( repo , caplog ) : [EOL] Path ( [string] ) . touch ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . stash ( [string] ) [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_stash_modified_index ( repo , caplog ) : [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] Path ( [string] ) . write_text ( [string] ) [EOL] repo . stage_all ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . stash ( [string] ) [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_already_stashed ( repo , caplog ) : [EOL] repo . stashed = True [EOL] with pytest . raises ( SystemExit ) : [EOL] repo . stash ( [string] ) [EOL] assert [string] in caplog . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from git . exc import GitCommandError [EOL] [EOL] [EOL] def test_tag ( repo ) : [EOL] assert repo . get_latest_tag ( ) is None [EOL] assert not repo . is_on_tag ( ) [EOL] repo . tag ( [string] ) [EOL] assert repo . get_latest_tag ( ) == [string] [EOL] assert repo . is_on_tag ( ) [EOL] repo . remove_tag ( [string] ) [EOL] assert repo . get_latest_tag ( ) is None [EOL] assert not repo . is_on_tag ( ) [EOL] [EOL] [EOL] def test_get_current_tag ( repo ) : [EOL] assert repo . get_current_tag ( ) is None [EOL] repo . tag ( [string] ) [EOL] assert repo . get_current_tag ( ) == [string] [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] assert repo . get_current_tag ( ) is None [EOL] [EOL] [EOL] def test_existing_tag ( repo ) : [EOL] repo . tag ( [string] ) [EOL] Path ( [string] ) . touch ( ) [EOL] repo . commit ( [string] ) [EOL] assert repo . get_current_tag ( ) is None [EOL] with pytest . raises ( GitCommandError ) : [EOL] repo . tag ( [string] ) [EOL] repo . tag ( [string] , overwrite = True ) [EOL] assert repo . get_current_tag ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , List , Dict [EOL] import typing [EOL] import elib [EOL] import pathlib [EOL] import subprocess [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from mockito import verifyStubbedInvocationsAreUsed , when [EOL] [EOL] from elib . updater import _github as github , _updater as updater [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _release ( ) : [EOL] json = { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } , ] } [EOL] yield updater . Release ( json ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def clean_up ( ) : [EOL] yield [EOL] bat = Path ( [string] ) . absolute ( ) [EOL] vbs = Path ( [string] ) . absolute ( ) [EOL] for path in ( bat , vbs ) : [EOL] if path . exists ( ) : [EOL] path . unlink ( ) [EOL] [EOL] [EOL] def test_updater ( release ) : [EOL] repo = [string] [EOL] current_version = [string] [EOL] exe = Path ( [string] ) [EOL] upd = updater . Updater ( repo , current_version , exe ) [EOL] when ( updater ) . get_latest_release ( repo ) . thenReturn ( release ) [EOL] [comment] [EOL] when ( github . Asset ) . download ( ... ) . thenReturn ( True ) [EOL] when ( subprocess ) . Popen ( ... ) [EOL] with pytest . raises ( SystemExit ) : [EOL] upd . update ( ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_updater_no_asset ( release , caplog ) : [EOL] release . _json [ [string] ] = [ ] [EOL] repo = [string] [EOL] current_version = [string] [EOL] exe = Path ( [string] ) [EOL] upd = updater . Updater ( repo , current_version , exe ) [EOL] when ( updater ) . get_latest_release ( repo ) . thenReturn ( release ) [EOL] upd . update ( ) [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_updater_up_to_date ( release , caplog ) : [EOL] repo = [string] [EOL] current_version = [string] [EOL] exe = Path ( [string] ) [EOL] upd = updater . Updater ( repo , current_version , exe ) [EOL] when ( updater ) . get_latest_release ( repo ) . thenReturn ( release ) [EOL] upd . update ( ) [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_updater_no_release ( caplog ) : [EOL] repo = [string] [EOL] current_version = [string] [EOL] exe = Path ( [string] ) [EOL] upd = updater . Updater ( repo , current_version , exe ) [EOL] when ( updater ) . get_latest_release ( repo ) . thenReturn ( None ) [EOL] upd . update ( ) [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any [EOL] import typing [EOL] import elib [EOL] import pathlib [EOL] import copy [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] import requests [EOL] from mockito import mock , verifyStubbedInvocationsAreUsed , when [EOL] [EOL] from elib . updater import _github as github [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_asset ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_release ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [ ] } [EOL] [EOL] [EOL] def test_val ( dummy_release ) : [EOL] release = github . Release ( dummy_release ) [EOL] assert release . assets == [ ] [EOL] assert isinstance ( github . Release . assets , github . _Val ) [EOL] [EOL] [EOL] def test_asset ( dummy_asset , dummy_release ) : [EOL] release = github . Release ( dummy_release ) [EOL] asset = github . Asset ( dummy_asset , release ) [EOL] for attrib in [ [string] , [string] , [string] , [string] ] : [EOL] assert getattr ( asset , attrib ) == dummy_asset [ attrib ] [EOL] [EOL] [EOL] def test_asset_download ( dummy_asset , dummy_release ) : [EOL] release = github . Release ( dummy_release ) [EOL] asset1 = github . Asset ( copy . copy ( dummy_asset ) , release ) [EOL] asset2 = github . Asset ( copy . copy ( dummy_asset ) , release ) [EOL] release . _json [ [string] ] = [ asset1 , asset2 ] [EOL] asset1 . _json [ [string] ] = [string] [EOL] asset2 . _json [ [string] ] = [string] [EOL] outfile = Path ( [string] ) . absolute ( ) [EOL] when ( github . Asset ) . _get_hexdigest ( ) . thenReturn ( [string] ) [EOL] when ( github ) . download ( [string] , outfile , hexdigest = [string] ) . thenReturn ( True ) [EOL] assert asset1 . download ( outfile ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_get_hexdigest ( dummy_release , dummy_asset ) : [EOL] release = github . Release ( copy . copy ( dummy_release ) ) [EOL] asset1 = github . Asset ( copy . copy ( dummy_asset ) , release ) [EOL] asset2 = github . Asset ( copy . copy ( dummy_asset ) , release ) [EOL] asset1 . _json [ [string] ] = [string] [EOL] asset2 . _json [ [string] ] = [string] [EOL] release . _json [ [string] ] = [ asset1 . _json , asset2 . _json ] [EOL] outfile = Path ( [string] ) . absolute ( ) [EOL] downloader = mock ( ) [EOL] when ( downloader ) . download_to_memory ( ) [EOL] downloader . file_binary_data = [string] . encode ( [string] ) [EOL] when ( github ) . Downloader ( ... ) . thenReturn ( downloader ) [EOL] when ( github ) . download ( [string] , outfile , hexdigest = [string] ) . thenReturn ( True ) [EOL] assert asset1 . download ( outfile ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_get_hexdigest_no_md5 ( dummy_release , dummy_asset ) : [EOL] release = github . Release ( copy . copy ( dummy_release ) ) [EOL] asset1 = github . Asset ( copy . copy ( dummy_asset ) , release ) [EOL] asset1 . _json [ [string] ] = [string] [EOL] release . _json [ [string] ] = [ asset1 . _json ] [EOL] outfile = Path ( [string] ) . absolute ( ) [EOL] when ( github ) . download ( [string] , outfile , hexdigest = None ) . thenReturn ( True ) [EOL] assert asset1 . download ( outfile ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_get_latest_release ( dummy_release ) : [EOL] repo = [string] [EOL] req = mock ( spec = requests . Request ) [EOL] req . ok = True [EOL] when ( req ) . json ( ) . thenReturn ( dummy_release ) [EOL] when ( requests ) . get ( rf' [string] { repo } [string] ' , timeout = [number] ) . thenReturn ( req ) [EOL] release = github . get_latest_release ( repo ) [EOL] assert isinstance ( release , github . Release ) [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_get_latest_release_req_timeout ( caplog ) : [EOL] repo = [string] [EOL] when ( requests ) . get ( rf' [string] { repo } [string] ' , timeout = [number] ) . thenRaise ( requests . exceptions . Timeout ) [EOL] assert github . get_latest_release ( repo ) is None [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] [EOL] [EOL] def test_get_latest_release_req_failed ( caplog ) : [EOL] repo = [string] [EOL] req = mock ( spec = requests . Request ) [EOL] req . ok = False [EOL] req . reason = [string] [EOL] when ( requests ) . get ( rf' [string] { repo } [string] ' , timeout = [number] ) . thenReturn ( req ) [EOL] assert github . get_latest_release ( repo ) is None [EOL] assert [string] in caplog . text [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_yaml_config_file ( dummy_config , ext ) : [EOL] with open ( f' [string] { ext }' , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . debug is True [EOL] assert cfg . string == [string] [EOL] assert cfg . integer is [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_yaml_list_of_str ( dummy_config , ext ) : [EOL] with open ( f' [string] { ext }' , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . some_list == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_yaml_list_of_int ( dummy_config , ext ) : [EOL] with open ( f' [string] { ext }' , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . some_list == [ [number] , - [number] , [number] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_yaml_namespace ( dummy_config , ext ) : [EOL] with open ( f' [string] { ext }' , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . namespace_key == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import elib [EOL] import test [EOL] from pathlib import Path [EOL] [EOL] import everett [EOL] import pytest [EOL] [EOL] from elib . config import ConfigProp [EOL] [EOL] [EOL] class WrongBaseClass : [EOL] [docstring] [EOL] string = ConfigProp ( str , [string] ) [EOL] [EOL] [EOL] def test_create_config ( dummy_config ) : [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . debug is False [EOL] assert not cfg . string [EOL] assert cfg . integer is [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_default_dict ( dummy_config , key ) : [EOL] cfg = dummy_config ( [string] , { key : [string] , [string] : [string] , [string] : [number] } ) [EOL] assert cfg . debug is True [EOL] assert cfg . string == [string] [EOL] assert cfg . integer is [number] [EOL] [EOL] [EOL] def test_no_default ( dummy_config ) : [EOL] cfg = dummy_config ( [string] ) [EOL] with pytest . raises ( everett . ConfigurationMissingError ) : [EOL] assert cfg . no_default == [string] [EOL] [EOL] [EOL] def test_wrong_base_class ( ) : [EOL] test = WrongBaseClass ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] print ( test . string ) [EOL] [EOL] [EOL] def test_calling_from_instance ( dummy_config ) : [EOL] assert isinstance ( dummy_config ( ) . integer , ConfigProp ) [EOL] [EOL] [EOL] def test_empty_config_file ( dummy_config ) : [EOL] Path ( [string] ) . touch ( ) [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . debug is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def test_env_config ( dummy_config ) : [EOL] with open ( f' [string] ' , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] cfg = dummy_config ( [string] ) [EOL] print ( cfg . _config ) [EOL] assert cfg . debug is True [EOL] assert cfg . string == [string] [EOL] assert cfg . integer is [number] [EOL] assert cfg . namespace_key == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib [EOL] import pytest [EOL] [EOL] from elib . config import BaseConfig , ConfigProp [EOL] [EOL] [EOL] class DummyConfig ( BaseConfig ) : [EOL] [docstring] [EOL] [EOL] debug = ConfigProp ( bool , [string] ) [EOL] string = ConfigProp ( str , [string] ) [EOL] integer = ConfigProp ( int , [string] ) [EOL] some_list = ConfigProp ( list , [string] ) [EOL] namespace_key = ConfigProp ( str , namespace = [string] ) [EOL] no_default = ConfigProp ( str ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def dummy_config ( ) : [EOL] def make_dummy_config ( * args , ** kwargs ) : [EOL] if args or kwargs : [EOL] return DummyConfig ( * args , ** kwargs ) [EOL] [EOL] return DummyConfig [EOL] [EOL] yield make_dummy_config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 0 0 $elib.config.property.ConfigProp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def test_ini_config_file ( dummy_config ) : [EOL] with open ( [string] , [string] ) as stream : [EOL] stream . write ( [string] ) [EOL] cfg = dummy_config ( [string] ) [EOL] assert cfg . debug is True [EOL] assert cfg . string == [string] [EOL] assert cfg . integer is [number] [EOL] assert cfg . namespace_key == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0