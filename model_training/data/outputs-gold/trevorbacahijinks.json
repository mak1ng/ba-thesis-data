from typing import Any , Dict , List , Tuple , Union [EOL] import abjad [EOL] import baca [EOL] import typing [EOL] import builtins [EOL] import typing [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] [comment] [EOL] [EOL] instruments = abjad . OrderedDict ( [ ( [string] , abjad . Piano ( ) ) , ( [string] , abjad . Violin ( ) ) ] ) [EOL] [EOL] [EOL] def _make_margin_markup ( markup , context = [string] ) : [EOL] return abjad . MarginMarkup ( context = context , markup = rf" [string] { markup }" , ) [EOL] [EOL] [EOL] margin_markups = abjad . OrderedDict ( [ ( [string] , _make_margin_markup ( [string] ) ) , ( [string] , _make_margin_markup ( [string] , context = [string] ) ) , ] ) [EOL] [EOL] [EOL] def margin_markup ( key , alert = None , context = [string] , selector = baca . leaf ( [number] ) , ) : [EOL] [docstring] [EOL] margin_markup = margin_markups [ key ] [EOL] command = baca . margin_markup ( margin_markup , alert = alert , context = context , selector = selector ) [EOL] return baca . not_parts ( command ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] metronome_marks = abjad . OrderedDict ( [ ( [string] , abjad . MetronomeMark ( ( [number] , [number] ) , [number] ) ) ] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] circuit = [number] * [ [ [number] ] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] ] [EOL] circuit [ [number] - [number] ] = [ - [number] , - [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] aggregate = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] assert aggregate == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] cary = [ [ - [number] , - [number] , - [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] [EOL] [EOL] order_1 = baca . sequence ( cary ) . flatten ( ) [EOL] order_1 = [ _ % [number] for _ in order_1 ] [EOL] assert order_1 == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] order_2 = [ baca . sequence ( _ ) . rotate ( n = [number] ) for _ in cary ] [EOL] order_2 = baca . sequence ( order_2 ) . rotate ( n = - [number] ) [EOL] order_2 = baca . sequence ( order_2 ) . flatten ( ) [EOL] order_2 = [ _ % [number] for _ in order_2 ] [EOL] assert order_2 == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] order_3 = [ baca . sequence ( _ ) . rotate ( n = [number] ) for _ in cary ] [EOL] order_3 = baca . sequence ( order_3 ) . rotate ( n = - [number] ) [EOL] order_3 = baca . sequence ( order_3 ) . flatten ( ) [EOL] order_3 = [ _ % [number] for _ in order_3 ] [EOL] assert order_3 == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] aggregate_ = abjad . PitchSet ( items = aggregate , item_class = abjad . NumberedPitch ) [EOL] [EOL] violin_pitches = [ ] [EOL] orders = ( order_1 , order_2 , order_3 ) [EOL] for order in orders : [EOL] pitches_ = aggregate_ . register ( order ) [EOL] violin_pitches . extend ( pitches_ ) [EOL] [EOL] [comment] [EOL] [EOL] pairs = { } [EOL] pairs [ [string] ] = [ ( n , [number] ) for n in ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ] [EOL] pairs [ [string] ] = [ ( n , [number] ) for n in ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ] [EOL] [EOL] proportions = { } [EOL] proportions [ [string] ] = [ abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , ] [EOL] proportions [ [string] ] = [ abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( - [number] , ) ) , abjad . Ratio ( ( [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) , abjad . Ratio ( ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , ] [EOL] [EOL] [EOL] def piano_rhythm ( staff ) : [EOL] [docstring] [EOL] assert staff in ( [string] , [string] ) [EOL] tag = abjad . Tag ( [string] ) [EOL] maker = abjad . makers . tuplet_from_ratio_and_pair [EOL] music = [ ] [EOL] for proportion , pair , aggregate in zip ( proportions [ staff ] , pairs [ staff ] , circuit ) : [EOL] if staff == [string] : [EOL] aggregate = list ( reversed ( aggregate ) ) [EOL] tuplet = maker ( proportion , pair ) [EOL] assert isinstance ( tuplet , abjad . Tuplet ) [EOL] duration = abjad . get . duration ( tuplet ) [EOL] duration = duration . with_denominator ( [number] ) [EOL] tuplet . denominator = duration . numerator [EOL] if tuplet . trivial ( ) : [EOL] tuplet . hide = True [EOL] leaves = abjad . select ( tuplet ) . leaves ( ) [EOL] [comment] [EOL] abjad . beam ( leaves , tag = tag ) [EOL] notes = abjad . select ( tuplet ) . leaves ( pitched = True ) [EOL] for note , pitch_number in zip ( notes , aggregate ) : [EOL] note . written_pitch = pitch_number [EOL] music . append ( tuplet ) [EOL] music . insert ( - [number] , abjad . Rest ( [string] ) ) [EOL] selection = abjad . select ( music ) [EOL] return baca . music ( selection , tag = tag ) [EOL] [EOL] [EOL] def violin_rhythm ( ) : [EOL] [docstring] [EOL] tag = abjad . Tag ( [string] ) [EOL] definitions = [ ( ( [number] , [number] , [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] , [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) ) , ] [EOL] maker = abjad . makers . tuplet_from_ratio_and_pair [EOL] components = [ ] [EOL] for definition in definitions : [EOL] ratio , pair = definition [EOL] assert isinstance ( ratio , tuple ) [EOL] tuplet = maker ( ratio , pair , tag = tag ) [EOL] leaves = abjad . select ( tuplet ) . leaves ( ) [EOL] abjad . beam ( leaves , tag = tag ) [EOL] components . append ( tuplet ) [EOL] components . insert ( - [number] , abjad . Rest ( [string] , tag = tag ) ) [EOL] selection = abjad . select ( components ) [EOL] return selection [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $baca.CommandTyping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[abjad.NumberedPitch]$ 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Tuple[typing.List[typing.Any],typing.List[typing.Any],typing.List[typing.Any]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[abjad.NumberedPitch]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $baca.RhythmCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $abjad.Selection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import baca [EOL] [EOL] breaks = baca . breaks ( baca . page ( baca . system ( [number] , [number] , [number] , measure = [number] , y_offset = [number] , ) , baca . system ( [number] , [number] , [number] , measure = [number] , y_offset = [number] , ) , baca . system ( [number] , [number] , [number] , measure = [number] , y_offset = [number] , ) , number = [number] , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] [EOL] metadata = abjad . OrderedDict ( [ ( [string] , [ [number] , [number] , [number] ] , ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import baca [EOL] [EOL] breaks = baca . breaks ( baca . page ( baca . system ( [number] , [number] , [number] , measure = [number] , y_offset = [number] , ) , baca . system ( [number] , [number] , [number] , measure = [number] , y_offset = [number] , ) , baca . system ( [number] , [number] , [number] , measure = [number] , y_offset = [number] , ) , number = [number] , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0