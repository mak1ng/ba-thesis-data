[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import List , Any [EOL] import io [EOL] import typing [EOL] def add_global_node ( dirt , name ) : [EOL] [EOL] f1 = open ( dirt + name + [string] , [string] ) [EOL] f2 = open ( dirt + name + [string] , [string] ) [EOL] f3 = open ( dirt + name + [string] , [string] ) [EOL] h1 = open ( dirt + name + [string] , [string] ) [EOL] h2 = open ( dirt + name + [string] , [string] ) [EOL] h3 = open ( dirt + name + [string] , [string] ) [EOL] index_list = [ ] [EOL] node = [string] [EOL] for line in f1 : [EOL] toks = line . strip ( ) . split ( ) [EOL] for t in toks : [EOL] h1 . write ( str ( t ) + [string] ) [EOL] h1 . write ( str ( node ) + [string] ) [EOL] index_list . append ( len ( toks ) ) [EOL] i = [number] [EOL] for line in f2 : [EOL] deps = line . strip ( ) . split ( ) [EOL] for d in deps : [EOL] h2 . write ( str ( d ) + [string] ) [EOL] index = index_list [ i ] [EOL] for j in range ( index ) : [EOL] d1 = [string] + str ( index ) + [string] + str ( j ) + [string] [EOL] h2 . write ( d1 + [string] ) [EOL] d3 = [string] + str ( index ) + [string] + str ( index ) + [string] [EOL] h2 . write ( d3 + [string] ) [EOL] i += [number] [EOL] for line in f3 : [EOL] seg = line . strip ( ) . split ( [string] ) [EOL] toks = seg [ [number] ] . split ( ) [EOL] deps = seg [ [number] ] . split ( ) [EOL] for t in toks : [EOL] h3 . write ( str ( t ) + [string] ) [EOL] h3 . write ( str ( node ) + [string] ) [EOL] for d in deps : [EOL] h3 . write ( str ( d ) + [string] ) [EOL] index = len ( toks ) [EOL] for j in range ( index ) : [EOL] d1 = [string] + str ( index ) + [string] + str ( j ) + [string] [EOL] h3 . write ( d1 + [string] ) [EOL] d3 = [string] + str ( index ) + [string] + str ( index ) + [string] [EOL] h3 . write ( d3 + [string] ) [EOL] [EOL] [EOL] def dep_to_levi ( dirt , name , Sequential = False ) : [EOL] [EOL] if name == [string] : [EOL] file_1 = [string] [EOL] file_2 = [string] [EOL] file_3 = [string] [EOL] elif name == [string] : [EOL] file_1 = [string] [EOL] file_2 = [string] [EOL] file_3 = [string] [EOL] elif name == [string] : [EOL] file_1 = [string] [EOL] file_2 = [string] [EOL] file_3 = [string] [EOL] [EOL] file_4 = dirt + name + [string] [EOL] file_5 = dirt + name + [string] [EOL] f1 = open ( file_1 , [string] ) [EOL] f2 = open ( file_2 , [string] ) [EOL] f3 = open ( file_3 , [string] ) [EOL] h1 = open ( file_4 , [string] ) [EOL] h2 = open ( file_5 , [string] ) [EOL] [EOL] tok_list = [ ] [EOL] dep_list = [ ] [EOL] head_list = [ ] [EOL] [EOL] for line in f1 : [EOL] seg = line . rstrip ( ) . split ( ) [EOL] tok_list . append ( seg ) [EOL] [EOL] for line in f2 : [EOL] seg = line . rstrip ( ) . split ( ) [EOL] dep_list . append ( seg ) [EOL] [EOL] for line in f3 : [EOL] seg = line . rstrip ( ) . split ( ) [EOL] head_list . append ( seg ) [EOL] [EOL] N = len ( tok_list ) [EOL] if len ( tok_list ) != len ( dep_list ) : [EOL] print ( [string] ) [EOL] for i in range ( N ) : [EOL] tok = tok_list [ i ] [EOL] dep = dep_list [ i ] [EOL] head = head_list [ i ] [EOL] M = len ( tok ) [EOL] if M == [number] : [EOL] print ( i ) [EOL] if len ( tok ) != len ( dep ) : [EOL] print ( [string] ) [EOL] for j in range ( M ) : [EOL] h1 . write ( str ( tok [ j ] ) + [string] ) [EOL] if Sequential : [EOL] if j + [number] < M : [EOL] d1 = [string] + str ( j ) + [string] + str ( j + [number] ) + [string] [EOL] h2 . write ( d1 + [string] ) [EOL] d2 = [string] + str ( j + [number] ) + [string] + str ( j ) + [string] [EOL] h2 . write ( d2 + [string] ) [EOL] for k in range ( M ) : [EOL] h1 . write ( str ( dep [ k ] ) + [string] ) [EOL] g1 = [string] + str ( k ) + [string] + str ( k ) + [string] [EOL] h2 . write ( g1 + [string] ) [EOL] g2 = [string] + str ( k + M ) + [string] + str ( k + M ) + [string] [EOL] h2 . write ( g2 + [string] ) [EOL] index = int ( head [ k ] ) [EOL] if index != [number] : [EOL] g3 = [string] + str ( index - [number] ) + [string] + str ( k + M ) + [string] [EOL] h2 . write ( g3 + [string] ) [EOL] g4 = [string] + str ( k + M ) + [string] + str ( index - [number] ) + [string] [EOL] h2 . write ( g4 + [string] ) [EOL] [EOL] g5 = [string] + str ( k + M ) + [string] + str ( k ) + [string] [EOL] h2 . write ( g5 + [string] ) [EOL] g6 = [string] + str ( k ) + [string] + str ( k + M ) + [string] [EOL] h2 . write ( g6 + [string] ) [EOL] h1 . write ( [string] ) [EOL] h2 . write ( [string] ) [EOL] [EOL] print ( N ) [EOL] [EOL] def gen_tokdeps ( dirt , name ) : [EOL] [EOL] file_4 = dirt + name + [string] [EOL] file_5 = dirt + name + [string] [EOL] file_6 = dirt + name + [string] [EOL] h4 = open ( file_4 , [string] ) [EOL] h5 = open ( file_5 , [string] ) [EOL] h6 = open ( file_6 , [string] ) [EOL] toks = [ ] [EOL] deps = [ ] [EOL] for line in h4 : [EOL] seg = line . strip ( ) . split ( ) [EOL] toks . append ( seg ) [EOL] for line in h5 : [EOL] seg = line . strip ( ) . split ( ) [EOL] deps . append ( seg ) [EOL] L = len ( toks ) [EOL] if len ( toks ) != len ( deps ) : [EOL] print ( [string] ) [EOL] for i in range ( L ) : [EOL] tok = toks [ i ] [EOL] dep = deps [ i ] [EOL] for j in range ( len ( tok ) ) : [EOL] h6 . write ( str ( tok [ j ] ) + [string] ) [EOL] h6 . write ( [string] ) [EOL] for j in range ( len ( dep ) ) : [EOL] h6 . write ( str ( dep [ j ] ) + [string] ) [EOL] h6 . write ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] add_global = True [EOL] Sequential = True [EOL] name_list = [ [string] , [string] , [string] ] [EOL] dirt = [string] [EOL] for name in name_list : [EOL] dep_to_levi ( dirt , name , Sequential ) [EOL] if name != [string] : [EOL] gen_tokdeps ( dirt , name ) [EOL] if add_global : [EOL] add_global_node ( dirt , name ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sys [EOL] import os [EOL] [EOL] [EOL] INPUT = sys . argv [ [number] ] [EOL] OUT_SURF = sys . argv [ [number] ] [EOL] OUT_GRAPH = sys . argv [ [number] ] [EOL] [EOL] with open ( INPUT ) as f : [EOL] lines = f . readlines ( ) [EOL] [EOL] with open ( OUT_SURF , [string] ) as surf , open ( OUT_GRAPH , [string] ) as graph : [EOL] amr_mode = False [EOL] amr_tokens = [ ] [EOL] for line in lines : [EOL] if line . startswith ( [string] ) : [EOL] if amr_mode : [EOL] amr_mode = False [EOL] amr = [string] . join ( amr_tokens ) [EOL] graph . write ( amr + [string] ) [EOL] amr_tokens = [ ] [EOL] tokens = line . split ( ) [EOL] if tokens [ [number] ] == [string] : [EOL] sent = [string] . join ( tokens [ [number] : ] ) [EOL] surf . write ( sent + [string] ) [EOL] elif line . strip ( ) == [string] : [EOL] continue [EOL] else : [EOL] amr_mode = True [EOL] amr_tokens . append ( line . strip ( ) ) [EOL] if amr_mode : [EOL] amr_mode = False [EOL] amr = [string] . join ( amr_tokens ) [EOL] graph . write ( amr + [string] ) [EOL] amr_tokens = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
[comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import Generator , Tuple , Any , List , DefaultDict , Type , Set , Dict [EOL] import preprocess [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] import re [EOL] from collections import defaultdict , Counter [EOL] [EOL] from nltk . parse import DependencyGraph [EOL] from parsimonious . exceptions import ParseError [EOL] from parsimonious . grammar import Grammar [EOL] [EOL] [EOL] def clean_grammar_file ( s ) : [EOL] return re . sub ( [string] , [string] , re . sub ( [string] , [string] , s . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) ) [EOL] [EOL] with open ( [string] ) as inF : [EOL] grammar = Grammar ( clean_grammar_file ( inF . read ( ) ) ) [EOL] [EOL] [EOL] class Var ( object ) : [EOL] def __init__ ( self , name ) : [EOL] self . _name = name [EOL] def is_constant ( self ) : [EOL] return False [EOL] def __repr__ ( self ) : [EOL] return [string] + self . _name + [string] [EOL] def __str__ ( self ) : [EOL] return self . _name [EOL] def __call__ ( self , align_key = [string] , append = False ) : [EOL] return self . _name + ( align_key if append else [string] ) [EOL] def __eq__ ( self , that ) : [EOL] return type ( that ) == type ( self ) and self . _name == that . _name [EOL] def __hash__ ( self ) : [EOL] return hash ( repr ( self ) ) [EOL] [EOL] class Concept ( object ) : [EOL] RE_FRAME_NUM = re . compile ( [string] ) [EOL] def __init__ ( self , name ) : [EOL] self . _name = name [EOL] def is_constant ( self ) : [EOL] return False [EOL] def is_frame ( self ) : [EOL] return self . RE_FRAME_NUM . search ( self . _name ) is not None [EOL] def __repr__ ( self ) : [EOL] return [string] + self . _name + [string] [EOL] def __str__ ( self , align_key = [string] , ** kwargs ) : [EOL] return self . _name + align_key [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . __str__ ( * args , ** kwargs ) [EOL] def __eq__ ( self , that ) : [EOL] return type ( that ) == type ( self ) and self . _name == that . _name [EOL] def __hash__ ( self ) : [EOL] return hash ( repr ( self ) ) [EOL] [EOL] class AMRConstant ( object ) : [EOL] def __init__ ( self , value ) : [EOL] self . _value = value [EOL] def is_constant ( self ) : [EOL] return True [EOL] def is_frame ( self ) : [EOL] return False [EOL] def __repr__ ( self ) : [EOL] return [string] + self . _value + [string] [EOL] def __str__ ( self , align_key = [string] , ** kwargs ) : [EOL] return self . _value + align_key [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . __str__ ( * args , ** kwargs ) [EOL] def __eq__ ( self , that ) : [EOL] return type ( that ) == type ( self ) and self . _value == that . _value [EOL] def __hash__ ( self ) : [EOL] return hash ( repr ( self ) ) [EOL] [EOL] class AMRString ( AMRConstant ) : [EOL] def __str__ ( self , align_key = [string] , ** kwargs ) : [EOL] return [string] + self . _value + [string] + align_key [EOL] def __repr__ ( self ) : [EOL] return [string] + self . _value + [string] [EOL] [EOL] class AMRNumber ( AMRConstant ) : [EOL] def __repr__ ( self ) : [EOL] return [string] + self . _value + [string] [EOL] [EOL] [EOL] class AMRError ( Exception ) : [EOL] pass [EOL] [EOL] class AMRSyntaxError ( Exception ) : [EOL] pass [EOL] [EOL] class AMR ( DependencyGraph ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , anno , tokens = None ) : [EOL] [docstring] [EOL] self . _v2c = { } [EOL] self . _triples = [ ] [EOL] self . _constants = set ( ) [EOL] self . _alignments = { } [EOL] self . _role_alignments = { } [EOL] self . _tokens = tokens [EOL] [EOL] self . nodes = defaultdict ( lambda : { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [ ] } ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] TOP = Var ( [string] ) [EOL] self . nodes [ TOP ] [ [string] ] = self . nodes [ TOP ] [ [string] ] = TOP [EOL] self . nodes [ TOP ] [ [string] ] = [string] [EOL] if anno : [EOL] self . _anno = anno [EOL] msg = [string] [EOL] try : [EOL] p = grammar . parse ( anno ) [EOL] except ParseError as e : [EOL] msg += [string] + str ( e ) [EOL] p = None [EOL] if p is None : [EOL] raise AMRSyntaxError ( [string] + anno . strip ( ) + msg ) [EOL] self . _analyze ( p ) [EOL] [EOL] def triples ( self , head = None , rel = None , dep = None , normalize_inverses = False , normalize_mod = False ) : [comment] [EOL] [docstring] [EOL] tt = ( trip for trip in self . _triples ) [EOL] if normalize_mod : [EOL] tt = ( ( h , [string] , d ) if r == [string] else ( h , r , d ) for h , r , d in tt ) [EOL] if normalize_inverses : [EOL] tt = ( ( y , r [ : - [number] ] , x ) if r . endswith ( [string] ) else ( x , r , y ) for x , r , y in tt ) [EOL] if head : [EOL] tt = ( ( h , r , d ) for h , r , d in tt if h in ( head if hasattr ( head , [string] ) else ( head , ) ) ) [EOL] if rel : [EOL] if rel == [string] : [EOL] tt = ( ( h , r , d ) for h , r , d in tt if r . startswith ( [string] ) ) [EOL] elif rel == [string] : [EOL] tt = ( ( h , r , d ) for h , r , d in tt if not r . startswith ( [string] ) ) [EOL] else : [EOL] tt = ( ( h , r , d ) for h , r , d in tt if r in ( rel if hasattr ( rel , [string] ) else (rel) ) ) [EOL] if dep : [EOL] tt = ( ( h , r , d ) for h , r , d in tt if d in ( dep if hasattr ( dep , [string] ) else ( dep , ) ) ) [EOL] return list ( tt ) [EOL] [EOL] def role_triples ( self , ** kwargs ) : [EOL] [docstring] [EOL] tt = [ ( h , r , d ) for h , r , d in self . triples ( ** kwargs ) if r not in ( [string] , [string] , [string] ) ] [EOL] return tt [EOL] [EOL] def constants ( self ) : [EOL] return self . _constants [EOL] [EOL] def concept ( self , variable ) : [EOL] return self . _v2c [ variable ] [EOL] [EOL] def concepts ( self ) : [EOL] return self . _v2c . items ( ) [EOL] [EOL] def var2concept ( self ) : [EOL] return dict ( self . _v2c ) [EOL] [EOL] def alignments ( self ) : [EOL] return dict ( self . _alignments ) [EOL] [EOL] def role_alignments ( self ) : [EOL] return dict ( self . _role_alignments ) [EOL] [EOL] def tokens ( self ) : [EOL] return self . _tokens [EOL] [EOL] def reentrancies ( self ) : [EOL] [docstring] [EOL] c = defaultdict ( int ) [EOL] for h , r , d in self . triples ( ) : [EOL] if isinstance ( d , Var ) : [EOL] c [ d ] += [number] [EOL] elif isinstance ( d , Concept ) : [EOL] c [ h ] -= [number] [EOL] return Counter ( c ) + Counter ( ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . __str__ ( * args , ** kwargs ) [EOL] [EOL] def __str__ ( self , alignments = True , tokens = True , compressed = False , indent = [string] * [number] ) : [EOL] [docstring] [EOL] def alignment_str ( align_key ) : [EOL] s = [string] + align_key [EOL] if tokens : [comment] [EOL] s += [string] + [string] . join ( tokens [ int ( woffset ) ] for woffset in align_key . split ( [string] ) [ [number] ] . split ( [string] ) ) + [string] [EOL] return s [EOL] [EOL] s = [string] [EOL] stack = [ ] [EOL] instance_fulfilled = None [EOL] align = role_align = { } [EOL] if alignments : [EOL] if tokens : [EOL] tokens = self . tokens ( ) [EOL] align = { k : alignment_str ( align_key ) for k , align_key in self . _alignments . items ( ) } [EOL] role_align = { k : alignment_str ( align_key ) for k , align_key in self . _role_alignments . items ( ) } [EOL] concept_stack_depth = { None : [number] } [comment] [EOL] for h , r , d in self . triples ( ) + [ ( None , None , None ) ] : [EOL] align_key = align . get ( ( h , r , d ) , [string] ) [EOL] role_align_key = role_align . get ( ( h , r , d ) , [string] ) [EOL] if r == [string] : [EOL] s += [string] + d ( ) [EOL] stack . append ( ( h , r , d ) ) [EOL] instance_fulfilled = False [EOL] elif r == [string] : [EOL] s += [string] + d ( align_key ) [EOL] instance_fulfilled = True [EOL] concept_stack_depth [ h ] = len ( stack ) [EOL] elif h == stack [ - [number] ] [ [number] ] and r == [string] : [comment] [EOL] s += [string] + r + role_align_key + [string] + d ( align_key ) [EOL] else : [EOL] while len ( stack ) > concept_stack_depth [ h ] : [EOL] h2 , r2 , d2 = stack . pop ( ) [EOL] if instance_fulfilled is False : [EOL] [comment] [EOL] [comment] [EOL] align_key2 = align . get ( ( h2 , r2 , d2 ) , [string] ) [EOL] s = s [ : - len ( d2 ( align_key2 ) ) - [number] ] + d2 ( align_key2 , append = not instance_fulfilled ) [EOL] else : [EOL] s += [string] [EOL] instance_fulfilled = None [EOL] if d is not None : [EOL] s += [string] + indent * len ( stack ) + r + role_align_key + [string] + d ( align_key ) [EOL] stack . append ( ( h , r , d ) ) [EOL] instance_fulfilled = False [EOL] return s [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self ) [EOL] [EOL] def _analyze ( self , p ) : [EOL] [docstring] [EOL] v2c = { } [comment] [EOL] allvars = set ( ) [comment] [EOL] elts = { } [comment] [EOL] consts = set ( ) [comment] [EOL] [EOL] def intern_elt ( x ) : [EOL] return elts . setdefault ( x , x ) [EOL] [EOL] def walk ( n ) : [comment] [EOL] triples = [ ] [EOL] deps = [ ] [EOL] v = None [EOL] for ch in n . children : [EOL] t = ch . expr_name [EOL] if t == [string] : [EOL] v = intern_elt ( Var ( ch . text ) ) [EOL] allvars . add ( v ) [EOL] elif t == [string] : [EOL] assert v is not None [EOL] if v in v2c : [EOL] raise AMRError ( [string] + str ( v ) + [string] + self . _anno ) [EOL] concept_node , alignment_node = ch . children [EOL] c = intern_elt ( Concept ( concept_node . text ) ) [EOL] v2c [ v ] = c [EOL] self . add_node ( { [string] : c , [string] : c , [string] : [string] , [string] : [string] , [string] : v , [string] : [ ] } ) [EOL] deps . append ( c ) [EOL] triple = ( v , [string] , c ) [EOL] triples . append ( triple ) [EOL] if alignment_node . text : [EOL] self . _alignments [ triple ] = alignment_node . text [ [number] : ] [EOL] elif t == [string] and ch . children : [EOL] for ch2 in ch . children : [EOL] _part , RELpart , _part , Ypart = ch2 . children [EOL] rel , relalignment = RELpart . children [EOL] rel = rel . text [EOL] assert rel is not None [EOL] assert len ( Ypart . children ) == [number] [EOL] q = Ypart . children [ [number] ] [EOL] tq = q . expr_name [EOL] n2 = None [EOL] triples2 = [ ] [EOL] deps2 = [ ] [EOL] qalign = None [EOL] if tq == [string] : [EOL] n2 , triples2 , deps2 = walk ( q ) [EOL] elif tq == [string] : [EOL] qleft , qalign = q . children [EOL] n2 = intern_elt ( AMRConstant ( qleft . text ) ) [EOL] consts . add ( n2 ) [EOL] elif tq == [string] : [EOL] qleft , qalign = q . children [EOL] n2 = intern_elt ( Var ( qleft . text ) ) [EOL] allvars . add ( n2 ) [EOL] elif tq == [string] : [EOL] quote1 , qstr , quote2 , qalign = q . children [EOL] n2 = intern_elt ( AMRString ( qstr . text ) ) [EOL] consts . add ( n2 ) [EOL] elif tq == [string] : [EOL] qleft , qalign = q . children [EOL] n2 = intern_elt ( AMRNumber ( qleft . text ) ) [EOL] consts . add ( n2 ) [EOL] assert n2 is not None [EOL] self . add_node ( { [string] : n2 , [string] : n2 , [string] : tq , [string] : rel , [string] : v } ) [EOL] self . nodes [ n2 ] [ [string] ] . extend ( deps2 ) [EOL] deps . append ( n2 ) [EOL] triple = ( v , rel , n2 ) [EOL] triples . append ( triple ) [EOL] if qalign and qalign . text : [EOL] self . _alignments [ triple ] = qalign . text [ [number] : ] [EOL] if relalignment . text : [EOL] self . _role_alignments [ triple ] = relalignment . text [ [number] : ] [EOL] triples . extend ( triples2 ) [EOL] return v , triples , deps [EOL] [EOL] assert p . expr_name == [string] [EOL] [EOL] n = None [EOL] for ch in p . children : [EOL] if ch . expr_name == [string] : [EOL] assert n is None [comment] [EOL] n , triples , deps = walk ( ch ) [EOL] self . add_node ( { [string] : n , [string] : n , [string] : [string] , [string] : [string] , [string] : intern_elt ( Var ( [string] ) ) } ) [EOL] self . nodes [ n ] [ [string] ] . extend ( deps ) [EOL] triples = [ ( intern_elt ( Var ( [string] ) ) , [string] , n ) ] + triples [EOL] [EOL] if allvars - set ( v2c . keys ( ) ) : [EOL] raise AMRError ( [string] + [string] . join ( map ( str , allvars - set ( v2c . keys ( ) ) ) ) + [string] + self . _anno ) [EOL] [EOL] [comment] [EOL] self . _v2c = v2c [EOL] self . _triples = triples [EOL] self . _constants = consts [EOL] [EOL] [EOL] [EOL] good_tests = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] sembad_tests = [ [string] , [string] ] [EOL] [EOL] bad_tests = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def test ( ) : [EOL] for good in good_tests : [EOL] try : [EOL] AMR ( good ) [EOL] except AMRSyntaxError : [EOL] print ( [string] ) [EOL] print ( good ) [EOL] except AMRError : [EOL] print ( [string] ) [EOL] print ( good ) [EOL] [EOL] for sembad in sembad_tests : [EOL] try : [EOL] AMR ( sembad ) [EOL] except AMRSyntaxError : [EOL] print ( [string] ) [EOL] print ( sembad ) [EOL] except AMRError : [EOL] pass [comment] [EOL] else : [EOL] print ( [string] ) [EOL] print ( sembad ) [EOL] [EOL] for bad in bad_tests : [EOL] try : [EOL] AMR ( bad ) [EOL] except AMRSyntaxError : [EOL] pass [EOL] else : [EOL] print ( [string] ) [EOL] print ( bad ) [EOL] [EOL] if __name__ == [string] : [EOL] test ( ) [EOL] import doctest [EOL] doctest . testmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $preprocess.amr_preprocess.amr.Var$ 0 0 0 0 0 0 0 0 0 0 $preprocess.amr_preprocess.amr.Var$ 0 0 0 0 0 0 0 0 0 $preprocess.amr_preprocess.amr.Var$ 0 0 0 0 0 $preprocess.amr_preprocess.amr.Var$ 0 0 0 0 0 $preprocess.amr_preprocess.amr.Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Tuple[typing.Any,typing.Any,typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[None,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Dict[None,builtins.int]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[None,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Any , List , DefaultDict , Set , Dict [EOL] import io [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] import sys [EOL] from amr import AMR , Var , Concept , AMRNumber [EOL] import re [EOL] import json [EOL] import argparse [EOL] from collections import Counter [EOL] from collections import defaultdict [EOL] from copy import deepcopy [EOL] [EOL] from ne_clusters import NE_CLUSTER , QUANT_CLUSTER [EOL] [EOL] [comment] [EOL] [EOL] class AMRTree ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , label ) : [EOL] self . _label = label [EOL] self . _children = [ ] [EOL] [EOL] def __str__ ( self ) : [EOL] if len ( self . children ) > [number] : [EOL] str_chs = [string] . join ( [ str ( ch ) for ch in self . _children ] ) [EOL] if len ( self . children ) > [number] : [EOL] return self . _label + [string] + str_chs + [string] [EOL] else : [EOL] return self . _label + [string] + str_chs [EOL] else : [EOL] return self . _label [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def simplify ( tokens , v2c ) : [EOL] new_tokens = [ ] [EOL] for tok in tokens : [EOL] [comment] [EOL] if tok . startswith ( [string] ) : [EOL] continue [EOL] elif tok == [string] : [EOL] continue [EOL] [comment] [EOL] elif tok . startswith ( [string] ) : [EOL] new_tok = tok . strip ( [string] ) [EOL] new_tok = new_tok . split ( [string] ) [ [number] ] [EOL] new_tokens . append ( new_tok ) [EOL] [comment] [EOL] else : [EOL] new_tok = tok . strip ( [string] ) [EOL] new_tok = new_tok . split ( [string] ) [ [number] ] [EOL] [comment] [EOL] if Var ( new_tok ) in v2c : [EOL] [comment] [EOL] new_tok = v2c [ Var ( new_tok ) ] . _name [EOL] [comment] [EOL] elif re . search ( SENSE_PATTERN , new_tok ) : [EOL] new_tok = new_tok [ : - [number] ] [EOL] [comment] [EOL] elif new_tok [ [number] ] == [string] and new_tok [ - [number] ] == [string] : [EOL] new_tok = new_tok [ [number] : - [number] ] [EOL] new_tokens . append ( new_tok ) [EOL] return new_tokens [EOL] [EOL] [comment] [EOL] [EOL] def get_name ( v , v2c ) : [EOL] try : [EOL] [comment] [EOL] c = v2c [ v ] [EOL] if re . search ( SENSE_PATTERN , c . _name ) : [EOL] return c . _name [ : - [number] ] [EOL] else : [EOL] return c . _name [EOL] except : [comment] [EOL] r = str ( v ) . lower ( ) [EOL] if r [ [number] ] == [string] and r [ - [number] ] == [string] : [EOL] return r [ [number] : - [number] ] [EOL] else : [EOL] return r [EOL] [EOL] [comment] [EOL] [EOL] def get_nodes ( graph ) : [EOL] v_ids = { } [EOL] rev_v_ids = [ ] [EOL] for concept in graph . concepts ( ) : [EOL] v = concept [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_ids [ v ] = str ( len ( v_ids ) ) [EOL] rev_v_ids . append ( v ) [EOL] [EOL] [comment] [EOL] for constant in graph . constants ( ) : [EOL] v_ids [ constant ] = str ( len ( v_ids ) ) [EOL] rev_v_ids . append ( constant ) [EOL] return v_ids , rev_v_ids [EOL] [EOL] [comment] [EOL] [EOL] def get_nodes2 ( graph ) : [EOL] v_ids = { } [EOL] rev_v_ids = [ ] [EOL] filtered = [ t for t in graph . triples ( ) if type ( t [ [number] ] ) != Var ] [EOL] [comment] [EOL] [comment] [EOL] for triple in filtered : [EOL] [comment] [EOL] if triple [ [number] ] == [string] : [EOL] v = triple [ [number] ] [EOL] [comment] [EOL] else : [EOL] v = triple [ [number] ] [EOL] if v not in v_ids : [EOL] [comment] [EOL] v_ids [ v ] = str ( len ( v_ids ) ) [EOL] rev_v_ids . append ( v ) [EOL] return v_ids , rev_v_ids [EOL] [EOL] [comment] [EOL] [EOL] def get_triples ( graph , v_ids , rev_v_ids ) : [EOL] triples = [ ] [EOL] for triple in graph . triples ( ) : [EOL] [comment] [EOL] [comment] [EOL] if triple [ [number] ] == [string] or triple [ [number] ] == [string] : [EOL] continue [EOL] predicate = triple [ [number] ] [EOL] try : [EOL] v1 = triple [ [number] ] [EOL] c1 = v2c [ v1 ] [EOL] except : [comment] [EOL] v1 = triple [ [number] ] [EOL] try : [EOL] v2 = triple [ [number] ] [EOL] c2 = v2c [ v2 ] [EOL] except : [EOL] v2 = triple [ [number] ] [EOL] triples . append ( ( v_ids [ v1 ] , v_ids [ v2 ] , predicate ) ) [EOL] if args . add_reverse : [EOL] [comment] [EOL] if predicate . endswith ( [string] ) : [EOL] rev_predicate = predicate [ : - [number] ] [EOL] else : [EOL] rev_predicate = predicate + [string] [EOL] triples . append ( ( v_ids [ v2 ] , v_ids [ v1 ] , rev_predicate ) ) [EOL] [EOL] [comment] [EOL] for v in v_ids : [EOL] triples . append ( ( v_ids [ v ] , v_ids [ v ] , [string] ) ) [EOL] return triples [EOL] [EOL] [comment] [EOL] [EOL] def anonymize_nes ( graph , triples , output_triples , v2c , anon_ids , anon_map , anon_surf ) : [EOL] [docstring] [EOL] name_triples = [ t for t in triples if t [ [number] ] == [string] ] [EOL] for name_t in name_triples : [EOL] conc = name_t [ [number] ] [EOL] name = name_t [ [number] ] [EOL] [EOL] [comment] [EOL] clusterized = NE_CLUSTER . setdefault ( v2c [ conc ] . _name , [string] ) [EOL] cluster_id = anon_ids [ clusterized ] [EOL] new_conc_name = clusterized + [string] + str ( cluster_id ) [EOL] anon_ids [ clusterized ] += [number] [EOL] v2c [ conc ] = Concept ( new_conc_name ) [EOL] [EOL] [comment] [EOL] op_tuples = [ t for t in triples if t [ [number] ] == name and t [ [number] ] != [string] ] [EOL] op_tuples = sorted ( op_tuples , key = lambda x : x [ [number] ] ) [EOL] [EOL] [comment] [EOL] anon_map [ new_conc_name ] = [string] . join ( [ str ( op [ [number] ] ) [ [number] : - [number] ] for op in op_tuples ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] alignments = [ graph . alignments ( ) [ t ] for t in op_tuples if t in graph . alignments ( ) ] [EOL] align_indexes = [ a . split ( [string] ) [ [number] ] for a in alignments ] [EOL] [comment] [EOL] indexes = [ ] [EOL] for a_index in align_indexes : [EOL] if [string] in a_index : [EOL] for i in a_index . split ( [string] ) : [EOL] indexes . append ( int ( i ) ) [EOL] else : [EOL] indexes . append ( int ( a_index ) ) [EOL] [comment] [EOL] for i , index in enumerate ( indexes ) : [EOL] if i == [number] : [EOL] anon_surf [ index ] = new_conc_name [EOL] else : [EOL] anon_surf [ index ] = [string] [EOL] [EOL] [comment] [EOL] for triple in triples : [EOL] try : [EOL] if triple [ [number] ] == name : [EOL] try : [EOL] output_triples . remove ( triple ) [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] elif triple [ [number] ] == conc and triple [ [number] ] == [string] and triple [ [number] ] == name : [EOL] output_triples . remove ( triple ) [EOL] elif triple [ [number] ] == conc and triple [ [number] ] == [string] : [EOL] output_triples . remove ( triple ) [EOL] elif triple [ [number] ] == conc and triple [ [number] ] == [string] : [EOL] output_t_index = output_triples . index ( triple ) [EOL] output_triples [ output_t_index ] = ( triple [ [number] ] , triple [ [number] ] , Concept ( new_conc_name ) ) [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] return output_triples , anon_ids , anon_map , anon_surf [EOL] [EOL] [comment] [EOL] [EOL] def anonymize_dates ( graph , triples , output_triples , v2c , anon_ids , anon_map , anon_surf ) : [EOL] [docstring] [EOL] date_vars = [ t [ [number] ] for t in triples if t [ [number] ] == Concept ( [string] ) ] [EOL] [comment] [EOL] for date_var in date_vars : [EOL] [EOL] [comment] [EOL] date_triples = [ t for t in triples if t [ [number] ] == date_var ] [EOL] [EOL] [comment] [EOL] date_triples = sorted ( date_triples , key = lambda x : x [ [number] ] ) [EOL] for date_t in date_triples : [EOL] if date_t [ [number] ] in [ [string] , [string] , [string] ] : [EOL] [EOL] [comment] [EOL] try : [EOL] alignment = graph . alignments ( ) [ date_t ] [EOL] except : [EOL] [comment] [EOL] continue [EOL] a_index = alignment . split ( [string] ) [ [number] ] [EOL] indexes = [ ] [EOL] if [string] in a_index : [EOL] for i in a_index . split ( [string] ) : [EOL] indexes . append ( int ( i ) ) [EOL] else : [EOL] indexes . append ( int ( a_index ) ) [EOL] [EOL] stripped = date_t [ [number] ] [ [number] : ] [EOL] new_conc_name = stripped + [string] + str ( anon_ids [ stripped ] ) [EOL] anon_ids [ stripped ] += [number] [EOL] anon_map [ new_conc_name ] = str ( date_t [ [number] ] ) [EOL] [EOL] [EOL] [comment] [EOL] output_t_index = output_triples . index ( date_t ) [EOL] output_triples [ output_t_index ] = ( date_t [ [number] ] , date_t [ [number] ] , Concept ( new_conc_name ) ) [EOL] [EOL] [comment] [EOL] for i , index in enumerate ( indexes ) : [EOL] if i == [number] : [EOL] curr_token = anon_surf [ index ] [EOL] if curr_token . isdigit ( ) or [string] in new_conc_name or [string] in new_conc_name : [EOL] anon_surf [ index ] = new_conc_name + [string] [EOL] else : [EOL] if [string] in curr_token : [EOL] [comment] [EOL] try : [EOL] next_index = indexes [ i + [number] ] [EOL] except IndexError : [EOL] [comment] [EOL] [comment] [EOL] print ( curr_token ) [EOL] continue [EOL] next_token = anon_surf [ next_index ] [EOL] [comment] [EOL] if next_token . isdigit ( ) or [string] in new_conc_name or [string] in new_conc_name : [EOL] anon_surf [ next_index ] = new_conc_name + [string] [EOL] else : [EOL] anon_surf [ next_index ] = new_conc_name + [string] [EOL] else : [EOL] [comment] [EOL] anon_surf [ index ] = new_conc_name + [string] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return output_triples , anon_ids , anon_map , anon_surf [EOL] [EOL] [comment] [EOL] [EOL] def anonymize_quants ( graph , triples , output_triples , v2c , anon_ids , anon_map , anon_surf ) : [EOL] [docstring] [EOL] quant_triples = [ t for t in triples if t [ [number] ] == [string] ] [EOL] for quant_t in quant_triples : [EOL] conc = quant_t [ [number] ] [EOL] quant = quant_t [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if type ( quant ) == Var : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] elif v2c [ conc ] . _name not in QUANT_CLUSTER : [EOL] if quant_t in graph . alignments ( ) : [EOL] a_index = graph . alignments ( ) [ quant_t ] . split ( [string] ) [ [number] ] [EOL] indexes = [ ] [EOL] if [string] in a_index : [EOL] for i in a_index . split ( [string] ) : [EOL] indexes . append ( int ( i ) ) [EOL] else : [EOL] indexes . append ( int ( a_index ) ) [EOL] new_quant_name = [string] + str ( anon_ids [ [string] ] ) [EOL] anon_ids [ [string] ] += [number] [EOL] anon_map [ new_quant_name ] = quant . _value [EOL] try : [EOL] output_t_index = output_triples . index ( quant_t ) [EOL] output_triples [ output_t_index ] [ [number] ] . _value = new_quant_name [EOL] except ValueError : [EOL] [comment] [EOL] pass [EOL] if quant_t in graph . alignments ( ) : [EOL] for i , index in enumerate ( indexes ) : [EOL] if i == [number] : [EOL] anon_surf [ index ] = new_quant_name [EOL] else : [EOL] anon_surf [ index ] = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] [comment] [EOL] if quant_t in graph . alignments ( ) : [EOL] a_index = graph . alignments ( ) [ quant_t ] . split ( [string] ) [ [number] ] [EOL] indexes = [ ] [EOL] if [string] in a_index : [EOL] for i in a_index . split ( [string] ) : [EOL] indexes . append ( int ( i ) ) [EOL] else : [EOL] indexes . append ( int ( a_index ) ) [EOL] new_quant_name = [string] + str ( anon_ids [ [string] ] ) [EOL] anon_ids [ [string] ] += [number] [EOL] anon_map [ new_quant_name ] = quant . _value [EOL] if quant_t in graph . alignments ( ) : [EOL] for i , index in enumerate ( indexes ) : [EOL] if i == [number] : [EOL] anon_surf [ index ] = new_quant_name [EOL] else : [EOL] anon_surf [ index ] = [string] [EOL] [EOL] [comment] [EOL] v2c [ conc ] = Concept ( new_quant_name ) [EOL] try : [EOL] output_triples . remove ( quant_t ) [EOL] except : [EOL] for triple in output_triples : [EOL] if triple [ [number] ] == quant_t [ [number] ] and triple [ [number] ] == quant_t [ [number] ] : [EOL] output_triples . remove ( triple ) [EOL] for triple in triples : [EOL] if triple [ [number] ] == conc and triple [ [number] ] == [string] : [EOL] output_t_index = output_triples . index ( triple ) [EOL] output_triples [ output_t_index ] = ( triple [ [number] ] , triple [ [number] ] , Concept ( new_quant_name ) ) [EOL] [EOL] return output_triples , anon_ids , anon_map , anon_surf [EOL] [EOL] [comment] [EOL] [EOL] def anonymize ( graph , surf ) : [EOL] [EOL] [comment] [EOL] triples = graph . triples ( ) [EOL] new_graph = deepcopy ( graph ) [EOL] [comment] [EOL] output_triples = new_graph . triples ( ) [EOL] v2c = new_graph . var2concept ( ) [EOL] [EOL] anon_ids = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] anon_map = { } [EOL] anon_surf = surf . split ( ) [EOL] output_triples , anon_ids , anon_map , anon_surf = anonymize_dates ( graph , triples , output_triples , v2c , anon_ids , anon_map , anon_surf ) [EOL] output_triples , anon_ids , anon_map , anon_surf = anonymize_nes ( graph , triples , output_triples , v2c , anon_ids , anon_map , anon_surf ) [EOL] output_triples , anon_ids , anon_map , anon_surf = anonymize_quants ( graph , triples , output_triples , v2c , anon_ids , anon_map , anon_surf ) [EOL] [EOL] anon_surf = [string] . join ( anon_surf ) . lower ( ) . split ( ) [comment] [EOL] return output_triples , v2c , anon_surf , anon_map [EOL] [EOL] [comment] [EOL] [EOL] def get_line_graph ( graph , surf , anon = False , scope = False ) : [EOL] triples = [ ] [EOL] nodes = { } [EOL] rev_nodes = [ ] [EOL] uniq = [number] [EOL] nodes_to_print = [ ] [EOL] graph_triples = graph . triples ( ) [EOL] if anon : [EOL] [comment] [EOL] [comment] [EOL] graph_triples , v2c , anon_surf , anon_map = anonymize ( graph , surf ) [EOL] anon_surf = [string] . join ( anon_surf ) [EOL] [comment] [EOL] nodes_scope = print_simplified ( graph_triples , v2c ) [EOL] nodes_scope = [string] . join ( nodes_scope ) [EOL] else : [EOL] graph_triples = graph . triples ( ) [EOL] v2c = graph . var2concept ( ) [EOL] anon_surf = surf [EOL] anon_map = None [EOL] nodes_scope = None [EOL] for triple in graph_triples : [EOL] src , edge , tgt = triple [EOL] [comment] [EOL] if edge == [string] : [EOL] [comment] [EOL] top_node = get_name ( tgt , v2c ) [EOL] continue [EOL] if edge == [string] or edge == [string] : [EOL] continue [EOL] [comment] [EOL] if src not in nodes : [EOL] nodes [ src ] = len ( nodes ) [EOL] rev_nodes . append ( src ) [EOL] src_id = nodes [ src ] [EOL] triples . append ( ( src_id , src_id , [string] ) ) [EOL] nodes_to_print . append ( get_name ( src , v2c ) ) [EOL] edge_uniq = edge + [string] + str ( uniq ) [EOL] uniq += [number] [EOL] nodes [ edge_uniq ] = len ( nodes ) [EOL] rev_nodes . append ( edge_uniq ) [EOL] edge_id = nodes [ edge_uniq ] [EOL] triples . append ( ( edge_id , edge_id , [string] ) ) [EOL] nodes_to_print . append ( edge ) [EOL] if tgt not in nodes : [EOL] nodes [ tgt ] = len ( nodes ) [EOL] rev_nodes . append ( tgt ) [EOL] tgt_id = nodes [ tgt ] [EOL] triples . append ( ( tgt_id , tgt_id , [string] ) ) [EOL] nodes_to_print . append ( get_name ( tgt , v2c ) ) [EOL] [comment] [EOL] src_id = nodes [ src ] [EOL] edge_id = nodes [ edge_uniq ] [EOL] tgt_id = nodes [ tgt ] [EOL] triples . append ( ( src_id , edge_id , [string] ) ) [EOL] triples . append ( ( edge_id , src_id , [string] ) ) [EOL] triples . append ( ( edge_id , tgt_id , [string] ) ) [EOL] triples . append ( ( tgt_id , edge_id , [string] ) ) [EOL] [comment] [EOL] [comment] [EOL] if scope and nodes_to_print != [ ] : [EOL] nodes_to_print , triples = add_scope_markers ( nodes_to_print , triples , top_node ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] if nodes_to_print == [ ] : [EOL] [comment] [EOL] triple = graph . triples ( ) [ [number] ] [EOL] nodes_to_print . append ( get_name ( triple [ [number] ] , v2c ) ) [EOL] triples . append ( ( [number] , [number] , [string] ) ) [EOL] return nodes_to_print , triples , anon_surf , anon_map , nodes_scope [EOL] [EOL] [comment] [EOL] [EOL] def add_scope_markers ( nodes , triples , top_node ) : [EOL] [docstring] [EOL] triples = set ( triples ) [EOL] [comment] [EOL] adj_list = build_adj_list ( triples ) [EOL] [EOL] [comment] [EOL] visited = [ False ] * len ( nodes ) [EOL] [EOL] [comment] [EOL] top_node_id = nodes . index ( top_node ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] stack = [ ] [EOL] add_marker ( nodes , triples , adj_list , top_node_id , stack , visited ) [EOL] return nodes , sorted ( list ( triples ) ) [EOL] [EOL] [comment] [EOL] [EOL] def add_marker ( nodes , triples , adj_list , node_id , stack , visited ) : [EOL] [docstring] [EOL] [comment] [EOL] node = nodes [ node_id ] [EOL] visited [ node_id ] = True [EOL] is_predicate = node . startswith ( [string] ) and len ( node ) > [number] [EOL] if is_predicate : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] child_id = list ( adj_list [ node_id ] ) [ [number] ] [EOL] except : [EOL] import ipdb ; ipdb . set_trace ( ) [EOL] has_gchild = has_child ( child_id , adj_list , visited ) [EOL] [comment] [EOL] [comment] [EOL] if has_gchild : [EOL] [comment] [EOL] nodes . append ( [string] ) [EOL] open_id = len ( nodes ) - [number] [EOL] nodes . append ( [string] ) [EOL] close_id = len ( nodes ) - [number] [EOL] stack . append ( close_id ) [comment] [EOL] [comment] [EOL] triples . add ( ( open_id , open_id , [string] ) ) [EOL] triples . add ( ( node_id , open_id , [string] ) ) [EOL] triples . add ( ( open_id , node_id , [string] ) ) [EOL] triples . add ( ( open_id , child_id , [string] ) ) [EOL] triples . add ( ( child_id , open_id , [string] ) ) [EOL] [EOL] triples . add ( ( close_id , close_id , [string] ) ) [EOL] triples . add ( ( node_id , close_id , [string] ) ) [EOL] triples . add ( ( close_id , node_id , [string] ) ) [EOL] [EOL] triples . remove ( ( node_id , child_id , [string] ) ) [EOL] triples . remove ( ( child_id , node_id , [string] ) ) [EOL] [comment] [EOL] add_marker ( nodes , triples , adj_list , child_id , stack , visited ) [EOL] [comment] [EOL] if has_gchild : [EOL] if len ( stack ) > [number] : [EOL] triples . add ( ( stack [ - [number] ] , stack [ - [number] ] , [string] ) ) [EOL] triples . add ( ( stack [ - [number] ] , stack [ - [number] ] , [string] ) ) [EOL] stack . pop ( ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] if has_child ( node_id , adj_list , visited ) : [EOL] for child_id in adj_list [ node_id ] : [EOL] add_marker ( nodes , triples , adj_list , child_id , stack , visited ) [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] [comment] [EOL] if len ( stack ) > [number] : [EOL] curr_id = stack [ - [number] ] [EOL] triples . add ( ( curr_id , node_id , [string] ) ) [EOL] triples . add ( ( node_id , curr_id , [string] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def has_child ( node_id , adj_list , visited ) : [EOL] [docstring] [EOL] if adj_list [ node_id ] == set ( ) : [EOL] return False [EOL] else : [EOL] [comment] [EOL] result = True [EOL] for child in adj_list [ node_id ] : [EOL] if visited [ child ] : [EOL] result = False [EOL] return result [EOL] [EOL] [comment] [EOL] [EOL] def build_adj_list ( triples ) : [EOL] adj_list = defaultdict ( set ) [EOL] for triple in triples : [EOL] if triple [ [number] ] == [string] : [EOL] adj_list [ triple [ [number] ] ] . add ( triple [ [number] ] ) [EOL] [comment] [EOL] return adj_list [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def print_simplified ( graph_triples , v2c ) : [EOL] [docstring] [EOL] s = [ ] [EOL] stack = [ ] [EOL] instance_fulfilled = None [EOL] concept_stack_depth = { None : [number] } [comment] [EOL] [EOL] [comment] [EOL] for h , r , d in graph_triples + [ ( None , None , None ) ] : [EOL] if r == [string] : [EOL] s . append ( [string] ) [EOL] s . append ( get_name ( d , v2c ) ) [EOL] stack . append ( ( h , r , d ) ) [EOL] instance_fulfilled = False [EOL] elif r == [string] : [EOL] instance_fulfilled = True [EOL] concept_stack_depth [ h ] = len ( stack ) [EOL] else : [EOL] while len ( stack ) > concept_stack_depth [ h ] : [EOL] h2 , r2 , d2 = stack . pop ( ) [EOL] if instance_fulfilled is False : [EOL] s . pop ( ) [EOL] s . pop ( ) [EOL] s . append ( get_name ( d2 , v2c ) ) [EOL] else : [EOL] s . append ( [string] ) [EOL] instance_fulfilled = None [EOL] if d is not None : [EOL] s . append ( r ) [EOL] s . append ( [string] ) [EOL] s . append ( get_name ( d , v2c ) ) [EOL] stack . append ( ( h , r , d ) ) [EOL] instance_fulfilled = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] final_s = [ ] [EOL] skip = False [EOL] for i , token in enumerate ( s [ : - [number] ] ) : [EOL] if token == [string] : [EOL] if s [ i + [number] ] == [string] : [EOL] skip = True [EOL] if not skip : [EOL] final_s . append ( token ) [EOL] elif token == [string] : [EOL] if not skip : [EOL] final_s . append ( token ) [EOL] skip = False [EOL] else : [EOL] final_s . append ( token ) [EOL] [comment] [EOL] final_s . append ( s [ - [number] ] ) [EOL] if len ( s ) == [number] : [EOL] [comment] [EOL] return s [ [number] : [number] ] [EOL] [comment] [EOL] return final_s [ [number] : ] [EOL] [comment] [EOL] [EOL] def main ( args ) : [EOL] [EOL] [comment] [EOL] with open ( args . input_amr ) as f : [EOL] amrs = f . readlines ( ) [EOL] with open ( args . input_surface ) as f : [EOL] surfs = f . readlines ( ) [EOL] [EOL] if args . triples_output is not None : [EOL] triples_out = open ( args . triples_output , [string] ) [EOL] [EOL] [comment] [EOL] anon_surfs = [ ] [EOL] anon_maps = [ ] [EOL] nodes_list_scope = [ ] [EOL] i = [number] [EOL] with open ( args . output , [string] ) as out , open ( args . output_surface , [string] ) as surf_out : [EOL] for amr , surf in zip ( amrs , surfs ) : [EOL] graph = AMR ( amr , surf . split ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if args . mode == [string] : [EOL] [comment] [EOL] [EOL] tokens = amr . split ( ) [EOL] new_tokens = simplify ( tokens , v2c ) [EOL] out . write ( [string] . join ( new_tokens ) + [string] ) [EOL] [EOL] elif args . mode == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_ids , rev_v_ids = get_nodes2 ( graph ) [EOL] [EOL] [comment] [EOL] triples = get_triples ( graph , v_ids , rev_v_ids ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cs = [ get_name ( v , v2c ) for v in rev_v_ids ] [EOL] out . write ( [string] . join ( cs ) + [string] ) [EOL] triples_out . write ( [string] . join ( [ [string] + [string] . join ( adj ) + [string] for adj in triples ] ) + [string] ) [EOL] [EOL] elif args . mode == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] i += [number] [EOL] [comment] [EOL] [comment] [EOL] nodes , triples , anon_surf , anon_map , nodes_scope = get_line_graph ( graph , surf , anon = args . anon , scope = args . scope ) [EOL] out . write ( [string] . join ( nodes ) + [string] ) [EOL] triples_out . write ( [string] . join ( [ [string] % adj for adj in triples ] ) + [string] ) [EOL] [comment] [EOL] anon_surfs . append ( anon_surf ) [EOL] anon_maps . append ( json . dumps ( anon_map ) ) [EOL] nodes_list_scope . append ( nodes_scope ) [EOL] [EOL] [comment] [EOL] surf_out . write ( surf . lower ( ) ) [EOL] if args . anon : [EOL] with open ( args . anon_surface , [string] ) as f : [EOL] for anon_surf in anon_surfs : [EOL] f . write ( anon_surf + [string] ) [EOL] with open ( args . map_output , [string] ) as f : [EOL] for anon_map in anon_maps : [EOL] f . write ( anon_map + [string] ) [EOL] with open ( args . nodes_scope , [string] ) as f : [EOL] for nodes_scope in nodes_list_scope : [EOL] f . write ( nodes_scope + [string] ) [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] , choices = [ [string] , [string] , [string] ] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = None , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] assert ( args . triples_output is not None ) or ( args . mode != [string] ) , [string] [EOL] assert ( args . map_output is not None ) or ( not args . anon ) , [string] [EOL] assert ( args . anon_surface is not None ) or ( not args . anon ) , [string] [EOL] [EOL] SENSE_PATTERN = re . compile ( [string] ) [EOL] [EOL] main ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0
from typing import List , Any [EOL] import io [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] [EOL] def add_global_node ( dirt , name ) : [EOL] [EOL] f1 = open ( dirt + name + [string] , [string] ) [EOL] f2 = open ( dirt + name + [string] , [string] ) [EOL] h1 = open ( dirt + name + [string] , [string] ) [EOL] h2 = open ( dirt + name + [string] , [string] ) [EOL] index_list = [ ] [EOL] node = [string] [EOL] for line in f1 : [EOL] toks = line . strip ( ) . split ( ) [EOL] for t in toks : [EOL] h1 . write ( str ( t ) + [string] ) [EOL] h1 . write ( str ( node ) + [string] ) [EOL] index_list . append ( len ( toks ) ) [EOL] i = [number] [EOL] for line in f2 : [EOL] deps = line . strip ( ) . split ( ) [EOL] for d in deps : [EOL] h2 . write ( str ( d ) + [string] ) [EOL] index = index_list [ i ] [EOL] for j in range ( index ) : [EOL] d1 = [string] + str ( index ) + [string] + str ( j ) + [string] [EOL] h2 . write ( d1 + [string] ) [EOL] d3 = [string] + str ( index ) + [string] + str ( index ) + [string] [EOL] h2 . write ( d3 + [string] ) [EOL] i += [number] [EOL] [EOL] [EOL] def gen_amrgrh ( dirt , name ) : [EOL] [EOL] file_4 = dirt + name + [string] [EOL] file_5 = dirt + name + [string] [EOL] file_6 = dirt + name + [string] [EOL] h4 = open ( file_4 , [string] ) [EOL] h5 = open ( file_5 , [string] ) [EOL] h6 = open ( file_6 , [string] ) [EOL] toks = [ ] [EOL] deps = [ ] [EOL] for line in h4 : [EOL] seg = line . strip ( ) . split ( ) [EOL] toks . append ( seg ) [EOL] for line in h5 : [EOL] seg = line . strip ( ) . split ( ) [EOL] deps . append ( seg ) [EOL] L = len ( toks ) [EOL] if len ( toks ) != len ( deps ) : [EOL] print ( [string] ) [EOL] for i in range ( L ) : [EOL] tok = toks [ i ] [EOL] dep = deps [ i ] [EOL] for j in range ( len ( tok ) ) : [EOL] h6 . write ( str ( tok [ j ] ) + [string] ) [EOL] h6 . write ( [string] ) [EOL] for j in range ( len ( dep ) ) : [EOL] h6 . write ( str ( dep [ j ] ) + [string] ) [EOL] h6 . write ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [comment] [EOL] [comment] [EOL] args = parser . parse_args ( ) [EOL] name_list = [ [string] , [string] , [string] ] [EOL] for name in name_list : [EOL] add_global_node ( args . input_dir , name ) [EOL] gen_amrgrh ( args . input_dir , name ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Dict [EOL] import typing [EOL] NE_CLUSTER = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] QUANT_CLUSTER = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import argparse [EOL] import typing [EOL] from graphviz import Digraph [EOL] import argparse [EOL] [EOL] [EOL] def gen_dot ( nodes , triples ) : [EOL] dot = Digraph ( ) [EOL] node_ids = nodes . split ( ) [EOL] new_nodes = [ ] [EOL] for i , node in enumerate ( node_ids ) : [EOL] if node . startswith ( [string] ) : [EOL] new_node = node [ [number] : ] . upper ( ) + [string] + str ( i ) [EOL] else : [EOL] new_node = node + [string] + str ( i ) [EOL] dot . node ( new_node ) [EOL] new_nodes . append ( new_node ) [EOL] for triple in triples . split ( ) : [EOL] src , tgt , label = triple [ [number] : - [number] ] . split ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dot . edge ( new_nodes [ int ( src ) ] , new_nodes [ int ( tgt ) ] , label = label ) [EOL] dot . view ( ) [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str ) [EOL] parser . add_argument ( [string] , type = str ) [EOL] [comment] [EOL] parser . add_argument ( [string] , type = int , default = [number] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] [EOL] with open ( args . input_nodes ) as f : [EOL] nodes_lines = f . readlines ( ) [EOL] with open ( args . input_triples ) as f : [EOL] triples_lines = f . readlines ( ) [EOL] [EOL] i = [number] [EOL] for nodes , triples in zip ( nodes_lines , triples_lines ) : [EOL] if i == args . index : [EOL] dot = gen_dot ( nodes , triples ) [EOL] i += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.int$ 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from sockeye_contrib . sacrebleu . sacrebleu import raw_corpus_bleu , compute_bleu , corpus_chrf , CHRF_ORDER , CHRF_BETA , sentence_bleu , sentence_chrf	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Tuple , Any [EOL] import filecmp [EOL] import typing [EOL] import os [EOL] import pytest [EOL] from filecmp import dircmp [EOL] [EOL] from generate_graphs import generate [EOL] [EOL] CWD = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] [EOL] BEAM_COMPARISONS = [ ( os . path . join ( CWD , [string] , [string] ) , os . path . join ( CWD , [string] , [string] ) ) ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , BEAM_COMPARISONS ) def test_beam_generation ( beams , expected_output , tmpdir ) : [EOL] generate ( beams , str ( tmpdir ) ) [EOL] [EOL] [comment] [EOL] result = dircmp ( expected_output , str ( tmpdir ) ) [EOL] assert result . left_list == result . right_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0