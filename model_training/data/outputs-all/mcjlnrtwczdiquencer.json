	0
import diquencer [EOL] from unittest import TestCase [EOL] [EOL] from diquencer . models import Position [EOL] [EOL] [EOL] class TestPosition ( TestCase ) : [EOL] def test_pulses_below ( self ) : [EOL] position = Position ( [number] ) [EOL] self . assertEqual ( position . pulses , [number] ) [EOL] self . assertEqual ( position . beats , [number] ) [EOL] self . assertEqual ( position . measures , [number] ) [EOL] [EOL] def test_pulses_zero ( self ) : [EOL] position = Position ( [number] ) [EOL] self . assertEqual ( position . pulses , [number] ) [EOL] self . assertEqual ( position . beats , [number] ) [EOL] self . assertEqual ( position . measures , [number] ) [EOL] [EOL] def test_pulses_above ( self ) : [EOL] position = Position ( [number] ) [EOL] self . assertEqual ( position . pulses , [number] ) [EOL] self . assertEqual ( position . beats , [number] ) [EOL] self . assertEqual ( position . measures , [number] ) [EOL] [EOL] def test_measures ( self ) : [EOL] position = Position ( [number] ) [EOL] self . assertEqual ( position . pulses , [number] ) [EOL] self . assertEqual ( position . beats , [number] ) [EOL] self . assertEqual ( position . measures , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0 0 0 0 0 $diquencer.models.Position$ 0 0 0 0 0 0
from typing import Union , Any , Literal [EOL] import typing_extensions [EOL] import diquencer [EOL] import threading [EOL] import typing [EOL] import logging [EOL] from threading import Event , Thread [EOL] from time import perf_counter , sleep [EOL] [EOL] from . events import MuteEvent , PatternEvent , StopEvent [EOL] from . exceptions import ChangePatternError , InvalidBank [EOL] from . midi_wrapper import Mute [EOL] from . models import Position [EOL] [EOL] [EOL] class SequencerEngine ( Thread ) : [EOL] def __init__ ( self , sequence , midi_wrapper , start_callback = None , error_callback = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _sequence = sequence [EOL] self . _midi = midi_wrapper [EOL] self . _start_callback = start_callback [EOL] self . _error_callback = error_callback [EOL] self . _pulsestamp = [number] [EOL] self . _stop_event = Event ( ) [EOL] self . _pulse_duration = [number] / self . _sequence . tempo / [number] [EOL] self . current_pattern = None [EOL] self . next_pattern = None [EOL] [EOL] @ property def position ( self ) : [EOL] return Position ( self . _pulsestamp ) [EOL] [EOL] def run ( self ) : [EOL] logging . info ( f" [string] { self . position } [string] " ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . _change_pattern ( self . _sequence . consume_event ( self . _pulsestamp ) ) [EOL] except ChangePatternError : [EOL] return [EOL] [EOL] [comment] [EOL] mute_event = self . _sequence . consume_event ( self . _pulsestamp ) [EOL] self . _play_tracks ( mute_event . playing_tracks ) [EOL] logging . info ( f" [string] { self . position } [string] " f"{ mute_event . playing_tracks } [string] " ) [EOL] [EOL] [comment] [EOL] for _ in range ( [number] * [number] ) : [EOL] self . _pulse ( ) [EOL] [EOL] [comment] [EOL] if self . _start_callback : [EOL] self . _start_callback ( ) [EOL] self . _midi . start ( ) [EOL] [EOL] [comment] [EOL] while not self . _stop_event . is_set ( ) : [EOL] self . _pulse ( ) [EOL] event = self . _sequence . consume_event ( self . _pulsestamp ) [EOL] if isinstance ( event , StopEvent ) : [EOL] self . current_pattern = None [EOL] break [EOL] elif isinstance ( event , PatternEvent ) : [EOL] try : [EOL] self . _change_pattern ( event ) [EOL] except ChangePatternError : [EOL] return [EOL] elif isinstance ( event , MuteEvent ) : [EOL] self . _play_tracks ( event . playing_tracks ) [EOL] logging . info ( f" [string] { self . position } [string] " f"{ event . playing_tracks } [string] " ) [EOL] self . _pulsestamp += [number] [EOL] [EOL] self . _midi . stop ( ) [EOL] logging . info ( f" [string] { self . position } [string] " ) [EOL] [EOL] self . _sequence . reset ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . _stop_event . set ( ) [EOL] [EOL] def _pulse ( self ) : [EOL] self . _midi . tick ( ) [EOL] start = perf_counter ( ) [EOL] while perf_counter ( ) < start + self . _pulse_duration : [EOL] sleep ( [number] ) [EOL] [EOL] def _play_tracks ( self , playing_tracks ) : [EOL] for track in range ( [number] , [number] ) : [EOL] state = Mute . OFF if track in playing_tracks else Mute . ON [EOL] self . _midi . mute ( track , state ) [EOL] [EOL] def _cleanup_after_abort ( self , error ) : [EOL] self . _midi . stop ( ) [EOL] self . _sequence . reset ( ) [EOL] logging . critical ( [string] , exc_info = True ) [EOL] if self . _error_callback : [EOL] self . _error_callback ( error ) [EOL] [EOL] def _change_pattern ( self , event ) : [EOL] pattern = event . pattern [EOL] try : [EOL] self . _midi . change_pattern ( pattern . bank_id , pattern . pattern_id ) [EOL] except InvalidBank as error : [EOL] self . _cleanup_after_abort ( error ) [EOL] raise ChangePatternError ( ) [EOL] logging . info ( f" [string] { self . position } [string] { pattern } [string] " ) [EOL] self . current_pattern = pattern [EOL] self . next_pattern = self . _sequence . next_pattern [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[diquencer.midi_wrapper.Mute.OFF],typing_extensions.Literal[diquencer.midi_wrapper.Mute.ON]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[diquencer.midi_wrapper.Mute.OFF],typing_extensions.Literal[diquencer.midi_wrapper.Mute.ON]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . sequencer import Sequencer [comment] [EOL]	0 0 0 0 0 0 0
class Position : [EOL] def __init__ ( self , pulses ) : [EOL] self . pulses = pulses % [number] [EOL] self . beats = int ( pulses / [number] ) % [number] [EOL] self . measures = int ( pulses / ( [number] * [number] ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] [comment] [EOL] return [string] . format ( str ( self . measures ) . zfill ( [number] ) , self . beats , str ( self . pulses ) . zfill ( [number] ) ) [EOL] [EOL] [EOL] class Pattern : [EOL] def __init__ ( self , name , pattern_id , bank_id , length ) : [EOL] self . name = name [EOL] self . pattern_id = pattern_id [EOL] self . bank_id = bank_id [EOL] self . length = length [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . bank_id }{ str ( self . pattern_id ) . zfill ( [number] ) } [string] { self . name }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import builtins [EOL] import typing [EOL] from enum import Enum [EOL] [EOL] import rtmidi [EOL] from rtmidi . midiconstants import PROGRAM_CHANGE , SONG_START , SONG_STOP , TIMING_CLOCK [EOL] [EOL] from . exceptions import InvalidBank , MIDIOutputError [EOL] [EOL] [EOL] class Mute ( Enum ) : [EOL] ON = [number] [EOL] OFF = [number] [EOL] [EOL] [EOL] class MIDIWrapper : [EOL] [EOL] BANKS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , channel = [number] ) : [EOL] self . channel = channel [EOL] self . _midi_out = rtmidi . MidiOut ( ) [EOL] self . _ports = self . _midi_out . get_ports ( ) [EOL] [EOL] @ property def output_ports ( self ) : [EOL] return self . _ports [EOL] [EOL] def raise_if_port_closed ( self ) : [EOL] if not self . _midi_out . is_port_open ( ) : [EOL] raise MIDIOutputError ( [string] ) [EOL] [EOL] def set_output_port ( self , port ) : [EOL] try : [EOL] port_id = self . _ports . index ( port ) [EOL] except ValueError : [EOL] raise MIDIOutputError ( [string] ) [EOL] [EOL] self . _midi_out . close_port ( ) [EOL] try : [EOL] self . _midi_out . open_port ( port_id ) [EOL] except rtmidi . InvalidPortError : [EOL] raise MIDIOutputError ( [string] ) [EOL] [EOL] def change_pattern ( self , bank , pattern ) : [EOL] try : [EOL] bank_number = self . BANKS . index ( bank ) [EOL] self . _midi_out . send_message ( [ PROGRAM_CHANGE + self . channel - [number] , ( pattern - [number] ) + bank_number * [number] ] ) [EOL] except ValueError : [EOL] raise InvalidBank ( f" [string] { bank } [string] " ) [EOL] [EOL] def start ( self ) : [EOL] self . _midi_out . send_message ( [ SONG_START ] ) [EOL] [EOL] def stop ( self ) : [EOL] self . _midi_out . send_message ( [ SONG_STOP ] ) [EOL] [EOL] def tick ( self ) : [EOL] self . _midi_out . send_message ( [ TIMING_CLOCK ] ) [EOL] [EOL] def mute ( self , track , mute_state ) : [EOL] self . _midi_out . send_message ( ( [number] + track , [number] , mute_state . value ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $Mute$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $Mute$ 0 0 0 0 0
from . models import Position [EOL] [EOL] [EOL] class SequenceEvent : [EOL] def __init__ ( self , pulsestamp ) : [EOL] self . pulsestamp = pulsestamp [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { Position ( self . pulsestamp ) }" [EOL] [EOL] [EOL] class MuteEvent ( SequenceEvent ) : [EOL] def __init__ ( self , pulsestamp , playing_tracks ) : [EOL] super ( ) . __init__ ( pulsestamp ) [EOL] self . playing_tracks = playing_tracks [EOL] [EOL] [EOL] class PatternEvent ( SequenceEvent ) : [EOL] def __init__ ( self , pulsestamp , pattern , repetitions ) : [EOL] super ( ) . __init__ ( pulsestamp ) [EOL] self . pattern = pattern [EOL] self . repetitions = repetitions [EOL] [EOL] [EOL] class StopEvent ( SequenceEvent ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class DiquencerException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SequencerTransportError ( DiquencerException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SequenceNotSet ( DiquencerException ) : [EOL] pass [EOL] [EOL] [EOL] class MIDIOutputError ( DiquencerException ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidBank ( DiquencerException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ChangePatternError ( DiquencerException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0