import 家具摆放1 [EOL] class House_item ( object ) : [EOL] [EOL] def __init__ ( self , name , area ) : [EOL] self . name = name [EOL] self . area = area [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] % ( self . name , self . area ) ) [EOL] [EOL] class House : [EOL] def __init__ ( self , house_type , area ) : [EOL] self . house_type = house_type [EOL] self . area = area [EOL] self . free_area = area [EOL] self . item_list = [ ] [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] % ( self . house_type , self . area , self . free_area , self . item_list ) ) [EOL] [EOL] def add_item ( self , item ) : [EOL] print ( [string] % item ) [EOL] if float ( item . area ) > self . free_area : [EOL] print ( [string] % item . name ) [EOL] return [EOL] self . item_list . append ( item . name ) [EOL] self . free_area -= float ( item . area ) [EOL] [EOL] [EOL] bed = House_item ( [string] , [string] ) [EOL] chest = House_item ( [string] , [string] ) [EOL] table = House_item ( [string] , [string] ) [EOL] print ( bed ) [EOL] print ( chest ) [EOL] print ( table ) [EOL] [EOL] My_house = House ( [string] , [number] ) [EOL] My_house . add_item ( bed ) [EOL] My_house . add_item ( chest ) [EOL] My_house . add_item ( table ) [EOL] [EOL] print ( My_house ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $家具摆放1.House_item$ 0 0 0 0 0 0 0 0 $家具摆放1.House_item$ 0 0 0 0 0 0 0 0 $家具摆放1.House_item$ 0 0 0 0 0 0 0 0 0 0 $家具摆放1.House_item$ 0 0 0 0 $家具摆放1.House_item$ 0 0 0 0 $家具摆放1.House_item$ 0 0 0 $家具摆放1.House$ 0 0 0 0 0 0 0 0 $家具摆放1.House$ 0 0 0 $家具摆放1.House_item$ 0 0 $家具摆放1.House$ 0 0 0 $家具摆放1.House_item$ 0 0 $家具摆放1.House$ 0 0 0 $家具摆放1.House_item$ 0 0 0 0 0 $家具摆放1.House$ 0 0
import 家具摆放 [EOL] class House_item ( object ) : [EOL] def __init__ ( self , name , area ) : [EOL] self . name = name [EOL] self . area = area [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . name , self . area ) [EOL] [EOL] class House : [EOL] def __init__ ( self , house_type , area ) : [EOL] self . house_type = house_type [EOL] self . area = area [EOL] self . free_area = area [EOL] self . item_list = [ ] [EOL] [EOL] def __str__ ( self ) : [EOL] [EOL] return ( [string] % ( self . house_type , self . area , self . free_area , self . item_list ) ) [EOL] [EOL] def add_item ( self , item ) : [EOL] print ( [string] % item . name ) [EOL] if float ( item . area ) > self . free_area : [EOL] print ( [string] % item . name ) [EOL] return [EOL] self . item_list . append ( item . name ) [EOL] self . free_area -= float ( item . area ) [EOL] [EOL] bed = House_item ( [string] , [string] ) [EOL] chest = House_item ( [string] , [string] ) [EOL] table = House_item ( [string] , [string] ) [EOL] print ( bed ) [EOL] print ( chest ) [EOL] print ( table ) [EOL] [EOL] M_huose = House ( [string] , [number] ) [EOL] M_huose . add_item ( bed ) [EOL] M_huose . add_item ( chest ) [EOL] M_huose . add_item ( table ) [EOL] [EOL] print ( M_huose ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $家具摆放.House_item$ 0 0 0 0 0 0 0 0 $家具摆放.House_item$ 0 0 0 0 0 0 0 0 $家具摆放.House_item$ 0 0 0 0 0 0 0 0 0 0 $家具摆放.House_item$ 0 0 0 0 $家具摆放.House_item$ 0 0 0 0 $家具摆放.House_item$ 0 0 0 $家具摆放.House$ 0 0 0 0 0 0 0 0 $家具摆放.House$ 0 0 0 $家具摆放.House_item$ 0 0 $家具摆放.House$ 0 0 0 $家具摆放.House_item$ 0 0 $家具摆放.House$ 0 0 0 $家具摆放.House_item$ 0 0 0 0 0 $家具摆放.House$ 0 0 0 0 0
[EOL] name = [string] [EOL] print ( name ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] name = [string] [EOL] print ( name . lower ( ) ) [EOL] print ( name . upper ( ) ) [EOL] print ( name . title ( ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] name = [string] [EOL] celebrated_dictum = [string] [EOL] said = name + celebrated_dictum [EOL] print ( said ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] famous_person = [string] [EOL] message = ( [string] % famous_person ) [EOL] print ( message ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] string = [string] [EOL] print ( [string] ) [EOL] print ( string ) [EOL] [EOL] stringA = [string] [EOL] print ( [string] ) [EOL] print ( stringA ) [EOL] [EOL] stringA = stringA . rstrip ( ) [EOL] stringA = stringA . lstrip ( ) [EOL] print ( [string] ) [EOL] print ( stringA ) [EOL] [EOL] [EOL] [EOL]	0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[EOL] print ( [number] * [number] ) [EOL] print ( [number] + [number] + [number] + [number] ) [EOL] print ( int ( [number] / [number] ) ) [EOL] print ( [number] - [number] ) [EOL] [EOL] [EOL] [EOL] fav_number = [number] [EOL] print ( [string] + str ( fav_number ) ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] like = [string] [EOL] shuzi = [string] [EOL] like = input ( [string] ) [EOL] if like == [string] : [EOL] print ( like ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
message = [string] [EOL] print ( message ) [EOL] [EOL] message = [string] [EOL] print ( message ) [EOL] [EOL]	$builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0
message = [string] [EOL] print ( message ) [EOL]	$builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] name = [string] [EOL] age = [string] [EOL] school = [string] [EOL] print ( name ) [EOL] print ( age ) [EOL] print ( school ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] time = input ( [string] ) [EOL] print ( [string] % time ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] sandwich_orders = [ [string] , [string] , [string] ] [EOL] finished_sandwiches = [ ] [EOL] [docstring] [EOL] a = True [EOL] while a : [EOL] if int ( len ( sandwich_orders ) ) != [number] : [EOL] sandwich = sandwich_orders . pop ( ) [EOL] finished_sandwiches . insert ( [number] , sandwich ) [EOL] else : [EOL] a = False [EOL] print ( finished_sandwiches ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] sandwich_orders = [ [string] , [string] , [string] , [string] ] [EOL] print ( sandwich_orders ) [EOL] while [string] in sandwich_orders : [EOL] sandwich_orders . remove ( [string] ) [EOL] print ( sandwich_orders ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] name = input ( [string] ) [EOL] land = input ( [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[EOL] car = input ( [string] ) [EOL] print ( [string] + car ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] eat = int ( input ( [string] ) ) [EOL] if eat >= [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] use = int ( input ( [string] ) ) [EOL] if use % [number] == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL]	0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import python假期作业 [EOL] class User ( object ) : [EOL] def __init__ ( self ) : [EOL] self . __frist_name = frist_name [EOL] self . __last_name = last_name [EOL] self . __addr = addr [EOL] [EOL] def getFrist_name ( self ) : [EOL] return self . __frist_name [EOL] [EOL] def getLast_name ( self ) : [EOL] return self . __last_name [EOL] [EOL] def getAddr ( self ) : [EOL] return self . __addr [EOL] [EOL] def setFrist_name ( self , newfrist_name ) : [EOL] self . __frist_name = newfrist_name [EOL] return self . __frist_name [EOL] [EOL] def setLast_name ( self , newlast_name ) : [EOL] self . __last_name = newlast_name [EOL] return self . __last_name [EOL] [EOL] def setAddr ( self , newaddr ) : [EOL] self . __addr = newaddr [EOL] return self . __addr [EOL] [EOL] [EOL] def describe_User ( self ) : [EOL] print ( self . frist_name ) [EOL] print ( self . last_name ) [EOL] [EOL] def greet_user ( self ) : [EOL] print ( [string] % self . __frist_name , __last_name ) [EOL] [EOL] [EOL] a = User [EOL] a . selffrist_name ( [string] ) [EOL] a . selflast_name ( [string] ) [EOL] a . selfaddr ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[python假期作业.python作业.作业1.User]$ 0 0 0 $typing.Type[python假期作业.python作业.作业1.User]$ 0 0 0 0 0 0 $typing.Type[python假期作业.python作业.作业1.User]$ 0 0 0 0 0 0 $typing.Type[python假期作业.python作业.作业1.User]$ 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] Add = [ [string] , [string] , [string] , [string] , [string] ] [EOL] for i in Add : [EOL] if i == [string] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] Adds = [ ] [EOL] Add = [ [string] , [string] , [string] , [string] , [string] ] [EOL] if Add not in Adds : [EOL] print ( [string] ) [EOL] for i in Add : [EOL] if i == [string] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] current_users = [ [string] , [string] , [string] , [string] , [string] ] [EOL] new_users = [ [string] , [string] , [string] , [string] , [string] ] [EOL] for i in new_users : [EOL] i = i . lower ( ) [EOL] if i in current_users : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] numbers = list ( range ( [number] , [number] ) ) [EOL] for list in numbers : [EOL] if list == [number] : [EOL] print ( [string] ) [EOL] elif list == [number] : [EOL] print ( [string] ) [EOL] elif list == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] alien_color = [ [string] , [string] , [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] [EOL] alien_color = [ [string] , [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] alien_color = [ [string] , [string] , [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] alien_color = [ [string] , [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] alien_color = [ [string] , [string] , [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] elif [string] in alien_color : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] alien_color = [ [string] , [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] elif [string] in alien_color : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] alien_color = [ [string] ] [EOL] if [string] in alien_color : [EOL] print ( [string] ) [EOL] elif [string] in alien_color : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] age = int ( input ( [string] ) ) [EOL] if age < [number] : [EOL] print ( [string] ) [EOL] elif [number] <= age < [number] : [EOL] print ( [string] ) [EOL] elif [number] <= age < [number] : [EOL] print ( [string] ) [EOL] elif [number] <= age < [number] : [EOL] print ( [string] ) [EOL] elif [number] <= age < [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] fruit = [ [string] , [string] , [string] , ] [EOL] if [string] in fruit : [EOL] print ( [string] ) [EOL] if [string] in fruit : [EOL] print ( [string] ) [EOL] if [string] in fruit : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
[EOL] from typing import List , Any , Set [EOL] import typing [EOL] names = { [string] , [string] , [string] , [string] } [EOL] def show_magicians ( ) : [EOL] for mag_names in names : [EOL] print ( mag_names ) [EOL] [EOL] show_magicians ( ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] names = { [string] , [string] , [string] , [string] } [EOL] mag_names = [ ] [EOL] def make_great ( names , mag_names ) : [EOL] while names : [EOL] mag = names . pop ( ) [EOL] mag = [string] + mag [EOL] mag_names . append ( mag ) [EOL] [EOL] def show_magicians ( mag_names ) : [EOL] for name in mag_names : [EOL] print ( name ) [EOL] [EOL] make_great ( names , mag_names ) [EOL] show_magicians ( mag_names ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] names = { [string] , [string] , [string] , [string] } [EOL] mag_names = [ ] [EOL] def make_great ( names , mag_names ) : [EOL] while names : [EOL] mag = names . pop ( ) [EOL] mag = [string] + mag [EOL] mag_names . append ( mag ) [EOL] [EOL] def show_magicians ( mag_names ) : [EOL] for name in mag_names : [EOL] print ( name ) [EOL] [EOL] make_great ( names , mag_names ) [EOL] show_magicians ( names ) [EOL] show_magicians ( mag_names ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
[EOL] from typing import Dict , Any [EOL] import typing [EOL] def city_country ( city_name , country ) : [EOL] c_country = city_name + [string] + country [EOL] return c_country [EOL] [EOL] city = city_country ( [string] , [string] ) [EOL] cityA = city_country ( [string] , [string] ) [EOL] cityB = city_country ( [string] , [string] ) [comment] [EOL] print ( city ) [EOL] print ( cityA ) [EOL] print ( cityB ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def make_album ( Artist , album , song_num = [string] ) : [EOL] if song_num : [EOL] ge = { [string] : Artist , [string] : album , [string] : song_num } [EOL] else : [EOL] ge = { [string] : Artist , [string] : album } [EOL] return ge [EOL] [EOL] singer = make_album ( [string] , [string] ) [EOL] singerA = make_album ( [string] , [string] ) [EOL] singerB = make_album ( [string] , [string] ) [EOL] print ( singer ) [EOL] print ( singerA ) [EOL] print ( singerB ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def make_album ( Artist , album , song_num = [string] ) : [EOL] if song_num : [EOL] ge = { [string] : Artist , [string] : album , [string] : song_num } [EOL] else : [EOL] ge = { [string] : Artist , [string] : album } [EOL] return ge [EOL] [EOL] Arist = input ( [string] ) [EOL] album = input ( [string] ) [EOL] [EOL] while True : [EOL] ge = input ( Arist ) [EOL] shou = input ( album ) [EOL] if ge == [string] or shou == [string] : [EOL] break [EOL] else : [EOL] singer = make_album ( ge , shou ) [EOL] print ( singer ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[EOL] def make_shirt ( size , Words ) : [EOL] print ( [string] + size + [string] + Words + [string] ) [EOL] [EOL] make_shirt ( [string] , [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def make_shirt ( size , Words ) : [EOL] print ( [string] + size + [string] + Words + [string] ) [EOL] [EOL] make_shirt ( [string] , [string] ) [EOL] make_shirt ( [string] , [string] ) [EOL] make_shirt ( [string] , [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def describe_city ( city_name , country = [string] ) : [EOL] print ( city_name + [string] + country + [string] ) [EOL] [EOL] describe_city ( [string] ) [EOL] describe_city ( [string] ) [EOL] describe_city ( [string] , [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , Any [EOL] import typing [EOL] def sandwich_eat ( * food ) : [EOL] print ( [string] ) [EOL] for i in food : [EOL] print ( i ) [EOL] [EOL] sandwich_eat ( [string] , [string] , [string] , [string] ) [EOL] sandwich_eat ( [string] ) [EOL] sandwich_eat ( [string] , [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def build_profile ( first , last , ** user_info ) : [EOL] [EOL] profile = { } [EOL] profile [ [string] ] = first [EOL] profile [ [string] ] = last [EOL] [EOL] for k , v in user_info . items ( ) : [EOL] profile [ k ] = v [EOL] return profile [EOL] [EOL] user = build_profile ( [string] , [string] , location = [string] , field = [string] ) [EOL] print ( user ) [EOL] userA = build_profile ( [string] , [string] , field = [string] ) [EOL] print ( userA ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def car_message ( car_name , car_trait , ** car ) : [EOL] car_m = { } [EOL] car_m [ [string] ] = car_name [EOL] car_m [ [string] ] = car_trait [EOL] [EOL] for k , v in car . items ( ) : [EOL] car_m [ k ] = v [EOL] return car_m [EOL] [EOL] car = car_message ( [string] , [string] , color = [string] , tow_package = True ) [EOL] print ( car ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List , Any , Type [EOL] import typing [EOL] [docstring] [EOL] num = list ( range ( [number] , [number] , [number] ) ) [EOL] num1 = [ ] [EOL] for i in num : [EOL] i = i ** [number] [EOL] num1 . append ( i ) [EOL] print ( num1 ) [EOL] [EOL] [EOL] [EOL] list = [ valce ** [number] for valce in range ( [number] , [number] ) ] [EOL] print ( list ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import builtins [EOL] from typing import List , Any , Type [EOL] import typing [EOL] list = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] print ( [string] ) [EOL] list1 = list [ [number] : [number] ] [EOL] for i in list1 : [EOL] print ( i ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] for i in list [ [number] : [number] ] : [EOL] print ( i ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] for i in list [ - [number] : ] : [EOL] print ( i ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] Pizza = [ [string] , [string] , [string] ] [EOL] [EOL] friend_pizzas = Pizza [ : ] [EOL] Pizza . append ( [string] ) [EOL] friend_pizzas . append ( [string] ) [EOL] print ( Pizza ) [EOL] print ( friend_pizzas ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] print ( Pizza ) [EOL] for i in Pizza : [EOL] print ( i ) [EOL] [EOL] print ( [string] ) [EOL] print ( friend_pizzas ) [EOL] for i in friend_pizzas : [EOL] print ( i ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] food = [ [string] , [string] , [string] , [string] , ] [EOL] for i in food : [EOL] print ( i ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] Pizza = [ [string] , [string] , [string] ] [EOL] for i in Pizza : [EOL] print ( i ) [EOL] for ia in Pizza : [EOL] print ( [string] + ia ) [EOL] [EOL] print ( str ( Pizza ) + [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] animal = [ [string] , [string] , [string] ] [EOL] for animals in animal : [EOL] print ( animals ) [EOL] [EOL] print ( [string] + animal [ [number] ] + [string] ) [EOL] print ( [string] + animal [ [number] ] + [string] ) [EOL] print ( [string] + animal [ [number] ] + [string] ) [EOL] [EOL] print ( str ( animal ) + [string] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] names = [ [string] ] [EOL] for i in names : [EOL] print ( i ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] names = [ [string] , [string] , [string] , [string] , [string] ] [EOL] for i in names : [EOL] print ( i ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] names = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] print ( [string] % names [ [number] ] ) [EOL] print ( [string] % names [ [number] ] ) [EOL] print ( [string] % names [ [number] ] ) [EOL] print ( [string] % names [ [number] ] ) [EOL] print ( [string] % names [ [number] ] ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] names = [ [string] ] [EOL] [EOL] ming = str ( input ( [string] ) ) [EOL] ming = [string] % ming + [string] [EOL] print ( ming ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] trip = [ [string] ] [EOL] for i in trip : [EOL] print ( i ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] trip = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for i in trip : [EOL] print ( i ) [EOL] mode = [string] % trip [ [number] ] [EOL] print ( mode ) [EOL] mode = [string] % trip [ [number] ] [EOL] print ( mode ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] tp = input ( [string] ) [EOL] [comment] [EOL] mode = [string] % tp [EOL] print ( mode ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Any , Type [EOL] import typing [EOL] list = [ [string] , [string] , [string] ] [EOL] print ( list ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( list [ [number] ] + [string] ) [EOL] list [ [number] ] = [string] [EOL] print ( list ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] list . insert ( [number] , [string] ) [EOL] print ( list ) [EOL] list . insert ( [number] , [string] ) [EOL] print ( list ) [EOL] list . append ( [string] ) [EOL] print ( list ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] for n in range ( [number] , [number] ) : [EOL] num = [number] [EOL] num += [number] [EOL] leave = list . pop ( num ) [EOL] print ( leave + [string] ) [EOL] for n in range ( [number] , [number] ) : [EOL] print ( [string] + list [ [number] ] + [string] ) [EOL] del list [ [number] ] [EOL] print ( list ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] message = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] print ( message [ [string] ] ) [EOL] print ( message [ [string] ] ) [EOL] print ( message [ [string] ] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] for k , v in message . items ( ) : [EOL] print ( k , v ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] number = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] print ( number ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] for k , v in number . items ( ) : [EOL] print ( k , v ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] python = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for k , v in python . items ( ) : [EOL] print ( k , v ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] python = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for k , v in python . items ( ) : [EOL] print ( k + [string] + v ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Set [EOL] import typing [EOL] number = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for k , v in number . items ( ) : [EOL] print ( k , v ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] cities = { [string] : { [string] , [string] , [string] } , [string] : { [string] , [string] , [string] } , [string] : { [string] , [string] , [string] } } [EOL] for city , mess in cities . items ( ) : [EOL] print ( city , mess ) [EOL] [EOL] for i in mess : [EOL] print ( i ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] python = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for k , v in python . items ( ) : [EOL] print ( k , v ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] dic = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [comment] [EOL] for k , v in dic . items ( ) : [EOL] print ( [string] + k + [string] + v + [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] for k in dic . keys ( ) : [EOL] print ( [string] + k ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] for v in dic . values ( ) : [EOL] print ( [string] + v ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] people = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for k in people . keys ( ) : [EOL] print ( k + [string] ) [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] people = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] if [string] not in people . keys ( ) : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] [comment] [EOL] import sublime [EOL] except ImportError : [EOL] from setuptools import setup , find_packages [EOL] [EOL] setup ( name = [string] , packages = find_packages ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Any [EOL] import string [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import logging [EOL] from string import Template [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] from . anaconda_lib import ioloop [EOL] from . anaconda_lib . helpers import get_settings [EOL] [EOL] from . commands import * [comment] [EOL] from . listeners import * [comment] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] DISABLED_PLUGINS = [ ] [EOL] LOOP_RUNNING = False [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . addHandler ( logging . StreamHandler ( sys . stdout ) ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] [EOL] def plugin_loaded ( ) : [EOL] [docstring] [EOL] [EOL] package_folder = os . path . dirname ( __file__ ) [EOL] if not os . path . exists ( os . path . join ( package_folder , [string] ) ) : [EOL] template_file = os . path . join ( package_folder , [string] , [string] ) [EOL] with open ( template_file , [string] , encoding = [string] ) as tplfile : [EOL] template = Template ( tplfile . read ( ) ) [EOL] [EOL] menu_file = os . path . join ( package_folder , [string] ) [EOL] with open ( menu_file , [string] , encoding = [string] ) as menu : [EOL] menu . write ( template . safe_substitute ( { [string] : os . path . basename ( package_folder ) } ) ) [EOL] [EOL] [comment] [EOL] sublime . set_timeout_async ( monitor_plugins , [number] ) [EOL] [EOL] if not LOOP_RUNNING : [EOL] ioloop . loop ( ) [EOL] [EOL] [EOL] def plugin_unloaded ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] enable_plugins ( ) [EOL] [EOL] if LOOP_RUNNING : [EOL] ioloop . terminate ( ) [EOL] [EOL] [EOL] def monitor_plugins ( ) : [EOL] [docstring] [EOL] [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] if not get_settings ( view , [string] , True ) : [EOL] return [EOL] [EOL] plist = [ [string] , [string] , [string] ] [EOL] [EOL] for plugin in plist : [EOL] if plugin in sys . modules : [EOL] [ sublime_plugin . unload_module ( m ) for k , m in sys . modules . items ( ) if plugin in k ] [EOL] if plugin not in DISABLED_PLUGINS : [EOL] DISABLED_PLUGINS . append ( plugin ) [EOL] [EOL] sublime . set_timeout_async ( monitor_plugins , [number] * [number] * [number] ) [EOL] [EOL] [EOL] def enable_plugins ( ) : [EOL] [docstring] [EOL] [EOL] for plugin in DISABLED_PLUGINS : [EOL] sublime_plugin . reload_plugin ( plugin ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple [EOL] import typing [EOL] import os [EOL] [EOL] messages_json = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] with open ( messages_json , [string] ) as message_file : [EOL] message_data = message_file . read ( ) [EOL] [EOL] ver = message_data . splitlines ( ) [ - [number] ] . split ( [string] ) [ [number] ] . strip ( ) . replace ( [string] , [string] ) [EOL] version = tuple ( [ int ( i ) for i in ver . split ( [string] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] import logging [EOL] import subprocess [EOL] [EOL] [EOL] def spawn ( args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if [string] not in kwargs : [EOL] kwargs [ [string] ] = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] kwargs [ [string] ] = - [number] [EOL] [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] kwargs [ [string] ] = startupinfo [EOL] [EOL] try : [EOL] return subprocess . Popen ( args , ** kwargs ) [EOL] except Exception as error : [EOL] msg = ( [string] ) . format ( args [ [number] ] , error ) [EOL] logging . error ( msg ) [EOL] raise RuntimeError ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class MyPy ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , code , filename , mypypath , settings ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . filename = filename [EOL] self . mypypath = mypypath [EOL] self . settings = settings [ [string] ] [EOL] self . linter = linter [EOL] super ( MyPy , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( self . code , self . filename , self . mypypath , self . settings ) . execute ( ) , [string] : self . uid , [string] : self . vid , } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PEP257 ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , ignore , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . filename = filename [EOL] self . ignore = ignore [EOL] self . linter = linter [EOL] super ( PEP257 , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( self . code , self . filename , self . ignore ) . execute ( ) , [string] : self . uid , [string] : self . vid , } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import os [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class Rename ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script , directories , new_word , refactor ) : [EOL] self . script = script [EOL] self . new_word = new_word [EOL] self . jedi_refactor = refactor [EOL] self . directories = directories [EOL] super ( Rename , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] renames = { } [EOL] try : [EOL] usages = self . script . usages ( ) [EOL] proposals = self . jedi_refactor . rename ( self . script , self . new_word ) [EOL] for u in usages : [EOL] path = os . path . dirname ( u . module_path ) [EOL] if self . is_same_path ( path ) : [EOL] if u . module_path not in renames : [EOL] renames [ u . module_path ] = [ ] [EOL] [EOL] thefile = proposals . new_files ( ) . get ( u . module_path ) [EOL] if thefile is None : [EOL] continue [EOL] [EOL] lineno = u . line - [number] [EOL] line = thefile . splitlines ( ) [ lineno ] [EOL] renames [ u . module_path ] . append ( { [string] : lineno , [string] : line } ) [EOL] success = True [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] success = False [EOL] [EOL] self . callback ( { [string] : success , [string] : renames , [string] : self . uid } ) [EOL] [EOL] def is_same_path ( self , path ) : [EOL] [docstring] [EOL] [EOL] for directory in self . directories : [EOL] if os . path . commonprefix ( [ directory , path ] ) == directory : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] class Command ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid ) : [EOL] self . uid = uid [EOL] self . callback = callback [EOL] [EOL] self . run ( ) [EOL] [EOL] [EOL] def get_function_parameters ( call_def ) : [EOL] [docstring] [EOL] [EOL] if not call_def : [EOL] return [ ] [EOL] [EOL] params = [ ] [EOL] for param in call_def . params : [EOL] cleaned_param = param . get_code ( ) . strip ( ) [EOL] if [string] in cleaned_param or cleaned_param == [string] : [EOL] continue [EOL] [EOL] params . append ( [ s . strip ( ) for s in cleaned_param . split ( [string] ) ] ) [EOL] [EOL] return params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PyFlakes ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , settings , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . settings = settings [EOL] self . filename = filename [EOL] super ( PyFlakes , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( ) . lint ( self . settings , self . code , self . filename ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class Lint ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , settings , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . settings = settings [EOL] self . filename = filename [EOL] super ( Lint , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter . Linter ( ) . run_linter ( self . settings , self . code , self . filename ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PyLint ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , rcfile , filename ) : [EOL] self . vid = vid [EOL] self . filename = filename [EOL] self . linter = linter [EOL] self . rcfile = rcfile [EOL] super ( PyLint , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( self . filename , self . rcfile ) . parse_errors ( ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] from autopep . autopep8_lib import autopep8 [EOL] [EOL] [EOL] class AutoPep8 ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , code , settings ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . options = autopep8 . parse_args ( self . parse_settings ( settings ) ) [EOL] super ( AutoPep8 , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] self . code = unicode ( self . code ) [EOL] try : [EOL] self . callback ( { [string] : True , [string] : autopep8 . fix_lines ( self . code . splitlines ( ) , options = self . options ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( str ( error ) ) [EOL] print ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : str ( error ) , [string] : self . uid , [string] : self . vid } ) [EOL] [EOL] def parse_settings ( self , settings ) : [EOL] [docstring] [EOL] [EOL] args = [ ] [EOL] args += [ [string] ] * settings . get ( [string] , [number] ) [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] args += [ [string] . format ( settings . get ( [string] , [number] ) ) ] [EOL] args += [ [string] . format ( settings . get ( [string] , [number] ) ) ] [EOL] args += [ [string] ] [EOL] [EOL] return args [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . base import Command , get_function_parameters [EOL] [EOL] [EOL] class CompleteParameters ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script , settings ) : [EOL] self . script = script [EOL] self . settings = settings [EOL] super ( CompleteParameters , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] completions = [ ] [EOL] complete_all = self . settings . get ( [string] , False ) [EOL] [EOL] try : [EOL] signatures = self . script . call_signatures ( ) [ [number] ] [EOL] except IndexError : [EOL] signatures = None [EOL] [EOL] params = get_function_parameters ( signatures ) [EOL] for i , p in enumerate ( params ) : [EOL] try : [EOL] name , value = p [EOL] except ValueError : [EOL] name = p [ [number] ] [EOL] value = None [EOL] [EOL] name = name . replace ( [string] , [string] ) [EOL] if value is None : [EOL] completions . append ( [string] % ( i + [number] , name ) ) [EOL] else : [EOL] if complete_all is True : [EOL] completions . append ( [string] % ( name , i + [number] , value ) ) [EOL] [EOL] self . callback ( { [string] : True , [string] : [string] . join ( completions ) , [string] : self . uid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import sys [EOL] import logging [EOL] [EOL] from . base import Command [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] import html [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] import html as cgi [EOL] from html . parser import HTMLParser [EOL] else : [EOL] [comment] [EOL] import cgi [EOL] from HTMLParser import HTMLParser [EOL] [EOL] [EOL] class Doc ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script , html ) : [EOL] self . script = script [EOL] self . html = html [EOL] super ( Doc , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] processed = [ ] [EOL] try : [EOL] definitions = self . script . goto_definitions ( ) [EOL] except Exception as error : [EOL] logging . debug ( error ) [EOL] logging . debug ( self . script ) [EOL] definitions = [ ] [EOL] [EOL] if not definitions : [EOL] success = False [EOL] docs = [ ] [EOL] else : [EOL] docs = [ ] [EOL] success = True [EOL] for definition in definitions : [EOL] if definition not in processed : [EOL] docs . append ( self . _plain ( definition ) if not self . html [EOL] else self . _html ( definition ) ) [EOL] processed . append ( definition ) [EOL] [EOL] self . callback ( { [string] : success , [string] : ( [string] if self . html [EOL] else [string] + [string] * [number] + [string] ) . join ( docs ) , [string] : self . uid } ) [EOL] [EOL] def _plain ( sef , definition ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( definition . full_name , [string] * [number] , definition . doc ) [EOL] [EOL] def _html ( self , definition ) : [EOL] [docstring] [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] escaped_doc = html . escape ( html . unescape ( definition . doc ) , quote = False ) [EOL] else : [EOL] try : [EOL] escaped_doc = cgi . escape ( HTMLParser . unescape . __func__ ( HTMLParser , definition . doc . encode ( [string] ) ) ) [EOL] except AttributeError : [EOL] [comment] [EOL] escaped_doc = cgi . escape ( HTMLParser . unescape ( HTMLParser , definition . doc ) ) [EOL] [EOL] escaped_doc = escaped_doc . replace ( [string] , [string] ) [EOL] [EOL] return [string] . format ( definition . full_name , escaped_doc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] DEBUG_MODE = False [EOL] [EOL] [EOL] class AutoComplete ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script ) : [EOL] self . script = script [EOL] super ( AutoComplete , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] completions = self . script . completions ( ) [EOL] if DEBUG_MODE is True : [EOL] logging . info ( completions ) [EOL] data = [ ( [string] . format ( comp . name , comp . type ) , comp . name ) for comp in completions ] [EOL] self . callback ( { [string] : True , [string] : data , [string] : self . uid } ) [EOL] except Exception as error : [EOL] msg = [string] [EOL] logging . error ( msg ) [EOL] logging . error ( error ) [EOL] print ( traceback . format_exc ( ) ) [EOL] if DEBUG_MODE : [EOL] logging . debug ( traceback . format_exc ( ) ) [EOL] [EOL] self . callback ( { [string] : False , [string] : str ( error ) , [string] : self . uid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PEP8 ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , settings , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . settings = settings [EOL] self . filename = filename [EOL] super ( PEP8 , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( ) . lint ( self . settings , self . code , self . filename ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from . doc import Doc [EOL] from . mypy import MyPy [EOL] from . lint import Lint [EOL] from . goto import Goto , GotoAssignment [EOL] from . pep8 import PEP8 [EOL] from . pep257 import PEP257 [EOL] from . mccabe import McCabe [EOL] from . rename import Rename [EOL] from . pylint import PyLint [EOL] from . pyflakes import PyFlakes [EOL] from . autoformat import AutoPep8 [EOL] from . find_usages import FindUsages [EOL] from . autocomplete import AutoComplete [EOL] from . import_validator import ImportValidator [EOL] from . complete_parameters import CompleteParameters [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class McCabe ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , mccabe , code , threshold , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . filename = filename if filename is not None else [string] [EOL] self . threshold = threshold [EOL] self . mccabe = mccabe ( self . code , self . filename ) [EOL] super ( McCabe , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . mccabe . get_code_complexity ( self . threshold ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : str ( error ) , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class ImportValidator ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . filename = filename [EOL] super ( ImportValidator , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] v = self . linter ( self . code , self . filename ) [EOL] self . callback ( { [string] : True , [string] : [ ] if v . is_valid ( ) else self . _convert ( v ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL] [EOL] def _convert ( self , validator ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] for line , lineno in validator . errors : [EOL] errors . append ( { [string] : [string] , [string] : lineno , [string] : [number] , [string] : [number] , [string] : [string] . format ( line ) , [string] : [string] , [string] : True } ) [EOL] [EOL] return errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any , Set [EOL] import typing [EOL] from . base import Command [EOL] [EOL] [EOL] class Goto ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script ) : [EOL] self . script = script [EOL] super ( Goto , self ) . __init__ ( callback , uid ) [EOL] [EOL] def _get_definitions ( self ) : [EOL] definitions = self . script . goto_assignments ( ) [EOL] if all ( d . type == [string] for d in definitions ) : [EOL] definitions = self . script . goto_definitions ( ) [EOL] return definitions [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] definitions = self . _get_definitions ( ) [EOL] except : [EOL] data = [ ] [EOL] success = False [EOL] else : [EOL] [comment] [EOL] data = set ( [ ( i . full_name , i . module_path , i . line , i . column + [number] ) for i in definitions if not i . in_builtin_module ( ) ] ) [EOL] [EOL] success = True [EOL] [EOL] self . callback ( { [string] : success , [string] : list ( data ) , [string] : self . uid } ) [EOL] [EOL] [EOL] class GotoAssignment ( Goto ) : [EOL] [docstring] [EOL] [EOL] def _get_definitions ( self ) : [EOL] return self . script . goto_assignments ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown,unknown,builtins.int]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown,unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown,unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class FindUsages ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script ) : [EOL] self . script = script [EOL] super ( FindUsages , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] usages = self . script . usages ( ) [EOL] success = True [EOL] except : [EOL] usages = None [EOL] success = False [EOL] [EOL] try : [EOL] self . callback ( { [string] : success , [string] : [ ( i . full_name , i . module_path , i . line , i . column ) for i in usages if not i . in_builtin_module ( ) ] if usages is not None else [ ] , [string] : self . uid } ) [EOL] except ValueError : [EOL] self . callback ( { [string] : success , [string] : [ ( i . name , i . module_path , i . line , i . column ) for i in usages if not i . in_builtin_module ( ) ] if usages is not None else [ ] , [string] : self . uid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] import logging [EOL] [EOL] [EOL] class HandlerRegistry ( object ) : [EOL] [docstring] [EOL] [EOL] initialized = False [EOL] [EOL] def __init__ ( self ) : [EOL] self . _handlers = { } [EOL] [EOL] def initialize ( self ) : [EOL] [docstring] [EOL] [EOL] if self . initialized : [EOL] return [EOL] [EOL] self . _import_plugin_handlers ( ) [EOL] self . initialized = True [EOL] [EOL] def get ( self , handler_type ) : [EOL] [docstring] [EOL] [EOL] return self . _handlers . get ( handler_type ) [EOL] [EOL] def register ( self , handler ) : [EOL] [docstring] [EOL] [EOL] self . _handlers [ handler . __handler_type__ ] = handler [EOL] [EOL] def _import_plugin_handlers ( self ) : [EOL] [docstring] [EOL] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] packages = [ os . path . join ( path , f ) for f in os . listdir ( path ) if f . startswith ( [string] ) ] [EOL] for package in packages : [EOL] if [string] in package or not os . path . isdir ( package ) : [EOL] continue [EOL] [EOL] lang = package . rsplit ( [string] , [number] ) [ [number] ] [EOL] sys . path . append ( [string] . format ( package ) ) [EOL] mod_name = [string] . format ( lang ) [EOL] mod = __import__ ( mod_name , globals ( ) , locals ( ) ) [EOL] logging . info ( [string] . format ( mod ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import json [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] @ contextmanager def json_decode ( data ) : [EOL] PY26 = False [EOL] data = data . replace ( [string] , [string] ) [EOL] if sys . version_info < ( [number] , [number] , [number] ) : [EOL] PY26 = True [EOL] fixed_keys = { } [EOL] try : [EOL] if PY26 : [EOL] for k , v in json . loads ( data . decode ( [string] ) ) . iteritems ( ) : [EOL] fixed_keys [ str ( k ) ] = v [EOL] yield fixed_keys [EOL] else : [EOL] yield json . loads ( data . decode ( [string] ) ) [EOL] except ValueError : [EOL] try : [EOL] yield eval ( data ) [EOL] except Exception : [EOL] yield str ( data . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . registry import HandlerRegistry [EOL] [EOL] [EOL] class AnacondaHandlerMeta ( type ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( cls , name , bases , attrs ) : [EOL] if not hasattr ( cls , [string] ) : [EOL] cls . _registry = HandlerRegistry ( ) [EOL] [EOL] if hasattr ( cls , [string] ) : [EOL] cls . _registry . register ( cls ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import inspect [EOL] [EOL] from . compat import AnacondaHandlerProvider [EOL] [EOL] [EOL] class AnacondaHandler ( AnacondaHandlerProvider ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , command , data , uid , vid , callback , debug = False ) : [EOL] self . uid = uid [EOL] self . vid = vid [EOL] self . data = data [EOL] self . debug = debug [EOL] self . callback = callback [EOL] self . command = command [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] command = getattr ( self , self . command ) [EOL] try : [EOL] func_code = command . func_code [EOL] except AttributeError : [EOL] [comment] [EOL] func_code = command . __code__ [EOL] [EOL] kwargs = { } [EOL] for argument , value in self . data . items ( ) : [EOL] if argument in inspect . getargs ( func_code ) . args : [EOL] kwargs [ argument ] = value [EOL] [EOL] command ( ** kwargs ) [EOL] [EOL] @ classmethod def get_handler ( cls , handler_type ) : [EOL] [docstring] [EOL] return cls . _registry . get ( handler_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . meta_handler import AnacondaHandlerMeta [EOL] [EOL] [EOL] class AnacondaHandlerProvider : [EOL] [docstring] [EOL] [EOL] __metaclass__ = AnacondaHandlerMeta [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . meta_handler import AnacondaHandlerMeta [EOL] [EOL] [EOL] class AnacondaHandlerProvider ( metaclass = AnacondaHandlerMeta ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import sys [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] from . python3 import AnacondaHandlerProvider [EOL] else : [EOL] from python2 import AnacondaHandlerProvider [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
import sys [EOL] import pkg_resources [EOL] sys . path . insert ( [number] , [string] ) [EOL] sys . path . insert ( [number] , [string] ) [EOL] pkg_resources . declare_namespace ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import sys [EOL] [EOL] import jedi [EOL] [EOL] from handlers . jedi_handler import JediHandler [EOL] from commands . complete_parameters import CompleteParameters [EOL] [EOL] PYTHON3 = sys . version_info >= ( [number] , [number] ) [EOL] [EOL] [EOL] class TestCompleteParameters ( object ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . settings = { [string] : False } [EOL] self . script = jedi . Script ( [string] ) [EOL] [EOL] def test_complete_parameters_command ( self ) : [EOL] CompleteParameters ( self . _check_parameters , [number] , self . script , self . settings ) [EOL] [EOL] def test_complete_all_parameters ( self ) : [EOL] self . settings [ [string] ] = True [EOL] CompleteParameters ( self . _check_all_parameters , [number] , self . script , self . settings ) [EOL] [EOL] def test_complete_parameters_handler ( self ) : [EOL] data = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , [string] : self . settings } [EOL] handler = JediHandler ( [string] , data , [number] , [number] , self . _check_parameters ) [EOL] handler . run ( ) [EOL] [EOL] def test_complete_all_parameters_handler ( self ) : [EOL] self . settings [ [string] ] = True [EOL] data = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , [string] : self . settings } [EOL] handler = JediHandler ( [string] , data , [number] , [number] , self . _check_all_parameters ) [EOL] handler . run ( ) [EOL] [EOL] def _check_parameters ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert result [ [string] ] == [string] if PYTHON3 else [string] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_all_parameters ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert result [ [string] ] == [string] if PYTHON3 else [string] [comment] [EOL] assert result [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0
def usages_helper ( ) : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Union [EOL] import typing [EOL] import sys [EOL] [EOL] import jedi [EOL] [EOL] from commands . autocomplete import AutoComplete [EOL] from handlers . jedi_handler import JediHandler [EOL] [EOL] [EOL] class TestAutoCompletion ( object ) : [EOL] [docstring] [EOL] [EOL] def test_autocomplete_command ( self ) : [EOL] AutoComplete ( self . _check , [number] , jedi . Script ( [string] ) ) [EOL] [EOL] def test_autocomplete_handler ( self ) : [EOL] data = { [string] : [string] , [string] : [number] , [string] : [number] } [EOL] handler = JediHandler ( [string] , data , [number] , [number] , self . _check ) [EOL] handler . run ( ) [EOL] [EOL] def _check ( self , kwrgs ) : [EOL] assert kwrgs [ [string] ] is True [EOL] assert len ( kwrgs [ [string] ] ) > [number] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] assert kwrgs [ [string] ] [ [number] ] == ( [string] , [string] ) [EOL] else : [EOL] assert kwrgs [ [string] ] [ [number] ] == ( [string] , [string] ) [EOL] assert kwrgs [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , List , Any , Union [EOL] import typing_extensions [EOL] import typing [EOL] import sys [EOL] import tempfile [EOL] import os [EOL] from nose . plugins . skip import SkipTest [EOL] [EOL] from handlers . python_lint_handler import PythonLintHandler [EOL] [EOL] PYTHON3 = sys . version_info >= ( [number] , [number] ) [EOL] PYTHON26 = sys . version_info < ( [number] , [number] ) [EOL] [EOL] [EOL] class real_temp_file ( object ) : [EOL] [EOL] def __init__ ( self , contents ) : [EOL] self . contents = contents [EOL] self . filename = None [EOL] [EOL] def __enter__ ( self ) : [EOL] with tempfile . NamedTemporaryFile ( delete = False ) as f : [EOL] f . write ( self . contents . encode ( ) ) [EOL] self . filename = f . name [EOL] f . close ( ) [EOL] return self . filename [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback ) : [EOL] os . remove ( self . filename ) [EOL] [EOL] [EOL] class TestLint ( object ) : [EOL] [docstring] [EOL] [EOL] _lintable_code = [string] [EOL] [EOL] _lintable_docstring = [string] [EOL] [EOL] _import_validator_code = [string] [EOL] [EOL] _type_checkable_code = [string] [EOL] [EOL] _type_checkable_async_code = [string] [EOL] [EOL] def setUp ( self ) : [EOL] self . _settings = { [string] : False , [string] : False , [string] : False , [string] : False , [string] : False , [string] : False , [string] : [string] , [string] : [ [string] ] } [EOL] [EOL] def test_pyflakes_lint ( self ) : [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pyflakes ) [EOL] self . _settings [ [string] ] = True [EOL] handler . lint ( self . _settings , self . _lintable_code ) [EOL] [EOL] def test_pyflakes_ignore ( self ) : [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pyflakes_ignore ) [comment] [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [string] [EOL] [EOL] def test_pep8_lint ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep8 ) [EOL] handler . lint ( self . _settings , self . _lintable_code ) [EOL] [EOL] def test_pep8_ignores ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [ [string] ] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep8_ignores ) [comment] [EOL] handler . lint ( self . _settings , self . _lintable_code ) [EOL] [EOL] def test_pep8_max_line_lenght ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [number] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep8_max_line_length ) [comment] [EOL] handler . lint ( self . _settings , [string] . format ( [string] * [number] ) ) [comment] [EOL] [EOL] def test_pep257_lint ( self ) : [EOL] if PYTHON26 : [EOL] raise SkipTest ( [string] ) [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep257 ) [EOL] handler . lint ( self . _settings , self . _lintable_docstring , [string] ) [EOL] [EOL] def test_pep257_ignores ( self ) : [EOL] if PYTHON26 : [EOL] raise SkipTest ( [string] ) [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep257_ignores ) [comment] [EOL] handler . lint ( self . _settings , self . _lintable_docstring , [string] ) [EOL] [EOL] def test_import_validator ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_validate_imports ) [comment] [EOL] handler . lint ( self . _settings , self . _import_validator_code , [string] ) [EOL] [EOL] def test_mypy ( self ) : [EOL] if not PYTHON3 : [EOL] raise SkipTest ( ) [EOL] try : [EOL] import mypy [comment] [EOL] except ImportError : [EOL] raise SkipTest ( [string] ) [EOL] with real_temp_file ( self . _type_checkable_code ) as temp_file_name : [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_mypy ) [EOL] handler . lint ( self . _settings , self . _type_checkable_code , temp_file_name ) [comment] [EOL] [EOL] def test_mypy_fast_parser ( self ) : [EOL] if not PYTHON3 : [EOL] raise SkipTest ( ) [EOL] try : [EOL] import mypy [comment] [EOL] except ImportError : [EOL] raise SkipTest ( [string] ) [EOL] with real_temp_file ( self . _type_checkable_async_code ) as temp_file_name : [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [ [string] , [string] ] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_mypy_async ) [comment] [EOL] handler . lint ( self . _settings , self . _type_checkable_code , temp_file_name ) [comment] [EOL] [EOL] def _check_pyflakes ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] err = [string] \ [EOL] if not PYTHON3 else [string] [comment] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == err [EOL] assert result [ [string] ] [ [number] ] [ [string] ] is False [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep8 ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] error1 = result [ [string] ] [ [number] ] [EOL] assert error1 [ [string] ] == [string] [comment] [EOL] assert error1 [ [string] ] == [string] [EOL] assert error1 [ [string] ] is True [EOL] error2 = result [ [string] ] [ [number] ] [EOL] assert error2 [ [string] ] == [string] [comment] [EOL] assert error2 [ [string] ] == [string] [EOL] assert error2 [ [string] ] is True [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep8_ignores ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] error1 = result [ [string] ] [ [number] ] [EOL] assert error1 [ [string] ] == [string] [comment] [EOL] assert error1 [ [string] ] == [string] [EOL] assert error1 [ [string] ] is True [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep8_max_line_length ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pyflakes_ignore ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep257 ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] raw_errors = [ r [ [string] ] for r in result [ [string] ] ] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] [EOL] error1 , error2 , error3 , error4 , error5 , _ , _ = result [ [string] ] [EOL] assert ( error1 [ [string] ] , error2 [ [string] ] , error3 [ [string] ] , error4 [ [string] ] , error5 [ [string] ] ) == ( [string] , [string] , [string] , [string] , [string] ) [comment] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep257_ignores ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_validate_imports ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [comment] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] is True [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_mypy ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [comment] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_mypy_async ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import glob [EOL] import logging [EOL] from string import Template [EOL] [EOL] import sublime [EOL] [EOL] from . helpers import get_settings [EOL] [EOL] [EOL] class Phantom ( object ) : [EOL] [docstring] [EOL] [EOL] themes = { } [comment] [EOL] templates = { } [comment] [EOL] loaded = False [EOL] phantomsets = { } [EOL] [EOL] def __init__ ( self ) : [EOL] if int ( sublime . version ( ) ) < [number] : [EOL] return [EOL] [EOL] if Phantom . loaded is False : [EOL] self . _load_css_themes ( ) [EOL] self . _load_phantom_templates ( ) [EOL] Phantom . loaded = True [EOL] [EOL] def clear_phantoms ( self , view ) : [EOL] if not self . loaded : [EOL] return [EOL] [EOL] vid = view . id ( ) [EOL] if vid in self . phantomsets : [EOL] self . phantomsets [ vid ] . update ( [ ] ) [EOL] [EOL] def update_phantoms ( self , view , phantoms ) : [EOL] if not self . loaded : [EOL] return [EOL] [EOL] thmname = get_settings ( view , [string] , [string] ) [EOL] tplname = get_settings ( view , [string] , [string] ) [EOL] [EOL] thm = self . themes . get ( thmname , self . themes [ [string] ] ) [EOL] tpl = self . templates . get ( tplname , self . templates [ [string] ] ) [EOL] [EOL] vid = view . id ( ) [EOL] if vid not in self . phantomsets : [EOL] self . phantomsets [ vid ] = sublime . PhantomSet ( view , [string] ) [EOL] [EOL] sublime_phantoms = [ ] [EOL] for item in phantoms : [EOL] region = view . full_line ( view . text_point ( item [ [string] ] , [number] ) ) [EOL] context = { [string] : thm } [EOL] context . update ( item ) [EOL] content = tpl . safe_substitute ( context ) [EOL] sublime_phantoms . append ( sublime . Phantom ( region , content , sublime . LAYOUT_BLOCK ) ) [EOL] [EOL] self . phantomsets [ vid ] . update ( sublime_phantoms ) [EOL] [EOL] def _load_phantom_templates ( self ) : [EOL] [docstring] [EOL] [EOL] template_files_pattern = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] , [string] , [string] ) [EOL] for template_file in glob . glob ( template_files_pattern ) : [EOL] with open ( template_file , [string] , encoding = [string] ) as tplfile : [EOL] tplname = os . path . basename ( template_file ) . split ( [string] ) [ [number] ] [EOL] tpldata = [string] . format ( tplfile . read ( ) ) [EOL] self . templates [ tplname ] = Template ( tpldata ) [EOL] [EOL] def _load_css_themes ( self ) : [EOL] [docstring] [EOL] [EOL] css_files_pattern = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] , [string] ) [EOL] for css_file in glob . glob ( css_files_pattern ) : [EOL] logging . info ( [string] . format ( self . _load_css ( css_file ) ) ) [EOL] [EOL] packages = sublime . active_window ( ) . extract_variables ( ) [ [string] ] [EOL] user_css_path = os . path . join ( packages , [string] , [string] ) [EOL] if os . path . exists ( user_css_path ) : [EOL] css_files_pattern = os . path . join ( user_css_path , [string] ) [EOL] for css_file in glob . glob ( css_files_pattern ) : [EOL] logging . info ( [string] , self . _load_css ( css_file ) ) [EOL] [EOL] def _load_css ( self , css_file ) : [EOL] [docstring] [EOL] [EOL] theme_name = os . path . basename ( css_file ) . split ( [string] ) [ [number] ] [EOL] with open ( css_file , [string] ) as resource : [EOL] self . themes [ theme_name ] = resource . read ( ) [EOL] [EOL] return theme_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi import Script [EOL] [EOL] [EOL] class Validator : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source , filename ) : [EOL] self . source = source [EOL] self . errors = [ ] [comment] [EOL] self . filename = filename [EOL] [EOL] def is_valid ( self ) : [EOL] [docstring] [EOL] [EOL] for line , lineno in self . _extract_imports ( ) : [EOL] error , valid = self . _validate_import ( line , lineno ) [EOL] if not valid : [EOL] self . errors . append ( ( error , lineno ) ) [EOL] [EOL] return not self . errors [EOL] [EOL] def _validate_import ( self , module_line , lineno ) : [EOL] [docstring] [EOL] [EOL] if [string] in module_line : [EOL] return True [EOL] [EOL] error = [ ] [EOL] error_string = [string] [EOL] valid = True [EOL] for word in module_line . split ( ) : [EOL] if word in ( [string] , [string] , [string] ) : [EOL] continue [EOL] [EOL] offset = int ( module_line . find ( word ) + len ( word ) / [number] ) [EOL] s = Script ( self . source , lineno , offset , self . filename ) [EOL] if not self . filename : [EOL] s = Script ( module_line , [number] , offset ) [EOL] [EOL] if not s . goto_assignments ( ) : [EOL] if valid is True : [EOL] valid = False [EOL] error . append ( word ) [EOL] [EOL] err = [string] if valid else error_string . format ( [string] . join ( error ) ) [EOL] return err , valid [EOL] [EOL] def _extract_imports ( self ) : [EOL] [docstring] [EOL] [EOL] found = [ ] [EOL] lineno = [number] [EOL] buffer_found = [ ] [comment] [EOL] in_docstring = False [EOL] for line in self . source . splitlines ( ) : [EOL] if self . __detect_docstring ( line ) : [EOL] if in_docstring : [EOL] in_docstring = False [EOL] else : [EOL] in_docstring = True [EOL] lineno += [number] [EOL] continue [EOL] else : [EOL] line = line . strip ( ) [EOL] if len ( buffer_found ) > [number] : [EOL] if [string] in line : [EOL] buffer_found . append ( line . replace ( [string] , [string] ) . strip ( ) ) [EOL] found . append ( ( [string] . join ( buffer_found ) , lineno ) ) [EOL] buffer_found = [ ] [EOL] else : [EOL] buffer_found . append ( line ) [EOL] else : [EOL] if self . __detect_docstring ( line ) : [EOL] continue [EOL] if line . startswith ( [string] ) or line . startswith ( [string] ) : [EOL] if [string] in line : [EOL] buffer_found . append ( line . replace ( [string] , [string] ) . strip ( ) ) [EOL] else : [EOL] found . append ( ( line , lineno ) ) [EOL] lineno += [number] [EOL] return found [EOL] [EOL] def __detect_docstring ( self , line ) : [EOL] [docstring] [EOL] [EOL] if [string] in line or [string] in line : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[Variable[_T]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[Variable[_T]]$ 0 0 $builtins.int$ 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 0 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[Variable[_T]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import pickle [EOL] import logging [EOL] [EOL] [EOL] class PersistentList ( list ) : [EOL] [EOL] [docstring] [EOL] [EOL] _file_path = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] [EOL] super ( PersistentList , self ) . __init__ ( ) [EOL] try : [EOL] with open ( self . _file_path , [string] ) as fileobj : [EOL] self . load ( fileobj ) [EOL] except IOError : [EOL] pass [EOL] except Exception as e : [EOL] logging . error ( [string] . format ( e ) ) [EOL] os . remove ( self . _file_path ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [EOL] super ( PersistentList , self ) . __setitem__ ( key , value ) [EOL] self . sync ( ) [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] [EOL] super ( PersistentList , self ) . __delitem__ ( key ) [EOL] self . sync ( ) [EOL] [EOL] def append ( self , value ) : [EOL] [EOL] super ( PersistentList , self ) . append ( value ) [EOL] self . sync ( ) [EOL] [EOL] def remove ( self , value ) : [EOL] [EOL] super ( PersistentList , self ) . remove ( value ) [EOL] self . sync ( ) [EOL] [EOL] def pop ( self , index = None ) : [EOL] [EOL] if index is not None : [EOL] value = super ( PersistentList , self ) . pop ( index ) [EOL] else : [EOL] value = super ( PersistentList , self ) . pop ( ) [EOL] [EOL] self . sync ( ) [EOL] return value [EOL] [EOL] def sort ( self , ** kwargs ) : [EOL] [EOL] super ( PersistentList , self ) . sort ( ** kwargs ) [EOL] self . sync ( ) [EOL] [EOL] def load ( self , fileobj ) : [EOL] [docstring] [EOL] [EOL] return self . extend ( pickle . load ( fileobj ) ) [EOL] [EOL] def sync ( self ) : [EOL] [docstring] [EOL] [EOL] with open ( self . _file_path , [string] ) as fileobj : [EOL] l = [ i for i in list ( self ) if type ( i ) is str or type ( i ) is bytes ] [EOL] return pickle . dump ( l , fileobj , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import threading [EOL] [EOL] import sublime [EOL] [EOL] [EOL] class ProgressBar ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] class Status ( object ) : [EOL] NONE = None [EOL] SUCCESS = [string] [EOL] FAILURE = [string] [EOL] TIMEOUT = [string] [EOL] [EOL] def __init__ ( self , messages ) : [EOL] threading . Thread . __init__ ( self ) [EOL] self . messages = messages [EOL] self . addition = [number] [EOL] self . die = False [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] sublime . set_timeout ( lambda : self . update ( [number] ) , [number] ) [EOL] [EOL] def update ( self , i ) : [EOL] [docstring] [EOL] [EOL] if self . die : [EOL] return [EOL] [EOL] size = [number] [EOL] pos = i % size [EOL] status = [string] . format ( [string] * pos , [string] * ( ( size - [number] ) - pos ) ) [EOL] [EOL] sublime . status_message ( [string] . format ( self . messages [ [string] ] , status ) ) [EOL] [EOL] if not ( size - [number] ) - pos : [EOL] self . addition = - [number] [EOL] if not pos : [EOL] self . addition = [number] [EOL] [EOL] i += self . addition [EOL] [EOL] sublime . set_timeout_async ( lambda : self . update ( i ) , [number] ) [EOL] [EOL] def terminate ( self , status = None ) : [EOL] [docstring] [EOL] status = status or self . Status . SUCCESS [EOL] [EOL] message = self . messages . get ( status ) or self . messages [ self . Status . SUCCESS ] [comment] [EOL] sublime . status_message ( message ) [EOL] self . die = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import cProfile [EOL] import typing [EOL] import pstats [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import time [EOL] import pstats [EOL] import logging [EOL] import functools [EOL] [EOL] try : [EOL] import cProfile [EOL] CPROFILE_AVAILABLE = True [EOL] except ImportError : [EOL] CPROFILE_AVAILABLE = False [EOL] [EOL] try : [EOL] import sublime [EOL] from . helpers import get_settings , project_name , is_remote_session [EOL] except ImportError : [EOL] [comment] [EOL] pass [EOL] [EOL] from . constants import WorkerStatus [EOL] [EOL] [EOL] def auto_project_switch ( func ) : [EOL] [docstring] [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( self , * args , ** kwargs ) : [EOL] [EOL] if self . status != WorkerStatus . healthy : [EOL] return [EOL] [EOL] def reconnect ( proc ) : [EOL] proc . kill ( ) [EOL] self . reconnecting = True [EOL] self . start ( ) [EOL] [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] auto_project_switch = get_settings ( view , [string] , False ) [EOL] [EOL] [comment] [EOL] python_interpreter = os . path . expandvars ( os . path . expanduser ( get_settings ( view , [string] ) ) ) [EOL] [EOL] process = self . processer . _process [EOL] if auto_project_switch and not is_remote_session ( view ) and hasattr ( self , [string] ) and ( project_name ( ) != self . project_name or process . args [ [number] ] != python_interpreter ) : [EOL] [EOL] print ( [string] ) [EOL] reconnect ( process ) [EOL] else : [EOL] func ( self , * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def auto_project_switch_ng ( func ) : [EOL] [docstring] [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( self , * args , ** kwargs ) : [EOL] [EOL] if self . status != WorkerStatus . healthy : [EOL] return [EOL] [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] project_switch = get_settings ( view , [string] , False ) [EOL] if project_switch : [EOL] python_interpreter = get_settings ( view , [string] ) [EOL] if python_interpreter != self . interpreter . raw_interpreter : [EOL] print ( [string] ) [EOL] self . on_python_interpreter_switch ( python_interpreter ) [EOL] return [EOL] [EOL] func ( self , * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def timeit ( logger ) : [EOL] [docstring] [EOL] [EOL] def decorator ( func ) : [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] starttime = time . time ( ) [EOL] result = func ( * args , ** kwargs ) [EOL] endtime = time . time ( ) [EOL] total = endtime - starttime [EOL] logger . debug ( [string] . format ( func . __name__ , total ) ) [EOL] [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] return decorator [EOL] [EOL] [EOL] def profile ( func ) : [EOL] [docstring] [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] [EOL] if get_settings ( view , [string] , False ) == [string] : [EOL] [EOL] if CPROFILE_AVAILABLE : [EOL] pr = cProfile . Profile ( ) [EOL] pr . enable ( ) [EOL] result = func ( * args , ** kwargs ) [EOL] pr . disable ( ) [EOL] ps = pstats . Stats ( pr , stream = sys . stdout ) [EOL] ps . sort_stats ( [string] ) [EOL] ps . print_stats ( [number] ) [EOL] else : [EOL] logging . error ( [string] [string] [string] . format ( sys . platform ) ) [EOL] result = func ( * args , ** kwargs ) [EOL] else : [EOL] result = func ( * args , ** kwargs ) [EOL] [EOL] return result [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Union [EOL] import _typing [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import sublime [EOL] from functools import partial [EOL] [EOL] from . _typing import Union , Dict [EOL] [EOL] [EOL] class JediUsages ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = text [EOL] [EOL] def process ( self , usages = False , data = None ) : [EOL] [docstring] [EOL] [EOL] view = self . text . view [EOL] if not data [ [string] ] : [EOL] sublime . status_message ( [string] . format ( view . substr ( view . word ( view . sel ( ) [ [number] ] ) ) ) ) [EOL] return [EOL] [EOL] definitions = data [ [string] ] if not usages else data [ [string] ] [EOL] if len ( definitions ) == [number] : [EOL] sublime . status_message ( [string] . format ( view . substr ( view . word ( view . sel ( ) [ [number] ] ) ) ) ) [EOL] return [EOL] [EOL] if definitions is not None and len ( definitions ) == [number] and not usages : [EOL] self . _jump ( * definitions [ [number] ] ) [EOL] else : [EOL] self . _show_options ( definitions , usages ) [EOL] [EOL] def _jump ( self , filename , lineno = None , columno = None , transient = False ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if type ( filename ) is int : [EOL] if filename == - [number] : [EOL] [comment] [EOL] view = self . text . view [EOL] point = self . point [EOL] [EOL] sublime . active_window ( ) . focus_view ( view ) [EOL] view . show ( point ) [EOL] [EOL] if view . sel ( ) [ [number] ] != point : [EOL] view . sel ( ) . clear ( ) [EOL] view . sel ( ) . add ( point ) [EOL] [EOL] return [EOL] [EOL] opts = self . options [ filename ] [EOL] if len ( self . options [ filename ] ) == [number] : [EOL] opts = opts [ [number] : ] [EOL] [EOL] filename , lineno , columno = opts [EOL] flags = sublime . ENCODED_POSITION [EOL] if transient : [EOL] flags |= sublime . TRANSIENT [EOL] [EOL] sublime . active_window ( ) . open_file ( [string] . format ( filename , lineno or [number] , columno or [number] ) , flags ) [EOL] [EOL] self . _toggle_indicator ( lineno , columno ) [EOL] [EOL] def _show_options ( self , defs , usages ) : [EOL] [docstring] [EOL] [EOL] view = self . text . view [EOL] if usages or ( not usages and type ( defs ) is not str ) : [EOL] if len ( defs ) == [number] : [EOL] options = [ [ o [ [number] ] , o [ [number] ] , [string] . format ( o [ [number] ] , o [ [number] ] ) ] for o in defs ] [EOL] else : [EOL] options = [ [ o [ [number] ] , [string] . format ( o [ [number] ] , o [ [number] ] ) ] for o in defs ] [EOL] else : [EOL] if len ( defs ) : [EOL] options = defs [ [number] ] [EOL] else : [EOL] sublime . status_message ( [string] . format ( view . substr ( view . word ( view . sel ( ) [ [number] ] ) ) ) ) [EOL] return [EOL] [EOL] self . options = defs [EOL] self . point = self . text . view . sel ( ) [ [number] ] [EOL] self . text . view . window ( ) . show_quick_panel ( options , self . _jump , on_highlight = partial ( self . _jump , transient = True ) ) [EOL] [EOL] def _toggle_indicator ( self , lineno = [number] , columno = [number] ) : [EOL] [docstring] [EOL] [EOL] pt = self . text . view . text_point ( lineno - [number] , columno ) [EOL] region_name = [string] . format ( self . text . view . id ( ) , lineno ) [EOL] [EOL] for i in range ( [number] ) : [EOL] delta = [number] * i * [number] [EOL] sublime . set_timeout ( lambda : self . text . view . add_regions ( region_name , [ sublime . Region ( pt , pt ) ] , [string] , [string] , sublime . DRAW_EMPTY_AS_OVERWRITE ) , delta ) [EOL] sublime . set_timeout ( lambda : self . text . view . erase_regions ( region_name ) , delta + [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime [EOL] [EOL] [EOL] class Integration : [EOL] [docstring] [EOL] [EOL] @ classmethod def enabled ( cls ) : [EOL] [docstring] [EOL] [EOL] globalsettings = sublime . load_settings ( [string] ) [EOL] settings = sublime . load_settings ( [string] ) [EOL] enabled = settings . get ( [string] , False ) [EOL] not_ignored = [string] not in globalsettings . get ( [string] ) [EOL] if enabled and not_ignored : [EOL] try : [EOL] from Kite . lib . installer import check [EOL] from Kite . lib . exceptions import KiteNotSupported [EOL] if not check . is_running ( ) : [EOL] return False [EOL] except ImportError : [EOL] return False [EOL] except KiteNotSupported : [EOL] [comment] [EOL] return True [EOL] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] @ classmethod def enable ( cls ) : [EOL] [docstring] [EOL] [EOL] settings = sublime . load_settings ( [string] ) [EOL] settings . set ( [string] , True ) [EOL] settings . save_settings ( [string] ) [EOL] [EOL] @ classmethod def disable ( cls ) : [EOL] [docstring] [EOL] [EOL] settings = sublime . load_settings ( [string] ) [EOL] settings . set ( [string] , False ) [EOL] settings . save_settings ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . anaconda_lib import aenum as enum [EOL] [EOL] [EOL] class WorkerStatus ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] incomplete = [number] [EOL] healthy = [number] [EOL] faulty = [number] [EOL] quiting = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Repr ( type ) : [EOL] [docstring] [EOL] [EOL] def __repr__ ( cls ) : [EOL] if hasattr ( cls , [string] ) : [EOL] return getattr ( cls , [string] ) ( ) [EOL] [EOL] return super ( Repr , cls ) . __repr__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import threading [EOL] import subprocess [EOL] [EOL] from . logger import Log [EOL] from . contexts import vagrant_root [EOL] from . helpers import create_subprocess [EOL] [EOL] PIPE = subprocess . PIPE [EOL] [EOL] [EOL] class VagrantBase ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine ) : [EOL] super ( VagrantBase , self ) . __init__ ( ) [EOL] self . machine = machine if machine is not None else [string] [EOL] self . callback = callback [EOL] self . vagrant_root = vagrant_root [EOL] [EOL] def wait_answer ( self , args ) : [EOL] [docstring] [EOL] [EOL] with vagrant_root ( self . vagrant_root ) : [EOL] proc = create_subprocess ( args , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] output , error = proc . communicate ( ) [EOL] [EOL] self . callback ( ( proc . poll ( ) == [number] , output , error ) ) [EOL] [EOL] [EOL] class VagrantInit ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , box ) : [EOL] super ( VagrantInit , self ) . __init__ ( callback , vagrant_root ) [EOL] self . box = box [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . box ] ) [EOL] [EOL] [EOL] class VagrantUp ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine = None ) : [EOL] super ( VagrantUp , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . machine ] ) [EOL] [EOL] [EOL] class VagrantReload ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine = None ) : [EOL] super ( VagrantReload , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . machine ] ) [EOL] [EOL] [EOL] class VagrantStatus ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine = None , full = False ) : [EOL] super ( VagrantStatus , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . full = full [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] args = [ [string] , [string] , self . machine ] [EOL] with vagrant_root ( self . vagrant_root ) : [EOL] proc = create_subprocess ( args , stdout = subprocess . PIPE , stderr = subprocess . PIPE , cwd = os . getcwd ( ) ) [EOL] output , error = proc . communicate ( ) [EOL] [EOL] if proc . poll ( ) != [number] : [EOL] self . callback ( ( False , error ) ) [EOL] else : [EOL] running = [string] in output [EOL] self . callback ( ( True , running if not self . full else output ) ) [EOL] [EOL] [EOL] class VagrantSSH ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , cmd , machine = None ) : [EOL] super ( VagrantSSH , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . cmd = cmd [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . machine , [string] , self . cmd ] ) [EOL] [EOL] [EOL] class VagrantIPAddress ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , root , machine = None , iface = [string] ) : [EOL] [EOL] with vagrant_root ( root ) : [EOL] cmd = ( [string] [string] [string] [string] ) . format ( iface ) [EOL] proc = create_subprocess ( [ [string] , [string] , machine , [string] , cmd ] , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] [EOL] output , error = proc . communicate ( ) [EOL] if proc . poll ( ) != [number] : [EOL] self . ip_address = None [EOL] else : [EOL] self . ip_address = output [EOL] [EOL] [EOL] class VagrantIPAddressGlobal ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , machine , iface = [string] ) : [EOL] [EOL] cmd = ( [string] [string] [string] [string] ) . format ( iface ) [EOL] proc = create_subprocess ( [ [string] , [string] , machine , [string] , cmd ] , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] [EOL] output , error = proc . communicate ( ) [EOL] if proc . poll ( ) != [number] : [EOL] self . ip_address = None [EOL] else : [EOL] self . ip_address = output [EOL] [EOL] [EOL] class VagrantMachineGlobalInfo ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , machine ) : [EOL] self . machine = machine [EOL] self . status = [string] [EOL] self . machine_id = [string] [EOL] [EOL] args = ( [string] , [string] ) [EOL] p = create_subprocess ( args , stdout = PIPE , stderr = PIPE ) [EOL] if p is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] output , err = p . communicate ( ) [EOL] if err : [EOL] raise RuntimeError ( err ) [EOL] [EOL] for line in output . splitlines ( ) [ [number] : ] : [EOL] if not line : [EOL] continue [EOL] [EOL] if line . startswith ( [string] ) : [EOL] break [EOL] [EOL] data = line . split ( ) [EOL] if not data : [EOL] continue [EOL] [EOL] if data [ [number] ] . decode ( [string] ) == machine : [EOL] self . machine_id = data [ [number] ] . decode ( [string] ) [EOL] self . status = data [ [number] ] . decode ( [string] ) [EOL] self . directory = data [ [number] ] . decode ( [string] ) [EOL] break [EOL] [EOL] [EOL] class VagrantStartMachine ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , machine , directory ) : [EOL] with vagrant_root ( directory ) : [EOL] args = ( [string] , [string] , machine ) [EOL] p = create_subprocess ( args , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] if p is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] output , err = p . communicate ( ) [EOL] Log . info ( output . decode ( [string] ) ) [EOL] if err : [EOL] [comment] [EOL] info = VagrantMachineGlobalInfo ( machine ) [EOL] if info . status != [string] : [EOL] raise RuntimeError ( err ) [EOL] [EOL] Log . error ( err . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.list$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , DefaultDict , List , Tuple , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import json [EOL] import logging [EOL] import functools [EOL] import traceback [EOL] import subprocess [EOL] from collections import defaultdict [EOL] [EOL] import sublime [EOL] [EOL] from . kite import Integration [EOL] [EOL] [comment] [EOL] git_installation = False [EOL] try : [EOL] import Anaconda [EOL] assert Anaconda [EOL] except ImportError : [EOL] git_installation = True [EOL] [EOL] NONE = [number] [EOL] ONLY_CODE = [number] [EOL] NOT_SCRATCH = [number] [EOL] LINTING_ENABLED = [number] [EOL] [EOL] ENVIRON_HOOK_INVALID = defaultdict ( lambda : False ) [EOL] AUTO_COMPLETION_DOT_VIEWS = [ ] [EOL] [EOL] [EOL] def dot_completion ( view ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] if ( view . window ( ) . id ( ) , view . id ( ) ) in AUTO_COMPLETION_DOT_VIEWS : [EOL] return True [EOL] [EOL] for trigger in view . settings ( ) . get ( [string] , [ ] ) : [EOL] if trigger . get ( [string] , [string] ) == [string] : [EOL] if [string] in trigger . get ( [string] ) : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def enable_dot_completion ( view ) : [EOL] [docstring] [EOL] [EOL] global AUTO_COMPLETION_DOT_VIEWS [EOL] [EOL] if view is None : [EOL] return [EOL] [EOL] triggers = view . settings ( ) . get ( [string] , [ ] ) [EOL] triggers . append ( { [string] : [string] , [string] : [string] } ) [EOL] view . settings ( ) . set ( [string] , triggers ) [EOL] [EOL] AUTO_COMPLETION_DOT_VIEWS . append ( ( view . window ( ) . id ( ) , view . id ( ) ) ) [EOL] [EOL] [EOL] def completion_is_disabled ( view ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] [comment] [EOL] if Integration . enabled ( ) : [EOL] return True [EOL] [EOL] return get_settings ( view , [string] , False ) [EOL] [EOL] [EOL] def is_code ( view , lang = [string] , ignore_comments = False , ignore_repl = False ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] [comment] [EOL] if view . settings ( ) . get ( [string] , False ) : [EOL] if not ignore_repl : [EOL] return False [EOL] [EOL] try : [EOL] location = view . sel ( ) [ [number] ] . begin ( ) [EOL] except IndexError : [EOL] return False [EOL] [EOL] if ignore_comments is True : [EOL] matcher = [string] . format ( lang ) [EOL] else : [EOL] matcher = [string] . format ( lang ) [EOL] [EOL] return view . match_selector ( location , matcher ) [EOL] [EOL] [EOL] def is_python ( view , ignore_comments = False , autocomplete_ignore_repl = False ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] [comment] [EOL] if view . settings ( ) . get ( [string] , False ) : [EOL] if not autocomplete_ignore_repl : [EOL] return False [EOL] [EOL] try : [EOL] location = view . sel ( ) [ [number] ] . begin ( ) [EOL] except IndexError : [EOL] return False [EOL] [EOL] if ignore_comments is True : [EOL] matcher = [string] [EOL] else : [EOL] matcher = [string] [EOL] [EOL] return view . match_selector ( location , matcher ) [EOL] [EOL] [EOL] def check_linting ( view , mask , code = [string] ) : [EOL] [docstring] [EOL] [EOL] if mask & ONLY_CODE and not is_code ( view , lang = code , ignore_comments = True ) : [EOL] return False [EOL] [EOL] if mask & NOT_SCRATCH and view . is_scratch ( ) : [EOL] return False [EOL] [EOL] if ( mask & LINTING_ENABLED and not get_settings ( view , [string] , False ) ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def check_linting_behaviour ( view , behaviours ) : [EOL] [docstring] [EOL] [EOL] b = get_settings ( view , [string] , [string] ) [EOL] return b in behaviours [EOL] [EOL] [EOL] def create_subprocess ( args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if [string] not in kwargs : [EOL] kwargs [ [string] ] = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] kwargs [ [string] ] = - [number] [EOL] [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] kwargs [ [string] ] = startupinfo [EOL] [EOL] if sublime . platform ( ) == [string] : [EOL] env = kwargs [ [string] ] if [string] in kwargs else os . environ . copy ( ) [EOL] if [string] in kwargs : [EOL] env = env [EOL] [EOL] env [ [string] ] = [string] [EOL] kwargs [ [string] ] = env [EOL] [EOL] try : [EOL] return subprocess . Popen ( args , ** kwargs ) [EOL] except Exception as e : [EOL] logging . error ( [string] [string] [string] [string] . format ( args [ [number] ] , e ) ) [EOL] [EOL] [EOL] def get_settings ( view , name , default = None ) : [EOL] [docstring] [EOL] [EOL] global ENVIRON_HOOK_INVALID [EOL] [EOL] if view is None : [EOL] return default [EOL] [EOL] plugin_settings = sublime . load_settings ( [string] ) [EOL] [EOL] if ( name in ( [string] , [string] ) and not ENVIRON_HOOK_INVALID [ view . id ( ) ] ) : [EOL] if view . window ( ) is not None and view . window ( ) . folders ( ) : [EOL] dirname = view . window ( ) . folders ( ) [ [number] ] [EOL] while True : [EOL] environfile = os . path . join ( dirname , [string] ) [EOL] if os . path . exists ( environfile ) and os . path . isfile ( environfile ) : [EOL] [comment] [EOL] with open ( environfile , [string] ) as jsonfile : [EOL] try : [EOL] data = json . loads ( jsonfile . read ( ) ) [EOL] except Exception as error : [EOL] sublime . error_message ( [string] [string] [string] [string] [string] . format ( environfile ) ) [EOL] logging . error ( error ) [EOL] ENVIRON_HOOK_INVALID [ view . id ( ) ] = True [EOL] break [comment] [EOL] else : [EOL] r = data . get ( name , view . settings ( ) . get ( name , plugin_settings . get ( name , default ) ) ) [EOL] w = view . window ( ) [EOL] if w is not None : [EOL] return sublime . expand_variables ( r , w . extract_variables ( ) ) [EOL] [EOL] return r [EOL] else : [EOL] parts = os . path . split ( dirname ) [EOL] if len ( parts [ [number] ] ) > [number] : [EOL] dirname = os . path . dirname ( dirname ) [EOL] else : [EOL] break [comment] [EOL] [EOL] r = view . settings ( ) . get ( name , plugin_settings . get ( name , default ) ) [EOL] if name == [string] : [EOL] r = expand ( view , r ) [EOL] elif name == [string] : [EOL] if isinstance ( r , ( list , tuple ) ) : [EOL] r = [ expand ( view , e ) for e in r ] [EOL] else : [EOL] r = expand ( view , r ) [EOL] [EOL] return r [EOL] [EOL] [EOL] def expand ( view , path ) : [EOL] [docstring] [EOL] [EOL] window = view . window ( ) [EOL] if window is not None : [EOL] tmp = sublime . expand_variables ( path , window . extract_variables ( ) ) [EOL] tmp = os . path . expanduser ( os . path . expandvars ( tmp ) ) [EOL] else : [EOL] return path [EOL] [EOL] return tmp [EOL] [EOL] [EOL] def active_view ( ) : [EOL] [docstring] [EOL] [EOL] return sublime . active_window ( ) . active_view ( ) [EOL] [EOL] [EOL] def is_remote_session ( view ) : [EOL] [docstring] [EOL] [EOL] if [string] in get_interpreter ( view ) : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def prepare_send_data ( location , method , handler ) : [EOL] [docstring] [EOL] [EOL] view = active_view ( ) [EOL] return { [string] : view . substr ( sublime . Region ( [number] , view . size ( ) ) ) , [string] : location [ [number] ] + [number] , [string] : location [ [number] ] , [string] : view . file_name ( ) or [string] , [string] : method , [string] : handler } [EOL] [EOL] [EOL] def project_name ( ) : [EOL] [docstring] [EOL] [EOL] window = sublime . active_window ( ) [EOL] project_name = window . project_file_name ( ) [EOL] if project_name is None : [EOL] folders = window . folders ( ) [EOL] if len ( folders ) > [number] : [EOL] try : [EOL] project_name = window . folders ( ) [ [number] ] . rsplit ( os . sep , [number] ) [ [number] ] [EOL] except IndexError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v = active_view ( ) [EOL] if v is not None and v . file_name ( ) is not None : [EOL] project_name = v . file_name ( ) . rsplit ( os . sep , [number] ) [ [number] ] [EOL] else : [EOL] project_name = [string] . format ( id = window . window_id ) [EOL] else : [EOL] project_name = [string] . format ( id = window . window_id ) [EOL] else : [EOL] project_name = project_name . rsplit ( os . sep , [number] ) [ [number] ] . split ( [string] ) [ [number] ] [EOL] [EOL] return project_name [EOL] [EOL] [EOL] def get_traceback ( ) : [EOL] [docstring] [EOL] [EOL] traceback_log = [ ] [EOL] for traceback_line in traceback . format_exc ( ) . splitlines ( ) : [EOL] traceback_log . append ( traceback_line ) [EOL] [EOL] return [string] . join ( traceback_log ) [EOL] [EOL] [EOL] def get_view ( window , vid ) : [EOL] [docstring] [EOL] [EOL] for view in window . views ( ) : [EOL] if view . id ( ) == vid : [EOL] return view [EOL] [EOL] [EOL] def get_window_view ( vid ) : [EOL] [docstring] [EOL] [EOL] for window in sublime . windows ( ) : [EOL] view = get_view ( window , vid ) [EOL] if view is not None : [EOL] return view [EOL] [EOL] [EOL] def cache ( func ) : [EOL] [docstring] [EOL] [EOL] cache = { } [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] if [string] in kwargs : [EOL] cache . pop ( func . __name__ ) [EOL] [EOL] result = cache . get ( func . __name__ , cache . setdefault ( func . __name__ , func ( * args , ** kwargs ) ) ) [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] @ cache def valid_languages ( ** kwargs ) : [EOL] [docstring] [EOL] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , os . pardir ) [EOL] languages = [ f . rsplit ( [string] , [number] ) [ [number] ] . lower ( ) for f in os . listdir ( path ) if f . startswith ( [string] ) and [string] not in f ] [EOL] [EOL] return [ [string] ] + languages [EOL] [EOL] [EOL] def get_interpreter ( view ) : [EOL] [docstring] [EOL] [EOL] return get_settings ( view , [string] , [string] ) [EOL] [EOL] [EOL] def debug_enabled ( view ) : [EOL] [docstring] [EOL] [EOL] return get_settings ( active_view ( ) , [string] , False ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Type [EOL] import typing [EOL] import logging [EOL] import sys [EOL] import logging [EOL] import functools [EOL] [EOL] import sublime [EOL] [EOL] from . helpers import get_settings , active_view [EOL] [EOL] [EOL] def prevent_spam ( func ) : [EOL] [docstring] [EOL] [EOL] _last_messages = { } [EOL] [EOL] def _remove_from_cache ( args ) : [EOL] m = _last_messages . pop ( args ) [EOL] if m == [number] : [EOL] return [EOL] [EOL] method = getattr ( Log . _logger , args [ [number] ] ) [EOL] method ( [string] . format ( args [ [number] ] , [string] if m == [number] else [string] . format ( m ) ) ) [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( cls , * args , ** kwargs ) : [EOL] if args in _last_messages : [EOL] _last_messages [ args ] += [number] [EOL] return [EOL] [EOL] _last_messages [ args ] = [number] [EOL] sublime . set_timeout_async ( lambda : _remove_from_cache ( args ) , [number] ) [EOL] func ( cls , args [ [number] ] , * args [ [number] : ] , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] class MetaLog ( type ) : [EOL] [EOL] def __new__ ( cls , name , bases , attrs , ** kwargs ) : [EOL] log_level = get_settings ( active_view ( ) , [string] , [string] ) [EOL] if log_level not in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] log_level = [string] [EOL] [EOL] cls . _logger = logging . getLogger ( [string] ) [EOL] cls . _logger . setLevel ( logging . __getattribute__ ( log_level . upper ( ) ) ) [EOL] log_handler = logging . StreamHandler ( sys . stdout ) [EOL] log_handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] [EOL] cls . _logger . addHandler ( log_handler ) [EOL] cls . _logger . propagate = False [EOL] [EOL] obj = super ( ) . __new__ ( cls , name , bases , attrs ) [EOL] for method in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] setattr ( obj , method , functools . partial ( obj . write , method ) ) [EOL] [EOL] return obj [EOL] [EOL] [EOL] class Log ( metaclass = MetaLog ) : [EOL] [docstring] [EOL] [EOL] @ classmethod @ prevent_spam def write ( cls , method , * args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] f = getattr ( cls . _logger , method ) [EOL] f ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] import os [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] @ contextmanager def vagrant_root ( directory ) : [EOL] current_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . expanduser ( directory ) ) [EOL] yield [EOL] os . chdir ( current_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import _typing [EOL] import typing [EOL] import sublime [EOL] import builtins [EOL] import sublime [EOL] [EOL] from . _typing import List [EOL] from Default . history_list import get_jump_history_for_view [EOL] [EOL] [EOL] class ExplorerPanel : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , view , options ) : [EOL] self . options = options [EOL] self . view = view [EOL] self . selected = [ ] [comment] [EOL] self . restore_point = view . sel ( ) [ [number] ] [EOL] [EOL] def show ( self , cluster , forced = False ) : [EOL] [docstring] [EOL] [EOL] if not cluster : [EOL] cluster = self . options [EOL] [EOL] if len ( cluster ) == [number] and not forced : [EOL] try : [EOL] Jumper ( self . view , cluster [ [number] ] [ [string] ] ) . jump ( ) [EOL] except KeyError : [EOL] if len ( cluster [ [number] ] . get ( [string] , [ ] ) ) == [number] and not forced : [EOL] Jumper ( self . view , cluster [ [number] ] [ [string] ] [ [number] ] [ [string] ] ) . jump ( ) [EOL] return [EOL] [EOL] self . last_cluster = cluster [EOL] quick_panel_options = [ ] [EOL] for data in cluster : [EOL] tmp = [ data [ [string] ] ] [EOL] if [string] in data : [EOL] tmp . append ( data [ [string] ] ) [EOL] if [string] in data : [EOL] tmp . append ( data [ [string] ] ) [EOL] quick_panel_options . append ( tmp ) [EOL] [EOL] self . view . window ( ) . show_quick_panel ( quick_panel_options , on_select = self . on_select , on_highlight = lambda index : self . on_select ( index , True ) ) [EOL] [EOL] def on_select ( self , index , transient = False ) : [EOL] [docstring] [EOL] [EOL] if index == - [number] : [EOL] self . _restore_view ( ) [EOL] return [EOL] [EOL] cluster = self . last_cluster [EOL] node = cluster [ index ] [EOL] if transient and [string] in node : [EOL] return [EOL] [EOL] if [string] in node : [EOL] self . prev_cluster = self . last_cluster [EOL] opts = node [ [string] ] [ : ] [EOL] opts . insert ( [number] , { [string] : [string] , [string] : [string] } ) [EOL] sublime . set_timeout ( lambda : self . show ( opts ) , [number] ) [EOL] else : [EOL] if node [ [string] ] == [string] and not transient : [EOL] sublime . set_timeout ( lambda : self . show ( self . prev_cluster ) , [number] ) [EOL] elif node [ [string] ] != [string] : [EOL] Jumper ( self . view , node [ [string] ] ) . jump ( transient ) [EOL] [EOL] def _restore_view ( self ) : [EOL] [docstring] [EOL] [EOL] sublime . active_window ( ) . focus_view ( self . view ) [EOL] self . view . show ( self . restore_point ) [EOL] [EOL] if self . view . sel ( ) [ [number] ] != self . restore_point : [EOL] self . view . sel ( ) . clear ( ) [EOL] self . view . sel ( ) . add ( self . restore_point ) [EOL] [EOL] [EOL] class Jumper : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , view , position ) : [EOL] self . position = position [EOL] self . view = view [EOL] [EOL] def jump ( self , transient = False ) : [EOL] [docstring] [EOL] [EOL] flags = sublime . ENCODED_POSITION [EOL] if transient is True : [EOL] flags |= sublime . TRANSIENT [EOL] [EOL] get_jump_history_for_view ( self . view ) . push_selection ( self . view ) [EOL] sublime . active_window ( ) . open_file ( self . position , flags ) [EOL] if not transient : [EOL] self . _toggle_indicator ( ) [EOL] [EOL] def _toggle_indicator ( self ) : [EOL] [docstring] [EOL] [EOL] path , line , column = self . position . rsplit ( [string] , [number] ) [EOL] pt = self . view . text_point ( int ( line ) - [number] , int ( column ) ) [EOL] region_name = [string] . format ( self . view . id ( ) , line ) [EOL] [EOL] for i in range ( [number] ) : [EOL] delta = [number] * i * [number] [EOL] sublime . set_timeout ( lambda : self . view . add_regions ( region_name , [ sublime . Region ( pt , pt ) ] , [string] , [string] , sublime . DRAW_EMPTY_AS_OVERWRITE ) , delta ) [EOL] sublime . set_timeout ( lambda : self . view . erase_regions ( region_name ) , delta + [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] import platform [EOL] import tempfile [EOL] [EOL] [EOL] class UnixSocketPath ( object ) : [EOL] [docstring] [EOL] [EOL] socketpath = { [string] : os . path . join ( [string] , [string] , [string] , [string] , [string] ) , [string] : os . path . join ( [string] , [string] , [string] , [string] ) } [EOL] [EOL] def __init__ ( self , project ) : [EOL] self . __project = project [EOL] self . __socket_file = os . path . join ( os . path . expanduser ( UnixSocketPath . socketpath . get ( platform . system ( ) . lower ( ) ) ) , project or [string] , [string] ) [EOL] [EOL] @ property def socket ( self ) : [EOL] [docstring] [EOL] [EOL] if len ( self . __socket_file ) < [number] : [EOL] return self . __socket_file [EOL] [EOL] socket_path = os . path . join ( tempfile . gettempdir ( ) , self . __project or [string] , [string] ) [EOL] if len ( socket_path ) > [number] : [EOL] [comment] [EOL] socket_path = os . path . join ( tempfile . gettempdir ( ) , self . __project [ : [number] ] , [string] ) [EOL] [EOL] return socket_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from . autopep_wrapper import AnacondaAutopep8 [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] import threading [EOL] [EOL] from . autopep8_lib import autopep8 [EOL] [EOL] [EOL] class AnacondaAutopep8 ( threading . Thread ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , settings , code , callback ) : [EOL] threading . Thread . __init__ ( self ) [EOL] self . code = code [EOL] self . callback = callback [EOL] self . options , _ = autopep8 . parse_args ( self . parse_settings ( settings ) ) [EOL] [EOL] def run ( self ) : [EOL] self . callback ( autopep8 . fix_string ( self . code , options = self . options ) ) [EOL] [EOL] def parse_settings ( self , settings ) : [EOL] [docstring] [EOL] [EOL] args = [ ] [EOL] args += [ [string] ] * settings . get ( [string] , [number] ) [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] args += [ [string] . format ( settings . get ( [string] , [number] ) ) ] [EOL] args += [ [string] ] [EOL] [EOL] return args [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Optional , Any , Union , Literal , DefaultDict , Type , Match , List , Tuple , Pattern , Set , Iterator , Dict [EOL] import typing_extensions [EOL] import argparse [EOL] import io [EOL] import multiprocessing [EOL] import typing [EOL] import configparser [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] import codecs [EOL] import collections [EOL] import copy [EOL] import difflib [EOL] import fnmatch [EOL] import inspect [EOL] import io [EOL] import keyword [EOL] import locale [EOL] import os [EOL] import re [EOL] import signal [EOL] import sys [EOL] import textwrap [EOL] import token [EOL] import tokenize [EOL] [EOL] import pycodestyle [EOL] [EOL] [EOL] try : [EOL] unicode [EOL] except NameError : [EOL] unicode = str [EOL] [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] CR = [string] [EOL] LF = [string] [EOL] CRLF = [string] [EOL] [EOL] [EOL] PYTHON_SHEBANG_REGEX = re . compile ( [string] ) [EOL] LAMBDA_REGEX = re . compile ( [string] ) [EOL] COMPARE_NEGATIVE_REGEX = re . compile ( [string] ) [EOL] COMPARE_NEGATIVE_REGEX_THROUGH = re . compile ( [string] ) [EOL] BARE_EXCEPT_REGEX = re . compile ( [string] ) [EOL] STARTSWITH_DEF_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] SHORTEN_OPERATOR_GROUPS = frozenset ( [ frozenset ( [ [string] ] ) , frozenset ( [ [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) , ] ) [EOL] [EOL] [EOL] DEFAULT_IGNORE = [string] [EOL] DEFAULT_INDENT_SIZE = [number] [EOL] [EOL] [EOL] [comment] [EOL] CODE_TO_2TO3 = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] [EOL] if sys . platform == [string] : [comment] [EOL] DEFAULT_CONFIG = os . path . expanduser ( [string] ) [EOL] else : [EOL] DEFAULT_CONFIG = os . path . join ( os . getenv ( [string] ) or os . path . expanduser ( [string] ) , [string] ) [EOL] PROJECT_CONFIG = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] MAX_PYTHON_FILE_DETECTION_BYTES = [number] [EOL] [EOL] [EOL] def open_with_encoding ( filename , encoding = None , mode = [string] , limit_byte_check = - [number] ) : [EOL] [docstring] [EOL] if not encoding : [EOL] encoding = detect_encoding ( filename , limit_byte_check = limit_byte_check ) [EOL] [EOL] return io . open ( filename , mode = mode , encoding = encoding , newline = [string] ) [comment] [EOL] [EOL] [EOL] def detect_encoding ( filename , limit_byte_check = - [number] ) : [EOL] [docstring] [EOL] try : [EOL] with open ( filename , [string] ) as input_file : [EOL] from lib2to3 . pgen2 import tokenize as lib2to3_tokenize [EOL] encoding = lib2to3_tokenize . detect_encoding ( input_file . readline ) [ [number] ] [EOL] [EOL] with open_with_encoding ( filename , encoding ) as test_file : [EOL] test_file . read ( limit_byte_check ) [EOL] [EOL] return encoding [EOL] except ( LookupError , SyntaxError , UnicodeDecodeError ) : [EOL] return [string] [EOL] [EOL] [EOL] def readlines_from_file ( filename ) : [EOL] [docstring] [EOL] with open_with_encoding ( filename ) as input_file : [EOL] return input_file . readlines ( ) [EOL] [EOL] [EOL] def extended_blank_lines ( logical_line , blank_lines , blank_before , indent_level , previous_logical ) : [EOL] [docstring] [EOL] if previous_logical . startswith ( [string] ) : [EOL] if blank_lines and pycodestyle . DOCSTRING_REGEX . match ( logical_line ) : [EOL] yield ( [number] , [string] . format ( blank_lines ) ) [EOL] elif pycodestyle . DOCSTRING_REGEX . match ( previous_logical ) : [EOL] [comment] [EOL] if ( indent_level and not blank_lines and not blank_before and logical_line . startswith ( ( [string] ) ) and [string] in logical_line ) : [EOL] yield ( [number] , [string] ) [EOL] [EOL] [EOL] pycodestyle . register_check ( extended_blank_lines ) [EOL] [EOL] [EOL] def continued_indentation ( logical_line , tokens , indent_level , indent_char , noqa ) : [EOL] [docstring] [EOL] first_row = tokens [ [number] ] [ [number] ] [ [number] ] [EOL] nrows = [number] + tokens [ - [number] ] [ [number] ] [ [number] ] - first_row [EOL] if noqa or nrows == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] indent_next = logical_line . endswith ( [string] ) [EOL] [EOL] row = depth = [number] [EOL] valid_hangs = ( ( DEFAULT_INDENT_SIZE , ) [EOL] if indent_char != [string] else ( DEFAULT_INDENT_SIZE , [number] * DEFAULT_INDENT_SIZE ) ) [EOL] [EOL] [comment] [EOL] parens = [ [number] ] * nrows [EOL] [EOL] [comment] [EOL] rel_indent = [ [number] ] * nrows [EOL] [EOL] [comment] [EOL] open_rows = [ [ [number] ] ] [EOL] [comment] [EOL] hangs = [ None ] [EOL] [EOL] [comment] [EOL] indent_chances = { } [EOL] last_indent = tokens [ [number] ] [ [number] ] [EOL] indent = [ last_indent [ [number] ] ] [EOL] [EOL] last_token_multiline = None [EOL] line = None [EOL] last_line = [string] [EOL] last_line_begins_with_multiline = False [EOL] for token_type , text , start , end , line in tokens : [EOL] [EOL] newline = row < start [ [number] ] - first_row [EOL] if newline : [EOL] row = start [ [number] ] - first_row [EOL] newline = ( not last_token_multiline and token_type not in ( tokenize . NL , tokenize . NEWLINE ) ) [EOL] last_line_begins_with_multiline = last_token_multiline [EOL] [EOL] if newline : [EOL] [comment] [EOL] last_indent = start [EOL] [EOL] [comment] [EOL] rel_indent [ row ] = pycodestyle . expand_indent ( line ) - indent_level [EOL] [EOL] [comment] [EOL] close_bracket = ( token_type == tokenize . OP and text in [string] ) [EOL] [EOL] [comment] [EOL] for open_row in reversed ( open_rows [ depth ] ) : [EOL] hang = rel_indent [ row ] - rel_indent [ open_row ] [EOL] hanging_indent = hang in valid_hangs [EOL] if hanging_indent : [EOL] break [EOL] if hangs [ depth ] : [EOL] hanging_indent = ( hang == hangs [ depth ] ) [EOL] [EOL] visual_indent = ( not close_bracket and hang > [number] and indent_chances . get ( start [ [number] ] ) ) [EOL] [EOL] if close_bracket and indent [ depth ] : [EOL] [comment] [EOL] if start [ [number] ] != indent [ depth ] : [EOL] yield ( start , [string] . format ( indent [ depth ] ) ) [EOL] elif close_bracket and not hang : [EOL] pass [EOL] elif indent [ depth ] and start [ [number] ] < indent [ depth ] : [EOL] [comment] [EOL] yield ( start , [string] . format ( indent [ depth ] ) ) [EOL] elif ( hanging_indent or ( indent_next and rel_indent [ row ] == [number] * DEFAULT_INDENT_SIZE ) ) : [EOL] [comment] [EOL] if close_bracket : [EOL] yield ( start , [string] . format ( indent_level + rel_indent [ open_row ] ) ) [EOL] hangs [ depth ] = hang [EOL] elif visual_indent is True : [EOL] [comment] [EOL] indent [ depth ] = start [ [number] ] [EOL] elif visual_indent in ( text , unicode ) : [EOL] [comment] [EOL] pass [EOL] else : [EOL] one_indented = ( indent_level + rel_indent [ open_row ] + DEFAULT_INDENT_SIZE ) [EOL] [comment] [EOL] if hang <= [number] : [EOL] error = ( [string] , one_indented ) [EOL] elif indent [ depth ] : [EOL] error = ( [string] , indent [ depth ] ) [EOL] elif not close_bracket and hangs [ depth ] : [EOL] error = ( [string] , one_indented ) [EOL] elif hang > DEFAULT_INDENT_SIZE : [EOL] error = ( [string] , one_indented ) [EOL] else : [EOL] hangs [ depth ] = hang [EOL] error = ( [string] , one_indented ) [EOL] [EOL] yield ( start , [string] . format ( * error ) ) [EOL] [EOL] [comment] [EOL] if ( parens [ row ] and token_type not in ( tokenize . NL , tokenize . COMMENT ) and not indent [ depth ] ) : [EOL] indent [ depth ] = start [ [number] ] [EOL] indent_chances [ start [ [number] ] ] = True [EOL] [comment] [EOL] elif ( token_type in ( tokenize . STRING , tokenize . COMMENT ) or text in ( [string] , [string] , [string] , [string] ) ) : [EOL] indent_chances [ start [ [number] ] ] = unicode [EOL] [comment] [EOL] [comment] [EOL] elif not indent_chances and not row and not depth and text == [string] : [EOL] indent_chances [ end [ [number] ] + [number] ] = True [EOL] elif text == [string] and line [ end [ [number] ] : ] . isspace ( ) : [EOL] open_rows [ depth ] . append ( row ) [EOL] [EOL] [comment] [EOL] if token_type == tokenize . OP : [EOL] if text in [string] : [EOL] depth += [number] [EOL] indent . append ( [number] ) [EOL] hangs . append ( None ) [EOL] if len ( open_rows ) == depth : [EOL] open_rows . append ( [ ] ) [EOL] open_rows [ depth ] . append ( row ) [EOL] parens [ row ] += [number] [EOL] elif text in [string] and depth > [number] : [EOL] [comment] [EOL] prev_indent = indent . pop ( ) or last_indent [ [number] ] [EOL] hangs . pop ( ) [EOL] for d in range ( depth ) : [EOL] if indent [ d ] > prev_indent : [EOL] indent [ d ] = [number] [EOL] for ind in list ( indent_chances ) : [EOL] if ind >= prev_indent : [EOL] del indent_chances [ ind ] [EOL] del open_rows [ depth + [number] : ] [EOL] depth -= [number] [EOL] if depth : [EOL] indent_chances [ indent [ depth ] ] = True [EOL] for idx in range ( row , - [number] , - [number] ) : [EOL] if parens [ idx ] : [EOL] parens [ idx ] -= [number] [EOL] break [EOL] assert len ( indent ) == depth + [number] [EOL] if ( start [ [number] ] not in indent_chances and not last_line . rstrip ( ) . endswith ( [string] ) ) : [EOL] [comment] [EOL] indent_chances [ start [ [number] ] ] = text [EOL] [EOL] last_token_multiline = ( start [ [number] ] != end [ [number] ] ) [EOL] if last_token_multiline : [EOL] rel_indent [ end [ [number] ] - first_row ] = rel_indent [ row ] [EOL] [EOL] last_line = line [EOL] [EOL] if ( indent_next and not last_line_begins_with_multiline and pycodestyle . expand_indent ( line ) == indent_level + DEFAULT_INDENT_SIZE ) : [EOL] pos = ( start [ [number] ] , indent [ [number] ] + [number] ) [EOL] desired_indent = indent_level + [number] * DEFAULT_INDENT_SIZE [EOL] if visual_indent : [EOL] yield ( pos , [string] . format ( desired_indent ) ) [EOL] else : [EOL] yield ( pos , [string] . format ( desired_indent ) ) [EOL] [EOL] [EOL] del pycodestyle . _checks [ [string] ] [ pycodestyle . continued_indentation ] [EOL] pycodestyle . register_check ( continued_indentation ) [EOL] [EOL] [EOL] class FixPEP8 ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , options , contents = None , long_line_ignore_cache = None ) : [EOL] self . filename = filename [EOL] if contents is None : [EOL] self . source = readlines_from_file ( filename ) [EOL] else : [EOL] sio = io . StringIO ( contents ) [EOL] self . source = sio . readlines ( ) [EOL] self . options = options [EOL] self . indent_word = _get_indentword ( [string] . join ( self . source ) ) [EOL] [EOL] self . long_line_ignore_cache = ( set ( ) if long_line_ignore_cache is None [EOL] else long_line_ignore_cache ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . fix_e115 = self . fix_e112 [EOL] self . fix_e116 = self . fix_e113 [EOL] self . fix_e121 = self . _fix_reindent [EOL] self . fix_e122 = self . _fix_reindent [EOL] self . fix_e123 = self . _fix_reindent [EOL] self . fix_e124 = self . _fix_reindent [EOL] self . fix_e126 = self . _fix_reindent [EOL] self . fix_e127 = self . _fix_reindent [EOL] self . fix_e128 = self . _fix_reindent [EOL] self . fix_e129 = self . _fix_reindent [EOL] self . fix_e202 = self . fix_e201 [EOL] self . fix_e203 = self . fix_e201 [EOL] self . fix_e211 = self . fix_e201 [EOL] self . fix_e221 = self . fix_e271 [EOL] self . fix_e222 = self . fix_e271 [EOL] self . fix_e223 = self . fix_e271 [EOL] self . fix_e226 = self . fix_e225 [EOL] self . fix_e227 = self . fix_e225 [EOL] self . fix_e228 = self . fix_e225 [EOL] self . fix_e241 = self . fix_e271 [EOL] self . fix_e242 = self . fix_e224 [EOL] self . fix_e261 = self . fix_e262 [EOL] self . fix_e272 = self . fix_e271 [EOL] self . fix_e273 = self . fix_e271 [EOL] self . fix_e274 = self . fix_e271 [EOL] self . fix_e306 = self . fix_e301 [EOL] self . fix_e501 = ( self . fix_long_line_logically if [EOL] options and ( options . aggressive >= [number] or options . experimental ) else [EOL] self . fix_long_line_physically ) [EOL] self . fix_e703 = self . fix_e702 [EOL] self . fix_w293 = self . fix_w291 [EOL] [EOL] def _fix_source ( self , results ) : [EOL] try : [EOL] ( logical_start , logical_end ) = _find_logical ( self . source ) [EOL] logical_support = True [EOL] except ( SyntaxError , tokenize . TokenError ) : [comment] [EOL] logical_support = False [EOL] [EOL] completed_lines = set ( ) [EOL] for result in sorted ( results , key = _priority_key ) : [EOL] if result [ [string] ] in completed_lines : [EOL] continue [EOL] [EOL] fixed_methodname = [string] + result [ [string] ] . lower ( ) [EOL] if hasattr ( self , fixed_methodname ) : [EOL] fix = getattr ( self , fixed_methodname ) [EOL] [EOL] line_index = result [ [string] ] - [number] [EOL] original_line = self . source [ line_index ] [EOL] [EOL] is_logical_fix = len ( _get_parameters ( fix ) ) > [number] [EOL] if is_logical_fix : [EOL] logical = None [EOL] if logical_support : [EOL] logical = _get_logical ( self . source , result , logical_start , logical_end ) [EOL] if logical and set ( range ( logical [ [number] ] [ [number] ] + [number] , logical [ [number] ] [ [number] ] + [number] ) ) . intersection ( completed_lines ) : [EOL] continue [EOL] [EOL] modified_lines = fix ( result , logical ) [EOL] else : [EOL] modified_lines = fix ( result ) [EOL] [EOL] if modified_lines is None : [EOL] [comment] [EOL] assert not is_logical_fix [EOL] [EOL] if self . source [ line_index ] == original_line : [EOL] modified_lines = [ ] [EOL] [EOL] if modified_lines : [EOL] completed_lines . update ( modified_lines ) [EOL] elif modified_lines == [ ] : [comment] [EOL] if self . options . verbose >= [number] : [EOL] print ( [string] . format ( error = result [ [string] ] , line = result [ [string] ] ) , file = sys . stderr ) [EOL] else : [comment] [EOL] completed_lines . add ( result [ [string] ] ) [EOL] else : [EOL] if self . options . verbose >= [number] : [EOL] print ( [string] . format ( fixed_methodname ) , file = sys . stderr ) [EOL] [EOL] info = result [ [string] ] . strip ( ) [EOL] print ( [string] . format ( self . filename , result [ [string] ] , result [ [string] ] , info ) , file = sys . stderr ) [EOL] [EOL] def fix ( self ) : [EOL] [docstring] [EOL] pep8_options = { [string] : self . options . ignore , [string] : self . options . select , [string] : self . options . max_line_length , } [EOL] results = _execute_pep8 ( pep8_options , self . source ) [EOL] [EOL] if self . options . verbose : [EOL] progress = { } [EOL] for r in results : [EOL] if r [ [string] ] not in progress : [EOL] progress [ r [ [string] ] ] = set ( ) [EOL] progress [ r [ [string] ] ] . add ( r [ [string] ] ) [EOL] print ( [string] . format ( n = len ( results ) , progress = progress ) , file = sys . stderr ) [EOL] [EOL] if self . options . line_range : [EOL] start , end = self . options . line_range [EOL] results = [ r for r in results if start <= r [ [string] ] <= end ] [EOL] [EOL] self . _fix_source ( filter_results ( source = [string] . join ( self . source ) , results = results , aggressive = self . options . aggressive ) ) [EOL] [EOL] if self . options . line_range : [EOL] [comment] [EOL] count = sum ( sline . count ( [string] ) for sline in self . source [ start - [number] : end ] ) [EOL] self . options . line_range [ [number] ] = start + count - [number] [EOL] [EOL] return [string] . join ( self . source ) [EOL] [EOL] def _fix_reindent ( self , result ) : [EOL] [docstring] [EOL] num_indent_spaces = int ( result [ [string] ] . split ( ) [ [number] ] ) [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] self . source [ line_index ] = [string] * num_indent_spaces + target . lstrip ( ) [EOL] [EOL] def fix_e112 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] if not target . lstrip ( ) . startswith ( [string] ) : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] self . source [ line_index ] = self . indent_word + target [EOL] [EOL] def fix_e113 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] indent = _get_indentation ( target ) [EOL] stripped = target . lstrip ( ) [EOL] [EOL] if not stripped . startswith ( [string] ) : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] self . source [ line_index ] = indent [ [number] : ] + stripped [EOL] [EOL] def fix_e125 ( self , result ) : [EOL] [docstring] [EOL] num_indent_spaces = int ( result [ [string] ] . split ( ) [ [number] ] ) [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] spaces_to_add = num_indent_spaces - len ( _get_indentation ( target ) ) [EOL] indent = len ( _get_indentation ( target ) ) [EOL] modified_lines = [ ] [EOL] [EOL] while len ( _get_indentation ( self . source [ line_index ] ) ) >= indent : [EOL] self . source [ line_index ] = ( [string] * spaces_to_add + self . source [ line_index ] ) [EOL] modified_lines . append ( [number] + line_index ) [comment] [EOL] line_index -= [number] [EOL] [EOL] return modified_lines [EOL] [EOL] def fix_e131 ( self , result ) : [EOL] [docstring] [EOL] num_indent_spaces = int ( result [ [string] ] . split ( ) [ [number] ] ) [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] spaces_to_add = num_indent_spaces - len ( _get_indentation ( target ) ) [EOL] [EOL] if spaces_to_add >= [number] : [EOL] self . source [ line_index ] = ( [string] * spaces_to_add + self . source [ line_index ] ) [EOL] else : [EOL] offset = abs ( spaces_to_add ) [EOL] self . source [ line_index ] = self . source [ line_index ] [ offset : ] [EOL] [EOL] def fix_e201 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] - [number] [EOL] [EOL] fixed = fix_whitespace ( target , offset = offset , replacement = [string] ) [EOL] [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_e224 ( self , result ) : [EOL] [docstring] [EOL] target = self . source [ result [ [string] ] - [number] ] [EOL] offset = result [ [string] ] - [number] [EOL] fixed = target [ : offset ] + target [ offset : ] . replace ( [string] , [string] ) [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] [EOL] def fix_e225 ( self , result ) : [EOL] [docstring] [EOL] target = self . source [ result [ [string] ] - [number] ] [EOL] offset = result [ [string] ] - [number] [EOL] fixed = target [ : offset ] + [string] + target [ offset : ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( fixed . replace ( [string] , [string] ) == target . replace ( [string] , [string] ) and _get_indentation ( fixed ) == _get_indentation ( target ) ) : [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] error_code = result . get ( [string] , [number] ) [EOL] try : [EOL] ts = generate_tokens ( fixed ) [EOL] except tokenize . TokenError : [EOL] return [EOL] if not check_syntax ( fixed . lstrip ( ) ) : [EOL] return [EOL] errors = list ( pycodestyle . missing_whitespace_around_operator ( fixed , ts ) ) [EOL] for e in reversed ( errors ) : [EOL] if error_code != e [ [number] ] . split ( ) [ [number] ] : [EOL] continue [EOL] offset = e [ [number] ] [ [number] ] [EOL] fixed = fixed [ : offset ] + [string] + fixed [ offset : ] [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] else : [EOL] return [ ] [EOL] [EOL] def fix_e231 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] [EOL] fixed = target [ : offset ] . rstrip ( ) + [string] + target [ offset : ] . lstrip ( ) [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_e251 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] c = min ( result [ [string] ] - [number] , len ( target ) - [number] ) [EOL] [EOL] if target [ c ] . strip ( ) : [EOL] fixed = target [EOL] else : [EOL] fixed = target [ : c ] . rstrip ( ) + target [ c : ] . lstrip ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if fixed . endswith ( ( [string] , [string] , [string] ) ) : [EOL] self . source [ line_index ] = fixed . rstrip ( [string] ) [EOL] self . source [ line_index + [number] ] = self . source [ line_index + [number] ] . lstrip ( ) [EOL] return [ line_index + [number] , line_index + [number] ] [comment] [EOL] [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] [EOL] def fix_e262 ( self , result ) : [EOL] [docstring] [EOL] target = self . source [ result [ [string] ] - [number] ] [EOL] offset = result [ [string] ] [EOL] [EOL] code = target [ : offset ] . rstrip ( [string] ) [EOL] comment = target [ offset : ] . lstrip ( [string] ) [EOL] [EOL] fixed = code + ( [string] + comment if comment . strip ( ) else [string] ) [EOL] [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] [EOL] def fix_e271 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] - [number] [EOL] [EOL] fixed = fix_whitespace ( target , offset = offset , replacement = [string] ) [EOL] [EOL] if fixed == target : [EOL] return [ ] [EOL] else : [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_e301 ( self , result ) : [EOL] [docstring] [EOL] cr = [string] [EOL] self . source [ result [ [string] ] - [number] ] = cr + self . source [ result [ [string] ] - [number] ] [EOL] [EOL] def fix_e302 ( self , result ) : [EOL] [docstring] [EOL] add_linenum = [number] - int ( result [ [string] ] . split ( ) [ - [number] ] ) [EOL] cr = [string] * add_linenum [EOL] self . source [ result [ [string] ] - [number] ] = cr + self . source [ result [ [string] ] - [number] ] [EOL] [EOL] def fix_e303 ( self , result ) : [EOL] [docstring] [EOL] delete_linenum = int ( result [ [string] ] . split ( [string] ) [ [number] ] . split ( [string] ) [ [number] ] ) - [number] [EOL] delete_linenum = max ( [number] , delete_linenum ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cnt = [number] [EOL] line = result [ [string] ] - [number] [EOL] modified_lines = [ ] [EOL] while cnt < delete_linenum and line >= [number] : [EOL] if not self . source [ line ] . strip ( ) : [EOL] self . source [ line ] = [string] [EOL] modified_lines . append ( [number] + line ) [comment] [EOL] cnt += [number] [EOL] line -= [number] [EOL] [EOL] return modified_lines [EOL] [EOL] def fix_e304 ( self , result ) : [EOL] [docstring] [EOL] line = result [ [string] ] - [number] [EOL] if not self . source [ line ] . strip ( ) : [EOL] self . source [ line ] = [string] [EOL] [EOL] def fix_e305 ( self , result ) : [EOL] [docstring] [EOL] cr = [string] [EOL] [comment] [EOL] offset = result [ [string] ] - [number] [EOL] while True : [EOL] if offset < [number] : [EOL] break [EOL] line = self . source [ offset ] . lstrip ( ) [EOL] if not line : [EOL] break [EOL] if line [ [number] ] != [string] : [EOL] break [EOL] offset -= [number] [EOL] offset += [number] [EOL] self . source [ offset ] = cr + self . source [ offset ] [EOL] [EOL] def fix_e401 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] - [number] [EOL] [EOL] if not target . lstrip ( ) . startswith ( [string] ) : [EOL] return [ ] [EOL] [EOL] indentation = re . split ( pattern = [string] , string = target , maxsplit = [number] ) [ [number] ] [EOL] fixed = ( target [ : offset ] . rstrip ( [string] ) + [string] + indentation + [string] + target [ offset : ] . lstrip ( [string] ) ) [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_long_line_logically ( self , result , logical ) : [EOL] [docstring] [EOL] if ( not logical or len ( logical [ [number] ] ) == [number] or self . source [ result [ [string] ] - [number] ] . lstrip ( ) . startswith ( [string] ) ) : [EOL] return self . fix_long_line_physically ( result ) [EOL] [EOL] start_line_index = logical [ [number] ] [ [number] ] [EOL] end_line_index = logical [ [number] ] [ [number] ] [EOL] logical_lines = logical [ [number] ] [EOL] [EOL] previous_line = get_item ( self . source , start_line_index - [number] , default = [string] ) [EOL] next_line = get_item ( self . source , end_line_index + [number] , default = [string] ) [EOL] [EOL] single_line = join_logical_line ( [string] . join ( logical_lines ) ) [EOL] [EOL] try : [EOL] fixed = self . fix_long_line ( target = single_line , previous_line = previous_line , next_line = next_line , original = [string] . join ( logical_lines ) ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] return self . fix_long_line_physically ( result ) [EOL] [EOL] if fixed : [EOL] for line_index in range ( start_line_index , end_line_index + [number] ) : [EOL] self . source [ line_index ] = [string] [EOL] self . source [ start_line_index ] = fixed [EOL] return range ( start_line_index + [number] , end_line_index + [number] ) [EOL] [EOL] return [ ] [EOL] [EOL] def fix_long_line_physically ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] previous_line = get_item ( self . source , line_index - [number] , default = [string] ) [EOL] next_line = get_item ( self . source , line_index + [number] , default = [string] ) [EOL] [EOL] try : [EOL] fixed = self . fix_long_line ( target = target , previous_line = previous_line , next_line = next_line , original = target ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] return [ ] [EOL] [EOL] if fixed : [EOL] self . source [ line_index ] = fixed [EOL] return [ line_index + [number] ] [EOL] [EOL] return [ ] [EOL] [EOL] def fix_long_line ( self , target , previous_line , next_line , original ) : [EOL] cache_entry = ( target , previous_line , next_line ) [EOL] if cache_entry in self . long_line_ignore_cache : [EOL] return [ ] [EOL] [EOL] if target . lstrip ( ) . startswith ( [string] ) : [EOL] if self . options . aggressive : [EOL] [comment] [EOL] return shorten_comment ( line = target , max_line_length = self . options . max_line_length , last_comment = not next_line . lstrip ( ) . startswith ( [string] ) ) [EOL] else : [EOL] return [ ] [EOL] [EOL] fixed = get_fixed_long_line ( target = target , previous_line = previous_line , original = original , indent_word = self . indent_word , max_line_length = self . options . max_line_length , aggressive = self . options . aggressive , experimental = self . options . experimental , verbose = self . options . verbose ) [EOL] [EOL] if fixed and not code_almost_equal ( original , fixed ) : [EOL] return fixed [EOL] [EOL] self . long_line_ignore_cache . add ( cache_entry ) [EOL] return None [EOL] [EOL] def fix_e502 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] self . source [ line_index ] = target . rstrip ( [string] ) + [string] [EOL] [EOL] def fix_e701 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] c = result [ [string] ] [EOL] [EOL] fixed_source = ( target [ : c ] + [string] + _get_indentation ( target ) + self . indent_word + target [ c : ] . lstrip ( [string] ) ) [EOL] self . source [ result [ [string] ] - [number] ] = fixed_source [EOL] return [ result [ [string] ] , result [ [string] ] + [number] ] [EOL] [EOL] def fix_e702 ( self , result , logical ) : [EOL] [docstring] [EOL] if not logical : [EOL] return [ ] [comment] [EOL] logical_lines = logical [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for line in logical_lines : [EOL] if [string] in line : [EOL] return [ ] [EOL] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] if target . rstrip ( ) . endswith ( [string] ) : [EOL] [comment] [EOL] self . source [ line_index ] = target . rstrip ( [string] ) [EOL] self . source [ line_index + [number] ] = self . source [ line_index + [number] ] . lstrip ( ) [EOL] return [ line_index + [number] , line_index + [number] ] [EOL] [EOL] if target . rstrip ( ) . endswith ( [string] ) : [EOL] self . source [ line_index ] = target . rstrip ( [string] ) + [string] [EOL] return [ line_index + [number] ] [EOL] [EOL] offset = result [ [string] ] - [number] [EOL] first = target [ : offset ] . rstrip ( [string] ) . rstrip ( ) [EOL] second = ( _get_indentation ( logical_lines [ [number] ] ) + target [ offset : ] . lstrip ( [string] ) . lstrip ( ) ) [EOL] [EOL] [comment] [EOL] inline_comment = None [EOL] if target [ offset : ] . lstrip ( [string] ) . lstrip ( ) [ : [number] ] == [string] : [EOL] inline_comment = target [ offset : ] . lstrip ( [string] ) [EOL] [EOL] if inline_comment : [EOL] self . source [ line_index ] = first + inline_comment [EOL] else : [EOL] self . source [ line_index ] = first + [string] + second [EOL] return [ line_index + [number] ] [EOL] [EOL] def fix_e704 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] match = STARTSWITH_DEF_REGEX . match ( target ) [EOL] if match : [EOL] self . source [ line_index ] = [string] . format ( match . group ( [number] ) , _get_indentation ( target ) + self . indent_word , target [ match . end ( [number] ) : ] . lstrip ( ) ) [EOL] [EOL] def fix_e711 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , offset , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] right_offset = offset + [number] [EOL] if right_offset >= len ( target ) : [EOL] return [ ] [EOL] [EOL] left = target [ : offset ] . rstrip ( ) [EOL] center = target [ offset : right_offset ] [EOL] right = target [ right_offset : ] . lstrip ( ) [EOL] [EOL] if not right . startswith ( [string] ) : [EOL] return [ ] [EOL] [EOL] if center . strip ( ) == [string] : [EOL] new_center = [string] [EOL] elif center . strip ( ) == [string] : [EOL] new_center = [string] [EOL] else : [EOL] return [ ] [EOL] [EOL] self . source [ line_index ] = [string] . join ( [ left , new_center , right ] ) [EOL] [EOL] def fix_e712 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , offset , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] [comment] [EOL] if re . match ( [string] , target ) : [EOL] self . source [ line_index ] = re . sub ( [string] , [string] , target , count = [number] ) [EOL] elif re . match ( [string] , target ) : [EOL] self . source [ line_index ] = re . sub ( [string] , [string] , target , count = [number] ) [EOL] else : [EOL] right_offset = offset + [number] [EOL] if right_offset >= len ( target ) : [EOL] return [ ] [EOL] [EOL] left = target [ : offset ] . rstrip ( ) [EOL] center = target [ offset : right_offset ] [EOL] right = target [ right_offset : ] . lstrip ( ) [EOL] [EOL] [comment] [EOL] new_right = None [EOL] if center . strip ( ) == [string] : [EOL] if re . match ( [string] , right ) : [EOL] new_right = re . sub ( [string] , [string] , right , count = [number] ) [EOL] elif center . strip ( ) == [string] : [EOL] if re . match ( [string] , right ) : [EOL] new_right = re . sub ( [string] , [string] , right , count = [number] ) [EOL] [EOL] if new_right is None : [EOL] return [ ] [EOL] [EOL] if new_right [ [number] ] . isalnum ( ) : [EOL] new_right = [string] + new_right [EOL] [EOL] self . source [ line_index ] = left + new_right [EOL] [EOL] def fix_e713 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , offset , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] [comment] [EOL] before_target = target [ : offset ] [EOL] target = target [ offset : ] [EOL] match_notin = COMPARE_NEGATIVE_REGEX_THROUGH . search ( target ) [EOL] notin_pos_start , notin_pos_end = [number] , [number] [EOL] if match_notin : [EOL] notin_pos_start = match_notin . start ( [number] ) [EOL] notin_pos_end = match_notin . end ( ) [EOL] target = [string] . format ( target [ : notin_pos_start ] , [string] , target [ notin_pos_end : ] ) [EOL] [EOL] [comment] [EOL] match = COMPARE_NEGATIVE_REGEX . search ( target ) [EOL] if match : [EOL] if match . group ( [number] ) == [string] : [EOL] pos_start = match . start ( [number] ) [EOL] new_target = [string] . format ( target [ : pos_start ] , match . group ( [number] ) , match . group ( [number] ) , match . group ( [number] ) , target [ match . end ( ) : ] , before_target ) [EOL] if match_notin : [EOL] [comment] [EOL] pos_start = notin_pos_start + offset [EOL] pos_end = notin_pos_end + offset - [number] [comment] [EOL] new_target = [string] . format ( new_target [ : pos_start ] , [string] , new_target [ pos_end : ] ) [EOL] self . source [ line_index ] = new_target [EOL] [EOL] def fix_e714 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] match = COMPARE_NEGATIVE_REGEX . search ( target ) [EOL] if match : [EOL] if match . group ( [number] ) == [string] : [EOL] pos_start = match . start ( [number] ) [EOL] self . source [ line_index ] = [string] . format ( target [ : pos_start ] , match . group ( [number] ) , match . group ( [number] ) , match . group ( [number] ) , target [ match . end ( ) : ] ) [EOL] [EOL] def fix_e722 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] match = BARE_EXCEPT_REGEX . search ( target ) [EOL] if match : [EOL] self . source [ line_index ] = [string] . format ( target [ : result [ [string] ] - [number] ] , [string] , target [ match . end ( ) : ] ) [EOL] [EOL] def fix_e731 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] match = LAMBDA_REGEX . search ( target ) [EOL] if match : [EOL] end = match . end ( ) [EOL] self . source [ line_index ] = [string] . format ( target [ : match . start ( [number] ) ] , match . group ( [number] ) , match . group ( [number] ) , target [ end : ] . lstrip ( ) ) [EOL] [EOL] def fix_w291 ( self , result ) : [EOL] [docstring] [EOL] fixed_line = self . source [ result [ [string] ] - [number] ] . rstrip ( ) [EOL] self . source [ result [ [string] ] - [number] ] = fixed_line + [string] [EOL] [EOL] def fix_w391 ( self , _ ) : [EOL] [docstring] [EOL] blank_count = [number] [EOL] for line in reversed ( self . source ) : [EOL] line = line . rstrip ( ) [EOL] if line : [EOL] break [EOL] else : [EOL] blank_count += [number] [EOL] [EOL] original_length = len ( self . source ) [EOL] self . source = self . source [ : original_length - blank_count ] [EOL] return range ( [number] , [number] + original_length ) [EOL] [EOL] def fix_w503 ( self , result ) : [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] one_string_token = target . split ( ) [ [number] ] [EOL] try : [EOL] ts = generate_tokens ( one_string_token ) [EOL] except tokenize . TokenError : [EOL] return [EOL] if not _is_binary_operator ( ts [ [number] ] [ [number] ] , one_string_token ) : [EOL] return [EOL] [comment] [EOL] comment_index = None [EOL] for i in range ( [number] ) : [EOL] [comment] [EOL] if ( line_index - i ) < [number] : [EOL] break [EOL] from_index = line_index - i - [number] [EOL] to_index = line_index + [number] [EOL] try : [EOL] ts = generate_tokens ( [string] . join ( self . source [ from_index : to_index ] ) ) [EOL] except Exception : [EOL] continue [EOL] newline_count = [number] [EOL] newline_index = [ ] [EOL] for i , t in enumerate ( ts ) : [EOL] if t [ [number] ] in ( tokenize . NEWLINE , tokenize . NL ) : [EOL] newline_index . append ( i ) [EOL] newline_count += [number] [EOL] if newline_count > [number] : [EOL] tts = ts [ newline_index [ - [number] ] : ] [EOL] else : [EOL] tts = ts [EOL] old = None [EOL] for t in tts : [EOL] if tokenize . COMMENT == t [ [number] ] : [EOL] if old is None : [EOL] comment_index = [number] [EOL] else : [EOL] comment_index = old [ [number] ] [ [number] ] [EOL] break [EOL] old = t [EOL] break [EOL] i = target . index ( one_string_token ) [EOL] self . source [ line_index ] = [string] . format ( target [ : i ] , target [ i + len ( one_string_token ) : ] ) [EOL] nl = find_newline ( self . source [ line_index - [number] : line_index ] ) [EOL] before_line = self . source [ line_index - [number] ] [EOL] bl = before_line . index ( nl ) [EOL] if comment_index : [EOL] self . source [ line_index - [number] ] = [string] . format ( before_line [ : comment_index ] , one_string_token , before_line [ comment_index + [number] : ] ) [EOL] else : [EOL] self . source [ line_index - [number] ] = [string] . format ( before_line [ : bl ] , one_string_token , before_line [ bl : ] ) [EOL] [EOL] [EOL] def get_index_offset_contents ( result , source ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] return ( line_index , result [ [string] ] - [number] , source [ line_index ] ) [EOL] [EOL] [EOL] def get_fixed_long_line ( target , previous_line , original , indent_word = [string] , max_line_length = [number] , aggressive = False , experimental = False , verbose = False ) : [EOL] [docstring] [EOL] indent = _get_indentation ( target ) [EOL] source = target [ len ( indent ) : ] [EOL] assert source . lstrip ( ) == source [EOL] assert not target . lstrip ( ) . startswith ( [string] ) [EOL] [EOL] [comment] [EOL] tokens = list ( generate_tokens ( source ) ) [EOL] [EOL] candidates = shorten_line ( tokens , source , indent , indent_word , max_line_length , aggressive = aggressive , experimental = experimental , previous_line = previous_line ) [EOL] [EOL] [comment] [EOL] candidates = sorted ( sorted ( set ( candidates ) . union ( [ target , original ] ) ) , key = lambda x : line_shortening_rank ( x , indent_word , max_line_length , experimental = experimental ) ) [EOL] [EOL] if verbose >= [number] : [EOL] print ( ( [string] * [number] + [string] ) . join ( [ [string] ] + candidates + [ [string] ] ) , file = wrap_output ( sys . stderr , [string] ) ) [EOL] [EOL] if candidates : [EOL] best_candidate = candidates [ [number] ] [EOL] [EOL] [comment] [EOL] if longest_line_length ( best_candidate ) > longest_line_length ( original ) : [EOL] return None [EOL] [EOL] return best_candidate [EOL] [EOL] [EOL] def longest_line_length ( code ) : [EOL] [docstring] [EOL] return max ( len ( line ) for line in code . splitlines ( ) ) [EOL] [EOL] [EOL] def join_logical_line ( logical_line ) : [EOL] [docstring] [EOL] indentation = _get_indentation ( logical_line ) [EOL] [EOL] return indentation + untokenize_without_newlines ( generate_tokens ( logical_line . lstrip ( ) ) ) + [string] [EOL] [EOL] [EOL] def untokenize_without_newlines ( tokens ) : [EOL] [docstring] [EOL] text = [string] [EOL] last_row = [number] [EOL] last_column = - [number] [EOL] [EOL] for t in tokens : [EOL] token_string = t [ [number] ] [EOL] ( start_row , start_column ) = t [ [number] ] [EOL] ( end_row , end_column ) = t [ [number] ] [EOL] [EOL] if start_row > last_row : [EOL] last_column = [number] [EOL] if ( ( start_column > last_column or token_string == [string] ) and not text . endswith ( [string] ) ) : [EOL] text += [string] [EOL] [EOL] if token_string != [string] : [EOL] text += token_string [EOL] [EOL] last_row = end_row [EOL] last_column = end_column [EOL] [EOL] return text . rstrip ( ) [EOL] [EOL] [EOL] def _find_logical ( source_lines ) : [EOL] [comment] [EOL] logical_start = [ ] [EOL] logical_end = [ ] [EOL] last_newline = True [EOL] parens = [number] [EOL] for t in generate_tokens ( [string] . join ( source_lines ) ) : [EOL] if t [ [number] ] in [ tokenize . COMMENT , tokenize . DEDENT , tokenize . INDENT , tokenize . NL , tokenize . ENDMARKER ] : [EOL] continue [EOL] if not parens and t [ [number] ] in [ tokenize . NEWLINE , tokenize . SEMI ] : [EOL] last_newline = True [EOL] logical_end . append ( ( t [ [number] ] [ [number] ] - [number] , t [ [number] ] [ [number] ] ) ) [EOL] continue [EOL] if last_newline and not parens : [EOL] logical_start . append ( ( t [ [number] ] [ [number] ] - [number] , t [ [number] ] [ [number] ] ) ) [EOL] last_newline = False [EOL] if t [ [number] ] == tokenize . OP : [EOL] if t [ [number] ] in [string] : [EOL] parens += [number] [EOL] elif t [ [number] ] in [string] : [EOL] parens -= [number] [EOL] return ( logical_start , logical_end ) [EOL] [EOL] [EOL] def _get_logical ( source_lines , result , logical_start , logical_end ) : [EOL] [docstring] [EOL] row = result [ [string] ] - [number] [EOL] col = result [ [string] ] - [number] [EOL] ls = None [EOL] le = None [EOL] for i in range ( [number] , len ( logical_start ) , [number] ) : [EOL] assert logical_end [EOL] x = logical_end [ i ] [EOL] if x [ [number] ] > row or ( x [ [number] ] == row and x [ [number] ] > col ) : [EOL] le = x [EOL] ls = logical_start [ i ] [EOL] break [EOL] if ls is None : [EOL] return None [EOL] original = source_lines [ ls [ [number] ] : le [ [number] ] + [number] ] [EOL] return ls , le , original [EOL] [EOL] [EOL] def get_item ( items , index , default = None ) : [EOL] if [number] <= index < len ( items ) : [EOL] return items [ index ] [EOL] [EOL] return default [EOL] [EOL] [EOL] def reindent ( source , indent_size ) : [EOL] [docstring] [EOL] reindenter = Reindenter ( source ) [EOL] return reindenter . run ( indent_size ) [EOL] [EOL] [EOL] def code_almost_equal ( a , b ) : [EOL] [docstring] [EOL] split_a = split_and_strip_non_empty_lines ( a ) [EOL] split_b = split_and_strip_non_empty_lines ( b ) [EOL] [EOL] if len ( split_a ) != len ( split_b ) : [EOL] return False [EOL] [EOL] for ( index , _ ) in enumerate ( split_a ) : [EOL] if [string] . join ( split_a [ index ] . split ( ) ) != [string] . join ( split_b [ index ] . split ( ) ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def split_and_strip_non_empty_lines ( text ) : [EOL] [docstring] [EOL] return [ line . strip ( ) for line in text . splitlines ( ) if line . strip ( ) ] [EOL] [EOL] [EOL] def fix_e265 ( source , aggressive = False ) : [comment] [EOL] [docstring] [EOL] if [string] not in source : [EOL] [comment] [EOL] return source [EOL] [EOL] ignored_line_numbers = multiline_string_lines ( source , include_docstrings = True ) | set ( commented_out_code_lines ( source ) ) [EOL] [EOL] fixed_lines = [ ] [EOL] sio = io . StringIO ( source ) [EOL] for ( line_number , line ) in enumerate ( sio . readlines ( ) , start = [number] ) : [EOL] if ( line . lstrip ( ) . startswith ( [string] ) and line_number not in ignored_line_numbers and not pycodestyle . noqa ( line ) ) : [EOL] indentation = _get_indentation ( line ) [EOL] line = line . lstrip ( ) [EOL] [EOL] [comment] [EOL] if len ( line ) > [number] : [EOL] pos = next ( ( index for index , c in enumerate ( line ) if c != [string] ) ) [EOL] if ( ( line [ : pos ] . count ( [string] ) > [number] or line [ [number] ] . isalnum ( ) ) and not line . rstrip ( ) . endswith ( [string] ) ) : [EOL] line = [string] + line . lstrip ( [string] ) [EOL] [EOL] fixed_lines . append ( indentation + line ) [EOL] else : [EOL] fixed_lines . append ( line ) [EOL] [EOL] return [string] . join ( fixed_lines ) [EOL] [EOL] [EOL] def refactor ( source , fixer_names , ignore = None , filename = [string] ) : [EOL] [docstring] [EOL] from lib2to3 import pgen2 [EOL] try : [EOL] new_text = refactor_with_2to3 ( source , fixer_names = fixer_names , filename = filename ) [EOL] except ( pgen2 . parse . ParseError , SyntaxError , UnicodeDecodeError , UnicodeEncodeError ) : [EOL] return source [EOL] [EOL] if ignore : [EOL] if ignore in new_text and ignore not in source : [EOL] return source [EOL] [EOL] return new_text [EOL] [EOL] [EOL] def code_to_2to3 ( select , ignore ) : [EOL] fixes = set ( ) [EOL] for code , fix in CODE_TO_2TO3 . items ( ) : [EOL] if code_match ( code , select = select , ignore = ignore ) : [EOL] fixes |= set ( fix ) [EOL] return fixes [EOL] [EOL] [EOL] def fix_2to3 ( source , aggressive = True , select = None , ignore = None , filename = [string] ) : [EOL] [docstring] [EOL] if not aggressive : [EOL] return source [EOL] [EOL] select = select or [ ] [EOL] ignore = ignore or [ ] [EOL] [EOL] return refactor ( source , code_to_2to3 ( select = select , ignore = ignore ) , filename = filename ) [EOL] [EOL] [EOL] def fix_w602 ( source , aggressive = True ) : [EOL] [docstring] [EOL] if not aggressive : [EOL] return source [EOL] [EOL] return refactor ( source , [ [string] ] , ignore = [string] ) [EOL] [EOL] [EOL] def find_newline ( source ) : [EOL] [docstring] [EOL] assert not isinstance ( source , unicode ) [EOL] [EOL] counter = collections . defaultdict ( int ) [EOL] for line in source : [EOL] if line . endswith ( CRLF ) : [EOL] counter [ CRLF ] += [number] [EOL] elif line . endswith ( CR ) : [EOL] counter [ CR ] += [number] [EOL] elif line . endswith ( LF ) : [EOL] counter [ LF ] += [number] [EOL] [EOL] return ( sorted ( counter , key = counter . get , reverse = True ) or [ LF ] ) [ [number] ] [EOL] [EOL] [EOL] def _get_indentword ( source ) : [EOL] [docstring] [EOL] indent_word = [string] [comment] [EOL] try : [EOL] for t in generate_tokens ( source ) : [EOL] if t [ [number] ] == token . INDENT : [EOL] indent_word = t [ [number] ] [EOL] break [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] pass [EOL] return indent_word [EOL] [EOL] [EOL] def _get_indentation ( line ) : [EOL] [docstring] [EOL] if line . strip ( ) : [EOL] non_whitespace_index = len ( line ) - len ( line . lstrip ( ) ) [EOL] return line [ : non_whitespace_index ] [EOL] [EOL] return [string] [EOL] [EOL] [EOL] def get_diff_text ( old , new , filename ) : [EOL] [docstring] [EOL] newline = [string] [EOL] diff = difflib . unified_diff ( old , new , [string] + filename , [string] + filename , lineterm = newline ) [EOL] [EOL] text = [string] [EOL] for line in diff : [EOL] text += line [EOL] [EOL] [comment] [EOL] if text and not line . endswith ( newline ) : [EOL] text += newline + [string] + newline [EOL] [EOL] return text [EOL] [EOL] [EOL] def _priority_key ( pep8_result ) : [EOL] [docstring] [EOL] priority = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] middle_index = [number] [EOL] lowest_priority = [ [string] , [string] ] [EOL] key = pep8_result [ [string] ] . lower ( ) [EOL] try : [EOL] return priority . index ( key ) [EOL] except ValueError : [EOL] try : [EOL] return middle_index + lowest_priority . index ( key ) + [number] [EOL] except ValueError : [EOL] return middle_index [EOL] [EOL] [EOL] def shorten_line ( tokens , source , indentation , indent_word , max_line_length , aggressive = False , experimental = False , previous_line = [string] ) : [EOL] [docstring] [EOL] for candidate in _shorten_line ( tokens = tokens , source = source , indentation = indentation , indent_word = indent_word , aggressive = aggressive , previous_line = previous_line ) : [EOL] yield candidate [EOL] [EOL] if aggressive : [EOL] for key_token_strings in SHORTEN_OPERATOR_GROUPS : [EOL] shortened = _shorten_line_at_tokens ( tokens = tokens , source = source , indentation = indentation , indent_word = indent_word , key_token_strings = key_token_strings , aggressive = aggressive ) [EOL] [EOL] if shortened is not None and shortened != source : [EOL] yield shortened [EOL] [EOL] if experimental : [EOL] for shortened in _shorten_line_at_tokens_new ( tokens = tokens , source = source , indentation = indentation , max_line_length = max_line_length ) : [EOL] [EOL] yield shortened [EOL] [EOL] [EOL] def _shorten_line ( tokens , source , indentation , indent_word , aggressive = False , previous_line = [string] ) : [EOL] [docstring] [EOL] for ( token_type , token_string , start_offset , end_offset ) in token_offsets ( tokens ) : [EOL] [EOL] if ( token_type == tokenize . COMMENT and not is_probably_part_of_multiline ( previous_line ) and not is_probably_part_of_multiline ( source ) and not source [ start_offset + [number] : ] . strip ( ) . lower ( ) . startswith ( ( [string] , [string] , [string] ) ) ) : [EOL] [comment] [EOL] first = source [ : start_offset ] [EOL] second = source [ start_offset : ] [EOL] yield ( indentation + second . strip ( ) + [string] + indentation + first . strip ( ) + [string] ) [EOL] elif token_type == token . OP and token_string != [string] : [EOL] [comment] [EOL] [EOL] assert token_type != token . INDENT [EOL] [EOL] first = source [ : end_offset ] [EOL] [EOL] second_indent = indentation [EOL] if first . rstrip ( ) . endswith ( [string] ) : [EOL] second_indent += indent_word [EOL] elif [string] in first : [EOL] second_indent += [string] * ( [number] + first . find ( [string] ) ) [EOL] else : [EOL] second_indent += indent_word [EOL] [EOL] second = ( second_indent + source [ end_offset : ] . lstrip ( ) ) [EOL] if ( not second . strip ( ) or second . lstrip ( ) . startswith ( [string] ) ) : [EOL] continue [EOL] [EOL] [comment] [EOL] if second . lstrip ( ) . startswith ( [string] ) : [EOL] continue [EOL] [comment] [EOL] if first . rstrip ( ) . endswith ( [string] ) : [EOL] continue [EOL] if token_string in [string] : [EOL] fixed = first + [string] + [string] + second [EOL] else : [EOL] fixed = first + [string] + second [EOL] [EOL] [comment] [EOL] if check_syntax ( normalize_multiline ( fixed ) [EOL] if aggressive else fixed ) : [EOL] yield indentation + fixed [EOL] [EOL] [EOL] def _is_binary_operator ( token_type , text ) : [EOL] return ( ( token_type == tokenize . OP or text in [ [string] , [string] ] ) and text not in [string] ) [EOL] [EOL] [EOL] [comment] [EOL] Token = collections . namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class ReformattedLines ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class _Indent ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , indent_amt ) : [EOL] self . _indent_amt = indent_amt [EOL] [EOL] def emit ( self ) : [EOL] return [string] * self . _indent_amt [EOL] [EOL] @ property def size ( self ) : [EOL] return self . _indent_amt [EOL] [EOL] class _Space ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def emit ( self ) : [EOL] return [string] [EOL] [EOL] @ property def size ( self ) : [EOL] return [number] [EOL] [EOL] class _LineBreak ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def emit ( self ) : [EOL] return [string] [EOL] [EOL] @ property def size ( self ) : [EOL] return [number] [EOL] [EOL] def __init__ ( self , max_line_length ) : [EOL] self . _max_line_length = max_line_length [EOL] self . _lines = [ ] [EOL] self . _bracket_depth = [number] [EOL] self . _prev_item = None [EOL] self . _prev_prev_item = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . emit ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def add ( self , obj , indent_amt , break_after_open_bracket ) : [EOL] if isinstance ( obj , Atom ) : [EOL] self . _add_item ( obj , indent_amt ) [EOL] return [EOL] [EOL] self . _add_container ( obj , indent_amt , break_after_open_bracket ) [EOL] [EOL] def add_comment ( self , item ) : [EOL] num_spaces = [number] [EOL] if len ( self . _lines ) > [number] : [EOL] if isinstance ( self . _lines [ - [number] ] , self . _Space ) : [EOL] num_spaces -= [number] [EOL] if len ( self . _lines ) > [number] : [EOL] if isinstance ( self . _lines [ - [number] ] , self . _Space ) : [EOL] num_spaces -= [number] [EOL] [EOL] while num_spaces > [number] : [EOL] self . _lines . append ( self . _Space ( ) ) [EOL] num_spaces -= [number] [EOL] self . _lines . append ( item ) [EOL] [EOL] def add_indent ( self , indent_amt ) : [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] [EOL] def add_line_break ( self , indent ) : [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . add_indent ( len ( indent ) ) [EOL] [EOL] def add_line_break_at ( self , index , indent_amt ) : [EOL] self . _lines . insert ( index , self . _LineBreak ( ) ) [EOL] self . _lines . insert ( index + [number] , self . _Indent ( indent_amt ) ) [EOL] [EOL] def add_space_if_needed ( self , curr_text , equal = False ) : [EOL] if ( not self . _lines or isinstance ( self . _lines [ - [number] ] , ( self . _LineBreak , self . _Indent , self . _Space ) ) ) : [EOL] return [EOL] [EOL] prev_text = unicode ( self . _prev_item ) [EOL] prev_prev_text = ( unicode ( self . _prev_prev_item ) if self . _prev_prev_item else [string] ) [EOL] [EOL] if ( ( ( self . _prev_item . is_keyword or self . _prev_item . is_string or self . _prev_item . is_name or self . _prev_item . is_number ) and ( curr_text [ [number] ] not in [string] or ( curr_text [ [number] ] == [string] and equal ) ) ) or ( ( prev_prev_text != [string] and prev_text [ - [number] ] != [string] and curr_text != [string] ) and curr_text [ [number] ] != [string] and ( ( prev_text [ - [number] ] in [string] and curr_text [ [number] ] not in [string] ) or prev_text [ - [number] ] in [string] or ( equal and prev_text == [string] ) or ( ( self . _prev_prev_item and ( prev_text not in [string] and ( self . _prev_prev_item . is_name or self . _prev_prev_item . is_number or self . _prev_prev_item . is_string ) ) and prev_text in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) ) ) ) ) : [EOL] self . _lines . append ( self . _Space ( ) ) [EOL] [EOL] def previous_item ( self ) : [EOL] [docstring] [EOL] return self . _prev_item [EOL] [EOL] def fits_on_current_line ( self , item_extent ) : [EOL] return self . current_size ( ) + item_extent <= self . _max_line_length [EOL] [EOL] def current_size ( self ) : [EOL] [docstring] [EOL] size = [number] [EOL] for item in reversed ( self . _lines ) : [EOL] size += item . size [EOL] if isinstance ( item , self . _LineBreak ) : [EOL] break [EOL] [EOL] return size [EOL] [EOL] def line_empty ( self ) : [EOL] return ( self . _lines and isinstance ( self . _lines [ - [number] ] , ( self . _LineBreak , self . _Indent ) ) ) [EOL] [EOL] def emit ( self ) : [EOL] string = [string] [EOL] for item in self . _lines : [EOL] if isinstance ( item , self . _LineBreak ) : [EOL] string = string . rstrip ( ) [EOL] string += item . emit ( ) [EOL] [EOL] return string . rstrip ( ) + [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _add_item ( self , item , indent_amt ) : [EOL] [docstring] [EOL] if self . _prev_item and self . _prev_item . is_string and item . is_string : [EOL] [comment] [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] [EOL] item_text = unicode ( item ) [EOL] if self . _lines and self . _bracket_depth : [EOL] [comment] [EOL] self . _prevent_default_initializer_splitting ( item , indent_amt ) [EOL] [EOL] if item_text in [string] : [EOL] self . _split_after_delimiter ( item , indent_amt ) [EOL] [EOL] elif self . _lines and not self . line_empty ( ) : [EOL] [comment] [EOL] if self . fits_on_current_line ( len ( item_text ) ) : [EOL] self . _enforce_space ( item ) [EOL] [EOL] else : [EOL] [comment] [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] [EOL] self . _lines . append ( item ) [EOL] self . _prev_item , self . _prev_prev_item = item , self . _prev_item [EOL] [EOL] if item_text in [string] : [EOL] self . _bracket_depth += [number] [EOL] [EOL] elif item_text in [string] : [EOL] self . _bracket_depth -= [number] [EOL] assert self . _bracket_depth >= [number] [EOL] [EOL] def _add_container ( self , container , indent_amt , break_after_open_bracket ) : [EOL] actual_indent = indent_amt + [number] [EOL] [EOL] if ( unicode ( self . _prev_item ) != [string] and not self . line_empty ( ) and not self . fits_on_current_line ( container . size + self . _bracket_depth + [number] ) ) : [EOL] [EOL] if unicode ( container ) [ [number] ] == [string] and self . _prev_item . is_name : [EOL] [comment] [EOL] break_after_open_bracket = True [EOL] actual_indent = indent_amt + [number] [EOL] elif ( break_after_open_bracket or unicode ( self . _prev_item ) not in [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] break_after_open_bracket = False [EOL] else : [EOL] actual_indent = self . current_size ( ) + [number] [EOL] break_after_open_bracket = False [EOL] [EOL] if isinstance ( container , ( ListComprehension , IfExpression ) ) : [EOL] actual_indent = indent_amt [EOL] [EOL] [comment] [EOL] [comment] [EOL] container . reflow ( self , [string] * actual_indent , break_after_open_bracket = break_after_open_bracket ) [EOL] [EOL] def _prevent_default_initializer_splitting ( self , item , indent_amt ) : [EOL] [docstring] [EOL] if unicode ( item ) == [string] : [EOL] [comment] [EOL] [comment] [EOL] self . _delete_whitespace ( ) [EOL] return [EOL] [EOL] if ( not self . _prev_item or not self . _prev_prev_item or unicode ( self . _prev_item ) != [string] ) : [EOL] return [EOL] [EOL] self . _delete_whitespace ( ) [EOL] prev_prev_index = self . _lines . index ( self . _prev_prev_item ) [EOL] [EOL] if ( isinstance ( self . _lines [ prev_prev_index - [number] ] , self . _Indent ) or self . fits_on_current_line ( item . size + [number] ) ) : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] if isinstance ( self . _lines [ prev_prev_index - [number] ] , self . _Space ) : [EOL] del self . _lines [ prev_prev_index - [number] ] [EOL] [EOL] self . add_line_break_at ( self . _lines . index ( self . _prev_prev_item ) , indent_amt ) [EOL] [EOL] def _split_after_delimiter ( self , item , indent_amt ) : [EOL] [docstring] [EOL] self . _delete_whitespace ( ) [EOL] [EOL] if self . fits_on_current_line ( item . size ) : [EOL] return [EOL] [EOL] last_space = None [EOL] for current_item in reversed ( self . _lines ) : [EOL] if ( last_space and ( not isinstance ( current_item , Atom ) or not current_item . is_colon ) ) : [EOL] break [EOL] else : [EOL] last_space = None [EOL] if isinstance ( current_item , self . _Space ) : [EOL] last_space = current_item [EOL] if isinstance ( current_item , ( self . _LineBreak , self . _Indent ) ) : [EOL] return [EOL] [EOL] if not last_space : [EOL] return [EOL] [EOL] self . add_line_break_at ( self . _lines . index ( last_space ) , indent_amt ) [EOL] [EOL] def _enforce_space ( self , item ) : [EOL] [docstring] [EOL] if isinstance ( self . _lines [ - [number] ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : [EOL] return [EOL] [EOL] if not self . _prev_item : [EOL] return [EOL] [EOL] item_text = unicode ( item ) [EOL] prev_text = unicode ( self . _prev_item ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( ( item_text == [string] and prev_text == [string] ) or ( item_text == [string] and prev_text == [string] ) or ( item_text == [string] and prev_text == [string] ) ) : [EOL] self . _lines . append ( self . _Space ( ) ) [EOL] [EOL] def _delete_whitespace ( self ) : [EOL] [docstring] [EOL] while isinstance ( self . _lines [ - [number] ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : [EOL] del self . _lines [ - [number] ] [EOL] [EOL] [EOL] class Atom ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , atom ) : [EOL] self . _atom = atom [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . _atom . token_string [EOL] [EOL] def __len__ ( self ) : [EOL] return self . size [EOL] [EOL] def reflow ( self , reflowed_lines , continued_indent , extent , break_after_open_bracket = False , is_list_comp_or_if_expr = False , next_is_dot = False ) : [EOL] if self . _atom . token_type == tokenize . COMMENT : [EOL] reflowed_lines . add_comment ( self ) [EOL] return [EOL] [EOL] total_size = extent if extent else self . size [EOL] [EOL] if self . _atom . token_string not in [string] : [EOL] [comment] [EOL] total_size += [number] [EOL] [EOL] prev_item = reflowed_lines . previous_item ( ) [EOL] if ( not is_list_comp_or_if_expr and not reflowed_lines . fits_on_current_line ( total_size ) and not ( next_is_dot and reflowed_lines . fits_on_current_line ( self . size + [number] ) ) and not reflowed_lines . line_empty ( ) and not self . is_colon and not ( prev_item and prev_item . is_name and unicode ( self ) == [string] ) ) : [EOL] [comment] [EOL] [comment] [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] else : [EOL] reflowed_lines . add_space_if_needed ( unicode ( self ) ) [EOL] [EOL] reflowed_lines . add ( self , len ( continued_indent ) , break_after_open_bracket ) [EOL] [EOL] def emit ( self ) : [EOL] return self . __repr__ ( ) [EOL] [EOL] @ property def is_keyword ( self ) : [EOL] return keyword . iskeyword ( self . _atom . token_string ) [EOL] [EOL] @ property def is_string ( self ) : [EOL] return self . _atom . token_type == tokenize . STRING [EOL] [EOL] @ property def is_name ( self ) : [EOL] return self . _atom . token_type == tokenize . NAME [EOL] [EOL] @ property def is_number ( self ) : [EOL] return self . _atom . token_type == tokenize . NUMBER [EOL] [EOL] @ property def is_comma ( self ) : [EOL] return self . _atom . token_string == [string] [EOL] [EOL] @ property def is_colon ( self ) : [EOL] return self . _atom . token_string == [string] [EOL] [EOL] @ property def size ( self ) : [EOL] return len ( self . _atom . token_string ) [EOL] [EOL] [EOL] class Container ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , items ) : [EOL] self . _items = items [EOL] [EOL] def __repr__ ( self ) : [EOL] string = [string] [EOL] last_was_keyword = False [EOL] [EOL] for item in self . _items : [EOL] if item . is_comma : [EOL] string += [string] [EOL] elif item . is_colon : [EOL] string += [string] [EOL] else : [EOL] item_string = unicode ( item ) [EOL] if ( string and ( last_was_keyword or ( not string . endswith ( tuple ( [string] ) ) and not item_string . startswith ( tuple ( [string] ) ) ) ) ) : [EOL] string += [string] [EOL] string += item_string [EOL] [EOL] last_was_keyword = item . is_keyword [EOL] return string [EOL] [EOL] def __iter__ ( self ) : [EOL] for element in self . _items : [EOL] yield element [EOL] [EOL] def __getitem__ ( self , idx ) : [EOL] return self . _items [ idx ] [EOL] [EOL] def reflow ( self , reflowed_lines , continued_indent , break_after_open_bracket = False ) : [EOL] last_was_container = False [EOL] for ( index , item ) in enumerate ( self . _items ) : [EOL] next_item = get_item ( self . _items , index + [number] ) [EOL] [EOL] if isinstance ( item , Atom ) : [EOL] is_list_comp_or_if_expr = ( isinstance ( self , ( ListComprehension , IfExpression ) ) ) [EOL] item . reflow ( reflowed_lines , continued_indent , self . _get_extent ( index ) , is_list_comp_or_if_expr = is_list_comp_or_if_expr , next_is_dot = ( next_item and unicode ( next_item ) == [string] ) ) [EOL] if last_was_container and item . is_comma : [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] last_was_container = False [EOL] else : [comment] [EOL] reflowed_lines . add ( item , len ( continued_indent ) , break_after_open_bracket ) [EOL] last_was_container = not isinstance ( item , ( ListComprehension , IfExpression ) ) [EOL] [EOL] if ( break_after_open_bracket and index == [number] and unicode ( item ) == self . open_bracket and ( not next_item or unicode ( next_item ) != self . close_bracket ) and ( len ( self . _items ) != [number] or not isinstance ( next_item , Atom ) ) ) : [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] break_after_open_bracket = False [EOL] else : [EOL] next_next_item = get_item ( self . _items , index + [number] ) [EOL] if ( unicode ( item ) not in [ [string] , [string] , [string] ] and next_item and not isinstance ( next_item , Container ) and unicode ( next_item ) != [string] and next_next_item and ( not isinstance ( next_next_item , Atom ) or unicode ( next_item ) == [string] ) and not reflowed_lines . line_empty ( ) and not reflowed_lines . fits_on_current_line ( self . _get_extent ( index + [number] ) + [number] ) ) : [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] [EOL] def _get_extent ( self , index ) : [EOL] [docstring] [EOL] extent = [number] [EOL] prev_item = get_item ( self . _items , index - [number] ) [EOL] seen_dot = prev_item and unicode ( prev_item ) == [string] [EOL] while index < len ( self . _items ) : [EOL] item = get_item ( self . _items , index ) [EOL] index += [number] [EOL] [EOL] if isinstance ( item , ( ListComprehension , IfExpression ) ) : [EOL] break [EOL] [EOL] if isinstance ( item , Container ) : [EOL] if prev_item and prev_item . is_name : [EOL] if seen_dot : [EOL] extent += [number] [EOL] else : [EOL] extent += item . size [EOL] [EOL] prev_item = item [EOL] continue [EOL] elif ( unicode ( item ) not in [ [string] , [string] , [string] , [string] ] and not item . is_name and not item . is_string ) : [EOL] break [EOL] [EOL] if unicode ( item ) == [string] : [EOL] seen_dot = True [EOL] [EOL] extent += item . size [EOL] prev_item = item [EOL] [EOL] return extent [EOL] [EOL] @ property def is_string ( self ) : [EOL] return False [EOL] [EOL] @ property def size ( self ) : [EOL] return len ( self . __repr__ ( ) ) [EOL] [EOL] @ property def is_keyword ( self ) : [EOL] return False [EOL] [EOL] @ property def is_name ( self ) : [EOL] return False [EOL] [EOL] @ property def is_comma ( self ) : [EOL] return False [EOL] [EOL] @ property def is_colon ( self ) : [EOL] return False [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return None [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return None [EOL] [EOL] [EOL] class Tuple ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return [string] [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class List ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return [string] [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class DictOrSet ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return [string] [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ListComprehension ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def size ( self ) : [EOL] length = [number] [EOL] for item in self . _items : [EOL] if isinstance ( item , IfExpression ) : [EOL] break [EOL] length += item . size [EOL] return length [EOL] [EOL] [EOL] class IfExpression ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def _parse_container ( tokens , index , for_or_if = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] items = [ Atom ( Token ( * tokens [ index ] ) ) ] [EOL] index += [number] [EOL] [EOL] num_tokens = len ( tokens ) [EOL] while index < num_tokens : [EOL] tok = Token ( * tokens [ index ] ) [EOL] [EOL] if tok . token_string in [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if for_or_if == [string] : [EOL] return ( ListComprehension ( items ) , index - [number] ) [EOL] [EOL] elif for_or_if == [string] : [EOL] return ( IfExpression ( items ) , index - [number] ) [EOL] [EOL] [comment] [EOL] items . append ( Atom ( tok ) ) [EOL] [EOL] [comment] [EOL] if tok . token_string == [string] : [EOL] [comment] [EOL] return ( Tuple ( items ) , index ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] [comment] [EOL] return ( List ( items ) , index ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] [comment] [EOL] return ( DictOrSet ( items ) , index ) [EOL] [EOL] elif tok . token_string in [string] : [EOL] [comment] [EOL] ( container , index ) = _parse_container ( tokens , index ) [EOL] items . append ( container ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] ( container , index ) = _parse_container ( tokens , index , [string] ) [EOL] items . append ( container ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] ( container , index ) = _parse_container ( tokens , index , [string] ) [EOL] items . append ( container ) [EOL] [EOL] else : [EOL] items . append ( Atom ( tok ) ) [EOL] [EOL] index += [number] [EOL] [EOL] return ( None , None ) [EOL] [EOL] [EOL] def _parse_tokens ( tokens ) : [EOL] [docstring] [EOL] [EOL] index = [number] [EOL] parsed_tokens = [ ] [EOL] [EOL] num_tokens = len ( tokens ) [EOL] while index < num_tokens : [EOL] tok = Token ( * tokens [ index ] ) [EOL] [EOL] assert tok . token_type != token . INDENT [EOL] if tok . token_type == tokenize . NEWLINE : [EOL] [comment] [EOL] break [EOL] [EOL] if tok . token_string in [string] : [EOL] ( container , index ) = _parse_container ( tokens , index ) [EOL] if not container : [EOL] return None [EOL] parsed_tokens . append ( container ) [EOL] else : [EOL] parsed_tokens . append ( Atom ( tok ) ) [EOL] [EOL] index += [number] [EOL] [EOL] return parsed_tokens [EOL] [EOL] [EOL] def _reflow_lines ( parsed_tokens , indentation , max_line_length , start_on_prefix_line ) : [EOL] [docstring] [EOL] [EOL] if unicode ( parsed_tokens [ [number] ] ) == [string] : [EOL] [comment] [EOL] continued_indent = indentation + [string] * [number] * DEFAULT_INDENT_SIZE [EOL] else : [EOL] continued_indent = indentation + [string] * DEFAULT_INDENT_SIZE [EOL] [EOL] break_after_open_bracket = not start_on_prefix_line [EOL] [EOL] lines = ReformattedLines ( max_line_length ) [EOL] lines . add_indent ( len ( indentation . lstrip ( [string] ) ) ) [EOL] [EOL] if not start_on_prefix_line : [EOL] [comment] [EOL] [comment] [EOL] first_token = get_item ( parsed_tokens , [number] ) [EOL] second_token = get_item ( parsed_tokens , [number] ) [EOL] [EOL] if ( first_token and second_token and unicode ( second_token ) [ [number] ] == [string] and len ( indentation ) + len ( first_token ) + [number] == len ( continued_indent ) ) : [EOL] return None [EOL] [EOL] for item in parsed_tokens : [EOL] lines . add_space_if_needed ( unicode ( item ) , equal = True ) [EOL] [EOL] save_continued_indent = continued_indent [EOL] if start_on_prefix_line and isinstance ( item , Container ) : [EOL] start_on_prefix_line = False [EOL] continued_indent = [string] * ( lines . current_size ( ) + [number] ) [EOL] [EOL] item . reflow ( lines , continued_indent , break_after_open_bracket ) [EOL] continued_indent = save_continued_indent [EOL] [EOL] return lines . emit ( ) [EOL] [EOL] [EOL] def _shorten_line_at_tokens_new ( tokens , source , indentation , max_line_length ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] yield indentation + source [EOL] [EOL] parsed_tokens = _parse_tokens ( tokens ) [EOL] [EOL] if parsed_tokens : [EOL] [comment] [EOL] [comment] [EOL] fixed = _reflow_lines ( parsed_tokens , indentation , max_line_length , start_on_prefix_line = True ) [EOL] if fixed and check_syntax ( normalize_multiline ( fixed . lstrip ( ) ) ) : [EOL] yield fixed [EOL] [EOL] fixed = _reflow_lines ( parsed_tokens , indentation , max_line_length , start_on_prefix_line = False ) [EOL] if fixed and check_syntax ( normalize_multiline ( fixed . lstrip ( ) ) ) : [EOL] yield fixed [EOL] [EOL] [EOL] def _shorten_line_at_tokens ( tokens , source , indentation , indent_word , key_token_strings , aggressive ) : [EOL] [docstring] [EOL] offsets = [ ] [EOL] for ( index , _t ) in enumerate ( token_offsets ( tokens ) ) : [EOL] ( token_type , token_string , start_offset , end_offset ) = _t [EOL] [EOL] assert token_type != token . INDENT [EOL] [EOL] if token_string in key_token_strings : [EOL] [comment] [EOL] unwanted_next_token = { [string] : [string] , [string] : [string] , [string] : [string] } . get ( token_string ) [EOL] if unwanted_next_token : [EOL] if ( get_item ( tokens , index + [number] , default = [ None , None ] ) [ [number] ] == unwanted_next_token or get_item ( tokens , index + [number] , default = [ None , None ] ) [ [number] ] == unwanted_next_token ) : [EOL] continue [EOL] [EOL] if ( index > [number] and token_string == [string] and tokens [ index - [number] ] [ [number] ] in [string] ) : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] [EOL] if end_offset < len ( source ) - [number] : [EOL] [comment] [EOL] offsets . append ( end_offset ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] previous_token = get_item ( tokens , index - [number] ) [EOL] if ( token_type == tokenize . STRING and previous_token and previous_token [ [number] ] == tokenize . STRING ) : [EOL] offsets . append ( start_offset ) [EOL] [EOL] current_indent = None [EOL] fixed = None [EOL] for line in split_at_offsets ( source , offsets ) : [EOL] if fixed : [EOL] fixed += [string] + current_indent + line [EOL] [EOL] for symbol in [string] : [EOL] if line . endswith ( symbol ) : [EOL] current_indent += indent_word [EOL] else : [EOL] [comment] [EOL] fixed = line [EOL] assert not current_indent [EOL] current_indent = indent_word [EOL] [EOL] assert fixed is not None [EOL] [EOL] if check_syntax ( normalize_multiline ( fixed ) [EOL] if aggressive > [number] else fixed ) : [EOL] return indentation + fixed [EOL] [EOL] return None [EOL] [EOL] [EOL] def token_offsets ( tokens ) : [EOL] [docstring] [EOL] end_offset = [number] [EOL] previous_end_row = [number] [EOL] previous_end_column = [number] [EOL] for t in tokens : [EOL] token_type = t [ [number] ] [EOL] token_string = t [ [number] ] [EOL] ( start_row , start_column ) = t [ [number] ] [EOL] ( end_row , end_column ) = t [ [number] ] [EOL] [EOL] [comment] [EOL] end_offset += start_column [EOL] if previous_end_row == start_row : [EOL] end_offset -= previous_end_column [EOL] [EOL] [comment] [EOL] start_offset = end_offset [EOL] [EOL] [comment] [EOL] end_offset += len ( token_string ) [EOL] [EOL] yield ( token_type , token_string , start_offset , end_offset ) [EOL] [EOL] previous_end_row = end_row [EOL] previous_end_column = end_column [EOL] [EOL] [EOL] def normalize_multiline ( line ) : [EOL] [docstring] [EOL] if line . startswith ( [string] ) and line . rstrip ( ) . endswith ( [string] ) : [EOL] return line + [string] [EOL] elif line . startswith ( [string] ) : [EOL] return [string] + line [EOL] elif line . startswith ( [string] ) : [EOL] return line + [string] [EOL] elif line . startswith ( [string] ) : [EOL] return line + [string] [EOL] elif line . startswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] return line + [string] [EOL] [EOL] return line [EOL] [EOL] [EOL] def fix_whitespace ( line , offset , replacement ) : [EOL] [docstring] [EOL] [comment] [EOL] left = line [ : offset ] . rstrip ( [string] ) [EOL] right = line [ offset : ] . lstrip ( [string] ) [EOL] if right . startswith ( [string] ) : [EOL] return line [EOL] [EOL] return left + replacement + right [EOL] [EOL] [EOL] def _execute_pep8 ( pep8_options , source ) : [EOL] [docstring] [EOL] class QuietReport ( pycodestyle . BaseReport ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , options ) : [EOL] super ( QuietReport , self ) . __init__ ( options ) [EOL] self . __full_error_results = [ ] [EOL] [EOL] def error ( self , line_number , offset , text , check ) : [EOL] [docstring] [EOL] code = super ( QuietReport , self ) . error ( line_number , offset , text , check ) [EOL] if code : [EOL] self . __full_error_results . append ( { [string] : code , [string] : line_number , [string] : offset + [number] , [string] : text } ) [EOL] [EOL] def full_error_results ( self ) : [EOL] [docstring] [EOL] return self . __full_error_results [EOL] [EOL] checker = pycodestyle . Checker ( [string] , lines = source , reporter = QuietReport , ** pep8_options ) [EOL] checker . check_all ( ) [EOL] return checker . report . full_error_results ( ) [EOL] [EOL] [EOL] def _remove_leading_and_normalize ( line ) : [EOL] return line . lstrip ( ) . rstrip ( CR + LF ) + [string] [EOL] [EOL] [EOL] class Reindenter ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , input_text ) : [EOL] sio = io . StringIO ( input_text ) [EOL] source_lines = sio . readlines ( ) [EOL] [EOL] self . string_content_line_numbers = multiline_string_lines ( input_text ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . lines = [ ] [EOL] for line_number , line in enumerate ( source_lines , start = [number] ) : [EOL] [comment] [EOL] if line_number in self . string_content_line_numbers : [EOL] self . lines . append ( line ) [EOL] else : [EOL] [comment] [EOL] self . lines . append ( _get_indentation ( line ) . expandtabs ( ) + _remove_leading_and_normalize ( line ) ) [EOL] [EOL] self . lines . insert ( [number] , None ) [EOL] self . index = [number] [comment] [EOL] self . input_text = input_text [EOL] [EOL] def run ( self , indent_size = DEFAULT_INDENT_SIZE ) : [EOL] [docstring] [EOL] if indent_size < [number] : [EOL] return self . input_text [EOL] [EOL] try : [EOL] stats = _reindent_stats ( tokenize . generate_tokens ( self . getline ) ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] return self . input_text [EOL] [comment] [EOL] lines = self . lines [EOL] [comment] [EOL] stats . append ( ( len ( lines ) , [number] ) ) [EOL] [comment] [EOL] have2want = { } [EOL] [comment] [EOL] after = [ ] [EOL] [comment] [EOL] [comment] [EOL] i = stats [ [number] ] [ [number] ] [EOL] after . extend ( lines [ [number] : i ] ) [EOL] for i in range ( len ( stats ) - [number] ) : [EOL] thisstmt , thislevel = stats [ i ] [EOL] nextstmt = stats [ i + [number] ] [ [number] ] [EOL] have = _leading_space_count ( lines [ thisstmt ] ) [EOL] want = thislevel * indent_size [EOL] if want < [number] : [EOL] [comment] [EOL] if have : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] want = have2want . get ( have , - [number] ) [EOL] if want < [number] : [EOL] [comment] [EOL] for j in range ( i + [number] , len ( stats ) - [number] ) : [EOL] jline , jlevel = stats [ j ] [EOL] if jlevel >= [number] : [EOL] if have == _leading_space_count ( lines [ jline ] ) : [EOL] want = jlevel * indent_size [EOL] break [EOL] if want < [number] : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for j in range ( i - [number] , - [number] , - [number] ) : [EOL] jline , jlevel = stats [ j ] [EOL] if jlevel >= [number] : [EOL] want = ( have + _leading_space_count ( after [ jline - [number] ] ) - _leading_space_count ( lines [ jline ] ) ) [EOL] break [EOL] if want < [number] : [EOL] [comment] [EOL] want = have [EOL] else : [EOL] want = [number] [EOL] assert want >= [number] [EOL] have2want [ have ] = want [EOL] diff = want - have [EOL] if diff == [number] or have == [number] : [EOL] after . extend ( lines [ thisstmt : nextstmt ] ) [EOL] else : [EOL] for line_number , line in enumerate ( lines [ thisstmt : nextstmt ] , start = thisstmt ) : [EOL] if line_number in self . string_content_line_numbers : [EOL] after . append ( line ) [EOL] elif diff > [number] : [EOL] if line == [string] : [EOL] after . append ( line ) [EOL] else : [EOL] after . append ( [string] * diff + line ) [EOL] else : [EOL] remove = min ( _leading_space_count ( line ) , - diff ) [EOL] after . append ( line [ remove : ] ) [EOL] [EOL] return [string] . join ( after ) [EOL] [EOL] def getline ( self ) : [EOL] [docstring] [EOL] if self . index >= len ( self . lines ) : [EOL] line = [string] [EOL] else : [EOL] line = self . lines [ self . index ] [EOL] self . index += [number] [EOL] return line [EOL] [EOL] [EOL] def _reindent_stats ( tokens ) : [EOL] [docstring] [EOL] find_stmt = [number] [comment] [EOL] level = [number] [comment] [EOL] stats = [ ] [EOL] [EOL] for t in tokens : [EOL] token_type = t [ [number] ] [EOL] sline = t [ [number] ] [ [number] ] [EOL] line = t [ [number] ] [EOL] [EOL] if token_type == tokenize . NEWLINE : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] find_stmt = [number] [EOL] [EOL] elif token_type == tokenize . INDENT : [EOL] find_stmt = [number] [EOL] level += [number] [EOL] [EOL] elif token_type == tokenize . DEDENT : [EOL] find_stmt = [number] [EOL] level -= [number] [EOL] [EOL] elif token_type == tokenize . COMMENT : [EOL] if find_stmt : [EOL] stats . append ( ( sline , - [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] elif token_type == tokenize . NL : [EOL] pass [EOL] [EOL] elif find_stmt : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] find_stmt = [number] [EOL] if line : [comment] [EOL] stats . append ( ( sline , level ) ) [EOL] [EOL] return stats [EOL] [EOL] [EOL] def _leading_space_count ( line ) : [EOL] [docstring] [EOL] i = [number] [EOL] while i < len ( line ) and line [ i ] == [string] : [EOL] i += [number] [EOL] return i [EOL] [EOL] [EOL] def refactor_with_2to3 ( source_text , fixer_names , filename = [string] ) : [EOL] [docstring] [EOL] from lib2to3 . refactor import RefactoringTool [EOL] fixers = [ [string] + name for name in fixer_names ] [EOL] tool = RefactoringTool ( fixer_names = fixers , explicit = fixers ) [EOL] [EOL] from lib2to3 . pgen2 import tokenize as lib2to3_tokenize [EOL] try : [EOL] [comment] [EOL] return unicode ( tool . refactor_string ( source_text , name = filename ) ) [EOL] except lib2to3_tokenize . TokenError : [EOL] return source_text [EOL] [EOL] [EOL] def check_syntax ( code ) : [EOL] [docstring] [EOL] try : [EOL] return compile ( code , [string] , [string] ) [EOL] except ( SyntaxError , TypeError , UnicodeDecodeError ) : [EOL] return False [EOL] [EOL] [EOL] def filter_results ( source , results , aggressive ) : [EOL] [docstring] [EOL] non_docstring_string_line_numbers = multiline_string_lines ( source , include_docstrings = False ) [EOL] all_string_line_numbers = multiline_string_lines ( source , include_docstrings = True ) [EOL] [EOL] commented_out_code_line_numbers = commented_out_code_lines ( source ) [EOL] [EOL] has_e901 = any ( result [ [string] ] . lower ( ) == [string] for result in results ) [EOL] [EOL] for r in results : [EOL] issue_id = r [ [string] ] . lower ( ) [EOL] [EOL] if r [ [string] ] in non_docstring_string_line_numbers : [EOL] if issue_id . startswith ( ( [string] , [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if r [ [string] ] in all_string_line_numbers : [EOL] if issue_id in [ [string] ] : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not aggressive and ( r [ [string] ] + [number] ) in all_string_line_numbers : [EOL] [comment] [EOL] [comment] [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if aggressive <= [number] : [EOL] if issue_id . startswith ( ( [string] , [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if aggressive <= [number] : [EOL] if issue_id . startswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if aggressive <= [number] : [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if r [ [string] ] in commented_out_code_line_numbers : [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if has_e901 : [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] yield r [EOL] [EOL] [EOL] def multiline_string_lines ( source , include_docstrings = False ) : [EOL] [docstring] [EOL] line_numbers = set ( ) [EOL] previous_token_type = [string] [EOL] try : [EOL] for t in generate_tokens ( source ) : [EOL] token_type = t [ [number] ] [EOL] start_row = t [ [number] ] [ [number] ] [EOL] end_row = t [ [number] ] [ [number] ] [EOL] [EOL] if token_type == tokenize . STRING and start_row != end_row : [EOL] if ( include_docstrings or previous_token_type != tokenize . INDENT ) : [EOL] [comment] [EOL] [comment] [EOL] line_numbers |= set ( range ( [number] + start_row , [number] + end_row ) ) [EOL] [EOL] previous_token_type = token_type [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] pass [EOL] [EOL] return line_numbers [EOL] [EOL] [EOL] def commented_out_code_lines ( source ) : [EOL] [docstring] [EOL] line_numbers = [ ] [EOL] try : [EOL] for t in generate_tokens ( source ) : [EOL] token_type = t [ [number] ] [EOL] token_string = t [ [number] ] [EOL] start_row = t [ [number] ] [ [number] ] [EOL] line = t [ [number] ] [EOL] [EOL] [comment] [EOL] if not line . lstrip ( ) . startswith ( [string] ) : [EOL] continue [EOL] [EOL] if token_type == tokenize . COMMENT : [EOL] stripped_line = token_string . lstrip ( [string] ) . strip ( ) [EOL] if ( [string] in stripped_line and [string] not in stripped_line and check_syntax ( stripped_line ) ) : [EOL] line_numbers . append ( start_row ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] pass [EOL] [EOL] return line_numbers [EOL] [EOL] [EOL] def shorten_comment ( line , max_line_length , last_comment = False ) : [EOL] [docstring] [EOL] assert len ( line ) > max_line_length [EOL] line = line . rstrip ( ) [EOL] [EOL] [comment] [EOL] indentation = _get_indentation ( line ) + [string] [EOL] max_line_length = min ( max_line_length , len ( indentation ) + [number] ) [EOL] [EOL] MIN_CHARACTER_REPEAT = [number] [EOL] if ( len ( line ) - len ( line . rstrip ( line [ - [number] ] ) ) >= MIN_CHARACTER_REPEAT and not line [ - [number] ] . isalnum ( ) ) : [EOL] [comment] [EOL] return line [ : max_line_length ] + [string] [EOL] elif last_comment and re . match ( [string] , line ) : [EOL] split_lines = textwrap . wrap ( line . lstrip ( [string] ) , initial_indent = indentation , subsequent_indent = indentation , width = max_line_length , break_long_words = False , break_on_hyphens = False ) [EOL] return [string] . join ( split_lines ) + [string] [EOL] [EOL] return line + [string] [EOL] [EOL] [EOL] def normalize_line_endings ( lines , newline ) : [EOL] [docstring] [EOL] return [ line . rstrip ( [string] ) + newline for line in lines ] [EOL] [EOL] [EOL] def mutual_startswith ( a , b ) : [EOL] return b . startswith ( a ) or a . startswith ( b ) [EOL] [EOL] [EOL] def code_match ( code , select , ignore ) : [EOL] if ignore : [EOL] assert not isinstance ( ignore , unicode ) [EOL] for ignored_code in [ c . strip ( ) for c in ignore ] : [EOL] if mutual_startswith ( code . lower ( ) , ignored_code . lower ( ) ) : [EOL] return False [EOL] [EOL] if select : [EOL] assert not isinstance ( select , unicode ) [EOL] for selected_code in [ c . strip ( ) for c in select ] : [EOL] if mutual_startswith ( code . lower ( ) , selected_code . lower ( ) ) : [EOL] return True [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def fix_code ( source , options = None , encoding = None , apply_config = False ) : [EOL] [docstring] [EOL] options = _get_options ( options , apply_config ) [EOL] [EOL] if not isinstance ( source , unicode ) : [EOL] source = source . decode ( encoding or get_encoding ( ) ) [EOL] [EOL] sio = io . StringIO ( source ) [EOL] return fix_lines ( sio . readlines ( ) , options = options ) [EOL] [EOL] [EOL] def _get_options ( raw_options , apply_config ) : [EOL] [docstring] [EOL] if not raw_options : [EOL] return parse_args ( [ [string] ] , apply_config = apply_config ) [EOL] [EOL] if isinstance ( raw_options , dict ) : [EOL] options = parse_args ( [ [string] ] , apply_config = apply_config ) [EOL] for name , value in raw_options . items ( ) : [EOL] if not hasattr ( options , name ) : [EOL] raise ValueError ( [string] . format ( name ) ) [EOL] [EOL] [comment] [EOL] expected_type = type ( getattr ( options , name ) ) [EOL] if not isinstance ( expected_type , ( str , unicode ) ) : [EOL] if isinstance ( value , ( str , unicode ) ) : [EOL] raise ValueError ( [string] . format ( name ) ) [EOL] setattr ( options , name , value ) [EOL] else : [EOL] options = raw_options [EOL] [EOL] return options [EOL] [EOL] [EOL] def fix_lines ( source_lines , options , filename = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] original_newline = find_newline ( source_lines ) [EOL] tmp_source = [string] . join ( normalize_line_endings ( source_lines , [string] ) ) [EOL] [EOL] [comment] [EOL] previous_hashes = set ( ) [EOL] [EOL] if options . line_range : [EOL] [comment] [EOL] fixed_source = tmp_source [EOL] else : [EOL] [comment] [EOL] fixed_source = apply_global_fixes ( tmp_source , options , filename = filename ) [EOL] [EOL] passes = [number] [EOL] long_line_ignore_cache = set ( ) [EOL] while hash ( fixed_source ) not in previous_hashes : [EOL] if options . pep8_passes >= [number] and passes > options . pep8_passes : [EOL] break [EOL] passes += [number] [EOL] [EOL] previous_hashes . add ( hash ( fixed_source ) ) [EOL] [EOL] tmp_source = copy . copy ( fixed_source ) [EOL] [EOL] fix = FixPEP8 ( filename , options , contents = tmp_source , long_line_ignore_cache = long_line_ignore_cache ) [EOL] [EOL] fixed_source = fix . fix ( ) [EOL] [EOL] sio = io . StringIO ( fixed_source ) [EOL] return [string] . join ( normalize_line_endings ( sio . readlines ( ) , original_newline ) ) [EOL] [EOL] [EOL] def fix_file ( filename , options = None , output = None , apply_config = False ) : [EOL] if not options : [EOL] options = parse_args ( [ filename ] , apply_config = apply_config ) [EOL] [EOL] original_source = readlines_from_file ( filename ) [EOL] [EOL] fixed_source = original_source [EOL] [EOL] if options . in_place or output : [EOL] encoding = detect_encoding ( filename ) [EOL] [EOL] if output : [EOL] output = LineEndingWrapper ( wrap_output ( output , encoding = encoding ) ) [EOL] [EOL] fixed_source = fix_lines ( fixed_source , options , filename = filename ) [EOL] [EOL] if options . diff : [EOL] new = io . StringIO ( fixed_source ) [EOL] new = new . readlines ( ) [EOL] diff = get_diff_text ( original_source , new , filename ) [EOL] if output : [EOL] output . write ( diff ) [EOL] output . flush ( ) [EOL] else : [EOL] return diff [EOL] elif options . in_place : [EOL] fp = open_with_encoding ( filename , encoding = encoding , mode = [string] ) [EOL] fp . write ( fixed_source ) [EOL] fp . close ( ) [EOL] else : [EOL] if output : [EOL] output . write ( fixed_source ) [EOL] output . flush ( ) [EOL] else : [EOL] return fixed_source [EOL] [EOL] [EOL] def global_fixes ( ) : [EOL] [docstring] [EOL] for function in list ( globals ( ) . values ( ) ) : [EOL] if inspect . isfunction ( function ) : [EOL] arguments = _get_parameters ( function ) [EOL] if arguments [ : [number] ] != [ [string] ] : [EOL] continue [EOL] [EOL] code = extract_code_from_function ( function ) [EOL] if code : [EOL] yield ( code , function ) [EOL] [EOL] [EOL] def _get_parameters ( function ) : [EOL] [comment] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if inspect . ismethod ( function ) : [EOL] function = function . __func__ [EOL] [EOL] return list ( inspect . signature ( function ) . parameters ) [EOL] else : [EOL] return inspect . getargspec ( function ) [ [number] ] [EOL] [EOL] [EOL] def apply_global_fixes ( source , options , where = [string] , filename = [string] ) : [EOL] [docstring] [EOL] if any ( code_match ( code , select = options . select , ignore = options . ignore ) for code in [ [string] , [string] ] ) : [EOL] source = reindent ( source , indent_size = options . indent_size ) [EOL] [EOL] for ( code , function ) in global_fixes ( ) : [EOL] if code_match ( code , select = options . select , ignore = options . ignore ) : [EOL] if options . verbose : [EOL] print ( [string] . format ( where , code . upper ( ) ) , file = sys . stderr ) [EOL] source = function ( source , aggressive = options . aggressive ) [EOL] [EOL] source = fix_2to3 ( source , aggressive = options . aggressive , select = options . select , ignore = options . ignore , filename = filename ) [EOL] [EOL] return source [EOL] [EOL] [EOL] def extract_code_from_function ( function ) : [EOL] [docstring] [EOL] if not function . __name__ . startswith ( [string] ) : [EOL] return None [EOL] [EOL] code = re . sub ( [string] , [string] , function . __name__ ) [EOL] if not code : [EOL] return None [EOL] [EOL] try : [EOL] int ( code [ [number] : ] ) [EOL] except ValueError : [EOL] return None [EOL] [EOL] return code [EOL] [EOL] [EOL] def _get_package_version ( ) : [EOL] packages = [ [string] . format ( pycodestyle . __version__ ) ] [EOL] return [string] . join ( packages ) [EOL] [EOL] [EOL] def create_parser ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] import argparse [EOL] [EOL] parser = argparse . ArgumentParser ( description = docstring_summary ( __doc__ ) , prog = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , version = [string] . format ( __version__ , _get_package_version ( ) ) ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = DEFAULT_CONFIG , help = [string] [string] [string] . format ( DEFAULT_CONFIG ) ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , type = int , metavar = [string] , default = [number] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , default = - [number] , type = int , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = [string] , help = [string] [string] . format ( DEFAULT_IGNORE ) ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = [number] , type = int , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , default = None , type = int , nargs = [number] , help = [string] [string] [string] ) [EOL] parser . add_argument ( [string] , default = DEFAULT_INDENT_SIZE , type = int , help = argparse . SUPPRESS ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] def parse_args ( arguments , apply_config = False ) : [EOL] [docstring] [EOL] parser = create_parser ( ) [EOL] args = parser . parse_args ( arguments ) [EOL] [EOL] if not args . files and not args . list_fixes : [EOL] parser . error ( [string] ) [EOL] [EOL] args . files = [ decode_filename ( name ) for name in args . files ] [EOL] [EOL] if apply_config : [EOL] parser = read_config ( args , parser ) [EOL] args = parser . parse_args ( arguments ) [EOL] args . files = [ decode_filename ( name ) for name in args . files ] [EOL] [EOL] if [string] in args . files : [EOL] if len ( args . files ) > [number] : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . diff : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . in_place : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . recursive : [EOL] parser . error ( [string] ) [EOL] [EOL] if len ( args . files ) > [number] and not ( args . in_place or args . diff ) : [EOL] parser . error ( [string] [string] [string] ) [EOL] [EOL] if args . recursive and not ( args . in_place or args . diff ) : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . in_place and args . diff : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . max_line_length <= [number] : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . select : [EOL] args . select = _split_comma_separated ( args . select ) [EOL] [EOL] if args . ignore : [EOL] args . ignore = _split_comma_separated ( args . ignore ) [EOL] elif not args . select : [EOL] if args . aggressive : [EOL] [comment] [EOL] args . select = set ( [ [string] , [string] ] ) [EOL] else : [EOL] args . ignore = _split_comma_separated ( DEFAULT_IGNORE ) [EOL] [EOL] if args . exclude : [EOL] args . exclude = _split_comma_separated ( args . exclude ) [EOL] else : [EOL] args . exclude = set ( [ ] ) [EOL] [EOL] if args . jobs < [number] : [EOL] [comment] [EOL] [comment] [EOL] import multiprocessing [EOL] args . jobs = multiprocessing . cpu_count ( ) [EOL] [EOL] if args . jobs > [number] and not args . in_place : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . line_range : [EOL] if args . line_range [ [number] ] <= [number] : [EOL] parser . error ( [string] ) [EOL] if args . line_range [ [number] ] > args . line_range [ [number] ] : [EOL] parser . error ( [string] [string] ) [EOL] [EOL] return args [EOL] [EOL] [EOL] def read_config ( args , parser ) : [EOL] [docstring] [EOL] try : [EOL] from configparser import ConfigParser as SafeConfigParser [EOL] from configparser import Error [EOL] except ImportError : [EOL] from ConfigParser import SafeConfigParser [EOL] from ConfigParser import Error [EOL] [EOL] config = SafeConfigParser ( ) [EOL] [EOL] try : [EOL] config . read ( args . global_config ) [EOL] [EOL] if not args . ignore_local_config : [EOL] parent = tail = args . files and os . path . abspath ( os . path . commonprefix ( args . files ) ) [EOL] while tail : [EOL] if config . read ( [ os . path . join ( parent , fn ) for fn in PROJECT_CONFIG ] ) : [EOL] break [EOL] ( parent , tail ) = os . path . split ( parent ) [EOL] [EOL] defaults = dict ( ) [EOL] option_list = dict ( [ ( o . dest , o . type or type ( o . default ) ) for o in parser . _actions ] ) [EOL] [EOL] for section in [ [string] , [string] ] : [EOL] if not config . has_section ( section ) : [EOL] continue [EOL] for ( k , _ ) in config . items ( section ) : [EOL] norm_opt = k . lstrip ( [string] ) . replace ( [string] , [string] ) [EOL] opt_type = option_list [ norm_opt ] [EOL] if opt_type is int : [EOL] value = config . getint ( section , k ) [EOL] elif opt_type is bool : [EOL] value = config . getboolean ( section , k ) [EOL] else : [EOL] value = config . get ( section , k ) [EOL] defaults [ norm_opt ] = value [EOL] [EOL] parser . set_defaults ( ** defaults ) [EOL] except Error : [EOL] [comment] [EOL] pass [EOL] [EOL] return parser [EOL] [EOL] [EOL] def _split_comma_separated ( string ) : [EOL] [docstring] [EOL] return set ( text . strip ( ) for text in string . split ( [string] ) if text . strip ( ) ) [EOL] [EOL] [EOL] def decode_filename ( filename ) : [EOL] [docstring] [EOL] if isinstance ( filename , unicode ) : [EOL] return filename [EOL] [EOL] return filename . decode ( sys . getfilesystemencoding ( ) ) [EOL] [EOL] [EOL] def supported_fixes ( ) : [EOL] [docstring] [EOL] yield ( [string] , docstring_summary ( reindent . __doc__ ) ) [EOL] [EOL] instance = FixPEP8 ( filename = None , options = None , contents = [string] ) [EOL] for attribute in dir ( instance ) : [EOL] code = re . match ( [string] , attribute ) [EOL] if code : [EOL] yield ( code . group ( [number] ) . upper ( ) , re . sub ( [string] , [string] , docstring_summary ( getattr ( instance , attribute ) . __doc__ ) ) ) [EOL] [EOL] for ( code , function ) in sorted ( global_fixes ( ) ) : [EOL] yield ( code . upper ( ) + ( [number] - len ( code ) ) * [string] , re . sub ( [string] , [string] , docstring_summary ( function . __doc__ ) ) ) [EOL] [EOL] for code in sorted ( CODE_TO_2TO3 ) : [EOL] yield ( code . upper ( ) + ( [number] - len ( code ) ) * [string] , re . sub ( [string] , [string] , docstring_summary ( fix_2to3 . __doc__ ) ) ) [EOL] [EOL] [EOL] def docstring_summary ( docstring ) : [EOL] [docstring] [EOL] return docstring . split ( [string] ) [ [number] ] if docstring else [string] [EOL] [EOL] [EOL] def line_shortening_rank ( candidate , indent_word , max_line_length , experimental = False ) : [EOL] [docstring] [EOL] if not candidate . strip ( ) : [EOL] return [number] [EOL] [EOL] rank = [number] [EOL] lines = candidate . rstrip ( ) . split ( [string] ) [EOL] [EOL] offset = [number] [EOL] if ( not lines [ [number] ] . lstrip ( ) . startswith ( [string] ) and lines [ [number] ] . rstrip ( ) [ - [number] ] not in [string] ) : [EOL] for ( opening , closing ) in ( [string] , [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] opening_loc = lines [ [number] ] . find ( opening ) [EOL] closing_loc = lines [ [number] ] . find ( closing ) [EOL] if opening_loc >= [number] : [EOL] if closing_loc < [number] or closing_loc != opening_loc + [number] : [EOL] offset = max ( offset , [number] + opening_loc ) [EOL] [EOL] current_longest = max ( offset + len ( x . strip ( ) ) for x in lines ) [EOL] [EOL] rank += [number] * max ( [number] , current_longest - max_line_length ) [EOL] [EOL] rank += len ( lines ) [EOL] [EOL] [comment] [EOL] rank += [number] * standard_deviation ( len ( line ) for line in lines ) [EOL] [EOL] bad_staring_symbol = { [string] : [string] , [string] : [string] , [string] : [string] } . get ( lines [ [number] ] [ - [number] ] ) [EOL] [EOL] if len ( lines ) > [number] : [EOL] if ( bad_staring_symbol and lines [ [number] ] . lstrip ( ) . startswith ( bad_staring_symbol ) ) : [EOL] rank += [number] [EOL] [EOL] for lineno , current_line in enumerate ( lines ) : [EOL] current_line = current_line . strip ( ) [EOL] [EOL] if current_line . startswith ( [string] ) : [EOL] continue [EOL] [EOL] for bad_start in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] if current_line . startswith ( bad_start ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if current_line == bad_start : [EOL] rank += [number] [EOL] [EOL] if ( current_line . endswith ( ( [string] , [string] , [string] , [string] , [string] ) ) and [string] in current_line ) : [EOL] rank += [number] [EOL] [EOL] if current_line . endswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] [comment] [EOL] if len ( current_line ) <= len ( indent_word ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if ( current_line . endswith ( [string] ) and current_line [ : - [number] ] . rstrip ( ) . endswith ( [string] ) ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if ( current_line . endswith ( [string] ) and len ( current_line ) > [number] and ( current_line [ - [number] ] . isalnum ( ) or current_line [ - [number] ] in [string] ) ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if current_line . endswith ( [string] ) : [EOL] rank += [number] [EOL] [EOL] if has_arithmetic_operator ( current_line ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if re . match ( [string] , current_line . rstrip ( [string] ) ) : [EOL] rank += [number] [EOL] [EOL] if re . match ( [string] , current_line . rstrip ( [string] ) ) : [EOL] rank += [number] [EOL] [EOL] if current_line . endswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] rank -= [number] [EOL] [EOL] [comment] [EOL] if current_line . startswith ( [string] ) : [EOL] rank -= [number] [EOL] [EOL] if current_line . endswith ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] total_len = len ( current_line ) [EOL] lineno += [number] [EOL] while lineno < len ( lines ) : [EOL] total_len += len ( lines [ lineno ] ) [EOL] [EOL] if lines [ lineno ] . lstrip ( ) . startswith ( [string] ) : [EOL] total_len = max_line_length [EOL] break [EOL] [EOL] if not lines [ lineno ] . endswith ( [string] ) : [EOL] break [EOL] [EOL] lineno += [number] [EOL] [EOL] if total_len < max_line_length : [EOL] rank += [number] [EOL] else : [EOL] rank += [number] if experimental else [number] [EOL] [EOL] [comment] [EOL] if [string] in current_line and current_line . endswith ( [string] ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if current_line . endswith ( [string] ) : [EOL] rank += [number] [EOL] [EOL] rank += [number] * count_unbalanced_brackets ( current_line ) [EOL] [EOL] return max ( [number] , rank ) [EOL] [EOL] [EOL] def standard_deviation ( numbers ) : [EOL] [docstring] [EOL] numbers = list ( numbers ) [EOL] if not numbers : [EOL] return [number] [EOL] mean = sum ( numbers ) / len ( numbers ) [EOL] return ( sum ( ( n - mean ) ** [number] for n in numbers ) / len ( numbers ) ) ** [number] [EOL] [EOL] [EOL] def has_arithmetic_operator ( line ) : [EOL] [docstring] [EOL] for operator in pycodestyle . ARITHMETIC_OP : [EOL] if operator in line : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def count_unbalanced_brackets ( line ) : [EOL] [docstring] [EOL] count = [number] [EOL] for opening , closing in [ [string] , [string] , [string] ] : [EOL] count += abs ( line . count ( opening ) - line . count ( closing ) ) [EOL] [EOL] return count [EOL] [EOL] [EOL] def split_at_offsets ( line , offsets ) : [EOL] [docstring] [EOL] result = [ ] [EOL] [EOL] previous_offset = [number] [EOL] current_offset = [number] [EOL] for current_offset in sorted ( offsets ) : [EOL] if current_offset < len ( line ) and previous_offset != current_offset : [EOL] result . append ( line [ previous_offset : current_offset ] . strip ( ) ) [EOL] previous_offset = current_offset [EOL] [EOL] result . append ( line [ current_offset : ] ) [EOL] [EOL] return result [EOL] [EOL] [EOL] class LineEndingWrapper ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output ) : [EOL] self . __output = output [EOL] [EOL] def write ( self , s ) : [EOL] self . __output . write ( s . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] [EOL] def flush ( self ) : [EOL] self . __output . flush ( ) [EOL] [EOL] [EOL] def match_file ( filename , exclude ) : [EOL] [docstring] [EOL] base_name = os . path . basename ( filename ) [EOL] [EOL] if base_name . startswith ( [string] ) : [EOL] return False [EOL] [EOL] for pattern in exclude : [EOL] if fnmatch . fnmatch ( base_name , pattern ) : [EOL] return False [EOL] if fnmatch . fnmatch ( filename , pattern ) : [EOL] return False [EOL] [EOL] if not os . path . isdir ( filename ) and not is_python_file ( filename ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def find_files ( filenames , recursive , exclude ) : [EOL] [docstring] [EOL] while filenames : [EOL] name = filenames . pop ( [number] ) [EOL] if recursive and os . path . isdir ( name ) : [EOL] for root , directories , children in os . walk ( name ) : [EOL] filenames += [ os . path . join ( root , f ) for f in children if match_file ( os . path . join ( root , f ) , exclude ) ] [EOL] directories [ : ] = [ d for d in directories if match_file ( os . path . join ( root , d ) , exclude ) ] [EOL] else : [EOL] yield name [EOL] [EOL] [EOL] def _fix_file ( parameters ) : [EOL] [docstring] [EOL] if parameters [ [number] ] . verbose : [EOL] print ( [string] . format ( parameters [ [number] ] ) , file = sys . stderr ) [EOL] try : [EOL] fix_file ( * parameters ) [EOL] except IOError as error : [EOL] print ( unicode ( error ) , file = sys . stderr ) [EOL] [EOL] [EOL] def fix_multiple_files ( filenames , options , output = None ) : [EOL] [docstring] [EOL] filenames = find_files ( filenames , options . recursive , options . exclude ) [EOL] if options . jobs > [number] : [EOL] import multiprocessing [EOL] pool = multiprocessing . Pool ( options . jobs ) [EOL] pool . map ( _fix_file , [ ( name , options ) for name in filenames ] ) [EOL] else : [EOL] for name in filenames : [EOL] _fix_file ( ( name , options , output ) ) [EOL] [EOL] [EOL] def is_python_file ( filename ) : [EOL] [docstring] [EOL] if filename . endswith ( [string] ) : [EOL] return True [EOL] [EOL] try : [EOL] with open_with_encoding ( filename , limit_byte_check = MAX_PYTHON_FILE_DETECTION_BYTES ) as f : [EOL] text = f . read ( MAX_PYTHON_FILE_DETECTION_BYTES ) [EOL] if not text : [EOL] return False [EOL] first_line = text . splitlines ( ) [ [number] ] [EOL] except ( IOError , IndexError ) : [EOL] return False [EOL] [EOL] if not PYTHON_SHEBANG_REGEX . match ( first_line ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def is_probably_part_of_multiline ( line ) : [EOL] [docstring] [EOL] return ( [string] in line or [string] in line or line . rstrip ( ) . endswith ( [string] ) ) [EOL] [EOL] [EOL] def wrap_output ( output , encoding ) : [EOL] [docstring] [EOL] return codecs . getwriter ( encoding ) ( output . buffer [EOL] if hasattr ( output , [string] ) [EOL] else output ) [EOL] [EOL] [EOL] def get_encoding ( ) : [EOL] [docstring] [EOL] return locale . getpreferredencoding ( ) or sys . getdefaultencoding ( ) [EOL] [EOL] [EOL] def main ( argv = None , apply_config = True ) : [EOL] [docstring] [EOL] if argv is None : [EOL] argv = sys . argv [EOL] [EOL] try : [EOL] [comment] [EOL] signal . signal ( signal . SIGPIPE , signal . SIG_DFL ) [EOL] except AttributeError : [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] try : [EOL] args = parse_args ( argv [ [number] : ] , apply_config = apply_config ) [EOL] [EOL] if args . list_fixes : [EOL] for code , description in sorted ( supported_fixes ( ) ) : [EOL] print ( [string] . format ( code = code , description = description ) ) [EOL] return [number] [EOL] [EOL] if args . files == [ [string] ] : [EOL] assert not args . in_place [EOL] [EOL] encoding = sys . stdin . encoding or get_encoding ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] wrap_output ( sys . stdout , encoding = encoding ) . write ( fix_code ( sys . stdin . read ( ) , args , encoding = encoding ) ) [EOL] else : [EOL] if args . in_place or args . diff : [EOL] args . files = list ( set ( args . files ) ) [EOL] else : [EOL] assert len ( args . files ) == [number] [EOL] assert not args . recursive [EOL] [EOL] fix_multiple_files ( args . files , args , sys . stdout ) [EOL] except KeyboardInterrupt : [EOL] return [number] [comment] [EOL] [EOL] [EOL] class CachedTokenizer ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . last_text = None [EOL] self . last_tokens = None [EOL] [EOL] def generate_tokens ( self , text ) : [EOL] [docstring] [EOL] if text != self . last_text : [EOL] string_io = io . StringIO ( text ) [EOL] self . last_tokens = list ( tokenize . generate_tokens ( string_io . readline ) ) [EOL] self . last_text = text [EOL] return self . last_tokens [EOL] [EOL] [EOL] _cached_tokenizer = CachedTokenizer ( ) [EOL] generate_tokens = _cached_tokenizer . generate_tokens [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , List , Tuple , Pattern , Dict [EOL] import codecs [EOL] import typing [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __credits__ = [string] [EOL] [EOL] import string , re [EOL] from codecs import BOM_UTF8 , lookup [EOL] from lib2to3 . pgen2 . token import * [EOL] [EOL] from . import token [EOL] __all__ = [ x for x in dir ( token ) if x [ [number] ] != [string] ] + [ [string] , [string] , [string] ] [EOL] del token [EOL] [EOL] try : [EOL] bytes [EOL] except NameError : [EOL] [comment] [EOL] [comment] [EOL] bytes = str [EOL] [EOL] def group ( * choices ) : return [string] + [string] . join ( choices ) + [string] [EOL] def any ( * choices ) : return group ( * choices ) + [string] [EOL] def maybe ( * choices ) : return group ( * choices ) + [string] [EOL] [EOL] Whitespace = [string] [EOL] Comment = [string] [EOL] Ignore = Whitespace + any ( [string] + Whitespace ) + maybe ( Comment ) [EOL] Name = [string] [EOL] [EOL] Binnumber = [string] [EOL] Hexnumber = [string] [EOL] Octnumber = [string] [EOL] Decnumber = [string] [EOL] Intnumber = group ( Binnumber , Hexnumber , Octnumber , Decnumber ) [EOL] Exponent = [string] [EOL] Pointfloat = group ( [string] , [string] ) + maybe ( Exponent ) [EOL] Expfloat = [string] + Exponent [EOL] Floatnumber = group ( Pointfloat , Expfloat ) [EOL] Imagnumber = group ( [string] , Floatnumber + [string] ) [EOL] Number = group ( Imagnumber , Floatnumber , Intnumber ) [EOL] [EOL] [comment] [EOL] Single = [string] [EOL] [comment] [EOL] Double = [string] [EOL] [comment] [EOL] Single3 = [string] [EOL] [comment] [EOL] Double3 = [string] [EOL] Triple = group ( [string] , [string] ) [EOL] [comment] [EOL] String = group ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] Operator = group ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] Bracket = [string] [EOL] Special = group ( [string] , [string] ) [EOL] Funny = group ( Operator , Bracket , Special ) [EOL] [EOL] PlainToken = group ( Number , Funny , String , Name ) [EOL] Token = Ignore + PlainToken [EOL] [EOL] [comment] [EOL] ContStr = group ( [string] + group ( [string] , [string] ) , [string] + group ( [string] , [string] ) ) [EOL] PseudoExtras = group ( [string] , Comment , Triple ) [EOL] PseudoToken = Whitespace + group ( PseudoExtras , Number , Funny , ContStr , Name ) [EOL] [EOL] tokenprog , pseudoprog , single3prog , double3prog = list ( map ( re . compile , ( Token , PseudoToken , Single3 , Double3 ) ) ) [EOL] endprogs = { [string] : re . compile ( Single ) , [string] : re . compile ( Double ) , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None } [EOL] [EOL] triple_quoted = { } [EOL] for t in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] triple_quoted [ t ] = t [EOL] single_quoted = { } [EOL] for t in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] single_quoted [ t ] = t [EOL] [EOL] tabsize = [number] [EOL] [EOL] class TokenError ( Exception ) : pass [EOL] [EOL] class StopTokenizing ( Exception ) : pass [EOL] [EOL] def printtoken ( type , token , xxx_todo_changeme , xxx_todo_changeme1 , line ) : [comment] [EOL] ( srow , scol ) = xxx_todo_changeme [EOL] ( erow , ecol ) = xxx_todo_changeme1 [EOL] print ( [string] % ( srow , scol , erow , ecol , tok_name [ type ] , repr ( token ) ) ) [EOL] [EOL] def tokenize ( readline , tokeneater = printtoken ) : [EOL] [docstring] [EOL] try : [EOL] tokenize_loop ( readline , tokeneater ) [EOL] except StopTokenizing : [EOL] pass [EOL] [EOL] [comment] [EOL] def tokenize_loop ( readline , tokeneater ) : [EOL] for token_info in generate_tokens ( readline ) : [EOL] tokeneater ( * token_info ) [EOL] [EOL] class Untokenizer : [EOL] [EOL] def __init__ ( self ) : [EOL] self . tokens = [ ] [EOL] self . prev_row = [number] [EOL] self . prev_col = [number] [EOL] [EOL] def add_whitespace ( self , start ) : [EOL] row , col = start [EOL] assert row <= self . prev_row [EOL] col_offset = col - self . prev_col [EOL] if col_offset : [EOL] self . tokens . append ( [string] * col_offset ) [EOL] [EOL] def untokenize ( self , iterable ) : [EOL] for t in iterable : [EOL] if len ( t ) == [number] : [EOL] self . compat ( t , iterable ) [EOL] break [EOL] tok_type , token , start , end , line = t [EOL] self . add_whitespace ( start ) [EOL] self . tokens . append ( token ) [EOL] self . prev_row , self . prev_col = end [EOL] if tok_type in ( NEWLINE , NL ) : [EOL] self . prev_row += [number] [EOL] self . prev_col = [number] [EOL] return [string] . join ( self . tokens ) [EOL] [EOL] def compat ( self , token , iterable ) : [EOL] startline = False [EOL] indents = [ ] [EOL] toks_append = self . tokens . append [EOL] toknum , tokval = token [EOL] if toknum in ( NAME , NUMBER ) : [EOL] tokval += [string] [EOL] if toknum in ( NEWLINE , NL ) : [EOL] startline = True [EOL] for tok in iterable : [EOL] toknum , tokval = tok [ : [number] ] [EOL] [EOL] if toknum in ( NAME , NUMBER ) : [EOL] tokval += [string] [EOL] [EOL] if toknum == INDENT : [EOL] indents . append ( tokval ) [EOL] continue [EOL] elif toknum == DEDENT : [EOL] indents . pop ( ) [EOL] continue [EOL] elif toknum in ( NEWLINE , NL ) : [EOL] startline = True [EOL] elif startline and indents : [EOL] toks_append ( indents [ - [number] ] ) [EOL] startline = False [EOL] toks_append ( tokval ) [EOL] [EOL] cookie_re = re . compile ( [string] ) [EOL] [EOL] def _get_normal_name ( orig_enc ) : [EOL] [docstring] [EOL] [comment] [EOL] enc = orig_enc [ : [number] ] . lower ( ) . replace ( [string] , [string] ) [EOL] if enc == [string] or enc . startswith ( [string] ) : [EOL] return [string] [EOL] if enc in ( [string] , [string] , [string] ) or enc . startswith ( ( [string] , [string] , [string] ) ) : [EOL] return [string] [EOL] return orig_enc [EOL] [EOL] def detect_encoding ( readline ) : [EOL] [docstring] [EOL] bom_found = False [EOL] encoding = None [EOL] default = [string] [EOL] def read_or_stop ( ) : [EOL] try : [EOL] return readline ( ) [EOL] except StopIteration : [EOL] return bytes ( ) [EOL] [EOL] def find_cookie ( line ) : [EOL] try : [EOL] line_string = line . decode ( [string] ) [EOL] except UnicodeDecodeError : [EOL] return None [EOL] [EOL] matches = cookie_re . findall ( line_string ) [EOL] if not matches : [EOL] return None [EOL] encoding = _get_normal_name ( matches [ [number] ] ) [EOL] try : [EOL] codec = lookup ( encoding ) [EOL] except LookupError : [EOL] [comment] [EOL] raise SyntaxError ( [string] + encoding ) [EOL] [EOL] if bom_found : [EOL] if codec . name != [string] : [EOL] [comment] [EOL] raise SyntaxError ( [string] ) [EOL] encoding += [string] [EOL] return encoding [EOL] [EOL] first = read_or_stop ( ) [EOL] if first . startswith ( BOM_UTF8 ) : [EOL] bom_found = True [EOL] first = first [ [number] : ] [EOL] default = [string] [EOL] if not first : [EOL] return default , [ ] [EOL] [EOL] encoding = find_cookie ( first ) [EOL] if encoding : [EOL] return encoding , [ first ] [EOL] [EOL] second = read_or_stop ( ) [EOL] if not second : [EOL] return default , [ first ] [EOL] [EOL] encoding = find_cookie ( second ) [EOL] if encoding : [EOL] return encoding , [ first , second ] [EOL] [EOL] return default , [ first , second ] [EOL] [EOL] def untokenize ( iterable ) : [EOL] [docstring] [EOL] ut = Untokenizer ( ) [EOL] return ut . untokenize ( iterable ) [EOL] [EOL] def generate_tokens ( readline ) : [EOL] [docstring] [EOL] lnum = parenlev = continued = [number] [EOL] namechars , numchars = string . ascii_letters + [string] , [string] [EOL] contstr , needcont = [string] , [number] [EOL] contline = None [EOL] indents = [ [number] ] [EOL] [EOL] while [number] : [comment] [EOL] try : [EOL] line = readline ( ) [EOL] except StopIteration : [EOL] line = [string] [EOL] lnum = lnum + [number] [EOL] pos , max = [number] , len ( line ) [EOL] [EOL] if contstr : [comment] [EOL] if not line : [EOL] raise TokenError ( [string] , strstart ) [EOL] endmatch = endprog . match ( line ) [EOL] if endmatch : [EOL] pos = end = endmatch . end ( [number] ) [EOL] yield ( STRING , contstr + line [ : end ] , strstart , ( lnum , end ) , contline + line ) [EOL] contstr , needcont = [string] , [number] [EOL] contline = None [EOL] elif needcont and line [ - [number] : ] != [string] and line [ - [number] : ] != [string] : [EOL] yield ( ERRORTOKEN , contstr + line , strstart , ( lnum , len ( line ) ) , contline ) [EOL] contstr = [string] [EOL] contline = None [EOL] continue [EOL] else : [EOL] contstr = contstr + line [EOL] contline = contline + line [EOL] continue [EOL] [EOL] elif parenlev == [number] and not continued : [comment] [EOL] if not line : break [EOL] column = [number] [EOL] while pos < max : [comment] [EOL] if line [ pos ] == [string] : column = column + [number] [EOL] elif line [ pos ] == [string] : column = ( column // tabsize + [number] ) * tabsize [EOL] elif line [ pos ] == [string] : column = [number] [EOL] else : break [EOL] pos = pos + [number] [EOL] if pos == max : break [EOL] [EOL] if line [ pos ] in [string] : [comment] [EOL] if line [ pos ] == [string] : [EOL] comment_token = line [ pos : ] . rstrip ( [string] ) [EOL] nl_pos = pos + len ( comment_token ) [EOL] yield ( COMMENT , comment_token , ( lnum , pos ) , ( lnum , pos + len ( comment_token ) ) , line ) [EOL] yield ( NL , line [ nl_pos : ] , ( lnum , nl_pos ) , ( lnum , len ( line ) ) , line ) [EOL] else : [EOL] yield ( ( NL , COMMENT ) [ line [ pos ] == [string] ] , line [ pos : ] , ( lnum , pos ) , ( lnum , len ( line ) ) , line ) [EOL] continue [EOL] [EOL] if column > indents [ - [number] ] : [comment] [EOL] indents . append ( column ) [EOL] yield ( INDENT , line [ : pos ] , ( lnum , [number] ) , ( lnum , pos ) , line ) [EOL] while column < indents [ - [number] ] : [EOL] if column not in indents : [EOL] raise IndentationError ( [string] , ( [string] , lnum , pos , line ) ) [EOL] indents = indents [ : - [number] ] [EOL] yield ( DEDENT , [string] , ( lnum , pos ) , ( lnum , pos ) , line ) [EOL] [EOL] else : [comment] [EOL] if not line : [EOL] raise TokenError ( [string] , ( lnum , [number] ) ) [EOL] continued = [number] [EOL] [EOL] while pos < max : [EOL] pseudomatch = pseudoprog . match ( line , pos ) [EOL] if pseudomatch : [comment] [EOL] start , end = pseudomatch . span ( [number] ) [EOL] spos , epos , pos = ( lnum , start ) , ( lnum , end ) , end [EOL] token , initial = line [ start : end ] , line [ start ] [EOL] [EOL] if initial in numchars or ( initial == [string] and token != [string] ) : [comment] [EOL] yield ( NUMBER , token , spos , epos , line ) [EOL] elif initial in [string] : [EOL] newline = NEWLINE [EOL] if parenlev > [number] : [EOL] newline = NL [EOL] yield ( newline , token , spos , epos , line ) [EOL] elif initial == [string] : [EOL] assert not token . endswith ( [string] ) [EOL] yield ( COMMENT , token , spos , epos , line ) [EOL] elif token in triple_quoted : [EOL] endprog = endprogs [ token ] [EOL] endmatch = endprog . match ( line , pos ) [EOL] if endmatch : [comment] [EOL] pos = endmatch . end ( [number] ) [EOL] token = line [ start : pos ] [EOL] yield ( STRING , token , spos , ( lnum , pos ) , line ) [EOL] else : [EOL] strstart = ( lnum , start ) [comment] [EOL] contstr = line [ start : ] [EOL] contline = line [EOL] break [EOL] elif initial in single_quoted or token [ : [number] ] in single_quoted or token [ : [number] ] in single_quoted : [EOL] if token [ - [number] ] == [string] : [comment] [EOL] strstart = ( lnum , start ) [EOL] endprog = ( endprogs [ initial ] or endprogs [ token [ [number] ] ] or endprogs [ token [ [number] ] ] ) [EOL] contstr , needcont = line [ start : ] , [number] [EOL] contline = line [EOL] break [EOL] else : [comment] [EOL] yield ( STRING , token , spos , epos , line ) [EOL] elif initial in namechars : [comment] [EOL] yield ( NAME , token , spos , epos , line ) [EOL] elif initial == [string] : [comment] [EOL] [comment] [EOL] yield ( NL , token , spos , ( lnum , pos ) , line ) [EOL] continued = [number] [EOL] else : [EOL] if initial in [string] : parenlev = parenlev + [number] [EOL] elif initial in [string] : parenlev = parenlev - [number] [EOL] yield ( OP , token , spos , epos , line ) [EOL] else : [EOL] yield ( ERRORTOKEN , line [ pos ] , ( lnum , pos ) , ( lnum , pos + [number] ) , line ) [EOL] pos = pos + [number] [EOL] [EOL] for indent in indents [ [number] : ] : [comment] [EOL] yield ( DEDENT , [string] , ( lnum , [number] ) , ( lnum , [number] ) , [string] ) [EOL] yield ( ENDMARKER , [string] , ( lnum , [number] ) , ( lnum , [number] ) , [string] ) [EOL] [EOL] if __name__ == [string] : [comment] [EOL] import sys [EOL] if len ( sys . argv ) > [number] : tokenize ( open ( sys . argv [ [number] ] ) . readline ) [EOL] else : tokenize ( sys . stdin . readline ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] simple_escapes = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] def escape ( m ) : [EOL] all , tail = m . group ( [number] , [number] ) [EOL] assert all . startswith ( [string] ) [EOL] esc = simple_escapes . get ( tail ) [EOL] if esc is not None : [EOL] return esc [EOL] if tail . startswith ( [string] ) : [EOL] hexes = tail [ [number] : ] [EOL] if len ( hexes ) < [number] : [EOL] raise ValueError ( [string] % tail ) [EOL] try : [EOL] i = int ( hexes , [number] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % tail ) [EOL] else : [EOL] try : [EOL] i = int ( tail , [number] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % tail ) [EOL] return chr ( i ) [EOL] [EOL] def evalString ( s ) : [EOL] assert s . startswith ( [string] ) or s . startswith ( [string] ) , repr ( s [ : [number] ] ) [EOL] q = s [ [number] ] [EOL] if s [ : [number] ] == q * [number] : [EOL] q = q * [number] [EOL] assert s . endswith ( q ) , repr ( s [ - len ( q ) : ] ) [EOL] assert len ( s ) >= [number] * len ( q ) [EOL] s = s [ len ( q ) : - len ( q ) ] [EOL] return re . sub ( [string] , escape , s ) [EOL] [EOL] def test ( ) : [EOL] for i in range ( [number] ) : [EOL] c = chr ( i ) [EOL] s = repr ( c ) [EOL] e = evalString ( s ) [EOL] if e != c : [EOL] print ( i , c , s , e ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Tuple , Any [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import pickle [EOL] [EOL] [comment] [EOL] from . import token , tokenize [EOL] [EOL] [EOL] class Grammar ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] self . states = [ ] [EOL] self . dfas = { } [EOL] self . labels = [ ( [number] , [string] ) ] [EOL] self . keywords = { } [EOL] self . tokens = { } [EOL] self . symbol2label = { } [EOL] self . start = [number] [EOL] [EOL] def dump ( self , filename ) : [EOL] [docstring] [EOL] f = open ( filename , [string] ) [EOL] pickle . dump ( self . __dict__ , f , [number] ) [EOL] f . close ( ) [EOL] [EOL] def load ( self , filename ) : [EOL] [docstring] [EOL] f = open ( filename , [string] ) [EOL] d = pickle . load ( f ) [EOL] f . close ( ) [EOL] self . __dict__ . update ( d ) [EOL] [EOL] def copy ( self ) : [EOL] [docstring] [EOL] new = self . __class__ ( ) [EOL] for dict_attr in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] setattr ( new , dict_attr , getattr ( self , dict_attr ) . copy ( ) ) [EOL] new . labels = self . labels [ : ] [EOL] new . states = self . states [ : ] [EOL] new . start = self . start [EOL] return new [EOL] [EOL] def report ( self ) : [EOL] [docstring] [EOL] from pprint import pprint [EOL] print ( [string] ) [EOL] pprint ( self . symbol2number ) [EOL] print ( [string] ) [EOL] pprint ( self . number2symbol ) [EOL] print ( [string] ) [EOL] pprint ( self . states ) [EOL] print ( [string] ) [EOL] pprint ( self . dfas ) [EOL] print ( [string] ) [EOL] pprint ( self . labels ) [EOL] print ( [string] , self . start ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] opmap_raw = [string] [EOL] [EOL] opmap = { } [EOL] for line in opmap_raw . splitlines ( ) : [EOL] if line : [EOL] op , name = line . split ( ) [EOL] opmap [ op ] = getattr ( token , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedReader$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BufferedReader$ 0 0 $io.BufferedReader$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] ENDMARKER = [number] [EOL] NAME = [number] [EOL] NUMBER = [number] [EOL] STRING = [number] [EOL] NEWLINE = [number] [EOL] INDENT = [number] [EOL] DEDENT = [number] [EOL] LPAR = [number] [EOL] RPAR = [number] [EOL] LSQB = [number] [EOL] RSQB = [number] [EOL] COLON = [number] [EOL] COMMA = [number] [EOL] SEMI = [number] [EOL] PLUS = [number] [EOL] MINUS = [number] [EOL] STAR = [number] [EOL] SLASH = [number] [EOL] VBAR = [number] [EOL] AMPER = [number] [EOL] LESS = [number] [EOL] GREATER = [number] [EOL] EQUAL = [number] [EOL] DOT = [number] [EOL] PERCENT = [number] [EOL] BACKQUOTE = [number] [EOL] LBRACE = [number] [EOL] RBRACE = [number] [EOL] EQEQUAL = [number] [EOL] NOTEQUAL = [number] [EOL] LESSEQUAL = [number] [EOL] GREATEREQUAL = [number] [EOL] TILDE = [number] [EOL] CIRCUMFLEX = [number] [EOL] LEFTSHIFT = [number] [EOL] RIGHTSHIFT = [number] [EOL] DOUBLESTAR = [number] [EOL] PLUSEQUAL = [number] [EOL] MINEQUAL = [number] [EOL] STAREQUAL = [number] [EOL] SLASHEQUAL = [number] [EOL] PERCENTEQUAL = [number] [EOL] AMPEREQUAL = [number] [EOL] VBAREQUAL = [number] [EOL] CIRCUMFLEXEQUAL = [number] [EOL] LEFTSHIFTEQUAL = [number] [EOL] RIGHTSHIFTEQUAL = [number] [EOL] DOUBLESTAREQUAL = [number] [EOL] DOUBLESLASH = [number] [EOL] DOUBLESLASHEQUAL = [number] [EOL] AT = [number] [EOL] OP = [number] [EOL] COMMENT = [number] [EOL] NL = [number] [EOL] RARROW = [number] [EOL] ERRORTOKEN = [number] [EOL] N_TOKENS = [number] [EOL] NT_OFFSET = [number] [EOL] [comment] [EOL] [EOL] tok_name = { } [EOL] for _name , _value in list ( globals ( ) . items ( ) ) : [EOL] if type ( _value ) is type ( [number] ) : [EOL] tok_name [ _value ] = _name [EOL] [EOL] [EOL] def ISTERMINAL ( x ) : [EOL] return x < NT_OFFSET [EOL] [EOL] def ISNONTERMINAL ( x ) : [EOL] return x >= NT_OFFSET [EOL] [EOL] def ISEOF ( x ) : [EOL] return x == ENDMARKER [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , List , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . import token [EOL] [EOL] class ParseError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg , type , value , context ) : [EOL] Exception . __init__ ( self , [string] % ( msg , type , value , context ) ) [EOL] self . msg = msg [EOL] self . type = type [EOL] self . value = value [EOL] self . context = context [EOL] [EOL] class Parser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , grammar , convert = None ) : [EOL] [docstring] [EOL] self . grammar = grammar [EOL] self . convert = convert or ( lambda grammar , node : node ) [EOL] [EOL] def setup ( self , start = None ) : [EOL] [docstring] [EOL] if start is None : [EOL] start = self . grammar . start [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] newnode = ( start , None , None , [ ] ) [EOL] stackentry = ( self . grammar . dfas [ start ] , [number] , newnode ) [EOL] self . stack = [ stackentry ] [EOL] self . rootnode = None [EOL] self . used_names = set ( ) [comment] [EOL] [EOL] def addtoken ( self , type , value , context ) : [EOL] [docstring] [EOL] [comment] [EOL] ilabel = self . classify ( type , value , context ) [EOL] [comment] [EOL] while True : [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] arcs = states [ state ] [EOL] [comment] [EOL] for i , newstate in arcs : [EOL] t , v = self . grammar . labels [ i ] [EOL] if ilabel == i : [EOL] [comment] [EOL] assert t < [number] [EOL] [comment] [EOL] self . shift ( type , value , newstate , context ) [EOL] [comment] [EOL] state = newstate [EOL] while states [ state ] == [ ( [number] , state ) ] : [EOL] self . pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] return True [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] [comment] [EOL] return False [EOL] elif t >= [number] : [EOL] [comment] [EOL] itsdfa = self . grammar . dfas [ t ] [EOL] itsstates , itsfirst = itsdfa [EOL] if ilabel in itsfirst : [EOL] [comment] [EOL] self . push ( t , self . grammar . dfas [ t ] , newstate , context ) [EOL] break [comment] [EOL] else : [EOL] if ( [number] , state ) in arcs : [EOL] [comment] [EOL] self . pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] raise ParseError ( [string] , type , value , context ) [EOL] else : [EOL] [comment] [EOL] raise ParseError ( [string] , type , value , context ) [EOL] [EOL] def classify ( self , type , value , context ) : [EOL] [docstring] [EOL] if type == token . NAME : [EOL] [comment] [EOL] self . used_names . add ( value ) [EOL] [comment] [EOL] ilabel = self . grammar . keywords . get ( value ) [EOL] if ilabel is not None : [EOL] return ilabel [EOL] ilabel = self . grammar . tokens . get ( type ) [EOL] if ilabel is None : [EOL] raise ParseError ( [string] , type , value , context ) [EOL] return ilabel [EOL] [EOL] def shift ( self , type , value , newstate , context ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = ( type , value , context , None ) [EOL] newnode = self . convert ( self . grammar , newnode ) [EOL] if newnode is not None : [EOL] node [ - [number] ] . append ( newnode ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] [EOL] def push ( self , type , newdfa , newstate , context ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = ( type , None , context , [ ] ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] self . stack . append ( ( newdfa , [number] , newnode ) ) [EOL] [EOL] def pop ( self ) : [EOL] [docstring] [EOL] popdfa , popstate , popnode = self . stack . pop ( ) [EOL] newnode = self . convert ( self . grammar , popnode ) [EOL] if newnode is not None : [EOL] if self . stack : [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] node [ - [number] ] . append ( newnode ) [EOL] else : [EOL] self . rootnode = newnode [EOL] self . rootnode . used_names = self . used_names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,None,None,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[unknown,None,None,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,None,None,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[unknown,None,None,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,None,typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,None,typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Dict , Optional , Any [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import re [EOL] [EOL] [comment] [EOL] from pgen2 import grammar , token [EOL] [EOL] [EOL] class Converter ( grammar . Grammar ) : [EOL] [docstring] [EOL] [EOL] def run ( self , graminit_h , graminit_c ) : [EOL] [docstring] [EOL] self . parse_graminit_h ( graminit_h ) [EOL] self . parse_graminit_c ( graminit_c ) [EOL] self . finish_off ( ) [EOL] [EOL] def parse_graminit_h ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] f = open ( filename ) [EOL] except IOError as err : [EOL] print ( [string] % ( filename , err ) ) [EOL] return False [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] lineno = [number] [EOL] for line in f : [EOL] lineno += [number] [EOL] mo = re . match ( [string] , line ) [EOL] if not mo and line . strip ( ) : [EOL] print ( [string] % ( filename , lineno , line . strip ( ) ) ) [EOL] else : [EOL] symbol , number = mo . groups ( ) [EOL] number = int ( number ) [EOL] assert symbol not in self . symbol2number [EOL] assert number not in self . number2symbol [EOL] self . symbol2number [ symbol ] = number [EOL] self . number2symbol [ number ] = symbol [EOL] return True [EOL] [EOL] def parse_graminit_c ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] f = open ( filename ) [EOL] except IOError as err : [EOL] print ( [string] % ( filename , err ) ) [EOL] return False [EOL] [comment] [EOL] lineno = [number] [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] allarcs = { } [EOL] states = [ ] [EOL] while line . startswith ( [string] ) : [EOL] while line . startswith ( [string] ) : [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] n , m , k = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs = [ ] [EOL] for _ in range ( k ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] i , j = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs . append ( ( i , j ) ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] allarcs [ ( n , m ) ] = arcs [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] s , t = list ( map ( int , mo . groups ( ) ) ) [EOL] assert s == len ( states ) , ( lineno , line ) [EOL] state = [ ] [EOL] for _ in range ( t ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] k , n , m = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs = allarcs [ n , m ] [EOL] assert k == len ( arcs ) , ( lineno , line ) [EOL] state . append ( arcs ) [EOL] states . append ( state ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] self . states = states [EOL] [EOL] [comment] [EOL] dfas = { } [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] ndfas = int ( mo . group ( [number] ) ) [EOL] for i in range ( ndfas ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] symbol = mo . group ( [number] ) [EOL] number , x , y , z = list ( map ( int , mo . group ( [number] , [number] , [number] , [number] ) ) ) [EOL] assert self . symbol2number [ symbol ] == number , ( lineno , line ) [EOL] assert self . number2symbol [ number ] == symbol , ( lineno , line ) [EOL] assert x == [number] , ( lineno , line ) [EOL] state = states [ z ] [EOL] assert y == len ( state ) , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] first = { } [EOL] rawbitset = eval ( mo . group ( [number] ) ) [EOL] for i , c in enumerate ( rawbitset ) : [EOL] byte = ord ( c ) [EOL] for j in range ( [number] ) : [EOL] if byte & ( [number] << j ) : [EOL] first [ i * [number] + j ] = [number] [EOL] dfas [ number ] = ( state , first ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] self . dfas = dfas [EOL] [EOL] [comment] [EOL] labels = [ ] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] nlabels = int ( mo . group ( [number] ) ) [EOL] for i in range ( nlabels ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] x , y = mo . groups ( ) [EOL] x = int ( x ) [EOL] if y == [string] : [EOL] y = None [EOL] else : [EOL] y = eval ( y ) [EOL] labels . append ( ( x , y ) ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] self . labels = labels [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] ndfas = int ( mo . group ( [number] ) ) [EOL] assert ndfas == len ( self . dfas ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] nlabels = int ( mo . group ( [number] ) ) [EOL] assert nlabels == len ( self . labels ) , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] start = int ( mo . group ( [number] ) ) [EOL] assert start in self . number2symbol , ( lineno , line ) [EOL] self . start = start [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] try : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] except StopIteration : [EOL] pass [EOL] else : [EOL] assert [number] , ( lineno , line ) [EOL] [EOL] def finish_off ( self ) : [EOL] [docstring] [EOL] self . keywords = { } [comment] [EOL] self . tokens = { } [comment] [EOL] for ilabel , ( type , value ) in enumerate ( self . labels ) : [EOL] if type == token . NAME and value is not None : [EOL] self . keywords [ value ] = ilabel [EOL] elif value is None : [EOL] self . tokens [ type ] = ilabel [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __version__ = [string] [EOL] [EOL] from jedi . api import Script , Interpreter , NotFoundError , set_debug_function [EOL] from jedi . api import preload_module , defined_names , names [EOL] from jedi import settings [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Optional , Any , Callable [EOL] import _importlib_modulespec [EOL] import typing [EOL] import inspect [EOL] from jedi . _compatibility import encoding , is_py3 , u [EOL] import inspect [EOL] import os [EOL] import time [EOL] [EOL] def _lazy_colorama_init ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] _inited = False [EOL] [EOL] try : [EOL] if os . name == [string] : [EOL] [comment] [EOL] raise ImportError [EOL] else : [EOL] [comment] [EOL] from colorama import Fore , init [EOL] from colorama import initialise [EOL] def _lazy_colorama_init ( ) : [EOL] [docstring] [EOL] global _inited [EOL] if not _inited : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] initialise . atexit_done = True [EOL] try : [EOL] init ( ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] _inited = True [EOL] [EOL] except ImportError : [EOL] class Fore ( object ) : [EOL] RED = [string] [EOL] GREEN = [string] [EOL] YELLOW = [string] [EOL] MAGENTA = [string] [EOL] RESET = [string] [EOL] [EOL] NOTICE = object ( ) [EOL] WARNING = object ( ) [EOL] SPEED = object ( ) [EOL] [EOL] enable_speed = False [EOL] enable_warning = False [EOL] enable_notice = False [EOL] [EOL] [comment] [EOL] debug_function = None [EOL] ignored_modules = [ [string] ] [EOL] _debug_indent = [number] [EOL] _start_time = time . time ( ) [EOL] [EOL] [EOL] def reset_time ( ) : [EOL] global _start_time , _debug_indent [EOL] _start_time = time . time ( ) [EOL] _debug_indent = [number] [EOL] [EOL] [EOL] def increase_indent ( func ) : [EOL] [docstring] [EOL] def wrapper ( * args , ** kwargs ) : [EOL] global _debug_indent [EOL] _debug_indent += [number] [EOL] try : [EOL] return func ( * args , ** kwargs ) [EOL] finally : [EOL] _debug_indent -= [number] [EOL] return wrapper [EOL] [EOL] [EOL] def dbg ( message , * args , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] color = kwargs . pop ( [string] , [string] ) [EOL] assert color [EOL] [EOL] if debug_function and enable_notice : [EOL] frm = inspect . stack ( ) [ [number] ] [EOL] mod = inspect . getmodule ( frm [ [number] ] ) [EOL] if not ( mod . __name__ in ignored_modules ) : [EOL] i = [string] * _debug_indent [EOL] _lazy_colorama_init ( ) [EOL] debug_function ( color , i + [string] + message % tuple ( u ( repr ( a ) ) for a in args ) ) [EOL] [EOL] [EOL] def warning ( message , * args , ** kwargs ) : [EOL] format = kwargs . pop ( [string] , True ) [EOL] assert not kwargs [EOL] [EOL] if debug_function and enable_warning : [EOL] i = [string] * _debug_indent [EOL] if format : [EOL] message = message % tuple ( u ( repr ( a ) ) for a in args ) [EOL] debug_function ( [string] , i + [string] + message ) [EOL] [EOL] [EOL] def speed ( name ) : [EOL] if debug_function and enable_speed : [EOL] now = time . time ( ) [EOL] i = [string] * _debug_indent [EOL] debug_function ( [string] , i + [string] + [string] % ( name , now - _start_time ) ) [EOL] [EOL] [EOL] def print_to_stdout ( color , str_out ) : [EOL] [docstring] [EOL] col = getattr ( Fore , color ) [EOL] _lazy_colorama_init ( ) [EOL] if not is_py3 : [EOL] str_out = str_out . encode ( encoding , [string] ) [EOL] print ( col + str_out + Fore . RESET ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] import inspect [EOL] [EOL] from jedi import settings [EOL] from jedi . parser . cache import parser_cache [EOL] [EOL] _time_caches = { } [EOL] [EOL] [EOL] def underscore_memoization ( func ) : [EOL] [docstring] [EOL] name = [string] + func . __name__ [EOL] [EOL] def wrapper ( self ) : [EOL] try : [EOL] return getattr ( self , name ) [EOL] except AttributeError : [EOL] result = func ( self ) [EOL] if inspect . isgenerator ( result ) : [EOL] result = list ( result ) [EOL] setattr ( self , name , result ) [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def clear_time_caches ( delete_all = False ) : [EOL] [docstring] [EOL] global _time_caches [EOL] [EOL] if delete_all : [EOL] for cache in _time_caches . values ( ) : [EOL] cache . clear ( ) [EOL] parser_cache . clear ( ) [EOL] else : [EOL] [comment] [EOL] for tc in _time_caches . values ( ) : [EOL] [comment] [EOL] for key , ( t , value ) in list ( tc . items ( ) ) : [EOL] if t < time . time ( ) : [EOL] [comment] [EOL] del tc [ key ] [EOL] [EOL] [EOL] def time_cache ( time_add_setting ) : [EOL] [docstring] [EOL] def _temp ( key_func ) : [EOL] dct = { } [EOL] _time_caches [ time_add_setting ] = dct [EOL] [EOL] def wrapper ( * args , ** kwargs ) : [EOL] generator = key_func ( * args , ** kwargs ) [EOL] key = next ( generator ) [EOL] try : [EOL] expiry , value = dct [ key ] [EOL] if expiry > time . time ( ) : [EOL] return value [EOL] except KeyError : [EOL] pass [EOL] [EOL] value = next ( generator ) [EOL] time_add = getattr ( settings , time_add_setting ) [EOL] if key is not None : [EOL] dct [ key ] = time . time ( ) + time_add , value [EOL] return value [EOL] return wrapper [EOL] return _temp [EOL] [EOL] [EOL] def memoize_method ( method ) : [EOL] [docstring] [EOL] def wrapper ( self , * args , ** kwargs ) : [EOL] cache_dict = self . __dict__ . setdefault ( [string] , { } ) [EOL] dct = cache_dict . setdefault ( method , { } ) [EOL] key = ( args , frozenset ( kwargs . items ( ) ) ) [EOL] try : [EOL] return dct [ key ] [EOL] except KeyError : [EOL] result = method ( self , * args , ** kwargs ) [EOL] dct [ key ] = result [EOL] return result [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import platform [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] case_insensitive_completion = True [EOL] [docstring] [EOL] [EOL] add_bracket_after_function = False [EOL] [docstring] [EOL] [EOL] no_completion_duplicates = True [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] use_filesystem_cache = True [EOL] [docstring] [EOL] [EOL] if platform . system ( ) . lower ( ) == [string] : [EOL] _cache_directory = os . path . join ( os . getenv ( [string] ) or [string] , [string] , [string] ) [EOL] elif platform . system ( ) . lower ( ) == [string] : [EOL] _cache_directory = os . path . join ( [string] , [string] , [string] , [string] ) [EOL] else : [EOL] _cache_directory = os . path . join ( os . getenv ( [string] ) or [string] , [string] ) [EOL] cache_directory = os . path . expanduser ( _cache_directory ) [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] fast_parser = True [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] dynamic_array_additions = True [EOL] [docstring] [EOL] [EOL] dynamic_params = True [EOL] [docstring] [EOL] [EOL] dynamic_params_for_other_modules = True [EOL] [docstring] [EOL] [EOL] additional_dynamic_modules = [ ] [EOL] [docstring] [EOL] [EOL] dynamic_flow_information = True [EOL] [docstring] [EOL] [EOL] auto_import_modules = [ [string] , ] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] max_until_execution_unique = [number] [EOL] [docstring] [EOL] [EOL] max_function_recursion_level = [number] [EOL] [docstring] [EOL] [EOL] max_executions_without_builtins = [number] [EOL] [docstring] [EOL] [EOL] max_executions = [number] [EOL] [docstring] [EOL] [EOL] scale_call_signatures = [number] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] call_signatures_validity = [number] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0
import builtins [EOL] from typing import Literal , Any , List , Tuple , Set [EOL] import typing_extensions [EOL] import typing [EOL] import textwrap [EOL] from inspect import cleandoc [EOL] [EOL] from jedi . _compatibility import literal_eval , is_py3 [EOL] from jedi . parser . python import tree [EOL] [EOL] _EXECUTE_NODES = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] _FLOW_KEYWORDS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def get_executable_nodes ( node , last_added = False ) : [EOL] [docstring] [EOL] result = [ ] [EOL] typ = node . type [EOL] if typ == [string] : [EOL] next_leaf = node . get_next_leaf ( ) [EOL] if last_added is False and node . parent . type != [string] and next_leaf != [string] : [EOL] result . append ( node ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] [comment] [EOL] result . append ( node ) [EOL] for child in node . children : [EOL] result += get_executable_nodes ( child , last_added = True ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] if node . children [ - [number] ] == [string] : [EOL] node = node . children [ - [number] ] [EOL] if node != [string] : [EOL] result += get_executable_nodes ( node ) [EOL] else : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] if node . type in _EXECUTE_NODES and not last_added : [EOL] result . append ( node ) [EOL] [EOL] for child in children : [EOL] result += get_executable_nodes ( child , last_added ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def get_comp_fors ( comp_for ) : [EOL] yield comp_for [EOL] last = comp_for . children [ - [number] ] [EOL] while True : [EOL] if last . type == [string] : [EOL] yield last [EOL] elif not last . type == [string] : [EOL] break [EOL] last = last . children [ - [number] ] [EOL] [EOL] [EOL] def for_stmt_defines_one_name ( for_stmt ) : [EOL] [docstring] [EOL] return for_stmt . children [ [number] ] . type == [string] [EOL] [EOL] [EOL] def get_flow_branch_keyword ( flow_node , node ) : [EOL] start_pos = node . start_pos [EOL] if not ( flow_node . start_pos < start_pos <= flow_node . end_pos ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] keyword = None [EOL] for i , child in enumerate ( flow_node . children ) : [EOL] if start_pos < child . start_pos : [EOL] return keyword [EOL] first_leaf = child . get_first_leaf ( ) [EOL] if first_leaf in _FLOW_KEYWORDS : [EOL] keyword = first_leaf [EOL] return [number] [EOL] [EOL] def get_statement_of_position ( node , pos ) : [EOL] for c in node . children : [EOL] if c . start_pos <= pos <= c . end_pos : [EOL] if c . type not in ( [string] , [string] , [string] ) \ [EOL] and not isinstance ( c , ( tree . Flow , tree . ClassOrFunc ) ) : [EOL] return c [EOL] else : [EOL] try : [EOL] return get_statement_of_position ( c , pos ) [EOL] except AttributeError : [EOL] pass [comment] [EOL] return None [EOL] [EOL] [EOL] def clean_scope_docstring ( scope_node ) : [EOL] [docstring] [EOL] node = scope_node . get_doc_node ( ) [EOL] if node is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cleaned = cleandoc ( safe_literal_eval ( node . value ) ) [EOL] [comment] [EOL] [comment] [EOL] if is_py3 or isinstance ( cleaned , unicode ) : [EOL] return cleaned [EOL] else : [EOL] return unicode ( cleaned , [string] , [string] ) [EOL] return [string] [EOL] [EOL] [EOL] def safe_literal_eval ( value ) : [EOL] first_two = value [ : [number] ] . lower ( ) [EOL] if first_two [ [number] ] == [string] or first_two in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] [EOL] try : [EOL] return literal_eval ( value ) [EOL] except SyntaxError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] [EOL] [EOL] def get_call_signature ( funcdef , width = [number] , call_string = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if call_string is None : [EOL] if funcdef . type == [string] : [EOL] call_string = [string] [EOL] else : [EOL] call_string = funcdef . name . value [EOL] if funcdef . type == [string] : [EOL] p = [string] + [string] . join ( param . get_code ( ) for param in funcdef . params ) . strip ( ) + [string] [EOL] else : [EOL] p = funcdef . children [ [number] ] . get_code ( ) [EOL] code = call_string + p [EOL] [EOL] return [string] . join ( textwrap . wrap ( code , width ) ) [EOL] [EOL] [EOL] def get_doc_with_call_signature ( scope_node ) : [EOL] [docstring] [EOL] call_signature = None [EOL] if scope_node . type == [string] : [EOL] for funcdef in scope_node . iter_funcdefs ( ) : [EOL] if funcdef . name . value == [string] : [EOL] call_signature = get_call_signature ( funcdef , call_string = scope_node . name . value ) [EOL] elif scope_node . type in ( [string] , [string] ) : [EOL] call_signature = get_call_signature ( scope_node ) [EOL] [EOL] doc = clean_scope_docstring ( scope_node ) [EOL] if call_signature is None : [EOL] return doc [EOL] return [string] % ( call_signature , doc ) [EOL] [EOL] [EOL] def move ( node , line_offset ) : [EOL] [docstring] [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] node . line += line_offset [EOL] else : [EOL] for c in children : [EOL] move ( c , line_offset ) [EOL] [EOL] [EOL] def get_following_comment_same_line ( node ) : [EOL] [docstring] [EOL] try : [EOL] if node . type == [string] : [EOL] whitespace = node . children [ [number] ] . get_first_leaf ( ) . prefix [EOL] elif node . type == [string] : [EOL] whitespace = node . children [ [number] ] . get_first_leaf ( ) . prefix [EOL] else : [EOL] whitespace = node . get_last_leaf ( ) . get_next_leaf ( ) . prefix [EOL] except AttributeError : [EOL] return None [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] if [string] not in whitespace : [EOL] return None [EOL] comment = whitespace [ whitespace . index ( [string] ) : ] [EOL] if [string] in comment : [EOL] comment = comment [ : comment . index ( [string] ) ] [EOL] if [string] in comment : [EOL] comment = comment [ : comment . index ( [string] ) ] [EOL] return comment [EOL] [EOL] [EOL] def is_scope ( node ) : [EOL] return node . type in ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def get_parent_scope ( node , include_flows = False ) : [EOL] [docstring] [EOL] scope = node . parent [EOL] while scope is not None : [EOL] if include_flows and isinstance ( scope , tree . Flow ) : [EOL] return scope [EOL] if is_scope ( scope ) : [EOL] break [EOL] scope = scope . parent [EOL] return scope [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import sys [EOL] from os . path import join , dirname , abspath , isdir [EOL] [EOL] [EOL] def _start_linter ( ) : [EOL] [docstring] [EOL] import jedi [EOL] [EOL] if [string] in sys . argv : [EOL] jedi . set_debug_function ( ) [EOL] [EOL] for path in sys . argv [ [number] : ] : [EOL] if path . startswith ( [string] ) : [EOL] continue [EOL] if isdir ( path ) : [EOL] import fnmatch [EOL] import os [EOL] [EOL] paths = [ ] [EOL] for root , dirnames , filenames in os . walk ( path ) : [EOL] for filename in fnmatch . filter ( filenames , [string] ) : [EOL] paths . append ( os . path . join ( root , filename ) ) [EOL] else : [EOL] paths = [ path ] [EOL] [EOL] try : [EOL] for path in paths : [EOL] for error in jedi . Script ( path = path ) . _analysis ( ) : [EOL] print ( error ) [EOL] except Exception : [EOL] if [string] in sys . argv : [EOL] import traceback [EOL] traceback . print_exc ( ) [EOL] import pdb [EOL] pdb . post_mortem ( ) [EOL] else : [EOL] raise [EOL] [EOL] [EOL] if len ( sys . argv ) == [number] and sys . argv [ [number] ] == [string] : [EOL] [comment] [EOL] [comment] [EOL] print ( join ( dirname ( abspath ( __file__ ) ) , [string] , [string] ) ) [EOL] elif len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] _start_linter ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Union , Type , Match , List , Tuple [EOL] import typing [EOL] import types [EOL] [docstring] [EOL] import sys [EOL] import contextlib [EOL] import functools [EOL] import re [EOL] from ast import literal_eval [EOL] [EOL] from jedi . _compatibility import unicode , reraise [EOL] from jedi import settings [EOL] [EOL] [EOL] class UncaughtAttributeError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def safe_property ( func ) : [EOL] return property ( reraise_uncaught ( func ) ) [EOL] [EOL] [EOL] def reraise_uncaught ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwds ) : [EOL] try : [EOL] return func ( * args , ** kwds ) [EOL] except AttributeError : [EOL] exc_info = sys . exc_info ( ) [EOL] reraise ( UncaughtAttributeError ( exc_info [ [number] ] ) , exc_info [ [number] ] ) [EOL] return wrapper [EOL] [EOL] [EOL] class PushBackIterator ( object ) : [EOL] def __init__ ( self , iterator ) : [EOL] self . pushes = [ ] [EOL] self . iterator = iterator [EOL] self . current = None [EOL] [EOL] def push_back ( self , value ) : [EOL] self . pushes . append ( value ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def next ( self ) : [EOL] [docstring] [EOL] return self . __next__ ( ) [EOL] [EOL] def __next__ ( self ) : [EOL] if self . pushes : [EOL] self . current = self . pushes . pop ( ) [EOL] else : [EOL] self . current = next ( self . iterator ) [EOL] return self . current [EOL] [EOL] [EOL] @ contextlib . contextmanager def scale_speed_settings ( factor ) : [EOL] a = settings . max_executions [EOL] b = settings . max_until_execution_unique [EOL] settings . max_executions *= factor [EOL] settings . max_until_execution_unique *= factor [EOL] try : [EOL] yield [EOL] finally : [EOL] settings . max_executions = a [EOL] settings . max_until_execution_unique = b [EOL] [EOL] [EOL] def indent_block ( text , indention = [string] ) : [EOL] [docstring] [EOL] temp = [string] [EOL] while text and text [ - [number] ] == [string] : [EOL] temp += text [ - [number] ] [EOL] text = text [ : - [number] ] [EOL] lines = text . split ( [string] ) [EOL] return [string] . join ( map ( lambda s : indention + s , lines ) ) + temp [EOL] [EOL] [EOL] @ contextlib . contextmanager def ignored ( * exceptions ) : [EOL] [docstring] [EOL] try : [EOL] yield [EOL] except exceptions : [EOL] pass [EOL] [EOL] [EOL] def source_to_unicode ( source , encoding = None ) : [EOL] def detect_encoding ( ) : [EOL] [docstring] [EOL] byte_mark = literal_eval ( [string] ) [EOL] if source . startswith ( byte_mark ) : [EOL] [comment] [EOL] return [string] [EOL] [EOL] first_two_lines = re . match ( [string] , source ) . group ( [number] ) [EOL] possible_encoding = re . search ( [string] , first_two_lines ) [EOL] if possible_encoding : [EOL] return possible_encoding . group ( [number] ) [EOL] else : [EOL] [comment] [EOL] return encoding if encoding is not None else [string] [EOL] [EOL] if isinstance ( source , unicode ) : [EOL] [comment] [EOL] return source [EOL] [EOL] encoding = detect_encoding ( ) [EOL] if not isinstance ( encoding , unicode ) : [EOL] encoding = unicode ( encoding , [string] , [string] ) [EOL] [comment] [EOL] return unicode ( source , encoding , [string] ) [EOL] [EOL] [EOL] def splitlines ( string , keepends = False ) : [EOL] [docstring] [EOL] if keepends : [EOL] lst = string . splitlines ( True ) [EOL] [EOL] [comment] [EOL] merge = [ ] [EOL] for i , line in enumerate ( lst ) : [EOL] if line . endswith ( [string] ) : [EOL] merge . append ( i ) [EOL] [EOL] for index in reversed ( merge ) : [EOL] try : [EOL] lst [ index ] = lst [ index ] + lst [ index + [number] ] [EOL] del lst [ index + [number] ] [EOL] except IndexError : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if string . endswith ( [string] ) or string == [string] : [EOL] lst . append ( [string] ) [EOL] return lst [EOL] else : [EOL] return re . split ( [string] , string ) [EOL] [EOL] [EOL] def unite ( iterable ) : [EOL] [docstring] [EOL] return set ( typ for types in iterable for typ in types ) [EOL] [EOL] [EOL] def to_list ( func ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] return list ( func ( * args , ** kwargs ) ) [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import difflib [EOL] [EOL] from jedi import common [EOL] from jedi . evaluate import helpers [EOL] from jedi . parser . python import tree as pt [EOL] [EOL] [EOL] class Refactoring ( object ) : [EOL] def __init__ ( self , change_dct ) : [EOL] [docstring] [EOL] self . change_dct = change_dct [EOL] [EOL] def old_files ( self ) : [EOL] dct = { } [EOL] for old_path , ( new_path , old_l , new_l ) in self . change_dct . items ( ) : [EOL] dct [ old_path ] = [string] . join ( old_l ) [EOL] return dct [EOL] [EOL] def new_files ( self ) : [EOL] dct = { } [EOL] for old_path , ( new_path , old_l , new_l ) in self . change_dct . items ( ) : [EOL] dct [ new_path ] = [string] . join ( new_l ) [EOL] return dct [EOL] [EOL] def diff ( self ) : [EOL] texts = [ ] [EOL] for old_path , ( new_path , old_l , new_l ) in self . change_dct . items ( ) : [EOL] if old_path : [EOL] udiff = difflib . unified_diff ( old_l , new_l ) [EOL] else : [EOL] udiff = difflib . unified_diff ( old_l , new_l , old_path , new_path ) [EOL] texts . append ( [string] . join ( udiff ) ) [EOL] return [string] . join ( texts ) [EOL] [EOL] [EOL] def rename ( script , new_name ) : [EOL] [docstring] [EOL] return Refactoring ( _rename ( script . usages ( ) , new_name ) ) [EOL] [EOL] [EOL] def _rename ( names , replace_str ) : [EOL] [docstring] [EOL] order = sorted ( names , key = lambda x : ( x . module_path , x . line , x . column ) , reverse = True ) [EOL] [EOL] def process ( path , old_lines , new_lines ) : [EOL] if new_lines is not None : [comment] [EOL] dct [ path ] = path , old_lines , new_lines [EOL] [EOL] dct = { } [EOL] current_path = object ( ) [EOL] new_lines = old_lines = None [EOL] for name in order : [EOL] if name . in_builtin_module ( ) : [EOL] continue [EOL] if current_path != name . module_path : [EOL] current_path = name . module_path [EOL] [EOL] process ( current_path , old_lines , new_lines ) [EOL] if current_path is not None : [EOL] [comment] [EOL] with open ( current_path ) as f : [EOL] source = f . read ( ) [EOL] [EOL] new_lines = common . splitlines ( common . source_to_unicode ( source ) ) [EOL] old_lines = new_lines [ : ] [EOL] [EOL] nr , indent = name . line , name . column [EOL] line = new_lines [ nr - [number] ] [EOL] new_lines [ nr - [number] ] = line [ : indent ] + replace_str + line [ indent + len ( name . name ) : ] [EOL] process ( current_path , old_lines , new_lines ) [EOL] return dct [EOL] [EOL] [EOL] def extract ( script , new_name ) : [EOL] [docstring] [EOL] new_lines = common . splitlines ( common . source_to_unicode ( script . source ) ) [EOL] old_lines = new_lines [ : ] [EOL] [EOL] user_stmt = script . _parser . user_stmt ( ) [EOL] [EOL] [comment] [EOL] dct = { } [EOL] if user_stmt : [EOL] pos = script . _pos [EOL] line_index = pos [ [number] ] - [number] [EOL] arr , index = helpers . array_for_pos ( user_stmt , pos ) [EOL] if arr is not None : [EOL] start_pos = arr [ index ] . start_pos [EOL] end_pos = arr [ index ] . end_pos [EOL] [EOL] [comment] [EOL] e = end_pos [ [number] ] if end_pos [ [number] ] == start_pos [ [number] ] else None [EOL] start_line = new_lines [ start_pos [ [number] ] - [number] ] [EOL] text = start_line [ start_pos [ [number] ] : e ] [EOL] for l in range ( start_pos [ [number] ] , end_pos [ [number] ] - [number] ) : [EOL] text += [string] + l [EOL] if e is None : [EOL] end_line = new_lines [ end_pos [ [number] ] - [number] ] [EOL] text += [string] + end_line [ : end_pos [ [number] ] ] [EOL] [EOL] [comment] [EOL] t = text . lstrip ( ) [EOL] del_start = start_pos [ [number] ] + len ( text ) - len ( t ) [EOL] [EOL] text = t . rstrip ( ) [EOL] del_end = len ( t ) - len ( text ) [EOL] if e is None : [EOL] new_lines [ end_pos [ [number] ] - [number] ] = end_line [ end_pos [ [number] ] - del_end : ] [EOL] e = len ( start_line ) [EOL] else : [EOL] e = e - del_end [EOL] start_line = start_line [ : del_start ] + new_name + start_line [ e : ] [EOL] new_lines [ start_pos [ [number] ] - [number] ] = start_line [EOL] new_lines [ start_pos [ [number] ] : end_pos [ [number] ] - [number] ] = [ ] [EOL] [EOL] [comment] [EOL] open_brackets = [ [string] , [string] , [string] ] [EOL] close_brackets = [ [string] , [string] , [string] ] [EOL] if [string] in text and not ( text [ [number] ] in open_brackets and text [ - [number] ] == close_brackets [ open_brackets . index ( text [ [number] ] ) ] ) : [EOL] text = [string] % text [EOL] [EOL] [comment] [EOL] indent = user_stmt . start_pos [ [number] ] [EOL] new = [string] % ( [string] * indent , new_name , text ) [EOL] new_lines . insert ( line_index , new ) [EOL] dct [ script . path ] = script . path , old_lines , new_lines [EOL] return Refactoring ( dct ) [EOL] [EOL] [EOL] def inline ( script ) : [EOL] [docstring] [EOL] new_lines = common . splitlines ( common . source_to_unicode ( script . source ) ) [EOL] [EOL] dct = { } [EOL] [EOL] definitions = script . goto_assignments ( ) [EOL] with common . ignored ( AssertionError ) : [EOL] assert len ( definitions ) == [number] [EOL] stmt = definitions [ [number] ] . _definition [EOL] usages = script . usages ( ) [EOL] inlines = [ r for r in usages if not stmt . start_pos <= ( r . line , r . column ) <= stmt . end_pos ] [EOL] inlines = sorted ( inlines , key = lambda x : ( x . module_path , x . line , x . column ) , reverse = True ) [EOL] expression_list = stmt . expression_list ( ) [EOL] [comment] [EOL] assert stmt . start_pos [ [number] ] == stmt . end_pos [ [number] ] [EOL] index = stmt . start_pos [ [number] ] - [number] [EOL] [EOL] line = new_lines [ index ] [EOL] replace_str = line [ expression_list [ [number] ] . start_pos [ [number] ] : stmt . end_pos [ [number] ] + [number] ] [EOL] replace_str = replace_str . strip ( ) [EOL] [comment] [EOL] if expression_list and isinstance ( expression_list [ [number] ] , pr . Array ) : [EOL] arr = expression_list [ [number] ] [EOL] if replace_str [ [number] ] not in [ [string] , [string] , [string] ] and len ( arr ) > [number] : [EOL] replace_str = [string] % replace_str [EOL] [EOL] [comment] [EOL] if len ( stmt . get_defined_names ( ) ) == [number] : [EOL] line = line [ : stmt . start_pos [ [number] ] ] + line [ stmt . end_pos [ [number] ] : ] [EOL] [EOL] dct = _rename ( inlines , replace_str ) [EOL] [comment] [EOL] new_lines = dct [ script . path ] [ [number] ] [EOL] if line . strip ( ) : [EOL] new_lines [ index ] = line [EOL] else : [EOL] new_lines . pop ( index ) [EOL] [EOL] return Refactoring ( dct ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Type [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] import __main__ [EOL] from collections import namedtuple [EOL] import logging [EOL] import traceback [EOL] import re [EOL] import os [EOL] import sys [EOL] [EOL] from jedi import Interpreter [EOL] from jedi . api . helpers import get_on_completion_name [EOL] from jedi import common [EOL] [EOL] [EOL] READLINE_DEBUG = False [EOL] [EOL] [EOL] def setup_readline ( namespace_module = __main__ ) : [EOL] [docstring] [EOL] if READLINE_DEBUG : [EOL] logging . basicConfig ( filename = [string] , filemode = [string] , level = logging . DEBUG ) [EOL] [EOL] class JediRL ( object ) : [EOL] def complete ( self , text , state ) : [EOL] [docstring] [EOL] if state == [number] : [EOL] sys . path . insert ( [number] , os . getcwd ( ) ) [EOL] [comment] [EOL] try : [EOL] logging . debug ( [string] + repr ( text ) ) [EOL] interpreter = Interpreter ( text , [ namespace_module . __dict__ ] ) [EOL] [EOL] lines = common . splitlines ( text ) [EOL] position = ( len ( lines ) , len ( lines [ - [number] ] ) ) [EOL] name = get_on_completion_name ( interpreter . _get_module_node ( ) , lines , position ) [EOL] before = text [ : len ( text ) - len ( name ) ] [EOL] completions = interpreter . completions ( ) [EOL] except : [EOL] logging . error ( [string] + traceback . format_exc ( ) ) [EOL] raise [EOL] finally : [EOL] sys . path . pop ( [number] ) [EOL] [EOL] self . matches = [ before + c . name_with_symbols for c in completions ] [EOL] try : [EOL] return self . matches [ state ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] try : [EOL] import readline [EOL] except ImportError : [EOL] print ( [string] ) [EOL] else : [EOL] readline . set_completer ( JediRL ( ) . complete ) [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . set_completer_delims ( [string] ) [EOL] [EOL] [EOL] def version_info ( ) : [EOL] [docstring] [EOL] Version = namedtuple ( [string] , [string] ) [EOL] from jedi import __version__ [EOL] tupl = re . findall ( [string] , __version__ ) [EOL] return Version ( * [ x if i == [number] else int ( x ) for i , x in enumerate ( tupl ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] from jedi . api import classes [EOL] from jedi . parser . python import tree [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate . filters import TreeNameDefinition [EOL] from jedi . evaluate . representation import ModuleContext [EOL] [EOL] [EOL] def compare_contexts ( c1 , c2 ) : [EOL] return c1 == c2 or ( c1 [ [number] ] == c2 [ [number] ] and c1 [ [number] ] . tree_node == c2 [ [number] ] . tree_node ) [EOL] [EOL] [EOL] def usages ( evaluator , definition_names , mods ) : [EOL] [docstring] [EOL] def resolve_names ( definition_names ) : [EOL] for name in definition_names : [EOL] if name . api_type == [string] : [EOL] found = False [EOL] for context in name . infer ( ) : [EOL] if isinstance ( context , ModuleContext ) : [EOL] found = True [EOL] yield context . name [EOL] if not found : [EOL] yield name [EOL] else : [EOL] yield name [EOL] [EOL] def compare_array ( definition_names ) : [EOL] [docstring] [EOL] return [ ( name . get_root_context ( ) , name . start_pos ) for name in resolve_names ( definition_names ) ] [EOL] [EOL] search_name = list ( definition_names ) [ [number] ] . string_name [EOL] compare_definitions = compare_array ( definition_names ) [EOL] mods = mods | set ( [ d . get_root_context ( ) for d in definition_names ] ) [EOL] definition_names = set ( resolve_names ( definition_names ) ) [EOL] for m in imports . get_modules_containing_name ( evaluator , mods , search_name ) : [EOL] if isinstance ( m , ModuleContext ) : [EOL] for name_node in m . tree_node . get_used_names ( ) . get ( search_name , [ ] ) : [EOL] context = evaluator . create_context ( m , name_node ) [EOL] result = evaluator . goto ( context , name_node ) [EOL] if any ( compare_contexts ( c1 , c2 ) for c1 in compare_array ( result ) for c2 in compare_definitions ) : [EOL] name = TreeNameDefinition ( context , name_node ) [EOL] definition_names . add ( name ) [EOL] [comment] [EOL] [comment] [EOL] compare_definitions += compare_array ( [ name ] ) [EOL] else : [EOL] [comment] [EOL] definition_names . add ( m . name ) [EOL] [EOL] return [ classes . Definition ( evaluator , n ) for n in definition_names ] [EOL] [EOL] [EOL] def resolve_potential_imports ( evaluator , definitions ) : [EOL] [docstring] [EOL] new = set ( ) [EOL] for d in definitions : [EOL] if isinstance ( d , TreeNameDefinition ) : [EOL] imp_or_stmt = d . tree_name . get_definition ( ) [EOL] if isinstance ( imp_or_stmt , tree . Import ) : [EOL] new |= resolve_potential_imports ( evaluator , set ( imports . infer_import ( d . parent_context , d . tree_name , is_goto = True ) ) ) [EOL] return set ( definitions ) | new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Type , Match , List , Dict [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] from collections import namedtuple [EOL] [EOL] from jedi . _compatibility import u [EOL] from jedi . evaluate . helpers import evaluate_call_of_leaf [EOL] from jedi . parser . python . parser import Parser [EOL] from jedi . parser . python import tree [EOL] from jedi . parser import tokenize [EOL] from jedi . cache import time_cache [EOL] from jedi import common [EOL] [EOL] [EOL] CompletionParts = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def sorted_definitions ( defs ) : [EOL] [comment] [EOL] return sorted ( defs , key = lambda x : ( x . module_path or [string] , x . line or [number] , x . column or [number] ) ) [EOL] [EOL] [EOL] def get_on_completion_name ( module_node , lines , position ) : [EOL] leaf = module_node . get_leaf_for_position ( position ) [EOL] if leaf is None or leaf . type in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] line = lines [ position [ [number] ] - [number] ] [EOL] [comment] [EOL] return re . search ( [string] , line [ : position [ [number] ] ] ) . group ( [number] ) [EOL] elif leaf . type not in ( [string] , [string] ) : [EOL] return [string] [EOL] [EOL] return leaf . value [ : position [ [number] ] - leaf . start_pos [ [number] ] ] [EOL] [EOL] [EOL] def _get_code ( code_lines , start_pos , end_pos ) : [EOL] [comment] [EOL] lines = code_lines [ start_pos [ [number] ] - [number] : end_pos [ [number] ] ] [EOL] [comment] [EOL] lines [ - [number] ] = lines [ - [number] ] [ : end_pos [ [number] ] ] [EOL] [comment] [EOL] lines [ [number] ] = lines [ [number] ] [ start_pos [ [number] ] : ] [EOL] return [string] . join ( lines ) [EOL] [EOL] [EOL] class OnErrorLeaf ( Exception ) : [EOL] @ property def error_leaf ( self ) : [EOL] return self . args [ [number] ] [EOL] [EOL] [EOL] def _is_on_comment ( leaf , position ) : [EOL] comment_lines = common . splitlines ( leaf . prefix ) [EOL] difference = leaf . start_pos [ [number] ] - position [ [number] ] [EOL] prefix_start_pos = leaf . get_start_pos_of_prefix ( ) [EOL] if difference == [number] : [EOL] indent = leaf . start_pos [ [number] ] [EOL] elif position [ [number] ] == prefix_start_pos [ [number] ] : [EOL] indent = prefix_start_pos [ [number] ] [EOL] else : [EOL] indent = [number] [EOL] line = comment_lines [ - difference - [number] ] [ : position [ [number] ] - indent ] [EOL] return [string] in line [EOL] [EOL] [EOL] def _get_code_for_stack ( code_lines , module_node , position ) : [EOL] leaf = module_node . get_leaf_for_position ( position , include_prefixes = True ) [EOL] [comment] [EOL] [comment] [EOL] if leaf . start_pos >= position : [EOL] if _is_on_comment ( leaf , position ) : [EOL] return u ( [string] ) [EOL] [EOL] [comment] [EOL] leaf = leaf . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return u ( [string] ) [comment] [EOL] [EOL] is_after_newline = leaf . type == [string] [EOL] while leaf . type == [string] : [EOL] leaf = leaf . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return u ( [string] ) [EOL] [EOL] if leaf . type == [string] or leaf . type == [string] : [EOL] if leaf . start_pos [ [number] ] < position [ [number] ] : [EOL] [comment] [EOL] return u ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] raise OnErrorLeaf ( leaf ) [EOL] else : [EOL] if leaf == [string] : [EOL] user_stmt = leaf . parent [EOL] else : [EOL] user_stmt = leaf . get_definition ( ) [EOL] if user_stmt . parent . type == [string] : [EOL] user_stmt = user_stmt . parent [EOL] [EOL] if is_after_newline : [EOL] if user_stmt . start_pos [ [number] ] > position [ [number] ] : [EOL] [comment] [EOL] [comment] [EOL] return u ( [string] ) [EOL] [EOL] [comment] [EOL] return _get_code ( code_lines , user_stmt . get_start_pos_of_prefix ( ) , position ) [EOL] [EOL] [EOL] def get_stack_at_position ( grammar , code_lines , module_node , pos ) : [EOL] [docstring] [EOL] class EndMarkerReached ( Exception ) : [EOL] pass [EOL] [EOL] def tokenize_without_endmarker ( code ) : [EOL] tokens = tokenize . source_tokens ( code , use_exact_op_types = True ) [EOL] for token_ in tokens : [EOL] if token_ . string == safeword : [EOL] raise EndMarkerReached ( ) [EOL] else : [EOL] yield token_ [EOL] [EOL] code = _get_code_for_stack ( code_lines , module_node , pos ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] safeword = [string] [EOL] code = code + safeword [EOL] [EOL] p = Parser ( grammar , error_recovery = True ) [EOL] try : [EOL] p . parse ( tokens = tokenize_without_endmarker ( code ) ) [EOL] except EndMarkerReached : [EOL] return Stack ( p . pgen_parser . stack ) [EOL] raise SystemError ( [string] ) [EOL] [EOL] [EOL] class Stack ( list ) : [EOL] def get_node_names ( self , grammar ) : [EOL] for dfa , state , ( node_number , nodes ) in self : [EOL] yield grammar . number2symbol [ node_number ] [EOL] [EOL] def get_nodes ( self ) : [EOL] for dfa , state , ( node_number , nodes ) in self : [EOL] for node in nodes : [EOL] yield node [EOL] [EOL] [EOL] def get_possible_completion_types ( grammar , stack ) : [EOL] def add_results ( label_index ) : [EOL] try : [EOL] grammar_labels . append ( inversed_tokens [ label_index ] ) [EOL] except KeyError : [EOL] try : [EOL] keywords . append ( inversed_keywords [ label_index ] ) [EOL] except KeyError : [EOL] t , v = grammar . labels [ label_index ] [EOL] assert t >= [number] [EOL] [comment] [EOL] inversed_keywords [EOL] itsdfa = grammar . dfas [ t ] [EOL] itsstates , itsfirst = itsdfa [EOL] for first_label_index in itsfirst . keys ( ) : [EOL] add_results ( first_label_index ) [EOL] [EOL] inversed_keywords = dict ( ( v , k ) for k , v in grammar . keywords . items ( ) ) [EOL] inversed_tokens = dict ( ( v , k ) for k , v in grammar . tokens . items ( ) ) [EOL] [EOL] keywords = [ ] [EOL] grammar_labels = [ ] [EOL] [EOL] def scan_stack ( index ) : [EOL] dfa , state , node = stack [ index ] [EOL] states , first = dfa [EOL] arcs = states [ state ] [EOL] [EOL] for label_index , new_state in arcs : [EOL] if label_index == [number] : [EOL] [comment] [EOL] scan_stack ( index - [number] ) [EOL] else : [EOL] add_results ( label_index ) [EOL] [EOL] scan_stack ( - [number] ) [EOL] [EOL] return keywords , grammar_labels [EOL] [EOL] [EOL] def evaluate_goto_definition ( evaluator , context , leaf ) : [EOL] if leaf . type == [string] : [EOL] [comment] [EOL] [comment] [EOL] return evaluator . goto_definitions ( context , leaf ) [EOL] [EOL] parent = leaf . parent [EOL] if parent . type == [string] : [EOL] return context . eval_node ( leaf . parent ) [EOL] elif parent . type == [string] : [EOL] return evaluate_call_of_leaf ( context , leaf ) [EOL] elif isinstance ( leaf , tree . Literal ) : [EOL] return context . evaluator . eval_atom ( context , leaf ) [EOL] return [ ] [EOL] [EOL] [EOL] CallSignatureDetails = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def _get_index_and_key ( nodes , position ) : [EOL] [docstring] [EOL] nodes_before = [ c for c in nodes if c . start_pos < position ] [EOL] if nodes_before [ - [number] ] . type == [string] : [EOL] nodes_before = [ c for c in nodes_before [ - [number] ] . children if c . start_pos < position ] [EOL] [EOL] key_str = None [EOL] [EOL] if nodes_before : [EOL] last = nodes_before [ - [number] ] [EOL] if last . type == [string] and last . children [ [number] ] . end_pos <= position : [EOL] [comment] [EOL] key_str = last . children [ [number] ] . value [EOL] elif last == [string] : [EOL] key_str = nodes_before [ - [number] ] . value [EOL] [EOL] return nodes_before . count ( [string] ) , key_str [EOL] [EOL] [EOL] def _get_call_signature_details_from_error_node ( node , position ) : [EOL] for index , element in reversed ( list ( enumerate ( node . children ) ) ) : [EOL] [comment] [EOL] if element == [string] and element . end_pos <= position and index > [number] : [EOL] [comment] [EOL] [comment] [EOL] children = node . children [ index : ] [EOL] name = element . get_previous_leaf ( ) [EOL] if name is None : [EOL] continue [EOL] if name . type == [string] or name . parent . type in ( [string] , [string] ) : [EOL] return CallSignatureDetails ( element , * _get_index_and_key ( children , position ) ) [EOL] [EOL] [EOL] def get_call_signature_details ( module , position ) : [EOL] leaf = module . get_leaf_for_position ( position , include_prefixes = True ) [EOL] if leaf . start_pos >= position : [EOL] [comment] [EOL] leaf = leaf . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return None [EOL] [EOL] if leaf == [string] : [EOL] if leaf . end_pos == position : [EOL] leaf = leaf . get_next_leaf ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] node = leaf . parent [EOL] while node is not None : [EOL] if node . type in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] [EOL] for n in node . children [ : : - [number] ] : [EOL] if n . start_pos < position and n . type == [string] : [EOL] result = _get_call_signature_details_from_error_node ( n , position ) [EOL] if result is not None : [EOL] return result [EOL] [EOL] if node . type == [string] and node . children [ [number] ] == [string] : [EOL] leaf = node . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return None [EOL] return CallSignatureDetails ( node . children [ [number] ] , * _get_index_and_key ( node . children , position ) ) [EOL] [EOL] node = node . parent [EOL] [EOL] return None [EOL] [EOL] [EOL] @ time_cache ( [string] ) def cache_call_signatures ( evaluator , context , bracket_leaf , code_lines , user_pos ) : [EOL] [docstring] [EOL] index = user_pos [ [number] ] - [number] [EOL] [EOL] before_cursor = code_lines [ index ] [ : user_pos [ [number] ] ] [EOL] other_lines = code_lines [ bracket_leaf . start_pos [ [number] ] : index ] [EOL] whole = [string] . join ( other_lines + [ before_cursor ] ) [EOL] before_bracket = re . match ( [string] , whole , re . DOTALL ) [EOL] [EOL] module_path = context . get_root_context ( ) . py__file__ ( ) [EOL] if module_path is None : [EOL] yield None [comment] [EOL] else : [EOL] yield ( module_path , before_bracket , bracket_leaf . start_pos ) [EOL] yield evaluate_goto_definition ( evaluator , context , bracket_leaf . get_previous_leaf ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CompletionParts]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CallSignatureDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CallSignatureDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CallSignatureDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate . compiled import mixed [EOL] from jedi . evaluate . context import Context [EOL] [EOL] [EOL] class NamespaceObject ( object ) : [EOL] def __init__ ( self , dct ) : [EOL] self . __dict__ = dct [EOL] [EOL] [EOL] class MixedModuleContext ( Context ) : [EOL] resets_positions = True [EOL] type = [string] [EOL] [EOL] def __init__ ( self , evaluator , tree_module , namespaces , path ) : [EOL] self . evaluator = evaluator [EOL] self . _namespaces = namespaces [EOL] [EOL] self . _namespace_objects = [ NamespaceObject ( n ) for n in namespaces ] [EOL] self . _module_context = ModuleContext ( evaluator , tree_module , path = path ) [EOL] self . tree_node = tree_module [EOL] [EOL] def get_node ( self ) : [EOL] return self . tree_node [EOL] [EOL] def get_filters ( self , * args , ** kwargs ) : [EOL] for filter in self . _module_context . get_filters ( * args , ** kwargs ) : [EOL] yield filter [EOL] [EOL] for namespace_obj in self . _namespace_objects : [EOL] compiled_object = compiled . create ( self . evaluator , namespace_obj ) [EOL] mixed_object = mixed . MixedObject ( self . evaluator , parent_context = self , compiled_object = compiled_object , tree_context = self . _module_context ) [EOL] for filter in mixed_object . get_filters ( * args , ** kwargs ) : [EOL] yield filter [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _module_context , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import jedi . utils [EOL] from jedi import __version__ as __jedi_version__ [EOL] [EOL] print ( [string] % __jedi_version__ ) [EOL] jedi . utils . setup_readline ( ) [EOL] [EOL] del jedi [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Any , Set [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import warnings [EOL] import sys [EOL] [EOL] from jedi . parser . python import load_grammar [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . python import parse [EOL] from jedi . parser_utils import get_executable_nodes , get_statement_of_position [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi import common [EOL] from jedi import cache [EOL] from jedi . api import classes [EOL] from jedi . api import interpreter [EOL] from jedi . api import usages [EOL] from jedi . api import helpers [EOL] from jedi . api . completion import Completion [EOL] from jedi . evaluate import Evaluator [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate . param import try_iter_content [EOL] from jedi . evaluate . helpers import get_module_names [EOL] from jedi . evaluate . sys_path import get_venv_path [EOL] from jedi . evaluate . iterable import unpack_tuple_to_dict [EOL] from jedi . evaluate . filters import TreeNameDefinition [EOL] [EOL] [comment] [EOL] [comment] [EOL] sys . setrecursionlimit ( [number] ) [EOL] [EOL] [EOL] class NotFoundError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Script ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , source = None , line = None , column = None , path = None , encoding = [string] , source_path = None , source_encoding = None , sys_path = None ) : [EOL] if source_path is not None : [EOL] warnings . warn ( [string] , DeprecationWarning , stacklevel = [number] ) [EOL] path = source_path [EOL] if source_encoding is not None : [EOL] warnings . warn ( [string] , DeprecationWarning , stacklevel = [number] ) [EOL] encoding = source_encoding [EOL] [EOL] self . _orig_path = path [EOL] [comment] [EOL] self . path = os . path . abspath ( path ) if path else None [EOL] [EOL] if source is None : [EOL] [comment] [EOL] with open ( path , [string] ) as f : [EOL] source = f . read ( ) [EOL] [EOL] self . _source = common . source_to_unicode ( source , encoding ) [EOL] self . _code_lines = common . splitlines ( self . _source ) [EOL] line = max ( len ( self . _code_lines ) , [number] ) if line is None else line [EOL] if not ( [number] < line <= len ( self . _code_lines ) ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] line_len = len ( self . _code_lines [ line - [number] ] ) [EOL] column = line_len if column is None else column [EOL] if not ( [number] <= column <= line_len ) : [EOL] raise ValueError ( [string] ) [EOL] self . _pos = line , column [EOL] self . _path = path [EOL] [EOL] cache . clear_time_caches ( ) [EOL] debug . reset_time ( ) [EOL] self . _grammar = load_grammar ( version = [string] % sys . version_info [ : [number] ] ) [EOL] if sys_path is None : [EOL] venv = os . getenv ( [string] ) [EOL] if venv : [EOL] sys_path = list ( get_venv_path ( venv ) ) [EOL] self . _evaluator = Evaluator ( self . _grammar , sys_path = sys_path ) [EOL] debug . speed ( [string] ) [EOL] [EOL] @ cache . memoize_method def _get_module_node ( self ) : [EOL] return parse ( code = self . _source , path = self . path , grammar = self . _grammar , cache = False , diff_cache = True , ) [EOL] [EOL] @ cache . memoize_method def _get_module ( self ) : [EOL] module = er . ModuleContext ( self . _evaluator , self . _get_module_node ( ) , self . path ) [EOL] imports . add_module ( self . _evaluator , module . name . string_name , module ) [EOL] return module [EOL] [EOL] @ property def source_path ( self ) : [EOL] [docstring] [EOL] warnings . warn ( [string] , DeprecationWarning , stacklevel = [number] ) [EOL] return self . path [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , repr ( self . _orig_path ) ) [EOL] [EOL] def completions ( self ) : [EOL] [docstring] [EOL] debug . speed ( [string] ) [EOL] completion = Completion ( self . _evaluator , self . _get_module ( ) , self . _code_lines , self . _pos , self . call_signatures ) [EOL] completions = completion . completions ( ) [EOL] debug . speed ( [string] ) [EOL] return completions [EOL] [EOL] def goto_definitions ( self ) : [EOL] [docstring] [EOL] module_node = self . _get_module_node ( ) [EOL] leaf = module_node . get_name_of_position ( self . _pos ) [EOL] if leaf is None : [EOL] leaf = module_node . get_leaf_for_position ( self . _pos ) [EOL] if leaf is None : [EOL] return [ ] [EOL] [EOL] context = self . _evaluator . create_context ( self . _get_module ( ) , leaf ) [EOL] definitions = helpers . evaluate_goto_definition ( self . _evaluator , context , leaf ) [EOL] [EOL] names = [ s . name for s in definitions ] [EOL] defs = [ classes . Definition ( self . _evaluator , name ) for name in names ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return helpers . sorted_definitions ( set ( defs ) ) [EOL] [EOL] def goto_assignments ( self , follow_imports = False ) : [EOL] [docstring] [EOL] def filter_follow_imports ( names ) : [EOL] for name in names : [EOL] if isinstance ( name , ( imports . ImportName , TreeNameDefinition ) ) : [EOL] for context in name . infer ( ) : [EOL] yield context . name [EOL] else : [EOL] yield name [EOL] [EOL] names = self . _goto ( ) [EOL] if follow_imports : [EOL] names = filter_follow_imports ( names ) [EOL] [EOL] defs = [ classes . Definition ( self . _evaluator , d ) for d in set ( names ) ] [EOL] return helpers . sorted_definitions ( defs ) [EOL] [EOL] def _goto ( self ) : [EOL] [docstring] [EOL] name = self . _get_module_node ( ) . get_name_of_position ( self . _pos ) [EOL] if name is None : [EOL] return [ ] [EOL] context = self . _evaluator . create_context ( self . _get_module ( ) , name ) [EOL] return list ( self . _evaluator . goto ( context , name ) ) [EOL] [EOL] def usages ( self , additional_module_paths = ( ) ) : [EOL] [docstring] [EOL] temp , settings . dynamic_flow_information = settings . dynamic_flow_information , False [EOL] try : [EOL] module_node = self . _get_module_node ( ) [EOL] user_stmt = get_statement_of_position ( module_node , self . _pos ) [EOL] definition_names = self . _goto ( ) [EOL] if not definition_names and isinstance ( user_stmt , tree . Import ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] name = user_stmt . get_name_of_position ( self . _pos ) [EOL] if name is None : [EOL] [comment] [EOL] return [ ] [EOL] definition_names = [ TreeNameDefinition ( self . _get_module ( ) , name ) ] [EOL] [EOL] if not definition_names : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] definition_names = usages . resolve_potential_imports ( self . _evaluator , definition_names ) [EOL] [EOL] modules = set ( [ d . get_root_context ( ) for d in definition_names ] ) [EOL] modules . add ( self . _get_module ( ) ) [EOL] definitions = usages . usages ( self . _evaluator , definition_names , modules ) [EOL] finally : [EOL] settings . dynamic_flow_information = temp [EOL] [EOL] return helpers . sorted_definitions ( set ( definitions ) ) [EOL] [EOL] def call_signatures ( self ) : [EOL] [docstring] [EOL] call_signature_details = helpers . get_call_signature_details ( self . _get_module_node ( ) , self . _pos ) [EOL] if call_signature_details is None : [EOL] return [ ] [EOL] [EOL] context = self . _evaluator . create_context ( self . _get_module ( ) , call_signature_details . bracket_leaf ) [EOL] with common . scale_speed_settings ( settings . scale_call_signatures ) : [EOL] definitions = helpers . cache_call_signatures ( self . _evaluator , context , call_signature_details . bracket_leaf , self . _code_lines , self . _pos ) [EOL] debug . speed ( [string] ) [EOL] [EOL] return [ classes . CallSignature ( self . _evaluator , d . name , call_signature_details . bracket_leaf . start_pos , call_signature_details . call_index , call_signature_details . keyword_name_str ) for d in definitions if hasattr ( d , [string] ) ] [EOL] [EOL] def _analysis ( self ) : [EOL] self . _evaluator . is_analysis = True [EOL] module_node = self . _get_module_node ( ) [EOL] self . _evaluator . analysis_modules = [ module_node ] [EOL] try : [EOL] for node in get_executable_nodes ( module_node ) : [EOL] context = self . _get_module ( ) . create_context ( node ) [EOL] if node . type in ( [string] , [string] ) : [EOL] [comment] [EOL] from jedi . evaluate . finder import _name_to_types [EOL] [comment] [EOL] _name_to_types ( self . _evaluator , context , node . children [ [number] ] ) [EOL] elif isinstance ( node , tree . Import ) : [EOL] import_names = set ( node . get_defined_names ( ) ) [EOL] if node . is_nested ( ) : [EOL] import_names |= set ( path [ - [number] ] for path in node . get_paths ( ) ) [EOL] for n in import_names : [EOL] imports . infer_import ( context , n ) [EOL] elif node . type == [string] : [EOL] types = context . eval_node ( node ) [EOL] for testlist in node . children [ : - [number] : [number] ] : [EOL] [comment] [EOL] unpack_tuple_to_dict ( context , types , testlist ) [EOL] else : [EOL] try_iter_content ( self . _evaluator . goto_definitions ( context , node ) ) [EOL] self . _evaluator . reset_recursion_limitations ( ) [EOL] [EOL] ana = [ a for a in self . _evaluator . analysis if self . path == a . path ] [EOL] return sorted ( set ( ana ) , key = lambda x : x . line ) [EOL] finally : [EOL] self . _evaluator . is_analysis = False [EOL] [EOL] [EOL] class Interpreter ( Script ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source , namespaces , ** kwds ) : [EOL] [docstring] [EOL] try : [EOL] namespaces = [ dict ( n ) for n in namespaces ] [EOL] except Exception : [EOL] raise TypeError ( [string] ) [EOL] [EOL] super ( Interpreter , self ) . __init__ ( source , ** kwds ) [EOL] self . namespaces = namespaces [EOL] [EOL] def _get_module ( self ) : [EOL] parser_module = super ( Interpreter , self ) . _get_module_node ( ) [EOL] return interpreter . MixedModuleContext ( self . _evaluator , parser_module , self . namespaces , path = self . path ) [EOL] [EOL] [EOL] def defined_names ( source , path = None , encoding = [string] ) : [EOL] [docstring] [EOL] warnings . warn ( [string] , DeprecationWarning ) [EOL] return names ( source , path , encoding ) [EOL] [EOL] [EOL] def names ( source = None , path = None , encoding = [string] , all_scopes = False , definitions = True , references = False ) : [EOL] [docstring] [EOL] def def_ref_filter ( _def ) : [EOL] is_def = _def . _name . tree_name . is_definition ( ) [EOL] return definitions and is_def or references and not is_def [EOL] [EOL] [comment] [EOL] script = Script ( source , line = [number] , column = [number] , path = path , encoding = encoding ) [EOL] module_context = script . _get_module ( ) [EOL] defs = [ classes . Definition ( script . _evaluator , TreeNameDefinition ( module_context . create_context ( name . parent ) , name ) ) for name in get_module_names ( script . _get_module_node ( ) , all_scopes ) ] [EOL] return sorted ( filter ( def_ref_filter , defs ) , key = lambda x : ( x . line , x . column ) ) [EOL] [EOL] [EOL] def preload_module ( * modules ) : [EOL] [docstring] [EOL] for m in modules : [EOL] s = [string] % m [EOL] Script ( s , [number] , len ( s ) , None ) . completions ( ) [EOL] [EOL] [EOL] def set_debug_function ( func_cb = debug . print_to_stdout , warnings = True , notices = True , speed = True ) : [EOL] [docstring] [EOL] debug . debug_function = func_cb [EOL] debug . enable_warning = warnings [EOL] debug . enable_notice = notices [EOL] debug . enable_speed = speed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , Tuple , Dict [EOL] import typing [EOL] from jedi . parser import token [EOL] from jedi . parser . python import tree [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi . api import classes [EOL] from jedi . api import helpers [EOL] from jedi . evaluate import imports [EOL] from jedi . api import keywords [EOL] from jedi . evaluate . helpers import evaluate_call_of_leaf [EOL] from jedi . evaluate . filters import get_global_filters [EOL] from jedi . parser_utils import get_statement_of_position [EOL] [EOL] [EOL] def get_call_signature_param_names ( call_signatures ) : [EOL] [comment] [EOL] for call_sig in call_signatures : [EOL] for p in call_sig . params : [EOL] [comment] [EOL] tree_name = p . _name . tree_name [EOL] [comment] [EOL] if tree_name is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tree_param = tree . search_ancestor ( tree_name , [string] ) [EOL] if tree_param . star_count == [number] : [comment] [EOL] yield p . _name [EOL] [EOL] [EOL] def filter_names ( evaluator , completion_names , stack , like_name ) : [EOL] comp_dct = { } [EOL] for name in completion_names : [EOL] if settings . case_insensitive_completion \ [EOL] and name . string_name . lower ( ) . startswith ( like_name . lower ( ) ) or name . string_name . startswith ( like_name ) : [EOL] [EOL] new = classes . Completion ( evaluator , name , stack , len ( like_name ) ) [EOL] k = ( new . name , new . complete ) [comment] [EOL] if k in comp_dct and settings . no_completion_duplicates : [EOL] comp_dct [ k ] . _same_name_completions . append ( new ) [EOL] else : [EOL] comp_dct [ k ] = new [EOL] yield new [EOL] [EOL] [EOL] def get_user_scope ( module_context , position ) : [EOL] [docstring] [EOL] user_stmt = get_statement_of_position ( module_context . tree_node , position ) [EOL] if user_stmt is None : [EOL] def scan ( scope ) : [EOL] for s in scope . children : [EOL] if s . start_pos <= position <= s . end_pos : [EOL] if isinstance ( s , ( tree . Scope , tree . Flow ) ) : [EOL] return scan ( s ) or s [EOL] elif s . type in ( [string] , [string] ) : [EOL] return scan ( s ) [EOL] return None [EOL] [EOL] scanned_node = scan ( module_context . tree_node ) [EOL] if scanned_node : [EOL] return module_context . create_context ( scanned_node , node_is_context = True ) [EOL] return module_context [EOL] else : [EOL] return module_context . create_context ( user_stmt ) [EOL] [EOL] [EOL] def get_flow_scope_node ( module_node , position ) : [EOL] node = module_node . get_leaf_for_position ( position , include_prefixes = True ) [EOL] while not isinstance ( node , ( tree . Scope , tree . Flow ) ) : [EOL] node = node . parent [EOL] [EOL] return node [EOL] [EOL] [EOL] class Completion : [EOL] def __init__ ( self , evaluator , module , code_lines , position , call_signatures_method ) : [EOL] self . _evaluator = evaluator [EOL] self . _module_context = module [EOL] self . _module_node = module . tree_node [EOL] self . _code_lines = code_lines [EOL] [EOL] [comment] [EOL] self . _like_name = helpers . get_on_completion_name ( self . _module_node , code_lines , position ) [EOL] [comment] [EOL] [comment] [EOL] self . _position = position [ [number] ] , position [ [number] ] - len ( self . _like_name ) [EOL] self . _call_signatures_method = call_signatures_method [EOL] [EOL] def completions ( self ) : [EOL] completion_names = self . _get_context_completions ( ) [EOL] [EOL] completions = filter_names ( self . _evaluator , completion_names , self . stack , self . _like_name ) [EOL] [EOL] return sorted ( completions , key = lambda x : ( x . name . startswith ( [string] ) , x . name . startswith ( [string] ) , x . name . lower ( ) ) ) [EOL] [EOL] def _get_context_completions ( self ) : [EOL] [docstring] [EOL] [EOL] grammar = self . _evaluator . grammar [EOL] [EOL] try : [EOL] self . stack = helpers . get_stack_at_position ( grammar , self . _code_lines , self . _module_node , self . _position ) [EOL] except helpers . OnErrorLeaf as e : [EOL] self . stack = None [EOL] if e . error_leaf . value == [string] : [EOL] [comment] [EOL] [comment] [EOL] return [ ] [EOL] [comment] [EOL] [EOL] return self . _global_completions ( ) [EOL] [EOL] allowed_keywords , allowed_tokens = helpers . get_possible_completion_types ( grammar , self . stack ) [EOL] [EOL] completion_names = list ( self . _get_keyword_completion_names ( allowed_keywords ) ) [EOL] [EOL] if token . NAME in allowed_tokens or token . INDENT in allowed_tokens : [EOL] [comment] [EOL] [EOL] symbol_names = list ( self . stack . get_node_names ( grammar ) ) [EOL] [EOL] nodes = list ( self . stack . get_nodes ( ) ) [EOL] [EOL] if [string] in symbol_names : [EOL] level = [number] [EOL] only_modules = True [EOL] level , names = self . _parse_dotted_names ( nodes ) [EOL] if [string] in symbol_names : [EOL] if [string] in nodes : [EOL] only_modules = False [EOL] else : [EOL] assert [string] in symbol_names [EOL] [EOL] completion_names += self . _get_importer_names ( names , level , only_modules ) [EOL] elif nodes and nodes [ - [number] ] in ( [string] , [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return list ( self . _get_class_context_completions ( is_function = True ) ) [EOL] elif symbol_names [ - [number] ] in ( [string] , [string] ) and nodes [ - [number] ] == [string] : [EOL] dot = self . _module_node . get_leaf_for_position ( self . _position ) [EOL] completion_names += self . _trailer_completions ( dot . get_previous_leaf ( ) ) [EOL] else : [EOL] completion_names += self . _global_completions ( ) [EOL] completion_names += self . _get_class_context_completions ( is_function = False ) [EOL] [EOL] if [string] in symbol_names : [EOL] call_signatures = self . _call_signatures_method ( ) [EOL] completion_names += get_call_signature_param_names ( call_signatures ) [EOL] [EOL] return completion_names [EOL] [EOL] def _get_keyword_completion_names ( self , keywords_ ) : [EOL] for k in keywords_ : [EOL] yield keywords . keyword ( self . _evaluator , k ) . name [EOL] [EOL] def _global_completions ( self ) : [EOL] context = get_user_scope ( self . _module_context , self . _position ) [EOL] debug . dbg ( [string] , context ) [EOL] flow_scope_node = get_flow_scope_node ( self . _module_node , self . _position ) [EOL] filters = get_global_filters ( self . _evaluator , context , self . _position , origin_scope = flow_scope_node ) [EOL] completion_names = [ ] [EOL] for filter in filters : [EOL] completion_names += filter . values ( ) [EOL] return completion_names [EOL] [EOL] def _trailer_completions ( self , previous_leaf ) : [EOL] user_context = get_user_scope ( self . _module_context , self . _position ) [EOL] evaluation_context = self . _evaluator . create_context ( self . _module_context , previous_leaf ) [EOL] contexts = evaluate_call_of_leaf ( evaluation_context , previous_leaf ) [EOL] completion_names = [ ] [EOL] debug . dbg ( [string] , contexts ) [EOL] for context in contexts : [EOL] for filter in context . get_filters ( search_global = False , origin_scope = user_context . tree_node ) : [EOL] completion_names += filter . values ( ) [EOL] return completion_names [EOL] [EOL] def _parse_dotted_names ( self , nodes ) : [EOL] level = [number] [EOL] names = [ ] [EOL] for node in nodes [ [number] : ] : [EOL] if node in ( [string] , [string] ) : [EOL] if not names : [EOL] level += len ( node . value ) [EOL] elif node . type == [string] : [EOL] names += node . children [ : : [number] ] [EOL] elif node . type == [string] : [EOL] names . append ( node ) [EOL] else : [EOL] break [EOL] return level , names [EOL] [EOL] def _get_importer_names ( self , names , level = [number] , only_modules = True ) : [EOL] names = [ n . value for n in names ] [EOL] i = imports . Importer ( self . _evaluator , names , self . _module_context , level ) [EOL] return i . completion_names ( self . _evaluator , only_modules = only_modules ) [EOL] [EOL] def _get_class_context_completions ( self , is_function = True ) : [EOL] [docstring] [EOL] leaf = self . _module_node . get_leaf_for_position ( self . _position , include_prefixes = True ) [EOL] cls = tree . search_ancestor ( leaf , [string] ) [EOL] if isinstance ( cls , ( tree . Class , tree . Function ) ) : [EOL] [comment] [EOL] random_context = self . _module_context . create_context ( cls , node_is_context = True ) [EOL] else : [EOL] return [EOL] [EOL] if cls . start_pos [ [number] ] >= leaf . start_pos [ [number] ] : [EOL] return [EOL] [EOL] filters = random_context . get_filters ( search_global = False , is_instance = True ) [EOL] [comment] [EOL] next ( filters ) [EOL] for filter in filters : [EOL] for name in filter . values ( ) : [EOL] if ( name . api_type == [string] ) == is_function : [EOL] yield name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match , List , Set , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import itertools [EOL] [EOL] import os [EOL] from jedi . parser import ParserSyntaxError [EOL] from jedi . parser . python import parse , tree [EOL] from jedi . common import unite [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate . context import LazyTreeContext [EOL] from jedi import debug [EOL] from jedi import _compatibility [EOL] from jedi import parser_utils [EOL] import re [EOL] [EOL] [EOL] def _evaluate_for_annotation ( context , annotation , index = None ) : [EOL] [docstring] [EOL] if annotation is not None : [EOL] definitions = context . eval_node ( _fix_forward_reference ( context , annotation ) ) [EOL] if index is not None : [EOL] definitions = list ( itertools . chain . from_iterable ( definition . py__getitem__ ( index ) for definition in definitions if definition . array_type == [string] and len ( list ( definition . py__iter__ ( ) ) ) >= index ) ) [EOL] return unite ( d . execute_evaluated ( ) for d in definitions ) [EOL] else : [EOL] return set ( ) [EOL] [EOL] [EOL] def _fix_forward_reference ( context , node ) : [EOL] evaled_nodes = context . eval_node ( node ) [EOL] if len ( evaled_nodes ) != [number] : [EOL] debug . warning ( [string] [string] % ( node , evaled_nodes ) ) [EOL] return node [EOL] evaled_node = list ( evaled_nodes ) [ [number] ] [EOL] if isinstance ( evaled_node , compiled . CompiledObject ) and isinstance ( evaled_node . obj , str ) : [EOL] try : [EOL] new_node = parse ( _compatibility . unicode ( evaled_node . obj ) , start_symbol = [string] , error_recovery = False ) [EOL] except ParserSyntaxError : [EOL] debug . warning ( [string] % evaled_node . obj ) [EOL] return node [EOL] else : [EOL] module = node . get_root_node ( ) [EOL] parser_utils . move ( new_node , module . end_pos [ [number] ] ) [EOL] new_node . parent = context . tree_node [EOL] return new_node [EOL] else : [EOL] return node [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_param ( execution_context , param ) : [EOL] annotation = param . annotation [EOL] module_context = execution_context . get_root_context ( ) [EOL] return _evaluate_for_annotation ( module_context , annotation ) [EOL] [EOL] [EOL] def py__annotations__ ( funcdef ) : [EOL] return_annotation = funcdef . annotation [EOL] if return_annotation : [EOL] dct = { [string] : return_annotation } [EOL] else : [EOL] dct = { } [EOL] for function_param in funcdef . params : [EOL] param_annotation = function_param . annotation [EOL] if param_annotation is not None : [EOL] dct [ function_param . name . value ] = param_annotation [EOL] return dct [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_return_types ( function_context ) : [EOL] annotation = py__annotations__ ( function_context . tree_node ) . get ( [string] , None ) [EOL] module_context = function_context . get_root_context ( ) [EOL] return _evaluate_for_annotation ( module_context , annotation ) [EOL] [EOL] [EOL] _typing_module = None [EOL] [EOL] [EOL] def _get_typing_replacement_module ( ) : [EOL] [docstring] [EOL] global _typing_module [EOL] if _typing_module is None : [EOL] typing_path = os . path . abspath ( os . path . join ( __file__ , [string] ) ) [EOL] with open ( typing_path ) as f : [EOL] code = _compatibility . unicode ( f . read ( ) ) [EOL] _typing_module = parse ( code ) [EOL] return _typing_module [EOL] [EOL] [EOL] def py__getitem__ ( context , typ , node ) : [EOL] if not typ . get_root_context ( ) . name . string_name == [string] : [EOL] return None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if node . type == [string] : [EOL] nodes = node . children [ : : [number] ] [comment] [EOL] else : [EOL] nodes = [ node ] [EOL] del node [EOL] [EOL] nodes = [ _fix_forward_reference ( context , node ) for node in nodes ] [EOL] type_name = typ . name . string_name [EOL] [EOL] [comment] [EOL] if type_name in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return unite ( context . eval_node ( node ) for node in nodes ) [EOL] if type_name in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return context . eval_node ( nodes [ [number] ] ) [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] typing = ModuleContext ( context . evaluator , module_node = _get_typing_replacement_module ( ) , path = None ) [EOL] factories = typing . py__getattribute__ ( [string] ) [EOL] assert len ( factories ) == [number] [EOL] factory = list ( factories ) [ [number] ] [EOL] assert factory [EOL] function_body_nodes = factory . tree_node . children [ [number] ] . children [EOL] valid_classnames = set ( child . name . value for child in function_body_nodes if isinstance ( child , tree . Class ) ) [EOL] if type_name not in valid_classnames : [EOL] return None [EOL] compiled_classname = compiled . create ( context . evaluator , type_name ) [EOL] [EOL] from jedi . evaluate . iterable import FakeSequence [EOL] args = FakeSequence ( context . evaluator , [string] , [ LazyTreeContext ( context , n ) for n in nodes ] ) [EOL] [EOL] result = factory . execute_evaluated ( compiled_classname , args ) [EOL] return result [EOL] [EOL] [EOL] def find_type_from_comment_hint_for ( context , node , name ) : [EOL] return _find_type_from_comment_hint ( context , node , node . children [ [number] ] , name ) [EOL] [EOL] [EOL] def find_type_from_comment_hint_with ( context , node , name ) : [EOL] assert len ( node . children [ [number] ] . children ) == [number] , [string] [EOL] varlist = node . children [ [number] ] . children [ [number] ] [EOL] return _find_type_from_comment_hint ( context , node , varlist , name ) [EOL] [EOL] [EOL] def find_type_from_comment_hint_assign ( context , node , name ) : [EOL] return _find_type_from_comment_hint ( context , node , node . children [ [number] ] , name ) [EOL] [EOL] [EOL] def _find_type_from_comment_hint ( context , node , varlist , name ) : [EOL] index = None [EOL] if varlist . type in ( [string] , [string] ) : [EOL] [comment] [EOL] index = [number] [EOL] for child in varlist . children : [EOL] if child == name : [EOL] break [EOL] if child . type == [string] : [EOL] continue [EOL] index += [number] [EOL] else : [EOL] return [ ] [EOL] [EOL] comment = parser_utils . get_following_comment_same_line ( node ) [EOL] if comment is None : [EOL] return [ ] [EOL] match = re . match ( [string] , comment ) [EOL] if not match : [EOL] return [ ] [EOL] annotation = tree . String ( repr ( str ( match . group ( [number] ) . strip ( ) ) ) , node . start_pos ) [EOL] annotation . parent = node . parent [EOL] return _evaluate_for_annotation ( context , annotation , index ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] import copy [EOL] import sys [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi import debug [EOL] from jedi . common import unite [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate import recursion [EOL] from jedi . evaluate import iterable [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate import stdlib [EOL] from jedi . evaluate import finder [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import precedence [EOL] from jedi . evaluate import param [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate . filters import TreeNameDefinition , ParamName [EOL] from jedi . evaluate . instance import AnonymousInstance , BoundMethod [EOL] from jedi . evaluate . context import ContextualizedName , ContextualizedNode [EOL] from jedi import parser_utils [EOL] [EOL] [EOL] class Evaluator ( object ) : [EOL] def __init__ ( self , grammar , sys_path = None ) : [EOL] self . grammar = grammar [EOL] self . memoize_cache = { } [comment] [EOL] [comment] [EOL] self . modules = { } [comment] [EOL] self . compiled_cache = { } [comment] [EOL] self . mixed_cache = { } [comment] [EOL] self . analysis = [ ] [EOL] self . dynamic_params_depth = [number] [EOL] self . is_analysis = False [EOL] self . python_version = sys . version_info [ : [number] ] [EOL] [EOL] if sys_path is None : [EOL] sys_path = sys . path [EOL] self . sys_path = copy . copy ( sys_path ) [EOL] try : [EOL] self . sys_path . remove ( [string] ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] self . reset_recursion_limitations ( ) [EOL] [EOL] [comment] [EOL] self . BUILTINS = compiled . get_special_object ( self , [string] ) [EOL] [EOL] def reset_recursion_limitations ( self ) : [EOL] self . recursion_detector = recursion . RecursionDetector ( ) [EOL] self . execution_recursion_detector = recursion . ExecutionRecursionDetector ( self ) [EOL] [EOL] def find_types ( self , context , name_or_str , name_context , position = None , search_global = False , is_goto = False ) : [EOL] [docstring] [EOL] f = finder . NameFinder ( self , context , name_context , name_or_str , position ) [EOL] filters = f . get_filters ( search_global ) [EOL] if is_goto : [EOL] return f . filter_name ( filters ) [EOL] return f . find ( filters , attribute_lookup = not search_global ) [EOL] [EOL] def eval_statement ( self , context , stmt , seek_name = None ) : [EOL] with recursion . execution_allowed ( self , stmt ) as allowed : [EOL] if allowed or context . get_root_context ( ) == self . BUILTINS : [EOL] return self . _eval_stmt ( context , stmt , seek_name ) [EOL] return set ( ) [EOL] [EOL] [comment] [EOL] @ debug . increase_indent def _eval_stmt ( self , context , stmt , seek_name = None ) : [EOL] [docstring] [EOL] debug . dbg ( [string] , stmt , seek_name ) [EOL] rhs = stmt . get_rhs ( ) [EOL] types = self . eval_element ( context , rhs ) [EOL] [EOL] if seek_name : [EOL] c_node = ContextualizedName ( context , seek_name ) [EOL] types = finder . check_tuple_assignments ( self , c_node , types ) [EOL] [EOL] first_operator = next ( stmt . yield_operators ( ) , None ) [EOL] if first_operator not in ( [string] , None ) and first_operator . type == [string] : [EOL] [comment] [EOL] operator = copy . copy ( first_operator ) [EOL] operator . value = operator . value [ : - [number] ] [EOL] name = stmt . get_defined_names ( ) [ [number] ] . value [EOL] left = context . py__getattribute__ ( name , position = stmt . start_pos , search_global = True ) [EOL] [EOL] for_stmt = tree . search_ancestor ( stmt , [string] ) [EOL] if for_stmt is not None and for_stmt . type == [string] and types \ [EOL] and parser_utils . for_stmt_defines_one_name ( for_stmt ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] node = for_stmt . get_testlist ( ) [EOL] cn = ContextualizedNode ( context , node ) [EOL] ordered = list ( iterable . py__iter__ ( self , cn . infer ( ) , cn ) ) [EOL] [EOL] for lazy_context in ordered : [EOL] dct = { for_stmt . children [ [number] ] . value : lazy_context . infer ( ) } [EOL] with helpers . predefine_names ( context , for_stmt , dct ) : [EOL] t = self . eval_element ( context , rhs ) [EOL] left = precedence . calculate ( self , context , left , operator , t ) [EOL] types = left [EOL] else : [EOL] types = precedence . calculate ( self , context , left , operator , types ) [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] def eval_element ( self , context , element ) : [EOL] if isinstance ( context , iterable . CompForContext ) : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] [EOL] if_stmt = element [EOL] while if_stmt is not None : [EOL] if_stmt = if_stmt . parent [EOL] if if_stmt . type in ( [string] , [string] ) : [EOL] break [EOL] if parser_utils . is_scope ( if_stmt ) : [EOL] if_stmt = None [EOL] break [EOL] predefined_if_name_dict = context . predefined_names . get ( if_stmt ) [EOL] if predefined_if_name_dict is None and if_stmt and if_stmt . type == [string] : [EOL] if_stmt_test = if_stmt . children [ [number] ] [EOL] name_dicts = [ { } ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if element . start_pos > if_stmt_test . end_pos : [EOL] [comment] [EOL] [comment] [EOL] if_names = helpers . get_names_of_node ( if_stmt_test ) [EOL] element_names = helpers . get_names_of_node ( element ) [EOL] str_element_names = [ e . value for e in element_names ] [EOL] if any ( i . value in str_element_names for i in if_names ) : [EOL] for if_name in if_names : [EOL] definitions = self . goto_definitions ( context , if_name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( definitions ) > [number] : [EOL] if len ( name_dicts ) * len ( definitions ) > [number] : [EOL] debug . dbg ( [string] , if_stmt ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] name_dicts = [ { } ] [EOL] break [EOL] [EOL] original_name_dicts = list ( name_dicts ) [EOL] name_dicts = [ ] [EOL] for definition in definitions : [EOL] new_name_dicts = list ( original_name_dicts ) [EOL] for i , name_dict in enumerate ( new_name_dicts ) : [EOL] new_name_dicts [ i ] = name_dict . copy ( ) [EOL] new_name_dicts [ i ] [ if_name . value ] = set ( [ definition ] ) [EOL] [EOL] name_dicts += new_name_dicts [EOL] else : [EOL] for name_dict in name_dicts : [EOL] name_dict [ if_name . value ] = definitions [EOL] if len ( name_dicts ) > [number] : [EOL] result = set ( ) [EOL] for name_dict in name_dicts : [EOL] with helpers . predefine_names ( context , if_stmt , name_dict ) : [EOL] result |= self . _eval_element_not_cached ( context , element ) [EOL] return result [EOL] else : [EOL] return self . _eval_element_if_evaluated ( context , element ) [EOL] else : [EOL] if predefined_if_name_dict : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] else : [EOL] return self . _eval_element_if_evaluated ( context , element ) [EOL] [EOL] def _eval_element_if_evaluated ( self , context , element ) : [EOL] [docstring] [EOL] parent = element [EOL] while parent is not None : [EOL] parent = parent . parent [EOL] predefined_if_name_dict = context . predefined_names . get ( parent ) [EOL] if predefined_if_name_dict is not None : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] return self . _eval_element_cached ( context , element ) [EOL] [EOL] @ memoize_default ( default = set ( ) , evaluator_is_first_arg = True ) def _eval_element_cached ( self , context , element ) : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] [EOL] @ debug . increase_indent def _eval_element_not_cached ( self , context , element ) : [EOL] debug . dbg ( [string] , element , element . start_pos ) [EOL] types = set ( ) [EOL] typ = element . type [EOL] if typ in ( [string] , [string] , [string] , [string] ) : [EOL] types = self . eval_atom ( context , element ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] if element . value in ( [string] , [string] , [string] ) : [EOL] types . add ( compiled . builtin_from_name ( self , element . value ) ) [EOL] [comment] [EOL] elif typ == [string] : [EOL] types = set ( [ er . FunctionContext ( self , context , element ) ] ) [EOL] elif typ == [string] : [EOL] types = self . eval_statement ( context , element ) [EOL] elif typ in ( [string] , [string] ) : [EOL] first_child = element . children [ [number] ] [EOL] if not ( first_child . type == [string] and first_child . value == [string] ) : [EOL] types = self . eval_atom ( context , first_child ) [EOL] for trailer in element . children [ [number] : ] : [EOL] if trailer == [string] : [comment] [EOL] right = self . eval_element ( context , element . children [ [number] ] ) [EOL] types = set ( precedence . calculate ( self , context , types , trailer , right ) ) [EOL] break [EOL] types = self . eval_trailer ( context , types , trailer ) [EOL] elif typ in ( [string] , [string] , ) : [EOL] [comment] [EOL] types = set ( [ iterable . SequenceLiteralContext ( self , context , element ) ] ) [EOL] elif typ in ( [string] , [string] ) : [EOL] types = self . eval_element ( context , element . children [ - [number] ] ) [EOL] for operator in element . children [ : - [number] ] : [EOL] types = set ( precedence . factor_calculate ( self , types , operator ) ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] types = ( self . eval_element ( context , element . children [ [number] ] ) | self . eval_element ( context , element . children [ - [number] ] ) ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] assert element . value == [string] [EOL] types = set ( [ compiled . create ( self , Ellipsis ) ] ) [EOL] elif typ == [string] : [EOL] types = self . eval_atom ( context , element . children [ [number] ] ) [EOL] for next_name in element . children [ [number] : : [number] ] : [EOL] [comment] [EOL] types = unite ( typ . py__getattribute__ ( next_name , name_context = context ) for typ in types ) [EOL] types = types [EOL] elif typ == [string] : [EOL] types = self . _eval_element_not_cached ( context , element . children [ [number] ] ) [EOL] elif typ == [string] : [EOL] types = pep0484 . _evaluate_for_annotation ( context , element . children [ [number] ] ) [EOL] else : [EOL] types = precedence . calculate_children ( self , context , element . children ) [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] def eval_atom ( self , context , atom ) : [EOL] [docstring] [EOL] if atom . type == [string] : [EOL] [comment] [EOL] stmt = atom . get_definition ( ) [EOL] if stmt . type == [string] : [EOL] stmt = tree . search_ancestor ( stmt , [string] , [string] , [string] , [string] ) [EOL] if stmt is None or stmt . type != [string] : [EOL] [comment] [EOL] [comment] [EOL] stmt = atom [EOL] return context . py__getattribute__ ( name_or_str = atom , position = stmt . start_pos , search_global = True ) [EOL] elif isinstance ( atom , tree . Literal ) : [EOL] string = parser_utils . safe_literal_eval ( atom . value ) [EOL] return set ( [ compiled . create ( self , string ) ] ) [EOL] else : [EOL] c = atom . children [EOL] if c [ [number] ] . type == [string] : [EOL] [comment] [EOL] types = self . eval_atom ( context , c [ [number] ] ) [EOL] for string in c [ [number] : ] : [EOL] right = self . eval_atom ( context , string ) [EOL] types = precedence . calculate ( self , context , types , [string] , right ) [EOL] return types [EOL] [comment] [EOL] elif c [ [number] ] == [string] and not len ( c ) == [number] \ [EOL] and not ( c [ [number] ] . type == [string] and len ( c [ [number] ] . children ) > [number] ) : [EOL] return self . eval_element ( context , c [ [number] ] ) [EOL] [EOL] try : [EOL] comp_for = c [ [number] ] . children [ [number] ] [EOL] except ( IndexError , AttributeError ) : [EOL] pass [EOL] else : [EOL] if comp_for == [string] : [EOL] [comment] [EOL] try : [EOL] comp_for = c [ [number] ] . children [ [number] ] [EOL] except IndexError : [EOL] pass [EOL] [EOL] if comp_for . type == [string] : [EOL] return set ( [ iterable . Comprehension . from_atom ( self , context , atom ) ] ) [EOL] [EOL] [comment] [EOL] array_node = c [ [number] ] [EOL] try : [EOL] array_node_c = array_node . children [EOL] except AttributeError : [EOL] array_node_c = [ ] [EOL] if c [ [number] ] == [string] and ( array_node == [string] or [string] in array_node_c ) : [EOL] context = iterable . DictLiteralContext ( self , context , atom ) [EOL] else : [EOL] context = iterable . SequenceLiteralContext ( self , context , atom ) [EOL] return set ( [ context ] ) [EOL] [EOL] def eval_trailer ( self , context , types , trailer ) : [EOL] trailer_op , node = trailer . children [ : [number] ] [EOL] if node == [string] : [comment] [EOL] node = ( ) [EOL] [EOL] new_types = set ( ) [EOL] if trailer_op == [string] : [EOL] new_types |= iterable . py__getitem__ ( self , context , types , trailer ) [EOL] else : [EOL] for typ in types : [EOL] debug . dbg ( [string] , trailer , typ ) [EOL] if trailer_op == [string] : [EOL] new_types |= typ . py__getattribute__ ( name_context = context , name_or_str = node ) [EOL] elif trailer_op == [string] : [EOL] arguments = param . TreeArguments ( self , context , node , trailer ) [EOL] new_types |= self . execute ( typ , arguments ) [EOL] return new_types [EOL] [EOL] @ debug . increase_indent def execute ( self , obj , arguments ) : [EOL] if not isinstance ( arguments , param . AbstractArguments ) : [EOL] raise NotImplementedError [EOL] arguments = param . Arguments ( self , arguments ) [EOL] [EOL] if self . is_analysis : [EOL] arguments . eval_all ( ) [EOL] [EOL] debug . dbg ( [string] , obj , arguments ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] return stdlib . execute ( self , obj , arguments ) [EOL] except stdlib . NotInStdLib : [EOL] pass [EOL] [EOL] try : [EOL] func = obj . py__call__ [EOL] except AttributeError : [EOL] debug . warning ( [string] , obj ) [EOL] return set ( ) [EOL] else : [EOL] types = func ( arguments ) [EOL] debug . dbg ( [string] , types , obj ) [EOL] return types [EOL] [EOL] def goto_definitions ( self , context , name ) : [EOL] def_ = name . get_definition ( ) [EOL] is_simple_name = name . parent . type not in ( [string] , [string] ) [EOL] if is_simple_name : [EOL] if name . parent . type == [string] and name . parent . name == name : [EOL] return [ er . ClassContext ( self , name . parent , context ) ] [EOL] elif name . parent . type == [string] : [EOL] return [ er . FunctionContext ( self , context , name . parent ) ] [EOL] elif name . parent . type == [string] : [EOL] raise NotImplementedError [EOL] if def_ . type == [string] and name in def_ . get_defined_names ( ) : [EOL] return self . eval_statement ( context , def_ , name ) [EOL] elif def_ . type == [string] and name . start_pos < def_ . children [ [number] ] . end_pos : [EOL] container_types = self . eval_element ( context , def_ . children [ [number] ] ) [EOL] cn = ContextualizedNode ( context , def_ . children [ [number] ] ) [EOL] for_types = iterable . py__iter__types ( self , container_types , cn ) [EOL] c_node = ContextualizedName ( context , name ) [EOL] return finder . check_tuple_assignments ( self , c_node , for_types ) [EOL] elif def_ . type in ( [string] , [string] ) : [EOL] return imports . infer_import ( context , name ) [EOL] [EOL] return helpers . evaluate_call_of_leaf ( context , name ) [EOL] [EOL] def goto ( self , context , name ) : [EOL] stmt = name . get_definition ( ) [EOL] par = name . parent [EOL] typ = par . type [EOL] if typ == [string] and par . children [ [number] ] == [string] and par . children [ [number] ] == name : [EOL] [comment] [EOL] trailer = par . parent [EOL] if trailer . type == [string] : [EOL] trailer = trailer . parent [EOL] if trailer . type != [string] : [EOL] if trailer . type == [string] : [EOL] types = self . eval_element ( context , trailer . children [ [number] ] ) [EOL] else : [EOL] i = trailer . parent . children . index ( trailer ) [EOL] to_evaluate = trailer . parent . children [ : i ] [EOL] types = self . eval_element ( context , to_evaluate [ [number] ] ) [EOL] for trailer in to_evaluate [ [number] : ] : [EOL] types = self . eval_trailer ( context , types , trailer ) [EOL] param_names = [ ] [EOL] for typ in types : [EOL] try : [EOL] get_param_names = typ . get_param_names [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] for param_name in get_param_names ( ) : [EOL] if param_name . string_name == name . value : [EOL] param_names . append ( param_name ) [EOL] return param_names [EOL] elif typ == [string] and name in par . get_defined_names ( ) : [EOL] [comment] [EOL] [comment] [EOL] return [ TreeNameDefinition ( context , name ) ] [EOL] elif typ == [string] and par . name : [EOL] return [ ParamName ( context , name ) ] [EOL] elif typ in ( [string] , [string] , [string] ) and par . name is name : [EOL] return [ TreeNameDefinition ( context , name ) ] [EOL] elif isinstance ( stmt , tree . Import ) : [EOL] module_names = imports . infer_import ( context , name , is_goto = True ) [EOL] return module_names [EOL] elif typ == [string] : [comment] [EOL] index = par . children . index ( name ) [EOL] if index > [number] : [EOL] new_dotted = helpers . deep_ast_copy ( par ) [EOL] new_dotted . children [ index - [number] : ] = [ ] [EOL] values = self . eval_element ( context , new_dotted ) [EOL] return unite ( value . py__getattribute__ ( name , name_context = context , is_goto = True ) for value in values ) [EOL] [EOL] if typ == [string] and par . children [ [number] ] == [string] : [EOL] values = helpers . evaluate_call_of_leaf ( context , name , cut_own_trailer = True ) [EOL] return unite ( value . py__getattribute__ ( name , name_context = context , is_goto = True ) for value in values ) [EOL] else : [EOL] if stmt . type != [string] : [EOL] [comment] [EOL] [comment] [EOL] stmt = name [EOL] return context . py__getattribute__ ( name , position = stmt . start_pos , search_global = True , is_goto = True ) [EOL] [EOL] def create_context ( self , base_context , node , node_is_context = False , node_is_object = False ) : [EOL] def parent_scope ( node ) : [EOL] while True : [EOL] node = node . parent [EOL] [EOL] if parser_utils . is_scope ( node ) : [EOL] return node [EOL] elif node . type in ( [string] , [string] ) : [EOL] if node . children [ [number] ] . type == [string] : [EOL] return node . children [ [number] ] [EOL] elif node . type == [string] : [EOL] for n in node . children [ [number] : [number] ] : [EOL] [comment] [EOL] if n . type == [string] : [EOL] return n [EOL] [EOL] def from_scope_node ( scope_node , child_is_funcdef = None , is_nested = True , node_is_object = False ) : [EOL] if scope_node == base_node : [EOL] return base_context [EOL] [EOL] is_funcdef = scope_node . type in ( [string] , [string] ) [EOL] parent_scope = parser_utils . get_parent_scope ( scope_node ) [EOL] parent_context = from_scope_node ( parent_scope , child_is_funcdef = is_funcdef ) [EOL] [EOL] if is_funcdef : [EOL] if isinstance ( parent_context , AnonymousInstance ) : [EOL] func = BoundMethod ( self , parent_context , parent_context . class_context , parent_context . parent_context , scope_node ) [EOL] else : [EOL] func = er . FunctionContext ( self , parent_context , scope_node ) [EOL] if is_nested and not node_is_object : [EOL] return func . get_function_execution ( ) [EOL] return func [EOL] elif scope_node . type == [string] : [EOL] class_context = er . ClassContext ( self , scope_node , parent_context ) [EOL] if child_is_funcdef : [EOL] [comment] [EOL] return AnonymousInstance ( self , parent_context , class_context ) [EOL] else : [EOL] return class_context [EOL] elif scope_node . type == [string] : [EOL] if node . start_pos >= scope_node . children [ - [number] ] . start_pos : [EOL] return parent_context [EOL] return iterable . CompForContext . from_comp_for ( parent_context , scope_node ) [EOL] raise Exception ( [string] ) [EOL] [EOL] base_node = base_context . tree_node [EOL] [EOL] if node_is_context and parser_utils . is_scope ( node ) : [EOL] scope_node = node [EOL] else : [EOL] if node . parent . type in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] node = node . parent [EOL] scope_node = parent_scope ( node ) [EOL] return from_scope_node ( scope_node , is_nested = True , node_is_object = node_is_object ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Callable , Any , Set [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import sys [EOL] import os [EOL] [EOL] [EOL] def makepath ( * paths ) : [EOL] dir = os . path . join ( * paths ) [EOL] try : [EOL] dir = os . path . abspath ( dir ) [EOL] except OSError : [EOL] pass [EOL] return dir , os . path . normcase ( dir ) [EOL] [EOL] [EOL] def _init_pathinfo ( sys_path ) : [EOL] [docstring] [EOL] d = set ( ) [EOL] for dir in sys_path : [EOL] try : [EOL] if os . path . isdir ( dir ) : [EOL] dir , dircase = makepath ( dir ) [EOL] d . add ( dircase ) [EOL] except TypeError : [EOL] continue [EOL] return d [EOL] [EOL] [EOL] def addpackage ( sys_path , sitedir , name , known_paths ) : [EOL] [docstring] [EOL] if known_paths is None : [EOL] known_paths = _init_pathinfo ( sys_path ) [EOL] reset = [number] [EOL] else : [EOL] reset = [number] [EOL] fullname = os . path . join ( sitedir , name ) [EOL] try : [EOL] f = open ( fullname , [string] ) [EOL] except OSError : [EOL] return [EOL] with f : [EOL] for n , line in enumerate ( f ) : [EOL] if line . startswith ( [string] ) : [EOL] continue [EOL] try : [EOL] if line . startswith ( ( [string] , [string] ) ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] line = line . rstrip ( ) [EOL] dir , dircase = makepath ( sitedir , line ) [EOL] if not dircase in known_paths and os . path . exists ( dir ) : [EOL] sys_path . append ( dir ) [EOL] known_paths . add ( dircase ) [EOL] except Exception : [EOL] print ( [string] . format ( n + [number] , fullname ) , file = sys . stderr ) [EOL] import traceback [EOL] for record in traceback . format_exception ( * sys . exc_info ( ) ) : [EOL] for line in record . splitlines ( ) : [EOL] print ( [string] + line , file = sys . stderr ) [EOL] print ( [string] , file = sys . stderr ) [EOL] break [EOL] if reset : [EOL] known_paths = None [EOL] return known_paths [EOL] [EOL] [EOL] def addsitedir ( sys_path , sitedir , known_paths = None ) : [EOL] [docstring] [EOL] if known_paths is None : [EOL] known_paths = _init_pathinfo ( sys_path ) [EOL] reset = [number] [EOL] else : [EOL] reset = [number] [EOL] sitedir , sitedircase = makepath ( sitedir ) [EOL] if not sitedircase in known_paths : [EOL] sys_path . append ( sitedir ) [comment] [EOL] known_paths . add ( sitedircase ) [EOL] try : [EOL] names = os . listdir ( sitedir ) [EOL] except OSError : [EOL] return [EOL] names = [ name for name in names if name . endswith ( [string] ) ] [EOL] for name in sorted ( names ) : [EOL] addpackage ( sys_path , sitedir , name , known_paths ) [EOL] if reset : [EOL] known_paths = None [EOL] return known_paths [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Set [EOL] import typing [EOL] from jedi . parser_utils import get_flow_branch_keyword , is_scope , get_parent_scope [EOL] [EOL] [EOL] class Status ( object ) : [EOL] lookup_table = { } [EOL] [EOL] def __init__ ( self , value , name ) : [EOL] self . _value = value [EOL] self . _name = name [EOL] Status . lookup_table [ value ] = self [EOL] [EOL] def invert ( self ) : [EOL] if self is REACHABLE : [EOL] return UNREACHABLE [EOL] elif self is UNREACHABLE : [EOL] return REACHABLE [EOL] else : [EOL] return UNSURE [EOL] [EOL] def __and__ ( self , other ) : [EOL] if UNSURE in ( self , other ) : [EOL] return UNSURE [EOL] else : [EOL] return REACHABLE if self . _value and other . _value else UNREACHABLE [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _name ) [EOL] [EOL] [EOL] REACHABLE = Status ( True , [string] ) [EOL] UNREACHABLE = Status ( False , [string] ) [EOL] UNSURE = Status ( None , [string] ) [EOL] [EOL] [EOL] def _get_flow_scopes ( node ) : [EOL] while True : [EOL] node = get_parent_scope ( node , include_flows = True ) [EOL] if node is None or is_scope ( node ) : [EOL] return [EOL] yield node [EOL] [EOL] [EOL] def reachability_check ( context , context_scope , node , origin_scope = None ) : [EOL] first_flow_scope = get_parent_scope ( node , include_flows = True ) [EOL] if origin_scope is not None : [EOL] origin_flow_scopes = list ( _get_flow_scopes ( origin_scope ) ) [EOL] node_flow_scopes = list ( _get_flow_scopes ( node ) ) [EOL] [EOL] branch_matches = True [EOL] for flow_scope in origin_flow_scopes : [EOL] if flow_scope in node_flow_scopes : [EOL] node_keyword = get_flow_branch_keyword ( flow_scope , node ) [EOL] origin_keyword = get_flow_branch_keyword ( flow_scope , origin_scope ) [EOL] branch_matches = node_keyword == origin_keyword [EOL] if flow_scope . type == [string] : [EOL] if not branch_matches : [EOL] return UNREACHABLE [EOL] elif flow_scope . type == [string] : [EOL] if not branch_matches and origin_keyword == [string] \ [EOL] and node_keyword == [string] : [EOL] return UNREACHABLE [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while origin_scope is not None : [EOL] if first_flow_scope == origin_scope and branch_matches : [EOL] return REACHABLE [EOL] origin_scope = origin_scope . parent [EOL] [EOL] return _break_check ( context , context_scope , first_flow_scope , node ) [EOL] [EOL] [EOL] def _break_check ( context , context_scope , flow_scope , node ) : [EOL] reachable = REACHABLE [EOL] if flow_scope . type == [string] : [EOL] if flow_scope . is_node_after_else ( node ) : [EOL] for check_node in flow_scope . get_test_nodes ( ) : [EOL] reachable = _check_if ( context , check_node ) [EOL] if reachable in ( REACHABLE , UNSURE ) : [EOL] break [EOL] reachable = reachable . invert ( ) [EOL] else : [EOL] flow_node = flow_scope . get_corresponding_test_node ( node ) [EOL] if flow_node is not None : [EOL] reachable = _check_if ( context , flow_node ) [EOL] elif flow_scope . type in ( [string] , [string] ) : [EOL] return UNSURE [EOL] [EOL] [comment] [EOL] if reachable in ( UNREACHABLE , UNSURE ) : [EOL] return reachable [EOL] [EOL] if context_scope != flow_scope and context_scope != flow_scope . parent : [EOL] flow_scope = get_parent_scope ( flow_scope , include_flows = True ) [EOL] return reachable & _break_check ( context , context_scope , flow_scope , node ) [EOL] else : [EOL] return reachable [EOL] [EOL] [EOL] def _check_if ( context , node ) : [EOL] types = context . eval_node ( node ) [EOL] values = set ( x . py__bool__ ( ) for x in types ) [EOL] if len ( values ) == [number] : [EOL] return Status . lookup_table [ values . pop ( ) ] [EOL] else : [EOL] return UNSURE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , Tuple , Iterator [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi import settings [EOL] from jedi import debug [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate . param import TreeArguments , create_default_param [EOL] from jedi . common import to_list , unite [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] MAX_PARAM_SEARCHES = [number] [EOL] [EOL] [EOL] class ParamListener ( object ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . param_possibilities = [ ] [EOL] [EOL] def execute ( self , params ) : [EOL] self . param_possibilities += params [EOL] [EOL] [EOL] class MergedExecutedParams ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , executed_params ) : [EOL] self . _executed_params = executed_params [EOL] [EOL] def infer ( self ) : [EOL] return unite ( p . infer ( ) for p in self . _executed_params ) [EOL] [EOL] [EOL] @ debug . increase_indent def search_params ( evaluator , execution_context , funcdef ) : [EOL] [docstring] [EOL] if not settings . dynamic_params : [EOL] return set ( ) [EOL] [EOL] evaluator . dynamic_params_depth += [number] [EOL] try : [EOL] debug . dbg ( [string] , funcdef . name . value , color = [string] ) [EOL] module_context = execution_context . get_root_context ( ) [EOL] function_executions = _search_function_executions ( evaluator , module_context , funcdef ) [EOL] if function_executions : [EOL] zipped_params = zip ( * list ( function_execution . get_params ( ) for function_execution in function_executions ) ) [EOL] params = [ MergedExecutedParams ( executed_params ) for executed_params in zipped_params ] [EOL] [comment] [EOL] else : [EOL] params = [ create_default_param ( execution_context , p ) for p in funcdef . params ] [EOL] debug . dbg ( [string] , color = [string] ) [EOL] return params [EOL] finally : [EOL] evaluator . dynamic_params_depth -= [number] [EOL] [EOL] [EOL] @ memoize_default ( [ ] , evaluator_is_first_arg = True ) @ to_list def _search_function_executions ( evaluator , module_context , funcdef ) : [EOL] [docstring] [EOL] from jedi . evaluate import representation as er [EOL] [EOL] func_string_name = funcdef . name . value [EOL] compare_node = funcdef [EOL] if func_string_name == [string] : [EOL] cls = get_parent_scope ( funcdef ) [EOL] if isinstance ( cls , tree . Class ) : [EOL] func_string_name = cls . name . value [EOL] compare_node = cls [EOL] [EOL] found_executions = False [EOL] i = [number] [EOL] for for_mod_context in imports . get_modules_containing_name ( evaluator , [ module_context ] , func_string_name ) : [EOL] if not isinstance ( module_context , er . ModuleContext ) : [EOL] return [EOL] for name , trailer in _get_possible_nodes ( for_mod_context , func_string_name ) : [EOL] i += [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if i * evaluator . dynamic_params_depth > MAX_PARAM_SEARCHES : [EOL] return [EOL] [EOL] random_context = evaluator . create_context ( for_mod_context , name ) [EOL] for function_execution in _check_name_for_execution ( evaluator , random_context , compare_node , name , trailer ) : [EOL] found_executions = True [EOL] yield function_execution [EOL] [EOL] [comment] [EOL] [comment] [EOL] if found_executions : [EOL] return [EOL] [EOL] [EOL] def _get_possible_nodes ( module_context , func_string_name ) : [EOL] try : [EOL] names = module_context . tree_node . get_used_names ( ) [ func_string_name ] [EOL] except KeyError : [EOL] return [EOL] [EOL] for name in names : [EOL] bracket = name . get_next_leaf ( ) [EOL] trailer = bracket . parent [EOL] if trailer . type == [string] and bracket == [string] : [EOL] yield name , trailer [EOL] [EOL] [EOL] def _check_name_for_execution ( evaluator , context , compare_node , name , trailer ) : [EOL] from jedi . evaluate import representation as er , instance [EOL] [EOL] def create_func_excs ( ) : [EOL] arglist = trailer . children [ [number] ] [EOL] if arglist == [string] : [EOL] arglist = ( ) [EOL] args = TreeArguments ( evaluator , context , arglist , trailer ) [EOL] if value_node . type == [string] : [EOL] yield value . get_function_execution ( args ) [EOL] else : [EOL] created_instance = instance . TreeInstance ( evaluator , value . parent_context , value , args ) [EOL] for execution in created_instance . create_init_executions ( ) : [EOL] yield execution [EOL] [EOL] for value in evaluator . goto_definitions ( context , name ) : [EOL] value_node = value . tree_node [EOL] if compare_node == value_node : [EOL] for func_execution in create_func_excs ( ) : [EOL] yield func_execution [EOL] elif isinstance ( value . parent_context , er . FunctionExecutionContext ) and compare_node . type == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] params = value . parent_context . get_params ( ) [EOL] if len ( params ) != [number] : [EOL] continue [EOL] values = params [ [number] ] . infer ( ) [EOL] nodes = [ v . tree_node for v in values ] [EOL] if nodes == [ compare_node ] : [EOL] [comment] [EOL] module_context = context . get_root_context ( ) [EOL] execution_context = next ( create_func_excs ( ) ) [EOL] for name , trailer in _get_possible_nodes ( module_context , params [ [number] ] . string_name ) : [EOL] if value_node . start_pos < name . start_pos < value_node . end_pos : [EOL] random_context = evaluator . create_context ( execution_context , name ) [EOL] iterator = _check_name_for_execution ( evaluator , random_context , compare_node , name , trailer ) [EOL] for function_execution in iterator : [EOL] yield function_execution [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from jedi . _compatibility import Python3Method [EOL] from jedi . common import unite [EOL] from jedi . parser . python . tree import ExprStmt , CompFor [EOL] from jedi . parser_utils import clean_scope_docstring , get_doc_with_call_signature [EOL] [EOL] [EOL] class Context ( object ) : [EOL] api_type = None [EOL] [docstring] [EOL] predefined_names = { } [EOL] tree_node = None [EOL] [EOL] def __init__ ( self , evaluator , parent_context = None ) : [EOL] self . evaluator = evaluator [EOL] self . parent_context = parent_context [EOL] [EOL] def get_root_context ( self ) : [EOL] context = self [EOL] while True : [EOL] if context . parent_context is None : [EOL] return context [EOL] context = context . parent_context [EOL] [EOL] def execute ( self , arguments ) : [EOL] return self . evaluator . execute ( self , arguments ) [EOL] [EOL] def execute_evaluated ( self , * value_list ) : [EOL] [docstring] [EOL] from jedi . evaluate . param import ValuesArguments [EOL] arguments = ValuesArguments ( [ [ value ] for value in value_list ] ) [EOL] return self . execute ( arguments ) [EOL] [EOL] def eval_node ( self , node ) : [EOL] return self . evaluator . eval_element ( self , node ) [EOL] [EOL] def eval_stmt ( self , stmt , seek_name = None ) : [EOL] return self . evaluator . eval_statement ( self , stmt , seek_name ) [EOL] [EOL] def eval_trailer ( self , types , trailer ) : [EOL] return self . evaluator . eval_trailer ( self , types , trailer ) [EOL] [EOL] @ Python3Method def py__getattribute__ ( self , name_or_str , name_context = None , position = None , search_global = False , is_goto = False ) : [EOL] if name_context is None : [EOL] name_context = self [EOL] return self . evaluator . find_types ( self , name_or_str , name_context , position , search_global , is_goto ) [EOL] [EOL] def create_context ( self , node , node_is_context = False , node_is_object = False ) : [EOL] return self . evaluator . create_context ( self , node , node_is_context , node_is_object ) [EOL] [EOL] def is_class ( self ) : [EOL] return False [EOL] [EOL] def py__bool__ ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def py__doc__ ( self , include_call_signature = False ) : [EOL] try : [EOL] self . tree_node . get_doc_node [EOL] except AttributeError : [EOL] return [string] [EOL] else : [EOL] if include_call_signature : [EOL] return get_doc_with_call_signature ( self . tree_node ) [EOL] else : [EOL] return clean_scope_docstring ( self . tree_node ) [EOL] return None [EOL] [EOL] [EOL] class TreeContext ( Context ) : [EOL] def __init__ ( self , evaluator , parent_context = None ) : [EOL] super ( TreeContext , self ) . __init__ ( evaluator , parent_context ) [EOL] self . predefined_names = { } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . tree_node ) [EOL] [EOL] [EOL] class AbstractLazyContext ( object ) : [EOL] def __init__ ( self , data ) : [EOL] self . data = data [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . data ) [EOL] [EOL] def infer ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class LazyKnownContext ( AbstractLazyContext ) : [EOL] [docstring] [EOL] def infer ( self ) : [EOL] return set ( [ self . data ] ) [EOL] [EOL] [EOL] class LazyKnownContexts ( AbstractLazyContext ) : [EOL] [docstring] [EOL] def infer ( self ) : [EOL] return self . data [EOL] [EOL] [EOL] class LazyUnknownContext ( AbstractLazyContext ) : [EOL] def __init__ ( self ) : [EOL] super ( LazyUnknownContext , self ) . __init__ ( None ) [EOL] [EOL] def infer ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class LazyTreeContext ( AbstractLazyContext ) : [EOL] def __init__ ( self , context , node ) : [EOL] super ( LazyTreeContext , self ) . __init__ ( node ) [EOL] self . _context = context [EOL] [comment] [EOL] [comment] [EOL] self . _predefined_names = dict ( context . predefined_names ) [EOL] [EOL] def infer ( self ) : [EOL] old , self . _context . predefined_names = self . _context . predefined_names , self . _predefined_names [EOL] try : [EOL] return self . _context . eval_node ( self . data ) [EOL] finally : [EOL] self . _context . predefined_names = old [EOL] [EOL] [EOL] def get_merged_lazy_context ( lazy_contexts ) : [EOL] if len ( lazy_contexts ) > [number] : [EOL] return MergedLazyContexts ( lazy_contexts ) [EOL] else : [EOL] return lazy_contexts [ [number] ] [EOL] [EOL] [EOL] class MergedLazyContexts ( AbstractLazyContext ) : [EOL] [docstring] [EOL] def infer ( self ) : [EOL] return unite ( l . infer ( ) for l in self . data ) [EOL] [EOL] [EOL] class ContextualizedNode ( object ) : [EOL] def __init__ ( self , context , node ) : [EOL] self . context = context [EOL] self . _node = node [EOL] [EOL] def get_root_context ( self ) : [EOL] return self . context . get_root_context ( ) [EOL] [EOL] def infer ( self ) : [EOL] return self . context . eval_node ( self . _node ) [EOL] [EOL] [EOL] class ContextualizedName ( ContextualizedNode ) : [EOL] [comment] [EOL] @ property def name ( self ) : [EOL] return self . _node [EOL] [EOL] def assignment_indexes ( self ) : [EOL] [docstring] [EOL] indexes = [ ] [EOL] node = self . _node . parent [EOL] compare = self . _node [EOL] while node is not None : [EOL] if node . type in ( [string] , [string] , [string] ) : [EOL] for i , child in enumerate ( node . children ) : [EOL] if child == compare : [EOL] indexes . insert ( [number] , ( int ( i / [number] ) , node ) ) [EOL] break [EOL] else : [EOL] raise LookupError ( [string] ) [EOL] elif isinstance ( node , ( ExprStmt , CompFor ) ) : [EOL] break [EOL] [EOL] compare = node [EOL] node = node . parent [EOL] return indexes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import List , Any [EOL] import typing [EOL] import copy [EOL] from itertools import chain [EOL] from contextlib import contextmanager [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] def deep_ast_copy ( obj ) : [EOL] [docstring] [EOL] [comment] [EOL] new_obj = copy . copy ( obj ) [EOL] [EOL] [comment] [EOL] new_children = [ ] [EOL] for child in obj . children : [EOL] if isinstance ( child , tree . Leaf ) : [EOL] new_child = copy . copy ( child ) [EOL] new_child . parent = new_obj [EOL] else : [EOL] new_child = deep_ast_copy ( child ) [EOL] new_child . parent = new_obj [EOL] new_children . append ( new_child ) [EOL] new_obj . children = new_children [EOL] [EOL] return new_obj [EOL] [EOL] [EOL] def evaluate_call_of_leaf ( context , leaf , cut_own_trailer = False ) : [EOL] [docstring] [EOL] trailer = leaf . parent [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if trailer . type != [string] or leaf not in ( trailer . children [ [number] ] , trailer . children [ - [number] ] ) : [EOL] if trailer . type == [string] : [EOL] return context . eval_node ( trailer ) [EOL] return context . eval_node ( leaf ) [EOL] [EOL] power = trailer . parent [EOL] index = power . children . index ( trailer ) [EOL] if cut_own_trailer : [EOL] cut = index [EOL] else : [EOL] cut = index + [number] [EOL] [EOL] if power . type == [string] : [EOL] start = index [EOL] while True : [EOL] start -= [number] [EOL] base = power . children [ start ] [EOL] if base . type != [string] : [EOL] break [EOL] trailers = power . children [ start + [number] : index + [number] ] [EOL] else : [EOL] base = power . children [ [number] ] [EOL] trailers = power . children [ [number] : cut ] [EOL] [EOL] values = context . eval_node ( base ) [EOL] for trailer in trailers : [EOL] values = context . eval_trailer ( values , trailer ) [EOL] return values [EOL] [EOL] [EOL] def call_of_leaf ( leaf ) : [EOL] [docstring] [EOL] [comment] [EOL] trailer = leaf . parent [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if trailer . type != [string] or leaf not in ( trailer . children [ [number] ] , trailer . children [ - [number] ] ) : [EOL] if trailer . type == [string] : [EOL] return trailer [EOL] return leaf [EOL] [EOL] power = trailer . parent [EOL] index = power . children . index ( trailer ) [EOL] [EOL] new_power = copy . copy ( power ) [EOL] new_power . children = list ( new_power . children ) [EOL] new_power . children [ index + [number] : ] = [ ] [EOL] [EOL] if power . type == [string] : [EOL] start = index [EOL] while True : [EOL] start -= [number] [EOL] if power . children [ start ] . type != [string] : [EOL] break [EOL] transformed = tree . Node ( [string] , power . children [ start : ] ) [EOL] transformed . parent = power . parent [EOL] return transformed [EOL] [EOL] return power [EOL] [EOL] [EOL] def get_names_of_node ( node ) : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] if node . type == [string] : [EOL] return [ node ] [EOL] else : [EOL] return [ ] [EOL] else : [EOL] return list ( chain . from_iterable ( get_names_of_node ( c ) for c in children ) ) [EOL] [EOL] [EOL] def get_module_names ( module , all_scopes ) : [EOL] [docstring] [EOL] names = chain . from_iterable ( module . get_used_names ( ) . values ( ) ) [EOL] if not all_scopes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] names = [ n for n in names if get_parent_scope ( n ) . parent in ( module , None ) ] [EOL] return names [EOL] [EOL] [EOL] @ contextmanager def predefine_names ( context , flow_scope , dct ) : [EOL] predefined = context . predefined_names [EOL] if flow_scope in predefined : [EOL] raise NotImplementedError ( [string] ) [EOL] predefined [ flow_scope ] = dct [EOL] try : [EOL] yield [EOL] finally : [EOL] del predefined [ flow_scope ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from contextlib import contextmanager [EOL] [EOL] from jedi import debug [EOL] from jedi import settings [EOL] [EOL] [EOL] class RecursionDetector ( object ) : [EOL] def __init__ ( self ) : [EOL] self . pushed_nodes = [ ] [EOL] [EOL] [EOL] @ contextmanager def execution_allowed ( evaluator , node ) : [EOL] [docstring] [EOL] pushed_nodes = evaluator . recursion_detector . pushed_nodes [EOL] [EOL] if node in pushed_nodes : [EOL] debug . warning ( [string] , node , node . start_pos ) [EOL] yield False [EOL] else : [EOL] pushed_nodes . append ( node ) [EOL] yield True [EOL] pushed_nodes . pop ( ) [EOL] [EOL] [EOL] def execution_recursion_decorator ( default = set ( ) ) : [EOL] def decorator ( func ) : [EOL] def wrapper ( execution , ** kwargs ) : [EOL] detector = execution . evaluator . execution_recursion_detector [EOL] allowed = detector . push_execution ( execution ) [EOL] try : [EOL] if allowed : [EOL] result = default [EOL] else : [EOL] result = func ( execution , ** kwargs ) [EOL] finally : [EOL] detector . pop_execution ( ) [EOL] return result [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] class ExecutionRecursionDetector ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , evaluator ) : [EOL] self . recursion_level = [number] [EOL] self . parent_execution_funcs = [ ] [EOL] self . execution_funcs = set ( ) [EOL] self . execution_count = [number] [EOL] self . _evaluator = evaluator [EOL] [EOL] def __call__ ( self , execution ) : [EOL] debug . dbg ( [string] , execution , self . recursion_level , self . execution_count , len ( self . execution_funcs ) ) [EOL] if self . check_recursion ( execution ) : [EOL] result = set ( ) [EOL] else : [EOL] result = self . func ( execution ) [EOL] self . pop_execution ( ) [EOL] return result [EOL] [EOL] def pop_execution ( self ) : [EOL] self . parent_execution_funcs . pop ( ) [EOL] self . recursion_level -= [number] [EOL] [EOL] def push_execution ( self , execution ) : [EOL] in_par_execution_funcs = execution . tree_node in self . parent_execution_funcs [EOL] in_execution_funcs = execution . tree_node in self . execution_funcs [EOL] self . recursion_level += [number] [EOL] self . execution_count += [number] [EOL] self . execution_funcs . add ( execution . tree_node ) [EOL] self . parent_execution_funcs . append ( execution . tree_node ) [EOL] [EOL] if self . execution_count > settings . max_executions : [EOL] return True [EOL] [EOL] module = execution . get_root_context ( ) [EOL] if module == self . _evaluator . BUILTINS : [EOL] return False [EOL] [EOL] if in_par_execution_funcs : [EOL] if self . recursion_level > settings . max_function_recursion_level : [EOL] return True [EOL] if in_execution_funcs and len ( self . execution_funcs ) > settings . max_until_execution_unique : [EOL] return True [EOL] if self . execution_count > settings . max_executions_without_builtins : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Union , Type , Set , Iterator , Dict , Callable [EOL] import typing [EOL] import operator [EOL] [docstring] [EOL] import operator as op [EOL] [EOL] from jedi . _compatibility import unicode [EOL] from jedi . parser . python import tree [EOL] from jedi import debug [EOL] from jedi . evaluate . compiled import CompiledObject , create , builtin_from_name [EOL] from jedi . evaluate import analysis [EOL] [EOL] [comment] [EOL] COMPARISON_OPERATORS = { [string] : op . eq , [string] : op . ne , [string] : op . is_ , [string] : op . is_not , [string] : op . lt , [string] : op . le , [string] : op . gt , [string] : op . ge , } [EOL] [EOL] [EOL] def literals_to_types ( evaluator , result ) : [EOL] [comment] [EOL] [comment] [EOL] new_result = set ( ) [EOL] for typ in result : [EOL] if is_literal ( typ ) : [EOL] [comment] [EOL] [comment] [EOL] cls = builtin_from_name ( evaluator , typ . name . string_name ) [EOL] new_result |= cls . execute_evaluated ( ) [EOL] else : [EOL] new_result . add ( typ ) [EOL] return new_result [EOL] [EOL] [EOL] def calculate_children ( evaluator , context , children ) : [EOL] [docstring] [EOL] iterator = iter ( children ) [EOL] types = context . eval_node ( next ( iterator ) ) [EOL] for operator in iterator : [EOL] right = next ( iterator ) [EOL] if operator . type == [string] : [comment] [EOL] operator = [string] . join ( c . value for c in operator . children ) [EOL] [EOL] [comment] [EOL] if operator in ( [string] , [string] ) : [EOL] left_bools = set ( [ left . py__bool__ ( ) for left in types ] ) [EOL] if left_bools == set ( [ True ] ) : [EOL] if operator == [string] : [EOL] types = context . eval_node ( right ) [EOL] elif left_bools == set ( [ False ] ) : [EOL] if operator != [string] : [EOL] types = context . eval_node ( right ) [EOL] [comment] [EOL] else : [EOL] types = calculate ( evaluator , context , types , operator , context . eval_node ( right ) ) [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] [EOL] def calculate ( evaluator , context , left_result , operator , right_result ) : [EOL] result = set ( ) [EOL] if not left_result or not right_result : [EOL] [comment] [EOL] result = ( left_result or set ( ) ) | ( right_result or set ( ) ) [EOL] result = literals_to_types ( evaluator , result ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( left_result ) * len ( right_result ) > [number] : [EOL] result = literals_to_types ( evaluator , left_result | right_result ) [EOL] else : [EOL] for left in left_result : [EOL] for right in right_result : [EOL] result |= _element_calculate ( evaluator , context , left , operator , right ) [EOL] return result [EOL] [EOL] [EOL] def factor_calculate ( evaluator , types , operator ) : [EOL] [docstring] [EOL] for typ in types : [EOL] if operator == [string] : [EOL] if _is_number ( typ ) : [EOL] yield create ( evaluator , - typ . obj ) [EOL] elif operator == [string] : [EOL] value = typ . py__bool__ ( ) [EOL] if value is None : [comment] [EOL] return [EOL] yield create ( evaluator , not value ) [EOL] else : [EOL] yield typ [EOL] [EOL] [EOL] def _is_number ( obj ) : [EOL] return isinstance ( obj , CompiledObject ) \ [EOL] and isinstance ( obj . obj , ( int , float ) ) [EOL] [EOL] [EOL] def is_string ( obj ) : [EOL] return isinstance ( obj , CompiledObject ) \ [EOL] and isinstance ( obj . obj , ( str , unicode ) ) [EOL] [EOL] [EOL] def is_literal ( obj ) : [EOL] return _is_number ( obj ) or is_string ( obj ) [EOL] [EOL] [EOL] def _is_tuple ( obj ) : [EOL] from jedi . evaluate import iterable [EOL] return isinstance ( obj , iterable . AbstractSequence ) and obj . array_type == [string] [EOL] [EOL] [EOL] def _is_list ( obj ) : [EOL] from jedi . evaluate import iterable [EOL] return isinstance ( obj , iterable . AbstractSequence ) and obj . array_type == [string] [EOL] [EOL] [EOL] def _element_calculate ( evaluator , context , left , operator , right ) : [EOL] from jedi . evaluate import iterable , instance [EOL] l_is_num = _is_number ( left ) [EOL] r_is_num = _is_number ( right ) [EOL] if operator == [string] : [EOL] [comment] [EOL] if isinstance ( left , iterable . AbstractSequence ) or is_string ( left ) : [EOL] return set ( [ left ] ) [EOL] elif isinstance ( right , iterable . AbstractSequence ) or is_string ( right ) : [EOL] return set ( [ right ] ) [EOL] elif operator == [string] : [EOL] if l_is_num and r_is_num or is_string ( left ) and is_string ( right ) : [EOL] return set ( [ create ( evaluator , left . obj + right . obj ) ] ) [EOL] elif _is_tuple ( left ) and _is_tuple ( right ) or _is_list ( left ) and _is_list ( right ) : [EOL] return set ( [ iterable . MergedArray ( evaluator , ( left , right ) ) ] ) [EOL] elif operator == [string] : [EOL] if l_is_num and r_is_num : [EOL] return set ( [ create ( evaluator , left . obj - right . obj ) ] ) [EOL] elif operator == [string] : [EOL] [comment] [EOL] [comment] [EOL] return set ( [ left ] ) [EOL] elif operator in COMPARISON_OPERATORS : [EOL] operation = COMPARISON_OPERATORS [ operator ] [EOL] if isinstance ( left , CompiledObject ) and isinstance ( right , CompiledObject ) : [EOL] [comment] [EOL] left = left . obj [EOL] right = right . obj [EOL] [EOL] try : [EOL] result = operation ( left , right ) [EOL] except TypeError : [EOL] [comment] [EOL] return set ( [ create ( evaluator , True ) , create ( evaluator , False ) ] ) [EOL] else : [EOL] return set ( [ create ( evaluator , result ) ] ) [EOL] elif operator == [string] : [EOL] return set ( ) [EOL] [EOL] def check ( obj ) : [EOL] [docstring] [EOL] return isinstance ( obj , instance . CompiledInstance ) and obj . name . string_name in ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] if operator in ( [string] , [string] ) and l_is_num != r_is_num \ [EOL] and not ( check ( left ) or check ( right ) ) : [EOL] message = [string] [EOL] analysis . add ( context , [string] , operator , message % ( left , right ) ) [EOL] [EOL] return set ( [ left , right ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] try : [EOL] from collections import abc [EOL] except ImportError : [EOL] [comment] [EOL] import collections as abc [EOL] [EOL] [EOL] def factory ( typing_name , indextypes ) : [EOL] class Iterable ( abc . Iterable ) : [EOL] def __iter__ ( self ) : [EOL] while True : [EOL] yield indextypes [ [number] ] ( ) [EOL] [EOL] class Iterator ( Iterable , abc . Iterator ) : [EOL] def next ( self ) : [EOL] [docstring] [EOL] return self . __next__ ( ) [EOL] [EOL] def __next__ ( self ) : [EOL] return indextypes [ [number] ] ( ) [EOL] [EOL] class Sequence ( abc . Sequence ) : [EOL] def __getitem__ ( self , index ) : [EOL] return indextypes [ [number] ] ( ) [EOL] [EOL] class MutableSequence ( Sequence , abc . MutableSequence ) : [EOL] pass [EOL] [EOL] class List ( MutableSequence , list ) : [EOL] pass [EOL] [EOL] class Tuple ( Sequence , tuple ) : [EOL] def __getitem__ ( self , index ) : [EOL] if indextypes [ [number] ] == Ellipsis : [EOL] [comment] [EOL] [comment] [EOL] return indextypes [ [number] ] ( ) [EOL] else : [EOL] return indextypes [ index ] ( ) [EOL] [EOL] class AbstractSet ( Iterable , abc . Set ) : [EOL] pass [EOL] [EOL] class MutableSet ( AbstractSet , abc . MutableSet ) : [EOL] pass [EOL] [EOL] class KeysView ( Iterable , abc . KeysView ) : [EOL] pass [EOL] [EOL] class ValuesView ( abc . ValuesView ) : [EOL] def __iter__ ( self ) : [EOL] while True : [EOL] yield indextypes [ [number] ] ( ) [EOL] [EOL] class ItemsView ( abc . ItemsView ) : [EOL] def __iter__ ( self ) : [EOL] while True : [EOL] yield ( indextypes [ [number] ] ( ) , indextypes [ [number] ] ( ) ) [EOL] [EOL] class Mapping ( Iterable , abc . Mapping ) : [EOL] def __getitem__ ( self , item ) : [EOL] return indextypes [ [number] ] ( ) [EOL] [EOL] def keys ( self ) : [EOL] return KeysView ( ) [EOL] [EOL] def values ( self ) : [EOL] return ValuesView ( ) [EOL] [EOL] def items ( self ) : [EOL] return ItemsView ( ) [EOL] [EOL] class MutableMapping ( Mapping , abc . MutableMapping ) : [EOL] pass [EOL] [EOL] class Dict ( MutableMapping , dict ) : [EOL] pass [EOL] [EOL] dct = { [string] : Sequence , [string] : MutableSequence , [string] : List , [string] : Iterable , [string] : Iterator , [string] : AbstractSet , [string] : MutableSet , [string] : Mapping , [string] : MutableMapping , [string] : Tuple , [string] : KeysView , [string] : ItemsView , [string] : ValuesView , [string] : Dict , } [EOL] return dct [ typing_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import inspect [EOL] [EOL] NO_DEFAULT = object ( ) [EOL] [EOL] [EOL] def memoize_default ( default = NO_DEFAULT , evaluator_is_first_arg = False , second_arg_is_evaluator = False ) : [EOL] [docstring] [EOL] def func ( function ) : [EOL] def wrapper ( obj , * args , ** kwargs ) : [EOL] if evaluator_is_first_arg : [EOL] cache = obj . memoize_cache [EOL] elif second_arg_is_evaluator : [comment] [EOL] cache = args [ [number] ] . memoize_cache [EOL] else : [EOL] cache = obj . evaluator . memoize_cache [EOL] [EOL] try : [EOL] memo = cache [ function ] [EOL] except KeyError : [EOL] memo = { } [EOL] cache [ function ] = memo [EOL] [EOL] key = ( obj , args , frozenset ( kwargs . items ( ) ) ) [EOL] if key in memo : [EOL] return memo [ key ] [EOL] else : [EOL] if default is not NO_DEFAULT : [EOL] memo [ key ] = default [EOL] rv = function ( obj , * args , ** kwargs ) [EOL] if inspect . isgenerator ( rv ) : [EOL] rv = list ( rv ) [EOL] memo [ key ] = rv [EOL] return rv [EOL] return wrapper [EOL] return func [EOL] [EOL] [EOL] class CachedMetaClass ( type ) : [EOL] [docstring] [EOL] @ memoize_default ( None , second_arg_is_evaluator = True ) def __call__ ( self , * args , ** kwargs ) : [EOL] return super ( CachedMetaClass , self ) . __call__ ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , List , Tuple , Set [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import imp [EOL] import os [EOL] import pkgutil [EOL] import sys [EOL] [EOL] from jedi . _compatibility import find_module , unicode , ImplicitNSInfo [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi . common import source_to_unicode , unite [EOL] from jedi . parser . python import parse [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . tree import search_ancestor [EOL] from jedi . parser . cache import parser_cache [EOL] from jedi . evaluate import sys_path [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate . filters import AbstractNameDefinition [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ memoize_default ( default = set ( ) ) def infer_import ( context , tree_name , is_goto = False ) : [EOL] module_context = context . get_root_context ( ) [EOL] import_node = search_ancestor ( tree_name , [string] , [string] ) [EOL] import_path = import_node . get_path_for_name ( tree_name ) [EOL] from_import_name = None [EOL] evaluator = context . evaluator [EOL] try : [EOL] from_names = import_node . get_from_names ( ) [EOL] except AttributeError : [EOL] [comment] [EOL] pass [EOL] else : [EOL] if len ( from_names ) + [number] == len ( import_path ) : [EOL] [comment] [EOL] [comment] [EOL] from_import_name = import_path [ - [number] ] [EOL] import_path = from_names [EOL] [EOL] importer = Importer ( evaluator , tuple ( import_path ) , module_context , import_node . level ) [EOL] [EOL] types = importer . follow ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if from_import_name is not None : [EOL] types = unite ( t . py__getattribute__ ( from_import_name . value if isinstance ( from_import_name , tree . Name ) else from_import_name , name_context = context , is_goto = is_goto ) for t in types ) [EOL] [EOL] if not types : [EOL] path = import_path + [ from_import_name ] [EOL] importer = Importer ( evaluator , tuple ( path ) , module_context , import_node . level ) [EOL] types = importer . follow ( ) [EOL] [comment] [EOL] if is_goto : [EOL] types = set ( s . name for s in types ) [EOL] else : [EOL] [comment] [EOL] if is_goto : [EOL] types = set ( s . name for s in types ) [EOL] [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] [EOL] class NestedImportModule ( tree . Module ) : [EOL] [docstring] [EOL] def __init__ ( self , module , nested_import ) : [EOL] self . _module = module [EOL] self . _nested_import = nested_import [EOL] [EOL] def _get_nested_import_name ( self ) : [EOL] [docstring] [EOL] i = self . _nested_import [EOL] [comment] [EOL] [comment] [EOL] zero = ( [number] , [number] ) [EOL] names = [ unicode ( name ) for name in i . namespace_names [ [number] : ] ] [EOL] name = helpers . FakeName ( names , self . _nested_import ) [EOL] new = tree . Import ( i . _sub_module , zero , zero , name ) [EOL] new . parent = self . _module [EOL] debug . dbg ( [string] , new ) [EOL] return helpers . FakeName ( str ( i . namespace_names [ [number] ] ) , new ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _module , name ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . _module , self . _nested_import ) [EOL] [EOL] [EOL] def _add_error ( context , name , message = None ) : [EOL] [comment] [EOL] if hasattr ( name , [string] ) : [EOL] analysis . add ( context , [string] , name , message ) [EOL] [EOL] [EOL] def get_init_path ( directory_path ) : [EOL] [docstring] [EOL] for suffix , _ , _ in imp . get_suffixes ( ) : [EOL] path = os . path . join ( directory_path , [string] + suffix ) [EOL] if os . path . exists ( path ) : [EOL] return path [EOL] return None [EOL] [EOL] [EOL] class ImportName ( AbstractNameDefinition ) : [EOL] start_pos = ( [number] , [number] ) [EOL] [EOL] def __init__ ( self , parent_context , string_name ) : [EOL] self . parent_context = parent_context [EOL] self . string_name = string_name [EOL] [EOL] def infer ( self ) : [EOL] return Importer ( self . parent_context . evaluator , [ self . string_name ] , self . parent_context , ) . follow ( ) [EOL] [EOL] def get_root_context ( self ) : [EOL] [comment] [EOL] return self . parent_context . get_root_context ( ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class SubModuleName ( ImportName ) : [EOL] def infer ( self ) : [EOL] return Importer ( self . parent_context . evaluator , [ self . string_name ] , self . parent_context , level = [number] ) . follow ( ) [EOL] [EOL] [EOL] class Importer ( object ) : [EOL] def __init__ ( self , evaluator , import_path , module_context , level = [number] ) : [EOL] [docstring] [EOL] debug . speed ( [string] % ( import_path , ) ) [EOL] self . _evaluator = evaluator [EOL] self . level = level [EOL] self . module_context = module_context [EOL] try : [EOL] self . file_path = module_context . py__file__ ( ) [EOL] except AttributeError : [EOL] [comment] [EOL] self . file_path = None [EOL] [EOL] if level : [EOL] base = module_context . py__package__ ( ) . split ( [string] ) [EOL] if base == [ [string] ] : [EOL] base = [ ] [EOL] if level > len ( base ) : [EOL] path = module_context . py__file__ ( ) [EOL] if path is not None : [EOL] import_path = list ( import_path ) [EOL] p = path [EOL] for i in range ( level ) : [EOL] p = os . path . dirname ( p ) [EOL] dir_name = os . path . basename ( p ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if dir_name : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if path . endswith ( os . path . sep + [string] ) : [EOL] import_path . insert ( [number] , [string] ) [EOL] else : [EOL] import_path . insert ( [number] , dir_name ) [EOL] else : [EOL] _add_error ( module_context , import_path [ - [number] ] ) [EOL] import_path = [ ] [EOL] [comment] [EOL] debug . warning ( [string] ) [EOL] else : [EOL] [comment] [EOL] import_path = tuple ( base ) + tuple ( import_path ) [EOL] self . import_path = import_path [EOL] [EOL] @ property def str_import_path ( self ) : [EOL] [docstring] [EOL] return tuple ( name . value if isinstance ( name , tree . Name ) else name for name in self . import_path ) [EOL] [EOL] def sys_path_with_modifications ( self ) : [EOL] in_path = [ ] [EOL] sys_path_mod = list ( sys_path . sys_path_with_modifications ( self . _evaluator , self . module_context ) ) [EOL] if self . file_path is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . import_path : [comment] [EOL] for path in sys_path . traverse_parents ( self . file_path ) : [EOL] if os . path . basename ( path ) == self . str_import_path [ [number] ] : [EOL] in_path . append ( os . path . dirname ( path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys_path_mod . insert ( [number] , os . path . dirname ( self . file_path ) ) [EOL] [EOL] return in_path + sys_path_mod [EOL] [EOL] def follow ( self ) : [EOL] if not self . import_path : [EOL] return set ( ) [EOL] return self . _do_import ( self . import_path , self . sys_path_with_modifications ( ) ) [EOL] [EOL] def _do_import ( self , import_path , sys_path ) : [EOL] [docstring] [EOL] import_parts = [ i . value if isinstance ( i , tree . Name ) else i for i in import_path ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if len ( import_path ) > [number] and import_parts [ : [number] ] == [ [string] , [string] ] : [EOL] [comment] [EOL] ipath = ( [string] + str ( import_parts [ [number] ] ) , ) + import_path [ [number] : ] [EOL] modules = self . _do_import ( ipath , sys_path ) [EOL] if modules : [EOL] return modules [EOL] else : [EOL] [comment] [EOL] return self . _do_import ( ( [string] , ) + import_path [ [number] : ] , sys_path ) [EOL] [EOL] module_name = [string] . join ( import_parts ) [EOL] try : [EOL] return set ( [ self . _evaluator . modules [ module_name ] ] ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] if len ( import_path ) > [number] : [EOL] [comment] [EOL] [comment] [EOL] bases = self . _do_import ( import_path [ : - [number] ] , sys_path ) [EOL] if not bases : [EOL] return set ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parent_module = list ( bases ) [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if import_parts == [ [string] , [string] ] : [EOL] return parent_module . py__getattribute__ ( [string] ) [EOL] [EOL] try : [EOL] method = parent_module . py__path__ [EOL] except AttributeError : [EOL] [comment] [EOL] _add_error ( self . module_context , import_path [ - [number] ] ) [EOL] return set ( ) [EOL] else : [EOL] paths = method ( ) [EOL] debug . dbg ( [string] , module_name , paths ) [EOL] for path in paths : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] if not isinstance ( path , list ) : [EOL] path = [ path ] [EOL] module_file , module_path , is_pkg = find_module ( import_parts [ - [number] ] , path , fullname = module_name ) [EOL] break [EOL] except ImportError : [EOL] module_path = None [EOL] if module_path is None : [EOL] _add_error ( self . module_context , import_path [ - [number] ] ) [EOL] return set ( ) [EOL] else : [EOL] parent_module = None [EOL] try : [EOL] debug . dbg ( [string] , import_parts [ - [number] ] , self . file_path ) [EOL] [comment] [EOL] [comment] [EOL] sys . path , temp = sys_path , sys . path [EOL] try : [EOL] module_file , module_path , is_pkg = find_module ( import_parts [ - [number] ] , fullname = module_name ) [EOL] finally : [EOL] sys . path = temp [EOL] except ImportError : [EOL] [comment] [EOL] _add_error ( self . module_context , import_path [ - [number] ] ) [EOL] return set ( ) [EOL] [EOL] code = None [EOL] if is_pkg : [EOL] [comment] [EOL] [comment] [EOL] if module_path . endswith ( ( [string] , [string] ) ) : [EOL] code = module_file . loader . get_source ( module_name ) [EOL] else : [EOL] module_path = get_init_path ( module_path ) [EOL] elif module_file : [EOL] code = module_file . read ( ) [EOL] module_file . close ( ) [EOL] [EOL] if isinstance ( module_path , ImplicitNSInfo ) : [EOL] from jedi . evaluate . representation import ImplicitNamespaceContext [EOL] fullname , paths = module_path . name , module_path . paths [EOL] module = ImplicitNamespaceContext ( self . _evaluator , fullname = fullname ) [EOL] module . paths = paths [EOL] elif module_file is None and not module_path . endswith ( ( [string] , [string] , [string] ) ) : [EOL] module = compiled . load_module ( self . _evaluator , module_path ) [EOL] else : [EOL] module = _load_module ( self . _evaluator , module_path , code , sys_path , parent_module ) [EOL] [EOL] if module is None : [EOL] [comment] [EOL] [comment] [EOL] return set ( ) [EOL] [EOL] self . _evaluator . modules [ module_name ] = module [EOL] return set ( [ module ] ) [EOL] [EOL] def _generate_name ( self , name , in_module = None ) : [EOL] [comment] [EOL] if in_module is None : [EOL] return ImportName ( self . module_context , name ) [EOL] return SubModuleName ( in_module , name ) [EOL] [EOL] def _get_module_names ( self , search_path = None , in_module = None ) : [EOL] [docstring] [EOL] [EOL] names = [ ] [EOL] [comment] [EOL] if search_path is None and in_module is None : [EOL] names += [ self . _generate_name ( name ) for name in sys . builtin_module_names ] [EOL] [EOL] if search_path is None : [EOL] search_path = self . sys_path_with_modifications ( ) [EOL] for module_loader , name , is_pkg in pkgutil . iter_modules ( search_path ) : [EOL] names . append ( self . _generate_name ( name , in_module = in_module ) ) [EOL] return names [EOL] [EOL] def completion_names ( self , evaluator , only_modules = False ) : [EOL] [docstring] [EOL] from jedi . evaluate . representation import ModuleContext , ImplicitNamespaceContext [EOL] names = [ ] [EOL] if self . import_path : [EOL] [comment] [EOL] if self . str_import_path == ( [string] , [string] ) : [EOL] [comment] [EOL] for mod in self . _get_module_names ( ) : [EOL] modname = mod . string_name [EOL] if modname . startswith ( [string] ) : [EOL] extname = modname [ len ( [string] ) : ] [EOL] names . append ( self . _generate_name ( extname ) ) [EOL] [comment] [EOL] for dir in self . sys_path_with_modifications ( ) : [EOL] flaskext = os . path . join ( dir , [string] ) [EOL] if os . path . isdir ( flaskext ) : [EOL] names += self . _get_module_names ( [ flaskext ] ) [EOL] [EOL] for context in self . follow ( ) : [EOL] [comment] [EOL] if context . api_type != [string] : [comment] [EOL] continue [EOL] [comment] [EOL] if isinstance ( context , ModuleContext ) and context . py__file__ ( ) . endswith ( [string] ) : [EOL] paths = context . py__path__ ( ) [EOL] names += self . _get_module_names ( paths , in_module = context ) [EOL] [EOL] [comment] [EOL] elif isinstance ( context , ImplicitNamespaceContext ) : [EOL] paths = context . paths [EOL] names += self . _get_module_names ( paths ) [EOL] [EOL] if only_modules : [EOL] [comment] [EOL] [comment] [EOL] if ( [string] , ) == self . str_import_path and not self . level : [EOL] [comment] [EOL] [comment] [EOL] names . append ( self . _generate_name ( [string] , context ) ) [EOL] [EOL] continue [EOL] [EOL] for filter in context . get_filters ( search_global = False ) : [EOL] names += filter . values ( ) [EOL] else : [EOL] [comment] [EOL] if not self . level : [EOL] names += self . _get_module_names ( ) [EOL] [EOL] if self . file_path is not None : [EOL] path = os . path . abspath ( self . file_path ) [EOL] for i in range ( self . level - [number] ) : [EOL] path = os . path . dirname ( path ) [EOL] names += self . _get_module_names ( [ path ] ) [EOL] [EOL] return names [EOL] [EOL] [EOL] def _load_module ( evaluator , path = None , code = None , sys_path = None , parent_module = None ) : [EOL] if sys_path is None : [EOL] sys_path = evaluator . sys_path [EOL] [EOL] dotted_path = path and compiled . dotted_from_fs_path ( path , sys_path ) [EOL] if path is not None and path . endswith ( ( [string] , [string] , [string] ) ) \ [EOL] and dotted_path not in settings . auto_import_modules : [EOL] [EOL] module_node = parse ( code = code , path = path , cache = True , diff_cache = True ) [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] return ModuleContext ( evaluator , module_node , path = path ) [EOL] else : [EOL] return compiled . load_module ( evaluator , path ) [EOL] [EOL] [EOL] def add_module ( evaluator , module_name , module ) : [EOL] if [string] not in module_name : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] evaluator . modules [ module_name ] = module [EOL] [EOL] [EOL] def get_modules_containing_name ( evaluator , modules , name ) : [EOL] [docstring] [EOL] from jedi . evaluate import representation as er [EOL] [EOL] def check_python_file ( path ) : [EOL] try : [EOL] node_cache_item = parser_cache [ path ] [EOL] except KeyError : [EOL] try : [EOL] return check_fs ( path ) [EOL] except IOError : [EOL] return None [EOL] else : [EOL] module_node = node_cache_item . node [EOL] return er . ModuleContext ( evaluator , module_node , path = path ) [EOL] [EOL] def check_fs ( path ) : [EOL] with open ( path , [string] ) as f : [EOL] code = source_to_unicode ( f . read ( ) ) [EOL] if name in code : [EOL] module_name = os . path . basename ( path ) [ : - [number] ] [comment] [EOL] module = _load_module ( evaluator , path , code ) [EOL] add_module ( evaluator , module_name , module ) [EOL] return module [EOL] [EOL] [comment] [EOL] used_mod_paths = set ( ) [EOL] for m in modules : [EOL] try : [EOL] path = m . py__file__ ( ) [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] used_mod_paths . add ( path ) [EOL] yield m [EOL] [EOL] if not settings . dynamic_params_for_other_modules : [EOL] return [EOL] [EOL] paths = set ( settings . additional_dynamic_modules ) [EOL] for p in used_mod_paths : [EOL] if p is not None : [EOL] [comment] [EOL] [comment] [EOL] d = os . path . dirname ( os . path . abspath ( p ) ) [EOL] for file_name in os . listdir ( d ) : [EOL] path = os . path . join ( d , file_name ) [EOL] if path not in used_mod_paths and path not in paths : [EOL] if file_name . endswith ( [string] ) : [EOL] paths . add ( path ) [EOL] [EOL] [comment] [EOL] for p in sorted ( paths ) : [EOL] [comment] [EOL] m = check_python_file ( p ) [EOL] if m is not None and not isinstance ( m , compiled . CompiledObject ) : [EOL] yield m [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match , List , Set , Dict [EOL] import typing [EOL] [docstring] [EOL] import collections [EOL] import re [EOL] [EOL] from jedi . common import unite [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate . instance import InstanceFunctionExecution , AbstractInstanceContext , CompiledInstance , BoundMethod [EOL] from jedi . evaluate import iterable [EOL] from jedi . parser . python import parse [EOL] from jedi import debug [EOL] from jedi . evaluate import precedence [EOL] from jedi . evaluate import param [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate . context import LazyTreeContext , ContextualizedNode [EOL] [EOL] [EOL] class NotInStdLib ( LookupError ) : [EOL] pass [EOL] [EOL] [EOL] def execute ( evaluator , obj , arguments ) : [EOL] if isinstance ( obj , BoundMethod ) : [EOL] raise NotInStdLib ( ) [EOL] [EOL] try : [EOL] obj_name = obj . name . string_name [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] if obj . parent_context == evaluator . BUILTINS : [EOL] module_name = [string] [EOL] elif isinstance ( obj . parent_context , er . ModuleContext ) : [EOL] module_name = obj . parent_context . name . string_name [EOL] else : [EOL] module_name = [string] [EOL] [EOL] [comment] [EOL] try : [EOL] func = _implemented [ module_name ] [ obj_name ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] return func ( evaluator , obj , arguments ) [EOL] raise NotInStdLib ( ) [EOL] [EOL] [EOL] def _follow_param ( evaluator , arguments , index ) : [EOL] try : [EOL] key , lazy_context = list ( arguments . unpack ( ) ) [ index ] [EOL] except IndexError : [EOL] return set ( ) [EOL] else : [EOL] return lazy_context . infer ( ) [EOL] [EOL] [EOL] def argument_clinic ( string , want_obj = False , want_context = False , want_arguments = False ) : [EOL] [docstring] [EOL] clinic_args = [ ] [EOL] allow_kwargs = False [EOL] optional = False [EOL] while string : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] match = re . match ( [string] , string ) [EOL] string = string [ len ( match . group ( [number] ) ) : ] [EOL] if not match . group ( [number] ) : [comment] [EOL] allow_kwargs = True [EOL] continue [EOL] optional = optional or bool ( match . group ( [number] ) ) [EOL] word = match . group ( [number] ) [EOL] clinic_args . append ( ( word , optional , allow_kwargs ) ) [EOL] [EOL] def f ( func ) : [EOL] def wrapper ( evaluator , obj , arguments ) : [EOL] debug . dbg ( [string] % obj , color = [string] ) [EOL] try : [EOL] lst = list ( arguments . eval_argument_clinic ( clinic_args ) ) [EOL] except ValueError : [EOL] return set ( ) [EOL] else : [EOL] kwargs = { } [EOL] if want_context : [EOL] kwargs [ [string] ] = arguments . context [EOL] if want_obj : [EOL] kwargs [ [string] ] = obj [EOL] if want_arguments : [EOL] kwargs [ [string] ] = arguments [EOL] return func ( evaluator , * lst , ** kwargs ) [EOL] finally : [EOL] debug . dbg ( [string] , color = [string] ) [EOL] [EOL] return wrapper [EOL] return f [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def builtins_next ( evaluator , iterators , defaults ) : [EOL] [docstring] [EOL] if evaluator . python_version [ [number] ] == [number] : [EOL] name = [string] [EOL] else : [EOL] name = [string] [EOL] [EOL] types = set ( ) [EOL] for iterator in iterators : [EOL] if isinstance ( iterator , AbstractInstanceContext ) : [EOL] for filter in iterator . get_filters ( include_self_names = True ) : [EOL] for n in filter . get ( name ) : [EOL] for context in n . infer ( ) : [EOL] types |= context . execute_evaluated ( ) [EOL] if types : [EOL] return types [EOL] return defaults [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def builtins_getattr ( evaluator , objects , names , defaults = None ) : [EOL] [comment] [EOL] for obj in objects : [EOL] for name in names : [EOL] if precedence . is_string ( name ) : [EOL] return obj . py__getattribute__ ( name . obj ) [EOL] else : [EOL] debug . warning ( [string] ) [EOL] continue [EOL] return set ( ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def builtins_type ( evaluator , objects , bases , dicts ) : [EOL] if bases or dicts : [EOL] [comment] [EOL] return set ( ) [EOL] else : [EOL] return set ( [ o . py__class__ ( ) for o in objects ] ) [EOL] [EOL] [EOL] class SuperInstance ( AbstractInstanceContext ) : [EOL] [docstring] [EOL] def __init__ ( self , evaluator , cls ) : [EOL] su = cls . py_mro ( ) [ [number] ] [EOL] super ( ) . __init__ ( evaluator , su and su [ [number] ] or self ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] , want_context = True ) def builtins_super ( evaluator , types , objects , context ) : [EOL] [comment] [EOL] if isinstance ( context , InstanceFunctionExecution ) : [EOL] su = context . instance . py__class__ ( ) . py__bases__ ( ) [EOL] return unite ( context . execute_evaluated ( ) for context in su [ [number] ] . infer ( ) ) [EOL] return set ( ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] , want_obj = True , want_arguments = True ) def builtins_reversed ( evaluator , sequences , obj , arguments ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] key , lazy_context = next ( arguments . unpack ( ) ) [EOL] cn = None [EOL] if isinstance ( lazy_context , LazyTreeContext ) : [EOL] [comment] [EOL] cn = ContextualizedNode ( lazy_context . _context , lazy_context . data ) [EOL] ordered = list ( iterable . py__iter__ ( evaluator , sequences , cn ) ) [EOL] [EOL] rev = list ( reversed ( ordered ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] seq = iterable . FakeSequence ( evaluator , [string] , rev ) [EOL] arguments = param . ValuesArguments ( [ [ seq ] ] ) [EOL] return set ( [ CompiledInstance ( evaluator , evaluator . BUILTINS , obj , arguments ) ] ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] , want_arguments = True ) def builtins_isinstance ( evaluator , objects , types , arguments ) : [EOL] bool_results = set ( [ ] ) [EOL] for o in objects : [EOL] try : [EOL] mro_func = o . py__class__ ( ) . py__mro__ [EOL] except AttributeError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return set ( [ compiled . create ( True ) , compiled . create ( False ) ] ) [EOL] [EOL] mro = mro_func ( ) [EOL] [EOL] for cls_or_tup in types : [EOL] if cls_or_tup . is_class ( ) : [EOL] bool_results . add ( cls_or_tup in mro ) [EOL] elif cls_or_tup . name . string_name == [string] \ [EOL] and cls_or_tup . get_root_context ( ) == evaluator . BUILTINS : [EOL] [comment] [EOL] classes = unite ( lazy_context . infer ( ) for lazy_context in cls_or_tup . py__iter__ ( ) ) [EOL] bool_results . add ( any ( cls in mro for cls in classes ) ) [EOL] else : [EOL] _ , lazy_context = list ( arguments . unpack ( ) ) [ [number] ] [EOL] if isinstance ( lazy_context , LazyTreeContext ) : [EOL] node = lazy_context . data [EOL] message = [string] [string] [string] % cls_or_tup [EOL] analysis . add ( lazy_context . _context , [string] , node , message ) [EOL] [EOL] return set ( compiled . create ( evaluator , x ) for x in bool_results ) [EOL] [EOL] [EOL] def collections_namedtuple ( evaluator , obj , arguments ) : [EOL] [docstring] [EOL] [comment] [EOL] if not hasattr ( collections , [string] ) : [EOL] return set ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] name = list ( _follow_param ( evaluator , arguments , [number] ) ) [ [number] ] . obj [EOL] _fields = list ( _follow_param ( evaluator , arguments , [number] ) ) [ [number] ] [EOL] if isinstance ( _fields , compiled . CompiledObject ) : [EOL] fields = _fields . obj . replace ( [string] , [string] ) . split ( ) [EOL] elif isinstance ( _fields , iterable . AbstractSequence ) : [EOL] fields = [ v . obj for lazy_context in _fields . py__iter__ ( ) for v in lazy_context . infer ( ) if hasattr ( v , [string] ) ] [EOL] else : [EOL] return set ( ) [EOL] [EOL] [comment] [EOL] source = collections . _class_template . format ( typename = name , field_names = fields , num_fields = len ( fields ) , arg_list = [string] . join ( fields ) , repr_fmt = [string] . join ( collections . _repr_template . format ( name = name ) for name in fields ) , field_defs = [string] . join ( collections . _field_template . format ( index = index , name = name ) for index , name in enumerate ( fields ) ) ) [EOL] [EOL] [comment] [EOL] generated_class = next ( parse ( source , grammar = evaluator . grammar ) . iter_classdefs ( ) ) [EOL] return set ( [ er . ClassContext ( evaluator , generated_class , evaluator . BUILTINS ) ] ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def _return_first_param ( evaluator , firsts ) : [EOL] return firsts [EOL] [EOL] [EOL] _implemented = { [string] : { [string] : builtins_getattr , [string] : builtins_type , [string] : builtins_super , [string] : builtins_reversed , [string] : builtins_isinstance , } , [string] : { [string] : _return_first_param , [string] : _return_first_param , } , [string] : { [string] : lambda * args : set ( ) , [string] : lambda * args : set ( ) , } , [string] : { [string] : collections_namedtuple , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Any , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . tree import search_ancestor [EOL] from jedi import debug [EOL] from jedi . common import unite [EOL] from jedi import settings [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate . instance import AbstractInstanceContext [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate import iterable [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate import flow_analysis [EOL] from jedi . evaluate import param [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate . filters import get_global_filters [EOL] from jedi . evaluate . context import ContextualizedName , ContextualizedNode [EOL] from jedi . parser_utils import is_scope , get_parent_scope [EOL] [EOL] [EOL] class NameFinder ( object ) : [EOL] def __init__ ( self , evaluator , context , name_context , name_or_str , position = None ) : [EOL] self . _evaluator = evaluator [EOL] [comment] [EOL] self . _context = context [EOL] self . _name_context = name_context [EOL] self . _name = name_or_str [EOL] if isinstance ( name_or_str , tree . Name ) : [EOL] self . _string_name = name_or_str . value [EOL] else : [EOL] self . _string_name = name_or_str [EOL] self . _position = position [EOL] self . _found_predefined_types = None [EOL] [EOL] @ debug . increase_indent def find ( self , filters , attribute_lookup ) : [EOL] [docstring] [EOL] names = self . filter_name ( filters ) [EOL] if self . _found_predefined_types is not None and names : [EOL] check = flow_analysis . reachability_check ( self . _context , self . _context . tree_node , self . _name ) [EOL] if check is flow_analysis . UNREACHABLE : [EOL] return set ( ) [EOL] return self . _found_predefined_types [EOL] [EOL] types = self . _names_to_types ( names , attribute_lookup ) [EOL] [EOL] if not names and not types \ [EOL] and not ( isinstance ( self . _name , tree . Name ) and isinstance ( self . _name . parent . parent , tree . Param ) ) : [EOL] if isinstance ( self . _name , tree . Name ) : [EOL] if attribute_lookup : [EOL] analysis . add_attribute_error ( self . _name_context , self . _context , self . _name ) [EOL] else : [EOL] message = ( [string] % self . _string_name ) [EOL] analysis . add ( self . _name_context , [string] , self . _name , message ) [EOL] [EOL] return types [EOL] [EOL] def _get_origin_scope ( self ) : [EOL] if isinstance ( self . _name , tree . Name ) : [EOL] scope = self . _name [EOL] while scope . parent is not None : [EOL] [comment] [EOL] if not isinstance ( scope , tree . Scope ) : [EOL] break [EOL] scope = scope . parent [EOL] return scope [EOL] else : [EOL] return None [EOL] [EOL] def get_filters ( self , search_global = False ) : [EOL] origin_scope = self . _get_origin_scope ( ) [EOL] if search_global : [EOL] return get_global_filters ( self . _evaluator , self . _context , self . _position , origin_scope ) [EOL] else : [EOL] return self . _context . get_filters ( search_global , self . _position , origin_scope = origin_scope ) [EOL] [EOL] def filter_name ( self , filters ) : [EOL] [docstring] [EOL] names = [ ] [EOL] if self . _context . predefined_names : [EOL] [comment] [EOL] node = self . _name [EOL] while node is not None and not is_scope ( node ) : [EOL] node = node . parent [EOL] if node . type in ( [string] , [string] , [string] ) : [EOL] try : [EOL] name_dict = self . _context . predefined_names [ node ] [EOL] types = name_dict [ self . _string_name ] [EOL] except KeyError : [EOL] continue [EOL] else : [EOL] self . _found_predefined_types = types [EOL] break [EOL] [EOL] for filter in filters : [EOL] names = filter . get ( self . _string_name ) [EOL] if names : [EOL] break [EOL] debug . dbg ( [string] , self . _string_name , self . _context , names , self . _position ) [EOL] return list ( names ) [EOL] [EOL] def _check_getattr ( self , inst ) : [EOL] [docstring] [EOL] [comment] [EOL] name = compiled . create ( self . _evaluator , self . _string_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] names = ( inst . get_function_slot_names ( [string] ) or inst . get_function_slot_names ( [string] ) ) [EOL] return inst . execute_function_slots ( names , name ) [EOL] [EOL] def _names_to_types ( self , names , attribute_lookup ) : [EOL] types = set ( ) [EOL] [EOL] types = unite ( name . infer ( ) for name in names ) [EOL] [EOL] debug . dbg ( [string] , names , types ) [EOL] if not names and isinstance ( self . _context , AbstractInstanceContext ) : [EOL] [comment] [EOL] return self . _check_getattr ( self . _context ) [EOL] [EOL] [comment] [EOL] if not types and isinstance ( self . _name , tree . Name ) and not isinstance ( self . _name_context , AbstractInstanceContext ) : [EOL] flow_scope = self . _name [EOL] base_node = self . _name_context . tree_node [EOL] if base_node . type == [string] : [EOL] return types [EOL] while True : [EOL] flow_scope = get_parent_scope ( flow_scope , include_flows = True ) [EOL] n = _check_flow_information ( self . _name_context , flow_scope , self . _name , self . _position ) [EOL] if n is not None : [EOL] return n [EOL] if flow_scope == base_node : [EOL] break [EOL] return types [EOL] [EOL] [EOL] def _name_to_types ( evaluator , context , tree_name ) : [EOL] types = [ ] [EOL] node = tree_name . get_definition ( ) [EOL] typ = node . type [EOL] if typ == [string] : [EOL] types = pep0484 . find_type_from_comment_hint_for ( context , node , tree_name ) [EOL] if types : [EOL] return types [EOL] if typ == [string] : [EOL] types = pep0484 . find_type_from_comment_hint_with ( context , node , tree_name ) [EOL] if types : [EOL] return types [EOL] if typ in ( [string] , [string] ) : [EOL] try : [EOL] types = context . predefined_names [ node ] [ tree_name . value ] [EOL] except KeyError : [EOL] cn = ContextualizedNode ( context , node . children [ [number] ] ) [EOL] for_types = iterable . py__iter__types ( evaluator , cn . infer ( ) , cn ) [EOL] c_node = ContextualizedName ( context , tree_name ) [EOL] types = check_tuple_assignments ( evaluator , c_node , for_types ) [EOL] elif typ == [string] : [EOL] types = _remove_statements ( evaluator , context , node , tree_name ) [EOL] elif typ == [string] : [EOL] types = context . eval_node ( node . get_context_manager_from_name ( tree_name ) ) [EOL] elif typ in ( [string] , [string] ) : [EOL] types = imports . infer_import ( context , tree_name ) [EOL] elif typ in ( [string] , [string] ) : [EOL] types = _apply_decorators ( evaluator , context , node ) [EOL] elif typ == [string] : [EOL] context = evaluator . create_context ( context , tree_name ) [EOL] finder = NameFinder ( evaluator , context , context , tree_name . value ) [EOL] filters = finder . get_filters ( search_global = True ) [EOL] [comment] [EOL] [comment] [EOL] filters = [ next ( filters ) ] [EOL] types += finder . find ( filters , attribute_lookup = False ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exceptions = context . eval_node ( tree_name . get_previous_sibling ( ) . get_previous_sibling ( ) ) [EOL] types = unite ( evaluator . execute ( t , param . ValuesArguments ( [ ] ) ) for t in exceptions ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] return types [EOL] [EOL] [EOL] def _apply_decorators ( evaluator , context , node ) : [EOL] [docstring] [EOL] if node . type == [string] : [EOL] decoratee_context = er . ClassContext ( evaluator , parent_context = context , classdef = node ) [EOL] else : [EOL] decoratee_context = er . FunctionContext ( evaluator , parent_context = context , funcdef = node ) [EOL] initial = values = set ( [ decoratee_context ] ) [EOL] for dec in reversed ( node . get_decorators ( ) ) : [EOL] debug . dbg ( [string] , dec , values ) [EOL] dec_values = context . eval_node ( dec . children [ [number] ] ) [EOL] trailer_nodes = dec . children [ [number] : - [number] ] [EOL] if trailer_nodes : [EOL] [comment] [EOL] trailer = tree . PythonNode ( [string] , trailer_nodes ) [EOL] trailer . parent = dec [EOL] dec_values = evaluator . eval_trailer ( context , dec_values , trailer ) [EOL] [EOL] if not len ( dec_values ) : [EOL] debug . warning ( [string] , dec , node ) [EOL] return initial [EOL] [EOL] values = unite ( dec_value . execute ( param . ValuesArguments ( [ values ] ) ) for dec_value in dec_values ) [EOL] if not len ( values ) : [EOL] debug . warning ( [string] , node ) [EOL] return initial [EOL] [EOL] debug . dbg ( [string] , values ) [EOL] return values [EOL] [EOL] [EOL] def _remove_statements ( evaluator , context , stmt , name ) : [EOL] [docstring] [EOL] types = set ( ) [EOL] check_instance = None [EOL] [EOL] pep0484types = pep0484 . find_type_from_comment_hint_assign ( context , stmt , name ) [EOL] if pep0484types : [EOL] return pep0484types [EOL] types |= context . eval_stmt ( stmt , seek_name = name ) [EOL] [EOL] if check_instance is not None : [EOL] [comment] [EOL] types = set ( [ er . get_instance_el ( evaluator , check_instance , a , True ) [EOL] if isinstance ( a , er . Function ) else a for a in types ] ) [EOL] return types [EOL] [EOL] [EOL] def _check_flow_information ( context , flow , search_name , pos ) : [EOL] [docstring] [EOL] if not settings . dynamic_flow_information : [EOL] return None [EOL] [EOL] result = None [EOL] if is_scope ( flow ) : [EOL] [comment] [EOL] module_node = flow . get_root_node ( ) [EOL] try : [EOL] names = module_node . get_used_names ( ) [ search_name . value ] [EOL] except KeyError : [EOL] return None [EOL] names = reversed ( [ n for n in names if flow . start_pos <= n . start_pos < ( pos or flow . end_pos ) ] ) [EOL] [EOL] for name in names : [EOL] ass = search_ancestor ( name , [string] ) [EOL] if ass is not None : [EOL] result = _check_isinstance_type ( context , ass . assertion , search_name ) [EOL] if result is not None : [EOL] return result [EOL] [EOL] if flow . type in ( [string] , [string] ) : [EOL] potential_ifs = [ c for c in flow . children [ [number] : : [number] ] if c != [string] ] [EOL] for if_test in reversed ( potential_ifs ) : [EOL] if search_name . start_pos > if_test . end_pos : [EOL] return _check_isinstance_type ( context , if_test , search_name ) [EOL] return result [EOL] [EOL] [EOL] def _check_isinstance_type ( context , element , search_name ) : [EOL] try : [EOL] assert element . type in ( [string] , [string] ) [EOL] [comment] [EOL] assert len ( element . children ) == [number] [EOL] first , trailer = element . children [EOL] assert first . type == [string] and first . value == [string] [EOL] assert trailer . type == [string] and trailer . children [ [number] ] == [string] [EOL] assert len ( trailer . children ) == [number] [EOL] [EOL] [comment] [EOL] arglist = trailer . children [ [number] ] [EOL] args = param . TreeArguments ( context . evaluator , context , arglist , trailer ) [EOL] param_list = list ( args . unpack ( ) ) [EOL] [comment] [EOL] assert len ( param_list ) == [number] [EOL] ( key1 , lazy_context_object ) , ( key2 , lazy_context_cls ) = param_list [EOL] assert key1 is None and key2 is None [EOL] call = helpers . call_of_leaf ( search_name ) [EOL] is_instance_call = helpers . call_of_leaf ( lazy_context_object . data ) [EOL] [comment] [EOL] [comment] [EOL] assert is_instance_call . get_code ( normalized = True ) == call . get_code ( normalized = True ) [EOL] except AssertionError : [EOL] return None [EOL] [EOL] result = set ( ) [EOL] for cls_or_tup in lazy_context_cls . infer ( ) : [EOL] if isinstance ( cls_or_tup , iterable . AbstractSequence ) and cls_or_tup . array_type == [string] : [EOL] for lazy_context in cls_or_tup . py__iter__ ( ) : [EOL] for context in lazy_context . infer ( ) : [EOL] result |= context . execute_evaluated ( ) [EOL] else : [EOL] result |= cls_or_tup . execute_evaluated ( ) [EOL] return result [EOL] [EOL] [EOL] def check_tuple_assignments ( evaluator , contextualized_name , types ) : [EOL] [docstring] [EOL] lazy_context = None [EOL] for index , node in contextualized_name . assignment_indexes ( ) : [EOL] cn = ContextualizedNode ( contextualized_name . context , node ) [EOL] iterated = iterable . py__iter__ ( evaluator , types , cn ) [EOL] for _ in range ( index + [number] ) : [EOL] try : [EOL] lazy_context = next ( iterated ) [EOL] except StopIteration : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return set ( ) [EOL] types = lazy_context . infer ( ) [EOL] return types [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , Union [EOL] import typing_extensions [EOL] import typing [EOL] from abc import abstractproperty [EOL] [EOL] from jedi . _compatibility import is_py3 [EOL] from jedi . common import unite [EOL] from jedi import debug [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import filters [EOL] from jedi . evaluate . context import Context , LazyKnownContext , LazyKnownContexts [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . cache import memoize_method [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate . dynamic import search_params [EOL] from jedi . evaluate import iterable [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] class AbstractInstanceContext ( Context ) : [EOL] [docstring] [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , evaluator , parent_context , class_context , var_args ) : [EOL] super ( AbstractInstanceContext , self ) . __init__ ( evaluator , parent_context ) [EOL] [comment] [EOL] [comment] [EOL] self . class_context = class_context [EOL] self . var_args = var_args [EOL] [EOL] def is_class ( self ) : [EOL] return False [EOL] [EOL] @ property def py__call__ ( self ) : [EOL] names = self . get_function_slot_names ( [string] ) [EOL] if not names : [EOL] [comment] [EOL] raise AttributeError [EOL] [EOL] def execute ( arguments ) : [EOL] return unite ( name . execute ( arguments ) for name in names ) [EOL] [EOL] return execute [EOL] [EOL] def py__class__ ( self ) : [EOL] return self . class_context [EOL] [EOL] def py__bool__ ( self ) : [EOL] [comment] [EOL] return None [EOL] [EOL] def get_function_slot_names ( self , name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for filter in self . get_filters ( include_self_names = False ) : [EOL] names = filter . get ( name ) [EOL] if names : [EOL] return names [EOL] return [ ] [EOL] [EOL] def execute_function_slots ( self , names , * evaluated_args ) : [EOL] return unite ( name . execute_evaluated ( * evaluated_args ) for name in names ) [EOL] [EOL] def py__get__ ( self , obj ) : [EOL] [comment] [EOL] [comment] [EOL] names = self . get_function_slot_names ( [string] ) [EOL] if names : [EOL] if isinstance ( obj , AbstractInstanceContext ) : [EOL] return self . execute_function_slots ( names , obj , obj . class_context ) [EOL] else : [EOL] none_obj = compiled . create ( self . evaluator , None ) [EOL] return self . execute_function_slots ( names , none_obj , obj ) [EOL] else : [EOL] return set ( [ self ] ) [EOL] [EOL] def get_filters ( self , search_global = None , until_position = None , origin_scope = None , include_self_names = True ) : [EOL] if include_self_names : [EOL] for cls in self . class_context . py__mro__ ( ) : [EOL] if isinstance ( cls , compiled . CompiledObject ) : [EOL] if cls . tree_node is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] yield SelfNameFilter ( self . evaluator , self , cls , origin_scope ) [EOL] else : [EOL] yield SelfNameFilter ( self . evaluator , self , cls , origin_scope ) [EOL] [EOL] for cls in self . class_context . py__mro__ ( ) : [EOL] if isinstance ( cls , compiled . CompiledObject ) : [EOL] yield CompiledInstanceClassFilter ( self . evaluator , self , cls ) [EOL] else : [EOL] yield InstanceClassFilter ( self . evaluator , self , cls , origin_scope ) [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] try : [EOL] names = self . get_function_slot_names ( [string] ) [EOL] except KeyError : [EOL] debug . warning ( [string] ) [EOL] return set ( ) [EOL] else : [EOL] index_obj = compiled . create ( self . evaluator , index ) [EOL] return self . execute_function_slots ( names , index_obj ) [EOL] [EOL] def py__iter__ ( self ) : [EOL] iter_slot_names = self . get_function_slot_names ( [string] ) [EOL] if not iter_slot_names : [EOL] debug . warning ( [string] % self ) [EOL] return [EOL] [EOL] for generator in self . execute_function_slots ( iter_slot_names ) : [EOL] if isinstance ( generator , AbstractInstanceContext ) : [EOL] [comment] [EOL] name = [string] if is_py3 else [string] [EOL] iter_slot_names = generator . get_function_slot_names ( name ) [EOL] if iter_slot_names : [EOL] yield LazyKnownContexts ( generator . execute_function_slots ( iter_slot_names ) ) [EOL] else : [EOL] debug . warning ( [string] , generator ) [EOL] else : [EOL] for lazy_context in generator . py__iter__ ( ) : [EOL] yield lazy_context [EOL] [EOL] @ abstractproperty def name ( self ) : [EOL] pass [EOL] [EOL] def _create_init_execution ( self , class_context , func_node ) : [EOL] bound_method = BoundMethod ( self . evaluator , self , class_context , self . parent_context , func_node ) [EOL] return InstanceFunctionExecution ( self , class_context . parent_context , bound_method , self . var_args ) [EOL] [EOL] def create_init_executions ( self ) : [EOL] for name in self . get_function_slot_names ( [string] ) : [EOL] if isinstance ( name , LazyInstanceName ) : [EOL] yield self . _create_init_execution ( name . class_context , name . tree_name . parent ) [EOL] [EOL] @ memoize_default ( ) def create_instance_context ( self , class_context , node ) : [EOL] if node . parent . type in ( [string] , [string] ) : [EOL] node = node . parent [EOL] scope = get_parent_scope ( node ) [EOL] if scope == class_context . tree_node : [EOL] return class_context [EOL] else : [EOL] parent_context = self . create_instance_context ( class_context , scope ) [EOL] if scope . type == [string] : [EOL] if scope . name . value == [string] and parent_context == class_context : [EOL] return self . _create_init_execution ( class_context , scope ) [EOL] else : [EOL] bound_method = BoundMethod ( self . evaluator , self , class_context , self . parent_context , scope ) [EOL] return bound_method . get_function_execution ( ) [EOL] else : [EOL] raise NotImplementedError [EOL] return class_context [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . class_context , self . var_args ) [EOL] [EOL] [EOL] class CompiledInstance ( AbstractInstanceContext ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( CompiledInstance , self ) . __init__ ( * args , ** kwargs ) [EOL] [comment] [EOL] [comment] [EOL] if self . class_context . name . string_name in [ [string] , [string] ] \ [EOL] and self . parent_context . get_root_context ( ) == self . evaluator . BUILTINS : [EOL] [comment] [EOL] self . var_args = iterable . get_dynamic_array_instance ( self ) [EOL] [EOL] @ property def name ( self ) : [EOL] return compiled . CompiledContextName ( self , self . class_context . name . string_name ) [EOL] [EOL] def create_instance_context ( self , class_context , node ) : [EOL] if get_parent_scope ( node ) . type == [string] : [EOL] return class_context [EOL] else : [EOL] return super ( CompiledInstance , self ) . create_instance_context ( class_context , node ) [EOL] [EOL] [EOL] class TreeInstance ( AbstractInstanceContext ) : [EOL] def __init__ ( self , evaluator , parent_context , class_context , var_args ) : [EOL] super ( TreeInstance , self ) . __init__ ( evaluator , parent_context , class_context , var_args ) [EOL] self . tree_node = class_context . tree_node [EOL] [EOL] @ property def name ( self ) : [EOL] return filters . ContextName ( self , self . class_context . name . tree_name ) [EOL] [EOL] [EOL] class AnonymousInstance ( TreeInstance ) : [EOL] def __init__ ( self , evaluator , parent_context , class_context ) : [EOL] super ( AnonymousInstance , self ) . __init__ ( evaluator , parent_context , class_context , var_args = None ) [EOL] [EOL] [EOL] class CompiledInstanceName ( compiled . CompiledName ) : [EOL] def __init__ ( self , evaluator , instance , parent_context , name ) : [EOL] super ( CompiledInstanceName , self ) . __init__ ( evaluator , parent_context , name ) [EOL] self . _instance = instance [EOL] [EOL] def infer ( self ) : [EOL] for result_context in super ( CompiledInstanceName , self ) . infer ( ) : [EOL] if isinstance ( result_context , er . FunctionContext ) : [EOL] parent_context = result_context . parent_context [EOL] while parent_context . is_class ( ) : [EOL] parent_context = parent_context . parent_context [EOL] [EOL] yield BoundMethod ( result_context . evaluator , self . _instance , self . parent_context , parent_context , result_context . tree_node ) [EOL] else : [EOL] if result_context . api_type == [string] : [EOL] yield CompiledBoundMethod ( result_context ) [EOL] else : [EOL] yield result_context [EOL] [EOL] [EOL] class CompiledInstanceClassFilter ( compiled . CompiledObjectFilter ) : [EOL] name_class = CompiledInstanceName [EOL] [EOL] def __init__ ( self , evaluator , instance , compiled_object ) : [EOL] super ( CompiledInstanceClassFilter , self ) . __init__ ( evaluator , compiled_object , is_instance = True , ) [EOL] self . _instance = instance [EOL] [EOL] def _create_name ( self , name ) : [EOL] return self . name_class ( self . _evaluator , self . _instance , self . _compiled_object , name ) [EOL] [EOL] [EOL] class BoundMethod ( er . FunctionContext ) : [EOL] def __init__ ( self , evaluator , instance , class_context , * args , ** kwargs ) : [EOL] super ( BoundMethod , self ) . __init__ ( evaluator , * args , ** kwargs ) [EOL] self . _instance = instance [EOL] self . _class_context = class_context [EOL] [EOL] def get_function_execution ( self , arguments = None ) : [EOL] if arguments is None : [EOL] return AnonymousInstanceFunctionExecution ( self . _instance , self . parent_context , self ) [EOL] else : [EOL] return InstanceFunctionExecution ( self . _instance , self . parent_context , self , arguments ) [EOL] [EOL] [EOL] class CompiledBoundMethod ( compiled . CompiledObject ) : [EOL] def __init__ ( self , func ) : [EOL] super ( CompiledBoundMethod , self ) . __init__ ( func . evaluator , func . obj , func . parent_context , func . tree_node ) [EOL] [EOL] def get_param_names ( self ) : [EOL] return list ( super ( CompiledBoundMethod , self ) . get_param_names ( ) ) [ [number] : ] [EOL] [EOL] [EOL] class InstanceNameDefinition ( filters . TreeNameDefinition ) : [EOL] def infer ( self ) : [EOL] contexts = super ( InstanceNameDefinition , self ) . infer ( ) [EOL] for context in contexts : [EOL] yield context [EOL] [EOL] [EOL] class LazyInstanceName ( filters . TreeNameDefinition ) : [EOL] [docstring] [EOL] def __init__ ( self , instance , class_context , tree_name ) : [EOL] self . _instance = instance [EOL] self . class_context = class_context [EOL] self . tree_name = tree_name [EOL] [EOL] @ property def parent_context ( self ) : [EOL] return self . _instance . create_instance_context ( self . class_context , self . tree_name ) [EOL] [EOL] [EOL] class LazyInstanceClassName ( LazyInstanceName ) : [EOL] def infer ( self ) : [EOL] for result_context in super ( LazyInstanceClassName , self ) . infer ( ) : [EOL] if isinstance ( result_context , er . FunctionContext ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parent_context = result_context . parent_context [EOL] while parent_context . is_class ( ) : [EOL] parent_context = parent_context . parent_context [EOL] [EOL] yield BoundMethod ( result_context . evaluator , self . _instance , self . class_context , parent_context , result_context . tree_node ) [EOL] else : [EOL] for c in er . apply_py__get__ ( result_context , self . _instance ) : [EOL] yield c [EOL] [EOL] [EOL] class InstanceClassFilter ( filters . ParserTreeFilter ) : [EOL] name_class = LazyInstanceClassName [EOL] [EOL] def __init__ ( self , evaluator , context , class_context , origin_scope ) : [EOL] super ( InstanceClassFilter , self ) . __init__ ( evaluator = evaluator , context = context , node_context = class_context , origin_scope = origin_scope ) [EOL] self . _class_context = class_context [EOL] [EOL] def _equals_origin_scope ( self ) : [EOL] node = self . _origin_scope [EOL] while node is not None : [EOL] if node == self . _parser_scope or node == self . context : [EOL] return True [EOL] node = get_parent_scope ( node ) [EOL] return False [EOL] [EOL] def _access_possible ( self , name ) : [EOL] return not name . value . startswith ( [string] ) or name . value . endswith ( [string] ) or self . _equals_origin_scope ( ) [EOL] [EOL] def _filter ( self , names ) : [EOL] names = super ( InstanceClassFilter , self ) . _filter ( names ) [EOL] return [ name for name in names if self . _access_possible ( name ) ] [EOL] [EOL] def _convert_names ( self , names ) : [EOL] return [ self . name_class ( self . context , self . _class_context , name ) for name in names ] [EOL] [EOL] [EOL] class SelfNameFilter ( InstanceClassFilter ) : [EOL] name_class = LazyInstanceName [EOL] [EOL] def _filter ( self , names ) : [EOL] names = self . _filter_self_names ( names ) [EOL] if isinstance ( self . _parser_scope , compiled . CompiledObject ) and False : [EOL] [comment] [EOL] return list ( names ) [EOL] else : [EOL] start , end = self . _parser_scope . start_pos , self . _parser_scope . end_pos [EOL] return [ n for n in names if start < n . start_pos < end ] [EOL] [EOL] def _filter_self_names ( self , names ) : [EOL] for name in names : [EOL] trailer = name . parent [EOL] if trailer . type == [string] \ [EOL] and len ( trailer . children ) == [number] \ [EOL] and trailer . children [ [number] ] == [string] : [EOL] if name . is_definition ( ) and self . _access_possible ( name ) : [EOL] yield name [EOL] [EOL] def _check_flows ( self , names ) : [EOL] return names [EOL] [EOL] [EOL] class ParamArguments ( object ) : [EOL] [docstring] [EOL] class LazyParamContext ( object ) : [EOL] def __init__ ( self , fucking_param ) : [EOL] self . _param = fucking_param [EOL] [EOL] def infer ( self ) : [EOL] return self . _param . infer ( ) [EOL] [EOL] def __init__ ( self , execution_context , funcdef ) : [EOL] self . _execution_context = execution_context [EOL] self . _funcdef = funcdef [EOL] [EOL] def unpack ( self , func = None ) : [EOL] params = search_params ( self . _execution_context . evaluator , self . _execution_context , self . _funcdef ) [EOL] is_first = True [EOL] for p in params : [EOL] [comment] [EOL] if is_first : [EOL] is_first = False [EOL] continue [EOL] yield None , self . LazyParamContext ( p ) [EOL] [EOL] [EOL] class InstanceVarArgs ( object ) : [EOL] def __init__ ( self , execution_context , funcdef , var_args ) : [EOL] self . _execution_context = execution_context [EOL] self . _funcdef = funcdef [EOL] self . _var_args = var_args [EOL] [EOL] @ memoize_method def _get_var_args ( self ) : [EOL] if self . _var_args is None : [EOL] [comment] [EOL] return ParamArguments ( self . _execution_context , self . _funcdef ) [EOL] [EOL] return self . _var_args [EOL] [EOL] def unpack ( self , func = None ) : [EOL] yield None , LazyKnownContext ( self . _execution_context . instance ) [EOL] for values in self . _get_var_args ( ) . unpack ( func ) : [EOL] yield values [EOL] [EOL] def get_calling_nodes ( self ) : [EOL] return self . _get_var_args ( ) . get_calling_nodes ( ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _var_args , name ) [EOL] [EOL] [EOL] class InstanceFunctionExecution ( er . FunctionExecutionContext ) : [EOL] def __init__ ( self , instance , parent_context , function_context , var_args ) : [EOL] self . instance = instance [EOL] var_args = InstanceVarArgs ( self , function_context . tree_node , var_args ) [EOL] [EOL] super ( InstanceFunctionExecution , self ) . __init__ ( instance . evaluator , parent_context , function_context , var_args ) [EOL] [EOL] [EOL] class AnonymousInstanceFunctionExecution ( InstanceFunctionExecution ) : [EOL] function_execution_filter = filters . AnonymousInstanceFunctionExecutionFilter [EOL] [EOL] def __init__ ( self , instance , parent_context , function_context ) : [EOL] super ( AnonymousInstanceFunctionExecution , self ) . __init__ ( instance , parent_context , function_context , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Iterable , Type , List , Tuple , Set , Iterator , Dict , Callable [EOL] import typing [EOL] [docstring] [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi import common [EOL] from jedi . common import unite , safe_property [EOL] from jedi . _compatibility import unicode , zip_longest , is_py3 [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate import context [EOL] from jedi . evaluate import precedence [EOL] from jedi . evaluate import recursion [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate . filters import DictFilter , AbstractNameDefinition , ParserTreeFilter [EOL] from jedi . parser_utils import get_comp_fors [EOL] [EOL] [EOL] class AbstractSequence ( context . Context ) : [EOL] builtin_methods = { } [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , evaluator ) : [EOL] super ( AbstractSequence , self ) . __init__ ( evaluator , evaluator . BUILTINS ) [EOL] [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def name ( self ) : [EOL] return compiled . CompiledContextName ( self , self . array_type ) [EOL] [EOL] [EOL] class BuiltinMethod ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , builtin_context , method , builtin_func ) : [EOL] self . _builtin_context = builtin_context [EOL] self . _method = method [EOL] self . _builtin_func = builtin_func [EOL] [EOL] def py__call__ ( self , params ) : [EOL] return self . _method ( self . _builtin_context ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _builtin_func , name ) [EOL] [EOL] [EOL] class SpecialMethodFilter ( DictFilter ) : [EOL] [docstring] [EOL] class SpecialMethodName ( AbstractNameDefinition ) : [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , parent_context , string_name , callable_ , builtin_context ) : [EOL] self . parent_context = parent_context [EOL] self . string_name = string_name [EOL] self . _callable = callable_ [EOL] self . _builtin_context = builtin_context [EOL] [EOL] def infer ( self ) : [EOL] filter = next ( self . _builtin_context . get_filters ( ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] builtin_func = next ( iter ( filter . get ( self . string_name ) [ [number] ] . infer ( ) ) ) [EOL] return set ( [ BuiltinMethod ( self . parent_context , self . _callable , builtin_func ) ] ) [EOL] [EOL] def __init__ ( self , context , dct , builtin_context ) : [EOL] super ( SpecialMethodFilter , self ) . __init__ ( dct ) [EOL] self . context = context [EOL] self . _builtin_context = builtin_context [EOL] [docstring] [EOL] [EOL] def _convert ( self , name , value ) : [EOL] return self . SpecialMethodName ( self . context , name , value , self . _builtin_context ) [EOL] [EOL] [EOL] def has_builtin_methods ( cls ) : [EOL] base_dct = { } [EOL] [comment] [EOL] [comment] [EOL] for base_cls in reversed ( cls . __bases__ ) : [EOL] try : [EOL] base_dct . update ( base_cls . builtin_methods ) [EOL] except AttributeError : [EOL] pass [EOL] [EOL] cls . builtin_methods = base_dct [EOL] for func in cls . __dict__ . values ( ) : [EOL] try : [EOL] cls . builtin_methods . update ( func . registered_builtin_methods ) [EOL] except AttributeError : [EOL] pass [EOL] return cls [EOL] [EOL] [EOL] def register_builtin_method ( method_name , python_version_match = None ) : [EOL] def wrapper ( func ) : [EOL] if python_version_match and python_version_match != [number] + int ( is_py3 ) : [EOL] [comment] [EOL] return func [EOL] dct = func . __dict__ . setdefault ( [string] , { } ) [EOL] dct [ method_name ] = func [EOL] return func [EOL] return wrapper [EOL] [EOL] [EOL] @ has_builtin_methods class GeneratorMixin ( object ) : [EOL] array_type = None [EOL] [EOL] @ register_builtin_method ( [string] ) @ register_builtin_method ( [string] , python_version_match = [number] ) @ register_builtin_method ( [string] , python_version_match = [number] ) def py__next__ ( self ) : [EOL] [comment] [EOL] return unite ( lazy_context . infer ( ) for lazy_context in self . py__iter__ ( ) ) [EOL] [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] gen_obj = compiled . get_special_object ( self . evaluator , [string] ) [EOL] yield SpecialMethodFilter ( self , self . builtin_methods , gen_obj ) [EOL] for filter in gen_obj . get_filters ( search_global ) : [EOL] yield filter [EOL] [EOL] def py__bool__ ( self ) : [EOL] return True [EOL] [EOL] def py__class__ ( self ) : [EOL] gen_obj = compiled . get_special_object ( self . evaluator , [string] ) [EOL] return gen_obj . py__class__ ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] return compiled . CompiledContextName ( self , [string] ) [EOL] [EOL] [EOL] class Generator ( GeneratorMixin , context . Context ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , evaluator , func_execution_context ) : [EOL] super ( Generator , self ) . __init__ ( evaluator , parent_context = evaluator . BUILTINS ) [EOL] self . _func_execution_context = func_execution_context [EOL] [EOL] def py__iter__ ( self ) : [EOL] return self . _func_execution_context . get_yield_values ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _func_execution_context ) [EOL] [EOL] [EOL] class CompForContext ( context . TreeContext ) : [EOL] @ classmethod def from_comp_for ( cls , parent_context , comp_for ) : [EOL] return cls ( parent_context . evaluator , parent_context , comp_for ) [EOL] [EOL] def __init__ ( self , evaluator , parent_context , comp_for ) : [EOL] super ( CompForContext , self ) . __init__ ( evaluator , parent_context ) [EOL] self . tree_node = comp_for [EOL] [EOL] def get_node ( self ) : [EOL] return self . tree_node [EOL] [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] yield ParserTreeFilter ( self . evaluator , self ) [EOL] [EOL] [EOL] class Comprehension ( AbstractSequence ) : [EOL] @ staticmethod def from_atom ( evaluator , context , atom ) : [EOL] bracket = atom . children [ [number] ] [EOL] if bracket == [string] : [EOL] if atom . children [ [number] ] . children [ [number] ] == [string] : [EOL] cls = DictComprehension [EOL] else : [EOL] cls = SetComprehension [EOL] elif bracket == [string] : [EOL] cls = GeneratorComprehension [EOL] elif bracket == [string] : [EOL] cls = ListComprehension [EOL] return cls ( evaluator , context , atom ) [EOL] [EOL] def __init__ ( self , evaluator , defining_context , atom ) : [EOL] super ( Comprehension , self ) . __init__ ( evaluator ) [EOL] self . _defining_context = defining_context [EOL] self . _atom = atom [EOL] [EOL] def _get_comprehension ( self ) : [EOL] [comment] [EOL] return self . _atom . children [ [number] ] [EOL] [EOL] def _get_comp_for ( self ) : [EOL] [comment] [EOL] return self . _get_comprehension ( ) . children [ [number] ] [EOL] [EOL] def _eval_node ( self , index = [number] ) : [EOL] [docstring] [EOL] return self . _get_comprehension ( ) . children [ index ] [EOL] [EOL] @ memoize_default ( ) def _get_comp_for_context ( self , parent_context , comp_for ) : [EOL] [comment] [EOL] return CompForContext . from_comp_for ( parent_context , comp_for ) [EOL] [EOL] def _nested ( self , comp_fors , parent_context = None ) : [EOL] evaluator = self . evaluator [EOL] comp_for = comp_fors [ [number] ] [EOL] input_node = comp_for . children [ [number] ] [EOL] parent_context = parent_context or self . _defining_context [EOL] input_types = parent_context . eval_node ( input_node ) [EOL] [EOL] cn = context . ContextualizedNode ( parent_context , input_node ) [EOL] iterated = py__iter__ ( evaluator , input_types , cn ) [EOL] exprlist = comp_for . children [ [number] ] [EOL] for i , lazy_context in enumerate ( iterated ) : [EOL] types = lazy_context . infer ( ) [EOL] dct = unpack_tuple_to_dict ( parent_context , types , exprlist ) [EOL] context_ = self . _get_comp_for_context ( parent_context , comp_for , ) [EOL] with helpers . predefine_names ( context_ , comp_for , dct ) : [EOL] try : [EOL] for result in self . _nested ( comp_fors [ [number] : ] , context_ ) : [EOL] yield result [EOL] except IndexError : [EOL] iterated = context_ . eval_node ( self . _eval_node ( ) ) [EOL] if self . array_type == [string] : [EOL] yield iterated , context_ . eval_node ( self . _eval_node ( [number] ) ) [EOL] else : [EOL] yield iterated [EOL] [EOL] @ memoize_default ( default = [ ] ) @ common . to_list def _iterate ( self ) : [EOL] comp_fors = tuple ( get_comp_fors ( self . _get_comp_for ( ) ) ) [EOL] for result in self . _nested ( comp_fors ) : [EOL] yield result [EOL] [EOL] def py__iter__ ( self ) : [EOL] for set_ in self . _iterate ( ) : [EOL] yield context . LazyKnownContexts ( set_ ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _atom ) [EOL] [EOL] [EOL] class ArrayMixin ( object ) : [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] [comment] [EOL] compiled_obj = compiled . builtin_from_name ( self . evaluator , self . array_type ) [EOL] yield SpecialMethodFilter ( self , self . builtin_methods , compiled_obj ) [EOL] for typ in compiled_obj . execute_evaluated ( self ) : [EOL] for filter in typ . get_filters ( ) : [EOL] yield filter [EOL] [EOL] def py__bool__ ( self ) : [EOL] return None [comment] [EOL] [EOL] def py__class__ ( self ) : [EOL] return compiled . builtin_from_name ( self . evaluator , self . array_type ) [EOL] [EOL] @ safe_property def parent ( self ) : [EOL] return self . evaluator . BUILTINS [EOL] [EOL] def dict_values ( self ) : [EOL] return unite ( self . _defining_context . eval_node ( v ) for k , v in self . _items ( ) ) [EOL] [EOL] [EOL] class ListComprehension ( ArrayMixin , Comprehension ) : [EOL] array_type = [string] [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] if isinstance ( index , slice ) : [EOL] return set ( [ self ] ) [EOL] [EOL] all_types = list ( self . py__iter__ ( ) ) [EOL] return all_types [ index ] . infer ( ) [EOL] [EOL] [EOL] class SetComprehension ( ArrayMixin , Comprehension ) : [EOL] array_type = [string] [EOL] [EOL] [EOL] @ has_builtin_methods class DictComprehension ( ArrayMixin , Comprehension ) : [EOL] array_type = [string] [EOL] [EOL] def _get_comp_for ( self ) : [EOL] return self . _get_comprehension ( ) . children [ [number] ] [EOL] [EOL] def py__iter__ ( self ) : [EOL] for keys , values in self . _iterate ( ) : [EOL] yield context . LazyKnownContexts ( keys ) [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] for keys , values in self . _iterate ( ) : [EOL] for k in keys : [EOL] if isinstance ( k , compiled . CompiledObject ) : [EOL] if k . obj == index : [EOL] return values [EOL] return self . dict_values ( ) [EOL] [EOL] def dict_values ( self ) : [EOL] return unite ( values for keys , values in self . _iterate ( ) ) [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_values ( self ) : [EOL] lazy_context = context . LazyKnownContexts ( self . dict_values ( ) ) [EOL] return set ( [ FakeSequence ( self . evaluator , [string] , [ lazy_context ] ) ] ) [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_items ( self ) : [EOL] items = set ( FakeSequence ( self . evaluator , [string] ( context . LazyKnownContexts ( keys ) , context . LazyKnownContexts ( values ) ) ) for keys , values in self . _iterate ( ) ) [EOL] [EOL] return create_evaluated_sequence_set ( self . evaluator , items , sequence_type = [string] ) [EOL] [EOL] [EOL] class GeneratorComprehension ( GeneratorMixin , Comprehension ) : [EOL] pass [EOL] [EOL] [EOL] class SequenceLiteralContext ( ArrayMixin , AbstractSequence ) : [EOL] mapping = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] def __init__ ( self , evaluator , defining_context , atom ) : [EOL] super ( SequenceLiteralContext , self ) . __init__ ( evaluator ) [EOL] self . atom = atom [EOL] self . _defining_context = defining_context [EOL] [EOL] if self . atom . type in ( [string] , [string] ) : [EOL] self . array_type = [string] [EOL] else : [EOL] self . array_type = SequenceLiteralContext . mapping [ atom . children [ [number] ] ] [EOL] [docstring] [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] [docstring] [EOL] if self . array_type == [string] : [EOL] for key , value in self . _items ( ) : [EOL] for k in self . _defining_context . eval_node ( key ) : [EOL] if isinstance ( k , compiled . CompiledObject ) \ [EOL] and index == k . obj : [EOL] return self . _defining_context . eval_node ( value ) [EOL] raise KeyError ( [string] % self ) [EOL] [EOL] [comment] [EOL] if isinstance ( index , slice ) : [EOL] return set ( [ self ] ) [EOL] else : [EOL] return self . _defining_context . eval_node ( self . _items ( ) [ index ] ) [EOL] [EOL] def py__iter__ ( self ) : [EOL] [docstring] [EOL] if self . array_type == [string] : [EOL] [comment] [EOL] types = set ( ) [EOL] for k , _ in self . _items ( ) : [EOL] types |= self . _defining_context . eval_node ( k ) [EOL] [comment] [EOL] [comment] [EOL] for _ in types : [EOL] yield context . LazyKnownContexts ( types ) [EOL] else : [EOL] for node in self . _items ( ) : [EOL] yield context . LazyTreeContext ( self . _defining_context , node ) [EOL] [EOL] for addition in check_array_additions ( self . _defining_context , self ) : [EOL] yield addition [EOL] [EOL] def _values ( self ) : [EOL] [docstring] [EOL] if self . array_type == [string] : [EOL] return unite ( v for k , v in self . _items ( ) ) [EOL] else : [EOL] return self . _items ( ) [EOL] [EOL] def _items ( self ) : [EOL] c = self . atom . children [EOL] [EOL] if self . atom . type in ( [string] , [string] ) : [EOL] return c [ : : [number] ] [EOL] [EOL] array_node = c [ [number] ] [EOL] if array_node in ( [string] , [string] , [string] ) : [EOL] return [ ] [comment] [EOL] [EOL] if array_node . type == [string] : [EOL] return array_node . children [ : : [number] ] [EOL] elif array_node . type == [string] : [EOL] kv = [ ] [EOL] iterator = iter ( array_node . children ) [EOL] for key in iterator : [EOL] op = next ( iterator , None ) [EOL] if op is None or op == [string] : [EOL] kv . append ( key ) [comment] [EOL] else : [EOL] assert op == [string] [comment] [EOL] kv . append ( ( key , next ( iterator ) ) ) [EOL] next ( iterator , None ) [comment] [EOL] return kv [EOL] else : [EOL] return [ array_node ] [EOL] [EOL] def exact_key_items ( self ) : [EOL] [docstring] [EOL] for key_node , value in self . _items ( ) : [EOL] for key in self . _defining_context . eval_node ( key_node ) : [EOL] if precedence . is_string ( key ) : [EOL] yield key . obj , context . LazyTreeContext ( self . _defining_context , value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . atom ) [EOL] [EOL] [EOL] @ has_builtin_methods class DictLiteralContext ( SequenceLiteralContext ) : [EOL] array_type = [string] [EOL] [EOL] def __init__ ( self , evaluator , defining_context , atom ) : [EOL] super ( SequenceLiteralContext , self ) . __init__ ( evaluator ) [EOL] self . _defining_context = defining_context [EOL] self . atom = atom [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_values ( self ) : [EOL] lazy_context = context . LazyKnownContexts ( self . dict_values ( ) ) [EOL] return set ( [ FakeSequence ( self . evaluator , [string] , [ lazy_context ] ) ] ) [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_items ( self ) : [EOL] lazy_contexts = [ context . LazyKnownContext ( FakeSequence ( self . evaluator , [string] , ( context . LazyTreeContext ( self . _defining_context , key_node ) , context . LazyTreeContext ( self . _defining_context , value_node ) ) ) ) for key_node , value_node in self . _items ( ) ] [EOL] [EOL] return set ( [ FakeSequence ( self . evaluator , [string] , lazy_contexts ) ] ) [EOL] [EOL] [EOL] class _FakeArray ( SequenceLiteralContext ) : [EOL] def __init__ ( self , evaluator , container , type ) : [EOL] super ( SequenceLiteralContext , self ) . __init__ ( evaluator ) [EOL] self . array_type = type [EOL] self . atom = container [EOL] [comment] [EOL] [EOL] [EOL] class FakeSequence ( _FakeArray ) : [EOL] def __init__ ( self , evaluator , array_type , lazy_context_list ) : [EOL] [docstring] [EOL] super ( FakeSequence , self ) . __init__ ( evaluator , None , array_type ) [EOL] self . _lazy_context_list = lazy_context_list [EOL] [EOL] def _items ( self ) : [EOL] raise DeprecationWarning [EOL] return self . _context_list [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] return set ( self . _lazy_context_list [ index ] . infer ( ) ) [EOL] [EOL] def py__iter__ ( self ) : [EOL] return self . _lazy_context_list [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _lazy_context_list ) [EOL] [EOL] [EOL] class FakeDict ( _FakeArray ) : [EOL] def __init__ ( self , evaluator , dct ) : [EOL] super ( FakeDict , self ) . __init__ ( evaluator , dct , [string] ) [EOL] self . _dct = dct [EOL] [EOL] def py__iter__ ( self ) : [EOL] for key in self . _dct : [EOL] yield context . LazyKnownContext ( compiled . create ( self . evaluator , key ) ) [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] return self . _dct [ index ] . infer ( ) [EOL] [EOL] def dict_values ( self ) : [EOL] return unite ( lazy_context . infer ( ) for lazy_context in self . _dct . values ( ) ) [EOL] [EOL] def _items ( self ) : [EOL] raise DeprecationWarning [EOL] for key , values in self . _dct . items ( ) : [EOL] [comment] [EOL] yield key , values [ [number] ] [EOL] [EOL] def exact_key_items ( self ) : [EOL] return self . _dct . items ( ) [EOL] [EOL] [EOL] class MergedArray ( _FakeArray ) : [EOL] def __init__ ( self , evaluator , arrays ) : [EOL] super ( MergedArray , self ) . __init__ ( evaluator , arrays , arrays [ - [number] ] . array_type ) [EOL] self . _arrays = arrays [EOL] [EOL] def py__iter__ ( self ) : [EOL] for array in self . _arrays : [EOL] for lazy_context in array . py__iter__ ( ) : [EOL] yield lazy_context [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] return unite ( lazy_context . infer ( ) for lazy_context in self . py__iter__ ( ) ) [EOL] [EOL] def _items ( self ) : [EOL] for array in self . _arrays : [EOL] for a in array . _items ( ) : [EOL] yield a [EOL] [EOL] def __len__ ( self ) : [EOL] return sum ( len ( a ) for a in self . _arrays ) [EOL] [EOL] [EOL] def unpack_tuple_to_dict ( context , types , exprlist ) : [EOL] [docstring] [EOL] if exprlist . type == [string] : [EOL] return { exprlist . value : types } [EOL] elif exprlist . type == [string] and exprlist . children [ [number] ] in [string] : [EOL] return unpack_tuple_to_dict ( context , types , exprlist . children [ [number] ] ) [EOL] elif exprlist . type in ( [string] , [string] , [string] , [string] ) : [EOL] dct = { } [EOL] parts = iter ( exprlist . children [ : : [number] ] ) [EOL] n = [number] [EOL] for lazy_context in py__iter__ ( context . evaluator , types , exprlist ) : [EOL] n += [number] [EOL] try : [EOL] part = next ( parts ) [EOL] except StopIteration : [EOL] [comment] [EOL] analysis . add ( context , [string] , part , message = [string] % n ) [EOL] else : [EOL] dct . update ( unpack_tuple_to_dict ( context , lazy_context . infer ( ) , part ) ) [EOL] has_parts = next ( parts , None ) [EOL] if types and has_parts is not None : [EOL] [comment] [EOL] analysis . add ( context , [string] , has_parts , message = [string] % n ) [EOL] return dct [EOL] elif exprlist . type == [string] or exprlist . type == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return { } [EOL] elif exprlist . type == [string] : [comment] [EOL] [comment] [EOL] return { } [EOL] raise NotImplementedError [EOL] [EOL] [EOL] def py__iter__ ( evaluator , types , contextualized_node = None ) : [EOL] debug . dbg ( [string] ) [EOL] type_iters = [ ] [EOL] for typ in types : [EOL] try : [EOL] iter_method = typ . py__iter__ [EOL] except AttributeError : [EOL] if contextualized_node is not None : [EOL] analysis . add ( contextualized_node . context , [string] , contextualized_node . _node , message = [string] % typ ) [EOL] else : [EOL] type_iters . append ( iter_method ( ) ) [EOL] [EOL] for lazy_contexts in zip_longest ( * type_iters ) : [EOL] yield context . get_merged_lazy_context ( [ l for l in lazy_contexts if l is not None ] ) [EOL] [EOL] [EOL] def py__iter__types ( evaluator , types , contextualized_node = None ) : [EOL] [docstring] [EOL] return unite ( lazy_context . infer ( ) for lazy_context in py__iter__ ( evaluator , types , contextualized_node ) ) [EOL] [EOL] [EOL] def py__getitem__ ( evaluator , context , types , trailer ) : [EOL] from jedi . evaluate . representation import ClassContext [EOL] from jedi . evaluate . instance import TreeInstance [EOL] result = set ( ) [EOL] [EOL] trailer_op , node , trailer_cl = trailer . children [EOL] assert trailer_op == [string] [EOL] assert trailer_cl == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for typ in list ( types ) : [EOL] if isinstance ( typ , ( ClassContext , TreeInstance ) ) : [EOL] typing_module_types = pep0484 . py__getitem__ ( context , typ , node ) [EOL] if typing_module_types is not None : [EOL] types . remove ( typ ) [EOL] result |= typing_module_types [EOL] [EOL] if not types : [EOL] [comment] [EOL] return result [EOL] [EOL] for index in create_index_types ( evaluator , context , node ) : [EOL] if isinstance ( index , ( compiled . CompiledObject , Slice ) ) : [EOL] index = index . obj [EOL] [EOL] if type ( index ) not in ( float , int , str , unicode , slice ) : [EOL] [comment] [EOL] [comment] [EOL] for typ in list ( types ) : [EOL] if isinstance ( typ , AbstractSequence ) and typ . array_type == [string] : [EOL] types . remove ( typ ) [EOL] result |= typ . dict_values ( ) [EOL] return result | py__iter__types ( evaluator , types ) [EOL] [EOL] for typ in types : [EOL] [comment] [EOL] try : [EOL] getitem = typ . py__getitem__ [EOL] except AttributeError : [EOL] [comment] [EOL] analysis . add ( context , [string] , trailer_op , message = [string] % typ ) [EOL] else : [EOL] try : [EOL] result |= getitem ( index ) [EOL] except IndexError : [EOL] result |= py__iter__types ( evaluator , set ( [ typ ] ) ) [EOL] except KeyError : [EOL] [comment] [EOL] result |= typ . dict_values ( ) [EOL] return result [EOL] [EOL] [EOL] def check_array_additions ( context , sequence ) : [EOL] [docstring] [EOL] if sequence . array_type not in ( [string] , [string] ) : [EOL] [comment] [EOL] return set ( ) [EOL] [EOL] return _check_array_additions ( context , sequence ) [EOL] [EOL] [EOL] @ memoize_default ( default = set ( ) ) @ debug . increase_indent def _check_array_additions ( context , sequence ) : [EOL] [docstring] [EOL] from jedi . evaluate import param [EOL] [EOL] debug . dbg ( [string] % sequence , color = [string] ) [EOL] module_context = context . get_root_context ( ) [EOL] if not settings . dynamic_array_additions or isinstance ( module_context , compiled . CompiledObject ) : [EOL] debug . dbg ( [string] , color = [string] ) [EOL] return set ( ) [EOL] [EOL] def find_additions ( context , arglist , add_name ) : [EOL] params = list ( param . TreeArguments ( context . evaluator , context , arglist ) . unpack ( ) ) [EOL] result = set ( ) [EOL] if add_name in [ [string] ] : [EOL] params = params [ [number] : ] [EOL] if add_name in [ [string] , [string] , [string] ] : [EOL] for key , lazy_context in params : [EOL] result . add ( lazy_context ) [EOL] elif add_name in [ [string] , [string] ] : [EOL] for key , lazy_context in params : [EOL] result |= set ( py__iter__ ( context . evaluator , lazy_context . infer ( ) ) ) [EOL] return result [EOL] [EOL] temp_param_add , settings . dynamic_params_for_other_modules = settings . dynamic_params_for_other_modules , False [EOL] [EOL] is_list = sequence . name . string_name == [string] [EOL] search_names = ( [ [string] , [string] , [string] ] if is_list else [ [string] , [string] ] ) [EOL] [EOL] added_types = set ( ) [EOL] for add_name in search_names : [EOL] try : [EOL] possible_names = module_context . tree_node . get_used_names ( ) [ add_name ] [EOL] except KeyError : [EOL] continue [EOL] else : [EOL] for name in possible_names : [EOL] context_node = context . tree_node [EOL] if not ( context_node . start_pos < name . start_pos < context_node . end_pos ) : [EOL] continue [EOL] trailer = name . parent [EOL] power = trailer . parent [EOL] trailer_pos = power . children . index ( trailer ) [EOL] try : [EOL] execution_trailer = power . children [ trailer_pos + [number] ] [EOL] except IndexError : [EOL] continue [EOL] else : [EOL] if execution_trailer . type != [string] or execution_trailer . children [ [number] ] != [string] or execution_trailer . children [ [number] ] == [string] : [EOL] continue [EOL] [EOL] random_context = context . create_context ( name ) [EOL] [EOL] with recursion . execution_allowed ( context . evaluator , power ) as allowed : [EOL] if allowed : [EOL] found = helpers . evaluate_call_of_leaf ( random_context , name , cut_own_trailer = True ) [EOL] if sequence in found : [EOL] [comment] [EOL] added_types |= find_additions ( random_context , execution_trailer . children [ [number] ] , add_name ) [EOL] [EOL] [comment] [EOL] settings . dynamic_params_for_other_modules = temp_param_add [EOL] debug . dbg ( [string] % added_types , color = [string] ) [EOL] return added_types [EOL] [EOL] [EOL] def get_dynamic_array_instance ( instance ) : [EOL] [docstring] [EOL] if not settings . dynamic_array_additions : [EOL] return instance . var_args [EOL] [EOL] ai = _ArrayInstance ( instance ) [EOL] from jedi . evaluate import param [EOL] return param . ValuesArguments ( [ [ ai ] ] ) [EOL] [EOL] [EOL] class _ArrayInstance ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , instance ) : [EOL] self . instance = instance [EOL] self . var_args = instance . var_args [EOL] [EOL] def py__iter__ ( self ) : [EOL] var_args = self . var_args [EOL] try : [EOL] _ , lazy_context = next ( var_args . unpack ( ) ) [EOL] except StopIteration : [EOL] pass [EOL] else : [EOL] for lazy in py__iter__ ( self . instance . evaluator , lazy_context . infer ( ) ) : [EOL] yield lazy [EOL] [EOL] from jedi . evaluate import param [EOL] if isinstance ( var_args , param . TreeArguments ) : [EOL] additions = _check_array_additions ( var_args . context , self . instance ) [EOL] for addition in additions : [EOL] yield addition [EOL] [EOL] [EOL] class Slice ( context . Context ) : [EOL] def __init__ ( self , context , start , stop , step ) : [EOL] super ( Slice , self ) . __init__ ( context . evaluator , parent_context = context . evaluator . BUILTINS ) [EOL] self . _context = context [EOL] [comment] [EOL] self . _start = start [EOL] self . _stop = stop [EOL] self . _step = step [EOL] [EOL] @ property def obj ( self ) : [EOL] [docstring] [EOL] def get ( element ) : [EOL] if element is None : [EOL] return None [EOL] [EOL] result = self . _context . eval_node ( element ) [EOL] if len ( result ) != [number] : [EOL] [comment] [EOL] [comment] [EOL] raise IndexError [EOL] try : [EOL] return list ( result ) [ [number] ] . obj [EOL] except AttributeError : [EOL] return None [EOL] [EOL] try : [EOL] return slice ( get ( self . _start ) , get ( self . _stop ) , get ( self . _step ) ) [EOL] except IndexError : [EOL] return slice ( None , None , None ) [EOL] [EOL] [EOL] def create_index_types ( evaluator , context , index ) : [EOL] [docstring] [EOL] if index == [string] : [EOL] [comment] [EOL] return set ( [ Slice ( context , None , None , None ) ] ) [EOL] elif index . type == [string] : [comment] [EOL] [comment] [EOL] result = [ ] [EOL] for el in index . children : [EOL] if el == [string] : [EOL] if not result : [EOL] result . append ( None ) [EOL] elif el . type == [string] : [EOL] if len ( el . children ) == [number] : [EOL] result . append ( el . children [ [number] ] ) [EOL] else : [EOL] result . append ( el ) [EOL] result += [ None ] * ( [number] - len ( result ) ) [EOL] [EOL] return set ( [ Slice ( context , * result ) ] ) [EOL] [EOL] [comment] [EOL] return context . eval_node ( index ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[[None,typing.Iterable[typing.Optional[Variable[_T]]]],typing.Iterator[Variable[_T]]][[typing.Callable[[Variable[_T]],typing.Any],typing.Iterable[Variable[_T]]],typing.Iterator[Variable[_T]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Callable[[[None,typing.Iterable[typing.Optional[Variable[_T]]]],typing.Iterator[Variable[_T]]][[typing.Callable[[Variable[_T]],typing.Any],typing.Iterable[Variable[_T]]],typing.Iterator[Variable[_T]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Set [EOL] import typing [EOL] import glob [EOL] import os [EOL] import sys [EOL] from jedi . evaluate . site import addsitedir [EOL] [EOL] from jedi . _compatibility import exec_function , unicode [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . python import parse [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi import debug [EOL] from jedi import common [EOL] from jedi . evaluate . compiled import CompiledObject [EOL] from jedi . evaluate . context import ContextualizedNode [EOL] [EOL] [EOL] def get_venv_path ( venv ) : [EOL] [docstring] [EOL] sys_path = _get_venv_path_dirs ( venv ) [EOL] with common . ignored ( ValueError ) : [EOL] sys_path . remove ( [string] ) [EOL] sys_path = _get_sys_path_with_egglinks ( sys_path ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return sys_path + sys . path [EOL] [EOL] [EOL] def _get_sys_path_with_egglinks ( sys_path ) : [EOL] [docstring] [EOL] result = [ ] [EOL] for p in sys_path : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for egg_link in sorted ( glob . glob ( os . path . join ( p , [string] ) ) ) : [EOL] with open ( egg_link ) as fd : [EOL] for line in fd : [EOL] line = line . strip ( ) [EOL] if line : [EOL] result . append ( os . path . join ( p , line ) ) [EOL] [comment] [EOL] [comment] [EOL] break [EOL] result . append ( p ) [EOL] return result [EOL] [EOL] [EOL] def _get_venv_path_dirs ( venv ) : [EOL] [docstring] [EOL] venv = os . path . abspath ( venv ) [EOL] sitedir = _get_venv_sitepackages ( venv ) [EOL] sys_path = [ ] [EOL] addsitedir ( sys_path , sitedir ) [EOL] return sys_path [EOL] [EOL] [EOL] def _get_venv_sitepackages ( venv ) : [EOL] if os . name == [string] : [EOL] p = os . path . join ( venv , [string] , [string] ) [EOL] else : [EOL] p = os . path . join ( venv , [string] , [string] % sys . version_info [ : [number] ] , [string] ) [EOL] return p [EOL] [EOL] [EOL] def _execute_code ( module_path , code ) : [EOL] c = [string] [EOL] variables = { [string] : module_path } [EOL] try : [EOL] exec_function ( c % code , variables ) [EOL] except Exception : [EOL] debug . warning ( [string] ) [EOL] else : [EOL] try : [EOL] res = variables [ [string] ] [EOL] if isinstance ( res , str ) : [EOL] return [ os . path . abspath ( res ) ] [EOL] except KeyError : [EOL] pass [EOL] return [ ] [EOL] [EOL] [EOL] def _paths_from_assignment ( module_context , expr_stmt ) : [EOL] [docstring] [EOL] for assignee , operator in zip ( expr_stmt . children [ : : [number] ] , expr_stmt . children [ [number] : : [number] ] ) : [EOL] try : [EOL] assert operator in [ [string] , [string] ] [EOL] assert assignee . type in ( [string] , [string] ) and len ( assignee . children ) > [number] [EOL] c = assignee . children [EOL] assert c [ [number] ] . type == [string] and c [ [number] ] . value == [string] [EOL] trailer = c [ [number] ] [EOL] assert trailer . children [ [number] ] == [string] and trailer . children [ [number] ] . value == [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] except AssertionError : [EOL] continue [EOL] [EOL] from jedi . evaluate . iterable import py__iter__ [EOL] from jedi . evaluate . precedence import is_string [EOL] cn = ContextualizedNode ( module_context . create_context ( expr_stmt ) , expr_stmt ) [EOL] for lazy_context in py__iter__ ( module_context . evaluator , cn . infer ( ) , cn ) : [EOL] for context in lazy_context . infer ( ) : [EOL] if is_string ( context ) : [EOL] yield context . obj [EOL] [EOL] [EOL] def _paths_from_list_modifications ( module_path , trailer1 , trailer2 ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if not ( trailer1 . type == [string] and trailer1 . children [ [number] ] == [string] [EOL] and trailer2 . type == [string] and trailer2 . children [ [number] ] == [string] [EOL] and len ( trailer2 . children ) == [number] ) : [EOL] return [ ] [EOL] [EOL] name = trailer1 . children [ [number] ] . value [EOL] if name not in [ [string] , [string] ] : [EOL] return [ ] [EOL] arg = trailer2 . children [ [number] ] [EOL] if name == [string] and len ( arg . children ) in ( [number] , [number] ) : [comment] [EOL] arg = arg . children [ [number] ] [EOL] return _execute_code ( module_path , arg . get_code ( ) ) [EOL] [EOL] [EOL] def _check_module ( module_context ) : [EOL] [docstring] [EOL] def get_sys_path_powers ( names ) : [EOL] for name in names : [EOL] power = name . parent . parent [EOL] if power . type in ( [string] , [string] ) : [EOL] c = power . children [EOL] if isinstance ( c [ [number] ] , tree . Name ) and c [ [number] ] . value == [string] \ [EOL] and c [ [number] ] . type == [string] : [EOL] n = c [ [number] ] . children [ [number] ] [EOL] if isinstance ( n , tree . Name ) and n . value == [string] : [EOL] yield name , power [EOL] [EOL] sys_path = list ( module_context . evaluator . sys_path ) [comment] [EOL] if isinstance ( module_context , CompiledObject ) : [EOL] return sys_path [EOL] [EOL] try : [EOL] possible_names = module_context . tree_node . get_used_names ( ) [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] for name , power in get_sys_path_powers ( possible_names ) : [EOL] stmt = name . get_definition ( ) [EOL] if len ( power . children ) >= [number] : [EOL] sys_path . extend ( _paths_from_list_modifications ( module_context . py__file__ ( ) , * power . children [ [number] : [number] ] ) ) [EOL] elif name . get_definition ( ) . type == [string] : [EOL] sys_path . extend ( _paths_from_assignment ( module_context , stmt ) ) [EOL] return sys_path [EOL] [EOL] [EOL] @ memoize_default ( evaluator_is_first_arg = True , default = [ ] ) def sys_path_with_modifications ( evaluator , module_context ) : [EOL] path = module_context . py__file__ ( ) [EOL] if path is None : [EOL] [comment] [EOL] [comment] [EOL] return list ( evaluator . sys_path ) [EOL] [EOL] curdir = os . path . abspath ( os . curdir ) [EOL] [comment] [EOL] with common . ignored ( OSError ) : [EOL] os . chdir ( os . path . dirname ( path ) ) [EOL] [EOL] buildout_script_paths = set ( ) [EOL] [EOL] result = _check_module ( module_context ) [EOL] result += _detect_django_path ( path ) [EOL] for buildout_script_path in _get_buildout_script_paths ( path ) : [EOL] for path in _get_paths_from_buildout_script ( evaluator , buildout_script_path ) : [EOL] buildout_script_paths . add ( path ) [EOL] [comment] [EOL] os . chdir ( curdir ) [EOL] return list ( result ) + list ( buildout_script_paths ) [EOL] [EOL] [EOL] def _get_paths_from_buildout_script ( evaluator , buildout_script_path ) : [EOL] try : [EOL] module_node = parse ( path = buildout_script_path , grammar = evaluator . grammar , cache = True ) [EOL] except IOError : [EOL] debug . warning ( [string] , buildout_script_path ) [EOL] return [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] for path in _check_module ( ModuleContext ( evaluator , module_node , buildout_script_path ) ) : [EOL] yield path [EOL] [EOL] [EOL] def traverse_parents ( path ) : [EOL] while True : [EOL] new = os . path . dirname ( path ) [EOL] if new == path : [EOL] return [EOL] path = new [EOL] yield path [EOL] [EOL] [EOL] def _get_parent_dir_with_file ( path , filename ) : [EOL] for parent in traverse_parents ( path ) : [EOL] if os . path . isfile ( os . path . join ( parent , filename ) ) : [EOL] return parent [EOL] return None [EOL] [EOL] [EOL] def _detect_django_path ( module_path ) : [EOL] [docstring] [EOL] result = [ ] [EOL] [EOL] for parent in traverse_parents ( module_path ) : [EOL] with common . ignored ( IOError ) : [EOL] with open ( parent + os . path . sep + [string] ) : [EOL] debug . dbg ( [string] , module_path ) [EOL] result . append ( parent ) [EOL] return result [EOL] [EOL] [EOL] def _get_buildout_script_paths ( module_path ) : [EOL] [docstring] [EOL] project_root = _get_parent_dir_with_file ( module_path , [string] ) [EOL] if not project_root : [EOL] return [ ] [EOL] bin_path = os . path . join ( project_root , [string] ) [EOL] if not os . path . exists ( bin_path ) : [EOL] return [ ] [EOL] extra_module_paths = [ ] [EOL] for filename in os . listdir ( bin_path ) : [EOL] try : [EOL] filepath = os . path . join ( bin_path , filename ) [EOL] with open ( filepath , [string] ) as f : [EOL] firstline = f . readline ( ) [EOL] if firstline . startswith ( [string] ) and [string] in firstline : [EOL] extra_module_paths . append ( filepath ) [EOL] except ( UnicodeDecodeError , IOError ) as e : [EOL] [comment] [EOL] [comment] [EOL] debug . warning ( unicode ( e ) ) [EOL] continue [EOL] return extra_module_paths [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Union , Type , List , Tuple , Iterator , Dict [EOL] import typing [EOL] [docstring] [EOL] from jedi import debug [EOL] from jedi . parser . python import tree [EOL] from jedi . evaluate . compiled import CompiledObject [EOL] [EOL] [EOL] CODES = { [string] : ( [number] , AttributeError , [string] ) , [string] : ( [number] , NameError , [string] ) , [string] : ( [number] , ImportError , [string] ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , ValueError , None ) , [string] : ( [number] , ValueError , None ) , } [EOL] [EOL] [EOL] class Error ( object ) : [EOL] def __init__ ( self , name , module_path , start_pos , message = None ) : [EOL] self . path = module_path [EOL] self . _start_pos = start_pos [EOL] self . name = name [EOL] if message is None : [EOL] message = CODES [ self . name ] [ [number] ] [EOL] self . message = message [EOL] [EOL] @ property def line ( self ) : [EOL] return self . _start_pos [ [number] ] [EOL] [EOL] @ property def column ( self ) : [EOL] return self . _start_pos [ [number] ] [EOL] [EOL] @ property def code ( self ) : [EOL] [comment] [EOL] first = self . __class__ . __name__ [ [number] ] [EOL] return first + str ( CODES [ self . name ] [ [number] ] ) [EOL] [EOL] def __unicode__ ( self ) : [EOL] return [string] % ( self . path , self . line , self . column , self . code , self . message ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . __unicode__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . path == other . path and self . name == other . name and self . _start_pos == other . _start_pos ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . path , self . _start_pos , self . name ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . name , self . path , self . _start_pos [ [number] ] , self . _start_pos [ [number] ] ) [EOL] [EOL] [EOL] class Warning ( Error ) : [EOL] pass [EOL] [EOL] [EOL] def add ( node_context , error_name , node , message = None , typ = Error , payload = None ) : [EOL] exception = CODES [ error_name ] [ [number] ] [EOL] if _check_for_exception_catch ( node_context , node , exception , payload ) : [EOL] return [EOL] [EOL] [comment] [EOL] module_context = node_context . get_root_context ( ) [EOL] module_path = module_context . py__file__ ( ) [EOL] instance = typ ( error_name , module_path , node . start_pos , message ) [EOL] debug . warning ( str ( instance ) , format = False ) [EOL] node_context . evaluator . analysis . append ( instance ) [EOL] [EOL] [EOL] def _check_for_setattr ( instance ) : [EOL] [docstring] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] module = instance . get_root_context ( ) [EOL] if not isinstance ( module , ModuleContext ) : [EOL] return False [EOL] [EOL] node = module . tree_node [EOL] try : [EOL] stmts = node . get_used_names ( ) [ [string] ] [EOL] except KeyError : [EOL] return False [EOL] [EOL] return any ( node . start_pos < stmt . start_pos < node . end_pos for stmt in stmts ) [EOL] [EOL] [EOL] def add_attribute_error ( name_context , lookup_context , name ) : [EOL] message = ( [string] % ( lookup_context , name ) ) [EOL] from jedi . evaluate . instance import AbstractInstanceContext , CompiledInstanceName [EOL] [comment] [EOL] [comment] [EOL] typ = Error [EOL] if isinstance ( lookup_context , AbstractInstanceContext ) : [EOL] slot_names = lookup_context . get_function_slot_names ( [string] ) + lookup_context . get_function_slot_names ( [string] ) [EOL] for n in slot_names : [EOL] if isinstance ( name , CompiledInstanceName ) and n . parent_context . obj == object : [EOL] typ = Warning [EOL] break [EOL] [EOL] if _check_for_setattr ( lookup_context ) : [EOL] typ = Warning [EOL] [EOL] payload = lookup_context , name [EOL] add ( name_context , [string] , name , message , typ , payload ) [EOL] [EOL] [EOL] def _check_for_exception_catch ( node_context , jedi_name , exception , payload = None ) : [EOL] [docstring] [EOL] def check_match ( cls , exception ) : [EOL] try : [EOL] return isinstance ( cls , CompiledObject ) and issubclass ( exception , cls . obj ) [EOL] except TypeError : [EOL] return False [EOL] [EOL] def check_try_for_except ( obj , exception ) : [EOL] [comment] [EOL] iterator = iter ( obj . children ) [EOL] for branch_type in iterator : [EOL] colon = next ( iterator ) [EOL] suite = next ( iterator ) [EOL] if branch_type == [string] \ [EOL] and not ( branch_type . start_pos < jedi_name . start_pos <= suite . end_pos ) : [EOL] return False [EOL] [EOL] for node in obj . get_except_clause_tests ( ) : [EOL] if node is None : [EOL] return True [comment] [EOL] else : [EOL] except_classes = node_context . eval_node ( node ) [EOL] for cls in except_classes : [EOL] from jedi . evaluate import iterable [EOL] if isinstance ( cls , iterable . AbstractSequence ) and cls . array_type == [string] : [EOL] [comment] [EOL] for lazy_context in cls . py__iter__ ( ) : [EOL] for typ in lazy_context . infer ( ) : [EOL] if check_match ( typ , exception ) : [EOL] return True [EOL] else : [EOL] if check_match ( cls , exception ) : [EOL] return True [EOL] [EOL] def check_hasattr ( node , suite ) : [EOL] try : [EOL] assert suite . start_pos <= jedi_name . start_pos < suite . end_pos [EOL] assert node . type in ( [string] , [string] ) [EOL] base = node . children [ [number] ] [EOL] assert base . type == [string] and base . value == [string] [EOL] trailer = node . children [ [number] ] [EOL] assert trailer . type == [string] [EOL] arglist = trailer . children [ [number] ] [EOL] assert arglist . type == [string] [EOL] from jedi . evaluate . param import TreeArguments [EOL] args = list ( TreeArguments ( node_context . evaluator , node_context , arglist ) . unpack ( ) ) [EOL] [comment] [EOL] assert len ( args ) == [number] [EOL] [EOL] [comment] [EOL] key , lazy_context = args [ [number] ] [EOL] names = list ( lazy_context . infer ( ) ) [EOL] assert len ( names ) == [number] and isinstance ( names [ [number] ] , CompiledObject ) [EOL] assert names [ [number] ] . obj == payload [ [number] ] . value [EOL] [EOL] [comment] [EOL] key , lazy_context = args [ [number] ] [EOL] objects = lazy_context . infer ( ) [EOL] return payload [ [number] ] in objects [EOL] except AssertionError : [EOL] return False [EOL] [EOL] obj = jedi_name [EOL] while obj is not None and not isinstance ( obj , ( tree . Function , tree . Class ) ) : [EOL] if isinstance ( obj , tree . Flow ) : [EOL] [comment] [EOL] if obj . type == [string] and check_try_for_except ( obj , exception ) : [EOL] return True [EOL] [comment] [EOL] if exception == AttributeError and obj . type in ( [string] , [string] ) : [EOL] if check_hasattr ( obj . children [ [number] ] , obj . children [ [number] ] ) : [EOL] return True [EOL] obj = obj . parent [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match , List , Pattern , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] from ast import literal_eval [EOL] import re [EOL] from textwrap import dedent [EOL] [EOL] from jedi . _compatibility import u [EOL] from jedi . common import unite [EOL] from jedi . evaluate import context [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . parser . python import parse [EOL] from jedi . common import indent_block [EOL] from jedi . evaluate . iterable import SequenceLiteralContext , FakeSequence [EOL] [EOL] [EOL] DOCSTRING_PARAM_PATTERNS = [ [string] , [string] , [string] , ] [EOL] [EOL] DOCSTRING_RETURN_PATTERNS = [ re . compile ( [string] , re . M ) , re . compile ( [string] , re . M ) , ] [EOL] [EOL] REST_ROLE_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] try : [EOL] from numpydoc . docscrape import NumpyDocString [EOL] except ImportError : [EOL] def _search_param_in_numpydocstr ( docstr , param_str ) : [EOL] return [ ] [EOL] else : [EOL] def _search_param_in_numpydocstr ( docstr , param_str ) : [EOL] [docstring] [EOL] params = NumpyDocString ( docstr ) . _parsed_data [ [string] ] [EOL] for p_name , p_type , p_descr in params : [EOL] if p_name == param_str : [EOL] m = re . match ( [string] , p_type ) [EOL] if m : [EOL] p_type = m . group ( [number] ) [EOL] [EOL] if p_type . startswith ( [string] ) : [EOL] types = set ( type ( x ) . __name__ for x in literal_eval ( p_type ) ) [EOL] return list ( types ) [EOL] else : [EOL] return [ p_type ] [EOL] return [ ] [EOL] [EOL] [EOL] def _search_param_in_docstr ( docstr , param_str ) : [EOL] [docstring] [EOL] [comment] [EOL] patterns = [ re . compile ( p % re . escape ( param_str ) ) for p in DOCSTRING_PARAM_PATTERNS ] [EOL] for pattern in patterns : [EOL] match = pattern . search ( docstr ) [EOL] if match : [EOL] return [ _strip_rst_role ( match . group ( [number] ) ) ] [EOL] [EOL] return ( _search_param_in_numpydocstr ( docstr , param_str ) or [ ] ) [EOL] [EOL] [EOL] def _strip_rst_role ( type_str ) : [EOL] [docstring] [EOL] match = REST_ROLE_PATTERN . match ( type_str ) [EOL] if match : [EOL] return match . group ( [number] ) [EOL] else : [EOL] return type_str [EOL] [EOL] [EOL] def _evaluate_for_statement_string ( module_context , string ) : [EOL] code = dedent ( u ( [string] ) ) [EOL] if string is None : [EOL] return [ ] [EOL] [EOL] for element in re . findall ( [string] , string ) : [EOL] [comment] [EOL] [comment] [EOL] string = [string] % element + string [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] module = parse ( code . format ( indent_block ( string ) ) ) [EOL] try : [EOL] funcdef = next ( module . iter_funcdefs ( ) ) [EOL] [comment] [EOL] [comment] [EOL] stmt = funcdef . children [ - [number] ] . children [ - [number] ] . children [ - [number] ] [EOL] except ( AttributeError , IndexError ) : [EOL] return [ ] [EOL] [EOL] from jedi . evaluate . param import ValuesArguments [EOL] from jedi . evaluate . representation import FunctionContext [EOL] function_context = FunctionContext ( module_context . evaluator , module_context , funcdef ) [EOL] func_execution_context = function_context . get_function_execution ( ValuesArguments ( [ ] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return list ( _execute_types_in_stmt ( func_execution_context , stmt ) ) [EOL] [EOL] [EOL] def _execute_types_in_stmt ( module_context , stmt ) : [EOL] [docstring] [EOL] definitions = module_context . eval_node ( stmt ) [EOL] return unite ( _execute_array_values ( module_context . evaluator , d ) for d in definitions ) [EOL] [EOL] [EOL] def _execute_array_values ( evaluator , array ) : [EOL] [docstring] [EOL] if isinstance ( array , SequenceLiteralContext ) : [EOL] values = [ ] [EOL] for lazy_context in array . py__iter__ ( ) : [EOL] objects = unite ( _execute_array_values ( evaluator , typ ) for typ in lazy_context . infer ( ) ) [EOL] values . append ( context . LazyKnownContexts ( objects ) ) [EOL] return set ( [ FakeSequence ( evaluator , array . array_type , values ) ] ) [EOL] else : [EOL] return array . execute_evaluated ( ) [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_param ( execution_context , param ) : [EOL] from jedi . evaluate . instance import InstanceFunctionExecution [EOL] [EOL] def eval_docstring ( docstring ) : [EOL] return set ( p for param_str in _search_param_in_docstr ( docstring , param . name . value ) for p in _evaluate_for_statement_string ( module_context , param_str ) ) [EOL] module_context = execution_context . get_root_context ( ) [EOL] func = param . get_parent_function ( ) [EOL] if func . type == [string] : [EOL] return set ( ) [EOL] [EOL] types = eval_docstring ( execution_context . py__doc__ ( ) ) [EOL] if isinstance ( execution_context , InstanceFunctionExecution ) and execution_context . function_context . name . string_name == [string] : [EOL] class_context = execution_context . instance . class_context [EOL] types |= eval_docstring ( class_context . py__doc__ ( ) ) [EOL] [EOL] return types [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_return_types ( function_context ) : [EOL] def search_return_in_docstr ( code ) : [EOL] for p in DOCSTRING_RETURN_PATTERNS : [EOL] match = p . search ( code ) [EOL] if match : [EOL] return _strip_rst_role ( match . group ( [number] ) ) [EOL] [EOL] type_str = search_return_in_docstr ( function_context . py__doc__ ( ) ) [EOL] return _evaluate_for_statement_string ( function_context . get_root_context ( ) , type_str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Dict , Any [EOL] import typing [EOL] from collections import defaultdict [EOL] [EOL] from jedi . _compatibility import zip_longest [EOL] from jedi import debug [EOL] from jedi import common [EOL] from jedi . parser . python import tree [EOL] from jedi . evaluate import iterable [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate import context [EOL] from jedi . evaluate import docstrings [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate . filters import ParamName [EOL] [EOL] [EOL] def add_argument_issue ( parent_context , error_name , lazy_context , message ) : [EOL] if isinstance ( lazy_context , context . LazyTreeContext ) : [EOL] node = lazy_context . data [EOL] if node . parent . type == [string] : [EOL] node = node . parent [EOL] analysis . add ( parent_context , error_name , node , message ) [EOL] [EOL] [EOL] def try_iter_content ( types , depth = [number] ) : [EOL] [docstring] [EOL] if depth > [number] : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] for typ in types : [EOL] try : [EOL] f = typ . py__iter__ [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] for lazy_context in f ( ) : [EOL] try_iter_content ( lazy_context . infer ( ) , depth + [number] ) [EOL] [EOL] [EOL] class AbstractArguments ( ) : [EOL] context = None [EOL] [EOL] def eval_argument_clinic ( self , parameters ) : [EOL] [docstring] [EOL] iterator = self . unpack ( ) [EOL] for i , ( name , optional , allow_kwargs ) in enumerate ( parameters ) : [EOL] key , argument = next ( iterator , ( None , None ) ) [EOL] if key is not None : [EOL] raise NotImplementedError [EOL] if argument is None and not optional : [EOL] debug . warning ( [string] , name , len ( parameters ) , i ) [EOL] raise ValueError [EOL] values = set ( ) if argument is None else argument . infer ( ) [EOL] [EOL] if not values and not optional : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] debug . warning ( [string] , name ) [EOL] raise ValueError [EOL] yield values [EOL] [EOL] def eval_all ( self , funcdef = None ) : [EOL] [docstring] [EOL] for key , lazy_context in self . unpack ( ) : [EOL] types = lazy_context . infer ( ) [EOL] try_iter_content ( types ) [EOL] [EOL] [EOL] class TreeArguments ( AbstractArguments ) : [EOL] def __init__ ( self , evaluator , context , argument_node , trailer = None ) : [EOL] [docstring] [EOL] self . argument_node = argument_node [EOL] self . context = context [EOL] self . _evaluator = evaluator [EOL] self . trailer = trailer [comment] [EOL] [EOL] def _split ( self ) : [EOL] if isinstance ( self . argument_node , ( tuple , list ) ) : [EOL] for el in self . argument_node : [EOL] yield [number] , el [EOL] else : [EOL] if not ( self . argument_node . type == [string] or ( ( self . argument_node . type == [string] ) and self . argument_node . children [ [number] ] in ( [string] , [string] ) ) ) : [EOL] yield [number] , self . argument_node [EOL] return [EOL] [EOL] iterator = iter ( self . argument_node . children ) [EOL] for child in iterator : [EOL] if child == [string] : [EOL] continue [EOL] elif child in ( [string] , [string] ) : [EOL] yield len ( child . value ) , next ( iterator ) [EOL] elif child . type == [string] and child . children [ [number] ] in ( [string] , [string] ) : [EOL] assert len ( child . children ) == [number] [EOL] yield len ( child . children [ [number] ] . value ) , child . children [ [number] ] [EOL] else : [EOL] yield [number] , child [EOL] [EOL] def unpack ( self , funcdef = None ) : [EOL] named_args = [ ] [EOL] for star_count , el in self . _split ( ) : [EOL] if star_count == [number] : [EOL] arrays = self . context . eval_node ( el ) [EOL] iterators = [ _iterate_star_args ( self . context , a , el , funcdef ) for a in arrays ] [EOL] iterators = list ( iterators ) [EOL] for values in list ( zip_longest ( * iterators ) ) : [EOL] [comment] [EOL] [comment] [EOL] yield None , context . get_merged_lazy_context ( [ v for v in values if v is not None ] ) [EOL] elif star_count == [number] : [EOL] arrays = self . _evaluator . eval_element ( self . context , el ) [EOL] for dct in arrays : [EOL] for key , values in _star_star_dict ( self . context , dct , el , funcdef ) : [EOL] yield key , values [EOL] else : [EOL] if el . type == [string] : [EOL] c = el . children [EOL] if len ( c ) == [number] : [comment] [EOL] named_args . append ( ( c [ [number] ] . value , context . LazyTreeContext ( self . context , c [ [number] ] ) , ) ) [EOL] else : [comment] [EOL] [comment] [EOL] comp = iterable . GeneratorComprehension ( self . _evaluator , self . context , self . argument_node . parent ) [EOL] yield None , context . LazyKnownContext ( comp ) [EOL] else : [EOL] yield None , context . LazyTreeContext ( self . context , el ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for named_arg in named_args : [EOL] yield named_arg [EOL] [EOL] def as_tree_tuple_objects ( self ) : [EOL] for star_count , argument in self . _split ( ) : [EOL] if argument . type == [string] : [EOL] argument , default = argument . children [ : : [number] ] [EOL] else : [EOL] default = None [EOL] yield argument , default , star_count [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . argument_node ) [EOL] [EOL] def get_calling_nodes ( self ) : [EOL] from jedi . evaluate . dynamic import MergedExecutedParams [EOL] old_arguments_list = [ ] [EOL] arguments = self [EOL] [EOL] while arguments not in old_arguments_list : [EOL] if not isinstance ( arguments , TreeArguments ) : [EOL] break [EOL] [EOL] old_arguments_list . append ( arguments ) [EOL] for name , default , star_count in reversed ( list ( arguments . as_tree_tuple_objects ( ) ) ) : [EOL] if not star_count or not isinstance ( name , tree . Name ) : [EOL] continue [EOL] [EOL] names = self . _evaluator . goto ( arguments . context , name ) [EOL] if len ( names ) != [number] : [EOL] break [EOL] if not isinstance ( names [ [number] ] , ParamName ) : [EOL] break [EOL] param = names [ [number] ] . get_param ( ) [EOL] if isinstance ( param , MergedExecutedParams ) : [EOL] [comment] [EOL] return [ ] [EOL] if not isinstance ( param , ExecutedParam ) : [EOL] break [EOL] if param . var_args is None : [EOL] break [EOL] arguments = param . var_args [EOL] break [EOL] [EOL] return [ arguments . argument_node or arguments . trailer ] [EOL] [EOL] [EOL] class ValuesArguments ( AbstractArguments ) : [EOL] def __init__ ( self , values_list ) : [EOL] self . _values_list = values_list [EOL] [EOL] def unpack ( self , funcdef = None ) : [EOL] for values in self . _values_list : [EOL] yield None , context . LazyKnownContexts ( values ) [EOL] [EOL] def get_calling_nodes ( self ) : [EOL] return [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . _values_list ) [EOL] [EOL] [EOL] class ExecutedParam ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , execution_context , param_node , lazy_context ) : [EOL] self . _execution_context = execution_context [EOL] self . _param_node = param_node [EOL] self . _lazy_context = lazy_context [EOL] self . string_name = param_node . name . value [EOL] [EOL] def infer ( self ) : [EOL] pep0484_hints = pep0484 . infer_param ( self . _execution_context , self . _param_node ) [EOL] doc_params = docstrings . infer_param ( self . _execution_context , self . _param_node ) [EOL] if pep0484_hints or doc_params : [EOL] return list ( set ( pep0484_hints ) | set ( doc_params ) ) [EOL] [EOL] return self . _lazy_context . infer ( ) [EOL] [EOL] @ property def var_args ( self ) : [EOL] return self . _execution_context . var_args [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . string_name ) [EOL] [EOL] [EOL] def get_params ( execution_context , var_args ) : [EOL] result_params = [ ] [EOL] param_dict = { } [EOL] funcdef = execution_context . tree_node [EOL] parent_context = execution_context . parent_context [EOL] [EOL] for param in funcdef . params : [EOL] param_dict [ param . name . value ] = param [EOL] unpacked_va = list ( var_args . unpack ( funcdef ) ) [EOL] var_arg_iterator = common . PushBackIterator ( iter ( unpacked_va ) ) [EOL] [EOL] non_matching_keys = defaultdict ( lambda : [ ] ) [EOL] keys_used = { } [EOL] keys_only = False [EOL] had_multiple_value_error = False [EOL] for param in funcdef . params : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] key , argument = next ( var_arg_iterator , ( None , None ) ) [EOL] while key is not None : [EOL] keys_only = True [EOL] try : [EOL] key_param = param_dict [ key ] [EOL] except KeyError : [EOL] non_matching_keys [ key ] = argument [EOL] else : [EOL] if key in keys_used : [EOL] had_multiple_value_error = True [EOL] m = ( [string] % ( funcdef . name , key ) ) [EOL] for node in var_args . get_calling_nodes ( ) : [EOL] analysis . add ( parent_context , [string] , node , message = m ) [EOL] else : [EOL] keys_used [ key ] = ExecutedParam ( execution_context , key_param , argument ) [EOL] key , argument = next ( var_arg_iterator , ( None , None ) ) [EOL] [EOL] try : [EOL] result_params . append ( keys_used [ param . name . value ] ) [EOL] continue [EOL] except KeyError : [EOL] pass [EOL] [EOL] if param . star_count == [number] : [EOL] [comment] [EOL] lazy_context_list = [ ] [EOL] if argument is not None : [EOL] lazy_context_list . append ( argument ) [EOL] for key , argument in var_arg_iterator : [EOL] [comment] [EOL] if key : [EOL] var_arg_iterator . push_back ( ( key , argument ) ) [EOL] break [EOL] lazy_context_list . append ( argument ) [EOL] seq = iterable . FakeSequence ( execution_context . evaluator , [string] , lazy_context_list ) [EOL] result_arg = context . LazyKnownContext ( seq ) [EOL] elif param . star_count == [number] : [EOL] [comment] [EOL] dct = iterable . FakeDict ( execution_context . evaluator , dict ( non_matching_keys ) ) [EOL] result_arg = context . LazyKnownContext ( dct ) [EOL] non_matching_keys = { } [EOL] else : [EOL] [comment] [EOL] if argument is None : [EOL] [comment] [EOL] if param . default is None : [EOL] result_arg = context . LazyUnknownContext ( ) [EOL] if not keys_only : [EOL] for node in var_args . get_calling_nodes ( ) : [EOL] m = _error_argument_count ( funcdef , len ( unpacked_va ) ) [EOL] analysis . add ( parent_context , [string] , node , message = m ) [EOL] else : [EOL] result_arg = context . LazyTreeContext ( parent_context , param . default ) [EOL] else : [EOL] result_arg = argument [EOL] [EOL] result_params . append ( ExecutedParam ( execution_context , param , result_arg ) ) [EOL] if not isinstance ( result_arg , context . LazyUnknownContext ) : [EOL] keys_used [ param . name . value ] = result_params [ - [number] ] [EOL] [EOL] if keys_only : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k in set ( param_dict ) - set ( keys_used ) : [EOL] param = param_dict [ k ] [EOL] [EOL] if not ( non_matching_keys or had_multiple_value_error or param . star_count or param . default ) : [EOL] [comment] [EOL] for node in var_args . get_calling_nodes ( ) : [EOL] m = _error_argument_count ( funcdef , len ( unpacked_va ) ) [EOL] analysis . add ( parent_context , [string] , node , message = m ) [EOL] [EOL] for key , lazy_context in non_matching_keys . items ( ) : [EOL] m = [string] % ( funcdef . name , key ) [EOL] add_argument_issue ( parent_context , [string] , lazy_context , message = m ) [EOL] [EOL] remaining_arguments = list ( var_arg_iterator ) [EOL] if remaining_arguments : [EOL] m = _error_argument_count ( funcdef , len ( unpacked_va ) ) [EOL] [comment] [EOL] [comment] [EOL] first_key , lazy_context = remaining_arguments [ [number] ] [EOL] if var_args . get_calling_nodes ( ) : [EOL] [comment] [EOL] add_argument_issue ( parent_context , [string] , lazy_context , message = m ) [EOL] return result_params [EOL] [EOL] [EOL] def _iterate_star_args ( context , array , input_node , funcdef = None ) : [EOL] try : [EOL] iter_ = array . py__iter__ [EOL] except AttributeError : [EOL] if funcdef is not None : [EOL] [comment] [EOL] m = [string] % ( funcdef . name . value , array ) [EOL] analysis . add ( context , [string] , input_node , message = m ) [EOL] else : [EOL] for lazy_context in iter_ ( ) : [EOL] yield lazy_context [EOL] [EOL] [EOL] def _star_star_dict ( context , array , input_node , funcdef ) : [EOL] from jedi . evaluate . instance import CompiledInstance [EOL] if isinstance ( array , CompiledInstance ) and array . name . string_name == [string] : [EOL] [comment] [EOL] [comment] [EOL] return { } [EOL] elif isinstance ( array , iterable . AbstractSequence ) and array . array_type == [string] : [EOL] return array . exact_key_items ( ) [EOL] else : [EOL] if funcdef is not None : [EOL] m = [string] % ( funcdef . name . value , array ) [EOL] analysis . add ( context , [string] , input_node , message = m ) [EOL] return { } [EOL] [EOL] [EOL] def _error_argument_count ( funcdef , actual_count ) : [EOL] default_arguments = sum ( [number] for p in funcdef . params if p . default or p . star_count ) [EOL] [EOL] if default_arguments == [number] : [EOL] before = [string] [EOL] else : [EOL] before = [string] % ( len ( funcdef . params ) - default_arguments ) [EOL] return ( [string] % ( funcdef . name , before , len ( funcdef . params ) , actual_count ) ) [EOL] [EOL] [EOL] def create_default_param ( execution_context , param ) : [EOL] if param . star_count == [number] : [EOL] result_arg = context . LazyKnownContext ( iterable . FakeSequence ( execution_context . evaluator , [string] , [ ] ) ) [EOL] elif param . star_count == [number] : [EOL] result_arg = context . LazyKnownContext ( iterable . FakeDict ( execution_context . evaluator , { } ) ) [EOL] elif param . default is None : [EOL] result_arg = context . LazyUnknownContext ( ) [EOL] else : [EOL] result_arg = context . LazyTreeContext ( execution_context . parent_context , param . default ) [EOL] return ExecutedParam ( execution_context , param , result_arg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from abc import abstractmethod [EOL] [EOL] from jedi . parser . tree import search_ancestor [EOL] from jedi . evaluate import flow_analysis [EOL] from jedi . common import to_list , unite [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] class AbstractNameDefinition ( object ) : [EOL] start_pos = None [EOL] string_name = None [EOL] parent_context = None [EOL] tree_name = None [EOL] [EOL] @ abstractmethod def infer ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def get_root_context ( self ) : [EOL] return self . parent_context . get_root_context ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] if self . start_pos is None : [EOL] return [string] % ( self . __class__ . __name__ , self . string_name ) [EOL] return [string] % ( self . __class__ . __name__ , self . string_name , self . start_pos ) [EOL] [EOL] def execute ( self , arguments ) : [EOL] return unite ( context . execute ( arguments ) for context in self . infer ( ) ) [EOL] [EOL] def execute_evaluated ( self , * args , ** kwargs ) : [EOL] return unite ( context . execute_evaluated ( * args , ** kwargs ) for context in self . infer ( ) ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] return self . parent_context . api_type [EOL] [EOL] [EOL] class AbstractTreeName ( AbstractNameDefinition ) : [EOL] def __init__ ( self , parent_context , tree_name ) : [EOL] self . parent_context = parent_context [EOL] self . tree_name = tree_name [EOL] [EOL] @ property def string_name ( self ) : [EOL] return self . tree_name . value [EOL] [EOL] @ property def start_pos ( self ) : [EOL] return self . tree_name . start_pos [EOL] [EOL] [EOL] class ContextNameMixin ( object ) : [EOL] def infer ( self ) : [EOL] return set ( [ self . _context ] ) [EOL] [EOL] def get_root_context ( self ) : [EOL] if self . parent_context is None : [EOL] return self . _context [EOL] return super ( ContextNameMixin , self ) . get_root_context ( ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] return self . _context . api_type [EOL] [EOL] [EOL] class ContextName ( ContextNameMixin , AbstractTreeName ) : [EOL] def __init__ ( self , context , tree_name ) : [EOL] super ( ContextName , self ) . __init__ ( context . parent_context , tree_name ) [EOL] self . _context = context [EOL] [EOL] [EOL] class TreeNameDefinition ( AbstractTreeName ) : [EOL] def infer ( self ) : [EOL] [comment] [EOL] from jedi . evaluate . finder import _name_to_types [EOL] return _name_to_types ( self . parent_context . evaluator , self . parent_context , self . tree_name ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] definition = self . tree_name . get_definition ( ) [EOL] return dict ( import_name = [string] , import_from = [string] , funcdef = [string] , param = [string] , classdef = [string] , ) . get ( definition . type , [string] ) [EOL] [EOL] [EOL] class ParamName ( AbstractTreeName ) : [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , parent_context , tree_name ) : [EOL] self . parent_context = parent_context [EOL] self . tree_name = tree_name [EOL] [EOL] def infer ( self ) : [EOL] return self . get_param ( ) . infer ( ) [EOL] [EOL] def get_param ( self ) : [EOL] params = self . parent_context . get_params ( ) [EOL] param_node = search_ancestor ( self . tree_name , [string] ) [EOL] return params [ param_node . position_index ] [EOL] [EOL] [EOL] class AnonymousInstanceParamName ( ParamName ) : [EOL] def infer ( self ) : [EOL] param_node = search_ancestor ( self . tree_name , [string] ) [EOL] if param_node . position_index == [number] : [EOL] [comment] [EOL] [comment] [EOL] return set ( [ self . parent_context . instance ] ) [EOL] else : [EOL] return self . get_param ( ) . infer ( ) [EOL] [EOL] [EOL] class AbstractFilter ( object ) : [EOL] _until_position = None [EOL] [EOL] def _filter ( self , names ) : [EOL] if self . _until_position is not None : [EOL] return [ n for n in names if n . start_pos < self . _until_position ] [EOL] return names [EOL] [EOL] @ abstractmethod def get ( self , name ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def values ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class AbstractUsedNamesFilter ( AbstractFilter ) : [EOL] name_class = TreeNameDefinition [EOL] [EOL] def __init__ ( self , context , parser_scope ) : [EOL] self . _parser_scope = parser_scope [EOL] self . _used_names = self . _parser_scope . get_root_node ( ) . get_used_names ( ) [EOL] self . context = context [EOL] [EOL] def get ( self , name ) : [EOL] try : [EOL] names = self . _used_names [ str ( name ) ] [EOL] except KeyError : [EOL] return [ ] [EOL] [EOL] return self . _convert_names ( self . _filter ( names ) ) [EOL] [EOL] def _convert_names ( self , names ) : [EOL] return [ self . name_class ( self . context , name ) for name in names ] [EOL] [EOL] def values ( self ) : [EOL] return self . _convert_names ( name for name_list in self . _used_names . values ( ) for name in self . _filter ( name_list ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . context ) [EOL] [EOL] [EOL] class ParserTreeFilter ( AbstractUsedNamesFilter ) : [EOL] def __init__ ( self , evaluator , context , node_context = None , until_position = None , origin_scope = None ) : [EOL] [docstring] [EOL] if node_context is None : [EOL] node_context = context [EOL] super ( ParserTreeFilter , self ) . __init__ ( context , node_context . tree_node ) [EOL] self . _node_context = node_context [EOL] self . _origin_scope = origin_scope [EOL] self . _until_position = until_position [EOL] [EOL] def _filter ( self , names ) : [EOL] names = super ( ParserTreeFilter , self ) . _filter ( names ) [EOL] names = [ n for n in names if self . _is_name_reachable ( n ) ] [EOL] return list ( self . _check_flows ( names ) ) [EOL] [EOL] def _is_name_reachable ( self , name ) : [EOL] if not name . is_definition ( ) : [EOL] return False [EOL] parent = name . parent [EOL] if parent . type == [string] : [EOL] return False [EOL] base_node = parent if parent . type in ( [string] , [string] ) else name [EOL] return get_parent_scope ( base_node ) == self . _parser_scope [EOL] [EOL] def _check_flows ( self , names ) : [EOL] for name in sorted ( names , key = lambda name : name . start_pos , reverse = True ) : [EOL] check = flow_analysis . reachability_check ( self . _node_context , self . _parser_scope , name , self . _origin_scope ) [EOL] if check is not flow_analysis . UNREACHABLE : [EOL] yield name [EOL] [EOL] if check is flow_analysis . REACHABLE : [EOL] break [EOL] [EOL] [EOL] class FunctionExecutionFilter ( ParserTreeFilter ) : [EOL] param_name = ParamName [EOL] [EOL] def __init__ ( self , evaluator , context , node_context = None , until_position = None , origin_scope = None ) : [EOL] super ( FunctionExecutionFilter , self ) . __init__ ( evaluator , context , node_context , until_position , origin_scope ) [EOL] [EOL] @ to_list def _convert_names ( self , names ) : [EOL] for name in names : [EOL] param = search_ancestor ( name , [string] ) [EOL] if param : [EOL] yield self . param_name ( self . context , name ) [EOL] else : [EOL] yield TreeNameDefinition ( self . context , name ) [EOL] [EOL] [EOL] class AnonymousInstanceFunctionExecutionFilter ( FunctionExecutionFilter ) : [EOL] param_name = AnonymousInstanceParamName [EOL] [EOL] [EOL] class GlobalNameFilter ( AbstractUsedNamesFilter ) : [EOL] def __init__ ( self , context , parser_scope ) : [EOL] super ( GlobalNameFilter , self ) . __init__ ( context , parser_scope ) [EOL] [EOL] @ to_list def _filter ( self , names ) : [EOL] for name in names : [EOL] if name . parent . type == [string] : [EOL] yield name [EOL] [EOL] [EOL] class DictFilter ( AbstractFilter ) : [EOL] def __init__ ( self , dct ) : [EOL] self . _dct = dct [EOL] [EOL] def get ( self , name ) : [EOL] try : [EOL] value = self . _convert ( name , self . _dct [ str ( name ) ] ) [EOL] except KeyError : [EOL] return [ ] [EOL] [EOL] return list ( self . _filter ( [ value ] ) ) [EOL] [EOL] def values ( self ) : [EOL] return self . _filter ( self . _convert ( * item ) for item in self . _dct . items ( ) ) [EOL] [EOL] def _convert ( self , name , value ) : [EOL] return value [EOL] [EOL] [EOL] def get_global_filters ( evaluator , context , until_position , origin_scope ) : [EOL] [docstring] [EOL] from jedi . evaluate . representation import FunctionExecutionContext [EOL] while context is not None : [EOL] [comment] [EOL] for filter in context . get_filters ( search_global = True , until_position = until_position , origin_scope = origin_scope ) : [EOL] yield filter [EOL] if isinstance ( context , FunctionExecutionContext ) : [EOL] [comment] [EOL] until_position = None [EOL] [EOL] context = context . parent_context [EOL] [EOL] [comment] [EOL] for filter in evaluator . BUILTINS . get_filters ( search_global = True ) : [EOL] yield filter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import time [EOL] import os [EOL] import sys [EOL] import hashlib [EOL] import gc [EOL] import shutil [EOL] import pickle [EOL] import platform [EOL] import errno [EOL] [EOL] from jedi import settings [EOL] from jedi import debug [EOL] from jedi . _compatibility import FileNotFoundError [EOL] [EOL] [EOL] _PICKLE_VERSION = [number] [EOL] [docstring] [EOL] [EOL] _VERSION_TAG = [string] % ( platform . python_implementation ( ) , sys . version_info [ [number] ] , sys . version_info [ [number] ] , _PICKLE_VERSION ) [EOL] [docstring] [EOL] [EOL] [comment] [EOL] parser_cache = { } [EOL] [EOL] [EOL] [EOL] class _NodeCacheItem ( object ) : [EOL] def __init__ ( self , node , lines , change_time = None ) : [EOL] self . node = node [EOL] self . lines = lines [EOL] if change_time is None : [EOL] change_time = time . time ( ) [EOL] self . change_time = change_time [EOL] [EOL] [EOL] def load_module ( grammar , path ) : [EOL] [docstring] [EOL] try : [EOL] p_time = os . path . getmtime ( path ) [EOL] except FileNotFoundError : [EOL] return None [EOL] [EOL] try : [EOL] [comment] [EOL] module_cache_item = parser_cache [ path ] [EOL] if p_time <= module_cache_item . change_time : [EOL] return module_cache_item . node [EOL] except KeyError : [EOL] if not settings . use_filesystem_cache : [EOL] return None [EOL] [EOL] return _load_from_file_system ( grammar , path , p_time ) [EOL] [EOL] [EOL] def _load_from_file_system ( grammar , path , p_time ) : [EOL] cache_path = _get_hashed_path ( grammar , path ) [EOL] try : [EOL] try : [EOL] if p_time > os . path . getmtime ( cache_path ) : [EOL] [comment] [EOL] return None [EOL] except OSError as e : [EOL] if e . errno == errno . ENOENT : [EOL] [comment] [EOL] raise FileNotFoundError [EOL] else : [EOL] raise [EOL] [EOL] with open ( cache_path , [string] ) as f : [EOL] gc . disable ( ) [EOL] try : [EOL] module_cache_item = pickle . load ( f ) [EOL] finally : [EOL] gc . enable ( ) [EOL] except FileNotFoundError : [EOL] return None [EOL] else : [EOL] parser_cache [ path ] = module_cache_item [EOL] debug . dbg ( [string] , path ) [EOL] return module_cache_item . node [EOL] [EOL] [EOL] def save_module ( grammar , path , module , lines , pickling = True ) : [EOL] try : [EOL] p_time = None if path is None else os . path . getmtime ( path ) [EOL] except OSError : [EOL] p_time = None [EOL] pickling = False [EOL] [EOL] item = _NodeCacheItem ( module , lines , p_time ) [EOL] parser_cache [ path ] = item [EOL] if settings . use_filesystem_cache and pickling and path is not None : [EOL] _save_to_file_system ( grammar , path , item ) [EOL] [EOL] [EOL] def _save_to_file_system ( grammar , path , item ) : [EOL] with open ( _get_hashed_path ( grammar , path ) , [string] ) as f : [EOL] pickle . dump ( item , f , pickle . HIGHEST_PROTOCOL ) [EOL] [EOL] [EOL] def remove_old_modules ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] def clear_cache ( self ) : [EOL] shutil . rmtree ( settings . cache_directory ) [EOL] parser_cache . clear ( ) [EOL] [EOL] [EOL] def _get_hashed_path ( grammar , path ) : [EOL] file_hash = hashlib . sha256 ( path . encode ( [string] ) ) . hexdigest ( ) [EOL] directory = _get_cache_directory_path ( ) [EOL] return os . path . join ( directory , [string] % ( grammar . sha256 , file_hash ) ) [EOL] [EOL] [EOL] def _get_cache_directory_path ( ) : [EOL] directory = os . path . join ( settings . cache_directory , _VERSION_TAG ) [EOL] if not os . path . exists ( directory ) : [EOL] os . makedirs ( directory ) [EOL] return directory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from jedi . parser . parser import ParserSyntaxError [EOL] from jedi . parser . pgen2 . pgen import generate_grammar [EOL] from jedi . parser import python [EOL] [EOL] [EOL] def parse ( grammar , code ) : [EOL] raise NotImplementedError [EOL] Parser ( grammar , code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] from jedi . _compatibility import is_py3 , is_py35 [EOL] from token import * [EOL] [EOL] [EOL] COMMENT = N_TOKENS [EOL] tok_name [ COMMENT ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] NL = N_TOKENS [EOL] tok_name [ NL ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] if is_py3 : [EOL] BACKQUOTE = N_TOKENS [EOL] tok_name [ BACKQUOTE ] = [string] [EOL] N_TOKENS += [number] [EOL] else : [EOL] RARROW = N_TOKENS [EOL] tok_name [ RARROW ] = [string] [EOL] N_TOKENS += [number] [EOL] ELLIPSIS = N_TOKENS [EOL] tok_name [ ELLIPSIS ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] if not is_py35 : [EOL] ATEQUAL = N_TOKENS [EOL] tok_name [ ATEQUAL ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] opmap_raw = [string] [EOL] [EOL] opmap = { } [EOL] for line in opmap_raw . splitlines ( ) : [EOL] op , name = line . split ( ) [EOL] opmap [ op ] = globals ( ) [ name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from jedi . parser import tree [EOL] from jedi . parser . pgen2 . parse import PgenParser [EOL] [EOL] [EOL] class ParserSyntaxError ( Exception ) : [EOL] [docstring] [EOL] def __init__ ( self , message , position ) : [EOL] self . message = message [EOL] self . position = position [EOL] [EOL] [EOL] class BaseParser ( object ) : [EOL] node_map = { } [EOL] default_node = tree . Node [EOL] [EOL] leaf_map = { } [EOL] default_leaf = tree . Leaf [EOL] [EOL] def __init__ ( self , grammar , start_symbol = [string] , error_recovery = False ) : [EOL] self . _grammar = grammar [EOL] self . _start_symbol = start_symbol [EOL] self . _error_recovery = error_recovery [EOL] [EOL] def parse ( self , tokens ) : [EOL] start_number = self . _grammar . symbol2number [ self . _start_symbol ] [EOL] self . pgen_parser = PgenParser ( self . _grammar , self . convert_node , self . convert_leaf , self . error_recovery , start_number ) [EOL] [EOL] node = self . pgen_parser . parse ( tokens ) [EOL] [comment] [EOL] del self . pgen_parser [EOL] return node [EOL] [EOL] def error_recovery ( self , grammar , stack , arcs , typ , value , start_pos , prefix , add_token_callback ) : [EOL] if self . _error_recovery : [EOL] raise NotImplementedError ( [string] ) [EOL] else : [EOL] raise ParserSyntaxError ( [string] , start_pos ) [EOL] [EOL] def convert_node ( self , grammar , type_ , children ) : [EOL] [comment] [EOL] symbol = grammar . number2symbol [ type_ ] [EOL] try : [EOL] return self . node_map [ symbol ] ( children ) [EOL] except KeyError : [EOL] return self . default_node ( symbol , children ) [EOL] [EOL] def convert_leaf ( self , grammar , type_ , value , prefix , start_pos ) : [EOL] try : [EOL] return self . leaf_map [ type_ ] ( value , start_pos , prefix ) [EOL] except KeyError : [EOL] return self . default_leaf ( value , start_pos , prefix ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , List , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from jedi . parser import tokenize [EOL] [EOL] [EOL] class InternalParseError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg , type , value , start_pos ) : [EOL] Exception . __init__ ( self , [string] % ( msg , tokenize . tok_name [ type ] , value , start_pos ) ) [EOL] self . msg = msg [EOL] self . type = type [EOL] self . value = value [EOL] self . start_pos = start_pos [EOL] [EOL] [EOL] def token_to_ilabel ( grammar , type_ , value ) : [EOL] [comment] [EOL] if type_ == tokenize . NAME : [EOL] [comment] [EOL] try : [EOL] return grammar . keywords [ value ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] try : [EOL] return grammar . tokens [ type_ ] [EOL] except KeyError : [EOL] return None [EOL] [EOL] [EOL] class PgenParser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , grammar , convert_node , convert_leaf , error_recovery , start ) : [EOL] [docstring] [EOL] self . grammar = grammar [EOL] self . convert_node = convert_node [EOL] self . convert_leaf = convert_leaf [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] newnode = ( start , [ ] ) [EOL] stackentry = ( self . grammar . dfas [ start ] , [number] , newnode ) [EOL] self . stack = [ stackentry ] [EOL] self . rootnode = None [EOL] self . error_recovery = error_recovery [EOL] [EOL] def parse ( self , tokens ) : [EOL] for type_ , value , start_pos , prefix in tokens : [EOL] if self . addtoken ( type_ , value , start_pos , prefix ) : [EOL] break [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . stack : [EOL] raise InternalParseError ( [string] , type_ , value , start_pos ) [EOL] return self . rootnode [EOL] [EOL] def addtoken ( self , type_ , value , start_pos , prefix ) : [EOL] [docstring] [EOL] ilabel = token_to_ilabel ( self . grammar , type_ , value ) [EOL] [EOL] [comment] [EOL] _gram = self . grammar [EOL] _labels = _gram . labels [EOL] _push = self . _push [EOL] _pop = self . _pop [EOL] _shift = self . _shift [EOL] while True : [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] arcs = states [ state ] [EOL] [comment] [EOL] for i , newstate in arcs : [EOL] t , v = _labels [ i ] [EOL] if ilabel == i : [EOL] [comment] [EOL] assert t < [number] [EOL] [comment] [EOL] _shift ( type_ , value , newstate , prefix , start_pos ) [EOL] [comment] [EOL] state = newstate [EOL] while states [ state ] == [ ( [number] , state ) ] : [EOL] _pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] return True [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] [comment] [EOL] return False [EOL] elif t >= [number] : [EOL] [comment] [EOL] itsdfa = _gram . dfas [ t ] [EOL] itsstates , itsfirst = itsdfa [EOL] if ilabel in itsfirst : [EOL] [comment] [EOL] _push ( t , itsdfa , newstate ) [EOL] break [comment] [EOL] else : [EOL] if ( [number] , state ) in arcs : [EOL] [comment] [EOL] _pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] raise InternalParseError ( [string] , type_ , value , start_pos ) [EOL] else : [EOL] self . error_recovery ( self . grammar , self . stack , arcs , type_ , value , start_pos , prefix , self . addtoken ) [EOL] break [EOL] [EOL] def _shift ( self , type_ , value , newstate , prefix , start_pos ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = self . convert_leaf ( self . grammar , type_ , value , prefix , start_pos ) [EOL] node [ - [number] ] . append ( newnode ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] [EOL] def _push ( self , type_ , newdfa , newstate ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = ( type_ , [ ] ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] self . stack . append ( ( newdfa , [number] , newnode ) ) [EOL] [EOL] def _pop ( self ) : [EOL] [docstring] [EOL] popdfa , popstate , ( type_ , children ) = self . stack . pop ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( children ) == [number] : [EOL] newnode = children [ [number] ] [EOL] else : [EOL] newnode = self . convert_node ( self . grammar , type_ , children ) [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . stack [ - [number] ] [ [number] ] [ [number] ] . append ( newnode ) [EOL] except IndexError : [EOL] [comment] [EOL] self . rootnode = newnode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pickle [EOL] import hashlib [EOL] [EOL] [EOL] [EOL] class Grammar ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bnf_text ) : [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] self . states = [ ] [EOL] self . dfas = { } [EOL] self . labels = [ ( [number] , [string] ) ] [EOL] self . keywords = { } [EOL] self . tokens = { } [EOL] self . symbol2label = { } [EOL] self . start = [number] [EOL] self . sha256 = hashlib . sha256 ( bnf_text . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] def dump ( self , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as f : [EOL] pickle . dump ( self . __dict__ , f , [number] ) [EOL] [EOL] def load ( self , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as f : [EOL] d = pickle . load ( f ) [EOL] self . __dict__ . update ( d ) [EOL] [EOL] def copy ( self ) : [EOL] [docstring] [EOL] new = self . __class__ ( ) [EOL] for dict_attr in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] setattr ( new , dict_attr , getattr ( self , dict_attr ) . copy ( ) ) [EOL] new . labels = self . labels [ : ] [EOL] new . states = self . states [ : ] [EOL] new . start = self . start [EOL] return new [EOL] [EOL] def report ( self ) : [EOL] [docstring] [EOL] from pprint import pprint [EOL] print ( [string] ) [EOL] pprint ( self . symbol2number ) [EOL] print ( [string] ) [EOL] pprint ( self . number2symbol ) [EOL] print ( [string] ) [EOL] pprint ( self . states ) [EOL] print ( [string] ) [EOL] pprint ( self . dfas ) [EOL] print ( [string] ) [EOL] pprint ( self . labels ) [EOL] print ( [string] , self . start ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . _compatibility import utf8_repr , unicode [EOL] from jedi . parser . tree import Node , BaseNode , Leaf , ErrorNode , ErrorLeaf , search_ancestor [EOL] [EOL] [EOL] class DocstringMixin ( object ) : [EOL] __slots__ = ( ) [EOL] [EOL] def get_doc_node ( self ) : [EOL] [docstring] [EOL] if self . type == [string] : [EOL] node = self . children [ [number] ] [EOL] elif isinstance ( self , ClassOrFunc ) : [EOL] node = self . children [ self . children . index ( [string] ) + [number] ] [EOL] if node . type == [string] : [comment] [EOL] node = node . children [ [number] ] [comment] [EOL] else : [comment] [EOL] simple_stmt = self . parent [EOL] c = simple_stmt . parent . children [EOL] index = c . index ( simple_stmt ) [EOL] if not index : [EOL] return None [EOL] node = c [ index - [number] ] [EOL] [EOL] if node . type == [string] : [EOL] node = node . children [ [number] ] [EOL] if node . type == [string] : [EOL] return node [EOL] return None [EOL] [EOL] [EOL] class PythonMixin ( object ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] def get_definition ( self ) : [EOL] if self . type in ( [string] , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] scope = self [EOL] while scope . parent is not None : [EOL] parent = scope . parent [EOL] if isinstance ( scope , ( PythonNode , PythonLeaf ) ) and parent . type != [string] : [EOL] if scope . type == [string] : [EOL] try : [EOL] if scope . children [ [number] ] . type == [string] : [EOL] return scope . children [ [number] ] [EOL] except IndexError : [EOL] pass [EOL] scope = parent [EOL] else : [EOL] break [EOL] return scope [EOL] [EOL] def get_name_of_position ( self , position ) : [EOL] for c in self . children : [EOL] if isinstance ( c , Leaf ) : [EOL] if c . type == [string] and c . start_pos <= position <= c . end_pos : [EOL] return c [EOL] else : [EOL] result = c . get_name_of_position ( position ) [EOL] if result is not None : [EOL] return result [EOL] return None [EOL] [EOL] [EOL] class PythonLeaf ( Leaf , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class _LeafWithoutNewlines ( PythonLeaf ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] @ property def end_pos ( self ) : [EOL] return self . line , self . indent + len ( self . value ) [EOL] [EOL] [EOL] [comment] [EOL] class PythonBaseNode ( BaseNode , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class PythonNode ( Node , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class PythonErrorNode ( ErrorNode , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class PythonErrorLeaf ( ErrorLeaf , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class EndMarker ( _LeafWithoutNewlines ) : [EOL] __slots__ = ( ) [EOL] type = [string] [EOL] [EOL] [EOL] class Newline ( PythonLeaf ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] type = [string] [EOL] [EOL] @ utf8_repr def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , repr ( self . value ) ) [EOL] [EOL] [EOL] class Name ( _LeafWithoutNewlines ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . value , self . line , self . indent ) [EOL] [EOL] def is_definition ( self ) : [EOL] if self . parent . type in ( [string] , [string] ) : [EOL] [comment] [EOL] return False [EOL] [EOL] stmt = self . get_definition ( ) [EOL] if stmt . type in ( [string] , [string] , [string] ) : [EOL] return self == stmt . name [EOL] elif stmt . type == [string] : [EOL] return self . start_pos < stmt . children [ [number] ] . start_pos [EOL] elif stmt . type == [string] : [EOL] return self . get_previous_sibling ( ) == [string] [EOL] else : [EOL] return stmt . type in ( [string] , [string] , [string] , [string] , [string] ) \ [EOL] and self in stmt . get_defined_names ( ) [EOL] [EOL] [EOL] class Literal ( PythonLeaf ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class Number ( Literal ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class String ( Literal ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class _StringComparisonMixin ( object ) : [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] if isinstance ( other , ( str , unicode ) ) : [EOL] return self . value == other [EOL] [EOL] return self is other [EOL] [EOL] def __ne__ ( self , other ) : [EOL] [docstring] [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] [EOL] class Operator ( _LeafWithoutNewlines , _StringComparisonMixin ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class Keyword ( _LeafWithoutNewlines , _StringComparisonMixin ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class Scope ( PythonBaseNode , DocstringMixin ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Scope , self ) . __init__ ( children ) [EOL] [EOL] def iter_funcdefs ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def iter_classdefs ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def iter_imports ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] , [string] ) [EOL] [EOL] def _search_in_scope ( self , * names ) : [EOL] def scan ( children ) : [EOL] for element in children : [EOL] if element . type in names : [EOL] yield element [EOL] if element . type in ( [string] , [string] , [string] ) or isinstance ( element , Flow ) : [EOL] for e in scan ( element . children ) : [EOL] yield e [EOL] [EOL] return scan ( self . children ) [EOL] [EOL] def get_suite ( self ) : [EOL] [docstring] [EOL] return self . children [ - [number] ] [EOL] [EOL] def __repr__ ( self ) : [EOL] try : [EOL] name = self . name . value [EOL] except AttributeError : [EOL] name = [string] [EOL] [EOL] return [string] % ( type ( self ) . __name__ , name , self . start_pos [ [number] ] , self . end_pos [ [number] ] ) [EOL] [EOL] [EOL] class Module ( Scope ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , ) [EOL] type = [string] [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Module , self ) . __init__ ( children ) [EOL] self . _used_names = None [EOL] [EOL] def iter_future_import_names ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for imp in self . iter_imports ( ) : [EOL] if imp . type == [string] and imp . level == [number] : [EOL] for path in imp . get_paths ( ) : [EOL] names = [ name . value for name in path ] [EOL] if len ( names ) == [number] and names [ [number] ] == [string] : [EOL] yield names [ [number] ] [EOL] [EOL] def has_explicit_absolute_import ( self ) : [EOL] [docstring] [EOL] for name in self . iter_future_import_names ( ) : [EOL] if name == [string] : [EOL] return True [EOL] return False [EOL] [EOL] def get_used_names ( self ) : [EOL] [docstring] [EOL] if self . _used_names is None : [EOL] [comment] [EOL] dct = { } [EOL] [EOL] def recurse ( node ) : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] if node . type == [string] : [EOL] arr = dct . setdefault ( node . value , [ ] ) [EOL] arr . append ( node ) [EOL] else : [EOL] for child in children : [EOL] recurse ( child ) [EOL] [EOL] recurse ( self ) [EOL] self . _used_names = dct [EOL] return self . _used_names [EOL] [EOL] [EOL] class Decorator ( PythonBaseNode ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class ClassOrFunc ( Scope ) : [EOL] __slots__ = ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . children [ [number] ] [EOL] [EOL] def get_decorators ( self ) : [EOL] [docstring] [EOL] decorated = self . parent [EOL] if decorated . type == [string] : [EOL] if decorated . children [ [number] ] . type == [string] : [EOL] return decorated . children [ [number] ] . children [EOL] else : [EOL] return decorated . children [ : [number] ] [EOL] else : [EOL] return [ ] [EOL] [EOL] [EOL] class Class ( ClassOrFunc ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Class , self ) . __init__ ( children ) [EOL] [EOL] def get_super_arglist ( self ) : [EOL] [docstring] [EOL] if self . children [ [number] ] != [string] : [comment] [EOL] return None [EOL] else : [EOL] if self . children [ [number] ] == [string] : [comment] [EOL] return None [EOL] else : [EOL] return self . children [ [number] ] [EOL] [EOL] [EOL] def _create_params ( parent , argslist_list ) : [EOL] [docstring] [EOL] def check_python2_nested_param ( node ) : [EOL] [docstring] [EOL] return node . type == [string] and node . children [ [number] ] == [string] [EOL] [EOL] try : [EOL] first = argslist_list [ [number] ] [EOL] except IndexError : [EOL] return [ ] [EOL] [EOL] if first . type in ( [string] , [string] ) : [EOL] if check_python2_nested_param ( first ) : [EOL] return [ first ] [EOL] else : [EOL] return [ Param ( [ first ] , parent ) ] [EOL] elif first == [string] : [EOL] return [ first ] [EOL] else : [comment] [EOL] children = first . children [EOL] new_children = [ ] [EOL] start = [number] [EOL] [comment] [EOL] for end , child in enumerate ( children + [ None ] , [number] ) : [EOL] if child is None or child == [string] : [EOL] param_children = children [ start : end ] [EOL] if param_children : [comment] [EOL] if check_python2_nested_param ( param_children [ [number] ] ) : [EOL] new_children += param_children [EOL] elif param_children [ [number] ] == [string] and param_children [ [number] ] == [string] : [EOL] new_children += param_children [EOL] else : [EOL] new_children . append ( Param ( param_children , parent ) ) [EOL] start = end [EOL] return new_children [EOL] [EOL] [EOL] class Function ( ClassOrFunc ) : [EOL] [docstring] [EOL] type = [string] [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Function , self ) . __init__ ( children ) [EOL] parameters = self . children [ [number] ] [comment] [EOL] parameters . children [ [number] : - [number] ] = _create_params ( parameters , parameters . children [ [number] : - [number] ] ) [EOL] [EOL] def _get_param_nodes ( self ) : [EOL] return self . children [ [number] ] . children [EOL] [EOL] @ property def params ( self ) : [EOL] [docstring] [EOL] return [ p for p in self . _get_param_nodes ( ) if p . type == [string] ] [EOL] [EOL] @ property def name ( self ) : [EOL] return self . children [ [number] ] [comment] [EOL] [EOL] def iter_yield_exprs ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def iter_return_stmts ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def is_generator ( self ) : [EOL] [docstring] [EOL] return next ( self . iter_yield_exprs ( ) , None ) is not None [EOL] [EOL] @ property def annotation ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . children [ [number] ] == [string] : [EOL] return self . children [ [number] ] [EOL] assert self . children [ [number] ] == [string] [EOL] return None [EOL] except IndexError : [EOL] return None [EOL] [EOL] class Lambda ( Function ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , children ) : [EOL] [comment] [EOL] super ( Function , self ) . __init__ ( children ) [EOL] [comment] [EOL] self . children [ [number] : - [number] ] = _create_params ( self , self . children [ [number] : - [number] ] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] raise AttributeError ( [string] ) [EOL] [EOL] def _get_param_nodes ( self ) : [EOL] return self . children [ [number] : - [number] ] [EOL] [EOL] @ property def annotation ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . start_pos ) [EOL] [EOL] [EOL] class Flow ( PythonBaseNode ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class IfStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_test_nodes ( self ) : [EOL] [docstring] [EOL] for i , c in enumerate ( self . children ) : [EOL] if c in ( [string] , [string] ) : [EOL] yield self . children [ i + [number] ] [EOL] [EOL] def get_corresponding_test_node ( self , node ) : [EOL] [docstring] [EOL] start_pos = node . start_pos [EOL] for check_node in reversed ( list ( self . get_test_nodes ( ) ) ) : [EOL] if check_node . start_pos < start_pos : [EOL] if start_pos < check_node . end_pos : [EOL] return None [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] return check_node [EOL] [EOL] def is_node_after_else ( self , node ) : [EOL] [docstring] [EOL] for c in self . children : [EOL] if c == [string] : [EOL] if node . start_pos > c . start_pos : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class WhileStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class ForStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_testlist ( self ) : [EOL] [docstring] [EOL] return self . children [ [number] ] [EOL] [EOL] [EOL] class TryStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_except_clause_tests ( self ) : [EOL] [docstring] [EOL] for node in self . children : [EOL] [comment] [EOL] if node . type == [string] : [EOL] yield node . children [ [number] ] [EOL] elif node == [string] : [EOL] yield None [EOL] [EOL] [EOL] class WithStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] names = [ ] [EOL] for with_item in self . children [ [number] : - [number] : [number] ] : [EOL] [comment] [EOL] if with_item . type == [string] : [EOL] names += _defined_names ( with_item . children [ [number] ] ) [EOL] return names [EOL] [EOL] def get_context_manager_from_name ( self , name ) : [EOL] [comment] [EOL] node = name . parent [EOL] if node . type != [string] : [EOL] raise ValueError ( [string] ) [EOL] return node . children [ [number] ] [EOL] [EOL] [EOL] class Import ( PythonBaseNode ) : [EOL] __slots__ = ( ) [EOL] [EOL] def get_path_for_name ( self , name ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] name = self . _aliases ( ) [ name ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] for path in self . get_paths ( ) : [EOL] if name in path : [EOL] return path [ : path . index ( name ) + [number] ] [EOL] raise ValueError ( [string] ) [EOL] [EOL] def is_nested ( self ) : [EOL] return False [comment] [EOL] [EOL] def is_star_import ( self ) : [EOL] return self . children [ - [number] ] == [string] [EOL] [EOL] [EOL] class ImportFrom ( Import ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] return [ alias or name for name , alias in self . _as_name_tuples ( ) ] [EOL] [EOL] def _aliases ( self ) : [EOL] [docstring] [EOL] return dict ( ( alias , name ) for name , alias in self . _as_name_tuples ( ) if alias is not None ) [EOL] [EOL] def get_from_names ( self ) : [EOL] for n in self . children [ [number] : ] : [EOL] if n not in ( [string] , [string] ) : [EOL] break [EOL] if n . type == [string] : [comment] [EOL] return n . children [ : : [number] ] [EOL] elif n == [string] : [comment] [EOL] return [ ] [EOL] else : [comment] [EOL] return [ n ] [EOL] [EOL] @ property def level ( self ) : [EOL] [docstring] [EOL] level = [number] [EOL] for n in self . children [ [number] : ] : [EOL] if n in ( [string] , [string] ) : [EOL] level += len ( n . value ) [EOL] else : [EOL] break [EOL] return level [EOL] [EOL] def _as_name_tuples ( self ) : [EOL] last = self . children [ - [number] ] [EOL] if last == [string] : [EOL] last = self . children [ - [number] ] [EOL] elif last == [string] : [EOL] return [comment] [EOL] [EOL] if last . type == [string] : [EOL] as_names = last . children [ : : [number] ] [EOL] else : [EOL] as_names = [ last ] [EOL] for as_name in as_names : [EOL] if as_name . type == [string] : [EOL] yield as_name , None [EOL] else : [EOL] yield as_name . children [ : : [number] ] [comment] [EOL] [EOL] def get_paths ( self ) : [EOL] [docstring] [EOL] dotted = self . get_from_names ( ) [EOL] [EOL] if self . children [ - [number] ] == [string] : [EOL] return [ dotted ] [EOL] return [ dotted + [ name ] for name , alias in self . _as_name_tuples ( ) ] [EOL] [EOL] [EOL] class ImportName ( Import ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] return [ alias or path [ [number] ] for path , alias in self . _dotted_as_names ( ) ] [EOL] [EOL] @ property def level ( self ) : [EOL] [docstring] [EOL] return [number] [comment] [EOL] [EOL] def get_paths ( self ) : [EOL] return [ path for path , alias in self . _dotted_as_names ( ) ] [EOL] [EOL] def _dotted_as_names ( self ) : [EOL] [docstring] [EOL] dotted_as_names = self . children [ [number] ] [EOL] if dotted_as_names . type == [string] : [EOL] as_names = dotted_as_names . children [ : : [number] ] [EOL] else : [EOL] as_names = [ dotted_as_names ] [EOL] [EOL] for as_name in as_names : [EOL] if as_name . type == [string] : [EOL] alias = as_name . children [ [number] ] [EOL] as_name = as_name . children [ [number] ] [EOL] else : [EOL] alias = None [EOL] if as_name . type == [string] : [EOL] yield [ as_name ] , alias [EOL] else : [EOL] [comment] [EOL] yield as_name . children [ : : [number] ] , alias [EOL] [EOL] def is_nested ( self ) : [EOL] [docstring] [EOL] return bool ( [ [number] for path , alias in self . _dotted_as_names ( ) if alias is None and len ( path ) > [number] ] ) [EOL] [EOL] def _aliases ( self ) : [EOL] [docstring] [EOL] return dict ( ( alias , path [ - [number] ] ) for path , alias in self . _dotted_as_names ( ) if alias is not None ) [EOL] [EOL] [EOL] class KeywordStatement ( PythonBaseNode ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] @ property def type ( self ) : [EOL] [docstring] [EOL] return [string] % self . keyword [EOL] [EOL] @ property def keyword ( self ) : [EOL] return self . children [ [number] ] . value [EOL] [EOL] [EOL] class AssertStmt ( KeywordStatement ) : [EOL] __slots__ = ( ) [EOL] [EOL] @ property def assertion ( self ) : [EOL] return self . children [ [number] ] [EOL] [EOL] [EOL] class GlobalStmt ( KeywordStatement ) : [EOL] __slots__ = ( ) [EOL] [EOL] def get_global_names ( self ) : [EOL] return self . children [ [number] : : [number] ] [EOL] [EOL] [EOL] class ReturnStmt ( KeywordStatement ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class YieldExpr ( PythonBaseNode ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] def _defined_names ( current ) : [EOL] [docstring] [EOL] names = [ ] [EOL] if current . type in ( [string] , [string] , [string] ) : [EOL] for child in current . children [ : : [number] ] : [EOL] names += _defined_names ( child ) [EOL] elif current . type in ( [string] , [string] ) : [EOL] names += _defined_names ( current . children [ [number] ] ) [EOL] elif current . type in ( [string] , [string] ) : [EOL] if current . children [ - [number] ] != [string] : [comment] [EOL] trailer = current . children [ - [number] ] [EOL] if trailer . children [ [number] ] == [string] : [EOL] names . append ( trailer . children [ [number] ] ) [EOL] else : [EOL] names . append ( current ) [EOL] return names [EOL] [EOL] [EOL] class ExprStmt ( PythonBaseNode , DocstringMixin ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] names = [ ] [EOL] if self . children [ [number] ] . type == [string] : [EOL] names = _defined_names ( self . children [ [number] ] ) [EOL] return [ name for i in range ( [number] , len ( self . children ) - [number] , [number] ) if [string] in self . children [ i + [number] ] . value for name in _defined_names ( self . children [ i ] ) ] + names [EOL] [EOL] def get_rhs ( self ) : [EOL] [docstring] [EOL] return self . children [ - [number] ] [EOL] [EOL] def yield_operators ( self ) : [EOL] [docstring] [EOL] first = self . children [ [number] ] [EOL] if first . type == [string] : [EOL] if len ( first . children ) <= [number] : [EOL] return [comment] [EOL] [EOL] first = first . children [ [number] ] [EOL] yield first [EOL] [EOL] for operator in self . children [ [number] : : [number] ] : [EOL] yield operator [EOL] [EOL] [EOL] class Param ( PythonBaseNode ) : [EOL] [docstring] [EOL] type = [string] [EOL] [EOL] def __init__ ( self , children , parent ) : [EOL] super ( Param , self ) . __init__ ( children ) [EOL] self . parent = parent [EOL] for child in children : [EOL] child . parent = self [EOL] [EOL] @ property def star_count ( self ) : [EOL] [docstring] [EOL] first = self . children [ [number] ] [EOL] if first in ( [string] , [string] ) : [EOL] return len ( first . value ) [EOL] return [number] [EOL] [EOL] @ property def default ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . children [ int ( self . children [ [number] ] in ( [string] , [string] ) ) + [number] ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] @ property def annotation ( self ) : [EOL] [docstring] [EOL] tfpdef = self . _tfpdef ( ) [EOL] if tfpdef . type == [string] : [EOL] assert tfpdef . children [ [number] ] == [string] [EOL] assert len ( tfpdef . children ) == [number] [EOL] annotation = tfpdef . children [ [number] ] [EOL] return annotation [EOL] else : [EOL] return None [EOL] [EOL] def _tfpdef ( self ) : [EOL] [docstring] [EOL] offset = int ( self . children [ [number] ] in ( [string] , [string] ) ) [EOL] return self . children [ offset ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . _tfpdef ( ) . type == [string] : [EOL] return self . _tfpdef ( ) . children [ [number] ] [EOL] else : [EOL] return self . _tfpdef ( ) [EOL] [EOL] @ property def position_index ( self ) : [EOL] [docstring] [EOL] index = self . parent . children . index ( self ) [EOL] try : [EOL] keyword_only_index = self . parent . children . index ( [string] ) [EOL] if index > keyword_only_index : [EOL] [comment] [EOL] index -= [number] [EOL] except ValueError : [EOL] pass [EOL] return index - [number] [EOL] [EOL] def get_parent_function ( self ) : [EOL] [docstring] [EOL] return search_ancestor ( self , [string] , [string] ) [EOL] [EOL] def get_code ( self , normalized = False , include_prefix = True , include_comma = True ) : [EOL] [docstring] [EOL] if include_comma : [EOL] return super ( Param , self ) . get_code ( normalized , include_prefix ) [EOL] [EOL] children = self . children [EOL] if children [ - [number] ] == [string] : [EOL] children = children [ : - [number] ] [EOL] return self . _get_code_for_children ( children , normalized = False , include_prefix = include_prefix ) [EOL] [EOL] def __repr__ ( self ) : [EOL] default = [string] if self . default is None else [string] % self . default . get_code ( ) [EOL] return [string] % ( type ( self ) . __name__ , str ( self . _tfpdef ( ) ) + default ) [EOL] [EOL] [EOL] class CompFor ( PythonBaseNode ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] return _defined_names ( self . children [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Any [EOL] import typing [EOL] from jedi . parser . python import tree [EOL] from jedi . parser import tokenize [EOL] from jedi . parser . token import ( DEDENT , INDENT , ENDMARKER , NEWLINE , NUMBER , STRING , tok_name ) [EOL] from jedi . parser . parser import BaseParser [EOL] from jedi . common import splitlines [EOL] [EOL] [EOL] class Parser ( BaseParser ) : [EOL] [docstring] [EOL] [EOL] node_map = { [string] : tree . ExprStmt , [string] : tree . Class , [string] : tree . Function , [string] : tree . Module , [string] : tree . ImportName , [string] : tree . ImportFrom , [string] : tree . KeywordStatement , [string] : tree . KeywordStatement , [string] : tree . ReturnStmt , [string] : tree . KeywordStatement , [string] : tree . YieldExpr , [string] : tree . KeywordStatement , [string] : tree . KeywordStatement , [string] : tree . GlobalStmt , [string] : tree . KeywordStatement , [string] : tree . KeywordStatement , [string] : tree . AssertStmt , [string] : tree . IfStmt , [string] : tree . WithStmt , [string] : tree . ForStmt , [string] : tree . WhileStmt , [string] : tree . TryStmt , [string] : tree . CompFor , [string] : tree . Decorator , [string] : tree . Lambda , [string] : tree . Lambda , [string] : tree . Lambda , } [EOL] default_node = tree . PythonNode [EOL] [EOL] def __init__ ( self , grammar , error_recovery = True , start_symbol = [string] ) : [EOL] super ( Parser , self ) . __init__ ( grammar , start_symbol , error_recovery = error_recovery ) [EOL] [EOL] self . syntax_errors = [ ] [EOL] self . _omit_dedent_list = [ ] [EOL] self . _indent_counter = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def parse ( self , tokens ) : [EOL] if self . _error_recovery : [EOL] if self . _start_symbol != [string] : [EOL] raise NotImplementedError [EOL] [EOL] tokens = self . _recovery_tokenize ( tokens ) [EOL] [EOL] node = super ( Parser , self ) . parse ( tokens ) [EOL] [EOL] if self . _start_symbol == [string] != node . type : [EOL] [comment] [EOL] [comment] [EOL] node = self . convert_node ( self . _grammar , self . _grammar . symbol2number [ [string] ] , [ node ] ) [EOL] [EOL] return node [EOL] [EOL] def convert_node ( self , grammar , type , children ) : [EOL] [docstring] [EOL] [comment] [EOL] symbol = grammar . number2symbol [ type ] [EOL] try : [EOL] return self . node_map [ symbol ] ( children ) [EOL] except KeyError : [EOL] if symbol == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] children = [ children [ [number] ] ] + children [ [number] : - [number] ] [EOL] return self . default_node ( symbol , children ) [EOL] [EOL] def convert_leaf ( self , grammar , type , value , prefix , start_pos ) : [EOL] [comment] [EOL] if type == tokenize . NAME : [EOL] if value in grammar . keywords : [EOL] return tree . Keyword ( value , start_pos , prefix ) [EOL] else : [EOL] return tree . Name ( value , start_pos , prefix ) [EOL] elif type == STRING : [EOL] return tree . String ( value , start_pos , prefix ) [EOL] elif type == NUMBER : [EOL] return tree . Number ( value , start_pos , prefix ) [EOL] elif type == NEWLINE : [EOL] return tree . Newline ( value , start_pos , prefix ) [EOL] elif type == ENDMARKER : [EOL] return tree . EndMarker ( value , start_pos , prefix ) [EOL] else : [EOL] return tree . Operator ( value , start_pos , prefix ) [EOL] [EOL] def error_recovery ( self , grammar , stack , arcs , typ , value , start_pos , prefix , add_token_callback ) : [EOL] [docstring] [EOL] if not self . _error_recovery : [EOL] return super ( Parser , self ) . error_recovery ( grammar , stack , arcs , typ , value , start_pos , prefix , add_token_callback ) [EOL] [EOL] def current_suite ( stack ) : [EOL] [comment] [EOL] [comment] [EOL] for index , ( dfa , state , ( type_ , nodes ) ) in reversed ( list ( enumerate ( stack ) ) ) : [EOL] [comment] [EOL] symbol = grammar . number2symbol [ type_ ] [EOL] if symbol == [string] : [EOL] break [EOL] elif symbol == [string] and len ( nodes ) > [number] : [EOL] [comment] [EOL] break [EOL] return index , symbol , nodes [EOL] [EOL] index , symbol , nodes = current_suite ( stack ) [EOL] [EOL] [comment] [EOL] if self . _stack_removal ( grammar , stack , arcs , index + [number] , value , start_pos ) : [EOL] add_token_callback ( typ , value , start_pos , prefix ) [EOL] else : [EOL] if typ == INDENT : [EOL] [comment] [EOL] [comment] [EOL] self . _omit_dedent_list . append ( self . _indent_counter ) [EOL] else : [EOL] error_leaf = tree . PythonErrorLeaf ( tok_name [ typ ] . lower ( ) , value , start_pos , prefix ) [EOL] stack [ - [number] ] [ [number] ] [ [number] ] . append ( error_leaf ) [EOL] [EOL] def _stack_removal ( self , grammar , stack , arcs , start_index , value , start_pos ) : [EOL] failed_stack = [ ] [EOL] found = False [EOL] all_nodes = [ ] [EOL] for dfa , state , ( typ , nodes ) in stack [ start_index : ] : [EOL] if nodes : [EOL] found = True [EOL] if found : [EOL] symbol = grammar . number2symbol [ typ ] [EOL] failed_stack . append ( ( symbol , nodes ) ) [EOL] all_nodes += nodes [EOL] if failed_stack : [EOL] stack [ start_index - [number] ] [ [number] ] [ [number] ] . append ( tree . PythonErrorNode ( all_nodes ) ) [EOL] [EOL] stack [ start_index : ] = [ ] [EOL] return failed_stack [EOL] [EOL] def _recovery_tokenize ( self , tokens ) : [EOL] for typ , value , start_pos , prefix in tokens : [EOL] [comment] [EOL] if typ == DEDENT : [EOL] [comment] [EOL] [comment] [EOL] o = self . _omit_dedent_list [EOL] if o and o [ - [number] ] == self . _indent_counter : [EOL] o . pop ( ) [EOL] continue [EOL] [EOL] self . _indent_counter -= [number] [EOL] elif typ == INDENT : [EOL] self . _indent_counter += [number] [EOL] [EOL] yield typ , value , start_pos , prefix [EOL] [EOL] [EOL] def _remove_last_newline ( node ) : [EOL] endmarker = node . children [ - [number] ] [EOL] [comment] [EOL] [comment] [EOL] prefix = endmarker . prefix [EOL] leaf = endmarker . get_previous_leaf ( ) [EOL] if prefix : [EOL] text = prefix [EOL] else : [EOL] if leaf is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] text = leaf . value [EOL] [EOL] if not text . endswith ( [string] ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] text = text [ : - [number] ] [EOL] if prefix : [EOL] endmarker . prefix = text [EOL] [EOL] if leaf is None : [EOL] end_pos = ( [number] , [number] ) [EOL] else : [EOL] end_pos = leaf . end_pos [EOL] [EOL] lines = splitlines ( text , keepends = True ) [EOL] if len ( lines ) == [number] : [EOL] end_pos = end_pos [ [number] ] , end_pos [ [number] ] + len ( lines [ [number] ] ) [EOL] else : [EOL] end_pos = end_pos [ [number] ] + len ( lines ) - [number] , len ( lines [ - [number] ] ) [EOL] endmarker . start_pos = end_pos [EOL] else : [EOL] leaf . value = text [EOL] endmarker . start_pos = leaf . end_pos [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] from jedi import settings [EOL] from jedi . _compatibility import FileNotFoundError [EOL] from jedi . parser . pgen2 . pgen import generate_grammar [EOL] from jedi . parser . python . parser import Parser , _remove_last_newline [EOL] from jedi . parser . python . diff import DiffParser [EOL] from jedi . parser . tokenize import generate_tokens [EOL] from jedi . parser . cache import parser_cache , load_module , save_module [EOL] from jedi . common import splitlines , source_to_unicode [EOL] [EOL] [EOL] _loaded_grammars = { } [EOL] [EOL] [EOL] def load_grammar ( version = None ) : [EOL] [docstring] [EOL] if version is None : [EOL] version = [string] [EOL] [EOL] if version in ( [string] , [string] ) : [EOL] version = [string] [EOL] elif version == [string] : [EOL] version = [string] [EOL] [EOL] file = [string] + version + [string] [EOL] [EOL] global _loaded_grammars [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , file ) [EOL] try : [EOL] return _loaded_grammars [ path ] [EOL] except KeyError : [EOL] try : [EOL] with open ( path ) as f : [EOL] bnf_text = f . read ( ) [EOL] grammar = generate_grammar ( bnf_text ) [EOL] return _loaded_grammars . setdefault ( path , grammar ) [EOL] except FileNotFoundError : [EOL] [comment] [EOL] return load_grammar ( ) [EOL] [EOL] [EOL] def parse ( code = None , path = None , grammar = None , error_recovery = True , start_symbol = [string] , cache = False , diff_cache = False ) : [EOL] [docstring] [EOL] if code is None and path is None : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if grammar is None : [EOL] grammar = load_grammar ( ) [EOL] [EOL] if cache and not code and path is not None : [EOL] [comment] [EOL] module_node = load_module ( grammar , path ) [EOL] if module_node is not None : [EOL] return module_node [EOL] [EOL] if code is None : [EOL] with open ( path , [string] ) as f : [EOL] code = source_to_unicode ( f . read ( ) ) [EOL] [EOL] if diff_cache and settings . fast_parser : [EOL] try : [EOL] module_cache_item = parser_cache [ path ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] lines = splitlines ( code , keepends = True ) [EOL] module_node = module_cache_item . node [EOL] old_lines = module_cache_item . lines [EOL] if old_lines == lines : [EOL] save_module ( grammar , path , module_node , lines , pickling = False ) [EOL] return module_node [EOL] [EOL] new_node = DiffParser ( grammar , module_node ) . update ( old_lines = old_lines , new_lines = lines ) [EOL] save_module ( grammar , path , new_node , lines , pickling = cache ) [EOL] return new_node [EOL] [EOL] added_newline = not code . endswith ( [string] ) [EOL] lines = tokenize_lines = splitlines ( code , keepends = True ) [EOL] if added_newline : [EOL] code += [string] [EOL] tokenize_lines = list ( tokenize_lines ) [EOL] tokenize_lines [ - [number] ] += [string] [EOL] tokenize_lines . append ( [string] ) [EOL] [EOL] tokens = generate_tokens ( tokenize_lines , use_exact_op_types = True ) [EOL] [EOL] p = Parser ( grammar , error_recovery = error_recovery , start_symbol = start_symbol ) [EOL] root_node = p . parse ( tokens = tokens ) [EOL] if added_newline : [EOL] _remove_last_newline ( root_node ) [EOL] [EOL] if cache or diff_cache : [EOL] save_module ( grammar , path , root_node , lines , pickling = cache ) [EOL] return root_node [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , List , Tuple , Iterator [EOL] import typing_extensions [EOL] import difflib [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] import difflib [EOL] from collections import namedtuple [EOL] [EOL] from jedi . common import splitlines [EOL] from jedi . parser . python . parser import Parser , _remove_last_newline [EOL] from jedi . parser . python . tree import EndMarker [EOL] from jedi import debug [EOL] from jedi . parser . tokenize import ( generate_tokens , NEWLINE , TokenInfo , ENDMARKER , INDENT , DEDENT ) [EOL] [EOL] [EOL] def _get_last_line ( node_or_leaf ) : [EOL] last_leaf = node_or_leaf . get_last_leaf ( ) [EOL] if _ends_with_newline ( last_leaf ) : [EOL] return last_leaf . start_pos [ [number] ] [EOL] else : [EOL] return last_leaf . end_pos [ [number] ] [EOL] [EOL] [EOL] def _ends_with_newline ( leaf , suffix = [string] ) : [EOL] if leaf . type == [string] : [EOL] typ = leaf . original_type [EOL] else : [EOL] typ = leaf . type [EOL] [EOL] return typ == [string] or suffix . endswith ( [string] ) [EOL] [EOL] [EOL] def _flows_finished ( grammar , stack ) : [EOL] [docstring] [EOL] for dfa , newstate , ( symbol_number , nodes ) in stack : [EOL] if grammar . number2symbol [ symbol_number ] in ( [string] , [string] , [string] , [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def suite_or_file_input_is_valid ( grammar , stack ) : [EOL] if not _flows_finished ( grammar , stack ) : [EOL] return False [EOL] [EOL] for dfa , newstate , ( symbol_number , nodes ) in reversed ( stack ) : [EOL] if grammar . number2symbol [ symbol_number ] == [string] : [EOL] [comment] [EOL] return len ( nodes ) > [number] [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] [EOL] [EOL] def _is_flow_node ( node ) : [EOL] try : [EOL] value = node . children [ [number] ] . value [EOL] except AttributeError : [EOL] return False [EOL] return value in ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class _PositionUpdatingFinished ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def _update_positions ( nodes , line_offset , last_leaf ) : [EOL] for node in nodes : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] [comment] [EOL] node . line += line_offset [EOL] if node is last_leaf : [EOL] raise _PositionUpdatingFinished [EOL] else : [EOL] _update_positions ( children , line_offset , last_leaf ) [EOL] [EOL] [EOL] class DiffParser ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , grammar , module ) : [EOL] self . _grammar = grammar [EOL] self . _module = module [EOL] [EOL] def _reset ( self ) : [EOL] self . _copy_count = [number] [EOL] self . _parser_count = [number] [EOL] [EOL] self . _nodes_stack = _NodesStack ( self . _module ) [EOL] [EOL] def update ( self , old_lines , new_lines ) : [EOL] [docstring] [EOL] debug . speed ( [string] ) [EOL] [comment] [EOL] self . _module . _used_names = None [EOL] [EOL] self . _parser_lines_new = new_lines [EOL] self . _added_newline = False [EOL] if new_lines [ - [number] ] != [string] : [EOL] [comment] [EOL] [comment] [EOL] self . _parser_lines_new = list ( new_lines ) [EOL] self . _parser_lines_new [ - [number] ] += [string] [EOL] self . _parser_lines_new . append ( [string] ) [EOL] self . _added_newline = True [EOL] [EOL] self . _reset ( ) [EOL] [EOL] line_length = len ( new_lines ) [EOL] sm = difflib . SequenceMatcher ( None , old_lines , self . _parser_lines_new ) [EOL] opcodes = sm . get_opcodes ( ) [EOL] debug . speed ( [string] ) [EOL] debug . dbg ( [string] % ( len ( old_lines ) , line_length ) ) [EOL] [EOL] for operation , i1 , i2 , j1 , j2 in opcodes : [EOL] debug . dbg ( [string] , operation , i1 + [number] , i2 , j1 + [number] , j2 ) [EOL] [EOL] if j2 == line_length + int ( self . _added_newline ) : [EOL] [comment] [EOL] j2 -= [number] [EOL] [EOL] if operation == [string] : [EOL] line_offset = j1 - i1 [EOL] self . _copy_from_old_parser ( line_offset , i2 , j2 ) [EOL] elif operation == [string] : [EOL] self . _parse ( until_line = j2 ) [EOL] elif operation == [string] : [EOL] self . _parse ( until_line = j2 ) [EOL] else : [EOL] assert operation == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _nodes_stack . close ( ) [EOL] [EOL] if self . _added_newline : [EOL] _remove_last_newline ( self . _module ) [EOL] [EOL] [comment] [EOL] if debug . debug_function : [EOL] self . _enabled_debugging ( old_lines , new_lines ) [EOL] last_pos = self . _module . end_pos [ [number] ] [EOL] if last_pos != line_length : [EOL] current_lines = splitlines ( self . _module . get_code ( ) , keepends = True ) [EOL] diff = difflib . unified_diff ( current_lines , new_lines ) [EOL] raise Exception ( [string] % ( last_pos , line_length , [string] . join ( diff ) ) ) [EOL] [EOL] debug . speed ( [string] ) [EOL] return self . _module [EOL] [EOL] def _enabled_debugging ( self , old_lines , lines_new ) : [EOL] if self . _module . get_code ( ) != [string] . join ( lines_new ) : [EOL] debug . warning ( [string] , [string] . join ( old_lines ) , [string] . join ( lines_new ) ) [EOL] [EOL] def _copy_from_old_parser ( self , line_offset , until_line_old , until_line_new ) : [EOL] copied_nodes = [ None ] [EOL] [EOL] last_until_line = - [number] [EOL] while until_line_new > self . _nodes_stack . parsed_until_line : [EOL] parsed_until_line_old = self . _nodes_stack . parsed_until_line - line_offset [EOL] line_stmt = self . _get_old_line_stmt ( parsed_until_line_old + [number] ) [EOL] if line_stmt is None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _parse ( self . _nodes_stack . parsed_until_line + [number] ) [EOL] elif not copied_nodes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _parse ( until_line_new ) [EOL] else : [EOL] p_children = line_stmt . parent . children [EOL] index = p_children . index ( line_stmt ) [EOL] [EOL] copied_nodes = self . _nodes_stack . copy_nodes ( p_children [ index : ] , until_line_old , line_offset ) [EOL] [comment] [EOL] if copied_nodes : [EOL] self . _copy_count += [number] [EOL] [EOL] from_ = copied_nodes [ [number] ] . get_start_pos_of_prefix ( ) [ [number] ] + line_offset [EOL] to = self . _nodes_stack . parsed_until_line [EOL] [EOL] debug . dbg ( [string] , from_ , to ) [EOL] [comment] [EOL] [comment] [EOL] assert last_until_line != self . _nodes_stack . parsed_until_line or not copied_nodes , last_until_line [EOL] last_until_line = self . _nodes_stack . parsed_until_line [EOL] [EOL] def _get_old_line_stmt ( self , old_line ) : [EOL] leaf = self . _module . get_leaf_for_position ( ( old_line , [number] ) , include_prefixes = True ) [EOL] [EOL] if _ends_with_newline ( leaf ) : [EOL] leaf = leaf . get_next_leaf ( ) [EOL] if leaf . get_start_pos_of_prefix ( ) [ [number] ] == old_line : [EOL] node = leaf [EOL] while node . parent . type not in ( [string] , [string] ) : [EOL] node = node . parent [EOL] return node [EOL] [comment] [EOL] return None [EOL] [EOL] def _get_before_insertion_node ( self ) : [EOL] if self . _nodes_stack . is_empty ( ) : [EOL] return None [EOL] [EOL] line = self . _nodes_stack . parsed_until_line + [number] [EOL] node = self . _new_module . get_last_leaf ( ) [EOL] while True : [EOL] parent = node . parent [EOL] if parent . type in ( [string] , [string] ) : [EOL] assert node . end_pos [ [number] ] <= line [EOL] assert node . end_pos [ [number] ] == [number] or [string] in self . _prefix [EOL] return node [EOL] node = parent [EOL] [EOL] def _parse ( self , until_line ) : [EOL] [docstring] [EOL] last_until_line = [number] [EOL] while until_line > self . _nodes_stack . parsed_until_line : [EOL] node = self . _try_parse_part ( until_line ) [EOL] nodes = self . _get_children_nodes ( node ) [EOL] [comment] [EOL] [EOL] self . _nodes_stack . add_parsed_nodes ( nodes ) [EOL] debug . dbg ( [string] , nodes [ [number] ] . get_start_pos_of_prefix ( ) [ [number] ] , self . _nodes_stack . parsed_until_line , node . end_pos [ [number] ] - [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert last_until_line != self . _nodes_stack . parsed_until_line , last_until_line [EOL] last_until_line = self . _nodes_stack . parsed_until_line [EOL] [EOL] def _get_children_nodes ( self , node ) : [EOL] nodes = node . children [EOL] first_element = nodes [ [number] ] [EOL] [comment] [EOL] if first_element . type == [string] and first_element . original_type == [string] : [EOL] assert False , str ( nodes ) [EOL] [EOL] return nodes [EOL] [EOL] def _try_parse_part ( self , until_line ) : [EOL] [docstring] [EOL] self . _parser_count += [number] [EOL] [comment] [EOL] [comment] [EOL] parsed_until_line = self . _nodes_stack . parsed_until_line [EOL] lines_after = self . _parser_lines_new [ parsed_until_line : ] [EOL] [comment] [EOL] tokens = self . _diff_tokenize ( lines_after , until_line , line_offset = parsed_until_line ) [EOL] self . _active_parser = Parser ( self . _grammar , error_recovery = True ) [EOL] return self . _active_parser . parse ( tokens = tokens ) [EOL] [EOL] def _diff_tokenize ( self , lines , until_line , line_offset = [number] ) : [EOL] is_first_token = True [EOL] omitted_first_indent = False [EOL] indents = [ ] [EOL] tokens = generate_tokens ( lines , use_exact_op_types = True ) [EOL] stack = self . _active_parser . pgen_parser . stack [EOL] for typ , string , start_pos , prefix in tokens : [EOL] start_pos = start_pos [ [number] ] + line_offset , start_pos [ [number] ] [EOL] if typ == INDENT : [EOL] indents . append ( start_pos [ [number] ] ) [EOL] if is_first_token : [EOL] omitted_first_indent = True [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] is_first_token = False [EOL] continue [EOL] is_first_token = False [EOL] [EOL] if typ == DEDENT : [EOL] indents . pop ( ) [EOL] if omitted_first_indent and not indents : [EOL] [comment] [EOL] [comment] [EOL] typ , string , start_pos , prefix = next ( tokens ) [EOL] if [string] in prefix : [EOL] prefix = re . sub ( [string] , [string] , prefix ) [EOL] else : [EOL] prefix = [string] [EOL] yield TokenInfo ( ENDMARKER , [string] , ( start_pos [ [number] ] + line_offset , [number] ) , prefix ) [EOL] break [EOL] elif typ == NEWLINE and start_pos [ [number] ] >= until_line : [EOL] yield TokenInfo ( typ , string , start_pos , prefix ) [EOL] [comment] [EOL] if suite_or_file_input_is_valid ( self . _grammar , stack ) : [EOL] start_pos = start_pos [ [number] ] + [number] , [number] [EOL] while len ( indents ) > int ( omitted_first_indent ) : [EOL] indents . pop ( ) [EOL] yield TokenInfo ( DEDENT , [string] , start_pos , [string] ) [EOL] [EOL] yield TokenInfo ( ENDMARKER , [string] , start_pos , [string] ) [EOL] break [EOL] else : [EOL] continue [EOL] [EOL] yield TokenInfo ( typ , string , start_pos , prefix ) [EOL] [EOL] [EOL] class _NodesStackNode ( object ) : [EOL] ChildrenGroup = namedtuple ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , tree_node , parent = None ) : [EOL] self . tree_node = tree_node [EOL] self . children_groups = [ ] [EOL] self . parent = parent [EOL] [EOL] def close ( self ) : [EOL] children = [ ] [EOL] for children_part , line_offset , last_line_offset_leaf in self . children_groups : [EOL] if line_offset != [number] : [EOL] try : [EOL] _update_positions ( children_part , line_offset , last_line_offset_leaf ) [EOL] except _PositionUpdatingFinished : [EOL] pass [EOL] children += children_part [EOL] self . tree_node . children = children [EOL] [comment] [EOL] for node in children : [EOL] node . parent = self . tree_node [EOL] [EOL] def add ( self , children , line_offset = [number] , last_line_offset_leaf = None ) : [EOL] group = self . ChildrenGroup ( children , line_offset , last_line_offset_leaf ) [EOL] self . children_groups . append ( group ) [EOL] [EOL] def get_last_line ( self , suffix ) : [EOL] line = [number] [EOL] if self . children_groups : [EOL] children_group = self . children_groups [ - [number] ] [EOL] last_leaf = children_group . children [ - [number] ] . get_last_leaf ( ) [EOL] line = last_leaf . end_pos [ [number] ] [EOL] [EOL] [comment] [EOL] offset = children_group . line_offset [EOL] if offset : [EOL] [comment] [EOL] [comment] [EOL] if last_leaf . line <= children_group . last_line_offset_leaf . line : [EOL] line += children_group . line_offset [EOL] [EOL] [comment] [EOL] [comment] [EOL] if _ends_with_newline ( last_leaf , suffix ) : [EOL] line -= [number] [EOL] line += suffix . count ( [string] ) [EOL] return line [EOL] [EOL] [EOL] class _NodesStack ( object ) : [EOL] endmarker_type = [string] [EOL] [EOL] def __init__ ( self , module ) : [EOL] [comment] [EOL] self . _tos = self . _base_node = _NodesStackNode ( module ) [EOL] self . _module = module [EOL] self . _last_prefix = [string] [EOL] self . prefix = [string] [EOL] [EOL] def is_empty ( self ) : [EOL] return not self . _base_node . children [EOL] [EOL] @ property def parsed_until_line ( self ) : [EOL] return self . _tos . get_last_line ( self . prefix ) [EOL] [EOL] def _get_insertion_node ( self , indentation_node ) : [EOL] indentation = indentation_node . start_pos [ [number] ] [EOL] [EOL] [comment] [EOL] node = self . _tos [EOL] while True : [EOL] tree_node = node . tree_node [EOL] if tree_node . type == [string] : [EOL] [comment] [EOL] node_indentation = tree_node . children [ [number] ] . start_pos [ [number] ] [EOL] [EOL] if indentation >= node_indentation : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return node [EOL] [EOL] elif tree_node . type == [string] : [EOL] return node [EOL] [EOL] node = self . _close_tos ( ) [EOL] [EOL] def _close_tos ( self ) : [EOL] self . _tos . close ( ) [EOL] self . _tos = self . _tos . parent [EOL] return self . _tos [EOL] [EOL] def add_parsed_nodes ( self , tree_nodes ) : [EOL] tree_nodes = self . _remove_endmarker ( tree_nodes ) [EOL] if not tree_nodes : [EOL] return [EOL] [EOL] assert tree_nodes [ [number] ] . type != [string] [EOL] [EOL] node = self . _get_insertion_node ( tree_nodes [ [number] ] ) [EOL] assert node . tree_node . type in ( [string] , [string] ) [EOL] node . add ( tree_nodes ) [EOL] self . _update_tos ( tree_nodes [ - [number] ] ) [EOL] [EOL] def _remove_endmarker ( self , tree_nodes ) : [EOL] [docstring] [EOL] last_leaf = tree_nodes [ - [number] ] . get_last_leaf ( ) [EOL] is_endmarker = last_leaf . type == self . endmarker_type [EOL] self . _last_prefix = [string] [EOL] if is_endmarker : [EOL] try : [EOL] separation = last_leaf . prefix . rindex ( [string] ) [EOL] except ValueError : [EOL] pass [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] last_leaf . prefix , self . _last_prefix = last_leaf . prefix [ : separation + [number] ] , last_leaf . prefix [ separation + [number] : ] [EOL] [EOL] first_leaf = tree_nodes [ [number] ] . get_first_leaf ( ) [EOL] first_leaf . prefix = self . prefix + first_leaf . prefix [EOL] self . prefix = [string] [EOL] [EOL] if is_endmarker : [EOL] self . prefix = last_leaf . prefix [EOL] [EOL] tree_nodes = tree_nodes [ : - [number] ] [EOL] [EOL] return tree_nodes [EOL] [EOL] def copy_nodes ( self , tree_nodes , until_line , line_offset ) : [EOL] [docstring] [EOL] tos = self . _get_insertion_node ( tree_nodes [ [number] ] ) [EOL] [EOL] new_nodes , self . _tos = self . _copy_nodes ( tos , tree_nodes , until_line , line_offset ) [EOL] return new_nodes [EOL] [EOL] def _copy_nodes ( self , tos , nodes , until_line , line_offset ) : [EOL] new_nodes = [ ] [EOL] [EOL] new_tos = tos [EOL] for node in nodes : [EOL] if node . type == [string] : [EOL] [comment] [EOL] break [EOL] [EOL] if node . start_pos [ [number] ] > until_line : [EOL] break [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if _get_last_line ( node ) > until_line : [EOL] [comment] [EOL] if node . type in ( [string] , [string] ) and node . children [ - [number] ] . type == [string] : [EOL] new_nodes . append ( node ) [EOL] break [EOL] [EOL] new_nodes . append ( node ) [EOL] [EOL] if not new_nodes : [EOL] return [ ] , tos [EOL] [EOL] last_node = new_nodes [ - [number] ] [EOL] line_offset_index = - [number] [EOL] if last_node . type in ( [string] , [string] ) : [EOL] suite = last_node . children [ - [number] ] [EOL] if suite . type == [string] : [EOL] suite_tos = _NodesStackNode ( suite ) [EOL] [comment] [EOL] [comment] [EOL] suite_nodes , recursive_tos = self . _copy_nodes ( suite_tos , suite . children , until_line , line_offset ) [EOL] if len ( suite_nodes ) < [number] : [EOL] [comment] [EOL] new_nodes . pop ( ) [EOL] else : [EOL] suite_tos . parent = tos [EOL] new_tos = recursive_tos [EOL] line_offset_index = - [number] [EOL] [EOL] elif ( new_nodes [ - [number] ] . type in ( [string] , [string] ) or _is_flow_node ( new_nodes [ - [number] ] ) ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] new_nodes . pop ( ) [EOL] while new_nodes : [EOL] last_node = new_nodes [ - [number] ] [EOL] if last_node . get_last_leaf ( ) . type == [string] : [EOL] break [EOL] new_nodes . pop ( ) [EOL] [EOL] if new_nodes : [EOL] try : [EOL] last_line_offset_leaf = new_nodes [ line_offset_index ] . get_last_leaf ( ) [EOL] except IndexError : [EOL] line_offset = [number] [EOL] [comment] [EOL] [comment] [EOL] last_line_offset_leaf = None [EOL] tos . add ( new_nodes , line_offset , last_line_offset_leaf ) [EOL] return new_nodes , new_tos [EOL] [EOL] def _update_tos ( self , tree_node ) : [EOL] if tree_node . type in ( [string] , [string] ) : [EOL] self . _tos = _NodesStackNode ( tree_node , self . _tos ) [EOL] self . _tos . add ( list ( tree_node . children ) ) [EOL] self . _update_tos ( tree_node . children [ - [number] ] ) [EOL] elif tree_node . type in ( [string] , [string] ) : [EOL] self . _update_tos ( tree_node . children [ - [number] ] ) [EOL] [EOL] def close ( self ) : [EOL] while self . _tos is not None : [EOL] self . _close_tos ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] last_leaf = self . _module . get_last_leaf ( ) [EOL] end_pos = list ( last_leaf . end_pos ) [EOL] except IndexError : [EOL] end_pos = [ [number] , [number] ] [EOL] lines = splitlines ( self . prefix ) [EOL] assert len ( lines ) > [number] [EOL] if len ( lines ) == [number] : [EOL] end_pos [ [number] ] += len ( lines [ [number] ] ) [EOL] else : [EOL] end_pos [ [number] ] += len ( lines ) - [number] [EOL] end_pos [ [number] ] = len ( lines [ - [number] ] ) [EOL] [EOL] endmarker = EndMarker ( [string] , tuple ( end_pos ) , self . prefix + self . _last_prefix ) [EOL] endmarker . parent = self . _module [EOL] self . _module . children . append ( endmarker ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $difflib.SequenceMatcher[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 $difflib.SequenceMatcher[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import string [EOL] import typing [EOL] import os [EOL] from string import Template [EOL] [EOL] import sublime [EOL] [EOL] from . . helpers import get_settings , active_view , is_remote_session [EOL] [EOL] [EOL] class AnacondaSetPythonBuilder ( object ) : [EOL] [docstring] [EOL] [EOL] def update_interpreter_build_system ( self , cmd ) : [EOL] [docstring] [EOL] [EOL] view = active_view ( ) [EOL] if get_settings ( view , [string] , True ) is False : [EOL] return [EOL] [EOL] if is_remote_session ( view ) : [EOL] return [EOL] [EOL] if cmd is None : [EOL] sublime . message_dialog ( [string] ) [EOL] return [EOL] [EOL] project = self . _get_project ( ) [EOL] if project . get ( [string] , False ) is not False : [EOL] if type ( project [ [string] ] ) is list : [EOL] done = False [EOL] current_list = project [ [string] ] [EOL] for i in range ( len ( current_list ) ) : [EOL] build = current_list [ i ] [EOL] if build [ [string] ] == [string] : [EOL] current_list [ i ] = self . _parse_tpl ( cmd ) [EOL] done = True [EOL] break [EOL] [EOL] if not done : [EOL] project [ [string] ] . append ( self . _parse_tpl ( cmd ) ) [EOL] else : [EOL] sublime . message_dialog ( [string] ) [EOL] else : [EOL] project . update ( { [string] : [ self . _parse_tpl ( cmd ) ] } ) [EOL] [EOL] self . _save_project ( project ) [EOL] [EOL] def _get_project ( self ) : [EOL] [docstring] [EOL] [EOL] return sublime . active_window ( ) . project_data ( ) [EOL] [EOL] def _parse_tpl ( self , cmd ) : [EOL] [docstring] [EOL] [EOL] template_file = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , [string] ) [EOL] with open ( template_file , [string] , encoding = [string] ) as tplfile : [EOL] template = Template ( tplfile . read ( ) ) [EOL] [EOL] cmd = cmd . replace ( [string] , [string] ) [EOL] return sublime . decode_value ( template . safe_substitute ( { [string] : cmd } ) ) [EOL] [EOL] def _save_project ( self , project_data ) : [EOL] [docstring] [EOL] [EOL] sublime . active_window ( ) . set_project_data ( project_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $string.Template$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $string.Template$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List [EOL] import socket [EOL] import urllib [EOL] import typing [EOL] import os [EOL] import socket [EOL] [EOL] from urllib . parse import urlparse , parse_qs [EOL] [EOL] import sublime [EOL] [EOL] from . . logger import Log [EOL] from . . unix_socket import UnixSocketPath [EOL] from . . helpers import project_name , debug_enabled [EOL] from . . helpers import get_settings , active_view , get_interpreter [EOL] from . . vagrant import VagrantIPAddressGlobal , VagrantMachineGlobalInfo [EOL] [EOL] [EOL] class Interpreter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter_string ) : [EOL] self . __data = { } [EOL] self . __raw_interpreter = interpreter_string [EOL] self . __parse_raw_interpreter ( ) [EOL] self . __project_name = [string] [EOL] [EOL] def __getattr__ ( self , attr_name ) : [EOL] [docstring] [EOL] [EOL] return self . __data . get ( attr_name , None ) [EOL] [EOL] @ property def raw_interpreter ( self ) : [EOL] return self . __raw_interpreter [EOL] [EOL] @ property def for_local ( self ) : [EOL] [docstring] [EOL] [EOL] return self . scheme == [string] [EOL] [EOL] @ property def for_remote ( self ) : [EOL] [docstring] [EOL] [EOL] return self . scheme == [string] [EOL] [EOL] @ property def for_vagrant ( self ) : [EOL] [docstring] [EOL] [EOL] return self . scheme == [string] [EOL] [EOL] @ property def project_name ( self ) : [EOL] [docstring] [EOL] [EOL] if not self . __project_name : [EOL] self . __project_name = project_name ( ) [EOL] [EOL] return self . __project_name [EOL] [EOL] def renew_interpreter ( self ) : [EOL] [docstring] [EOL] [EOL] if not self . for_local : [EOL] return [EOL] [EOL] self . __prepare_local_interpreter ( ) [EOL] [EOL] def __prepare_local_interpreter ( self ) : [EOL] [docstring] [EOL] [EOL] view = active_view ( ) [EOL] self . __extract_port ( view ) [EOL] self . __extract_paths ( view ) [EOL] self . __extract_python_interpreter ( view ) [EOL] self . __extract_script ( ) [EOL] [EOL] args = [ self . python , [string] , self . script_file , [string] , self . project_name ] [EOL] if self . port is not None : [EOL] args . append ( str ( self . port ) ) [EOL] if len ( self . paths ) > [number] : [EOL] paths = [ p for p in self . paths if os . path . exists ( p ) ] [EOL] args . extend ( [ [string] , [string] . join ( paths ) ] ) [EOL] args . extend ( [ str ( os . getpid ( ) ) ] ) [EOL] [EOL] kwargs = { } [EOL] folders = sublime . active_window ( ) . folders ( ) [EOL] if len ( folders ) > [number] and os . path . exists ( folders [ [number] ] ) : [EOL] kwargs [ [string] ] = folders [ [number] ] [EOL] [EOL] self . __data [ [string] ] = ( args , kwargs ) [EOL] [EOL] def __extract_port ( self , view ) : [EOL] [docstring] [EOL] [EOL] if sublime . platform ( ) != [string] : [EOL] self . __data [ [string] ] = [string] [EOL] else : [EOL] self . __data [ [string] ] = self . __get_unix_domain_socket ( ) [EOL] return [EOL] [EOL] if debug_enabled ( view ) : [EOL] port = get_settings ( view , [string] , [number] ) [EOL] self . __data [ [string] ] = port [EOL] return [EOL] [EOL] if sublime . platform ( ) != [string] : [EOL] s = socket . socket ( ) [EOL] s . bind ( ( [string] , [number] ) ) [EOL] self . __data [ [string] ] = s . getsockname ( ) [ [number] ] [EOL] s . close ( ) [EOL] [EOL] def __extract_paths ( self , view ) : [EOL] [docstring] [EOL] [EOL] extra = get_settings ( view , [string] , [ ] ) [EOL] paths = [ os . path . expanduser ( os . path . expandvars ( p ) ) for p in extra ] [EOL] [EOL] try : [EOL] paths . extend ( sublime . active_window ( ) . folders ( ) ) [EOL] except AttributeError : [EOL] Log . warning ( [string] [string] ) [EOL] paths = paths . split ( [string] ) [EOL] paths . extend ( sublime . active_window ( ) . folder ( ) ) [EOL] [EOL] self . __data [ [string] ] = paths [EOL] [EOL] def __extract_python_interpreter ( self , view ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] python = os . path . expanduser ( os . path . expandvars ( get_interpreter ( view ) ) ) [EOL] if [string] in python : [EOL] Log . warning ( [string] [string] [string] . format ( python ) ) [EOL] except : [EOL] python = [string] [EOL] finally : [EOL] self . __data [ [string] ] = python [EOL] [EOL] def __extract_script ( self ) : [EOL] [docstring] [EOL] [EOL] self . __data [ [string] ] = os . path . join ( os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) ) , [string] , [string] ) [EOL] [EOL] def __get_unix_domain_socket ( self ) : [EOL] [docstring] [EOL] [EOL] if sublime . platform ( ) != [string] : [EOL] return [string] [EOL] [EOL] return UnixSocketPath ( self . project_name ) . socket [EOL] [EOL] def __parse_raw_interpreter ( self ) : [EOL] [docstring] [EOL] [EOL] urldata = urlparse ( self . __raw_interpreter ) [EOL] self . __data [ [string] ] = urldata . scheme if urldata . scheme else [string] [EOL] if len ( self . __data [ [string] ] ) == [number] : [EOL] self . __data [ [string] ] = [string] [EOL] [EOL] if self . for_local : [EOL] [comment] [EOL] return self . __prepare_local_interpreter ( ) [EOL] [EOL] if urldata . query and [string] in urldata . query : [EOL] self . __data [ [string] ] = [string] [EOL] [EOL] netloc = urldata . netloc [EOL] if [string] in urldata . netloc : [EOL] left , netloc = netloc . split ( [string] ) [EOL] self . __data [ [string] ] , self . __data [ [string] ] = left . split ( [string] ) [EOL] [EOL] if self . for_remote : [EOL] self . __data [ [string] ] , self . __data [ [string] ] = netloc . split ( [string] ) [EOL] [EOL] if self . for_vagrant : [EOL] self . __data [ [string] ] , self . __data [ [string] ] = netloc . split ( [string] ) [EOL] [EOL] if urldata . query : [EOL] options = parse_qs ( urldata . query ) [EOL] for key , value in options . items ( ) : [EOL] self . __data [ key ] = ( value if key in [ [string] , [string] ] else value [ [number] ] ) [EOL] [EOL] if self . for_vagrant : [EOL] self . __data [ [string] ] = self . __data . get ( [string] , [string] ) [EOL] self . __data [ [string] ] = ( self . __data . get ( [string] , [string] ) ) [EOL] _vagrant_hosts = { [string] : [string] , [string] : self . address , [string] : VagrantIPAddressGlobal ( VagrantMachineGlobalInfo ( self . machine ) . machine_id , self . dev ) . ip_address } [EOL] self . __data [ [string] ] = _vagrant_hosts [ self . network ] [EOL] [EOL] pathmap = { } [EOL] for map_data in self . __data . get ( [string] , [ ] ) : [EOL] split_data = map_data . split ( [string] ) [EOL] if len ( split_data ) != [number] : [EOL] Log . warning ( [string] . format ( map_data ) ) [EOL] continue [EOL] [EOL] local_path = os . path . expanduser ( os . path . expandvars ( split_data [ [number] ] ) ) [EOL] remote_path = os . path . expanduser ( os . path . expandvars ( split_data [ [number] ] ) ) [EOL] pathmap [ local_path ] = remote_path [EOL] [EOL] self . __data [ [string] ] = pathmap [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] return [string] . join ( self . arguments [ [number] ] ) [EOL] except TypeError : [EOL] rep = [string] [EOL] for k , v in self . __data . items ( ) : [EOL] rep + k + [string] + v + [string] [EOL] return rep [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class StubProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . _process = None [EOL] self . _interpreter = None [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . local_process import LocalProcess [EOL] from . remote_process import StubProcess [EOL] from . vagrant_process import VagrantProcess [EOL] [EOL] [EOL] class WorkerProcess ( object ) : [EOL] [docstring] [EOL] [EOL] _processers = { [string] : StubProcess , [string] : VagrantProcess } [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . _interpreter = interpreter [EOL] [EOL] def take ( self ) : [EOL] scheme = self . _interpreter . scheme [EOL] return self . _processers . get ( scheme , LocalProcess ) ( self . _interpreter ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Any , Union , List , Dict [EOL] import socket [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import time [EOL] import shlex [EOL] import socket [EOL] import subprocess [EOL] [EOL] from . . logger import Log [EOL] from . . helpers import create_subprocess [EOL] from . . helpers import debug_enabled , active_view , get_settings [EOL] [EOL] [EOL] class VagrantProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . interpreter = interpreter [EOL] self . _process = None [EOL] self . errpr = [string] [EOL] self . tip = [string] [EOL] [EOL] @ property def healthy ( self ) : [EOL] [docstring] [EOL] [EOL] if debug_enabled : [EOL] return True [EOL] [EOL] if self . _process . poll ( ) is not None : [EOL] self . error = [string] [EOL] self . tip = [string] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if self . interpreter . manual is not None or self . _up_already ( ) : [EOL] return True [EOL] [EOL] args , kwargs = self . _prepare_arguments ( ) [EOL] self . _process = create_subprocess ( args , ** kwargs ) [EOL] time . sleep ( [number] ) [comment] [EOL] if self . _process is None or self . _process . poll ( ) is not None : [EOL] [comment] [EOL] output , error = self . _process . communicate ( ) [EOL] if error == [string] : [EOL] return True [comment] [EOL] self . error = ( [string] [string] . format ( [string] . join ( args ) , output . decode ( [string] ) , error . decode ( [string] ) . replace ( [string] , [string] ) ) ) [EOL] self . tip = [string] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _up_already ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] s . settimeout ( [number] ) [EOL] s . connect ( ( self . interpreter . host , self . interpreter . port ) ) [EOL] s . close ( ) [EOL] self . interpreter . manual = True [EOL] except : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _prepare_arguments ( self ) : [EOL] [docstring] [EOL] [EOL] script_file = self . _compose_script_file ( ) [EOL] paths = self . _compose_extra_paths ( ) [EOL] cmd = [string] . format ( self . interpreter . machine_id , [string] . format ( self . interpreter . interpreter , script_file , self . interpreter . project_name , [string] . format ( [string] + [string] . join ( paths ) if paths else [string] ) , self . interpreter . port ) ) [EOL] [EOL] kwargs = { [string] : subprocess . PIPE , [string] : subprocess . PIPE } [EOL] return shlex . split ( cmd , posix = os . name != [string] ) , kwargs [EOL] [EOL] def _compose_script_file ( self ) : [EOL] [docstring] [EOL] [EOL] target_os = self . interpreter . os [EOL] target_os = [string] if target_os is None else target_os . lower ( ) [EOL] sep = [string] if target_os == [string] else [string] [EOL] shared = self . interpreter . shared [EOL] if shared is None : [EOL] shared = [string] if target_os == [string] else [string] [EOL] [EOL] return [string] . format ( shared , sep ) [EOL] [EOL] def _compose_extra_paths ( self ) : [EOL] [docstring] [EOL] [EOL] extra_paths = [ ] [EOL] try : [EOL] self . interpreter . extra . extend ( [ ] ) [EOL] except AttributeError : [EOL] if self . interpreter . extra is not None : [EOL] Log . warning ( [string] [string] ) [EOL] extra_paths . extend ( self . interpreter . extra . split ( [string] ) ) [EOL] else : [EOL] extra_paths . extend ( self . interpreter . extra ) [EOL] [EOL] extra_paths . extend ( get_settings ( active_view ( ) , [string] , [ ] ) ) [EOL] return extra_paths [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] [EOL] from . . helpers import create_subprocess [EOL] from . . helpers import debug_enabled , active_view [EOL] [EOL] [EOL] class LocalProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . interpreter = interpreter [EOL] self . _process = None [EOL] self . error = [string] [EOL] self . tip = [string] [EOL] [EOL] @ property def healthy ( self ) : [EOL] [docstring] [EOL] [EOL] if debug_enabled ( active_view ( ) ) : [EOL] [comment] [EOL] return True [EOL] [EOL] if self . _process . poll ( ) is not None : [EOL] self . error = [string] [EOL] self . tip = [string] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] if debug_enabled ( active_view ( ) ) : [EOL] [comment] [EOL] return True [EOL] [EOL] args , kwargs = self . interpreter . arguments [EOL] self . _process = create_subprocess ( args , ** kwargs ) [EOL] if self . _process is None : [EOL] [comment] [EOL] self . _set_wrong_config_error ( ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] [EOL] if self . _process is not None and self . _process . poll ( ) is None : [EOL] self . _process . kill ( ) [EOL] self . _process = None [EOL] [EOL] def _set_wrong_config_error ( self ) : [EOL] [docstring] [EOL] [EOL] example = [string] [EOL] if os . name == [string] : [EOL] example = [string] [EOL] [EOL] self . error = ( [string] [string] . format ( self . interpreter . raw_interpreter ) ) [EOL] self . tip = ( [string] [string] [string] . format ( example ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class ItalianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_AEIO = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_CG = [ [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( ItalianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_5 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab8 : pass [EOL] self . cursor = v_4 [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_4 [EOL] if self . cursor >= self . limit : [EOL] raise lab5 ( ) [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_3 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] except lab3 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( ItalianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_attached_pronoun ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( ItalianStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab3 : pass [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_vowel_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping_b ( ItalianStemmer . g_AEIO , [number] , [number] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if not self . in_grouping_b ( ItalianStemmer . g_CG , [number] , [number] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_attached_pronoun ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_vowel_suffix ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_7 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_7 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , ItalianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class GermanStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] ] [EOL] [EOL] g_st_ending = [ [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab11 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab11 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab10 ( ) [EOL] except lab11 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab10 : pass [EOL] self . cursor = v_5 [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_5 [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab8 : pass [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_4 [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] except lab5 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( GermanStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab0 ( ) [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( GermanStemmer . g_s_ending , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab2 ( ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( GermanStemmer . g_st_ending , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] c = self . cursor - [number] [EOL] if self . limit_backward > c or c > self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor = c [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab3 ( ) [EOL] if among_var == [number] : [EOL] raise lab3 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab4 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] raise lab3 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab7 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab7 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_10 [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_10 [EOL] raise lab10 ( ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_10 [EOL] raise lab10 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab10 : pass [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_4 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , GermanStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class PorterStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_WXY = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] B_Y_found = False [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_Y_found = other . B_Y_found [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_shortv ( self ) : [EOL] [comment] [EOL] if not self . out_grouping_b ( PorterStemmer . g_v_WXY , [number] , [number] ) : [EOL] return False [EOL] if not self . in_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] if not self . out_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_1a ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_1b ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor != self . I_p1 : [EOL] return False [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] return False [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] return True [EOL] [EOL] def r_Step_1c ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_2 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_3 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_4 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_5a ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] raise lab2 ( ) [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_5b ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_Y_found = False [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_4 [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_4 [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab8 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab11 ( ) [EOL] raise lab10 ( ) [EOL] except lab11 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab10 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab13 ( ) [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab12 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab7 : pass [EOL] self . cursor = v_5 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1a ( ) : [EOL] raise lab16 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1b ( ) : [EOL] raise lab17 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1c ( ) : [EOL] raise lab18 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_12 [EOL] [comment] [EOL] v_13 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_2 ( ) : [EOL] raise lab19 ( ) [EOL] except lab19 : pass [EOL] self . cursor = self . limit - v_13 [EOL] [comment] [EOL] v_14 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_3 ( ) : [EOL] raise lab20 ( ) [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_14 [EOL] [comment] [EOL] v_15 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_4 ( ) : [EOL] raise lab21 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_15 [EOL] [comment] [EOL] v_16 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_5a ( ) : [EOL] raise lab22 ( ) [EOL] except lab22 : pass [EOL] self . cursor = self . limit - v_16 [EOL] [comment] [EOL] v_17 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_5b ( ) : [EOL] raise lab23 ( ) [EOL] except lab23 : pass [EOL] self . cursor = self . limit - v_17 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_18 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . B_Y_found : [EOL] raise lab24 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_19 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_20 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab29 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_20 [EOL] raise lab28 ( ) [EOL] except lab29 : pass [EOL] self . cursor = v_20 [EOL] if self . cursor >= self . limit : [EOL] raise lab27 ( ) [EOL] self . cursor += [number] [EOL] except lab28 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab26 ( ) [EOL] except lab27 : pass [EOL] self . cursor = v_19 [EOL] raise lab25 ( ) [EOL] except lab26 : pass [EOL] except lab25 : pass [EOL] except lab24 : pass [EOL] self . cursor = v_18 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , PorterStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL] class lab22 ( BaseException ) : pass [EOL] class lab23 ( BaseException ) : pass [EOL] class lab24 ( BaseException ) : pass [EOL] class lab25 ( BaseException ) : pass [EOL] class lab26 ( BaseException ) : pass [EOL] class lab27 ( BaseException ) : pass [EOL] class lab28 ( BaseException ) : pass [EOL] class lab29 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class FrenchStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_keep_with_s = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = v_4 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab7 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_4 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab7 : pass [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab5 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab5 : pass [EOL] self . cursor = v_2 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] try : [EOL] [comment] [EOL] if self . find_among ( FrenchStemmer . a_0 , [number] ) == [number] : [EOL] raise lab3 ( ) [EOL] raise lab1 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab14 ( ) [EOL] raise lab13 ( ) [EOL] except lab14 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab13 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab6 : pass [EOL] self . cursor = v_4 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( FrenchStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab5 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab4 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab3 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab7 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab9 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab6 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab11 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab11 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab11 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab13 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab12 : pass [EOL] except lab11 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab15 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab14 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if not self . out_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . in_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return False [EOL] return True [EOL] [EOL] def r_i_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . out_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_residual_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( FrenchStemmer . g_keep_with_s , [number] , [number] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_4 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] except lab1 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_4 [EOL] return True [EOL] [EOL] def r_un_double ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( FrenchStemmer . a_8 , [number] ) == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_un_accent ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] try : [EOL] if not self . out_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] v_1 -= [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] if v_1 > [number] : [EOL] return False [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab3 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] try : [EOL] [comment] [EOL] if not self . r_i_verb_suffix ( ) : [EOL] raise lab7 ( ) [EOL] raise lab5 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_7 [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab9 : pass [EOL] except lab8 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . r_residual_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_un_double ( ) : [EOL] raise lab11 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_un_accent ( ) : [EOL] raise lab12 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_10 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_11 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab13 ( ) [EOL] except lab13 : pass [EOL] self . cursor = v_11 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , FrenchStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] __all__ = ( [string] , [string] ) [EOL] [EOL] from . danish_stemmer import DanishStemmer [EOL] from . dutch_stemmer import DutchStemmer [EOL] from . english_stemmer import EnglishStemmer [EOL] from . finnish_stemmer import FinnishStemmer [EOL] from . french_stemmer import FrenchStemmer [EOL] from . german_stemmer import GermanStemmer [EOL] from . hungarian_stemmer import HungarianStemmer [EOL] from . italian_stemmer import ItalianStemmer [EOL] from . norwegian_stemmer import NorwegianStemmer [EOL] from . porter_stemmer import PorterStemmer [EOL] from . portuguese_stemmer import PortugueseStemmer [EOL] from . romanian_stemmer import RomanianStemmer [EOL] from . russian_stemmer import RussianStemmer [EOL] from . spanish_stemmer import SpanishStemmer [EOL] from . swedish_stemmer import SwedishStemmer [EOL] from . turkish_stemmer import TurkishStemmer [EOL] [EOL] _languages = { [string] : DanishStemmer , [string] : DutchStemmer , [string] : EnglishStemmer , [string] : FinnishStemmer , [string] : FrenchStemmer , [string] : GermanStemmer , [string] : HungarianStemmer , [string] : ItalianStemmer , [string] : NorwegianStemmer , [string] : PorterStemmer , [string] : PortugueseStemmer , [string] : RomanianStemmer , [string] : RussianStemmer , [string] : SpanishStemmer , [string] : SwedishStemmer , [string] : TurkishStemmer , } [EOL] [EOL] try : [EOL] import Stemmer [EOL] cext_available = True [EOL] except ImportError : [EOL] cext_available = False [EOL] [EOL] def algorithms ( ) : [EOL] if cext_available : [EOL] return Stemmer . language ( ) [EOL] else : [EOL] return list ( _languages . keys ( ) ) [EOL] [EOL] def stemmer ( lang ) : [EOL] if cext_available : [EOL] return Stemmer . Stemmer ( lang ) [EOL] if lang . lower ( ) in _languages : [EOL] return _languages [ lang . lower ( ) ] ( ) [EOL] else : [EOL] raise KeyError ( [string] % lang ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class HungarianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_10 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_11 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . out_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] self . cursor = v_2 [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if self . find_among ( HungarianStemmer . a_0 , [number] ) == [number] : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] if not self . out_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_v_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_double ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( HungarianStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] return True [EOL] [EOL] def r_undouble ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] c = self . cursor - [number] [EOL] if self . limit_backward > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_instrum ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( HungarianStemmer . a_4 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_v_ending ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case_special ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case_other ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_factive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_plural ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_owned ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_9 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_sing_owner ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_10 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_plur_owner ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_11 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_instrum ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case_special ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case_other ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_factive ( ) : [EOL] raise lab5 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_owned ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_sing_owner ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_plur_owner ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_plural ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_10 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , HungarianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class FinnishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] g_AEI = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_V1 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_V2 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_particle_end = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] B_ending_removed = False [EOL] S_x = [string] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_ending_removed = other . B_ending_removed [EOL] self . S_x = other . S_x [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_1 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_3 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = v_3 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_3 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_particle_etc ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( FinnishStemmer . g_particle_end , [number] , [number] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_possessive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_1 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_3 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_LONG ( self ) : [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_5 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_VI ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] if not self . in_grouping_b ( FinnishStemmer . g_V2 , [number] , [number] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_LONG ( ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] return False [EOL] if not self . out_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . B_ending_removed = True [EOL] return True [EOL] [EOL] def r_other_endings ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p2 : [EOL] return False [EOL] self . cursor = self . I_p2 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_i_plural ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_8 , [number] ) == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_t_plural ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p2 : [EOL] return False [EOL] self . cursor = self . I_p2 [EOL] v_5 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_9 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_5 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_5 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_tidy ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . r_LONG ( ) : [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab0 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping_b ( FinnishStemmer . g_AEI , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if not self . out_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_8 [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] if not self . out_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] self . cursor = self . limit - v_9 [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_9 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] self . S_x = self . slice_to ( self . S_x ) [EOL] if self . S_x == [string] : [EOL] return False [EOL] [comment] [EOL] if not self . eq_v_b ( self . S_x ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . B_ending_removed = False [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_particle_etc ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_possessive ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case_ending ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_endings ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . B_ending_removed : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_i_plural ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_t_plural ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_8 [EOL] except lab5 : pass [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_tidy ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , FinnishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class RomanianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] B_standard_suffix_removed = False [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_standard_suffix_removed = other . B_standard_suffix_removed [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab5 : pass [EOL] self . cursor = v_2 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( RomanianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_step_0 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_combo_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_standard_suffix_removed = True [EOL] self . cursor = self . limit - v_1 [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_standard_suffix_removed = False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_combo_suffix ( ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_standard_suffix_removed = True [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] if not self . out_grouping_b ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_vowel_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_step_0 ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . B_standard_suffix_removed : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_vowel_suffix ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , RomanianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class RussianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_perfective_gerund ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_adjective ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_adjectival ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_adjective ( ) : [EOL] return False [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_reflexive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_verb ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_noun ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_derivational ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_tidy_up ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_perfective_gerund ( ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_reflexive ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_adjectival ( ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] if not self . r_verb ( ) : [EOL] raise lab7 ( ) [EOL] raise lab5 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . r_noun ( ) : [EOL] raise lab1 ( ) [EOL] except lab5 : pass [EOL] except lab2 : pass [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab8 : pass [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_derivational ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_tidy_up ( ) : [EOL] raise lab10 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_10 [EOL] self . limit_backward = v_3 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , RussianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] class BaseStemmer ( object ) : [EOL] def __init__ ( self ) : [EOL] self . set_current ( [string] ) [EOL] self . maxCacheSize = [number] [EOL] self . _cache = { } [EOL] self . _counter = [number] [EOL] [EOL] def set_current ( self , value ) : [EOL] [docstring] [EOL] self . current = value [EOL] self . cursor = [number] [EOL] self . limit = len ( self . current ) [EOL] self . limit_backward = [number] [EOL] self . bra = self . cursor [EOL] self . ket = self . limit [EOL] [EOL] def get_current ( self ) : [EOL] [docstring] [EOL] return self . current [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . current = other . current [EOL] self . cursor = other . cursor [EOL] self . limit = other . limit [EOL] self . limit_backward = other . limit_backward [EOL] self . bra = other . bra [EOL] self . ket = other . ket [EOL] [EOL] def in_grouping ( self , s , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] return False [EOL] self . cursor += [number] [EOL] return True [EOL] [EOL] def in_grouping_b ( self , s , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] return False [EOL] self . cursor -= [number] [EOL] return True [EOL] [EOL] def out_grouping ( self , s , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if ch > max or ch < min : [EOL] self . cursor += [number] [EOL] return True [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] self . cursor += [number] [EOL] return True [EOL] return False [EOL] [EOL] def out_grouping_b ( self , s , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if ch > max or ch < min : [EOL] self . cursor -= [number] [EOL] return True [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] self . cursor -= [number] [EOL] return True [EOL] return False [EOL] [EOL] def in_range ( self , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] self . cursor += [number] [EOL] return True [EOL] [EOL] def in_range_b ( self , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] self . cursor -= [number] [EOL] return True [EOL] [EOL] def out_range ( self , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if not ( ch > max or ch < min ) : [EOL] return False [EOL] self . cursor += [number] [EOL] return True [EOL] [EOL] def out_range_b ( self , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if not ( ch > max or ch < min ) : [EOL] return False [EOL] self . cursor -= [number] [EOL] return True [EOL] [EOL] def eq_s ( self , s_size , s ) : [EOL] if self . limit - self . cursor < s_size : [EOL] return False [EOL] if self . current [ self . cursor : self . cursor + s_size ] != s : [EOL] return False [EOL] self . cursor += s_size [EOL] return True [EOL] [EOL] def eq_s_b ( self , s_size , s ) : [EOL] if self . cursor - self . limit_backward < s_size : [EOL] return False [EOL] if self . current [ self . cursor - s_size : self . cursor ] != s : [EOL] return False [EOL] self . cursor -= s_size [EOL] return True [EOL] [EOL] def eq_v ( self , s ) : [EOL] return self . eq_s ( len ( s ) , s ) [EOL] [EOL] def eq_v_b ( self , s ) : [EOL] return self . eq_s_b ( len ( s ) , s ) [EOL] [EOL] def find_among ( self , v , v_size ) : [EOL] i = [number] [EOL] j = v_size [EOL] [EOL] c = self . cursor [EOL] l = self . limit [EOL] [EOL] common_i = [number] [EOL] common_j = [number] [EOL] [EOL] first_key_inspected = False [EOL] [EOL] while True : [EOL] k = i + ( ( j - i ) >> [number] ) [EOL] diff = [number] [EOL] common = min ( common_i , common_j ) [comment] [EOL] w = v [ k ] [EOL] for i2 in range ( common , w . s_size ) : [EOL] if c + common == l : [EOL] diff = - [number] [EOL] break [EOL] diff = ord ( self . current [ c + common ] ) - ord ( w . s [ i2 ] ) [EOL] if diff != [number] : [EOL] break [EOL] common += [number] [EOL] if diff < [number] : [EOL] j = k [EOL] common_j = common [EOL] else : [EOL] i = k [EOL] common_i = common [EOL] if j - i <= [number] : [EOL] if i > [number] : [EOL] break [comment] [EOL] if j == i : [EOL] break [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if first_key_inspected : [EOL] break [EOL] first_key_inspected = True [EOL] while True : [EOL] w = v [ i ] [EOL] if common_i >= w . s_size : [EOL] self . cursor = c + w . s_size [EOL] if w . method is None : [EOL] return w . result [EOL] method = getattr ( self , w . method ) [EOL] res = method ( ) [EOL] self . cursor = c + w . s_size [EOL] if res : [EOL] return w . result [EOL] i = w . substring_i [EOL] if i < [number] : [EOL] return [number] [EOL] return - [number] [comment] [EOL] [EOL] def find_among_b ( self , v , v_size ) : [EOL] [docstring] [EOL] i = [number] [EOL] j = v_size [EOL] [EOL] c = self . cursor [EOL] lb = self . limit_backward ; [EOL] [EOL] common_i = [number] [EOL] common_j = [number] [EOL] [EOL] first_key_inspected = False [EOL] [EOL] while True : [EOL] k = i + ( ( j - i ) >> [number] ) [EOL] diff = [number] [EOL] common = min ( common_i , common_j ) [EOL] w = v [ k ] [EOL] for i2 in range ( w . s_size - [number] - common , - [number] , - [number] ) : [EOL] if c - common == lb : [EOL] diff = - [number] [EOL] break [EOL] diff = ord ( self . current [ c - [number] - common ] ) - ord ( w . s [ i2 ] ) [EOL] if diff != [number] : [EOL] break [EOL] common += [number] [EOL] if diff < [number] : [EOL] j = k [EOL] common_j = common [EOL] else : [EOL] i = k [EOL] common_i = common [EOL] if j - i <= [number] : [EOL] if i > [number] : [EOL] break [EOL] if j == i : [EOL] break [EOL] if first_key_inspected : [EOL] break [EOL] first_key_inspected = True [EOL] while True : [EOL] w = v [ i ] [EOL] if common_i >= w . s_size : [EOL] self . cursor = c - w . s_size [EOL] if w . method is None : [EOL] return w . result [EOL] method = getattr ( self , w . method ) [EOL] res = method ( ) [EOL] self . cursor = c - w . s_size [EOL] if res : [EOL] return w . result [EOL] i = w . substring_i [EOL] if i < [number] : [EOL] return [number] [EOL] return - [number] [comment] [EOL] [EOL] def replace_s ( self , c_bra , c_ket , s ) : [EOL] [docstring] [EOL] adjustment = len ( s ) - ( c_ket - c_bra ) [EOL] self . current = self . current [ [number] : c_bra ] + s + self . current [ c_ket : ] [EOL] self . limit += adjustment [EOL] if self . cursor >= c_ket : [EOL] self . cursor += adjustment [EOL] elif self . cursor > c_bra : [EOL] self . cursor = c_bra [EOL] return adjustment [EOL] [EOL] def slice_check ( self ) : [EOL] if self . bra < [number] or self . bra > self . ket or self . ket > self . limit or self . limit > len ( self . current ) : [EOL] return False [EOL] return True [EOL] [EOL] def slice_from ( self , s ) : [EOL] [docstring] [EOL] result = False [EOL] if self . slice_check ( ) : [EOL] self . replace_s ( self . bra , self . ket , s ) [EOL] result = True [EOL] return result [EOL] [EOL] def slice_del ( self ) : [EOL] return self . slice_from ( [string] ) [EOL] [EOL] def insert ( self , c_bra , c_ket , s ) : [EOL] [docstring] [EOL] adjustment = self . replace_s ( c_bra , c_ket , s ) [EOL] if c_bra <= self . bra : [EOL] self . bra += adjustment [EOL] if c_bra <= self . ket : [EOL] self . ket += adjustment [EOL] [EOL] def slice_to ( self , s ) : [EOL] [docstring] [EOL] result = [string] [EOL] if self . slice_check ( ) : [EOL] result = self . current [ self . bra : self . ket ] [EOL] return result [EOL] [EOL] def assign_to ( self , s ) : [EOL] [docstring] [EOL] return self . current [ [number] : self . limit ] [EOL] [EOL] def _stem_word ( self , word ) : [EOL] cache = self . _cache . get ( word ) [EOL] if cache is None : [EOL] self . set_current ( word ) [EOL] self . _stem ( ) [EOL] result = self . get_current ( ) [EOL] self . _cache [ word ] = [ result , self . _counter ] [EOL] else : [EOL] cache [ [number] ] = self . _counter [EOL] result = cache [ [number] ] [EOL] self . _counter += [number] [EOL] return result [EOL] [EOL] def _clear_cache ( self ) : [EOL] removecount = int ( len ( self . _cache ) - self . maxCacheSize * [number] / [number] ) [EOL] oldcaches = sorted ( self . _cache . items ( ) , key = lambda cache : cache [ [number] ] [ [number] ] ) [ [number] : removecount ] [EOL] for key , value in oldcaches : [EOL] del self . _cache [ key ] [EOL] [EOL] def stemWord ( self , word ) : [EOL] result = self . _stem_word ( word ) [EOL] if len ( self . _cache ) > self . maxCacheSize : [EOL] self . _clear_cache ( ) [EOL] return result [EOL] [EOL] def stemWords ( self , words ) : [EOL] result = [ self . _stem_word ( word ) for word in words ] [EOL] if len ( self . _cache ) > self . maxCacheSize : [EOL] self . _clear_cache ( ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] class Among ( object ) : [EOL] def __init__ ( self , s , substring_i , result , method = None ) : [EOL] [docstring] [EOL] self . s_size = len ( s ) [EOL] self . s = s [EOL] self . substring_i = substring_i [EOL] self . result = result [EOL] self . method = method [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class SpanishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( SpanishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_attached_pronoun ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( SpanishStemmer . a_1 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab3 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_y_verb_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_4 [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_residual_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_9 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_attached_pronoun ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_4 [EOL] try : [EOL] [comment] [EOL] if not self . r_y_verb_suffix ( ) : [EOL] raise lab5 ( ) [EOL] raise lab3 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_residual_suffix ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_5 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_6 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , SpanishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class DutchStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_I = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_j = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] B_e_found = False [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . B_e_found = other . B_e_found [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( DutchStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] self . cursor = v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab3 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab9 : pass [EOL] self . cursor = v_5 [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = v_5 [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_4 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not self . I_p1 < [number] : [EOL] raise lab4 ( ) [EOL] self . I_p1 = [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( DutchStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_undouble ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( DutchStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_e_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_e_found = False [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( DutchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . B_e_found = True [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_en_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( DutchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DutchStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_en_ending ( ) : [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab0 ( ) [EOL] if not self . out_grouping_b ( DutchStemmer . g_v_j , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_e_ending ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_en_ending ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DutchStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] raise lab4 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] raise lab4 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_e_ending ( ) : [EOL] raise lab4 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . B_e_found : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping_b ( DutchStemmer . g_v_I , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( DutchStemmer . a_5 , [number] ) == [number] : [EOL] raise lab9 ( ) [EOL] if not self . out_grouping_b ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab9 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_4 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , DutchStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class NorwegianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( NorwegianStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( NorwegianStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_main_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( NorwegianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( NorwegianStemmer . g_s_ending , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] if not self . out_grouping_b ( NorwegianStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_consonant_pair ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( NorwegianStemmer . a_1 , [number] ) == [number] : [EOL] self . limit_backward = v_3 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_3 [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_other_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( NorwegianStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_main_suffix ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , NorwegianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class TurkishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_10 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_11 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_12 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_13 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_14 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_15 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_16 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_17 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_18 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_19 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_20 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_21 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_22 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_23 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_vowel = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_U = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel1 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel2 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel3 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel4 = [ [number] ] [EOL] [EOL] g_vowel5 = [ [number] ] [EOL] [EOL] g_vowel6 = [ [number] ] [EOL] [EOL] B_continue_stemming_noun_suffixes = False [EOL] I_strlen = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_continue_stemming_noun_suffixes = other . B_continue_stemming_noun_suffixes [EOL] self . I_strlen = other . I_strlen [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_check_vowel_harmony ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel1 , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = self . limit - v_4 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_4 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab3 ( ) [EOL] self . cursor -= [number] [EOL] except lab4 : pass [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel2 , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_5 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab6 ( ) [EOL] self . cursor -= [number] [EOL] except lab7 : pass [EOL] raise lab2 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel3 , [number] , [number] ) : [EOL] raise lab11 ( ) [EOL] self . cursor = self . limit - v_6 [EOL] raise lab10 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_6 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab9 ( ) [EOL] self . cursor -= [number] [EOL] except lab10 : pass [EOL] raise lab2 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab12 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel4 , [number] , [number] ) : [EOL] raise lab14 ( ) [EOL] self . cursor = self . limit - v_7 [EOL] raise lab13 ( ) [EOL] except lab14 : pass [EOL] self . cursor = self . limit - v_7 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab12 ( ) [EOL] self . cursor -= [number] [EOL] except lab13 : pass [EOL] raise lab2 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab15 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel5 , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] self . cursor = self . limit - v_8 [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_8 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab15 ( ) [EOL] self . cursor -= [number] [EOL] except lab16 : pass [EOL] raise lab2 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab18 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel6 , [number] , [number] ) : [EOL] raise lab20 ( ) [EOL] self . cursor = self . limit - v_9 [EOL] raise lab19 ( ) [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_9 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab18 ( ) [EOL] self . cursor -= [number] [EOL] except lab19 : pass [EOL] raise lab2 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab21 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel5 , [number] , [number] ) : [EOL] raise lab23 ( ) [EOL] self . cursor = self . limit - v_10 [EOL] raise lab22 ( ) [EOL] except lab23 : pass [EOL] self . cursor = self . limit - v_10 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab21 ( ) [EOL] self . cursor -= [number] [EOL] except lab22 : pass [EOL] raise lab2 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel6 , [number] , [number] ) : [EOL] raise lab25 ( ) [EOL] self . cursor = self . limit - v_11 [EOL] raise lab24 ( ) [EOL] except lab25 : pass [EOL] self . cursor = self . limit - v_11 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab24 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_1 [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_n_consonant ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_s_consonant ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_y_consonant ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_U_vowel ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_possessives ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_0 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_U_vowel ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_sU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_s_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_lArI ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_1 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nUn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_3 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_n_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_4 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_5 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_DA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_6 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ndA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_7 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_DAn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_8 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ndAn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_9 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ylA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_10 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ki ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ncA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_11 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_n_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yUm ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_12 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_sUn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_13 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yUz ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_14 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_sUnUz ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_15 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_lAr ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_16 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nUz ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_17 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_DUr ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_18 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_cAsInA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_19 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yDU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_20 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ysA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_21 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ymUs_ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_22 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yken ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_stem_nominal_verb_suffixes ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] self . B_continue_stemming_noun_suffixes = True [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_2 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yDU ( ) : [EOL] raise lab4 ( ) [EOL] raise lab2 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_2 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ysA ( ) : [EOL] raise lab5 ( ) [EOL] raise lab2 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . r_mark_yken ( ) : [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_cAsInA ( ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUnUz ( ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab9 ( ) [EOL] raise lab7 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUm ( ) : [EOL] raise lab10 ( ) [EOL] raise lab7 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUn ( ) : [EOL] raise lab11 ( ) [EOL] raise lab7 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUz ( ) : [EOL] raise lab12 ( ) [EOL] raise lab7 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_3 [EOL] except lab7 : pass [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] raise lab6 ( ) [EOL] raise lab0 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab13 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_DUr ( ) : [EOL] raise lab16 ( ) [EOL] raise lab15 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_5 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yDU ( ) : [EOL] raise lab17 ( ) [EOL] raise lab15 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_5 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ysA ( ) : [EOL] raise lab18 ( ) [EOL] raise lab15 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] except lab14 : pass [EOL] [comment] [EOL] self . B_continue_stemming_noun_suffixes = False [EOL] raise lab0 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_nUz ( ) : [EOL] raise lab19 ( ) [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yDU ( ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_mark_ysA ( ) : [EOL] raise lab19 ( ) [EOL] except lab20 : pass [EOL] raise lab0 ( ) [EOL] except lab19 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUnUz ( ) : [EOL] raise lab24 ( ) [EOL] raise lab23 ( ) [EOL] except lab24 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUz ( ) : [EOL] raise lab25 ( ) [EOL] raise lab23 ( ) [EOL] except lab25 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUn ( ) : [EOL] raise lab26 ( ) [EOL] raise lab23 ( ) [EOL] except lab26 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . r_mark_yUm ( ) : [EOL] raise lab22 ( ) [EOL] except lab23 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab27 ( ) [EOL] except lab27 : pass [EOL] raise lab0 ( ) [EOL] except lab22 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_DUr ( ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUnUz ( ) : [EOL] raise lab30 ( ) [EOL] raise lab29 ( ) [EOL] except lab30 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab31 ( ) [EOL] raise lab29 ( ) [EOL] except lab31 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUm ( ) : [EOL] raise lab32 ( ) [EOL] raise lab29 ( ) [EOL] except lab32 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUn ( ) : [EOL] raise lab33 ( ) [EOL] raise lab29 ( ) [EOL] except lab33 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUz ( ) : [EOL] raise lab34 ( ) [EOL] raise lab29 ( ) [EOL] except lab34 : pass [EOL] self . cursor = self . limit - v_10 [EOL] except lab29 : pass [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab28 ( ) [EOL] except lab28 : pass [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_stem_suffix_chain_before_ki ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_ki ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_DA ( ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab5 ( ) [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_nUn ( ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab13 ( ) [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab14 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab14 ( ) [EOL] except lab14 : pass [EOL] raise lab9 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] except lab8 : pass [EOL] raise lab0 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_ndA ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab16 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab15 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab17 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_11 [EOL] raise lab18 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_11 [EOL] raise lab18 ( ) [EOL] except lab18 : pass [EOL] raise lab15 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] return False [EOL] except lab15 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_stem_noun_suffixes ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_ncA ( ) : [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_4 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab9 ( ) [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab10 ( ) [EOL] except lab10 : pass [EOL] raise lab5 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] except lab4 : pass [EOL] raise lab0 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ndA ( ) : [EOL] raise lab13 ( ) [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . r_mark_nA ( ) : [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab15 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_8 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab16 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab17 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab17 ( ) [EOL] except lab17 : pass [EOL] raise lab14 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] raise lab11 ( ) [EOL] except lab14 : pass [EOL] raise lab0 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ndAn ( ) : [EOL] raise lab20 ( ) [EOL] raise lab19 ( ) [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] if not self . r_mark_nU ( ) : [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab22 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_12 [EOL] raise lab23 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_12 [EOL] raise lab23 ( ) [EOL] except lab23 : pass [EOL] raise lab21 ( ) [EOL] except lab22 : pass [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab18 ( ) [EOL] except lab21 : pass [EOL] raise lab0 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_DAn ( ) : [EOL] raise lab24 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_13 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_14 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab27 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_15 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_15 [EOL] raise lab28 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_15 [EOL] raise lab28 ( ) [EOL] except lab28 : pass [EOL] raise lab26 ( ) [EOL] except lab27 : pass [EOL] self . cursor = self . limit - v_14 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab29 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_16 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_16 [EOL] raise lab30 ( ) [EOL] except lab30 : pass [EOL] raise lab26 ( ) [EOL] except lab29 : pass [EOL] self . cursor = self . limit - v_14 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_13 [EOL] raise lab25 ( ) [EOL] except lab26 : pass [EOL] except lab25 : pass [EOL] raise lab0 ( ) [EOL] except lab24 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_17 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_nUn ( ) : [EOL] raise lab33 ( ) [EOL] raise lab32 ( ) [EOL] except lab33 : pass [EOL] self . cursor = self . limit - v_17 [EOL] [comment] [EOL] if not self . r_mark_ylA ( ) : [EOL] raise lab31 ( ) [EOL] except lab32 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_18 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_19 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab36 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] raise lab36 ( ) [EOL] raise lab35 ( ) [EOL] except lab36 : pass [EOL] self . cursor = self . limit - v_19 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_20 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab39 ( ) [EOL] raise lab38 ( ) [EOL] except lab39 : pass [EOL] self . cursor = self . limit - v_20 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab37 ( ) [EOL] except lab38 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_21 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_21 [EOL] raise lab40 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_21 [EOL] raise lab40 ( ) [EOL] except lab40 : pass [EOL] raise lab35 ( ) [EOL] except lab37 : pass [EOL] self . cursor = self . limit - v_19 [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_18 [EOL] raise lab34 ( ) [EOL] except lab35 : pass [EOL] except lab34 : pass [EOL] raise lab0 ( ) [EOL] except lab31 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab41 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab0 ( ) [EOL] except lab41 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] raise lab42 ( ) [EOL] raise lab0 ( ) [EOL] except lab42 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_22 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_DA ( ) : [EOL] raise lab45 ( ) [EOL] raise lab44 ( ) [EOL] except lab45 : pass [EOL] self . cursor = self . limit - v_22 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yU ( ) : [EOL] raise lab46 ( ) [EOL] raise lab44 ( ) [EOL] except lab46 : pass [EOL] self . cursor = self . limit - v_22 [EOL] [comment] [EOL] if not self . r_mark_yA ( ) : [EOL] raise lab43 ( ) [EOL] except lab44 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_23 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_24 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab49 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_25 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_25 [EOL] raise lab50 ( ) [EOL] except lab50 : pass [EOL] raise lab48 ( ) [EOL] except lab49 : pass [EOL] self . cursor = self . limit - v_24 [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_23 [EOL] raise lab47 ( ) [EOL] except lab48 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_23 [EOL] raise lab47 ( ) [EOL] except lab47 : pass [EOL] raise lab0 ( ) [EOL] except lab43 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_26 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab52 ( ) [EOL] raise lab51 ( ) [EOL] except lab52 : pass [EOL] self . cursor = self . limit - v_26 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] return False [EOL] except lab51 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_27 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_27 [EOL] raise lab53 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_27 [EOL] raise lab53 ( ) [EOL] except lab53 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_post_process_last_consonants ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( TurkishStemmer . a_23 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_append_U_to_stems_ending_with_d_or_g ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab3 ( ) [EOL] self . cursor -= [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] self . cursor = self . limit - v_8 [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_8 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab8 ( ) [EOL] self . cursor -= [number] [EOL] except lab9 : pass [EOL] [comment] [EOL] try : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] self . cursor = self . limit - v_11 [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_11 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab13 ( ) [EOL] self . cursor -= [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_12 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab13 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] v_13 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_14 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] self . cursor = self . limit - v_14 [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] self . cursor = self . limit - v_14 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] v_15 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_15 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_13 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] except lab2 : pass [EOL] return True [EOL] [EOL] def r_more_than_one_syllable_word ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] v_2 = [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] v_2 -= [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] if v_2 > [number] : [EOL] return False [EOL] self . cursor = v_1 [EOL] return True [EOL] [EOL] def r_is_reserved_word ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] v_2 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_strlen = [number] ; [EOL] [comment] [EOL] if not self . I_strlen == self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_4 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] self . I_strlen = [number] [EOL] [comment] [EOL] if not self . I_strlen == self . limit : [EOL] return False [EOL] self . cursor = v_4 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_is_reserved_word ( ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_append_U_to_stems_ending_with_d_or_g ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_post_process_last_consonants ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . r_more_than_one_syllable_word ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_stem_nominal_verb_suffixes ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . B_continue_stemming_noun_suffixes : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_stem_noun_suffixes ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , TurkishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL] class lab22 ( BaseException ) : pass [EOL] class lab23 ( BaseException ) : pass [EOL] class lab24 ( BaseException ) : pass [EOL] class lab25 ( BaseException ) : pass [EOL] class lab26 ( BaseException ) : pass [EOL] class lab27 ( BaseException ) : pass [EOL] class lab28 ( BaseException ) : pass [EOL] class lab29 ( BaseException ) : pass [EOL] class lab30 ( BaseException ) : pass [EOL] class lab31 ( BaseException ) : pass [EOL] class lab32 ( BaseException ) : pass [EOL] class lab33 ( BaseException ) : pass [EOL] class lab34 ( BaseException ) : pass [EOL] class lab35 ( BaseException ) : pass [EOL] class lab36 ( BaseException ) : pass [EOL] class lab37 ( BaseException ) : pass [EOL] class lab38 ( BaseException ) : pass [EOL] class lab39 ( BaseException ) : pass [EOL] class lab40 ( BaseException ) : pass [EOL] class lab41 ( BaseException ) : pass [EOL] class lab42 ( BaseException ) : pass [EOL] class lab43 ( BaseException ) : pass [EOL] class lab44 ( BaseException ) : pass [EOL] class lab45 ( BaseException ) : pass [EOL] class lab46 ( BaseException ) : pass [EOL] class lab47 ( BaseException ) : pass [EOL] class lab48 ( BaseException ) : pass [EOL] class lab49 ( BaseException ) : pass [EOL] class lab50 ( BaseException ) : pass [EOL] class lab51 ( BaseException ) : pass [EOL] class lab52 ( BaseException ) : pass [EOL] class lab53 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class DanishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p1 = [number] [EOL] S_ch = [string] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p1 = other . I_p1 [EOL] self . S_ch = other . S_ch [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( DanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( DanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_main_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DanishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( DanishStemmer . g_s_ending , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_consonant_pair ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( DanishStemmer . a_1 , [number] ) == [number] : [EOL] self . limit_backward = v_3 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_3 [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_other_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DanishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_3 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_3 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_4 [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_undouble ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . out_grouping_b ( DanishStemmer . g_v , [number] , [number] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] self . S_ch = self . slice_to ( self . S_ch ) [EOL] if self . S_ch == [string] : [EOL] return False [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] if not self . eq_v_b ( self . S_ch ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_main_suffix ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , DanishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class EnglishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_10 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_WXY = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_valid_LI = [ [number] , [number] , [number] ] [EOL] [EOL] B_Y_found = False [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_Y_found = other . B_Y_found [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_Y_found = False [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_5 [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_5 [EOL] if self . cursor >= self . limit : [EOL] raise lab5 ( ) [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_4 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = v_3 [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if self . find_among ( EnglishStemmer . a_0 , [number] ) == [number] : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] return True [EOL] [EOL] def r_shortv ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v_WXY , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if self . cursor > self . limit_backward : [EOL] return False [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_1a ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor - [number] [EOL] if self . limit_backward > c or c > self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor = c [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_1b ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor != self . I_p1 : [EOL] return False [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] return False [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] return True [EOL] [EOL] def r_Step_1c ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if self . cursor > self . limit_backward : [EOL] raise lab2 ( ) [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_2 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( EnglishStemmer . g_valid_LI , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_3 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_4 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_5 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] raise lab2 ( ) [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_exception2 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( EnglishStemmer . a_9 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if self . cursor > self . limit_backward : [EOL] return False [EOL] return True [EOL] [EOL] def r_exception1 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( EnglishStemmer . a_10 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor < self . limit : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . B_Y_found : [EOL] return False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_2 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_exception1 ( ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] try : [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] raise lab3 ( ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab5 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_4 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1a ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_exception2 ( ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1b ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1c ( ) : [EOL] raise lab10 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_2 ( ) : [EOL] raise lab11 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_3 ( ) : [EOL] raise lab12 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_4 ( ) : [EOL] raise lab13 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_5 ( ) : [EOL] raise lab14 ( ) [EOL] except lab14 : pass [EOL] self . cursor = self . limit - v_12 [EOL] except lab7 : pass [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_13 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab15 ( ) [EOL] except lab15 : pass [EOL] self . cursor = v_13 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , EnglishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class SwedishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( SwedishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SwedishStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_main_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SwedishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( SwedishStemmer . g_s_ending , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_consonant_pair ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( SwedishStemmer . a_1 , [number] ) == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_other_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SwedishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_main_suffix ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , SwedishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class PortugueseStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( PortugueseStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( PortugueseStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab3 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_residual_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_residual_form ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . r_residual_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_residual_form ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_9 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_10 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_10 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , PortugueseStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import logging [EOL] import subprocess [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] from io import StringIO [EOL] else : [EOL] try : [EOL] from cStringIO import StringIO [EOL] except ImportError : [EOL] from StringIO import StringIO [EOL] assert StringIO [EOL] [EOL] [EOL] from pylint . __pkginfo__ import numversion [EOL] [EOL] from process import spawn [EOL] [EOL] PIPE = subprocess . PIPE [EOL] [EOL] [EOL] class PyLinter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , rcfile ) : [EOL] self . filename = filename [EOL] self . rcfile = rcfile [EOL] self . output = None [EOL] [EOL] self . execute ( ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] if numversion < ( [number] , [number] , [number] ) : [EOL] args = [string] . split ( [string] ) [EOL] else : [EOL] args = [string] . split ( [string] ) [EOL] [EOL] if self . rcfile : [EOL] args . append ( [string] . format ( os . path . expanduser ( self . rcfile ) ) ) [EOL] [EOL] args . append ( self . filename ) [EOL] args = [ sys . executable , [string] , [string] ] + args [EOL] [EOL] proc = spawn ( args , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] if proc is None : [EOL] return { [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] [EOL] self . output , _ = proc . communicate ( ) [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] self . output = self . output . decode ( [string] ) [EOL] [EOL] def parse_errors ( self ) : [EOL] [docstring] [EOL] [EOL] errors = { [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] data = self . output [EOL] [EOL] for error in data . splitlines ( ) : [EOL] if [string] in error : [EOL] _ , module = error . split ( [string] ) [EOL] if module not in self . filename : [EOL] continue [EOL] else : [EOL] offset = None [EOL] try : [EOL] if numversion >= ( [number] , [number] , [number] ) : [EOL] code , line , offset , message = error . split ( [string] , [number] ) [EOL] else : [EOL] code , line , message = error . split ( [string] , [number] ) [EOL] except ValueError as exception : [EOL] logging . debug ( [string] [string] . format ( exception ) ) [EOL] logging . debug ( [string] [string] . format ( error ) ) [EOL] continue [EOL] [EOL] if numversion < ( [number] , [number] , [number] ) : [EOL] try : [EOL] line , offset = line . split ( [string] ) [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] errors [ self . _map_code ( code ) [ [number] ] ] . append ( { [string] : int ( line ) , [string] : offset , [string] : self . _map_code ( code ) [ [number] ] , [string] : [string] . format ( self . _map_code ( code ) [ [number] ] , message ) } ) [EOL] [EOL] return errors [EOL] [EOL] def _map_code ( self , code ) : [EOL] [docstring] [EOL] [EOL] mapping = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return ( mapping [ code [ [number] ] ] , code [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Optional , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import re [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . dirname ( __file__ ) ) [EOL] [EOL] import _ast [comment] [EOL] [EOL] import pycodestyle as pep8 [comment] [EOL] import pyflakes . checker as pyflakes [comment] [EOL] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] def cmp_to_key ( mycmp ) : [EOL] [docstring] [EOL] [EOL] class K ( object ) : [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , obj , * args ) : [EOL] self . obj = obj [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) < [number] [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) > [number] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) == [number] [EOL] [EOL] def __le__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) <= [number] [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) >= [number] [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) != [number] [EOL] [EOL] def __hash__ ( self ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] return K [EOL] else : [EOL] from functools import cmp_to_key [EOL] [EOL] [EOL] pyflakes . messages . Message . __str__ = ( lambda self : self . message % self . message_args ) [EOL] [EOL] [EOL] class LintError ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , level , message , message_args , ** kwargs ) : [EOL] self . lineno = loc [EOL] self . level = level [EOL] self . message = message [EOL] self . message_args = message_args [EOL] [EOL] for k , v in kwargs . items ( ) : [EOL] setattr ( self , k , v ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] [EOL] return self . message % self . message_args [EOL] [EOL] [EOL] class Pep8Error ( LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text ) : [EOL] super ( Pep8Error , self ) . __init__ ( filename , loc , [string] , [string] , ( code , text ) , offset = offset , text = text ) [EOL] [EOL] [EOL] class Pep8Warning ( LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text ) : [EOL] super ( Pep8Warning , self ) . __init__ ( filename , loc , [string] , [string] , ( code , text ) , offset = offset , text = text ) [EOL] [EOL] [EOL] class PythonError ( LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , text ) : [EOL] super ( PythonError , self ) . __init__ ( filename , loc , [string] , [string] , ( text , ) , text = text ) [EOL] [EOL] [EOL] class OffsetError ( LintError ) : [EOL] [EOL] def __init__ ( self , filename , loc , text , offset ) : [EOL] super ( OffsetError , self ) . __init__ ( filename , loc , [string] , [string] , ( text , ) , offset = offset + [number] , text = text ) [EOL] [EOL] [EOL] class Linter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [EOL] self . enabled = False [EOL] [EOL] def pyflakes_check ( self , code , filename , ignore = None ) : [EOL] [docstring] [EOL] [EOL] class FakeLoc : [EOL] lineno = [number] [EOL] [EOL] try : [EOL] code = code . encode ( [string] ) + [string] [EOL] tree = compile ( code , filename or [string] , [string] , _ast . PyCF_ONLY_AST ) [EOL] except ( SyntaxError , IndentationError ) : [EOL] return self . _handle_syntactic_error ( code , filename ) [EOL] except ValueError as error : [EOL] return [ PythonError ( filename , FakeLoc ( ) , error . args [ [number] ] ) ] [EOL] else : [EOL] [comment] [EOL] w = pyflakes . Checker ( tree , filename , ignore ) [EOL] [EOL] return w . messages [EOL] [EOL] def pep8_check ( self , code , filename , rcfile , ignore , max_line_length ) : [EOL] [docstring] [EOL] [EOL] messages = [ ] [EOL] _lines = code . split ( [string] ) [EOL] [EOL] if _lines : [EOL] class FakeCol : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , line_number ) : [EOL] self . lineno = line_number [EOL] [EOL] class SublimeLinterReport ( pep8 . BaseReport ) : [EOL] [docstring] [EOL] [EOL] def error ( self , line_number , offset , text , check ) : [EOL] [docstring] [EOL] col = FakeCol ( line_number ) [EOL] code = text [ : [number] ] [EOL] message = text [ [number] : ] [EOL] [EOL] if self . _ignore_code ( code ) : [EOL] return [EOL] [EOL] if code in self . counters : [EOL] self . counters [ code ] += [number] [EOL] else : [EOL] self . counters [ code ] = [number] [EOL] self . messages [ code ] = message [EOL] [EOL] if code in self . expected : [EOL] return [EOL] [EOL] self . file_errors += [number] [EOL] self . total_errors += [number] [EOL] [EOL] pep8_error = code . startswith ( [string] ) [EOL] klass = Pep8Error if pep8_error else Pep8Warning [EOL] messages . append ( klass ( filename , col , offset , code , message ) ) [EOL] [EOL] return code [EOL] [EOL] params = { [string] : SublimeLinterReport } [EOL] if not rcfile : [EOL] _ignore = ignore + pep8 . DEFAULT_IGNORE . split ( [string] ) [EOL] params [ [string] ] = _ignore [EOL] else : [EOL] params [ [string] ] = os . path . expanduser ( rcfile ) [EOL] [EOL] options = pep8 . StyleGuide ( ** params ) . options [EOL] if not rcfile : [EOL] options . max_line_length = max_line_length [EOL] [EOL] good_lines = [ l + [string] for l in _lines ] [EOL] good_lines [ - [number] ] = good_lines [ - [number] ] . rstrip ( [string] ) [EOL] [EOL] if not good_lines [ - [number] ] : [EOL] good_lines = good_lines [ : - [number] ] [EOL] [EOL] pep8 . Checker ( filename , good_lines , options = options ) . check_all ( ) [EOL] [EOL] return messages [EOL] [EOL] def run_linter ( self , settings , code , filename ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] [EOL] if settings . get ( [string] , True ) : [EOL] check_params = { [string] : settings . get ( [string] , [ ] ) , [string] : settings . get ( [string] , pep8 . MAX_LINE_LENGTH ) } [EOL] errors . extend ( self . pep8_check ( code , filename , settings . get ( [string] ) , ** check_params ) ) [EOL] [EOL] pyflakes_ignore = settings . get ( [string] , None ) [EOL] pyflakes_disabled = settings . get ( [string] , False ) [EOL] explicit_ignore = settings . get ( [string] , [ ] ) [EOL] [EOL] if not pyflakes_disabled and not settings . get ( [string] ) : [EOL] errors . extend ( self . pyflakes_check ( code , filename , pyflakes_ignore ) ) [EOL] [EOL] return self . parse_errors ( errors , explicit_ignore ) [EOL] [EOL] def sort_errors ( self , errors ) : [EOL] [docstring] [EOL] errors . sort ( key = cmp_to_key ( lambda a , b : a . lineno < b . lineno ) ) [EOL] [EOL] def prepare_error_level ( self , error ) : [EOL] [docstring] [EOL] return [string] if not hasattr ( error , [string] ) else error . level [EOL] [EOL] def parse_errors ( self , errors , explicit_ignore ) : [EOL] [docstring] [EOL] [EOL] errors_list = [ ] [EOL] if errors is None : [EOL] return errors_list [EOL] [EOL] errors . sort ( key = cmp_to_key ( lambda a , b : a . lineno < b . lineno ) ) [EOL] for error in errors : [EOL] error_level = [string] if not hasattr ( error , [string] ) else error . level [EOL] message = error . message . capitalize ( ) [EOL] [EOL] offset = None [EOL] if hasattr ( error , [string] ) : [EOL] offset = error . offset [EOL] elif hasattr ( error , [string] ) : [EOL] offset = error . col [EOL] [EOL] error_data = { [string] : False , [string] : error_level , [string] : error . lineno , [string] : offset , [string] : message , [string] : str ( error ) } [EOL] [EOL] if isinstance ( error , ( Pep8Error , Pep8Warning , OffsetError ) ) : [EOL] error_data [ [string] ] = True [EOL] errors_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . RedefinedWhileUnused , pyflakes . messages . RedefinedInListComp , pyflakes . messages . UndefinedName , pyflakes . messages . UndefinedExport , pyflakes . messages . UndefinedLocal , pyflakes . messages . Redefined , pyflakes . messages . UnusedVariable ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] regex = ( [string] [string] . format ( re . escape ( error . message_args [ [number] ] ) ) ) [EOL] error_data [ [string] ] = len ( error . message_args [ [number] ] ) [EOL] error_data [ [string] ] = regex [EOL] errors_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . ImportShadowedByLoopVar ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] errors_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . UnusedImport , pyflakes . messages . ImportStarUsed ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] if isinstance ( error , pyflakes . messages . ImportStarUsed ) : [EOL] word = [string] [EOL] else : [EOL] word = error . message_args [ [number] ] [EOL] [EOL] linematch = [string] [EOL] r = [string] . format ( re . escape ( word ) ) [EOL] error_data [ [string] ] = r [EOL] error_data [ [string] ] = linematch [EOL] errors_list . append ( error_data ) [EOL] elif ( isinstance ( error , pyflakes . messages . DuplicateArgument ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] errors_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . LateFutureImport ) : [EOL] pass [EOL] elif isinstance ( error , PythonError ) : [EOL] print ( error ) [EOL] else : [EOL] print ( [string] , type ( error ) ) [EOL] [EOL] return errors_list [EOL] [EOL] def _handle_syntactic_error ( self , code , filename ) : [EOL] [docstring] [EOL] [EOL] value = sys . exc_info ( ) [ [number] ] [EOL] msg = value . args [ [number] ] [EOL] [EOL] lineno , offset , text = value . lineno , value . offset , value . text [EOL] [EOL] if text is None : [comment] [EOL] if msg . startswith ( [string] ) : [EOL] arg = msg . split ( [string] , [number] ) [ [number] ] . split ( [string] , [number] ) [ [number] ] . strip ( [string] ) [EOL] error = pyflakes . messages . DuplicateArgument ( filename , lineno , arg ) [EOL] else : [EOL] error = PythonError ( filename , value , msg ) [EOL] else : [EOL] line = text . splitlines ( ) [ - [number] ] [EOL] [EOL] if offset is not None : [EOL] offset = offset - ( len ( text ) - len ( line ) ) [EOL] [EOL] if offset is not None : [EOL] error = OffsetError ( filename , value , msg , offset ) [EOL] else : [EOL] error = PythonError ( filename , value , msg ) [EOL] [EOL] error . lineno = lineno [EOL] [EOL] return [ error ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $builtins.int$ 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import pydocstyle [EOL] [EOL] class PEP257 ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , filename , ignore ) : [EOL] self . code = code [EOL] self . filename = filename [EOL] self . ignore = [ ] if ignore is None else ignore [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] try : [EOL] for error in pydocstyle . ConventionChecker ( ) . check_source ( self . code , self . filename ) : [EOL] error_code = getattr ( error , [string] , None ) [EOL] if error_code is not None and error_code not in self . ignore : [comment] [EOL] errors . append ( self . _convert ( error ) ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] [EOL] return errors [EOL] [EOL] def _convert ( self , error ) : [EOL] [docstring] [EOL] [EOL] return { [string] : [string] , [string] : error . line , [string] : [number] , [string] : error . code , [string] : [string] . format ( error . code , error . message . split ( [string] , [number] ) [ [number] ] ) , [string] : [string] , [string] : True } [EOL] except SyntaxError : [EOL] [comment] [EOL] class PEP257 ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , filename , ignore ) : [EOL] pass [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import re [EOL] import _ast [EOL] [EOL] from linting import linter [EOL] import pyflakes . checker as pyflakes [EOL] [EOL] [EOL] pyflakes . messages . Message . __str__ = ( lambda self : self . message % self . message_args ) [EOL] [EOL] [EOL] class PyFlakesError ( pyflakes . messages . Message ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , level , message , message_args , ** kwargs ) : [EOL] super ( PyFlakesError , self ) . __init__ ( filename , loc ) [EOL] [EOL] self . level = level [EOL] self . message = message [EOL] self . message_args = message_args [EOL] [EOL] [EOL] class PyFlakesLinter ( linter . Linter ) : [EOL] [docstring] [EOL] [EOL] def lint ( self , settings , code , filename ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] pyflakes_ignore = settings . get ( [string] , None ) [EOL] pyflakes_disabled = settings . get ( [string] , False ) [EOL] explicit_ignore = settings . get ( [string] , [ ] ) [EOL] [EOL] if not pyflakes_disabled and not settings . get ( [string] ) : [EOL] errors . extend ( self . check ( code , filename , pyflakes_ignore ) ) [EOL] [EOL] return self . parse ( errors , explicit_ignore ) [EOL] [EOL] def check ( self , code , filename , ignore = None ) : [EOL] [docstring] [EOL] [EOL] class FakeLoc : [EOL] lineno = [number] [EOL] [EOL] try : [EOL] fname = [string] [EOL] if filename is not None : [EOL] fname = filename . encode ( [string] ) or [string] [EOL] code = code . encode ( [string] ) + [string] [EOL] tree = compile ( code , fname , [string] , _ast . PyCF_ONLY_AST ) [EOL] except ( SyntaxError , IndentationError ) : [EOL] return self . _handle_syntactic_error ( code , filename ) [EOL] except ValueError as error : [EOL] return [ PyFlakesError ( filename , FakeLoc ( ) , [string] , error . args [ [number] ] ) , [ ] ] [EOL] else : [EOL] [comment] [EOL] w = pyflakes . Checker ( tree , filename , ignore ) [EOL] [EOL] return w . messages [EOL] [EOL] def parse ( self , errors , explicit_ignore ) : [EOL] [docstring] [EOL] [EOL] error_list = [ ] [EOL] if errors is None : [EOL] return error_list [EOL] [EOL] errors . sort ( key = linter . cmp_to_key ( lambda a , b : a . lineno < b . lineno ) ) [EOL] for error in errors : [EOL] error_level = [string] if not hasattr ( error , [string] ) else error . level [EOL] message = error . message . capitalize ( ) [EOL] [EOL] error_data = { [string] : False , [string] : error_level , [string] : error . lineno , [string] : message , [string] : str ( error ) } [EOL] if hasattr ( error , [string] ) : [EOL] error_data [ [string] ] = error . offset [EOL] elif hasattr ( error , [string] ) : [EOL] error_data [ [string] ] = error . col [EOL] [EOL] if ( isinstance ( error , ( linter . OffsetError ) ) ) : [EOL] error_data [ [string] ] = True [EOL] error_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . RedefinedWhileUnused , pyflakes . messages . RedefinedInListComp , pyflakes . messages . UndefinedName , pyflakes . messages . UndefinedExport , pyflakes . messages . UndefinedLocal , pyflakes . messages . UnusedVariable ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] [EOL] error_data [ [string] ] = len ( error . message_args [ [number] ] ) [EOL] error_data [ [string] ] = ( [string] [string] . format ( re . escape ( error . message_args [ [number] ] ) ) ) [EOL] error_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . ImportShadowedByLoopVar ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] error_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . UnusedImport , pyflakes . messages . ImportStarUsed ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] if isinstance ( error , pyflakes . messages . ImportStarUsed ) : [EOL] word = [string] [EOL] else : [EOL] word = error . message_args [ [number] ] [EOL] [EOL] linematch = [string] [EOL] r = [string] . format ( re . escape ( word ) ) [EOL] error_data [ [string] ] = r [EOL] error_data [ [string] ] = linematch [EOL] error_list . append ( error_data ) [EOL] elif ( isinstance ( error , pyflakes . messages . DuplicateArgument ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] error_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . LateFutureImport ) : [EOL] pass [EOL] elif isinstance ( error , linter . PythonError ) : [EOL] print ( error ) [EOL] else : [EOL] print ( [string] , type ( error ) ) [EOL] [EOL] return error_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Union , List , Tuple , Dict [EOL] import subprocess [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import shlex [EOL] import logging [EOL] import subprocess [EOL] from subprocess import PIPE , Popen [EOL] [EOL] [EOL] MYPY_SUPPORTED = False [EOL] MYPY_VERSION = None [EOL] try : [EOL] from mypy import main as mypy [EOL] MYPY_SUPPORTED = True [EOL] MYPY_VERSION = tuple ( int ( i ) for i in mypy . __version__ . replace ( [string] , [string] ) . split ( [string] ) ) [EOL] del mypy [EOL] except ImportError : [EOL] print ( [string] ) [EOL] logging . info ( [string] ) [EOL] pass [EOL] [EOL] [EOL] class MyPy ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , filename , mypypath , settings ) : [EOL] self . code = code [EOL] self . filename = filename [EOL] self . mypypath = mypypath [EOL] self . settings = settings [EOL] [EOL] @ property def silent ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] in self . settings [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] if not MYPY_SUPPORTED : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] errors = [ ] [EOL] try : [EOL] errors = self . check_source ( ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] logging . error ( error ) [EOL] [EOL] return errors [EOL] [EOL] def check_source ( self ) : [EOL] [docstring] [EOL] [EOL] err_ctx = [string] [EOL] if MYPY_VERSION < ( [number] , [number] , [number] ) : [EOL] err_ctx = [string] [EOL] [EOL] args = shlex . split ( [string] . format ( sys . executable , err_ctx , [string] . join ( self . settings [ : - [number] ] ) , self . filename ) ) [EOL] env = os . environ . copy ( ) [EOL] if self . mypypath is not None and self . mypypath != [string] : [EOL] env [ [string] ] = self . mypypath [EOL] [EOL] kwargs = { [string] : os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] : - [number] , [string] : env } [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] kwargs [ [string] ] = startupinfo [EOL] [EOL] proc = Popen ( args , stdout = PIPE , stderr = PIPE , ** kwargs ) [EOL] out , err = proc . communicate ( ) [EOL] if err is not None and len ( err ) > [number] : [EOL] if sys . version_info >= ( [number] , ) : [EOL] err = err . decode ( [string] ) [EOL] raise RuntimeError ( err ) [EOL] [EOL] if sys . version_info >= ( [number] , ) : [EOL] out = out . decode ( [string] ) [EOL] [EOL] errors = [ ] [EOL] for line in out . splitlines ( ) : [EOL] if ( self . settings [ - [number] ] and not self . silent and [string] in line . lower ( ) ) : [EOL] continue [EOL] [EOL] data = line . split ( [string] ) if os . name != [string] else line [ [number] : ] . split ( [string] ) [EOL] errors . append ( { [string] : [string] , [string] : int ( data [ [number] ] ) , [string] : [number] , [string] : [string] , [string] : [string] . format ( data [ [number] ] , data [ [number] ] ) , [string] : [string] , [string] : True } ) [EOL] [EOL] return errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import List , Optional , Any [EOL] import optparse [EOL] import typing [EOL] [docstring] [EOL] from __future__ import with_statement [EOL] [EOL] import optparse [EOL] import sys [EOL] from collections import defaultdict [EOL] try : [EOL] import ast [EOL] from ast import iter_child_nodes [EOL] except ImportError : [comment] [EOL] from flake8 . util import ast , iter_child_nodes [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] class ASTVisitor ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . node = None [EOL] self . _cache = { } [EOL] [EOL] def default ( self , node , * args ) : [EOL] for child in iter_child_nodes ( node ) : [EOL] self . dispatch ( child , * args ) [EOL] [EOL] def dispatch ( self , node , * args ) : [EOL] self . node = node [EOL] klass = node . __class__ [EOL] meth = self . _cache . get ( klass ) [EOL] if meth is None : [EOL] className = klass . __name__ [EOL] meth = getattr ( self . visitor , [string] + className , self . default ) [EOL] self . _cache [ klass ] = meth [EOL] return meth ( node , * args ) [EOL] [EOL] def preorder ( self , tree , visitor , * args ) : [EOL] [docstring] [EOL] self . visitor = visitor [EOL] visitor . visit = self . dispatch [EOL] self . dispatch ( tree , * args ) [comment] [EOL] [EOL] [EOL] class PathNode ( object ) : [EOL] def __init__ ( self , name , look = [string] ) : [EOL] self . name = name [EOL] self . look = look [EOL] [EOL] def to_dot ( self ) : [EOL] print ( [string] % ( self . look , self . name , self . dot_id ( ) ) ) [EOL] [EOL] def dot_id ( self ) : [EOL] return id ( self ) [EOL] [EOL] [EOL] class PathGraph ( object ) : [EOL] def __init__ ( self , name , entity , lineno ) : [EOL] self . name = name [EOL] self . entity = entity [EOL] self . lineno = lineno [EOL] self . nodes = defaultdict ( list ) [EOL] [EOL] def connect ( self , n1 , n2 ) : [EOL] self . nodes [ n1 ] . append ( n2 ) [EOL] [EOL] def to_dot ( self ) : [EOL] print ( [string] ) [EOL] for node in self . nodes : [EOL] node . to_dot ( ) [EOL] for node , nexts in self . nodes . items ( ) : [EOL] for next in nexts : [EOL] print ( [string] % ( node . dot_id ( ) , next . dot_id ( ) ) ) [EOL] print ( [string] ) [EOL] [EOL] def complexity ( self ) : [EOL] [docstring] [EOL] num_edges = sum ( [ len ( n ) for n in self . nodes . values ( ) ] ) [EOL] num_nodes = len ( self . nodes ) [EOL] return num_edges - num_nodes + [number] [EOL] [EOL] [EOL] class PathGraphingAstVisitor ( ASTVisitor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( PathGraphingAstVisitor , self ) . __init__ ( ) [EOL] self . classname = [string] [EOL] self . graphs = { } [EOL] self . reset ( ) [EOL] [EOL] def reset ( self ) : [EOL] self . graph = None [EOL] self . tail = None [EOL] [EOL] def dispatch_list ( self , node_list ) : [EOL] for node in node_list : [EOL] self . dispatch ( node ) [EOL] [EOL] def visitFunctionDef ( self , node ) : [EOL] [EOL] if self . classname : [EOL] entity = [string] % ( self . classname , node . name ) [EOL] else : [EOL] entity = node . name [EOL] [EOL] name = [string] % ( node . lineno , entity ) [EOL] [EOL] if self . graph is not None : [EOL] [comment] [EOL] pathnode = self . appendPathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] self . graph . connect ( self . tail , bottom ) [EOL] self . graph . connect ( pathnode , bottom ) [EOL] self . tail = bottom [EOL] else : [EOL] self . graph = PathGraph ( name , entity , node . lineno ) [EOL] pathnode = PathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] self . graphs [ [string] % ( self . classname , node . name ) ] = self . graph [EOL] self . reset ( ) [EOL] [EOL] def visitClassDef ( self , node ) : [EOL] old_classname = self . classname [EOL] self . classname += node . name + [string] [EOL] self . dispatch_list ( node . body ) [EOL] self . classname = old_classname [EOL] [EOL] def appendPathNode ( self , name ) : [EOL] if not self . tail : [EOL] return [EOL] pathnode = PathNode ( name ) [EOL] self . graph . connect ( self . tail , pathnode ) [EOL] self . tail = pathnode [EOL] return pathnode [EOL] [EOL] def visitSimpleStatement ( self , node ) : [EOL] if node . lineno is None : [EOL] lineno = [number] [EOL] else : [EOL] lineno = node . lineno [EOL] name = [string] % lineno [EOL] self . appendPathNode ( name ) [EOL] [EOL] visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = visitRaise = visitYield = visitImport = visitCall = visitSubscript = visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = visitSimpleStatement [EOL] [EOL] def visitLoop ( self , node ) : [EOL] name = [string] % node . lineno [EOL] [EOL] if self . graph is None : [EOL] [comment] [EOL] self . graph = PathGraph ( name , name , node . lineno ) [EOL] pathnode = PathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] self . graphs [ [string] % ( self . classname , name ) ] = self . graph [EOL] self . reset ( ) [EOL] else : [EOL] pathnode = self . appendPathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] self . graph . connect ( self . tail , bottom ) [EOL] self . graph . connect ( pathnode , bottom ) [EOL] self . tail = bottom [EOL] [EOL] [comment] [EOL] [EOL] visitFor = visitWhile = visitLoop [EOL] [EOL] def visitIf ( self , node ) : [EOL] name = [string] % node . lineno [EOL] pathnode = self . appendPathNode ( name ) [EOL] loose_ends = [ ] [EOL] self . dispatch_list ( node . body ) [EOL] loose_ends . append ( self . tail ) [EOL] if node . orelse : [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . orelse ) [EOL] loose_ends . append ( self . tail ) [EOL] else : [EOL] loose_ends . append ( pathnode ) [EOL] if pathnode : [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] for le in loose_ends : [EOL] self . graph . connect ( le , bottom ) [EOL] self . tail = bottom [EOL] [EOL] def visitTryExcept ( self , node ) : [EOL] name = [string] % node . lineno [EOL] pathnode = self . appendPathNode ( name ) [EOL] loose_ends = [ ] [EOL] self . dispatch_list ( node . body ) [EOL] loose_ends . append ( self . tail ) [EOL] for handler in node . handlers : [EOL] self . tail = pathnode [EOL] self . dispatch_list ( handler . body ) [EOL] loose_ends . append ( self . tail ) [EOL] if pathnode : [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] for le in loose_ends : [EOL] self . graph . connect ( le , bottom ) [EOL] self . tail = bottom [EOL] [EOL] def visitWith ( self , node ) : [EOL] name = [string] % node . lineno [EOL] self . appendPathNode ( name ) [EOL] self . dispatch_list ( node . body ) [EOL] [EOL] [EOL] class McCabeChecker ( object ) : [EOL] [docstring] [EOL] name = [string] [EOL] version = __version__ [EOL] _code = [string] [EOL] _error_tmpl = [string] [EOL] max_complexity = [number] [EOL] [EOL] def __init__ ( self , tree , filename ) : [EOL] self . tree = tree [EOL] [EOL] @ classmethod def add_options ( cls , parser ) : [EOL] parser . add_option ( [string] , default = - [number] , action = [string] , type = [string] , help = [string] ) [EOL] parser . config_options . append ( [string] ) [EOL] [EOL] @ classmethod def parse_options ( cls , options ) : [EOL] cls . max_complexity = options . max_complexity [EOL] [EOL] def run ( self ) : [EOL] if self . max_complexity < [number] : [EOL] return [EOL] visitor = PathGraphingAstVisitor ( ) [EOL] visitor . preorder ( self . tree , visitor ) [EOL] for graph in visitor . graphs . values ( ) : [EOL] if graph . complexity ( ) >= self . max_complexity : [EOL] text = self . _error_tmpl % ( graph . entity , graph . complexity ( ) ) [EOL] yield graph . lineno , [number] , text , type ( self ) [EOL] [EOL] [EOL] def get_code_complexity ( code , threshold = [number] , filename = [string] ) : [EOL] try : [EOL] tree = compile ( code , filename , [string] , ast . PyCF_ONLY_AST ) [EOL] except SyntaxError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] sys . stderr . write ( [string] % ( filename , e ) ) [EOL] return [number] [EOL] [EOL] complx = [ ] [EOL] McCabeChecker . max_complexity = threshold [EOL] for lineno , offset , text , check in McCabeChecker ( tree , filename ) . run ( ) : [EOL] complx . append ( [string] % ( filename , lineno , text ) ) [EOL] [EOL] if len ( complx ) == [number] : [EOL] return [number] [EOL] print ( [string] . join ( complx ) ) [EOL] return len ( complx ) [EOL] [EOL] [EOL] def get_module_complexity ( module_path , threshold = [number] ) : [EOL] [docstring] [EOL] with open ( module_path , [string] ) as mod : [EOL] code = mod . read ( ) [EOL] return get_code_complexity ( code , threshold , filename = module_path ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] opar = optparse . OptionParser ( ) [EOL] opar . add_option ( [string] , [string] , dest = [string] , help = [string] , action = [string] ) [EOL] opar . add_option ( [string] , [string] , dest = [string] , help = [string] , type = [string] , default = [number] ) [EOL] [EOL] options , args = opar . parse_args ( argv ) [EOL] [EOL] with open ( args [ [number] ] , [string] ) as mod : [EOL] code = mod . read ( ) [EOL] tree = compile ( code , args [ [number] ] , [string] , ast . PyCF_ONLY_AST ) [EOL] visitor = PathGraphingAstVisitor ( ) [EOL] visitor . preorder ( tree , visitor ) [EOL] [EOL] if options . dot : [EOL] print ( [string] ) [EOL] for graph in visitor . graphs . values ( ) : [EOL] if graph . complexity ( ) >= options . threshold : [EOL] graph . to_dot ( ) [EOL] print ( [string] ) [EOL] else : [EOL] for graph in visitor . graphs . values ( ) : [EOL] if graph . complexity ( ) >= options . threshold : [EOL] print ( graph . name , graph . complexity ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ast [EOL] [EOL] from . mccabe import McCabeChecker [EOL] [EOL] [EOL] class AnacondaMcCabe ( object ) : [EOL] [docstring] [EOL] [EOL] checker = McCabeChecker [EOL] [EOL] def __init__ ( self , code , filename ) : [EOL] self . code = code [EOL] self . filename = filename [EOL] [EOL] @ property def tree ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] code = self . code . encode ( [string] ) + [string] [EOL] return compile ( code , self . filename , [string] , ast . PyCF_ONLY_AST ) [EOL] except SyntaxError : [EOL] return None [EOL] [EOL] def get_code_complexity ( self , threshold = [number] ) : [EOL] [docstring] [EOL] [EOL] if self . tree is not None : [EOL] self . checker . max_complexity = threshold [EOL] return self . parse ( self . checker ( self . tree , self . filename ) . run ( ) ) [EOL] [EOL] return None [EOL] [EOL] def parse ( self , complexities ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] for complexity in complexities : [EOL] errors . append ( { [string] : int ( complexity [ [number] ] ) , [string] : int ( complexity [ [number] ] + [number] ) , [string] : complexity [ [number] ] . split ( [string] , [number] ) [ [number] ] , [string] : complexity [ [number] ] . split ( [string] , [number] ) [ [number] ] } ) [EOL] [EOL] return errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] import os [EOL] [EOL] import pycodestyle as pep8 [EOL] from linting import linter [EOL] [EOL] [EOL] class Pep8Error ( linter . LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text , level = [string] ) : [EOL] ct_tuple = ( code , text ) [EOL] err_str = [string] . format ( level ) [EOL] super ( Pep8Error , self ) . __init__ ( filename , loc , level , err_str , ct_tuple , offset = offset , text = text ) [EOL] [EOL] [EOL] class Pep8Warning ( linter . LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text , level = [string] ) : [EOL] ct_tuple = ( code , text ) [EOL] err_str = [string] . format ( level ) [EOL] super ( Pep8Warning , self ) . __init__ ( filename , loc , level , err_str , ct_tuple , offset = offset , text = text ) [EOL] [EOL] [EOL] class Pep8Linter ( linter . Linter ) : [EOL] [docstring] [EOL] [EOL] def lint ( self , settings , code , filename ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] check_params = { [string] : settings . get ( [string] , [ ] ) , [string] : settings . get ( [string] , pep8 . MAX_LINE_LENGTH ) , [string] : settings . get ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } ) } [EOL] errors . extend ( self . check ( code , filename , settings . get ( [string] ) , ** check_params ) ) [EOL] [EOL] return self . parse ( errors ) [EOL] [EOL] def check ( self , code , filename , rcfile , ignore , max_line_length , levels ) : [EOL] [docstring] [EOL] [EOL] messages = [ ] [EOL] _lines = code . split ( [string] ) [EOL] [EOL] if _lines : [EOL] class AnacondaReport ( pep8 . BaseReport ) : [EOL] [docstring] [EOL] [EOL] def error ( self , line_number , offset , text , check ) : [EOL] [docstring] [EOL] [EOL] col = line_number [EOL] code = text [ : [number] ] [EOL] message = text [ [number] : ] [EOL] [EOL] if self . _ignore_code ( code ) : [EOL] return [EOL] [EOL] if code in self . counters : [EOL] self . counters [ code ] += [number] [EOL] else : [EOL] self . counters [ code ] = [number] [EOL] self . messages [ code ] = message [EOL] [EOL] if code in self . expected : [EOL] return [EOL] [EOL] self . file_errors += [number] [EOL] self . total_errors += [number] [EOL] [EOL] pep8_error = code . startswith ( [string] ) [EOL] klass = Pep8Error if pep8_error else Pep8Warning [EOL] messages . append ( klass ( filename , col , offset , code , message , levels [ code [ [number] ] ] ) ) [EOL] [EOL] return code [EOL] [EOL] params = { [string] : AnacondaReport } [EOL] if not rcfile : [EOL] _ignore = ignore [EOL] params [ [string] ] = _ignore [EOL] else : [EOL] params [ [string] ] = os . path . expanduser ( rcfile ) [EOL] [EOL] options = pep8 . StyleGuide ( ** params ) . options [EOL] if not rcfile : [EOL] options . max_line_length = max_line_length [EOL] [EOL] good_lines = [ l + [string] for l in _lines ] [EOL] good_lines [ - [number] ] = good_lines [ - [number] ] . rstrip ( [string] ) [EOL] [EOL] if not good_lines [ - [number] ] : [EOL] good_lines = good_lines [ : - [number] ] [EOL] [EOL] pep8 . Checker ( filename , good_lines , options = options ) . check_all ( ) [EOL] [EOL] return messages [EOL] [EOL] def parse ( self , errors ) : [EOL] errors_list = [ ] [EOL] if errors is None : [EOL] return errors_list [EOL] [EOL] self . sort_errors ( errors ) [EOL] for error in errors : [EOL] error_level = self . prepare_error_level ( error ) [EOL] message = error . message . capitalize ( ) [EOL] offset = error . offset [EOL] [EOL] error_data = { [string] : True , [string] : error_level , [string] : error . lineno , [string] : offset , [string] : message , [string] : str ( error ) } [EOL] errors_list . append ( error_data ) [EOL] [EOL] return errors_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.List[typing.Any]$ 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class Message ( object ) : [EOL] message = [string] [EOL] message_args = ( ) [EOL] [EOL] def __init__ ( self , filename , loc ) : [EOL] self . filename = filename [EOL] self . lineno = loc . lineno [EOL] self . col = getattr ( loc , [string] , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . filename , self . lineno , self . message % self . message_args ) [EOL] [EOL] [EOL] class UnusedImport ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class RedefinedWhileUnused ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class RedefinedInListComp ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class ImportShadowedByLoopVar ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class ImportStarNotPermitted ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , modname ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( modname , ) [EOL] [EOL] [EOL] class ImportStarUsed ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , modname ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( modname , ) [EOL] [EOL] [EOL] class ImportStarUsage ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , from_list ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , from_list ) [EOL] [EOL] [EOL] class UndefinedName ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class DoctestSyntaxError ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , position = None ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] if position : [EOL] ( self . lineno , self . col ) = position [EOL] self . message_args = ( ) [EOL] [EOL] [EOL] class UndefinedExport ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class UndefinedLocal ( Message ) : [EOL] message = ( [string] [string] ) [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class DuplicateArgument ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class MultiValueRepeatedKeyLiteral ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , key ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( key , ) [EOL] [EOL] [EOL] class MultiValueRepeatedKeyVariable ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , key ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( key , ) [EOL] [EOL] [EOL] class LateFutureImport ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , names ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( ) [EOL] [EOL] [EOL] class FutureFeatureNotDefined ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class UnusedVariable ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , names ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( names , ) [EOL] [EOL] [EOL] class ReturnWithArgsInsideGenerator ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class ReturnOutsideFunction ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class YieldOutsideFunction ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class ContinueOutsideLoop ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class BreakOutsideLoop ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class ContinueInFinally ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class DefaultExceptNotLast ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class TwoStarredExpressions ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class TooManyExpressionsInStarredAssignment ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class AssertTuple ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Set [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] import os [EOL] [EOL] [EOL] class SelectColorSchemeCommand ( sublime_plugin . WindowCommand ) : [EOL] [EOL] PREFS_FILE = [string] [EOL] DEFAULT_CS = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] views = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] schemes = None [EOL] [EOL] [comment] [EOL] prefs = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] last_selected = - [number] [EOL] [EOL] def run ( self ) : [EOL] self . prefs = sublime . load_settings ( self . PREFS_FILE ) [EOL] [EOL] self . views = None [EOL] [EOL] self . current = self . prefs . get ( [string] , self . DEFAULT_CS ) [EOL] [EOL] show_legacy = sublime . load_settings ( [string] ) . get ( [string] , False ) [EOL] [EOL] initial_highlight = - [number] [EOL] self . schemes = [ ] [EOL] names = [ ] [EOL] package_set = set ( ) [EOL] for cs in sublime . find_resources ( [string] ) : [EOL] if self . current and cs == self . current : [EOL] initial_highlight = len ( self . schemes ) [EOL] if len ( cs . split ( [string] , [number] ) ) != [number] : [comment] [EOL] continue [EOL] pkg = os . path . dirname ( cs ) [EOL] if pkg == [string] and not show_legacy : [EOL] continue [EOL] if pkg . startswith ( [string] ) : [EOL] pkg = pkg [ len ( [string] ) : ] [EOL] name , ext = os . path . splitext ( os . path . basename ( cs ) ) [EOL] self . schemes . append ( cs ) [EOL] names . append ( [ name , pkg ] ) [EOL] package_set . add ( pkg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if len ( package_set ) == [number] : [EOL] names = [ name for name , pkg in names ] [EOL] [EOL] self . window . show_quick_panel ( names , self . on_done , sublime . KEEP_OPEN_ON_FOCUS_LOST , initial_highlight , self . on_highlighted ) [EOL] [EOL] def on_done ( self , index ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in self . overridden_views ( find = False ) : [EOL] i [ [string] ] . set ( [string] , i [ [string] ] ) [EOL] [EOL] if index == - [number] : [EOL] self . prefs . set ( [string] , self . current ) [EOL] else : [EOL] self . prefs . set ( [string] , self . schemes [ index ] ) [EOL] sublime . save_settings ( self . PREFS_FILE ) [EOL] [EOL] def on_highlighted ( self , index ) : [EOL] [docstring] [EOL] [EOL] if index == - [number] : [EOL] return [EOL] [EOL] self . last_selected = index [EOL] [EOL] def update_cs ( ) : [EOL] [comment] [EOL] [comment] [EOL] if index != self . last_selected : [EOL] return [EOL] selected = self . schemes [ index ] [EOL] if self . prefs . get ( [string] ) == selected : [EOL] return [EOL] self . prefs . set ( [string] , selected ) [EOL] for i in self . overridden_views ( ) : [EOL] i [ [string] ] . set ( [string] , self . schemes [ index ] ) [EOL] sublime . set_timeout ( update_cs , [number] ) [EOL] [EOL] def overridden_views ( self , find = True ) : [EOL] [docstring] [EOL] [EOL] if self . views is None : [EOL] if find is False : [EOL] return [ ] [EOL] [comment] [EOL] [comment] [EOL] if self . prefs . get ( [string] ) == self . current : [EOL] return [ ] [EOL] vs = [ ] [EOL] for i in range ( self . window . num_groups ( ) ) : [EOL] v = self . window . active_view_in_group ( i ) [EOL] cs = v . settings ( ) . get ( [string] , self . DEFAULT_CS ) [EOL] if self . is_view_specific ( v ) : [EOL] vs . append ( { [string] : v . settings ( ) , [string] : cs , } ) [EOL] self . views = vs [EOL] return self . views [EOL] [EOL] def is_view_specific ( self , view ) : [EOL] [docstring] [EOL] [EOL] vcs = view . settings ( ) . get ( [string] , self . DEFAULT_CS ) [EOL] pd = self . window . project_data ( ) [EOL] pcs = None [EOL] if pd is not None : [EOL] pcs = pd . get ( [string] , { } ) . get ( [string] ) [EOL] gcs = self . prefs . get ( [string] ) [EOL] [EOL] if pcs is not None and vcs != pcs : [EOL] return True [EOL] return vcs != gcs [EOL] [EOL] [EOL] class SelectThemeCommand ( sublime_plugin . WindowCommand ) : [EOL] [EOL] PREFS_FILE = [string] [EOL] DEFAULT_THEME = [string] [EOL] [EOL] [comment] [EOL] current = None [EOL] [EOL] [comment] [EOL] themes = None [EOL] [EOL] [comment] [EOL] prefs = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] last_selected = - [number] [EOL] [EOL] def run ( self ) : [EOL] self . prefs = sublime . load_settings ( self . PREFS_FILE ) [EOL] [EOL] self . current = self . prefs . get ( [string] , self . DEFAULT_THEME ) [EOL] cur_index = - [number] [EOL] [EOL] self . themes = [ ] [EOL] names = [ ] [EOL] nameset = set ( ) [EOL] [EOL] for theme in sublime . find_resources ( [string] ) : [EOL] name = os . path . basename ( theme ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if name in nameset : [EOL] continue [EOL] nameset . add ( name ) [EOL] [EOL] if name == self . current : [EOL] cur_index = len ( self . themes ) [EOL] if len ( theme . split ( [string] , [number] ) ) != [number] : [comment] [EOL] continue [EOL] self . themes . append ( name ) [EOL] pkg = os . path . dirname ( theme ) + [string] [EOL] if pkg . startswith ( [string] ) : [EOL] pkg = pkg [ len ( [string] ) : ] [EOL] names . append ( [ name , pkg ] ) [EOL] [EOL] self . window . show_quick_panel ( names , self . on_done , sublime . KEEP_OPEN_ON_FOCUS_LOST , cur_index , self . on_highlighted ) [EOL] [EOL] def on_done ( self , index ) : [EOL] [docstring] [EOL] [EOL] if index == - [number] : [EOL] theme = self . current [EOL] else : [EOL] theme = self . themes [ index ] [EOL] self . prefs . set ( [string] , theme ) [EOL] sublime . save_settings ( self . PREFS_FILE ) [EOL] [EOL] def on_highlighted ( self , index ) : [EOL] [docstring] [EOL] [EOL] if index == - [number] : [EOL] return [EOL] [EOL] self . last_selected = index [EOL] [EOL] def update_theme ( ) : [EOL] [comment] [EOL] [comment] [EOL] if index != self . last_selected : [EOL] return [EOL] self . prefs . set ( [string] , self . themes [ index ] ) [EOL] sublime . set_timeout ( update_theme , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def advance_to_first_non_white_space_on_line ( view , pt ) : [EOL] while True : [EOL] c = view . substr ( pt ) [EOL] if c == [string] or c == [string] : [EOL] pt += [number] [EOL] else : [EOL] break [EOL] [EOL] return pt [EOL] [EOL] [EOL] def has_non_white_space_on_line ( view , pt ) : [EOL] while True : [EOL] c = view . substr ( pt ) [EOL] if c == [string] or c == [string] : [EOL] pt += [number] [EOL] else : [EOL] return c != [string] [EOL] [EOL] [EOL] def build_comment_data ( view , pt ) : [EOL] shell_vars = view . meta_info ( [string] , pt ) [EOL] if not shell_vars : [EOL] return ( [ ] , [ ] ) [EOL] [EOL] [comment] [EOL] all_vars = { } [EOL] for v in shell_vars : [EOL] if [string] in v and [string] in v : [EOL] all_vars [ v [ [string] ] ] = v [ [string] ] [EOL] [EOL] line_comments = [ ] [EOL] block_comments = [ ] [EOL] [EOL] [comment] [EOL] suffixes = [ [string] ] + [ [string] + str ( i ) for i in range ( [number] , [number] ) ] [EOL] for suffix in suffixes : [EOL] start = all_vars . setdefault ( [string] + suffix ) [EOL] end = all_vars . setdefault ( [string] + suffix ) [EOL] disable_indent = all_vars . setdefault ( [string] + suffix ) [EOL] [EOL] if start and end : [EOL] block_comments . append ( ( start , end , disable_indent == [string] ) ) [EOL] block_comments . append ( ( start . strip ( ) , end . strip ( ) , disable_indent == [string] ) ) [EOL] elif start : [EOL] line_comments . append ( ( start , disable_indent == [string] ) ) [EOL] line_comments . append ( ( start . strip ( ) , disable_indent == [string] ) ) [EOL] [EOL] return ( line_comments , block_comments ) [EOL] [EOL] [EOL] class ToggleCommentCommand ( sublime_plugin . TextCommand ) : [EOL] def remove_block_comment ( self , view , edit , comment_data , region ) : [EOL] ( line_comments , block_comments ) = comment_data [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] whole_region = view . extract_scope ( region . begin ( ) + region . size ( ) / [number] ) [EOL] [EOL] for c in block_comments : [EOL] ( start , end , disable_indent ) = c [EOL] start_region = sublime . Region ( whole_region . begin ( ) , whole_region . begin ( ) + len ( start ) ) [EOL] end_region = sublime . Region ( whole_region . end ( ) - len ( end ) , whole_region . end ( ) ) [EOL] [EOL] if view . substr ( start_region ) == start and view . substr ( end_region ) == end : [EOL] [comment] [EOL] view . erase ( edit , start_region ) [EOL] [EOL] end_region = sublime . Region ( end_region . begin ( ) - start_region . size ( ) , end_region . end ( ) - start_region . size ( ) ) [EOL] [EOL] view . erase ( edit , end_region ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def remove_line_comment ( self , view , edit , comment_data , region ) : [EOL] ( line_comments , block_comments ) = comment_data [EOL] [EOL] found_line_comment = False [EOL] [EOL] start_positions = [ advance_to_first_non_white_space_on_line ( view , r . begin ( ) ) for r in view . lines ( region ) ] [EOL] start_positions . reverse ( ) [EOL] [EOL] for pos in start_positions : [EOL] for c in line_comments : [EOL] ( start , disable_indent ) = c [EOL] comment_region = sublime . Region ( pos , pos + len ( start ) ) [EOL] if view . substr ( comment_region ) == start : [EOL] view . erase ( edit , comment_region ) [EOL] found_line_comment = True [EOL] break [EOL] [EOL] return found_line_comment [EOL] [EOL] def is_entirely_line_commented ( self , view , comment_data , region ) : [EOL] ( line_comments , block_comments ) = comment_data [EOL] [EOL] start_positions = [ advance_to_first_non_white_space_on_line ( view , r . begin ( ) ) for r in view . lines ( region ) ] [EOL] start_positions = list ( filter ( lambda p : has_non_white_space_on_line ( view , p ) , start_positions ) ) [EOL] [EOL] if len ( start_positions ) == [number] : [EOL] return False [EOL] [EOL] for pos in start_positions : [EOL] found_line_comment = False [EOL] for c in line_comments : [EOL] ( start , disable_indent ) = c [EOL] comment_region = sublime . Region ( pos , pos + len ( start ) ) [EOL] if view . substr ( comment_region ) == start : [EOL] found_line_comment = True [EOL] if not found_line_comment : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def block_comment_region ( self , view , edit , block_comment_data , region ) : [EOL] ( start , end , disable_indent ) = block_comment_data [EOL] [EOL] if region . empty ( ) : [EOL] [comment] [EOL] [comment] [EOL] view . replace ( edit , sublime . Region ( region . end ( ) ) , [string] ) [EOL] view . insert ( edit , region . end ( ) + [number] , end ) [EOL] view . replace ( edit , sublime . Region ( region . end ( ) , region . end ( ) + [number] ) , [string] ) [EOL] view . insert ( edit , region . begin ( ) , start ) [EOL] else : [EOL] view . insert ( edit , region . end ( ) , end ) [EOL] view . insert ( edit , region . begin ( ) , start ) [EOL] [EOL] def line_comment_region ( self , view , edit , line_comment_data , region ) : [EOL] ( start , disable_indent ) = line_comment_data [EOL] [EOL] start_positions = [ r . begin ( ) for r in view . lines ( region ) ] [EOL] start_positions . reverse ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] non_empty_start_positions = list ( filter ( lambda p : has_non_white_space_on_line ( view , p ) , start_positions ) ) [EOL] [EOL] [comment] [EOL] if len ( non_empty_start_positions ) != [number] : [EOL] start_positions = non_empty_start_positions [EOL] [EOL] if not disable_indent : [EOL] min_indent = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] for pos in start_positions : [EOL] indent = advance_to_first_non_white_space_on_line ( view , pos ) - pos [EOL] if min_indent is None or indent < min_indent : [EOL] min_indent = indent [EOL] [EOL] if min_indent is not None and min_indent > [number] : [EOL] start_positions = [ r + min_indent for r in start_positions ] [EOL] [EOL] for pos in start_positions : [EOL] view . insert ( edit , pos , start ) [EOL] [EOL] def add_comment ( self , view , edit , comment_data , prefer_block , region ) : [EOL] ( line_comments , block_comments ) = comment_data [EOL] [EOL] if len ( line_comments ) == [number] and len ( block_comments ) == [number] : [EOL] return [EOL] [EOL] if len ( block_comments ) == [number] : [EOL] prefer_block = False [EOL] [EOL] if len ( line_comments ) == [number] : [EOL] prefer_block = True [EOL] [EOL] if region . empty ( ) : [EOL] if prefer_block : [EOL] [comment] [EOL] self . block_comment_region ( view , edit , block_comments [ [number] ] , region ) [EOL] else : [EOL] [comment] [EOL] self . line_comment_region ( view , edit , line_comments [ [number] ] , region ) [EOL] else : [EOL] if prefer_block : [EOL] [comment] [EOL] self . block_comment_region ( view , edit , block_comments [ [number] ] , region ) [EOL] else : [EOL] [comment] [EOL] self . line_comment_region ( view , edit , line_comments [ [number] ] , region ) [EOL] [EOL] def run ( self , edit , block = False ) : [EOL] for region in self . view . sel ( ) : [EOL] comment_data = build_comment_data ( self . view , region . begin ( ) ) [EOL] if ( region . end ( ) != self . view . size ( ) and build_comment_data ( self . view , region . end ( ) ) != comment_data ) : [EOL] [comment] [EOL] continue [EOL] [EOL] if self . remove_block_comment ( self . view , edit , comment_data , region ) : [EOL] continue [EOL] [EOL] if self . is_entirely_line_commented ( self . view , comment_data , region ) : [EOL] self . remove_line_comment ( self . view , edit , comment_data , region ) [EOL] continue [EOL] [EOL] has_line_comment = len ( comment_data [ [number] ] ) > [number] [EOL] [EOL] if not has_line_comment and not block and region . empty ( ) : [EOL] [comment] [EOL] line = self . view . line ( region . a ) [EOL] line = sublime . Region ( advance_to_first_non_white_space_on_line ( self . view , line . a ) , line . b ) [EOL] [EOL] [comment] [EOL] if self . remove_block_comment ( self . view , edit , comment_data , line ) : [EOL] continue [EOL] [EOL] self . add_comment ( self . view , edit , comment_data , block , line ) [EOL] continue [EOL] [EOL] [comment] [EOL] self . add_comment ( self . view , edit , comment_data , block , region ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def clamp ( xmin , x , xmax ) : [EOL] if x < xmin : [EOL] return xmin [EOL] if x > xmax : [EOL] return xmax [EOL] return x [EOL] [EOL] [EOL] class DeleteWordCommand ( sublime_plugin . TextCommand ) : [EOL] def find_by_class ( self , pt , classes , forward ) : [EOL] if forward : [EOL] delta = [number] [EOL] end_position = self . view . size ( ) [EOL] if pt > end_position : [EOL] pt = end_position [EOL] else : [EOL] delta = - [number] [EOL] end_position = [number] [EOL] if pt < end_position : [EOL] pt = end_position [EOL] [EOL] while pt != end_position : [EOL] if self . view . classify ( pt ) & classes != [number] : [EOL] return pt [EOL] pt += delta [EOL] [EOL] return pt [EOL] [EOL] def expand_word ( self , view , pos , classes , forward ) : [EOL] if forward : [EOL] delta = [number] [EOL] else : [EOL] delta = - [number] [EOL] ws = [ [string] , [string] ] [EOL] [EOL] if forward : [EOL] if view . substr ( pos ) in ws and view . substr ( pos + [number] ) in ws : [EOL] classes = sublime . CLASS_WORD_START | sublime . CLASS_PUNCTUATION_START | sublime . CLASS_LINE_END [EOL] else : [EOL] if view . substr ( pos - [number] ) in ws and view . substr ( pos - [number] ) in ws : [EOL] classes = sublime . CLASS_WORD_END | sublime . CLASS_PUNCTUATION_END | sublime . CLASS_LINE_START [EOL] [EOL] return sublime . Region ( pos , self . find_by_class ( pos + delta , classes , forward ) ) [EOL] [EOL] def run ( self , edit , forward = True , sub_words = False ) : [EOL] if forward : [EOL] classes = sublime . CLASS_WORD_END | sublime . CLASS_PUNCTUATION_END | sublime . CLASS_LINE_START [EOL] if sub_words : [EOL] classes |= sublime . CLASS_SUB_WORD_END [EOL] else : [EOL] classes = ( sublime . CLASS_WORD_START | sublime . CLASS_PUNCTUATION_START | sublime . CLASS_LINE_END | sublime . CLASS_LINE_START ) [EOL] if sub_words : [EOL] classes |= sublime . CLASS_SUB_WORD_START [EOL] [EOL] new_sels = [ ] [EOL] for s in reversed ( self . view . sel ( ) ) : [EOL] if s . empty ( ) : [EOL] new_sels . append ( self . expand_word ( self . view , s . b , classes , forward ) ) [EOL] [EOL] sz = self . view . size ( ) [EOL] for s in new_sels : [EOL] self . view . sel ( ) . add ( sublime . Region ( clamp ( [number] , s . a , sz ) , clamp ( [number] , s . b , sz ) ) ) [EOL] [EOL] self . view . run_command ( [string] , { [string] : forward } ) [EOL] [EOL] if forward : [EOL] self . view . run_command ( [string] ) [EOL] else : [EOL] self . view . run_command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] import sublime_api [EOL] [EOL] [EOL] MAX_COLUMNS = [number] [EOL] [EOL] [EOL] def create_splits ( num_splits ) : [EOL] return [ [number] ] + [ [number] / num_splits * i for i in range ( [number] , num_splits ) ] + [ [number] ] [EOL] [EOL] [EOL] def rows_cols_for_panes ( num_panes , max_columns ) : [EOL] if num_panes > max_columns : [EOL] num_cols = max_columns [EOL] num_rows = num_panes - num_cols + [number] [EOL] else : [EOL] num_cols = num_panes [EOL] num_rows = [number] [EOL] return num_rows , num_cols [EOL] [EOL] [EOL] def assign_cells ( num_panes , max_columns ) : [EOL] num_rows , num_cols = rows_cols_for_panes ( num_panes , max_columns ) [EOL] [EOL] cells = [ ] [EOL] for i in range ( [number] , num_panes ) : [EOL] if i < ( max_columns - [number] ) : [EOL] cells . append ( [ i , [number] , i + [number] , num_rows ] ) [EOL] else : [EOL] row = i - ( max_columns - [number] ) [EOL] cells . append ( [ num_cols - [number] , row , num_cols , row + [number] ] ) [EOL] return cells [EOL] [EOL] [EOL] def move_sheets ( window , src_group , dst_group ) : [EOL] sheets = window . sheets_in_group ( src_group ) [EOL] transient = window . transient_sheet_in_group ( src_group ) [EOL] [EOL] for i in range ( len ( sheets ) ) : [EOL] window . set_sheet_index ( sheets [ i ] , dst_group , i ) [EOL] [EOL] if transient is not None : [EOL] window . set_sheet_index ( transient , dst_group , - [number] ) [EOL] [EOL] [EOL] def num_sheets_in_group_including_transient ( window , group ) : [EOL] num = len ( window . sheets_in_group ( group ) ) [EOL] if window . transient_sheet_in_group ( group ) is not None : [EOL] num += [number] [EOL] return num [EOL] [EOL] [EOL] class NewPaneCommand ( sublime_plugin . WindowCommand ) : [EOL] def new_pane ( self , window , move_sheet , max_columns ) : [EOL] cur_sheet = window . active_sheet ( ) [EOL] [EOL] layout = window . get_layout ( ) [EOL] num_panes = len ( layout [ [string] ] ) [EOL] [EOL] cur_index = window . active_group ( ) [EOL] [EOL] rows = layout [ [string] ] [EOL] cols = layout [ [string] ] [EOL] cells = layout [ [string] ] [EOL] [EOL] if cells != assign_cells ( num_panes , max_columns ) : [EOL] [comment] [EOL] num_rows , num_cols = rows_cols_for_panes ( num_panes + [number] , max_columns ) [EOL] rows = create_splits ( num_rows ) [EOL] cols = create_splits ( num_cols ) [EOL] cells = assign_cells ( num_panes + [number] , max_columns ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] num_cols = len ( cols ) - [number] [EOL] num_rows = len ( rows ) - [number] [EOL] [EOL] [comment] [EOL] if num_cols < max_columns : [EOL] num_cols += [number] [EOL] cols = create_splits ( num_cols ) [EOL] else : [EOL] num_rows += [number] [EOL] rows = create_splits ( num_rows ) [EOL] [EOL] cells = assign_cells ( num_panes + [number] , max_columns ) [EOL] [EOL] window . set_layout ( { [string] : cells , [string] : rows , [string] : cols } ) [EOL] window . settings ( ) . set ( [string] , cells ) [EOL] [EOL] [comment] [EOL] for i in reversed ( range ( [number] , num_panes - cur_index - [number] ) ) : [EOL] move_sheets ( window , cur_index + i + [number] , cur_index + i + [number] ) [EOL] [EOL] if move_sheet : [EOL] transient = window . transient_sheet_in_group ( cur_index ) [EOL] if transient is not None and cur_sheet . sheet_id == transient . sheet_id : [EOL] [comment] [EOL] window . set_sheet_index ( cur_sheet , cur_index + [number] , - [number] ) [EOL] else : [EOL] window . set_sheet_index ( cur_sheet , cur_index + [number] , [number] ) [EOL] [EOL] if num_sheets_in_group_including_transient ( window , cur_index ) == [number] : [EOL] window . focus_group ( cur_index ) [EOL] window . new_file ( sublime . TRANSIENT ) [EOL] [EOL] window . focus_group ( cur_index + [number] ) [EOL] else : [EOL] window . focus_group ( cur_index + [number] ) [EOL] window . new_file ( sublime . TRANSIENT ) [EOL] [EOL] def run ( self , move = True ) : [EOL] max_columns = self . window . template_settings ( ) . get ( [string] , MAX_COLUMNS ) [EOL] self . new_pane ( self . window , move , max_columns ) [EOL] [EOL] [EOL] class ClosePaneCommand ( sublime_plugin . WindowCommand ) : [EOL] def close_pane ( self , window , idx , max_columns ) : [EOL] layout = window . get_layout ( ) [EOL] num_panes = len ( layout [ [string] ] ) [EOL] selected_sheet = window . active_sheet_in_group ( idx ) [EOL] [EOL] if num_panes == [number] : [EOL] return [EOL] [EOL] for i in range ( idx , window . num_groups ( ) ) : [EOL] move_sheets ( window , i , i - [number] ) [EOL] [EOL] rows = layout [ [string] ] [EOL] cols = layout [ [string] ] [EOL] cells = layout [ [string] ] [EOL] [EOL] if layout [ [string] ] != assign_cells ( num_panes , max_columns ) : [EOL] num_rows , num_cols = rows_cols_for_panes ( num_panes - [number] , max_columns ) [EOL] rows = create_splits ( num_rows ) [EOL] cols = create_splits ( num_cols ) [EOL] cells = assign_cells ( num_panes - [number] , max_columns ) [EOL] else : [EOL] num_cols = len ( cols ) - [number] [EOL] num_rows = len ( rows ) - [number] [EOL] [EOL] if num_rows > [number] : [EOL] num_rows -= [number] [EOL] rows = create_splits ( num_rows ) [EOL] else : [EOL] num_cols -= [number] [EOL] cols = create_splits ( num_cols ) [EOL] [EOL] cells = assign_cells ( num_panes - [number] , max_columns ) [EOL] [EOL] window . set_layout ( { [string] : cells , [string] : rows , [string] : cols } ) [EOL] window . settings ( ) . set ( [string] , cells ) [EOL] [EOL] new_idx = idx - [number] [EOL] if new_idx < [number] : [EOL] new_idx = [number] [EOL] window . focus_group ( new_idx ) [EOL] window . focus_sheet ( selected_sheet ) [EOL] [EOL] def run ( self , group = - [number] ) : [EOL] if group < [number] : [EOL] group = self . window . active_group ( ) [EOL] max_columns = self . window . template_settings ( ) . get ( [string] , MAX_COLUMNS ) [EOL] self . close_pane ( self . window , group , max_columns ) [EOL] [EOL] [EOL] def is_automatic_layout ( window ) : [EOL] last_automatic_layout = window . settings ( ) . get ( [string] ) [EOL] if last_automatic_layout is None : [EOL] return False [EOL] [EOL] if window . get_layout ( ) [ [string] ] != last_automatic_layout : [EOL] window . settings ( ) . erase ( [string] ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] class AutomaticPaneCloser ( sublime_plugin . EventListener ) : [EOL] def on_activated ( self , view ) : [EOL] [comment] [EOL] [comment] [EOL] sublime . set_timeout ( lambda : self . on_close ( view ) , [number] ) [EOL] [EOL] def on_close ( self , view ) : [EOL] window = sublime . active_window ( ) [EOL] [EOL] if not is_automatic_layout ( window ) : [EOL] return [EOL] [EOL] if sublime_api . window_is_dragging ( window . id ( ) ) : [EOL] return [EOL] [EOL] [comment] [EOL] if view . size ( ) != [number] or view . file_name ( ) is not None : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] focused_group = window . active_group ( ) [EOL] [EOL] for i in reversed ( range ( window . num_groups ( ) ) ) : [EOL] if num_sheets_in_group_including_transient ( window , i ) == [number] : [EOL] if i == focused_group : [EOL] focused_group = - [number] [EOL] elif i < focused_group : [EOL] focused_group -= [number] [EOL] [EOL] window . run_command ( [string] , { [string] : i } ) [EOL] if focused_group >= [number] : [EOL] window . focus_group ( focused_group ) [EOL] break [EOL] [EOL] [EOL] class FocusNeighboringGroup ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , forward = True ) : [EOL] group = self . window . active_group ( ) [EOL] if forward : [EOL] group = ( group + [number] ) % self . window . num_groups ( ) [EOL] else : [EOL] group = ( group - [number] ) % self . window . num_groups ( ) [EOL] [EOL] self . window . focus_group ( group ) [EOL] [EOL] [EOL] class MoveToNeighboringGroup ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , forward = True ) : [EOL] group = self . window . active_group ( ) [EOL] if forward : [EOL] group = ( group + [number] ) % self . window . num_groups ( ) [EOL] else : [EOL] group = ( group - [number] ) % self . window . num_groups ( ) [EOL] [EOL] self . window . run_command ( [string] , { [string] : group } ) [EOL] [EOL] [EOL] class SetMaxColumns ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , columns ) : [EOL] if columns >= [number] : [EOL] max_columns = columns [EOL] self . window . template_settings ( ) . set ( [string] , max_columns ) [EOL] [EOL] [comment] [EOL] layout = self . window . get_layout ( ) [EOL] num_panes = len ( layout [ [string] ] ) [EOL] [EOL] num_rows , num_cols = rows_cols_for_panes ( num_panes , max_columns ) [EOL] rows = create_splits ( num_rows ) [EOL] cols = create_splits ( num_cols ) [EOL] cells = assign_cells ( num_panes , max_columns ) [EOL] self . window . set_layout ( { [string] : cells , [string] : rows , [string] : cols } ) [EOL] self . window . settings ( ) . set ( [string] , cells ) [EOL] [EOL] def is_checked ( self , columns ) : [EOL] if not is_automatic_layout ( self . window ) : [EOL] return False [EOL] [EOL] max_columns = self . window . template_settings ( ) . get ( [string] , MAX_COLUMNS ) [EOL] return columns == max_columns [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class SetMarkCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] mark = [ s for s in self . view . sel ( ) ] [EOL] self . view . add_regions ( [string] , mark , [string] , [string] , sublime . HIDDEN | sublime . PERSISTENT ) [EOL] [EOL] [EOL] class SwapWithMarkCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] old_mark = self . view . get_regions ( [string] ) [EOL] [EOL] mark = [ s for s in self . view . sel ( ) ] [EOL] self . view . add_regions ( [string] , mark , [string] , [string] , sublime . HIDDEN | sublime . PERSISTENT ) [EOL] [EOL] if len ( old_mark ) : [EOL] self . view . sel ( ) . clear ( ) [EOL] for r in old_mark : [EOL] self . view . sel ( ) . add ( r ) [EOL] [EOL] [EOL] class SelectToMarkCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] mark = self . view . get_regions ( [string] ) [EOL] [EOL] num = min ( len ( mark ) , len ( self . view . sel ( ) ) ) [EOL] [EOL] regions = [ ] [EOL] for i in range ( num ) : [EOL] regions . append ( self . view . sel ( ) [ i ] . cover ( mark [ i ] ) ) [EOL] [EOL] for i in range ( num , len ( self . view . sel ( ) ) ) : [EOL] regions . append ( self . view . sel ( ) [ i ] ) [EOL] [EOL] self . view . sel ( ) . clear ( ) [EOL] for r in regions : [EOL] self . view . sel ( ) . add ( r ) [EOL] [EOL] [EOL] class DeleteToMark ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] self . view . run_command ( [string] ) [EOL] self . view . run_command ( [string] , { [string] : False } ) [EOL] self . view . run_command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def fold_region_from_indent ( view , r ) : [EOL] if r . b == view . size ( ) : [EOL] return sublime . Region ( r . a - [number] , r . b ) [EOL] else : [EOL] return sublime . Region ( r . a - [number] , r . b - [number] ) [EOL] [EOL] [EOL] class FoldUnfoldCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] new_sel = [ ] [EOL] for s in self . view . sel ( ) : [EOL] r = s [EOL] empty_region = r . empty ( ) [EOL] if empty_region : [EOL] r = sublime . Region ( r . a - [number] , r . a + [number] ) [EOL] [EOL] unfolded = self . view . unfold ( r ) [EOL] if len ( unfolded ) == [number] : [EOL] self . view . fold ( s ) [EOL] elif empty_region : [EOL] for r in unfolded : [EOL] new_sel . append ( r ) [EOL] [EOL] if len ( new_sel ) > [number] : [EOL] self . view . sel ( ) . clear ( ) [EOL] for r in new_sel : [EOL] self . view . sel ( ) . add ( r ) [EOL] [EOL] [EOL] class FoldCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] new_sel = [ ] [EOL] for s in self . view . sel ( ) : [EOL] if s . empty ( ) : [EOL] r = self . view . indented_region ( s . a ) [EOL] if not r . empty ( ) : [EOL] r = fold_region_from_indent ( self . view , r ) [EOL] self . view . fold ( r ) [EOL] new_sel . append ( r ) [EOL] else : [EOL] new_sel . append ( s ) [EOL] else : [EOL] if self . view . fold ( s ) : [EOL] new_sel . append ( s ) [EOL] else : [EOL] r = self . view . indented_region ( s . a ) [EOL] if not r . empty ( ) : [EOL] r = fold_region_from_indent ( self . view , r ) [EOL] self . view . fold ( r ) [EOL] new_sel . append ( r ) [EOL] else : [EOL] new_sel . append ( s ) [EOL] [EOL] self . view . sel ( ) . clear ( ) [EOL] for r in new_sel : [EOL] self . view . sel ( ) . add ( r ) [EOL] [EOL] [EOL] class FoldAllCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] folds = [ ] [EOL] tp = [number] [EOL] size = self . view . size ( ) [EOL] while tp < size : [EOL] s = self . view . indented_region ( tp ) [EOL] if not s . empty ( ) : [EOL] r = fold_region_from_indent ( self . view , s ) [EOL] folds . append ( r ) [EOL] tp = s . b [EOL] else : [EOL] tp = self . view . full_line ( tp ) . b [EOL] [EOL] self . view . fold ( folds ) [EOL] self . view . show ( self . view . sel ( ) ) [EOL] [EOL] sublime . status_message ( [string] + str ( len ( folds ) ) + [string] ) [EOL] [EOL] [EOL] class FoldByLevelCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , level ) : [EOL] level = int ( level ) [EOL] folds = [ ] [EOL] tp = [number] [EOL] size = self . view . size ( ) [EOL] while tp < size : [EOL] if self . view . indentation_level ( tp ) == level : [EOL] s = self . view . indented_region ( tp ) [EOL] if not s . empty ( ) : [EOL] r = fold_region_from_indent ( self . view , s ) [EOL] folds . append ( r ) [EOL] tp = s . b [EOL] continue [EOL] [EOL] tp = self . view . full_line ( tp ) . b [EOL] [EOL] self . view . fold ( folds ) [EOL] self . view . show ( self . view . sel ( ) ) [EOL] [EOL] sublime . status_message ( [string] + str ( len ( folds ) ) + [string] ) [EOL] [EOL] [EOL] class UnfoldCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] new_sel = [ ] [EOL] for s in self . view . sel ( ) : [EOL] unfold = s [EOL] if s . empty ( ) : [EOL] unfold = sublime . Region ( s . a - [number] , s . a + [number] ) [EOL] [EOL] unfolded = self . view . unfold ( unfold ) [EOL] if len ( unfolded ) == [number] and s . empty ( ) : [EOL] unfolded = self . view . unfold ( self . view . full_line ( s . b ) ) [EOL] [EOL] if len ( unfolded ) == [number] : [EOL] new_sel . append ( s ) [EOL] else : [EOL] for r in unfolded : [EOL] new_sel . append ( r ) [EOL] [EOL] if len ( new_sel ) > [number] : [EOL] self . view . sel ( ) . clear ( ) [EOL] for r in new_sel : [EOL] self . view . sel ( ) . add ( r ) [EOL] [EOL] [EOL] class UnfoldAllCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] self . view . unfold ( sublime . Region ( [number] , self . view . size ( ) ) ) [EOL] self . view . show ( self . view . sel ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime_plugin [EOL] [EOL] [EOL] class TrimTrailingWhiteSpaceCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] trailing_white_space = self . view . find_all ( [string] ) [EOL] trailing_white_space . reverse ( ) [EOL] for r in trailing_white_space : [EOL] self . view . erase ( edit , r ) [EOL] [EOL] [EOL] class TrimTrailingWhiteSpace ( sublime_plugin . EventListener ) : [EOL] def on_pre_save ( self , view ) : [EOL] if view . settings ( ) . get ( [string] ) is True : [EOL] view . run_command ( [string] ) [EOL] [EOL] [EOL] class EnsureNewlineAtEofCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] if self . view . size ( ) > [number] and self . view . substr ( self . view . size ( ) - [number] ) != [string] : [EOL] self . view . insert ( edit , self . view . size ( ) , [string] ) [EOL] [EOL] [EOL] class EnsureNewlineAtEof ( sublime_plugin . EventListener ) : [EOL] def on_pre_save ( self , view ) : [EOL] if view . settings ( ) . get ( [string] ) is True : [EOL] if view . size ( ) > [number] and view . substr ( view . size ( ) - [number] ) != [string] : [EOL] view . run_command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class DetectIndentationCommand ( sublime_plugin . TextCommand ) : [EOL] [docstring] [EOL] [EOL] def run ( self , edit , show_message = True , threshold = [number] ) : [EOL] sample = self . view . substr ( sublime . Region ( [number] , min ( self . view . size ( ) , [number] ** [number] ) ) ) [EOL] [EOL] starts_with_tab = [number] [EOL] spaces_list = [ ] [EOL] indented_lines = [number] [EOL] [EOL] for line in sample . split ( [string] ) : [EOL] if not line : [EOL] continue [EOL] if line [ [number] ] == [string] : [EOL] starts_with_tab += [number] [EOL] indented_lines += [number] [EOL] elif line . startswith ( [string] ) : [EOL] spaces = [number] [EOL] for ch in line : [EOL] if ch == [string] : [EOL] spaces += [number] [EOL] else : [EOL] break [EOL] if spaces > [number] and spaces != len ( line ) : [EOL] indented_lines += [number] [EOL] spaces_list . append ( spaces ) [EOL] [EOL] evidence = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] if indented_lines >= threshold : [EOL] if len ( spaces_list ) > starts_with_tab : [EOL] for indent in range ( [number] , [number] , - [number] ) : [EOL] same_indent = list ( filter ( lambda x : x % indent == [number] , spaces_list ) ) [EOL] if len ( same_indent ) >= evidence [ indent ] * len ( spaces_list ) : [EOL] if show_message : [EOL] sublime . status_message ( [string] + str ( indent ) + [string] ) [EOL] self . view . settings ( ) . set ( [string] , True ) [EOL] self . view . settings ( ) . set ( [string] , indent ) [EOL] return [EOL] [EOL] for indent in range ( [number] , [number] , - [number] ) : [EOL] same_indent = list ( filter ( lambda x : x % indent == [number] or x % indent == [number] , spaces_list ) ) [EOL] if len ( same_indent ) >= evidence [ indent ] * len ( spaces_list ) : [EOL] if show_message : [EOL] sublime . status_message ( [string] + str ( indent ) + [string] ) [EOL] self . view . settings ( ) . set ( [string] , True ) [EOL] self . view . settings ( ) . set ( [string] , indent ) [EOL] return [EOL] [EOL] elif starts_with_tab >= [number] * indented_lines : [EOL] if show_message : [EOL] sublime . status_message ( [string] ) [EOL] self . view . settings ( ) . set ( [string] , False ) [EOL] [EOL] [EOL] class DetectIndentationEventListener ( sublime_plugin . EventListener ) : [EOL] def on_load ( self , view ) : [EOL] if view . settings ( ) . get ( [string] ) : [EOL] is_at_front = ( view . window ( ) is not None and view . window ( ) . active_view ( ) == view ) [EOL] view . run_command ( [string] , { [string] : is_at_front } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Any [EOL] import typing [EOL] import os . path [EOL] import platform [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def compare_file_names ( x , y ) : [EOL] if platform . system ( ) == [string] or platform . system ( ) == [string] : [EOL] return x . lower ( ) == y . lower ( ) [EOL] else : [EOL] return x == y [EOL] [EOL] [EOL] class SwitchFileCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , extensions = [ ] ) : [EOL] if not self . window . active_view ( ) : [EOL] return [EOL] [EOL] fname = self . window . active_view ( ) . file_name ( ) [EOL] if not fname : [EOL] return [EOL] [EOL] base , ext = os . path . splitext ( fname ) [EOL] [EOL] start = [number] [EOL] count = len ( extensions ) [EOL] [EOL] if ext != [string] : [EOL] ext = ext [ [number] : ] [EOL] [EOL] for i in range ( [number] , len ( extensions ) ) : [EOL] if compare_file_names ( extensions [ i ] , ext ) : [EOL] start = i + [number] [EOL] count -= [number] [EOL] break [EOL] [EOL] for i in range ( [number] , count ) : [EOL] idx = ( start + i ) % len ( extensions ) [EOL] [EOL] new_path = base + [string] + extensions [ idx ] [EOL] [EOL] if os . path . exists ( new_path ) : [EOL] self . window . open_file ( new_path , flags = sublime . FORCE_GROUP ) [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class CopyPathCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] if len ( self . view . file_name ( ) ) > [number] : [EOL] sublime . set_clipboard ( self . view . file_name ( ) ) [EOL] sublime . status_message ( [string] ) [EOL] [EOL] def is_enabled ( self ) : [EOL] return self . view . file_name ( ) is not None and len ( self . view . file_name ( ) ) > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os . path [EOL] [EOL] import sublime_plugin [EOL] [EOL] [EOL] class SaveOnFocusLost ( sublime_plugin . EventListener ) : [EOL] def on_deactivated_async ( self , view ) : [EOL] fname = view . file_name ( ) [EOL] [EOL] if not fname or not view . is_dirty ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] if view . settings ( ) . get ( [string] ) is True and os . path . exists ( fname ) : [EOL] view . run_command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import base64 [EOL] import binascii [EOL] import os [EOL] import threading [EOL] from urllib . error import URLError [EOL] from urllib . request import build_opener , install_opener , ProxyHandler , urlopen [EOL] [EOL] import sublime [EOL] import sublime_api [EOL] import sublime_plugin [EOL] [EOL] [EOL] class InstallPackageControlCommand ( sublime_plugin . ApplicationCommand ) : [EOL] [EOL] error_prefix = [string] [EOL] filename = [string] [EOL] public_key = ( [string] [string] ) [EOL] [EOL] def run ( self ) : [EOL] threading . Thread ( target = self . _install ) . start ( ) [EOL] [EOL] def is_visible ( self ) : [EOL] ipp_path = os . path . join ( sublime . installed_packages_path ( ) , self . filename ) [EOL] p_path = os . path . join ( sublime . packages_path ( ) , self . filename . replace ( [string] , [string] ) ) [EOL] [EOL] return not os . path . exists ( ipp_path ) and not os . path . exists ( p_path ) [EOL] [EOL] def _install ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] package_data = self . _download ( ) [EOL] if package_data is None : [EOL] sublime . set_timeout ( self . _show_error , [number] ) [EOL] return [EOL] [EOL] dest = os . path . join ( sublime . installed_packages_path ( ) , self . filename ) [EOL] [EOL] with open ( dest , [string] ) as f : [EOL] f . write ( package_data ) [EOL] [EOL] sublime . set_timeout ( self . _show_success , [number] ) [EOL] [EOL] except (Exception) as e : [EOL] print ( self . error_prefix + str ( e ) ) [EOL] sublime . set_timeout ( self . _show_error , [number] ) [EOL] [EOL] def _show_success ( self ) : [EOL] [docstring] [EOL] [EOL] sublime . message_dialog ( [string] [string] ) [EOL] [EOL] def _show_error ( self ) : [EOL] [docstring] [EOL] [EOL] sublime . error_message ( [string] [string] [string] ) [EOL] [EOL] def _download ( self ) : [EOL] [docstring] [EOL] [EOL] host_path = [string] + self . filename . replace ( [string] , [string] ) [EOL] [comment] [EOL] secure_url = [string] + host_path [EOL] insecure_url = [string] + host_path [EOL] [EOL] secure_sig_url = secure_url + [string] [EOL] insecure_sig_url = insecure_url + [string] [EOL] [EOL] install_opener ( build_opener ( ProxyHandler ( ) ) ) [EOL] [EOL] try : [EOL] package_data = urlopen ( secure_url ) . read ( ) [EOL] sig_data = urlopen ( secure_sig_url ) . read ( ) [EOL] except (URLError) as e : [EOL] print ( [string] % ( self . error_prefix , str ( e ) ) ) [EOL] try : [EOL] package_data = urlopen ( insecure_url ) . read ( ) [EOL] sig_data = urlopen ( insecure_sig_url ) . read ( ) [EOL] except (URLError) as e2 : [EOL] print ( [string] % ( self . error_prefix , str ( e2 ) ) ) [EOL] return None [EOL] [EOL] return self . _verify ( package_data , sig_data ) [EOL] [EOL] def _verify ( self , package_data , sig_data ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] armored_sig = sig_data . decode ( [string] ) . strip ( ) [EOL] except (UnicodeDecodeError) : [EOL] print ( self . error_prefix + [string] ) [EOL] return None [EOL] [EOL] begin = [string] [EOL] end = [string] [EOL] pem_error = self . error_prefix + [string] [EOL] [EOL] b64_sig = [string] [EOL] [EOL] in_body = None [EOL] for line in armored_sig . splitlines ( ) : [EOL] if not in_body : [EOL] if line != begin : [EOL] print ( pem_error ) [EOL] return None [EOL] in_body = True [EOL] [EOL] else : [EOL] if line . startswith ( [string] ) : [EOL] if line != end : [EOL] print ( pem_error ) [EOL] return None [EOL] break [EOL] b64_sig += line [EOL] [EOL] try : [EOL] sig = base64 . b64decode ( b64_sig ) [EOL] except ( binascii . Error ) : [EOL] print ( self . error_prefix + [string] ) [EOL] return None [EOL] [EOL] public_key = base64 . b64decode ( self . public_key ) [EOL] if not sublime_api . verify_pc_signature ( package_data , sig , public_key ) : [EOL] print ( self . error_prefix + [string] ) [EOL] return None [EOL] [EOL] return package_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime_plugin [EOL] [EOL] [EOL] class DuplicateLineCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] for region in self . view . sel ( ) : [EOL] if region . empty ( ) : [EOL] line = self . view . line ( region ) [EOL] line_contents = self . view . substr ( line ) + [string] [EOL] self . view . insert ( edit , line . begin ( ) , line_contents ) [EOL] else : [EOL] self . view . insert ( edit , region . begin ( ) , self . view . substr ( region ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import codecs [EOL] import string [EOL] [EOL] import sublime_plugin [EOL] [EOL] [EOL] class Transformer ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] view = self . view [EOL] for s in view . sel ( ) : [EOL] if s . empty ( ) : [EOL] s = view . word ( s ) [EOL] [EOL] txt = self . transformer ( view . substr ( s ) ) [EOL] view . replace ( edit , s , txt ) [EOL] [EOL] [EOL] class SwapCaseCommand ( Transformer ) : [EOL] @ staticmethod def transformer ( s ) : [EOL] return s . swapcase ( ) [EOL] [EOL] [EOL] class UpperCaseCommand ( Transformer ) : [EOL] @ staticmethod def transformer ( s ) : [EOL] return s . upper ( ) [EOL] [EOL] [EOL] class LowerCaseCommand ( Transformer ) : [EOL] @ staticmethod def transformer ( s ) : [EOL] return s . lower ( ) [EOL] [EOL] [EOL] class TitleCaseCommand ( Transformer ) : [EOL] @ staticmethod def transformer ( s ) : [EOL] return string . capwords ( s , [string] ) [EOL] [EOL] [EOL] class Rot13Command ( Transformer ) : [EOL] @ staticmethod def transformer ( s ) : [EOL] return codecs . encode ( s , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Iterator , List , Dict , Any [EOL] import typing [EOL] import os [EOL] import plistlib [EOL] import sys [EOL] [EOL] try : [EOL] import yaml [EOL] except ImportError : [EOL] pass [EOL] [EOL] [EOL] def needs_yaml_quoting ( s ) : [EOL] return ( s == [string] or s [ [number] ] in [string] or s . startswith ( [string] ) or s in [ [string] , [string] , [string] ] or [string] in s or [string] in s or [string] in s or [string] in s or [string] in s or [string] in s or [string] in s or s [ - [number] ] in [string] or s . strip ( ) != s ) [EOL] [EOL] [EOL] def quote ( s ) : [EOL] if [string] in s or [string] in s : [EOL] return [string] + s . replace ( [string] , [string] ) + [string] [EOL] else : [EOL] return [string] + s . replace ( [string] , [string] ) . replace ( [string] , [string] ) + [string] [EOL] [EOL] [EOL] def order_keys ( l ) : [EOL] key_order = reversed ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] l = sorted ( l ) [EOL] for key in key_order : [EOL] if key in l : [EOL] del l [ l . index ( key ) ] [EOL] l . insert ( [number] , key ) [EOL] return l [EOL] [EOL] [EOL] def to_yaml ( val , start_block_on_newline = False , indent = [number] ) : [EOL] tab_size = [number] [EOL] out = [string] [EOL] [EOL] if indent == [number] : [EOL] out += [string] [EOL] out += [string] [EOL] [EOL] if isinstance ( val , list ) : [EOL] if len ( val ) == [number] : [EOL] out += [string] [EOL] else : [EOL] if start_block_on_newline : [EOL] out += [string] [EOL] [EOL] for x in val : [EOL] out += [string] * indent [EOL] out += [string] [EOL] out += to_yaml ( x , False , indent + [number] ) [EOL] elif isinstance ( val , dict ) : [EOL] if start_block_on_newline : [EOL] out += [string] [EOL] [EOL] first = True [EOL] for k in order_keys ( val . keys ( ) ) : [EOL] v = val [ k ] [EOL] [EOL] if not first or start_block_on_newline : [EOL] out += [string] * indent [EOL] else : [EOL] first = False [EOL] [EOL] if isinstance ( k , int ) : [EOL] out += str ( k ) [EOL] elif needs_yaml_quoting ( k ) : [EOL] out += quote ( k ) [EOL] else : [EOL] out += k [EOL] [EOL] out += [string] [EOL] out += to_yaml ( v , True , indent + tab_size ) [EOL] elif isinstance ( val , str ) : [EOL] if needs_yaml_quoting ( val ) : [EOL] if [string] in val : [EOL] assert (start_block_on_newline) [EOL] if start_block_on_newline : [EOL] if val [ - [number] ] == [string] : [EOL] out += [string] [EOL] else : [EOL] out += [string] [EOL] for l in val . splitlines ( ) : [EOL] out += [string] * indent [EOL] out += l [EOL] out += [string] [EOL] else : [EOL] out += quote ( val ) [EOL] out += [string] [EOL] else : [EOL] out += val [EOL] out += [string] [EOL] elif isinstance ( val , bool ) : [EOL] if val : [EOL] out += [string] [EOL] else : [EOL] out += [string] [EOL] else : [EOL] out += str ( val ) + [string] [EOL] return out [EOL] [EOL] [EOL] def build_scope_map ( ) : [EOL] syntax_by_scope = { } [EOL] for f in sublime . find_resources ( [string] ) : [EOL] try : [EOL] s = sublime . load_resource ( f ) [EOL] l = plistlib . readPlistFromBytes ( s . encode ( [string] ) ) [EOL] if [string] in l : [EOL] fname = os . path . splitext ( f ) [ [number] ] + [string] [EOL] syntax_by_scope [ l [ [string] ] ] = os . path . basename ( fname ) [EOL] except : [EOL] pass [EOL] [EOL] return syntax_by_scope [EOL] [EOL] [EOL] scope_map = { } [EOL] [EOL] [EOL] def syntax_for_scope ( key ) : [EOL] use_scope_refs = True [EOL] if use_scope_refs : [EOL] return [string] + key [EOL] else : [EOL] global scope_map [EOL] if len ( scope_map ) == [number] : [EOL] scope_map = build_scope_map ( ) [EOL] [EOL] return scope_map [ key ] [EOL] [EOL] [EOL] def is_external_syntax ( key ) : [EOL] return key [ [number] ] not in [string] [EOL] [EOL] [EOL] def format_external_syntax ( key ) : [EOL] assert ( is_external_syntax ( key ) ) [EOL] [EOL] if [string] in key : [EOL] syntax , rule = key . split ( [string] ) [EOL] return syntax_for_scope ( syntax ) + [string] + rule [EOL] else : [EOL] return syntax_for_scope ( key ) [EOL] [EOL] [EOL] def leading_whitespace ( s ) : [EOL] return s [ [number] : len ( s ) - len ( s . lstrip ( ) ) ] [EOL] [EOL] [EOL] def format_regex ( s ) : [EOL] if [string] in s : [EOL] lines = s . splitlines ( ) [EOL] [EOL] [comment] [EOL] if len ( lines ) > [number] : [EOL] common_indent = leading_whitespace ( lines [ [number] ] ) [EOL] for l in lines [ [number] : ] : [EOL] cur_indent = leading_whitespace ( l ) [EOL] if cur_indent . startswith ( common_indent ) : [EOL] pass [EOL] elif common_indent . startswith ( cur_indent ) : [EOL] common_indent = cur_indent [EOL] else : [EOL] common_indent = [string] [EOL] [EOL] [comment] [EOL] if not lines [ [number] ] . startswith ( common_indent ) : [EOL] lines [ [number] ] = common_indent + lines [ [number] ] . lstrip ( ) [EOL] else : [EOL] common_indent = leading_whitespace ( lines [ [number] ] ) [EOL] [EOL] s = [string] . join ( [ l [ len ( common_indent ) : ] for l in lines ] ) . rstrip ( [string] ) [EOL] [EOL] return s [EOL] [EOL] [EOL] def format_comment ( s ) : [EOL] s = s . strip ( ) . replace ( [string] , [string] ) [EOL] [EOL] if [string] in s : [EOL] s = s . rstrip ( [string] ) + [string] [EOL] [EOL] return s [EOL] [EOL] [EOL] def format_captures ( c ) : [EOL] ret = { } [EOL] for k , v in c . items ( ) : [EOL] if [string] not in v : [EOL] warn ( [string] + str ( c ) ) [EOL] continue [EOL] [EOL] try : [EOL] ret [ int ( k ) ] = v [ [string] ] [EOL] except ValueError : [EOL] warn ( [string] ) [EOL] ret [ k ] = v [ [string] ] [EOL] return ret [EOL] [EOL] [EOL] def warn ( msg ) : [EOL] print ( msg , file = sys . stderr ) [EOL] [EOL] [EOL] def make_context ( patterns , repository ) : [EOL] ctx = [ ] [EOL] for p in patterns : [EOL] if [string] in p : [EOL] entry = { } [EOL] entry [ [string] ] = format_regex ( p [ [string] ] ) [EOL] if [string] in p or [string] in p : [EOL] if [string] in p : [EOL] captures = format_captures ( p [ [string] ] ) [EOL] else : [EOL] captures = format_captures ( p [ [string] ] ) [EOL] [EOL] if [string] in captures : [EOL] entry [ [string] ] = captures [ [string] ] [EOL] del captures [ [string] ] [EOL] [EOL] if len ( captures ) > [number] : [EOL] entry [ [string] ] = captures [EOL] [EOL] end_entry = { } [EOL] end_entry [ [string] ] = format_regex ( p [ [string] ] ) [EOL] end_entry [ [string] ] = True [EOL] if [string] in p or [string] in p : [EOL] captures = format_captures ( p . get ( [string] , p . get ( [string] ) ) ) [EOL] if [string] in captures : [EOL] end_entry [ [string] ] = captures [ [string] ] [EOL] del captures [ [string] ] [EOL] [EOL] if len ( captures ) > [number] : [EOL] end_entry [ [string] ] = captures [EOL] [EOL] if [string] in end_entry [ [string] ] : [EOL] warn ( [string] [string] + end_entry [ [string] ] ) [EOL] [EOL] apply_last = False [EOL] if [string] in p and p [ [string] ] == [number] : [EOL] apply_last = True [EOL] [EOL] if [string] in p : [EOL] child_patterns = p [ [string] ] [EOL] else : [EOL] child_patterns = [ ] [EOL] [EOL] child = make_context ( child_patterns , repository ) [EOL] if apply_last : [EOL] child . append ( end_entry ) [EOL] else : [EOL] child . insert ( [number] , end_entry ) [EOL] [EOL] if [string] in p : [EOL] child . insert ( [number] , { [string] : p [ [string] ] } ) [EOL] if [string] in p : [EOL] child . insert ( [number] , { [string] : p [ [string] ] } ) [EOL] [EOL] if [string] in p : [EOL] comment = format_comment ( p [ [string] ] ) [EOL] if len ( comment ) > [number] : [EOL] entry [ [string] ] = comment [EOL] [EOL] entry [ [string] ] = child [EOL] [EOL] ctx . append ( entry ) [EOL] [EOL] elif [string] in p : [EOL] entry = { } [EOL] entry [ [string] ] = format_regex ( p [ [string] ] ) [EOL] [EOL] if [string] in p : [EOL] entry [ [string] ] = p [ [string] ] [EOL] [EOL] if [string] in p : [EOL] entry [ [string] ] = format_captures ( p [ [string] ] ) [EOL] [EOL] if [string] in p : [EOL] comment = format_comment ( p [ [string] ] ) [EOL] if len ( comment ) > [number] : [EOL] entry [ [string] ] = comment [EOL] [EOL] ctx . append ( entry ) [EOL] [EOL] elif [string] in p : [EOL] key = p [ [string] ] [EOL] [EOL] if key [ [number] ] == [string] : [EOL] key = key [ [number] : ] [EOL] if key not in repository : [EOL] raise Exception ( [string] + key ) [EOL] [EOL] ctx . append ( { [string] : key } ) [EOL] elif key == [string] : [EOL] ctx . append ( { [string] : [string] } ) [EOL] elif key == [string] : [EOL] ctx . append ( { [string] : [string] } ) [EOL] elif key [ [number] ] == [string] : [EOL] raise Exception ( [string] + key ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ctx . append ( { [string] : format_external_syntax ( key ) } ) [EOL] [EOL] else : [EOL] raise Exception ( [string] % p . keys ( ) ) [EOL] [EOL] return ctx [EOL] [EOL] [EOL] def convert ( fname ) : [EOL] if fname . startswith ( [string] ) : [EOL] s = sublime . load_resource ( fname ) [EOL] else : [EOL] with open ( fname , [string] , encoding = [string] ) as f : [EOL] s = f . read ( ) [EOL] l = plistlib . readPlistFromBytes ( s . encode ( [string] ) ) [EOL] [EOL] if [string] in l : [EOL] repository = l [ [string] ] [EOL] else : [EOL] repository = { } [EOL] [EOL] [comment] [EOL] for key , value in repository . items ( ) : [EOL] if [string] in value or [string] in value : [EOL] repository [ key ] = [ value ] [EOL] else : [EOL] repository [ key ] = value [ [string] ] [EOL] [EOL] contexts = { [string] : make_context ( l [ [string] ] , repository ) } [EOL] [EOL] for key , value in repository . items ( ) : [EOL] assert ( key != [string] ) [EOL] [EOL] contexts [ key ] = make_context ( value , repository ) [EOL] [EOL] syn = { } [EOL] [EOL] if [string] in l : [EOL] comment = format_comment ( l [ [string] ] ) [EOL] if len ( comment ) > [number] : [EOL] syn [ [string] ] = comment [EOL] [EOL] if [string] in l : [EOL] syn [ [string] ] = l [ [string] ] [EOL] [EOL] if [string] in l : [EOL] syn [ [string] ] = l [ [string] ] [EOL] [EOL] if [string] in l : [EOL] syn [ [string] ] = l [ [string] ] [EOL] [EOL] if [string] in l : [EOL] syn [ [string] ] = l [ [string] ] [EOL] [EOL] if [string] in l : [EOL] syn [ [string] ] = l [ [string] ] [EOL] [EOL] if [string] in l : [EOL] syn [ [string] ] = l [ [string] ] [EOL] [EOL] syn [ [string] ] = contexts [EOL] [EOL] return syn [EOL] [EOL] [EOL] def extract_by_key ( key , v ) : [EOL] if isinstance ( v , list ) : [EOL] ret = [ ] [EOL] for x in v : [EOL] ret . extend ( extract_by_key ( key , x ) ) [EOL] return ret [EOL] elif isinstance ( v , dict ) : [EOL] ret = [ ] [EOL] for k , x in v . items ( ) : [EOL] if k == key : [EOL] ret . append ( x ) [EOL] else : [EOL] ret . extend ( extract_by_key ( key , x ) ) [EOL] return ret [EOL] else : [EOL] return [ ] [EOL] [EOL] [EOL] def find_external_refs ( ) : [EOL] refmap = { } [EOL] for f in sublime . find_resources ( [string] ) : [EOL] l = convert ( f ) [EOL] refmap [ f ] = extract_by_key ( [string] , l ) [EOL] print ( to_yaml ( refmap , False , [number] ) ) [EOL] [EOL] [EOL] try : [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] class ConvertSyntaxCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self ) : [EOL] view = self . window . active_view ( ) [EOL] if not view : [EOL] return [EOL] [EOL] syn = self . syntax_info ( view ) [EOL] if not syn : [EOL] return [EOL] base , ext = os . path . splitext ( syn ) [EOL] [EOL] data = to_yaml ( convert ( syn ) ) [EOL] [EOL] [comment] [EOL] data = [string] . join ( l . rstrip ( ) for l in data . splitlines ( ) ) + [string] [EOL] [EOL] v = self . window . new_file ( ) [EOL] v . set_name ( os . path . basename ( base ) + [string] ) [EOL] v . assign_syntax ( [string] ) [EOL] v . settings ( ) . set ( [string] , os . path . join ( sublime . packages_path ( ) , [string] ) ) [EOL] v . run_command ( [string] , { [string] : data } ) [EOL] [EOL] def is_visible ( self ) : [EOL] view = self . window . active_view ( ) [EOL] if not view : [EOL] return False [EOL] [EOL] syn = self . syntax_info ( view ) [EOL] return syn is not None [EOL] [EOL] def description ( self ) : [EOL] view = self . window . active_view ( ) [EOL] if not view : [EOL] return super ( ) . description ( ) [EOL] [EOL] syn = self . syntax_info ( view ) [EOL] if not syn : [EOL] return super ( ) . description ( ) [EOL] [EOL] return [string] + os . path . basename ( syn ) + [string] [EOL] [EOL] def syntax_info ( self , view ) : [EOL] syn = view . settings ( ) . get ( [string] ) [EOL] if syn . endswith ( [string] ) : [EOL] return syn [EOL] [EOL] fname = view . file_name ( ) [EOL] if fname and fname . endswith ( [string] ) : [EOL] return fname [EOL] [EOL] return None [EOL] [EOL] [EOL] except ImportError : [EOL] import fnmatch [EOL] [EOL] class sublime : [EOL] base_path = [string] [EOL] [EOL] @ classmethod def find_resources ( cls , pattern ) : [EOL] paths = [ ] [EOL] for root , dirs , files in os . walk ( cls . base_path ) : [EOL] for fname in files : [EOL] if fnmatch . fnmatch ( fname , pattern ) : [EOL] path = os . path . join ( root , fname ) [EOL] [EOL] if path [ [number] : [number] ] == [string] or path [ [number] : [number] ] == [string] : [EOL] path = path [ [number] : ] [EOL] [EOL] paths . append ( path ) [EOL] return paths [EOL] [EOL] @ staticmethod def load_resource ( fname ) : [EOL] with open ( fname , [string] , encoding = [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] if __name__ == [string] : [EOL] args = sys . argv [ [number] : ] [EOL] [EOL] if not args : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] else : [EOL] filenames = [ ] [EOL] for path in args : [EOL] if os . path . isdir ( path ) : [EOL] sublime . base_path = path [EOL] filenames . extend ( sublime . find_resources ( [string] ) ) [EOL] else : [EOL] filenames . append ( path ) [EOL] [EOL] for fname in filenames : [EOL] outfile = os . path . splitext ( fname ) [ [number] ] + [string] [EOL] if os . path . exists ( outfile ) : [EOL] print ( [string] + outfile ) [EOL] continue [EOL] [EOL] data = convert ( fname ) [EOL] text = to_yaml ( data ) [EOL] [comment] [EOL] if [string] in sys . modules : [EOL] assert ( data == yaml . load ( text ) ) [EOL] [EOL] with open ( outfile , [string] , encoding = [string] ) as f : [EOL] [comment] [EOL] text = [string] . join ( l . rstrip ( ) for l in text . splitlines ( ) ) + [string] [EOL] f . write ( text ) [EOL] [EOL] print ( [string] + outfile ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Iterator , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def next_line ( view , pt ) : [EOL] return view . line ( pt ) . b + [number] [EOL] [EOL] [EOL] def prev_line ( view , pt ) : [EOL] return view . line ( pt ) . a - [number] [EOL] [EOL] [EOL] def is_ws ( str ) : [EOL] for ch in str : [EOL] if ch != [string] and ch != [string] : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def indented_block ( view , r ) : [EOL] if r . empty ( ) : [EOL] if r . a == view . size ( ) : [EOL] return False [EOL] [EOL] nl = next_line ( view , r . a ) [EOL] nr = view . indented_region ( nl ) [EOL] if nr . a < nl : [EOL] nr . a = nl [EOL] [EOL] this_indent = view . indentation_level ( r . a ) [EOL] next_indent = view . indentation_level ( nl ) [EOL] [EOL] ok = False [EOL] [EOL] if this_indent + [number] == next_indent : [EOL] ok = True [EOL] [EOL] if not ok : [EOL] prev_indent = view . indentation_level ( prev_line ( view , r . a ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] line_str = view . substr ( view . line ( r . a ) ) [EOL] if is_ws ( line_str ) and len ( view . get_regions ( [string] ) ) > [number] : [EOL] if prev_indent + [number] == this_indent and this_indent == next_indent : [EOL] ok = True [EOL] [EOL] if ok : [EOL] [comment] [EOL] l = next_line ( view , nl ) [EOL] while l < nr . end ( ) : [EOL] if view . indentation_level ( l ) == next_indent : [EOL] return False [EOL] l = next_line ( view , l ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class BlockContext ( sublime_plugin . EventListener ) : [EOL] def on_query_context ( self , view , key , operator , operand , match_all ) : [EOL] if key == [string] : [EOL] is_all = True [EOL] is_any = False [EOL] [EOL] if operator != sublime . OP_EQUAL and operator != sublime . OP_NOT_EQUAL : [EOL] return False [EOL] [EOL] for r in view . sel ( ) : [EOL] if operator == sublime . OP_EQUAL : [EOL] b = ( operand == indented_block ( view , r ) ) [EOL] else : [EOL] b = ( operand != indented_block ( view , r ) ) [EOL] [EOL] if b : [EOL] is_any = True [EOL] else : [EOL] is_all = False [EOL] [EOL] if match_all : [EOL] return is_all [EOL] else : [EOL] return is_any [EOL] [EOL] return None [EOL] [EOL] [EOL] class WrapBlockCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , begin , end ) : [EOL] [EOL] self . view . run_command ( [string] , { [string] : begin } ) [EOL] [EOL] regions = reversed ( [ s for s in self . view . sel ( ) ] ) [EOL] for r in regions : [EOL] if r . empty ( ) : [EOL] nl = next_line ( self . view , r . a ) [EOL] nr = self . view . indented_region ( nl ) [EOL] [EOL] begin_line = self . view . substr ( self . view . line ( r . a ) ) [EOL] [EOL] ws = [string] [EOL] for ch in begin_line : [EOL] if ch == [string] or ch == [string] : [EOL] ws += ch [EOL] else : [EOL] break [EOL] [EOL] self . view . insert ( edit , nr . end ( ) , ws + end + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
import sublime_plugin [EOL] [EOL] [EOL] class EchoCommand ( sublime_plugin . ApplicationCommand ) : [EOL] def run ( self , ** kwargs ) : [EOL] print ( kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sublime_plugin [EOL] [EOL] [EOL] class QuickPanelCommand ( sublime_plugin . WindowCommand ) : [EOL] def select_item ( self , items , idx ) : [EOL] if idx >= [number] : [EOL] self . window . run_command ( items [ idx ] [ [string] ] , items [ idx ] [ [string] ] ) [EOL] [EOL] def run ( self , items ) : [EOL] self . window . show_quick_panel ( items = [ x [ [string] ] for x in items ] , on_select = lambda idx : self . select_item ( items , idx ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime_plugin [EOL] [EOL] [EOL] class AutoIndentTagCommand ( sublime_plugin . TextCommand ) : [EOL] [EOL] def run ( self , edit ) : [EOL] view = self . view [EOL] [EOL] cursor = view . sel ( ) [ [number] ] . a [EOL] cur_line = view . line ( cursor ) [EOL] line_start = cur_line . a [EOL] end = cursor - line_start [EOL] preceeding = view . substr ( cur_line ) [EOL] [EOL] prev_tag = None [EOL] next_tag = None [EOL] [EOL] while True : [EOL] pos = preceeding . rfind ( [string] , [number] , end ) [EOL] [EOL] [comment] [EOL] if pos == - [number] : [EOL] [comment] [EOL] if line_start == [number] : [EOL] break [EOL] prev_line = view . full_line ( line_start - [number] ) [EOL] line_start = prev_line . a [EOL] preceeding = view . substr ( prev_line ) [EOL] end = len ( preceeding ) [EOL] continue [EOL] [EOL] point = line_start + pos [EOL] [EOL] if view . score_selector ( point , [string] ) > [number] : [EOL] [comment] [EOL] point = self . skip_whitespace ( point + [number] ) [EOL] [comment] [EOL] if view . substr ( point ) == [string] : [EOL] break [EOL] prev_tag = view . substr ( view . extract_scope ( point ) ) [EOL] break [EOL] [EOL] end = pos [EOL] [EOL] [comment] [EOL] point = self . skip_whitespace ( cursor + [number] ) [EOL] next_tag = view . substr ( view . extract_scope ( point ) ) [EOL] [EOL] if not prev_tag or not next_tag or prev_tag != next_tag : [EOL] view . run_command ( [string] , { [string] : [string] } ) [EOL] return [EOL] [EOL] view . run_command ( [string] , { [string] : [string] } ) [EOL] [EOL] def skip_whitespace ( self , point ) : [EOL] while self . view . substr ( point ) in { [string] , [string] , [string] } : [EOL] point += [number] [EOL] return point [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def expand_to_line ( view , region ) : [EOL] [docstring] [EOL] [EOL] if not ( region . a == region . b ) and view . substr ( region . end ( ) - [number] ) == [string] : [EOL] return sublime . Region ( view . line ( region ) . begin ( ) , region . end ( ) ) [EOL] else : [EOL] return view . full_line ( region ) [EOL] [EOL] [EOL] def extract_line_blocks ( view ) : [EOL] blocks = [ expand_to_line ( view , s ) for s in view . sel ( ) ] [EOL] if len ( blocks ) == [number] : [EOL] return blocks [EOL] [EOL] [comment] [EOL] merged_blocks = [ blocks [ [number] ] ] [EOL] for block in blocks [ [number] : ] : [EOL] last_block = merged_blocks [ - [number] ] [EOL] if block . begin ( ) <= last_block . end ( ) : [EOL] merged_blocks [ - [number] ] = sublime . Region ( last_block . begin ( ) , block . end ( ) ) [EOL] else : [EOL] merged_blocks . append ( block ) [EOL] [EOL] return merged_blocks [EOL] [EOL] [EOL] class SwapLineUpCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] blocks = extract_line_blocks ( self . view ) [EOL] [EOL] [comment] [EOL] if len ( blocks ) == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] if blocks [ [number] ] . begin ( ) == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] add_trailing_newline = ( self . view . substr ( self . view . size ( ) - [number] ) != [string] ) and blocks [ - [number] ] . b == self . view . size ( ) [EOL] if add_trailing_newline : [EOL] [comment] [EOL] [comment] [EOL] sel = [ r for r in self . view . sel ( ) ] [EOL] self . view . insert ( edit , self . view . size ( ) , [string] ) [EOL] if self . view . sel ( ) [ - [number] ] . end ( ) == self . view . size ( ) : [EOL] [comment] [EOL] self . view . sel ( ) . clear ( ) [EOL] for r in sel : [EOL] self . view . sel ( ) . add ( r ) [EOL] [EOL] [comment] [EOL] blocks [ - [number] ] = sublime . Region ( blocks [ - [number] ] . a , blocks [ - [number] ] . b + [number] ) [EOL] [EOL] [comment] [EOL] blocks . reverse ( ) [EOL] for b in blocks : [EOL] prev_line = self . view . full_line ( b . begin ( ) - [number] ) [EOL] self . view . insert ( edit , b . end ( ) , self . view . substr ( prev_line ) ) [EOL] self . view . erase ( edit , prev_line ) [EOL] [EOL] if add_trailing_newline : [EOL] [comment] [EOL] self . view . erase ( edit , sublime . Region ( self . view . size ( ) - [number] , self . view . size ( ) ) ) [EOL] [EOL] [comment] [EOL] self . view . show ( self . view . sel ( ) , False ) [EOL] [EOL] [EOL] class SwapLineDownCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] blocks = extract_line_blocks ( self . view ) [EOL] [EOL] [comment] [EOL] if len ( blocks ) == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] if blocks [ - [number] ] . end ( ) == self . view . size ( ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] add_trailing_newline = ( self . view . substr ( self . view . size ( ) - [number] ) != [string] ) [EOL] if add_trailing_newline : [EOL] [comment] [EOL] [comment] [EOL] self . view . insert ( edit , self . view . size ( ) , [string] ) [EOL] [EOL] [comment] [EOL] blocks . reverse ( ) [EOL] for b in blocks : [EOL] next_line = self . view . full_line ( b . end ( ) ) [EOL] contents = self . view . substr ( next_line ) [EOL] [EOL] self . view . erase ( edit , next_line ) [EOL] self . view . insert ( edit , b . begin ( ) , contents ) [EOL] [EOL] if add_trailing_newline : [EOL] [comment] [EOL] self . view . erase ( edit , sublime . Region ( self . view . size ( ) - [number] , self . view . size ( ) ) ) [EOL] [EOL] [comment] [EOL] self . view . show ( self . view . sel ( ) , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class KillRing : [EOL] def __init__ ( self ) : [EOL] self . limit = [number] [EOL] self . buffer = [ None for i in range ( self . limit ) ] [EOL] self . head = [number] [EOL] self . len = [number] [EOL] self . kill_points = [ ] [EOL] self . kill_id = [number] [EOL] [EOL] def top ( self ) : [EOL] return self . buffer [ self . head ] [EOL] [EOL] def seal ( self ) : [EOL] self . kill_points = [ ] [EOL] self . kill_id = [number] [EOL] [EOL] def push ( self , text ) : [EOL] self . head = ( self . head + [number] ) % self . limit [EOL] self . buffer [ self . head ] = text [EOL] if self . len < self . limit : [EOL] self . len += [number] [EOL] [EOL] def add ( self , view_id , text , regions , forward ) : [EOL] if view_id != self . kill_id : [EOL] [comment] [EOL] [comment] [EOL] self . seal ( ) [EOL] [EOL] begin_points = [ ] [EOL] end_points = [ ] [EOL] for r in regions : [EOL] begin_points . append ( r . begin ( ) ) [EOL] end_points . append ( r . end ( ) ) [EOL] [EOL] if forward : [EOL] compare_points = begin_points [EOL] else : [EOL] compare_points = end_points [EOL] [EOL] if compare_points == self . kill_points : [EOL] [comment] [EOL] [comment] [EOL] if forward : [EOL] self . buffer [ self . head ] = self . buffer [ self . head ] + text [EOL] else : [EOL] self . buffer [ self . head ] = text + self . buffer [ self . head ] [EOL] else : [EOL] [comment] [EOL] self . push ( text ) [EOL] [EOL] self . kill_points = begin_points [EOL] self . kill_id = view_id [EOL] [EOL] def get ( self , index ) : [EOL] return self . buffer [ ( self . head + index ) % self . limit ] [EOL] [EOL] def __len__ ( self ) : [EOL] return self . len [EOL] [EOL] [EOL] kill_ring = KillRing ( ) [EOL] [EOL] [EOL] class YankCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] kill_ring . seal ( ) [EOL] text = kill_ring . top ( ) [EOL] [EOL] lines = text . splitlines ( ) [EOL] [EOL] regions = [ r for r in self . view . sel ( ) ] [EOL] regions . reverse ( ) [EOL] [EOL] if len ( regions ) > [number] and len ( regions ) == len ( lines ) : [EOL] [comment] [EOL] [comment] [EOL] for i in range ( len ( regions ) ) : [EOL] s = regions [ i ] [EOL] line = lines [ i ] [EOL] num = self . view . insert ( edit , s . begin ( ) , line ) [EOL] self . view . erase ( edit , sublime . Region ( s . begin ( ) + num , s . end ( ) + num ) ) [EOL] else : [EOL] [comment] [EOL] for s in regions : [EOL] num = self . view . insert ( edit , s . begin ( ) , text ) [EOL] self . view . erase ( edit , sublime . Region ( s . begin ( ) + num , s . end ( ) + num ) ) [EOL] [EOL] def is_enabled ( self ) : [EOL] return len ( kill_ring ) > [number] [EOL] [EOL] [EOL] class AddToKillRingCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , forward ) : [EOL] delta = [number] [EOL] if not forward : [EOL] delta = - [number] [EOL] [EOL] text = [ ] [EOL] regions = [ ] [EOL] for s in self . view . sel ( ) : [EOL] if s . empty ( ) : [EOL] s = sublime . Region ( s . a , s . a + delta ) [EOL] text . append ( self . view . substr ( s ) ) [EOL] regions . append ( s ) [EOL] [EOL] kill_ring . add ( self . view . id ( ) , [string] . join ( text ) , regions , forward ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0
from typing import Literal , Any , Union , List , Dict [EOL] import typing_extensions [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def lookup_symbol ( window , symbol ) : [EOL] if len ( symbol . strip ( ) ) < [number] : [EOL] return [ ] [EOL] [EOL] index_locations = window . lookup_symbol_in_index ( symbol ) [EOL] open_file_locations = window . lookup_symbol_in_open_files ( symbol ) [EOL] [EOL] def file_in_location_list ( fname , locations ) : [EOL] for l in locations : [EOL] if l [ [number] ] == fname : [EOL] return True [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] locations = [ ] [EOL] ofl_ignore = [ ] [EOL] for l in index_locations : [EOL] if file_in_location_list ( l [ [number] ] , open_file_locations ) : [EOL] if not file_in_location_list ( l [ [number] ] , ofl_ignore ) : [EOL] for ofl in open_file_locations : [EOL] if l [ [number] ] == ofl [ [number] ] : [EOL] locations . append ( ofl ) [EOL] ofl_ignore . append ( ofl ) [EOL] else : [EOL] locations . append ( l ) [EOL] [EOL] for ofl in open_file_locations : [EOL] if not file_in_location_list ( ofl [ [number] ] , ofl_ignore ) : [EOL] locations . append ( ofl ) [EOL] [EOL] return locations [EOL] [EOL] [EOL] def symbol_at_point ( view , pt ) : [EOL] symbol = view . substr ( view . expand_by_class ( pt , sublime . CLASS_WORD_START | sublime . CLASS_WORD_END , [string] ) ) [EOL] locations = lookup_symbol ( view . window ( ) , symbol ) [EOL] [EOL] if len ( locations ) == [number] : [EOL] symbol = view . substr ( view . word ( pt ) ) [EOL] locations = lookup_symbol ( view . window ( ) , symbol ) [EOL] [EOL] return symbol , locations [EOL] [EOL] [EOL] def open_location ( window , l ) : [EOL] fname , display_fname , rowcol = l [EOL] row , col = rowcol [EOL] [EOL] window . open_file ( fname + [string] + str ( row ) + [string] + str ( col ) , sublime . ENCODED_POSITION | sublime . FORCE_GROUP ) [EOL] [EOL] [EOL] def format_location ( l ) : [EOL] fname , display_fname , rowcol = l [EOL] row , col = rowcol [EOL] [EOL] return display_fname + [string] + str ( row ) [EOL] [EOL] [EOL] def location_href ( l ) : [EOL] return [string] % ( l [ [number] ] , l [ [number] ] [ [number] ] , l [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] def filter_current_symbol ( view , point , symbol , locations ) : [EOL] [docstring] [EOL] [EOL] def match_view ( path , view ) : [EOL] fname = view . file_name ( ) [EOL] if fname is None : [EOL] if path . startswith ( [string] ) : [EOL] path_view = view . window ( ) . find_open_file ( path ) [EOL] return path_view and path_view . id ( ) == view . id ( ) [EOL] return False [EOL] return path == fname [EOL] [EOL] new_locations = [ ] [EOL] for l in locations : [EOL] if match_view ( l [ [number] ] , view ) : [EOL] symbol_begin_pt = view . text_point ( l [ [number] ] [ [number] ] - [number] , l [ [number] ] [ [number] ] ) [EOL] symbol_end_pt = symbol_begin_pt + len ( symbol ) [EOL] if point >= symbol_begin_pt and point <= symbol_end_pt : [EOL] continue [EOL] new_locations . append ( l ) [EOL] return new_locations [EOL] [EOL] [EOL] def navigate_to_symbol ( view , symbol , locations ) : [EOL] def select_entry ( window , locations , idx , orig_view , orig_sel ) : [EOL] if idx >= [number] : [EOL] open_location ( window , locations [ idx ] ) [EOL] else : [EOL] if orig_view : [EOL] orig_view . sel ( ) . clear ( ) [EOL] orig_view . sel ( ) . add_all ( orig_sel ) [EOL] window . focus_view ( orig_view ) [EOL] orig_view . show ( orig_sel [ [number] ] ) [EOL] [EOL] def highlight_entry ( window , locations , idx ) : [EOL] fname , display_fname , rowcol = locations [ idx ] [EOL] row , col = rowcol [EOL] [EOL] window . open_file ( fname + [string] + str ( row ) + [string] + str ( col ) , group = window . active_group ( ) , flags = sublime . TRANSIENT | sublime . ENCODED_POSITION | sublime . FORCE_GROUP ) [EOL] [EOL] orig_sel = None [EOL] if view : [EOL] orig_sel = [ r for r in view . sel ( ) ] [EOL] [EOL] if len ( locations ) == [number] : [EOL] sublime . status_message ( [string] + symbol ) [EOL] elif len ( locations ) == [number] : [EOL] open_location ( view . window ( ) , locations [ [number] ] ) [EOL] else : [EOL] window = view . window ( ) [EOL] window . show_quick_panel ( items = [ format_location ( l ) for l in locations ] , on_select = lambda x : select_entry ( window , locations , x , view , orig_sel ) , on_highlight = lambda x : highlight_entry ( window , locations , x ) , flags = sublime . KEEP_OPEN_ON_FOCUS_LOST ) [EOL] [EOL] [EOL] class GotoDefinition ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , symbol = None ) : [EOL] v = self . window . active_view ( ) [EOL] [EOL] if not symbol and not v : [EOL] return [EOL] [EOL] if not symbol : [EOL] pt = v . sel ( ) [ [number] ] [EOL] symbol , locations = symbol_at_point ( v , pt ) [EOL] else : [EOL] locations = lookup_symbol ( self . window , symbol ) [EOL] [EOL] navigate_to_symbol ( v , symbol , locations ) [EOL] [EOL] [EOL] class ContextGotoDefinitionCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , event ) : [EOL] pt = self . view . window_to_text ( ( event [ [string] ] , event [ [string] ] ) ) [EOL] [EOL] symbol , locations = symbol_at_point ( self . view , pt ) [EOL] [EOL] navigate_to_symbol ( self . view , symbol , locations ) [EOL] [EOL] def is_visible ( self , event ) : [EOL] pt = self . view . window_to_text ( ( event [ [string] ] , event [ [string] ] ) ) [EOL] symbol , locations = symbol_at_point ( self . view , pt ) [EOL] [EOL] return len ( locations ) > [number] [EOL] [EOL] def want_event ( self ) : [EOL] return True [EOL] [EOL] [EOL] class ShowDefinitions ( sublime_plugin . EventListener ) : [EOL] def on_hover ( self , view , point , hover_zone ) : [EOL] if not view . settings ( ) . get ( [string] ) : [EOL] return [EOL] [EOL] if hover_zone != sublime . HOVER_TEXT : [EOL] return [EOL] [EOL] def score ( scopes ) : [EOL] return view . score_selector ( point , scopes ) [EOL] [EOL] [comment] [EOL] if score ( [string] ) and not score ( [string] ) : [EOL] is_class = score ( [string] ) [EOL] is_id = score ( [string] ) [EOL] if not is_class and not is_id : [EOL] return [EOL] else : [EOL] if not score ( [string] ) : [EOL] return [EOL] if score ( [string] ) : [EOL] return [EOL] [comment] [EOL] if score ( [string] ) and not score ( [string] ) : [EOL] return [EOL] [EOL] symbol , locations = symbol_at_point ( view , point ) [EOL] locations = filter_current_symbol ( view , point , symbol , locations ) [EOL] if not locations : [EOL] return [EOL] [EOL] location_map = { location_href ( l ) : l for l in locations } [EOL] [EOL] def on_navigate ( href ) : [EOL] open_location ( view . window ( ) , location_map [ href ] ) [EOL] [EOL] links = [ ] [EOL] for l in locations : [EOL] links . append ( [string] % ( location_href ( l ) , format_location ( l ) ) ) [EOL] links = [string] . join ( links ) [EOL] plural = [string] if len ( locations ) > [number] else [string] [EOL] [EOL] body = [string] % ( plural , links ) [EOL] [EOL] view . show_popup ( body , flags = sublime . HIDE_ON_MOUSE_MOVE_AWAY , location = point , on_navigate = on_navigate , max_width = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def copy ( view , text ) : [EOL] sublime . set_clipboard ( text ) [EOL] view . hide_popup ( ) [EOL] sublime . status_message ( [string] ) [EOL] [EOL] [EOL] class ShowScopeNameCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] scope = self . view . scope_name ( self . view . sel ( ) [ - [number] ] . b ) [EOL] [EOL] html = [string] % ( scope . replace ( [string] , [string] ) , scope . rstrip ( ) ) [EOL] [EOL] self . view . show_popup ( html , max_width = [number] , on_navigate = lambda x : copy ( self . view , x ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import os . path [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class EditSettingsCommand ( sublime_plugin . ApplicationCommand ) : [EOL] def run ( self , base_file , user_file = None , default = None ) : [EOL] [docstring] [EOL] [EOL] if base_file is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] platform_name = { [string] : [string] , [string] : [string] , [string] : [string] , } [ sublime . platform ( ) ] [EOL] [EOL] variables = { [string] : [string] , [string] : platform_name , } [EOL] [EOL] base_file = sublime . expand_variables ( base_file . replace ( [string] , [string] ) , variables ) [EOL] if user_file is not None : [EOL] user_file = sublime . expand_variables ( user_file . replace ( [string] , [string] ) , variables ) [EOL] [EOL] base_path = base_file . replace ( [string] , [string] ) [EOL] is_resource = base_path . startswith ( [string] ) [EOL] file_name = os . path . basename ( base_file ) [EOL] resource_exists = is_resource and base_path [ [number] : ] in sublime . find_resources ( file_name ) [EOL] filesystem_exists = ( not is_resource ) and os . path . exists ( base_path ) [EOL] [EOL] if not resource_exists and not filesystem_exists : [EOL] sublime . error_message ( [string] + base_path + [string] ) [EOL] return [EOL] [EOL] if user_file is None : [EOL] user_package_path = os . path . join ( sublime . packages_path ( ) , [string] ) [EOL] user_file = os . path . join ( user_package_path , file_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not os . path . exists ( os . path . join ( user_package_path , file_name ) ) : [EOL] for suffix in { [string] , [string] , [string] } : [EOL] platform_suffix = [string] % ( platform_name , suffix ) [EOL] if not file_name . endswith ( platform_suffix ) : [EOL] continue [EOL] non_platform_file_name = file_name [ : - len ( platform_suffix ) ] + suffix [EOL] non_platform_path = os . path . join ( user_package_path , non_platform_file_name ) [EOL] if os . path . exists ( non_platform_path ) : [EOL] user_file = non_platform_path [EOL] break [EOL] [EOL] sublime . run_command ( [string] ) [EOL] new_window = sublime . active_window ( ) [EOL] [EOL] new_window . run_command ( [string] , { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] } ) [EOL] new_window . focus_group ( [number] ) [EOL] new_window . run_command ( [string] , { [string] : base_file } ) [EOL] new_window . focus_group ( [number] ) [EOL] new_window . run_command ( [string] , { [string] : user_file , [string] : default } ) [EOL] [EOL] new_window . set_tabs_visible ( True ) [EOL] new_window . set_sidebar_visible ( False ) [EOL] [EOL] base_view = new_window . active_view_in_group ( [number] ) [EOL] user_view = new_window . active_view_in_group ( [number] ) [EOL] [EOL] base_settings = base_view . settings ( ) [EOL] base_settings . set ( [string] , [string] ) [EOL] base_settings . set ( [string] , user_view . id ( ) ) [EOL] [EOL] user_settings = user_view . settings ( ) [EOL] user_settings . set ( [string] , [string] ) [EOL] user_settings . set ( [string] , base_view . id ( ) ) [EOL] if not os . path . exists ( user_file ) : [EOL] user_view . set_scratch ( True ) [EOL] user_settings . set ( [string] , default . replace ( [string] , [string] ) ) [EOL] [EOL] [EOL] class EditSyntaxSettingsCommand ( sublime_plugin . WindowCommand ) : [EOL] [docstring] [EOL] [EOL] def run ( self ) : [EOL] view = self . window . active_view ( ) [EOL] syntax , _ = os . path . splitext ( os . path . basename ( view . settings ( ) . get ( [string] ) ) ) [EOL] self . window . run_command ( [string] , { [string] : [string] , [string] : os . path . join ( sublime . packages_path ( ) , [string] , syntax + [string] ) , [string] : ( [string] [string] ) % syntax } ) [EOL] [EOL] def is_enabled ( self ) : [EOL] return self . window . active_view ( ) is not None [EOL] [EOL] [EOL] class EditSettingsListener ( sublime_plugin . EventListener ) : [EOL] [docstring] [EOL] [EOL] def on_modified ( self , view ) : [EOL] [docstring] [EOL] [EOL] view_settings = view . settings ( ) [EOL] [EOL] settings_view_type = view_settings . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if settings_view_type == [string] and view . is_scratch ( ) : [EOL] file_region = sublime . Region ( [number] , view . size ( ) ) [EOL] if view_settings . get ( [string] ) != view . substr ( file_region ) : [EOL] view . set_scratch ( False ) [EOL] [EOL] def on_pre_close ( self , view ) : [EOL] [docstring] [EOL] [EOL] view_settings = view . settings ( ) [EOL] [EOL] if not view_settings . get ( [string] ) : [EOL] return [EOL] [EOL] if view . window ( ) is None : [EOL] return [EOL] [EOL] view_settings . set ( [string] , view . window ( ) . id ( ) ) [EOL] [EOL] def on_close ( self , view ) : [EOL] [docstring] [EOL] [EOL] view_settings = view . settings ( ) [EOL] [EOL] if not view_settings . get ( [string] ) : [EOL] return [EOL] [EOL] window_id = view_settings . get ( [string] ) [EOL] window = None [EOL] for win in sublime . windows ( ) : [EOL] if win . id ( ) == window_id : [EOL] window = win [EOL] break [EOL] [EOL] if not window : [EOL] return [EOL] [EOL] other_view_id = view_settings . get ( [string] ) [EOL] views = window . views ( ) [EOL] views_left = len ( views ) [EOL] for other in views : [EOL] if other . id ( ) == other_view_id : [EOL] window . focus_view ( other ) [EOL] [comment] [EOL] other . settings ( ) . erase ( [string] ) [EOL] [comment] [EOL] sublime . set_timeout ( lambda : window . run_command ( [string] ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if views_left == [number] and len ( window . folders ( ) ) < [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def close_window ( ) : [EOL] if window . id ( ) == sublime . active_window ( ) . id ( ) : [EOL] window . run_command ( [string] ) [EOL] sublime . set_timeout ( close_window , [number] ) [EOL] [EOL] [EOL] class OpenFileSettingsCommand ( sublime_plugin . WindowCommand ) : [EOL] [docstring] [EOL] [EOL] def run ( self ) : [EOL] view = self . window . active_view ( ) [EOL] settings_name , _ = os . path . splitext ( os . path . basename ( view . settings ( ) . get ( [string] ) ) ) [EOL] dir_name = os . path . join ( sublime . packages_path ( ) , [string] ) [EOL] self . window . open_file ( os . path . join ( dir_name , settings_name + [string] ) ) [EOL] [EOL] def is_enabled ( self ) : [EOL] return self . window . active_view ( ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import functools [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class NewFileAtCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , dirs ) : [EOL] v = self . window . new_file ( ) [EOL] [EOL] if len ( dirs ) == [number] : [EOL] v . settings ( ) . set ( [string] , dirs [ [number] ] ) [EOL] [EOL] def is_visible ( self , dirs ) : [EOL] return len ( dirs ) == [number] [EOL] [EOL] [EOL] class DeleteFileCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , files ) : [EOL] [comment] [EOL] import Default . send2trash as send2trash [EOL] for f in files : [EOL] v = self . window . find_open_file ( f ) [EOL] if v is not None and not v . close ( ) : [EOL] return [EOL] [EOL] send2trash . send2trash ( f ) [EOL] [EOL] def is_visible ( self , files ) : [EOL] return len ( files ) > [number] [EOL] [EOL] [EOL] class NewFolderCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , dirs ) : [EOL] self . window . show_input_panel ( [string] , [string] , functools . partial ( self . on_done , dirs [ [number] ] ) , None , None ) [EOL] [EOL] def on_done ( self , dir , name ) : [EOL] os . makedirs ( os . path . join ( dir , name ) , [number] ) [EOL] [EOL] def is_visible ( self , dirs ) : [EOL] return len ( dirs ) == [number] [EOL] [EOL] [EOL] class DeleteFolderCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , dirs ) : [EOL] [EOL] if len ( dirs ) == [number] : [EOL] message = [string] % dirs [ [number] ] [EOL] else : [EOL] message = [string] % len ( dirs ) [EOL] [EOL] if sublime . ok_cancel_dialog ( message , [string] ) : [EOL] import Default . send2trash as send2trash [EOL] try : [EOL] for d in dirs : [EOL] send2trash . send2trash ( d ) [EOL] except : [EOL] sublime . status_message ( [string] ) [EOL] [EOL] def is_visible ( self , dirs ) : [EOL] return len ( dirs ) > [number] [EOL] [EOL] [EOL] class RenamePathCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , paths ) : [EOL] branch , leaf = os . path . split ( paths [ [number] ] ) [EOL] v = self . window . show_input_panel ( [string] , leaf , functools . partial ( self . on_done , paths [ [number] ] , branch ) , None , None ) [EOL] name , ext = os . path . splitext ( leaf ) [EOL] [EOL] v . sel ( ) . clear ( ) [EOL] v . sel ( ) . add ( sublime . Region ( [number] , len ( name ) ) ) [EOL] [EOL] def is_case_change ( self , old , new ) : [EOL] if old . lower ( ) != new . lower ( ) : [EOL] return False [EOL] if os . stat ( old ) . st_ino != os . stat ( new ) . st_ino : [EOL] return False [EOL] return True [EOL] [EOL] def on_done ( self , old , branch , leaf ) : [EOL] new = os . path . join ( branch , leaf ) [EOL] [EOL] if new == old : [EOL] return [EOL] [EOL] try : [EOL] if os . path . isfile ( new ) and not self . is_case_change ( old , new ) : [EOL] raise OSError ( [string] ) [EOL] [EOL] os . rename ( old , new ) [EOL] [EOL] v = self . window . find_open_file ( old ) [EOL] if v : [EOL] v . retarget ( new ) [EOL] except OSError as e : [EOL] sublime . status_message ( [string] + str ( e ) ) [EOL] except : [EOL] sublime . status_message ( [string] ) [EOL] [EOL] def is_visible ( self , paths ) : [EOL] return len ( paths ) == [number] [EOL] [EOL] [EOL] class OpenContainingFolderCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , files ) : [EOL] branch , leaf = os . path . split ( files [ [number] ] ) [EOL] self . window . run_command ( [string] , { [string] : branch , [string] : leaf } ) [EOL] [EOL] def is_visible ( self , files ) : [EOL] return len ( files ) > [number] [EOL] [EOL] [EOL] class FindInFolderCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , dirs ) : [EOL] self . window . run_command ( [string] , { [string] : [string] , [string] : [string] . join ( dirs ) } ) [EOL] [EOL] def is_visible ( self , dirs ) : [EOL] return len ( dirs ) > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class PromptGotoLineCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self ) : [EOL] self . window . show_input_panel ( [string] , [string] , self . on_done , None , None ) [EOL] [EOL] def on_done ( self , text ) : [EOL] try : [EOL] line = int ( text ) [EOL] if self . window . active_view ( ) : [EOL] self . window . active_view ( ) . run_command ( [string] , { [string] : line } ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] [EOL] class GotoLineCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , line ) : [EOL] [comment] [EOL] line = int ( line ) - [number] [EOL] [EOL] [comment] [EOL] if line < [number] : [EOL] lines , _ = self . view . rowcol ( self . view . size ( ) ) [EOL] line = lines + line + [number] [EOL] [EOL] pt = self . view . text_point ( line , [number] ) [EOL] [EOL] self . view . sel ( ) . clear ( ) [EOL] self . view . sel ( ) . add ( sublime . Region ( pt ) ) [EOL] [EOL] self . view . show ( pt ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List , Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def get_tab_size ( view ) : [EOL] return int ( view . settings ( ) . get ( [string] , [number] ) ) [EOL] [EOL] [EOL] def normed_indentation_pt ( view , sel , non_space = False ) : [EOL] [docstring] [EOL] [EOL] tab_size = get_tab_size ( view ) [EOL] pos = [number] [EOL] ln = view . line ( sel ) [EOL] [EOL] for pt in range ( ln . begin ( ) , ln . end ( ) if non_space else sel . begin ( ) ) : [EOL] ch = view . substr ( pt ) [EOL] [EOL] if ch == [string] : [EOL] pos += tab_size - ( pos % tab_size ) [EOL] [EOL] elif ch . isspace ( ) : [EOL] pos += [number] [EOL] [EOL] elif non_space : [EOL] break [EOL] else : [EOL] pos += [number] [EOL] [EOL] return pos [EOL] [EOL] [EOL] def compress_column ( column ) : [EOL] [comment] [EOL] if all ( c . isspace ( ) for c in column ) : [EOL] column = [string] [EOL] [EOL] [comment] [EOL] elif column [ - [number] ] == [string] : [EOL] while column and column [ - [number] ] == [string] : [EOL] column . pop ( ) [EOL] column . append ( [string] ) [EOL] [EOL] [comment] [EOL] return column [EOL] [EOL] [EOL] def line_and_normed_pt ( view , pt ) : [EOL] return ( view . rowcol ( pt ) [ [number] ] , normed_indentation_pt ( view , sublime . Region ( pt ) ) ) [EOL] [EOL] [EOL] def pt_from_line_and_normed_pt ( view , p ) : [EOL] ln , pt = p [EOL] i = start_pt = view . text_point ( ln , [number] ) [EOL] tab_size = get_tab_size ( view ) [EOL] [EOL] pos = [number] [EOL] [EOL] for i in range ( start_pt , start_pt + pt ) : [EOL] ch = view . substr ( i ) [EOL] [EOL] if ch == [string] : [EOL] pos += tab_size - ( pos % tab_size ) [EOL] else : [EOL] pos += [number] [EOL] [EOL] i += [number] [EOL] if pos == pt : [EOL] break [EOL] [EOL] return i [EOL] [EOL] [EOL] def save_selections ( view , selections = None ) : [EOL] return [ [ line_and_normed_pt ( view , p ) for p in ( sel . a , sel . b ) ] for sel in selections or view . sel ( ) ] [EOL] [EOL] [EOL] def region_from_stored_selection ( view , stored ) : [EOL] return sublime . Region ( * [ pt_from_line_and_normed_pt ( view , p ) for p in stored ] ) [EOL] [EOL] [EOL] def restore_selections ( view , lines_and_pts ) : [EOL] view . sel ( ) . clear ( ) [EOL] [EOL] for stored in lines_and_pts : [EOL] view . sel ( ) . add ( region_from_stored_selection ( view , stored ) ) [EOL] [EOL] [EOL] def unexpand ( the_string , tab_size , first_line_offset = [number] , only_leading = True ) : [EOL] lines = the_string . split ( [string] ) [EOL] compressed = [ ] [EOL] [EOL] for li , line in enumerate ( lines ) : [EOL] pos = [number] [EOL] [EOL] if not li : [EOL] pos += first_line_offset [EOL] [EOL] rebuilt_line = [ ] [EOL] column = [ ] [EOL] [EOL] for i , char in enumerate ( line ) : [EOL] if only_leading and not char . isspace ( ) : [EOL] column . extend ( list ( line [ i : ] ) ) [EOL] break [EOL] [EOL] column . append ( char ) [EOL] pos += [number] [EOL] [EOL] if char == [string] : [EOL] pos += tab_size - ( pos % tab_size ) [EOL] [EOL] if pos % tab_size == [number] : [EOL] rebuilt_line . extend ( compress_column ( column ) ) [EOL] column = [ ] [EOL] [EOL] rebuilt_line . extend ( column ) [EOL] compressed . append ( [string] . join ( rebuilt_line ) ) [EOL] [EOL] return [string] . join ( compressed ) [EOL] [EOL] [EOL] class TabCommand ( sublime_plugin . TextCommand ) : [EOL] translate = False [EOL] [EOL] def run ( self , edit , set_translate_tabs = False , whole_buffer = True , ** kw ) : [EOL] view = self . view [EOL] [EOL] if set_translate_tabs or not self . translate : [EOL] view . settings ( ) . set ( [string] , self . translate ) [EOL] [EOL] if whole_buffer or not view . has_non_empty_selection_region ( ) : [EOL] self . operation_regions = [ sublime . Region ( [number] , view . size ( ) ) ] [EOL] else : [EOL] self . operation_regions = view . sel ( ) [EOL] [EOL] sels = save_selections ( view ) [EOL] visible , = save_selections ( view , [ view . visible_region ( ) ] ) [EOL] self . do ( edit , ** kw ) [EOL] restore_selections ( view , sels ) [EOL] visible = region_from_stored_selection ( view , visible ) [EOL] view . show ( visible , False ) [EOL] view . run_command ( [string] , { [string] : [number] } ) [EOL] [EOL] [EOL] class ExpandTabs ( TabCommand ) : [EOL] translate = True [EOL] [EOL] def do ( self , edit , ** kw ) : [EOL] view = self . view [EOL] tab_size = get_tab_size ( view ) [EOL] [EOL] for sel in self . operation_regions : [EOL] sel = view . line ( sel ) [comment] [EOL] view . replace ( edit , sel , view . substr ( sel ) . expandtabs ( tab_size ) ) [EOL] [EOL] [EOL] class UnexpandTabs ( TabCommand ) : [EOL] def do ( self , edit , only_leading = True , ** kw ) : [EOL] view = self . view [EOL] tab_size = get_tab_size ( view ) [EOL] [EOL] for sel in self . operation_regions : [EOL] the_string = view . substr ( sel ) [EOL] first_line_off_set = normed_indentation_pt ( view , sel ) % tab_size [EOL] [EOL] compressed = unexpand ( the_string , tab_size , first_line_off_set , only_leading = only_leading ) [EOL] [EOL] view . replace ( edit , sel , compressed ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , List , Any [EOL] import threading [EOL] import typing [EOL] import collections [EOL] import functools [EOL] import html [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import threading [EOL] import time [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class ProcessListener ( object ) : [EOL] def on_data ( self , proc , data ) : [EOL] pass [EOL] [EOL] def on_finished ( self , proc ) : [EOL] pass [EOL] [EOL] [EOL] class AsyncProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cmd , shell_cmd , env , listener , path = [string] , shell = False ) : [EOL] [docstring] [EOL] [EOL] if not shell_cmd and not cmd : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if shell_cmd and not isinstance ( shell_cmd , str ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . listener = listener [EOL] self . killed = False [EOL] [EOL] self . start_time = time . time ( ) [EOL] [EOL] [comment] [EOL] startupinfo = None [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] [EOL] [comment] [EOL] if path : [EOL] old_path = os . environ [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] os . environ [ [string] ] = os . path . expandvars ( path ) [EOL] [EOL] proc_env = os . environ . copy ( ) [EOL] proc_env . update ( env ) [EOL] for k , v in proc_env . items ( ) : [EOL] proc_env [ k ] = os . path . expandvars ( v ) [EOL] [EOL] if shell_cmd and sys . platform == [string] : [EOL] [comment] [EOL] self . proc = subprocess . Popen ( shell_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE , stdin = subprocess . PIPE , startupinfo = startupinfo , env = proc_env , shell = True ) [EOL] elif shell_cmd and sys . platform == [string] : [EOL] [comment] [EOL] self . proc = subprocess . Popen ( [ [string] , [string] , [string] , shell_cmd ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE , stdin = subprocess . PIPE , startupinfo = startupinfo , env = proc_env , shell = False ) [EOL] elif shell_cmd and sys . platform == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . proc = subprocess . Popen ( [ [string] , [string] , shell_cmd ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE , stdin = subprocess . PIPE , startupinfo = startupinfo , env = proc_env , shell = False ) [EOL] else : [EOL] [comment] [EOL] self . proc = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE , stdin = subprocess . PIPE , startupinfo = startupinfo , env = proc_env , shell = shell ) [EOL] [EOL] if path : [EOL] os . environ [ [string] ] = old_path [EOL] [EOL] if self . proc . stdout : [EOL] threading . Thread ( target = self . read_stdout ) . start ( ) [EOL] [EOL] if self . proc . stderr : [EOL] threading . Thread ( target = self . read_stderr ) . start ( ) [EOL] [EOL] def kill ( self ) : [EOL] if not self . killed : [EOL] self . killed = True [EOL] if sys . platform == [string] : [EOL] [comment] [EOL] [comment] [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] subprocess . Popen ( [string] + str ( self . proc . pid ) , startupinfo = startupinfo ) [EOL] else : [EOL] self . proc . terminate ( ) [EOL] self . listener = None [EOL] [EOL] def poll ( self ) : [EOL] return self . proc . poll ( ) is None [EOL] [EOL] def exit_code ( self ) : [EOL] return self . proc . poll ( ) [EOL] [EOL] def read_stdout ( self ) : [EOL] while True : [EOL] data = os . read ( self . proc . stdout . fileno ( ) , [number] ** [number] ) [EOL] [EOL] if len ( data ) > [number] : [EOL] if self . listener : [EOL] self . listener . on_data ( self , data ) [EOL] else : [EOL] self . proc . stdout . close ( ) [EOL] if self . listener : [EOL] self . listener . on_finished ( self ) [EOL] break [EOL] [EOL] def read_stderr ( self ) : [EOL] while True : [EOL] data = os . read ( self . proc . stderr . fileno ( ) , [number] ** [number] ) [EOL] [EOL] if len ( data ) > [number] : [EOL] if self . listener : [EOL] self . listener . on_data ( self , data ) [EOL] else : [EOL] self . proc . stderr . close ( ) [EOL] break [EOL] [EOL] [EOL] class ExecCommand ( sublime_plugin . WindowCommand , ProcessListener ) : [EOL] BLOCK_SIZE = [number] ** [number] [EOL] text_queue = collections . deque ( ) [EOL] text_queue_proc = None [EOL] text_queue_lock = threading . Lock ( ) [EOL] [EOL] proc = None [EOL] [EOL] errs_by_file = { } [EOL] phantom_sets_by_buffer = { } [EOL] show_errors_inline = True [EOL] [EOL] def run ( self , cmd = None , shell_cmd = None , file_regex = [string] , line_regex = [string] , working_dir = [string] , encoding = [string] , env = { } , quiet = False , kill = False , update_phantoms_only = False , hide_phantoms_only = False , word_wrap = True , syntax = [string] , ** kwargs ) : [EOL] [EOL] if update_phantoms_only : [EOL] if self . show_errors_inline : [EOL] self . update_phantoms ( ) [EOL] return [EOL] if hide_phantoms_only : [EOL] self . hide_phantoms ( ) [EOL] return [EOL] [EOL] [comment] [EOL] self . text_queue_lock . acquire ( ) [EOL] try : [EOL] self . text_queue . clear ( ) [EOL] self . text_queue_proc = None [EOL] finally : [EOL] self . text_queue_lock . release ( ) [EOL] [EOL] if kill : [EOL] if self . proc : [EOL] self . proc . kill ( ) [EOL] self . proc = None [EOL] self . append_string ( None , [string] ) [EOL] return [EOL] [EOL] if not hasattr ( self , [string] ) : [EOL] [comment] [EOL] self . output_view = self . window . create_output_panel ( [string] ) [EOL] [EOL] [comment] [EOL] if working_dir == [string] and self . window . active_view ( ) and self . window . active_view ( ) . file_name ( ) : [EOL] working_dir = os . path . dirname ( self . window . active_view ( ) . file_name ( ) ) [EOL] [EOL] self . output_view . settings ( ) . set ( [string] , file_regex ) [EOL] self . output_view . settings ( ) . set ( [string] , line_regex ) [EOL] self . output_view . settings ( ) . set ( [string] , working_dir ) [EOL] self . output_view . settings ( ) . set ( [string] , word_wrap ) [EOL] self . output_view . settings ( ) . set ( [string] , False ) [EOL] self . output_view . settings ( ) . set ( [string] , False ) [EOL] self . output_view . settings ( ) . set ( [string] , False ) [EOL] self . output_view . assign_syntax ( syntax ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . window . create_output_panel ( [string] ) [EOL] [EOL] self . encoding = encoding [EOL] self . quiet = quiet [EOL] [EOL] self . proc = None [EOL] if not self . quiet : [EOL] if shell_cmd : [EOL] print ( [string] + shell_cmd ) [EOL] elif cmd : [EOL] cmd_string = cmd [EOL] if not isinstance ( cmd , str ) : [EOL] cmd_string = [string] . join ( cmd ) [EOL] print ( [string] + cmd_string ) [EOL] sublime . status_message ( [string] ) [EOL] [EOL] show_panel_on_build = sublime . load_settings ( [string] ) . get ( [string] , True ) [EOL] if show_panel_on_build : [EOL] self . window . run_command ( [string] , { [string] : [string] } ) [EOL] [EOL] self . hide_phantoms ( ) [EOL] self . show_errors_inline = sublime . load_settings ( [string] ) . get ( [string] , True ) [EOL] [EOL] merged_env = env . copy ( ) [EOL] if self . window . active_view ( ) : [EOL] user_env = self . window . active_view ( ) . settings ( ) . get ( [string] ) [EOL] if user_env : [EOL] merged_env . update ( user_env ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if working_dir != [string] : [EOL] os . chdir ( working_dir ) [EOL] [EOL] self . debug_text = [string] [EOL] if shell_cmd : [EOL] self . debug_text += [string] + shell_cmd + [string] [EOL] else : [EOL] self . debug_text += [string] + str ( cmd ) + [string] [EOL] self . debug_text += [string] + str ( os . getcwd ( ) ) + [string] [EOL] if [string] in merged_env : [EOL] self . debug_text += [string] + str ( merged_env [ [string] ] ) + [string] [EOL] else : [EOL] self . debug_text += [string] + str ( os . environ [ [string] ] ) + [string] [EOL] [EOL] try : [EOL] [comment] [EOL] self . proc = AsyncProcess ( cmd , shell_cmd , merged_env , self , ** kwargs ) [EOL] [EOL] self . text_queue_lock . acquire ( ) [EOL] try : [EOL] self . text_queue_proc = self . proc [EOL] finally : [EOL] self . text_queue_lock . release ( ) [EOL] [EOL] except Exception as e : [EOL] self . append_string ( None , str ( e ) + [string] ) [EOL] self . append_string ( None , self . debug_text + [string] ) [EOL] if not self . quiet : [EOL] self . append_string ( None , [string] ) [EOL] [EOL] def is_enabled ( self , kill = False , ** kwargs ) : [EOL] if kill : [EOL] return ( self . proc is not None ) and self . proc . poll ( ) [EOL] else : [EOL] return True [EOL] [EOL] def append_string ( self , proc , str ) : [EOL] self . text_queue_lock . acquire ( ) [EOL] [EOL] was_empty = False [EOL] try : [EOL] if proc != self . text_queue_proc : [EOL] [comment] [EOL] [comment] [EOL] if proc : [EOL] proc . kill ( ) [EOL] return [EOL] [EOL] if len ( self . text_queue ) == [number] : [EOL] was_empty = True [EOL] self . text_queue . append ( [string] ) [EOL] [EOL] available = self . BLOCK_SIZE - len ( self . text_queue [ - [number] ] ) [EOL] [EOL] if len ( str ) < available : [EOL] cur = self . text_queue . pop ( ) [EOL] self . text_queue . append ( cur + str ) [EOL] else : [EOL] self . text_queue . append ( str ) [EOL] [EOL] finally : [EOL] self . text_queue_lock . release ( ) [EOL] [EOL] if was_empty : [EOL] sublime . set_timeout ( self . service_text_queue , [number] ) [EOL] [EOL] def service_text_queue ( self ) : [EOL] self . text_queue_lock . acquire ( ) [EOL] [EOL] is_empty = False [EOL] try : [EOL] if len ( self . text_queue ) == [number] : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] characters = self . text_queue . popleft ( ) [EOL] is_empty = ( len ( self . text_queue ) == [number] ) [EOL] finally : [EOL] self . text_queue_lock . release ( ) [EOL] [EOL] self . output_view . run_command ( [string] , { [string] : characters , [string] : True , [string] : True } ) [EOL] [EOL] if self . show_errors_inline and characters . find ( [string] ) >= [number] : [EOL] errs = self . output_view . find_all_results_with_text ( ) [EOL] errs_by_file = { } [EOL] for file , line , column , text in errs : [EOL] if file not in errs_by_file : [EOL] errs_by_file [ file ] = [ ] [EOL] errs_by_file [ file ] . append ( ( line , column , text ) ) [EOL] self . errs_by_file = errs_by_file [EOL] [EOL] self . update_phantoms ( ) [EOL] [EOL] if not is_empty : [EOL] sublime . set_timeout ( self . service_text_queue , [number] ) [EOL] [EOL] def finish ( self , proc ) : [EOL] if not self . quiet : [EOL] elapsed = time . time ( ) - proc . start_time [EOL] exit_code = proc . exit_code ( ) [EOL] if exit_code == [number] or exit_code is None : [EOL] self . append_string ( proc , [string] % elapsed ) [EOL] else : [EOL] self . append_string ( proc , [string] % ( elapsed , exit_code ) ) [EOL] self . append_string ( proc , self . debug_text ) [EOL] [EOL] if proc != self . proc : [EOL] return [EOL] [EOL] errs = self . output_view . find_all_results ( ) [EOL] if len ( errs ) == [number] : [EOL] sublime . status_message ( [string] ) [EOL] else : [EOL] sublime . status_message ( [string] % len ( errs ) ) [EOL] [EOL] def on_data ( self , proc , data ) : [EOL] try : [EOL] characters = data . decode ( self . encoding ) [EOL] except : [EOL] characters = [string] + self . encoding + [string] [EOL] proc = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] characters = characters . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] self . append_string ( proc , characters ) [EOL] [EOL] def on_finished ( self , proc ) : [EOL] sublime . set_timeout ( functools . partial ( self . finish , proc ) , [number] ) [EOL] [EOL] def update_phantoms ( self ) : [EOL] stylesheet = [string] [EOL] [EOL] for file , errs in self . errs_by_file . items ( ) : [EOL] view = self . window . find_open_file ( file ) [EOL] if view : [EOL] [EOL] buffer_id = view . buffer_id ( ) [EOL] if buffer_id not in self . phantom_sets_by_buffer : [EOL] phantom_set = sublime . PhantomSet ( view , [string] ) [EOL] self . phantom_sets_by_buffer [ buffer_id ] = phantom_set [EOL] else : [EOL] phantom_set = self . phantom_sets_by_buffer [ buffer_id ] [EOL] [EOL] phantoms = [ ] [EOL] [EOL] for line , column , text in errs : [EOL] pt = view . text_point ( line - [number] , column - [number] ) [EOL] phantoms . append ( sublime . Phantom ( sublime . Region ( pt , view . line ( pt ) . b ) , ( [string] + stylesheet + [string] + [string] + html . escape ( text , quote = False ) + [string] + [string] + chr ( [number] ) + [string] + [string] ) , sublime . LAYOUT_BELOW , on_navigate = self . on_phantom_navigate ) ) [EOL] [EOL] phantom_set . update ( phantoms ) [EOL] [EOL] def hide_phantoms ( self ) : [EOL] for file , errs in self . errs_by_file . items ( ) : [EOL] view = self . window . find_open_file ( file ) [EOL] if view : [EOL] view . erase_phantoms ( [string] ) [EOL] [EOL] self . errs_by_file = { } [EOL] self . phantom_sets_by_buffer = { } [EOL] self . show_errors_inline = False [EOL] [EOL] def on_phantom_navigate ( self , url ) : [EOL] self . hide_phantoms ( ) [EOL] [EOL] [EOL] class ExecEventListener ( sublime_plugin . EventListener ) : [EOL] def on_load ( self , view ) : [EOL] w = view . window ( ) [EOL] if w is not None : [EOL] w . run_command ( [string] , { [string] : True } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] import random [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def permute_selection ( f , v , e ) : [EOL] regions = [ s for s in v . sel ( ) if not s . empty ( ) ] [EOL] regions . sort ( ) [EOL] txt = [ v . substr ( s ) for s in regions ] [EOL] txt = f ( txt ) [EOL] [EOL] [comment] [EOL] if len ( txt ) != len ( regions ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] combined = list ( zip ( regions , txt ) ) [EOL] combined . sort ( key = lambda x : x [ [number] ] , reverse = True ) [EOL] [EOL] for x in combined : [EOL] [ r , t ] = x [EOL] v . replace ( e , r , t ) [EOL] [EOL] [EOL] def case_insensitive_sort ( txt ) : [EOL] txt . sort ( key = lambda x : x . lower ( ) ) [EOL] return txt [EOL] [EOL] [EOL] def case_sensitive_sort ( txt ) : [EOL] txt . sort ( ) [EOL] return txt [EOL] [EOL] [EOL] def reverse_list ( l ) : [EOL] l . reverse ( ) [EOL] return l [EOL] [EOL] [EOL] def shuffle_list ( l ) : [EOL] random . shuffle ( l ) [EOL] return l [EOL] [EOL] [EOL] def uniquealise_list ( l ) : [EOL] table = { } [EOL] res = [ ] [EOL] for x in l : [EOL] if x not in table : [EOL] table [ x ] = x [EOL] res . append ( x ) [EOL] return res [EOL] [EOL] [EOL] permute_funcs = { [string] : reverse_list , [string] : shuffle_list , [string] : uniquealise_list , } [EOL] [EOL] [EOL] def unique_selection ( v , e ) : [EOL] regions = [ s for s in v . sel ( ) if not s . empty ( ) ] [EOL] regions . sort ( ) [EOL] [EOL] dupregions = [ ] [EOL] table = { } [EOL] for r in regions : [EOL] txt = v . substr ( r ) [EOL] if txt not in table : [EOL] table [ txt ] = r [EOL] else : [EOL] dupregions . append ( r ) [EOL] [EOL] dupregions . reverse ( ) [EOL] for r in dupregions : [EOL] v . erase ( e , r ) [EOL] [EOL] [EOL] def shrink_wrap_region ( view , region ) : [EOL] a , b = region . begin ( ) , region . end ( ) [EOL] [EOL] for a in range ( a , b ) : [EOL] if not view . substr ( a ) . isspace ( ) : [EOL] break [EOL] [EOL] for b in range ( b - [number] , a , - [number] ) : [EOL] if not view . substr ( b ) . isspace ( ) : [EOL] b += [number] [EOL] break [EOL] [EOL] return sublime . Region ( a , b ) [EOL] [EOL] [EOL] def shrinkwrap_and_expand_non_empty_selections_to_entire_line ( v ) : [EOL] sw = shrink_wrap_region [EOL] regions = [ ] [EOL] [EOL] for sel in v . sel ( ) : [EOL] if not sel . empty ( ) : [EOL] regions . append ( v . line ( sw ( v , v . line ( sel ) ) ) ) [EOL] v . sel ( ) . subtract ( sel ) [EOL] [EOL] for r in regions : [EOL] v . sel ( ) . add ( r ) [EOL] [EOL] [EOL] def permute_lines ( f , v , e ) : [EOL] shrinkwrap_and_expand_non_empty_selections_to_entire_line ( v ) [EOL] [EOL] regions = [ s for s in v . sel ( ) if not s . empty ( ) ] [EOL] if not regions : [EOL] regions = [ sublime . Region ( [number] , v . size ( ) ) ] [EOL] [EOL] regions . sort ( reverse = True ) [EOL] [EOL] for r in regions : [EOL] txt = v . substr ( r ) [EOL] lines = txt . splitlines ( ) [EOL] lines = f ( lines ) [EOL] [EOL] v . replace ( e , r , [string] . join ( lines ) ) [EOL] [EOL] [EOL] def has_multiple_non_empty_selection_region ( v ) : [EOL] return len ( [ s for s in v . sel ( ) if not s . empty ( ) ] ) > [number] [EOL] [EOL] [EOL] class SortLinesCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , case_sensitive = False , reverse = False , remove_duplicates = False ) : [EOL] view = self . view [EOL] [EOL] if case_sensitive : [EOL] permute_lines ( case_sensitive_sort , view , edit ) [EOL] else : [EOL] permute_lines ( case_insensitive_sort , view , edit ) [EOL] [EOL] if reverse : [EOL] permute_lines ( reverse_list , view , edit ) [EOL] [EOL] if remove_duplicates : [EOL] permute_lines ( uniquealise_list , view , edit ) [EOL] [EOL] [EOL] class SortSelectionCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , case_sensitive = False , reverse = False , remove_duplicates = False ) : [EOL] [EOL] view = self . view [EOL] [EOL] permute_selection ( case_sensitive_sort if case_sensitive else case_insensitive_sort , view , edit ) [EOL] [EOL] if reverse : [EOL] permute_selection ( reverse_list , view , edit ) [EOL] [EOL] if remove_duplicates : [EOL] unique_selection ( view , edit ) [EOL] [EOL] def is_enabled ( self , ** kw ) : [EOL] return has_multiple_non_empty_selection_region ( self . view ) [EOL] [EOL] [EOL] class PermuteLinesCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , operation = [string] ) : [EOL] permute_lines ( permute_funcs [ operation ] , self . view , edit ) [EOL] [EOL] [EOL] class PermuteSelectionCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , operation = [string] ) : [EOL] view = self . view [EOL] [EOL] if operation == [string] : [EOL] permute_selection ( reverse_list , view , edit ) [EOL] [EOL] elif operation == [string] : [EOL] permute_selection ( shuffle_list , view , edit ) [EOL] [EOL] elif operation == [string] : [EOL] unique_selection ( view , edit ) [EOL] [EOL] def is_enabled ( self , ** kw ) : [EOL] return has_multiple_non_empty_selection_region ( self . view ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sublime_plugin [EOL] [EOL] [EOL] class ScrollToBof ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] self . view . show ( [number] ) [EOL] [EOL] [EOL] class ScrollToEof ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] self . view . show ( self . view . size ( ) ) [EOL] [EOL] [EOL] class ShowAtCenter ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] self . view . show_at_center ( self . view . sel ( ) [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime_plugin [EOL] [EOL] [EOL] def profile_text ( ) : [EOL] output = [string] [EOL] for event in sorted ( sublime_plugin . profile . keys ( ) ) : [EOL] output += [string] . format ( event ) [EOL] for name , summary in sublime_plugin . profile [ event ] . items ( ) : [EOL] output += [string] . format ( name , summary ) [EOL] output += [string] [EOL] return output [EOL] [EOL] [EOL] class ProfilePluginsCommand ( sublime_plugin . WindowCommand ) : [EOL] def run_ ( self , edit_token , args ) : [EOL] output = [string] [EOL] output += profile_text ( ) [EOL] [EOL] v = self . window . new_file ( ) [EOL] v . set_scratch ( True ) [EOL] v . set_name ( [string] ) [EOL] edit = v . begin_edit ( edit_token , [string] ) [EOL] v . insert ( edit , [number] , output ) [EOL] v . end_edit ( edit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0
import webbrowser [EOL] [EOL] import sublime_plugin [EOL] [EOL] [EOL] class OpenInBrowserCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] if self . view . file_name ( ) : [EOL] webbrowser . open_new_tab ( [string] + self . view . file_name ( ) ) [EOL] [EOL] def is_visible ( self ) : [EOL] return self . view . file_name ( ) is not None and ( self . view . file_name ( ) [ - [number] : ] == [string] or self . view . file_name ( ) [ - [number] : ] == [string] or self . view . file_name ( ) [ - [number] : ] == [string] or self . view . file_name ( ) [ - [number] : ] == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import string [EOL] import functools [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class SetUnsavedViewName ( sublime_plugin . EventListener ) : [EOL] setting_name = False [EOL] [EOL] dropped_chars = string . whitespace [EOL] [EOL] pending = [number] [EOL] [EOL] def on_modified_async ( self , view ) : [EOL] if view . file_name ( ) or view . is_loading ( ) : [EOL] return [EOL] [EOL] if self . setting_name : [EOL] return [EOL] [EOL] self . pending += [number] [EOL] sublime . set_timeout_async ( functools . partial ( self . update_title , view ) , [number] ) [EOL] [EOL] def update_title ( self , view ) : [EOL] self . pending -= [number] [EOL] if self . pending != [number] : [EOL] return [EOL] [EOL] if view . settings ( ) . get ( [string] ) is False : [EOL] return [EOL] [EOL] cur_name = view . settings ( ) . get ( [string] ) [EOL] view_name = view . name ( ) [EOL] [EOL] [comment] [EOL] syntax = view . settings ( ) . get ( [string] ) [EOL] if syntax != [string] : [EOL] if cur_name : [EOL] [comment] [EOL] view . settings ( ) . erase ( [string] ) [EOL] if cur_name == view_name : [EOL] view . set_name ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] if not cur_name and view_name : [EOL] return [EOL] [EOL] [comment] [EOL] if cur_name and cur_name != view . name ( ) : [EOL] view . settings ( ) . erase ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if view . settings ( ) . get ( [string] ) : [EOL] return [EOL] [EOL] line = view . line ( [number] ) [EOL] if line . size ( ) > [number] : [EOL] line = sublime . Region ( [number] , [number] ) [EOL] [EOL] first_line = view . substr ( line ) [EOL] [EOL] first_line = first_line . strip ( self . dropped_chars ) [EOL] [EOL] self . setting_name = True [EOL] view . set_name ( first_line ) [EOL] self . setting_name = False [EOL] [EOL] view . settings ( ) . set ( [string] , first_line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import textwrap [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] def reformat ( template ) : [EOL] return textwrap . dedent ( template ) . lstrip ( ) [EOL] [EOL] [EOL] class NewBuildSystemCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self ) : [EOL] v = self . window . new_file ( ) [EOL] v . settings ( ) . set ( [string] , os . path . join ( sublime . packages_path ( ) , [string] ) ) [EOL] v . assign_syntax ( [string] ) [EOL] v . set_name ( [string] ) [EOL] [EOL] template = reformat ( [string] ) [EOL] v . run_command ( [string] , { [string] : template } ) [EOL] [EOL] [EOL] class NewPluginCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self ) : [EOL] v = self . window . new_file ( ) [EOL] v . settings ( ) . set ( [string] , os . path . join ( sublime . packages_path ( ) , [string] ) ) [EOL] v . assign_syntax ( [string] ) [EOL] [EOL] template = reformat ( [string] ) [EOL] v . run_command ( [string] , { [string] : template } ) [EOL] [EOL] [EOL] class NewSnippetCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self ) : [EOL] v = self . window . new_file ( ) [EOL] v . settings ( ) . set ( [string] , os . path . join ( sublime . packages_path ( ) , [string] ) ) [EOL] v . settings ( ) . set ( [string] , [string] ) [EOL] v . assign_syntax ( [string] ) [EOL] [EOL] template = reformat ( [string] ) [EOL] v . run_command ( [string] , { [string] : template } ) [EOL] [EOL] [EOL] class NewSyntaxCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self ) : [EOL] v = self . window . new_file ( ) [EOL] v . settings ( ) . set ( [string] , os . path . join ( sublime . packages_path ( ) , [string] ) ) [EOL] v . settings ( ) . set ( [string] , [string] ) [EOL] v . assign_syntax ( [string] ) [EOL] [EOL] template = reformat ( [string] ) [EOL] [EOL] v . run_command ( [string] , { [string] : template } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import List , Any [EOL] import typing [EOL] import re [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class ClipboardHistory ( ) : [EOL] [docstring] [EOL] [EOL] LIST_LIMIT = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . storage = [ ] [EOL] [EOL] def push_text ( self , text ) : [EOL] if not text : [EOL] return [EOL] [EOL] DISPLAY_LEN = [number] [EOL] [EOL] [comment] [EOL] display_text = re . sub ( [string] , [string] , text ) [EOL] [comment] [EOL] display_text = re . sub ( [string] , [string] , display_text ) [EOL] display_text = ( display_text [ : DISPLAY_LEN ] + [string] ) if len ( display_text ) > DISPLAY_LEN else display_text [EOL] [EOL] self . del_duplicate ( text ) [EOL] self . storage . insert ( [number] , ( display_text , text ) ) [EOL] [EOL] if len ( self . storage ) > self . LIST_LIMIT : [EOL] del self . storage [ self . LIST_LIMIT : ] [EOL] [EOL] def get ( self ) : [EOL] return self . storage [EOL] [EOL] def del_duplicate ( self , text ) : [EOL] [comment] [EOL] self . storage = [ s for s in self . storage if s [ [number] ] != text ] [EOL] [EOL] def empty ( self ) : [EOL] return len ( self . storage ) == [number] [EOL] [EOL] [EOL] g_clipboard_history = ClipboardHistory ( ) [EOL] [EOL] [EOL] class ClipboardHistoryUpdater ( sublime_plugin . EventListener ) : [EOL] [docstring] [EOL] [EOL] def on_post_text_command ( self , view , name , args ) : [EOL] if view . settings ( ) . get ( [string] ) : [EOL] return [EOL] [EOL] if name == [string] or name == [string] : [EOL] g_clipboard_history . push_text ( sublime . get_clipboard ( ) ) [EOL] [EOL] [EOL] class PasteFromHistoryCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit ) : [EOL] if self . view . settings ( ) . get ( [string] ) : [EOL] return [EOL] [EOL] [comment] [EOL] paste_list = g_clipboard_history . get ( ) [EOL] keys = [ x [ [number] ] for x in paste_list ] [EOL] self . view . show_popup_menu ( keys , lambda choice_index : self . paste_choice ( choice_index ) ) [EOL] [EOL] def is_enabled ( self ) : [EOL] return not g_clipboard_history . empty ( ) [EOL] [EOL] def paste_choice ( self , choice_index ) : [EOL] if choice_index == - [number] : [EOL] return [EOL] [comment] [EOL] text = g_clipboard_history . get ( ) [ choice_index ] [ [number] ] [EOL] [EOL] [comment] [EOL] g_clipboard_history . push_text ( text ) [EOL] [EOL] sublime . set_clipboard ( text ) [EOL] self . view . run_command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Literal , Any , Union , Match , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import re [EOL] [EOL] import sublime [EOL] import sublime_api [EOL] import sublime_plugin [EOL] [EOL] [EOL] PACKAGES_FILE_REGEX = [string] [EOL] [EOL] [EOL] class RunSyntaxTestsCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , find_all = False , ** kwargs ) : [EOL] [EOL] if not hasattr ( self , [string] ) : [EOL] [comment] [EOL] self . output_view = self . window . create_output_panel ( [string] ) [EOL] [EOL] settings = self . output_view . settings ( ) [EOL] settings . set ( [string] , PACKAGES_FILE_REGEX ) [EOL] settings . set ( [string] , sublime . packages_path ( ) ) [EOL] settings . set ( [string] , True ) [EOL] settings . set ( [string] , False ) [EOL] settings . set ( [string] , False ) [EOL] settings . set ( [string] , False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . window . create_output_panel ( [string] ) [EOL] [EOL] if not find_all : [EOL] relative_path = package_relative_path ( self . window . active_view ( ) ) [EOL] if not relative_path : [EOL] return [EOL] [EOL] file_name = os . path . basename ( relative_path ) [EOL] [EOL] if is_syntax ( relative_path ) : [EOL] tests = [ ] [EOL] for t in sublime . find_resources ( [string] ) : [EOL] first_line = sublime . load_resource ( t ) . splitlines ( ) [ [number] ] [EOL] match = re . match ( [string] , first_line ) [EOL] if not match : [EOL] continue [EOL] syntax = match . group ( [number] ) [EOL] if syntax == relative_path or syntax == file_name : [EOL] tests . append ( t ) [EOL] elif file_name . startswith ( [string] ) : [EOL] tests = [ relative_path ] [EOL] else : [EOL] sublime . error_message ( [string] [string] ) [EOL] return [EOL] else : [EOL] tests = sublime . find_resources ( [string] ) [EOL] [EOL] show_panel_on_build ( self . window ) [EOL] [EOL] total_assertions = [number] [EOL] failed_assertions = [number] [EOL] [EOL] for t in tests : [EOL] assertions , test_output_lines = sublime_api . run_syntax_test ( t ) [EOL] total_assertions += assertions [EOL] if len ( test_output_lines ) > [number] : [EOL] failed_assertions += len ( test_output_lines ) [EOL] for line in test_output_lines : [EOL] append ( self . output_view , line + [string] ) [EOL] [EOL] if failed_assertions > [number] : [EOL] message = [string] [EOL] params = ( failed_assertions , total_assertions , len ( tests ) ) [EOL] else : [EOL] message = [string] [EOL] params = ( total_assertions , len ( tests ) ) [EOL] [EOL] append ( self . output_view , message . format ( * params ) ) [EOL] append ( self . output_view , [string] ) [EOL] [EOL] def in_dir ( self , folder , path ) : [EOL] if not folder . endswith ( os . sep ) : [EOL] folder += os . sep [EOL] return path . startswith ( folder ) [EOL] [EOL] [EOL] class ProfileSyntaxDefinitionCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , ** kwargs ) : [EOL] [EOL] view = self . window . active_view ( ) [EOL] if not view : [EOL] sublime . error_message ( [string] ) [EOL] return [EOL] [EOL] if not hasattr ( self , [string] ) : [EOL] [comment] [EOL] self . output_view = self . window . create_output_panel ( [string] ) [EOL] [EOL] self . output_view . settings ( ) . set ( [string] , False ) [EOL] self . output_view . settings ( ) . set ( [string] , False ) [EOL] self . output_view . settings ( ) . set ( [string] , False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . window . create_output_panel ( [string] ) [EOL] [EOL] show_panel_on_build ( self . window ) [EOL] [EOL] source = view . substr ( sublime . Region ( [number] , view . size ( ) ) ) [EOL] syntax = view . settings ( ) . get ( [string] ) [EOL] [EOL] total = [number] [EOL] for _ in range ( [number] , [number] ) : [EOL] total += sublime_api . profile_syntax_definition ( source , syntax ) [EOL] avg = total / [number] [EOL] [EOL] output = [string] [string] [EOL] append ( self . output_view , output . format ( syntax , avg * [number] ) ) [EOL] [EOL] [EOL] class SyntaxDefinitionCompatibilityCommand ( sublime_plugin . WindowCommand ) : [EOL] def run ( self , ** kwargs ) : [EOL] [EOL] view = self . window . active_view ( ) [EOL] if not view or not view . file_name ( ) . endswith ( [string] ) : [EOL] sublime . error_message ( [string] [string] ) [EOL] return [EOL] [EOL] if not hasattr ( self , [string] ) : [EOL] [comment] [EOL] self . output_view = self . window . create_output_panel ( [string] ) [EOL] [EOL] settings = self . output_view . settings ( ) [EOL] settings . set ( [string] , PACKAGES_FILE_REGEX ) [EOL] settings . set ( [string] , sublime . packages_path ( ) ) [EOL] settings . set ( [string] , True ) [EOL] settings . set ( [string] , False ) [EOL] settings . set ( [string] , False ) [EOL] settings . set ( [string] , False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . window . create_output_panel ( [string] ) [EOL] [EOL] relative_path = package_relative_path ( view ) [EOL] if not relative_path : [EOL] return [EOL] [EOL] show_panel_on_build ( self . window ) [EOL] [EOL] patterns = sublime_api . incompatible_syntax_patterns ( relative_path ) [EOL] [EOL] num = len ( patterns ) [EOL] [EOL] if num > [number] : [EOL] line_pattern = [string] [EOL] for pattern in sorted ( patterns , key = lambda p : p [ [number] ] ) : [EOL] value_line , value_col = pattern [ [number] ] [EOL] regex_line , regex_col = pattern [ [number] ] [EOL] [EOL] value_begin = view . text_point ( value_line , value_col ) [EOL] next_char = view . substr ( value_begin ) [EOL] while next_char == [string] : [EOL] value_col += [number] [EOL] value_begin = view . text_point ( value_line , value_col ) [EOL] next_char = view . substr ( value_begin ) [EOL] [EOL] line = value_line + regex_line [EOL] col = value_col + regex_col [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if next_char in { [string] , [string] } : [EOL] col += [number] [EOL] [EOL] chunk_begin = value_begin + [number] [EOL] chunk_end = chunk_begin + regex_col [EOL] escaped_quotes = self . count_escapes ( next_char , view , chunk_begin , chunk_end ) [EOL] [EOL] while escaped_quotes : [EOL] col += escaped_quotes [EOL] chunk_begin = chunk_end [EOL] chunk_end += escaped_quotes [EOL] escaped_quotes = self . count_escapes ( next_char , view , chunk_begin , chunk_end ) [EOL] [EOL] [comment] [EOL] elif next_char == [string] : [EOL] line += [number] [EOL] [comment] [EOL] value_point = view . text_point ( value_line + [number] , [number] ) [EOL] value_line = view . substr ( view . line ( value_point ) ) [EOL] indent_size = len ( value_line ) - len ( value_line . lstrip ( ) ) [EOL] col = indent_size + regex_col [EOL] [EOL] [comment] [EOL] elif next_char == [string] : [EOL] def get_line ( view , line_num ) : [EOL] point = view . text_point ( line_num , [number] ) [EOL] return view . substr ( view . line ( point ) ) [EOL] [EOL] line += [number] [EOL] raw_line = get_line ( view , line ) [EOL] stripped_line = raw_line . lstrip ( ) [EOL] stripped_len = len ( stripped_line ) [EOL] indent_size = len ( raw_line ) - stripped_len [EOL] consumed = [number] [EOL] [EOL] while consumed + stripped_len + [number] <= regex_col : [EOL] consumed += stripped_len + [number] [EOL] line += [number] [EOL] raw_line = get_line ( view , line ) [EOL] stripped_line = raw_line . lstrip ( ) [EOL] stripped_len = len ( stripped_line ) [EOL] indent_size = len ( raw_line ) - stripped_len [EOL] [EOL] col = indent_size + ( regex_col - consumed ) [EOL] [EOL] append ( self . output_view , line_pattern . format ( relative_path , line + [number] , col + [number] , pattern [ [number] ] ) ) [EOL] [EOL] message = [string] [EOL] s = [string] if num > [number] else [string] [EOL] params = ( num , s , relative_path ) [EOL] [EOL] else : [EOL] message = [string] [EOL] params = ( relative_path , ) [EOL] [EOL] append ( self . output_view , message . format ( * params ) ) [EOL] append ( self . output_view , [string] ) [EOL] [EOL] def count_escapes ( self , quote , view , begin , end ) : [EOL] chunk = view . substr ( sublime . Region ( begin , end ) ) [EOL] if quote == [string] : [EOL] return chunk . count ( [string] ) [EOL] return len ( re . findall ( [string] , chunk ) ) [EOL] [EOL] [EOL] def is_syntax ( path ) : [EOL] return path . endswith ( [string] ) or path . endswith ( [string] ) [EOL] [EOL] [EOL] def package_relative_path ( view ) : [EOL] def show_error ( ) : [EOL] sublime . error_message ( [string] [string] [string] ) [EOL] [EOL] if not view : [EOL] show_error ( ) [EOL] return None [EOL] [EOL] def os_to_resource_path ( p ) : [EOL] if p and os . name == [string] : [EOL] p = p . replace ( [string] , [string] ) [EOL] return p [EOL] [EOL] path = None [EOL] file_name = None [EOL] relative_path = None [EOL] [EOL] packages_path = sublime . packages_path ( ) [EOL] data_dir = os . path . dirname ( packages_path ) + os . sep [EOL] [EOL] path = view . file_name ( ) [EOL] file_name = os . path . basename ( path ) [EOL] if path . startswith ( data_dir ) : [EOL] relative_path = os_to_resource_path ( [string] + path [ len ( packages_path ) : ] ) [EOL] [EOL] else : [EOL] [comment] [EOL] prefix = os . path . dirname ( path ) [EOL] suffix = file_name [EOL] while not prefix . endswith ( os . sep ) : [EOL] if os . path . exists ( os . path . join ( packages_path , suffix ) ) : [EOL] relative_path = os_to_resource_path ( os . path . join ( [string] , suffix ) ) [EOL] break [EOL] prefix , tail = os . path . split ( prefix ) [EOL] suffix = os . path . join ( tail , suffix ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if relative_path : [EOL] try : [EOL] loader_version = sublime . load_resource ( relative_path ) [EOL] except IOError : [EOL] relative_path = None [EOL] else : [EOL] with open ( path , [string] , encoding = [string] , newline = [string] ) as f : [EOL] fs_version = f . read ( ) [EOL] if fs_version != loader_version : [EOL] relative_path = None [EOL] [EOL] if not relative_path : [EOL] show_error ( ) [EOL] [EOL] return relative_path [EOL] [EOL] [EOL] def show_panel_on_build ( window ) : [EOL] if sublime . load_settings ( [string] ) . get ( [string] , True ) : [EOL] window . run_command ( [string] , { [string] : [string] } ) [EOL] [EOL] [EOL] def append ( panel , output ) : [EOL] panel . run_command ( [string] , { [string] : output , [string] : True , [string] : True } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 $builtins.int$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Any [EOL] import typing [EOL] import re [EOL] import webbrowser [EOL] [EOL] import sublime_plugin [EOL] [EOL] [EOL] rex = re . compile ( [string] ) [EOL] [EOL] [EOL] class OpenContextUrlCommand ( sublime_plugin . TextCommand ) : [EOL] def run ( self , edit , event ) : [EOL] url = self . find_url ( event ) [EOL] webbrowser . open_new_tab ( url ) [EOL] [EOL] def is_visible ( self , event ) : [EOL] return self . find_url ( event ) is not None [EOL] [EOL] def find_url ( self , event ) : [EOL] pt = self . view . window_to_text ( ( event [ [string] ] , event [ [string] ] ) ) [EOL] line = self . view . line ( pt ) [EOL] [EOL] line . a = max ( line . a , pt - [number] ) [EOL] line . b = min ( line . b , pt + [number] ) [EOL] [EOL] text = self . view . substr ( line ) [EOL] [EOL] it = rex . finditer ( text ) [EOL] [EOL] for match in it : [EOL] if match . start ( ) <= ( pt - line . a ) and match . end ( ) >= ( pt - line . a ) : [EOL] url = text [ match . start ( ) : match . end ( ) ] [EOL] if url [ [number] : [number] ] == [string] : [EOL] return [string] + url [EOL] else : [EOL] return url [EOL] [EOL] return None [EOL] [EOL] def description ( self , event ) : [EOL] url = self . find_url ( event ) [EOL] if len ( url ) > [number] : [EOL] url = url [ [number] : [number] ] + [string] [EOL] return [string] + url [EOL] [EOL] def want_event ( self ) : [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] [EOL] class IncreaseFontSizeCommand ( sublime_plugin . ApplicationCommand ) : [EOL] def run ( self ) : [EOL] s = sublime . load_settings ( [string] ) [EOL] current = s . get ( [string] , [number] ) [EOL] [EOL] if current >= [number] : [EOL] current += [number] [EOL] elif current >= [number] : [EOL] current += [number] [EOL] else : [EOL] current += [number] [EOL] [EOL] if current > [number] : [EOL] current = [number] [EOL] s . set ( [string] , current ) [EOL] [EOL] sublime . save_settings ( [string] ) [EOL] [EOL] [EOL] class DecreaseFontSizeCommand ( sublime_plugin . ApplicationCommand ) : [EOL] def run ( self ) : [EOL] s = sublime . load_settings ( [string] ) [EOL] current = s . get ( [string] , [number] ) [EOL] [comment] [EOL] [EOL] if current >= [number] : [EOL] current -= [number] [EOL] elif current >= [number] : [EOL] current -= [number] [EOL] else : [EOL] current -= [number] [EOL] [EOL] if current < [number] : [EOL] current = [number] [EOL] s . set ( [string] , current ) [EOL] [EOL] sublime . save_settings ( [string] ) [EOL] [EOL] [EOL] class ResetFontSizeCommand ( sublime_plugin . ApplicationCommand ) : [EOL] def run ( self ) : [EOL] s = sublime . load_settings ( [string] ) [EOL] s . erase ( [string] ) [EOL] [EOL] sublime . save_settings ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] [EOL] if sys . platform == [string] : [EOL] from . plat_osx import send2trash [EOL] elif sys . platform == [string] : [EOL] from . plat_win import send2trash [EOL] else : [EOL] from . plat_other import send2trash [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import io [EOL] import typing [EOL] import sys [EOL] import os [EOL] import os . path as op [EOL] from datetime import datetime [EOL] import stat [EOL] from urllib . parse import quote [EOL] [EOL] FILES_DIR = [string] [EOL] INFO_DIR = [string] [EOL] INFO_SUFFIX = [string] [EOL] [EOL] [comment] [EOL] XDG_DATA_HOME = op . expanduser ( os . environ . get ( [string] , [string] ) ) [EOL] HOMETRASH = op . join ( XDG_DATA_HOME , [string] ) [EOL] [EOL] uid = os . getuid ( ) [EOL] TOPDIR_TRASH = [string] [EOL] TOPDIR_FALLBACK = [string] + str ( uid ) [EOL] [EOL] def is_parent ( parent , path ) : [EOL] path = op . realpath ( path ) [comment] [EOL] parent = op . realpath ( parent ) [EOL] return path . startswith ( parent ) [EOL] [EOL] def format_date ( date ) : [EOL] return date . strftime ( [string] ) [EOL] [EOL] def info_for ( src , topdir ) : [EOL] [comment] [EOL] [comment] [EOL] if topdir is None or not is_parent ( topdir , src ) : [EOL] src = op . abspath ( src ) [EOL] else : [EOL] src = op . relpath ( src , topdir ) [EOL] [EOL] info = [string] [EOL] info += [string] + quote ( src ) + [string] [EOL] info += [string] + format_date ( datetime . now ( ) ) + [string] [EOL] return info [EOL] [EOL] def check_create ( dir ) : [EOL] [comment] [EOL] if not op . exists ( dir ) : [EOL] os . makedirs ( dir , [number] ) [EOL] [EOL] def trash_move ( src , dst , topdir = None ) : [EOL] filename = op . basename ( src ) [EOL] filespath = op . join ( dst , FILES_DIR ) [EOL] infopath = op . join ( dst , INFO_DIR ) [EOL] base_name , ext = op . splitext ( filename ) [EOL] [EOL] counter = [number] [EOL] destname = filename [EOL] while op . exists ( op . join ( filespath , destname ) ) or op . exists ( op . join ( infopath , destname + INFO_SUFFIX ) ) : [EOL] counter += [number] [EOL] destname = [string] % ( base_name , counter , ext ) [EOL] [EOL] check_create ( filespath ) [EOL] check_create ( infopath ) [EOL] [EOL] os . rename ( src , op . join ( filespath , destname ) ) [EOL] f = open ( op . join ( infopath , destname + INFO_SUFFIX ) , [string] ) [EOL] f . write ( info_for ( src , topdir ) ) [EOL] f . close ( ) [EOL] [EOL] def find_mount_point ( path ) : [EOL] [comment] [EOL] [comment] [EOL] path = op . realpath ( path ) [comment] [EOL] while not op . ismount ( path ) : [EOL] path = op . split ( path ) [ [number] ] [EOL] return path [EOL] [EOL] def find_ext_volume_global_trash ( volume_root ) : [EOL] [comment] [EOL] [comment] [EOL] trash_dir = op . join ( volume_root , TOPDIR_TRASH ) [EOL] if not op . exists ( trash_dir ) : [EOL] return None [EOL] [EOL] mode = os . lstat ( trash_dir ) . st_mode [EOL] [comment] [EOL] [comment] [EOL] if not op . isdir ( trash_dir ) or op . islink ( trash_dir ) or not ( mode & stat . S_ISVTX ) : [EOL] return None [EOL] [EOL] trash_dir = op . join ( trash_dir , str ( uid ) ) [EOL] try : [EOL] check_create ( trash_dir ) [EOL] except OSError : [EOL] return None [EOL] return trash_dir [EOL] [EOL] def find_ext_volume_fallback_trash ( volume_root ) : [EOL] [comment] [EOL] trash_dir = op . join ( volume_root , TOPDIR_FALLBACK ) [EOL] [comment] [EOL] [comment] [EOL] check_create ( trash_dir ) [EOL] return trash_dir [EOL] [EOL] def find_ext_volume_trash ( volume_root ) : [EOL] trash_dir = find_ext_volume_global_trash ( volume_root ) [EOL] if trash_dir is None : [EOL] trash_dir = find_ext_volume_fallback_trash ( volume_root ) [EOL] return trash_dir [EOL] [EOL] [comment] [EOL] def get_dev ( path ) : [EOL] return os . lstat ( path ) . st_dev [EOL] [EOL] def send2trash ( path ) : [EOL] [comment] [EOL] [comment] [EOL] if not op . exists ( path ) : [EOL] raise OSError ( [string] % path ) [EOL] [comment] [EOL] [comment] [EOL] if not os . access ( path , os . W_OK ) : [EOL] raise OSError ( [string] % path ) [EOL] [comment] [EOL] [comment] [EOL] path_dev = get_dev ( path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] trash_dev = get_dev ( op . expanduser ( [string] ) ) [EOL] [EOL] if path_dev == trash_dev : [EOL] topdir = XDG_DATA_HOME [EOL] dest_trash = HOMETRASH [EOL] else : [EOL] topdir = find_mount_point ( path ) [EOL] trash_dev = get_dev ( topdir ) [EOL] if trash_dev != path_dev : [EOL] raise OSError ( [string] % path ) [EOL] dest_trash = find_ext_volume_trash ( topdir ) [EOL] trash_move ( path , dest_trash , topdir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] [comment] [EOL] import sublime [EOL] except ImportError : [EOL] from setuptools import setup , find_packages [EOL] [EOL] setup ( name = [string] , packages = find_packages ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple [EOL] import typing [EOL] import os [EOL] [EOL] messages_json = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] with open ( messages_json , [string] ) as message_file : [EOL] message_data = message_file . read ( ) [EOL] [EOL] ver = message_data . splitlines ( ) [ - [number] ] . split ( [string] ) [ [number] ] . strip ( ) . replace ( [string] , [string] ) [EOL] version = tuple ( [ int ( i ) for i in ver . split ( [string] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Any [EOL] import string [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import logging [EOL] from string import Template [EOL] [EOL] import sublime [EOL] import sublime_plugin [EOL] [EOL] from . anaconda_lib import ioloop [EOL] from . anaconda_lib . helpers import get_settings [EOL] [EOL] from . commands import * [comment] [EOL] from . listeners import * [comment] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] DISABLED_PLUGINS = [ ] [EOL] LOOP_RUNNING = False [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . addHandler ( logging . StreamHandler ( sys . stdout ) ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] [EOL] def plugin_loaded ( ) : [EOL] [docstring] [EOL] [EOL] package_folder = os . path . dirname ( __file__ ) [EOL] if not os . path . exists ( os . path . join ( package_folder , [string] ) ) : [EOL] template_file = os . path . join ( package_folder , [string] , [string] ) [EOL] with open ( template_file , [string] , encoding = [string] ) as tplfile : [EOL] template = Template ( tplfile . read ( ) ) [EOL] [EOL] menu_file = os . path . join ( package_folder , [string] ) [EOL] with open ( menu_file , [string] , encoding = [string] ) as menu : [EOL] menu . write ( template . safe_substitute ( { [string] : os . path . basename ( package_folder ) } ) ) [EOL] [EOL] [comment] [EOL] sublime . set_timeout_async ( monitor_plugins , [number] ) [EOL] [EOL] if not LOOP_RUNNING : [EOL] ioloop . loop ( ) [EOL] [EOL] [EOL] def plugin_unloaded ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] enable_plugins ( ) [EOL] [EOL] if LOOP_RUNNING : [EOL] ioloop . terminate ( ) [EOL] [EOL] [EOL] def monitor_plugins ( ) : [EOL] [docstring] [EOL] [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] if not get_settings ( view , [string] , True ) : [EOL] return [EOL] [EOL] plist = [ [string] , [string] , [string] ] [EOL] [EOL] for plugin in plist : [EOL] if plugin in sys . modules : [EOL] [ sublime_plugin . unload_module ( m ) for k , m in sys . modules . items ( ) if plugin in k ] [EOL] if plugin not in DISABLED_PLUGINS : [EOL] DISABLED_PLUGINS . append ( plugin ) [EOL] [EOL] sublime . set_timeout_async ( monitor_plugins , [number] * [number] * [number] ) [EOL] [EOL] [EOL] def enable_plugins ( ) : [EOL] [docstring] [EOL] [EOL] for plugin in DISABLED_PLUGINS : [EOL] sublime_plugin . reload_plugin ( plugin ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] import logging [EOL] import subprocess [EOL] [EOL] [EOL] def spawn ( args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if [string] not in kwargs : [EOL] kwargs [ [string] ] = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] kwargs [ [string] ] = - [number] [EOL] [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] kwargs [ [string] ] = startupinfo [EOL] [EOL] try : [EOL] return subprocess . Popen ( args , ** kwargs ) [EOL] except Exception as error : [EOL] msg = ( [string] ) . format ( args [ [number] ] , error ) [EOL] logging . error ( msg ) [EOL] raise RuntimeError ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from . doc import Doc [EOL] from . mypy import MyPy [EOL] from . lint import Lint [EOL] from . goto import Goto , GotoAssignment [EOL] from . pep8 import PEP8 [EOL] from . pep257 import PEP257 [EOL] from . mccabe import McCabe [EOL] from . rename import Rename [EOL] from . pylint import PyLint [EOL] from . pyflakes import PyFlakes [EOL] from . autoformat import AutoPep8 [EOL] from . find_usages import FindUsages [EOL] from . autocomplete import AutoComplete [EOL] from . import_validator import ImportValidator [EOL] from . complete_parameters import CompleteParameters [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PEP8 ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , settings , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . settings = settings [EOL] self . filename = filename [EOL] super ( PEP8 , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( ) . lint ( self . settings , self . code , self . filename ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PEP257 ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , ignore , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . filename = filename [EOL] self . ignore = ignore [EOL] self . linter = linter [EOL] super ( PEP257 , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( self . code , self . filename , self . ignore ) . execute ( ) , [string] : self . uid , [string] : self . vid , } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class Lint ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , settings , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . settings = settings [EOL] self . filename = filename [EOL] super ( Lint , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter . Linter ( ) . run_linter ( self . settings , self . code , self . filename ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import os [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class Rename ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script , directories , new_word , refactor ) : [EOL] self . script = script [EOL] self . new_word = new_word [EOL] self . jedi_refactor = refactor [EOL] self . directories = directories [EOL] super ( Rename , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] renames = { } [EOL] try : [EOL] usages = self . script . usages ( ) [EOL] proposals = self . jedi_refactor . rename ( self . script , self . new_word ) [EOL] for u in usages : [EOL] path = os . path . dirname ( u . module_path ) [EOL] if self . is_same_path ( path ) : [EOL] if u . module_path not in renames : [EOL] renames [ u . module_path ] = [ ] [EOL] [EOL] thefile = proposals . new_files ( ) . get ( u . module_path ) [EOL] if thefile is None : [EOL] continue [EOL] [EOL] lineno = u . line - [number] [EOL] line = thefile . splitlines ( ) [ lineno ] [EOL] renames [ u . module_path ] . append ( { [string] : lineno , [string] : line } ) [EOL] success = True [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] success = False [EOL] [EOL] self . callback ( { [string] : success , [string] : renames , [string] : self . uid } ) [EOL] [EOL] def is_same_path ( self , path ) : [EOL] [docstring] [EOL] [EOL] for directory in self . directories : [EOL] if os . path . commonprefix ( [ directory , path ] ) == directory : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PyFlakes ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , settings , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . settings = settings [EOL] self . filename = filename [EOL] super ( PyFlakes , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( ) . lint ( self . settings , self . code , self . filename ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class PyLint ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , rcfile , filename ) : [EOL] self . vid = vid [EOL] self . filename = filename [EOL] self . linter = linter [EOL] self . rcfile = rcfile [EOL] super ( PyLint , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( self . filename , self . rcfile ) . parse_errors ( ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] class Command ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid ) : [EOL] self . uid = uid [EOL] self . callback = callback [EOL] [EOL] self . run ( ) [EOL] [EOL] [EOL] def get_function_parameters ( call_def ) : [EOL] [docstring] [EOL] [EOL] if not call_def : [EOL] return [ ] [EOL] [EOL] params = [ ] [EOL] for param in call_def . params : [EOL] cleaned_param = param . get_code ( ) . strip ( ) [EOL] if [string] in cleaned_param or cleaned_param == [string] : [EOL] continue [EOL] [EOL] params . append ( [ s . strip ( ) for s in cleaned_param . split ( [string] ) ] ) [EOL] [EOL] return params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class MyPy ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , code , filename , mypypath , settings ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . filename = filename [EOL] self . mypypath = mypypath [EOL] self . settings = settings [ [string] ] [EOL] self . linter = linter [EOL] super ( MyPy , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . linter ( self . code , self . filename , self . mypypath , self . settings ) . execute ( ) , [string] : self . uid , [string] : self . vid , } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class McCabe ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , mccabe , code , threshold , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . filename = filename if filename is not None else [string] [EOL] self . threshold = threshold [EOL] self . mccabe = mccabe ( self . code , self . filename ) [EOL] super ( McCabe , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] self . callback ( { [string] : True , [string] : self . mccabe . get_code_complexity ( self . threshold ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : str ( error ) , [string] : self . uid , [string] : self . vid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . base import Command , get_function_parameters [EOL] [EOL] [EOL] class CompleteParameters ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script , settings ) : [EOL] self . script = script [EOL] self . settings = settings [EOL] super ( CompleteParameters , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] completions = [ ] [EOL] complete_all = self . settings . get ( [string] , False ) [EOL] [EOL] try : [EOL] signatures = self . script . call_signatures ( ) [ [number] ] [EOL] except IndexError : [EOL] signatures = None [EOL] [EOL] params = get_function_parameters ( signatures ) [EOL] for i , p in enumerate ( params ) : [EOL] try : [EOL] name , value = p [EOL] except ValueError : [EOL] name = p [ [number] ] [EOL] value = None [EOL] [EOL] name = name . replace ( [string] , [string] ) [EOL] if value is None : [EOL] completions . append ( [string] % ( i + [number] , name ) ) [EOL] else : [EOL] if complete_all is True : [EOL] completions . append ( [string] % ( name , i + [number] , value ) ) [EOL] [EOL] self . callback ( { [string] : True , [string] : [string] . join ( completions ) , [string] : self . uid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class ImportValidator ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , linter , code , filename ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . linter = linter [EOL] self . filename = filename [EOL] super ( ImportValidator , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] v = self . linter ( self . code , self . filename ) [EOL] self . callback ( { [string] : True , [string] : [ ] if v . is_valid ( ) else self . _convert ( v ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( error ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : error , [string] : self . uid , [string] : self . vid } ) [EOL] [EOL] def _convert ( self , validator ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] for line , lineno in validator . errors : [EOL] errors . append ( { [string] : [string] , [string] : lineno , [string] : [number] , [string] : [number] , [string] : [string] . format ( line ) , [string] : [string] , [string] : True } ) [EOL] [EOL] return errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import sys [EOL] import logging [EOL] [EOL] from . base import Command [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] import html [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] import html as cgi [EOL] from html . parser import HTMLParser [EOL] else : [EOL] [comment] [EOL] import cgi [EOL] from HTMLParser import HTMLParser [EOL] [EOL] [EOL] class Doc ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script , html ) : [EOL] self . script = script [EOL] self . html = html [EOL] super ( Doc , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] processed = [ ] [EOL] try : [EOL] definitions = self . script . goto_definitions ( ) [EOL] except Exception as error : [EOL] logging . debug ( error ) [EOL] logging . debug ( self . script ) [EOL] definitions = [ ] [EOL] [EOL] if not definitions : [EOL] success = False [EOL] docs = [ ] [EOL] else : [EOL] docs = [ ] [EOL] success = True [EOL] for definition in definitions : [EOL] if definition not in processed : [EOL] docs . append ( self . _plain ( definition ) if not self . html [EOL] else self . _html ( definition ) ) [EOL] processed . append ( definition ) [EOL] [EOL] self . callback ( { [string] : success , [string] : ( [string] if self . html [EOL] else [string] + [string] * [number] + [string] ) . join ( docs ) , [string] : self . uid } ) [EOL] [EOL] def _plain ( sef , definition ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( definition . full_name , [string] * [number] , definition . doc ) [EOL] [EOL] def _html ( self , definition ) : [EOL] [docstring] [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] escaped_doc = html . escape ( html . unescape ( definition . doc ) , quote = False ) [EOL] else : [EOL] try : [EOL] escaped_doc = cgi . escape ( HTMLParser . unescape . __func__ ( HTMLParser , definition . doc . encode ( [string] ) ) ) [EOL] except AttributeError : [EOL] [comment] [EOL] escaped_doc = cgi . escape ( HTMLParser . unescape ( HTMLParser , definition . doc ) ) [EOL] [EOL] escaped_doc = escaped_doc . replace ( [string] , [string] ) [EOL] [EOL] return [string] . format ( definition . full_name , escaped_doc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] [EOL] DEBUG_MODE = False [EOL] [EOL] [EOL] class AutoComplete ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script ) : [EOL] self . script = script [EOL] super ( AutoComplete , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] completions = self . script . completions ( ) [EOL] if DEBUG_MODE is True : [EOL] logging . info ( completions ) [EOL] data = [ ( [string] . format ( comp . name , comp . type ) , comp . name ) for comp in completions ] [EOL] self . callback ( { [string] : True , [string] : data , [string] : self . uid } ) [EOL] except Exception as error : [EOL] msg = [string] [EOL] logging . error ( msg ) [EOL] logging . error ( error ) [EOL] print ( traceback . format_exc ( ) ) [EOL] if DEBUG_MODE : [EOL] logging . debug ( traceback . format_exc ( ) ) [EOL] [EOL] self . callback ( { [string] : False , [string] : str ( error ) , [string] : self . uid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any , Set [EOL] import typing [EOL] from . base import Command [EOL] [EOL] [EOL] class Goto ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script ) : [EOL] self . script = script [EOL] super ( Goto , self ) . __init__ ( callback , uid ) [EOL] [EOL] def _get_definitions ( self ) : [EOL] definitions = self . script . goto_assignments ( ) [EOL] if all ( d . type == [string] for d in definitions ) : [EOL] definitions = self . script . goto_definitions ( ) [EOL] return definitions [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] definitions = self . _get_definitions ( ) [EOL] except : [EOL] data = [ ] [EOL] success = False [EOL] else : [EOL] [comment] [EOL] data = set ( [ ( i . full_name , i . module_path , i . line , i . column + [number] ) for i in definitions if not i . in_builtin_module ( ) ] ) [EOL] [EOL] success = True [EOL] [EOL] self . callback ( { [string] : success , [string] : list ( data ) , [string] : self . uid } ) [EOL] [EOL] [EOL] class GotoAssignment ( Goto ) : [EOL] [docstring] [EOL] [EOL] def _get_definitions ( self ) : [EOL] return self . script . goto_assignments ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown,unknown,builtins.int]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown,unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[typing.Tuple[unknown,unknown,unknown,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import logging [EOL] import traceback [EOL] [EOL] from . base import Command [EOL] from autopep . autopep8_lib import autopep8 [EOL] [EOL] [EOL] class AutoPep8 ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , vid , code , settings ) : [EOL] self . vid = vid [EOL] self . code = code [EOL] self . options = autopep8 . parse_args ( self . parse_settings ( settings ) ) [EOL] super ( AutoPep8 , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] self . code = unicode ( self . code ) [EOL] try : [EOL] self . callback ( { [string] : True , [string] : autopep8 . fix_lines ( self . code . splitlines ( ) , options = self . options ) , [string] : self . uid , [string] : self . vid } ) [EOL] except Exception as error : [EOL] logging . error ( str ( error ) ) [EOL] print ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] logging . debug ( traceback . format_exc ( ) . splitlines ( ) ) [EOL] self . callback ( { [string] : False , [string] : str ( error ) , [string] : self . uid , [string] : self . vid } ) [EOL] [EOL] def parse_settings ( self , settings ) : [EOL] [docstring] [EOL] [EOL] args = [ ] [EOL] args += [ [string] ] * settings . get ( [string] , [number] ) [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] args += [ [string] . format ( settings . get ( [string] , [number] ) ) ] [EOL] args += [ [string] . format ( settings . get ( [string] , [number] ) ) ] [EOL] args += [ [string] ] [EOL] [EOL] return args [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . base import Command [EOL] [EOL] [EOL] class FindUsages ( Command ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , uid , script ) : [EOL] self . script = script [EOL] super ( FindUsages , self ) . __init__ ( callback , uid ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] usages = self . script . usages ( ) [EOL] success = True [EOL] except : [EOL] usages = None [EOL] success = False [EOL] [EOL] try : [EOL] self . callback ( { [string] : success , [string] : [ ( i . full_name , i . module_path , i . line , i . column ) for i in usages if not i . in_builtin_module ( ) ] if usages is not None else [ ] , [string] : self . uid } ) [EOL] except ValueError : [EOL] self . callback ( { [string] : success , [string] : [ ( i . name , i . module_path , i . line , i . column ) for i in usages if not i . in_builtin_module ( ) ] if usages is not None else [ ] , [string] : self . uid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] import logging [EOL] [EOL] [EOL] class HandlerRegistry ( object ) : [EOL] [docstring] [EOL] [EOL] initialized = False [EOL] [EOL] def __init__ ( self ) : [EOL] self . _handlers = { } [EOL] [EOL] def initialize ( self ) : [EOL] [docstring] [EOL] [EOL] if self . initialized : [EOL] return [EOL] [EOL] self . _import_plugin_handlers ( ) [EOL] self . initialized = True [EOL] [EOL] def get ( self , handler_type ) : [EOL] [docstring] [EOL] [EOL] return self . _handlers . get ( handler_type ) [EOL] [EOL] def register ( self , handler ) : [EOL] [docstring] [EOL] [EOL] self . _handlers [ handler . __handler_type__ ] = handler [EOL] [EOL] def _import_plugin_handlers ( self ) : [EOL] [docstring] [EOL] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] packages = [ os . path . join ( path , f ) for f in os . listdir ( path ) if f . startswith ( [string] ) ] [EOL] for package in packages : [EOL] if [string] in package or not os . path . isdir ( package ) : [EOL] continue [EOL] [EOL] lang = package . rsplit ( [string] , [number] ) [ [number] ] [EOL] sys . path . append ( [string] . format ( package ) ) [EOL] mod_name = [string] . format ( lang ) [EOL] mod = __import__ ( mod_name , globals ( ) , locals ( ) ) [EOL] logging . info ( [string] . format ( mod ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import json [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] @ contextmanager def json_decode ( data ) : [EOL] PY26 = False [EOL] data = data . replace ( [string] , [string] ) [EOL] if sys . version_info < ( [number] , [number] , [number] ) : [EOL] PY26 = True [EOL] fixed_keys = { } [EOL] try : [EOL] if PY26 : [EOL] for k , v in json . loads ( data . decode ( [string] ) ) . iteritems ( ) : [EOL] fixed_keys [ str ( k ) ] = v [EOL] yield fixed_keys [EOL] else : [EOL] yield json . loads ( data . decode ( [string] ) ) [EOL] except ValueError : [EOL] try : [EOL] yield eval ( data ) [EOL] except Exception : [EOL] yield str ( data . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import inspect [EOL] [EOL] from . compat import AnacondaHandlerProvider [EOL] [EOL] [EOL] class AnacondaHandler ( AnacondaHandlerProvider ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , command , data , uid , vid , callback , debug = False ) : [EOL] self . uid = uid [EOL] self . vid = vid [EOL] self . data = data [EOL] self . debug = debug [EOL] self . callback = callback [EOL] self . command = command [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] command = getattr ( self , self . command ) [EOL] try : [EOL] func_code = command . func_code [EOL] except AttributeError : [EOL] [comment] [EOL] func_code = command . __code__ [EOL] [EOL] kwargs = { } [EOL] for argument , value in self . data . items ( ) : [EOL] if argument in inspect . getargs ( func_code ) . args : [EOL] kwargs [ argument ] = value [EOL] [EOL] command ( ** kwargs ) [EOL] [EOL] @ classmethod def get_handler ( cls , handler_type ) : [EOL] [docstring] [EOL] return cls . _registry . get ( handler_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . registry import HandlerRegistry [EOL] [EOL] [EOL] class AnacondaHandlerMeta ( type ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( cls , name , bases , attrs ) : [EOL] if not hasattr ( cls , [string] ) : [EOL] cls . _registry = HandlerRegistry ( ) [EOL] [EOL] if hasattr ( cls , [string] ) : [EOL] cls . _registry . register ( cls ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . meta_handler import AnacondaHandlerMeta [EOL] [EOL] [EOL] class AnacondaHandlerProvider ( metaclass = AnacondaHandlerMeta ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . meta_handler import AnacondaHandlerMeta [EOL] [EOL] [EOL] class AnacondaHandlerProvider : [EOL] [docstring] [EOL] [EOL] __metaclass__ = AnacondaHandlerMeta [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import sys [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] from . python3 import AnacondaHandlerProvider [EOL] else : [EOL] from python2 import AnacondaHandlerProvider [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
def usages_helper ( ) : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Union [EOL] import typing [EOL] import sys [EOL] [EOL] import jedi [EOL] [EOL] from commands . autocomplete import AutoComplete [EOL] from handlers . jedi_handler import JediHandler [EOL] [EOL] [EOL] class TestAutoCompletion ( object ) : [EOL] [docstring] [EOL] [EOL] def test_autocomplete_command ( self ) : [EOL] AutoComplete ( self . _check , [number] , jedi . Script ( [string] ) ) [EOL] [EOL] def test_autocomplete_handler ( self ) : [EOL] data = { [string] : [string] , [string] : [number] , [string] : [number] } [EOL] handler = JediHandler ( [string] , data , [number] , [number] , self . _check ) [EOL] handler . run ( ) [EOL] [EOL] def _check ( self , kwrgs ) : [EOL] assert kwrgs [ [string] ] is True [EOL] assert len ( kwrgs [ [string] ] ) > [number] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] assert kwrgs [ [string] ] [ [number] ] == ( [string] , [string] ) [EOL] else : [EOL] assert kwrgs [ [string] ] [ [number] ] == ( [string] , [string] ) [EOL] assert kwrgs [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , List , Any , Union [EOL] import typing_extensions [EOL] import typing [EOL] import sys [EOL] import tempfile [EOL] import os [EOL] from nose . plugins . skip import SkipTest [EOL] [EOL] from handlers . python_lint_handler import PythonLintHandler [EOL] [EOL] PYTHON3 = sys . version_info >= ( [number] , [number] ) [EOL] PYTHON26 = sys . version_info < ( [number] , [number] ) [EOL] [EOL] [EOL] class real_temp_file ( object ) : [EOL] [EOL] def __init__ ( self , contents ) : [EOL] self . contents = contents [EOL] self . filename = None [EOL] [EOL] def __enter__ ( self ) : [EOL] with tempfile . NamedTemporaryFile ( delete = False ) as f : [EOL] f . write ( self . contents . encode ( ) ) [EOL] self . filename = f . name [EOL] f . close ( ) [EOL] return self . filename [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback ) : [EOL] os . remove ( self . filename ) [EOL] [EOL] [EOL] class TestLint ( object ) : [EOL] [docstring] [EOL] [EOL] _lintable_code = [string] [EOL] [EOL] _lintable_docstring = [string] [EOL] [EOL] _import_validator_code = [string] [EOL] [EOL] _type_checkable_code = [string] [EOL] [EOL] _type_checkable_async_code = [string] [EOL] [EOL] def setUp ( self ) : [EOL] self . _settings = { [string] : False , [string] : False , [string] : False , [string] : False , [string] : False , [string] : False , [string] : [string] , [string] : [ [string] ] } [EOL] [EOL] def test_pyflakes_lint ( self ) : [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pyflakes ) [EOL] self . _settings [ [string] ] = True [EOL] handler . lint ( self . _settings , self . _lintable_code ) [EOL] [EOL] def test_pyflakes_ignore ( self ) : [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pyflakes_ignore ) [comment] [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [string] [EOL] [EOL] def test_pep8_lint ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep8 ) [EOL] handler . lint ( self . _settings , self . _lintable_code ) [EOL] [EOL] def test_pep8_ignores ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [ [string] ] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep8_ignores ) [comment] [EOL] handler . lint ( self . _settings , self . _lintable_code ) [EOL] [EOL] def test_pep8_max_line_lenght ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [number] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep8_max_line_length ) [comment] [EOL] handler . lint ( self . _settings , [string] . format ( [string] * [number] ) ) [comment] [EOL] [EOL] def test_pep257_lint ( self ) : [EOL] if PYTHON26 : [EOL] raise SkipTest ( [string] ) [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep257 ) [EOL] handler . lint ( self . _settings , self . _lintable_docstring , [string] ) [EOL] [EOL] def test_pep257_ignores ( self ) : [EOL] if PYTHON26 : [EOL] raise SkipTest ( [string] ) [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_pep257_ignores ) [comment] [EOL] handler . lint ( self . _settings , self . _lintable_docstring , [string] ) [EOL] [EOL] def test_import_validator ( self ) : [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_validate_imports ) [comment] [EOL] handler . lint ( self . _settings , self . _import_validator_code , [string] ) [EOL] [EOL] def test_mypy ( self ) : [EOL] if not PYTHON3 : [EOL] raise SkipTest ( ) [EOL] try : [EOL] import mypy [comment] [EOL] except ImportError : [EOL] raise SkipTest ( [string] ) [EOL] with real_temp_file ( self . _type_checkable_code ) as temp_file_name : [EOL] self . _settings [ [string] ] = True [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_mypy ) [EOL] handler . lint ( self . _settings , self . _type_checkable_code , temp_file_name ) [comment] [EOL] [EOL] def test_mypy_fast_parser ( self ) : [EOL] if not PYTHON3 : [EOL] raise SkipTest ( ) [EOL] try : [EOL] import mypy [comment] [EOL] except ImportError : [EOL] raise SkipTest ( [string] ) [EOL] with real_temp_file ( self . _type_checkable_async_code ) as temp_file_name : [EOL] self . _settings [ [string] ] = True [EOL] self . _settings [ [string] ] = [ [string] , [string] ] [EOL] handler = PythonLintHandler ( [string] , None , [number] , [number] , self . _check_mypy_async ) [comment] [EOL] handler . lint ( self . _settings , self . _type_checkable_code , temp_file_name ) [comment] [EOL] [EOL] def _check_pyflakes ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] err = [string] \ [EOL] if not PYTHON3 else [string] [comment] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == err [EOL] assert result [ [string] ] [ [number] ] [ [string] ] is False [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep8 ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] error1 = result [ [string] ] [ [number] ] [EOL] assert error1 [ [string] ] == [string] [comment] [EOL] assert error1 [ [string] ] == [string] [EOL] assert error1 [ [string] ] is True [EOL] error2 = result [ [string] ] [ [number] ] [EOL] assert error2 [ [string] ] == [string] [comment] [EOL] assert error2 [ [string] ] == [string] [EOL] assert error2 [ [string] ] is True [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep8_ignores ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] error1 = result [ [string] ] [ [number] ] [EOL] assert error1 [ [string] ] == [string] [comment] [EOL] assert error1 [ [string] ] == [string] [EOL] assert error1 [ [string] ] is True [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep8_max_line_length ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pyflakes_ignore ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep257 ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] raw_errors = [ r [ [string] ] for r in result [ [string] ] ] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] assert [string] in raw_errors [comment] [EOL] [EOL] error1 , error2 , error3 , error4 , error5 , _ , _ = result [ [string] ] [EOL] assert ( error1 [ [string] ] , error2 [ [string] ] , error3 [ [string] ] , error4 [ [string] ] , error5 [ [string] ] ) == ( [string] , [string] , [string] , [string] , [string] ) [comment] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_pep257_ignores ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_validate_imports ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [comment] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] is True [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_mypy ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [comment] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_mypy_async ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import sys [EOL] [EOL] import jedi [EOL] [EOL] from handlers . jedi_handler import JediHandler [EOL] from commands . complete_parameters import CompleteParameters [EOL] [EOL] PYTHON3 = sys . version_info >= ( [number] , [number] ) [EOL] [EOL] [EOL] class TestCompleteParameters ( object ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . settings = { [string] : False } [EOL] self . script = jedi . Script ( [string] ) [EOL] [EOL] def test_complete_parameters_command ( self ) : [EOL] CompleteParameters ( self . _check_parameters , [number] , self . script , self . settings ) [EOL] [EOL] def test_complete_all_parameters ( self ) : [EOL] self . settings [ [string] ] = True [EOL] CompleteParameters ( self . _check_all_parameters , [number] , self . script , self . settings ) [EOL] [EOL] def test_complete_parameters_handler ( self ) : [EOL] data = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , [string] : self . settings } [EOL] handler = JediHandler ( [string] , data , [number] , [number] , self . _check_parameters ) [EOL] handler . run ( ) [EOL] [EOL] def test_complete_all_parameters_handler ( self ) : [EOL] self . settings [ [string] ] = True [EOL] data = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None , [string] : self . settings } [EOL] handler = JediHandler ( [string] , data , [number] , [number] , self . _check_all_parameters ) [EOL] handler . run ( ) [EOL] [EOL] def _check_parameters ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert result [ [string] ] == [string] if PYTHON3 else [string] [EOL] assert result [ [string] ] == [number] [EOL] [EOL] def _check_all_parameters ( self , result ) : [EOL] assert result [ [string] ] is True [EOL] assert result [ [string] ] == [string] if PYTHON3 else [string] [comment] [EOL] assert result [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0
import sys [EOL] import pkg_resources [EOL] sys . path . insert ( [number] , [string] ) [EOL] sys . path . insert ( [number] , [string] ) [EOL] pkg_resources . declare_namespace ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Union [EOL] import _typing [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import sublime [EOL] from functools import partial [EOL] [EOL] from . _typing import Union , Dict [EOL] [EOL] [EOL] class JediUsages ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = text [EOL] [EOL] def process ( self , usages = False , data = None ) : [EOL] [docstring] [EOL] [EOL] view = self . text . view [EOL] if not data [ [string] ] : [EOL] sublime . status_message ( [string] . format ( view . substr ( view . word ( view . sel ( ) [ [number] ] ) ) ) ) [EOL] return [EOL] [EOL] definitions = data [ [string] ] if not usages else data [ [string] ] [EOL] if len ( definitions ) == [number] : [EOL] sublime . status_message ( [string] . format ( view . substr ( view . word ( view . sel ( ) [ [number] ] ) ) ) ) [EOL] return [EOL] [EOL] if definitions is not None and len ( definitions ) == [number] and not usages : [EOL] self . _jump ( * definitions [ [number] ] ) [EOL] else : [EOL] self . _show_options ( definitions , usages ) [EOL] [EOL] def _jump ( self , filename , lineno = None , columno = None , transient = False ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if type ( filename ) is int : [EOL] if filename == - [number] : [EOL] [comment] [EOL] view = self . text . view [EOL] point = self . point [EOL] [EOL] sublime . active_window ( ) . focus_view ( view ) [EOL] view . show ( point ) [EOL] [EOL] if view . sel ( ) [ [number] ] != point : [EOL] view . sel ( ) . clear ( ) [EOL] view . sel ( ) . add ( point ) [EOL] [EOL] return [EOL] [EOL] opts = self . options [ filename ] [EOL] if len ( self . options [ filename ] ) == [number] : [EOL] opts = opts [ [number] : ] [EOL] [EOL] filename , lineno , columno = opts [EOL] flags = sublime . ENCODED_POSITION [EOL] if transient : [EOL] flags |= sublime . TRANSIENT [EOL] [EOL] sublime . active_window ( ) . open_file ( [string] . format ( filename , lineno or [number] , columno or [number] ) , flags ) [EOL] [EOL] self . _toggle_indicator ( lineno , columno ) [EOL] [EOL] def _show_options ( self , defs , usages ) : [EOL] [docstring] [EOL] [EOL] view = self . text . view [EOL] if usages or ( not usages and type ( defs ) is not str ) : [EOL] if len ( defs ) == [number] : [EOL] options = [ [ o [ [number] ] , o [ [number] ] , [string] . format ( o [ [number] ] , o [ [number] ] ) ] for o in defs ] [EOL] else : [EOL] options = [ [ o [ [number] ] , [string] . format ( o [ [number] ] , o [ [number] ] ) ] for o in defs ] [EOL] else : [EOL] if len ( defs ) : [EOL] options = defs [ [number] ] [EOL] else : [EOL] sublime . status_message ( [string] . format ( view . substr ( view . word ( view . sel ( ) [ [number] ] ) ) ) ) [EOL] return [EOL] [EOL] self . options = defs [EOL] self . point = self . text . view . sel ( ) [ [number] ] [EOL] self . text . view . window ( ) . show_quick_panel ( options , self . _jump , on_highlight = partial ( self . _jump , transient = True ) ) [EOL] [EOL] def _toggle_indicator ( self , lineno = [number] , columno = [number] ) : [EOL] [docstring] [EOL] [EOL] pt = self . text . view . text_point ( lineno - [number] , columno ) [EOL] region_name = [string] . format ( self . text . view . id ( ) , lineno ) [EOL] [EOL] for i in range ( [number] ) : [EOL] delta = [number] * i * [number] [EOL] sublime . set_timeout ( lambda : self . text . view . add_regions ( region_name , [ sublime . Region ( pt , pt ) ] , [string] , [string] , sublime . DRAW_EMPTY_AS_OVERWRITE ) , delta ) [EOL] sublime . set_timeout ( lambda : self . text . view . erase_regions ( region_name ) , delta + [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_typing.Union[builtins.str,_typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sublime [EOL] [EOL] [EOL] class Integration : [EOL] [docstring] [EOL] [EOL] @ classmethod def enabled ( cls ) : [EOL] [docstring] [EOL] [EOL] globalsettings = sublime . load_settings ( [string] ) [EOL] settings = sublime . load_settings ( [string] ) [EOL] enabled = settings . get ( [string] , False ) [EOL] not_ignored = [string] not in globalsettings . get ( [string] ) [EOL] if enabled and not_ignored : [EOL] try : [EOL] from Kite . lib . installer import check [EOL] from Kite . lib . exceptions import KiteNotSupported [EOL] if not check . is_running ( ) : [EOL] return False [EOL] except ImportError : [EOL] return False [EOL] except KiteNotSupported : [EOL] [comment] [EOL] return True [EOL] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] @ classmethod def enable ( cls ) : [EOL] [docstring] [EOL] [EOL] settings = sublime . load_settings ( [string] ) [EOL] settings . set ( [string] , True ) [EOL] settings . save_settings ( [string] ) [EOL] [EOL] @ classmethod def disable ( cls ) : [EOL] [docstring] [EOL] [EOL] settings = sublime . load_settings ( [string] ) [EOL] settings . set ( [string] , False ) [EOL] settings . save_settings ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import pstats [EOL] import typing [EOL] import cProfile [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import time [EOL] import pstats [EOL] import logging [EOL] import functools [EOL] [EOL] try : [EOL] import cProfile [EOL] CPROFILE_AVAILABLE = True [EOL] except ImportError : [EOL] CPROFILE_AVAILABLE = False [EOL] [EOL] try : [EOL] import sublime [EOL] from . helpers import get_settings , project_name , is_remote_session [EOL] except ImportError : [EOL] [comment] [EOL] pass [EOL] [EOL] from . constants import WorkerStatus [EOL] [EOL] [EOL] def auto_project_switch ( func ) : [EOL] [docstring] [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( self , * args , ** kwargs ) : [EOL] [EOL] if self . status != WorkerStatus . healthy : [EOL] return [EOL] [EOL] def reconnect ( proc ) : [EOL] proc . kill ( ) [EOL] self . reconnecting = True [EOL] self . start ( ) [EOL] [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] auto_project_switch = get_settings ( view , [string] , False ) [EOL] [EOL] [comment] [EOL] python_interpreter = os . path . expandvars ( os . path . expanduser ( get_settings ( view , [string] ) ) ) [EOL] [EOL] process = self . processer . _process [EOL] if auto_project_switch and not is_remote_session ( view ) and hasattr ( self , [string] ) and ( project_name ( ) != self . project_name or process . args [ [number] ] != python_interpreter ) : [EOL] [EOL] print ( [string] ) [EOL] reconnect ( process ) [EOL] else : [EOL] func ( self , * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def auto_project_switch_ng ( func ) : [EOL] [docstring] [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( self , * args , ** kwargs ) : [EOL] [EOL] if self . status != WorkerStatus . healthy : [EOL] return [EOL] [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] project_switch = get_settings ( view , [string] , False ) [EOL] if project_switch : [EOL] python_interpreter = get_settings ( view , [string] ) [EOL] if python_interpreter != self . interpreter . raw_interpreter : [EOL] print ( [string] ) [EOL] self . on_python_interpreter_switch ( python_interpreter ) [EOL] return [EOL] [EOL] func ( self , * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def timeit ( logger ) : [EOL] [docstring] [EOL] [EOL] def decorator ( func ) : [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] starttime = time . time ( ) [EOL] result = func ( * args , ** kwargs ) [EOL] endtime = time . time ( ) [EOL] total = endtime - starttime [EOL] logger . debug ( [string] . format ( func . __name__ , total ) ) [EOL] [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] return decorator [EOL] [EOL] [EOL] def profile ( func ) : [EOL] [docstring] [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] view = sublime . active_window ( ) . active_view ( ) [EOL] [EOL] if get_settings ( view , [string] , False ) == [string] : [EOL] [EOL] if CPROFILE_AVAILABLE : [EOL] pr = cProfile . Profile ( ) [EOL] pr . enable ( ) [EOL] result = func ( * args , ** kwargs ) [EOL] pr . disable ( ) [EOL] ps = pstats . Stats ( pr , stream = sys . stdout ) [EOL] ps . sort_stats ( [string] ) [EOL] ps . print_stats ( [number] ) [EOL] else : [EOL] logging . error ( [string] [string] [string] . format ( sys . platform ) ) [EOL] result = func ( * args , ** kwargs ) [EOL] else : [EOL] result = func ( * args , ** kwargs ) [EOL] [EOL] return result [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Repr ( type ) : [EOL] [docstring] [EOL] [EOL] def __repr__ ( cls ) : [EOL] if hasattr ( cls , [string] ) : [EOL] return getattr ( cls , [string] ) ( ) [EOL] [EOL] return super ( Repr , cls ) . __repr__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , DefaultDict , List , Tuple , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import json [EOL] import logging [EOL] import functools [EOL] import traceback [EOL] import subprocess [EOL] from collections import defaultdict [EOL] [EOL] import sublime [EOL] [EOL] from . kite import Integration [EOL] [EOL] [comment] [EOL] git_installation = False [EOL] try : [EOL] import Anaconda [EOL] assert Anaconda [EOL] except ImportError : [EOL] git_installation = True [EOL] [EOL] NONE = [number] [EOL] ONLY_CODE = [number] [EOL] NOT_SCRATCH = [number] [EOL] LINTING_ENABLED = [number] [EOL] [EOL] ENVIRON_HOOK_INVALID = defaultdict ( lambda : False ) [EOL] AUTO_COMPLETION_DOT_VIEWS = [ ] [EOL] [EOL] [EOL] def dot_completion ( view ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] if ( view . window ( ) . id ( ) , view . id ( ) ) in AUTO_COMPLETION_DOT_VIEWS : [EOL] return True [EOL] [EOL] for trigger in view . settings ( ) . get ( [string] , [ ] ) : [EOL] if trigger . get ( [string] , [string] ) == [string] : [EOL] if [string] in trigger . get ( [string] ) : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def enable_dot_completion ( view ) : [EOL] [docstring] [EOL] [EOL] global AUTO_COMPLETION_DOT_VIEWS [EOL] [EOL] if view is None : [EOL] return [EOL] [EOL] triggers = view . settings ( ) . get ( [string] , [ ] ) [EOL] triggers . append ( { [string] : [string] , [string] : [string] } ) [EOL] view . settings ( ) . set ( [string] , triggers ) [EOL] [EOL] AUTO_COMPLETION_DOT_VIEWS . append ( ( view . window ( ) . id ( ) , view . id ( ) ) ) [EOL] [EOL] [EOL] def completion_is_disabled ( view ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] [comment] [EOL] if Integration . enabled ( ) : [EOL] return True [EOL] [EOL] return get_settings ( view , [string] , False ) [EOL] [EOL] [EOL] def is_code ( view , lang = [string] , ignore_comments = False , ignore_repl = False ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] [comment] [EOL] if view . settings ( ) . get ( [string] , False ) : [EOL] if not ignore_repl : [EOL] return False [EOL] [EOL] try : [EOL] location = view . sel ( ) [ [number] ] . begin ( ) [EOL] except IndexError : [EOL] return False [EOL] [EOL] if ignore_comments is True : [EOL] matcher = [string] . format ( lang ) [EOL] else : [EOL] matcher = [string] . format ( lang ) [EOL] [EOL] return view . match_selector ( location , matcher ) [EOL] [EOL] [EOL] def is_python ( view , ignore_comments = False , autocomplete_ignore_repl = False ) : [EOL] [docstring] [EOL] [EOL] if view is None : [EOL] return False [EOL] [EOL] [comment] [EOL] if view . settings ( ) . get ( [string] , False ) : [EOL] if not autocomplete_ignore_repl : [EOL] return False [EOL] [EOL] try : [EOL] location = view . sel ( ) [ [number] ] . begin ( ) [EOL] except IndexError : [EOL] return False [EOL] [EOL] if ignore_comments is True : [EOL] matcher = [string] [EOL] else : [EOL] matcher = [string] [EOL] [EOL] return view . match_selector ( location , matcher ) [EOL] [EOL] [EOL] def check_linting ( view , mask , code = [string] ) : [EOL] [docstring] [EOL] [EOL] if mask & ONLY_CODE and not is_code ( view , lang = code , ignore_comments = True ) : [EOL] return False [EOL] [EOL] if mask & NOT_SCRATCH and view . is_scratch ( ) : [EOL] return False [EOL] [EOL] if ( mask & LINTING_ENABLED and not get_settings ( view , [string] , False ) ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def check_linting_behaviour ( view , behaviours ) : [EOL] [docstring] [EOL] [EOL] b = get_settings ( view , [string] , [string] ) [EOL] return b in behaviours [EOL] [EOL] [EOL] def create_subprocess ( args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if [string] not in kwargs : [EOL] kwargs [ [string] ] = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] kwargs [ [string] ] = - [number] [EOL] [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] kwargs [ [string] ] = startupinfo [EOL] [EOL] if sublime . platform ( ) == [string] : [EOL] env = kwargs [ [string] ] if [string] in kwargs else os . environ . copy ( ) [EOL] if [string] in kwargs : [EOL] env = env [EOL] [EOL] env [ [string] ] = [string] [EOL] kwargs [ [string] ] = env [EOL] [EOL] try : [EOL] return subprocess . Popen ( args , ** kwargs ) [EOL] except Exception as e : [EOL] logging . error ( [string] [string] [string] [string] . format ( args [ [number] ] , e ) ) [EOL] [EOL] [EOL] def get_settings ( view , name , default = None ) : [EOL] [docstring] [EOL] [EOL] global ENVIRON_HOOK_INVALID [EOL] [EOL] if view is None : [EOL] return default [EOL] [EOL] plugin_settings = sublime . load_settings ( [string] ) [EOL] [EOL] if ( name in ( [string] , [string] ) and not ENVIRON_HOOK_INVALID [ view . id ( ) ] ) : [EOL] if view . window ( ) is not None and view . window ( ) . folders ( ) : [EOL] dirname = view . window ( ) . folders ( ) [ [number] ] [EOL] while True : [EOL] environfile = os . path . join ( dirname , [string] ) [EOL] if os . path . exists ( environfile ) and os . path . isfile ( environfile ) : [EOL] [comment] [EOL] with open ( environfile , [string] ) as jsonfile : [EOL] try : [EOL] data = json . loads ( jsonfile . read ( ) ) [EOL] except Exception as error : [EOL] sublime . error_message ( [string] [string] [string] [string] [string] . format ( environfile ) ) [EOL] logging . error ( error ) [EOL] ENVIRON_HOOK_INVALID [ view . id ( ) ] = True [EOL] break [comment] [EOL] else : [EOL] r = data . get ( name , view . settings ( ) . get ( name , plugin_settings . get ( name , default ) ) ) [EOL] w = view . window ( ) [EOL] if w is not None : [EOL] return sublime . expand_variables ( r , w . extract_variables ( ) ) [EOL] [EOL] return r [EOL] else : [EOL] parts = os . path . split ( dirname ) [EOL] if len ( parts [ [number] ] ) > [number] : [EOL] dirname = os . path . dirname ( dirname ) [EOL] else : [EOL] break [comment] [EOL] [EOL] r = view . settings ( ) . get ( name , plugin_settings . get ( name , default ) ) [EOL] if name == [string] : [EOL] r = expand ( view , r ) [EOL] elif name == [string] : [EOL] if isinstance ( r , ( list , tuple ) ) : [EOL] r = [ expand ( view , e ) for e in r ] [EOL] else : [EOL] r = expand ( view , r ) [EOL] [EOL] return r [EOL] [EOL] [EOL] def expand ( view , path ) : [EOL] [docstring] [EOL] [EOL] window = view . window ( ) [EOL] if window is not None : [EOL] tmp = sublime . expand_variables ( path , window . extract_variables ( ) ) [EOL] tmp = os . path . expanduser ( os . path . expandvars ( tmp ) ) [EOL] else : [EOL] return path [EOL] [EOL] return tmp [EOL] [EOL] [EOL] def active_view ( ) : [EOL] [docstring] [EOL] [EOL] return sublime . active_window ( ) . active_view ( ) [EOL] [EOL] [EOL] def is_remote_session ( view ) : [EOL] [docstring] [EOL] [EOL] if [string] in get_interpreter ( view ) : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def prepare_send_data ( location , method , handler ) : [EOL] [docstring] [EOL] [EOL] view = active_view ( ) [EOL] return { [string] : view . substr ( sublime . Region ( [number] , view . size ( ) ) ) , [string] : location [ [number] ] + [number] , [string] : location [ [number] ] , [string] : view . file_name ( ) or [string] , [string] : method , [string] : handler } [EOL] [EOL] [EOL] def project_name ( ) : [EOL] [docstring] [EOL] [EOL] window = sublime . active_window ( ) [EOL] project_name = window . project_file_name ( ) [EOL] if project_name is None : [EOL] folders = window . folders ( ) [EOL] if len ( folders ) > [number] : [EOL] try : [EOL] project_name = window . folders ( ) [ [number] ] . rsplit ( os . sep , [number] ) [ [number] ] [EOL] except IndexError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v = active_view ( ) [EOL] if v is not None and v . file_name ( ) is not None : [EOL] project_name = v . file_name ( ) . rsplit ( os . sep , [number] ) [ [number] ] [EOL] else : [EOL] project_name = [string] . format ( id = window . window_id ) [EOL] else : [EOL] project_name = [string] . format ( id = window . window_id ) [EOL] else : [EOL] project_name = project_name . rsplit ( os . sep , [number] ) [ [number] ] . split ( [string] ) [ [number] ] [EOL] [EOL] return project_name [EOL] [EOL] [EOL] def get_traceback ( ) : [EOL] [docstring] [EOL] [EOL] traceback_log = [ ] [EOL] for traceback_line in traceback . format_exc ( ) . splitlines ( ) : [EOL] traceback_log . append ( traceback_line ) [EOL] [EOL] return [string] . join ( traceback_log ) [EOL] [EOL] [EOL] def get_view ( window , vid ) : [EOL] [docstring] [EOL] [EOL] for view in window . views ( ) : [EOL] if view . id ( ) == vid : [EOL] return view [EOL] [EOL] [EOL] def get_window_view ( vid ) : [EOL] [docstring] [EOL] [EOL] for window in sublime . windows ( ) : [EOL] view = get_view ( window , vid ) [EOL] if view is not None : [EOL] return view [EOL] [EOL] [EOL] def cache ( func ) : [EOL] [docstring] [EOL] [EOL] cache = { } [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] if [string] in kwargs : [EOL] cache . pop ( func . __name__ ) [EOL] [EOL] result = cache . get ( func . __name__ , cache . setdefault ( func . __name__ , func ( * args , ** kwargs ) ) ) [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] @ cache def valid_languages ( ** kwargs ) : [EOL] [docstring] [EOL] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , os . pardir ) [EOL] languages = [ f . rsplit ( [string] , [number] ) [ [number] ] . lower ( ) for f in os . listdir ( path ) if f . startswith ( [string] ) and [string] not in f ] [EOL] [EOL] return [ [string] ] + languages [EOL] [EOL] [EOL] def get_interpreter ( view ) : [EOL] [docstring] [EOL] [EOL] return get_settings ( view , [string] , [string] ) [EOL] [EOL] [EOL] def debug_enabled ( view ) : [EOL] [docstring] [EOL] [EOL] return get_settings ( active_view ( ) , [string] , False ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] import platform [EOL] import tempfile [EOL] [EOL] [EOL] class UnixSocketPath ( object ) : [EOL] [docstring] [EOL] [EOL] socketpath = { [string] : os . path . join ( [string] , [string] , [string] , [string] , [string] ) , [string] : os . path . join ( [string] , [string] , [string] , [string] ) } [EOL] [EOL] def __init__ ( self , project ) : [EOL] self . __project = project [EOL] self . __socket_file = os . path . join ( os . path . expanduser ( UnixSocketPath . socketpath . get ( platform . system ( ) . lower ( ) ) ) , project or [string] , [string] ) [EOL] [EOL] @ property def socket ( self ) : [EOL] [docstring] [EOL] [EOL] if len ( self . __socket_file ) < [number] : [EOL] return self . __socket_file [EOL] [EOL] socket_path = os . path . join ( tempfile . gettempdir ( ) , self . __project or [string] , [string] ) [EOL] if len ( socket_path ) > [number] : [EOL] [comment] [EOL] socket_path = os . path . join ( tempfile . gettempdir ( ) , self . __project [ : [number] ] , [string] ) [EOL] [EOL] return socket_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import threading [EOL] import subprocess [EOL] [EOL] from . logger import Log [EOL] from . contexts import vagrant_root [EOL] from . helpers import create_subprocess [EOL] [EOL] PIPE = subprocess . PIPE [EOL] [EOL] [EOL] class VagrantBase ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine ) : [EOL] super ( VagrantBase , self ) . __init__ ( ) [EOL] self . machine = machine if machine is not None else [string] [EOL] self . callback = callback [EOL] self . vagrant_root = vagrant_root [EOL] [EOL] def wait_answer ( self , args ) : [EOL] [docstring] [EOL] [EOL] with vagrant_root ( self . vagrant_root ) : [EOL] proc = create_subprocess ( args , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] output , error = proc . communicate ( ) [EOL] [EOL] self . callback ( ( proc . poll ( ) == [number] , output , error ) ) [EOL] [EOL] [EOL] class VagrantInit ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , box ) : [EOL] super ( VagrantInit , self ) . __init__ ( callback , vagrant_root ) [EOL] self . box = box [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . box ] ) [EOL] [EOL] [EOL] class VagrantUp ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine = None ) : [EOL] super ( VagrantUp , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . machine ] ) [EOL] [EOL] [EOL] class VagrantReload ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine = None ) : [EOL] super ( VagrantReload , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . machine ] ) [EOL] [EOL] [EOL] class VagrantStatus ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , machine = None , full = False ) : [EOL] super ( VagrantStatus , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . full = full [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] args = [ [string] , [string] , self . machine ] [EOL] with vagrant_root ( self . vagrant_root ) : [EOL] proc = create_subprocess ( args , stdout = subprocess . PIPE , stderr = subprocess . PIPE , cwd = os . getcwd ( ) ) [EOL] output , error = proc . communicate ( ) [EOL] [EOL] if proc . poll ( ) != [number] : [EOL] self . callback ( ( False , error ) ) [EOL] else : [EOL] running = [string] in output [EOL] self . callback ( ( True , running if not self . full else output ) ) [EOL] [EOL] [EOL] class VagrantSSH ( VagrantBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback , vagrant_root , cmd , machine = None ) : [EOL] super ( VagrantSSH , self ) . __init__ ( callback , vagrant_root , machine ) [EOL] self . cmd = cmd [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] self . wait_answer ( [ [string] , [string] , self . machine , [string] , self . cmd ] ) [EOL] [EOL] [EOL] class VagrantIPAddress ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , root , machine = None , iface = [string] ) : [EOL] [EOL] with vagrant_root ( root ) : [EOL] cmd = ( [string] [string] [string] [string] ) . format ( iface ) [EOL] proc = create_subprocess ( [ [string] , [string] , machine , [string] , cmd ] , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] [EOL] output , error = proc . communicate ( ) [EOL] if proc . poll ( ) != [number] : [EOL] self . ip_address = None [EOL] else : [EOL] self . ip_address = output [EOL] [EOL] [EOL] class VagrantIPAddressGlobal ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , machine , iface = [string] ) : [EOL] [EOL] cmd = ( [string] [string] [string] [string] ) . format ( iface ) [EOL] proc = create_subprocess ( [ [string] , [string] , machine , [string] , cmd ] , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] [EOL] output , error = proc . communicate ( ) [EOL] if proc . poll ( ) != [number] : [EOL] self . ip_address = None [EOL] else : [EOL] self . ip_address = output [EOL] [EOL] [EOL] class VagrantMachineGlobalInfo ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , machine ) : [EOL] self . machine = machine [EOL] self . status = [string] [EOL] self . machine_id = [string] [EOL] [EOL] args = ( [string] , [string] ) [EOL] p = create_subprocess ( args , stdout = PIPE , stderr = PIPE ) [EOL] if p is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] output , err = p . communicate ( ) [EOL] if err : [EOL] raise RuntimeError ( err ) [EOL] [EOL] for line in output . splitlines ( ) [ [number] : ] : [EOL] if not line : [EOL] continue [EOL] [EOL] if line . startswith ( [string] ) : [EOL] break [EOL] [EOL] data = line . split ( ) [EOL] if not data : [EOL] continue [EOL] [EOL] if data [ [number] ] . decode ( [string] ) == machine : [EOL] self . machine_id = data [ [number] ] . decode ( [string] ) [EOL] self . status = data [ [number] ] . decode ( [string] ) [EOL] self . directory = data [ [number] ] . decode ( [string] ) [EOL] break [EOL] [EOL] [EOL] class VagrantStartMachine ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , machine , directory ) : [EOL] with vagrant_root ( directory ) : [EOL] args = ( [string] , [string] , machine ) [EOL] p = create_subprocess ( args , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] if p is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] output , err = p . communicate ( ) [EOL] Log . info ( output . decode ( [string] ) ) [EOL] if err : [EOL] [comment] [EOL] info = VagrantMachineGlobalInfo ( machine ) [EOL] if info . status != [string] : [EOL] raise RuntimeError ( err ) [EOL] [EOL] Log . error ( err . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.list$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import glob [EOL] import logging [EOL] from string import Template [EOL] [EOL] import sublime [EOL] [EOL] from . helpers import get_settings [EOL] [EOL] [EOL] class Phantom ( object ) : [EOL] [docstring] [EOL] [EOL] themes = { } [comment] [EOL] templates = { } [comment] [EOL] loaded = False [EOL] phantomsets = { } [EOL] [EOL] def __init__ ( self ) : [EOL] if int ( sublime . version ( ) ) < [number] : [EOL] return [EOL] [EOL] if Phantom . loaded is False : [EOL] self . _load_css_themes ( ) [EOL] self . _load_phantom_templates ( ) [EOL] Phantom . loaded = True [EOL] [EOL] def clear_phantoms ( self , view ) : [EOL] if not self . loaded : [EOL] return [EOL] [EOL] vid = view . id ( ) [EOL] if vid in self . phantomsets : [EOL] self . phantomsets [ vid ] . update ( [ ] ) [EOL] [EOL] def update_phantoms ( self , view , phantoms ) : [EOL] if not self . loaded : [EOL] return [EOL] [EOL] thmname = get_settings ( view , [string] , [string] ) [EOL] tplname = get_settings ( view , [string] , [string] ) [EOL] [EOL] thm = self . themes . get ( thmname , self . themes [ [string] ] ) [EOL] tpl = self . templates . get ( tplname , self . templates [ [string] ] ) [EOL] [EOL] vid = view . id ( ) [EOL] if vid not in self . phantomsets : [EOL] self . phantomsets [ vid ] = sublime . PhantomSet ( view , [string] ) [EOL] [EOL] sublime_phantoms = [ ] [EOL] for item in phantoms : [EOL] region = view . full_line ( view . text_point ( item [ [string] ] , [number] ) ) [EOL] context = { [string] : thm } [EOL] context . update ( item ) [EOL] content = tpl . safe_substitute ( context ) [EOL] sublime_phantoms . append ( sublime . Phantom ( region , content , sublime . LAYOUT_BLOCK ) ) [EOL] [EOL] self . phantomsets [ vid ] . update ( sublime_phantoms ) [EOL] [EOL] def _load_phantom_templates ( self ) : [EOL] [docstring] [EOL] [EOL] template_files_pattern = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] , [string] , [string] ) [EOL] for template_file in glob . glob ( template_files_pattern ) : [EOL] with open ( template_file , [string] , encoding = [string] ) as tplfile : [EOL] tplname = os . path . basename ( template_file ) . split ( [string] ) [ [number] ] [EOL] tpldata = [string] . format ( tplfile . read ( ) ) [EOL] self . templates [ tplname ] = Template ( tpldata ) [EOL] [EOL] def _load_css_themes ( self ) : [EOL] [docstring] [EOL] [EOL] css_files_pattern = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] , [string] ) [EOL] for css_file in glob . glob ( css_files_pattern ) : [EOL] logging . info ( [string] . format ( self . _load_css ( css_file ) ) ) [EOL] [EOL] packages = sublime . active_window ( ) . extract_variables ( ) [ [string] ] [EOL] user_css_path = os . path . join ( packages , [string] , [string] ) [EOL] if os . path . exists ( user_css_path ) : [EOL] css_files_pattern = os . path . join ( user_css_path , [string] ) [EOL] for css_file in glob . glob ( css_files_pattern ) : [EOL] logging . info ( [string] , self . _load_css ( css_file ) ) [EOL] [EOL] def _load_css ( self , css_file ) : [EOL] [docstring] [EOL] [EOL] theme_name = os . path . basename ( css_file ) . split ( [string] ) [ [number] ] [EOL] with open ( css_file , [string] ) as resource : [EOL] self . themes [ theme_name ] = resource . read ( ) [EOL] [EOL] return theme_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import _typing [EOL] import typing [EOL] import sublime [EOL] import builtins [EOL] import sublime [EOL] [EOL] from . _typing import List [EOL] from Default . history_list import get_jump_history_for_view [EOL] [EOL] [EOL] class ExplorerPanel : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , view , options ) : [EOL] self . options = options [EOL] self . view = view [EOL] self . selected = [ ] [comment] [EOL] self . restore_point = view . sel ( ) [ [number] ] [EOL] [EOL] def show ( self , cluster , forced = False ) : [EOL] [docstring] [EOL] [EOL] if not cluster : [EOL] cluster = self . options [EOL] [EOL] if len ( cluster ) == [number] and not forced : [EOL] try : [EOL] Jumper ( self . view , cluster [ [number] ] [ [string] ] ) . jump ( ) [EOL] except KeyError : [EOL] if len ( cluster [ [number] ] . get ( [string] , [ ] ) ) == [number] and not forced : [EOL] Jumper ( self . view , cluster [ [number] ] [ [string] ] [ [number] ] [ [string] ] ) . jump ( ) [EOL] return [EOL] [EOL] self . last_cluster = cluster [EOL] quick_panel_options = [ ] [EOL] for data in cluster : [EOL] tmp = [ data [ [string] ] ] [EOL] if [string] in data : [EOL] tmp . append ( data [ [string] ] ) [EOL] if [string] in data : [EOL] tmp . append ( data [ [string] ] ) [EOL] quick_panel_options . append ( tmp ) [EOL] [EOL] self . view . window ( ) . show_quick_panel ( quick_panel_options , on_select = self . on_select , on_highlight = lambda index : self . on_select ( index , True ) ) [EOL] [EOL] def on_select ( self , index , transient = False ) : [EOL] [docstring] [EOL] [EOL] if index == - [number] : [EOL] self . _restore_view ( ) [EOL] return [EOL] [EOL] cluster = self . last_cluster [EOL] node = cluster [ index ] [EOL] if transient and [string] in node : [EOL] return [EOL] [EOL] if [string] in node : [EOL] self . prev_cluster = self . last_cluster [EOL] opts = node [ [string] ] [ : ] [EOL] opts . insert ( [number] , { [string] : [string] , [string] : [string] } ) [EOL] sublime . set_timeout ( lambda : self . show ( opts ) , [number] ) [EOL] else : [EOL] if node [ [string] ] == [string] and not transient : [EOL] sublime . set_timeout ( lambda : self . show ( self . prev_cluster ) , [number] ) [EOL] elif node [ [string] ] != [string] : [EOL] Jumper ( self . view , node [ [string] ] ) . jump ( transient ) [EOL] [EOL] def _restore_view ( self ) : [EOL] [docstring] [EOL] [EOL] sublime . active_window ( ) . focus_view ( self . view ) [EOL] self . view . show ( self . restore_point ) [EOL] [EOL] if self . view . sel ( ) [ [number] ] != self . restore_point : [EOL] self . view . sel ( ) . clear ( ) [EOL] self . view . sel ( ) . add ( self . restore_point ) [EOL] [EOL] [EOL] class Jumper : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , view , position ) : [EOL] self . position = position [EOL] self . view = view [EOL] [EOL] def jump ( self , transient = False ) : [EOL] [docstring] [EOL] [EOL] flags = sublime . ENCODED_POSITION [EOL] if transient is True : [EOL] flags |= sublime . TRANSIENT [EOL] [EOL] get_jump_history_for_view ( self . view ) . push_selection ( self . view ) [EOL] sublime . active_window ( ) . open_file ( self . position , flags ) [EOL] if not transient : [EOL] self . _toggle_indicator ( ) [EOL] [EOL] def _toggle_indicator ( self ) : [EOL] [docstring] [EOL] [EOL] path , line , column = self . position . rsplit ( [string] , [number] ) [EOL] pt = self . view . text_point ( int ( line ) - [number] , int ( column ) ) [EOL] region_name = [string] . format ( self . view . id ( ) , line ) [EOL] [EOL] for i in range ( [number] ) : [EOL] delta = [number] * i * [number] [EOL] sublime . set_timeout ( lambda : self . view . add_regions ( region_name , [ sublime . Region ( pt , pt ) ] , [string] , [string] , sublime . DRAW_EMPTY_AS_OVERWRITE ) , delta ) [EOL] sublime . set_timeout ( lambda : self . view . erase_regions ( region_name ) , delta + [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . anaconda_lib import aenum as enum [EOL] [EOL] [EOL] class WorkerStatus ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] incomplete = [number] [EOL] healthy = [number] [EOL] faulty = [number] [EOL] quiting = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import pickle [EOL] import logging [EOL] [EOL] [EOL] class PersistentList ( list ) : [EOL] [EOL] [docstring] [EOL] [EOL] _file_path = os . path . join ( os . path . dirname ( __file__ ) , os . pardir , [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] [EOL] super ( PersistentList , self ) . __init__ ( ) [EOL] try : [EOL] with open ( self . _file_path , [string] ) as fileobj : [EOL] self . load ( fileobj ) [EOL] except IOError : [EOL] pass [EOL] except Exception as e : [EOL] logging . error ( [string] . format ( e ) ) [EOL] os . remove ( self . _file_path ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [EOL] super ( PersistentList , self ) . __setitem__ ( key , value ) [EOL] self . sync ( ) [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] [EOL] super ( PersistentList , self ) . __delitem__ ( key ) [EOL] self . sync ( ) [EOL] [EOL] def append ( self , value ) : [EOL] [EOL] super ( PersistentList , self ) . append ( value ) [EOL] self . sync ( ) [EOL] [EOL] def remove ( self , value ) : [EOL] [EOL] super ( PersistentList , self ) . remove ( value ) [EOL] self . sync ( ) [EOL] [EOL] def pop ( self , index = None ) : [EOL] [EOL] if index is not None : [EOL] value = super ( PersistentList , self ) . pop ( index ) [EOL] else : [EOL] value = super ( PersistentList , self ) . pop ( ) [EOL] [EOL] self . sync ( ) [EOL] return value [EOL] [EOL] def sort ( self , ** kwargs ) : [EOL] [EOL] super ( PersistentList , self ) . sort ( ** kwargs ) [EOL] self . sync ( ) [EOL] [EOL] def load ( self , fileobj ) : [EOL] [docstring] [EOL] [EOL] return self . extend ( pickle . load ( fileobj ) ) [EOL] [EOL] def sync ( self ) : [EOL] [docstring] [EOL] [EOL] with open ( self . _file_path , [string] ) as fileobj : [EOL] l = [ i for i in list ( self ) if type ( i ) is str or type ( i ) is bytes ] [EOL] return pickle . dump ( l , fileobj , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.bytes,builtins.str]]$ 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] import os [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] @ contextmanager def vagrant_root ( directory ) : [EOL] current_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . expanduser ( directory ) ) [EOL] yield [EOL] os . chdir ( current_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Type [EOL] import typing [EOL] import logging [EOL] import sys [EOL] import logging [EOL] import functools [EOL] [EOL] import sublime [EOL] [EOL] from . helpers import get_settings , active_view [EOL] [EOL] [EOL] def prevent_spam ( func ) : [EOL] [docstring] [EOL] [EOL] _last_messages = { } [EOL] [EOL] def _remove_from_cache ( args ) : [EOL] m = _last_messages . pop ( args ) [EOL] if m == [number] : [EOL] return [EOL] [EOL] method = getattr ( Log . _logger , args [ [number] ] ) [EOL] method ( [string] . format ( args [ [number] ] , [string] if m == [number] else [string] . format ( m ) ) ) [EOL] [EOL] @ functools . wraps ( func ) def wrapper ( cls , * args , ** kwargs ) : [EOL] if args in _last_messages : [EOL] _last_messages [ args ] += [number] [EOL] return [EOL] [EOL] _last_messages [ args ] = [number] [EOL] sublime . set_timeout_async ( lambda : _remove_from_cache ( args ) , [number] ) [EOL] func ( cls , args [ [number] ] , * args [ [number] : ] , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] class MetaLog ( type ) : [EOL] [EOL] def __new__ ( cls , name , bases , attrs , ** kwargs ) : [EOL] log_level = get_settings ( active_view ( ) , [string] , [string] ) [EOL] if log_level not in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] log_level = [string] [EOL] [EOL] cls . _logger = logging . getLogger ( [string] ) [EOL] cls . _logger . setLevel ( logging . __getattribute__ ( log_level . upper ( ) ) ) [EOL] log_handler = logging . StreamHandler ( sys . stdout ) [EOL] log_handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] [EOL] cls . _logger . addHandler ( log_handler ) [EOL] cls . _logger . propagate = False [EOL] [EOL] obj = super ( ) . __new__ ( cls , name , bases , attrs ) [EOL] for method in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] setattr ( obj , method , functools . partial ( obj . write , method ) ) [EOL] [EOL] return obj [EOL] [EOL] [EOL] class Log ( metaclass = MetaLog ) : [EOL] [docstring] [EOL] [EOL] @ classmethod @ prevent_spam def write ( cls , method , * args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] f = getattr ( cls . _logger , method ) [EOL] f ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import threading [EOL] [EOL] import sublime [EOL] [EOL] [EOL] class ProgressBar ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] class Status ( object ) : [EOL] NONE = None [EOL] SUCCESS = [string] [EOL] FAILURE = [string] [EOL] TIMEOUT = [string] [EOL] [EOL] def __init__ ( self , messages ) : [EOL] threading . Thread . __init__ ( self ) [EOL] self . messages = messages [EOL] self . addition = [number] [EOL] self . die = False [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] sublime . set_timeout ( lambda : self . update ( [number] ) , [number] ) [EOL] [EOL] def update ( self , i ) : [EOL] [docstring] [EOL] [EOL] if self . die : [EOL] return [EOL] [EOL] size = [number] [EOL] pos = i % size [EOL] status = [string] . format ( [string] * pos , [string] * ( ( size - [number] ) - pos ) ) [EOL] [EOL] sublime . status_message ( [string] . format ( self . messages [ [string] ] , status ) ) [EOL] [EOL] if not ( size - [number] ) - pos : [EOL] self . addition = - [number] [EOL] if not pos : [EOL] self . addition = [number] [EOL] [EOL] i += self . addition [EOL] [EOL] sublime . set_timeout_async ( lambda : self . update ( i ) , [number] ) [EOL] [EOL] def terminate ( self , status = None ) : [EOL] [docstring] [EOL] status = status or self . Status . SUCCESS [EOL] [EOL] message = self . messages . get ( status ) or self . messages [ self . Status . SUCCESS ] [comment] [EOL] sublime . status_message ( message ) [EOL] self . die = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi import Script [EOL] [EOL] [EOL] class Validator : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source , filename ) : [EOL] self . source = source [EOL] self . errors = [ ] [comment] [EOL] self . filename = filename [EOL] [EOL] def is_valid ( self ) : [EOL] [docstring] [EOL] [EOL] for line , lineno in self . _extract_imports ( ) : [EOL] error , valid = self . _validate_import ( line , lineno ) [EOL] if not valid : [EOL] self . errors . append ( ( error , lineno ) ) [EOL] [EOL] return not self . errors [EOL] [EOL] def _validate_import ( self , module_line , lineno ) : [EOL] [docstring] [EOL] [EOL] if [string] in module_line : [EOL] return True [EOL] [EOL] error = [ ] [EOL] error_string = [string] [EOL] valid = True [EOL] for word in module_line . split ( ) : [EOL] if word in ( [string] , [string] , [string] ) : [EOL] continue [EOL] [EOL] offset = int ( module_line . find ( word ) + len ( word ) / [number] ) [EOL] s = Script ( self . source , lineno , offset , self . filename ) [EOL] if not self . filename : [EOL] s = Script ( module_line , [number] , offset ) [EOL] [EOL] if not s . goto_assignments ( ) : [EOL] if valid is True : [EOL] valid = False [EOL] error . append ( word ) [EOL] [EOL] err = [string] if valid else error_string . format ( [string] . join ( error ) ) [EOL] return err , valid [EOL] [EOL] def _extract_imports ( self ) : [EOL] [docstring] [EOL] [EOL] found = [ ] [EOL] lineno = [number] [EOL] buffer_found = [ ] [comment] [EOL] in_docstring = False [EOL] for line in self . source . splitlines ( ) : [EOL] if self . __detect_docstring ( line ) : [EOL] if in_docstring : [EOL] in_docstring = False [EOL] else : [EOL] in_docstring = True [EOL] lineno += [number] [EOL] continue [EOL] else : [EOL] line = line . strip ( ) [EOL] if len ( buffer_found ) > [number] : [EOL] if [string] in line : [EOL] buffer_found . append ( line . replace ( [string] , [string] ) . strip ( ) ) [EOL] found . append ( ( [string] . join ( buffer_found ) , lineno ) ) [EOL] buffer_found = [ ] [EOL] else : [EOL] buffer_found . append ( line ) [EOL] else : [EOL] if self . __detect_docstring ( line ) : [EOL] continue [EOL] if line . startswith ( [string] ) or line . startswith ( [string] ) : [EOL] if [string] in line : [EOL] buffer_found . append ( line . replace ( [string] , [string] ) . strip ( ) ) [EOL] else : [EOL] found . append ( ( line , lineno ) ) [EOL] lineno += [number] [EOL] return found [EOL] [EOL] def __detect_docstring ( self , line ) : [EOL] [docstring] [EOL] [EOL] if [string] in line or [string] in line : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[Variable[_T]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[Variable[_T]]$ 0 0 $builtins.int$ 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 0 0 0 0 $typing.List[Variable[_T]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[Variable[_T]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import string [EOL] import typing [EOL] import os [EOL] from string import Template [EOL] [EOL] import sublime [EOL] [EOL] from . . helpers import get_settings , active_view , is_remote_session [EOL] [EOL] [EOL] class AnacondaSetPythonBuilder ( object ) : [EOL] [docstring] [EOL] [EOL] def update_interpreter_build_system ( self , cmd ) : [EOL] [docstring] [EOL] [EOL] view = active_view ( ) [EOL] if get_settings ( view , [string] , True ) is False : [EOL] return [EOL] [EOL] if is_remote_session ( view ) : [EOL] return [EOL] [EOL] if cmd is None : [EOL] sublime . message_dialog ( [string] ) [EOL] return [EOL] [EOL] project = self . _get_project ( ) [EOL] if project . get ( [string] , False ) is not False : [EOL] if type ( project [ [string] ] ) is list : [EOL] done = False [EOL] current_list = project [ [string] ] [EOL] for i in range ( len ( current_list ) ) : [EOL] build = current_list [ i ] [EOL] if build [ [string] ] == [string] : [EOL] current_list [ i ] = self . _parse_tpl ( cmd ) [EOL] done = True [EOL] break [EOL] [EOL] if not done : [EOL] project [ [string] ] . append ( self . _parse_tpl ( cmd ) ) [EOL] else : [EOL] sublime . message_dialog ( [string] ) [EOL] else : [EOL] project . update ( { [string] : [ self . _parse_tpl ( cmd ) ] } ) [EOL] [EOL] self . _save_project ( project ) [EOL] [EOL] def _get_project ( self ) : [EOL] [docstring] [EOL] [EOL] return sublime . active_window ( ) . project_data ( ) [EOL] [EOL] def _parse_tpl ( self , cmd ) : [EOL] [docstring] [EOL] [EOL] template_file = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , [string] ) [EOL] with open ( template_file , [string] , encoding = [string] ) as tplfile : [EOL] template = Template ( tplfile . read ( ) ) [EOL] [EOL] cmd = cmd . replace ( [string] , [string] ) [EOL] return sublime . decode_value ( template . safe_substitute ( { [string] : cmd } ) ) [EOL] [EOL] def _save_project ( self , project_data ) : [EOL] [docstring] [EOL] [EOL] sublime . active_window ( ) . set_project_data ( project_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $string.Template$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $string.Template$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import platform [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] case_insensitive_completion = True [EOL] [docstring] [EOL] [EOL] add_bracket_after_function = False [EOL] [docstring] [EOL] [EOL] no_completion_duplicates = True [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] use_filesystem_cache = True [EOL] [docstring] [EOL] [EOL] if platform . system ( ) . lower ( ) == [string] : [EOL] _cache_directory = os . path . join ( os . getenv ( [string] ) or [string] , [string] , [string] ) [EOL] elif platform . system ( ) . lower ( ) == [string] : [EOL] _cache_directory = os . path . join ( [string] , [string] , [string] , [string] ) [EOL] else : [EOL] _cache_directory = os . path . join ( os . getenv ( [string] ) or [string] , [string] ) [EOL] cache_directory = os . path . expanduser ( _cache_directory ) [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] fast_parser = True [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] dynamic_array_additions = True [EOL] [docstring] [EOL] [EOL] dynamic_params = True [EOL] [docstring] [EOL] [EOL] dynamic_params_for_other_modules = True [EOL] [docstring] [EOL] [EOL] additional_dynamic_modules = [ ] [EOL] [docstring] [EOL] [EOL] dynamic_flow_information = True [EOL] [docstring] [EOL] [EOL] auto_import_modules = [ [string] , ] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] max_until_execution_unique = [number] [EOL] [docstring] [EOL] [EOL] max_function_recursion_level = [number] [EOL] [docstring] [EOL] [EOL] max_executions_without_builtins = [number] [EOL] [docstring] [EOL] [EOL] max_executions = [number] [EOL] [docstring] [EOL] [EOL] scale_call_signatures = [number] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] call_signatures_validity = [number] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0
from typing import List , Any , Type [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] import __main__ [EOL] from collections import namedtuple [EOL] import logging [EOL] import traceback [EOL] import re [EOL] import os [EOL] import sys [EOL] [EOL] from jedi import Interpreter [EOL] from jedi . api . helpers import get_on_completion_name [EOL] from jedi import common [EOL] [EOL] [EOL] READLINE_DEBUG = False [EOL] [EOL] [EOL] def setup_readline ( namespace_module = __main__ ) : [EOL] [docstring] [EOL] if READLINE_DEBUG : [EOL] logging . basicConfig ( filename = [string] , filemode = [string] , level = logging . DEBUG ) [EOL] [EOL] class JediRL ( object ) : [EOL] def complete ( self , text , state ) : [EOL] [docstring] [EOL] if state == [number] : [EOL] sys . path . insert ( [number] , os . getcwd ( ) ) [EOL] [comment] [EOL] try : [EOL] logging . debug ( [string] + repr ( text ) ) [EOL] interpreter = Interpreter ( text , [ namespace_module . __dict__ ] ) [EOL] [EOL] lines = common . splitlines ( text ) [EOL] position = ( len ( lines ) , len ( lines [ - [number] ] ) ) [EOL] name = get_on_completion_name ( interpreter . _get_module_node ( ) , lines , position ) [EOL] before = text [ : len ( text ) - len ( name ) ] [EOL] completions = interpreter . completions ( ) [EOL] except : [EOL] logging . error ( [string] + traceback . format_exc ( ) ) [EOL] raise [EOL] finally : [EOL] sys . path . pop ( [number] ) [EOL] [EOL] self . matches = [ before + c . name_with_symbols for c in completions ] [EOL] try : [EOL] return self . matches [ state ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] try : [EOL] import readline [EOL] except ImportError : [EOL] print ( [string] ) [EOL] else : [EOL] readline . set_completer ( JediRL ( ) . complete ) [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . parse_and_bind ( [string] ) [EOL] [comment] [EOL] readline . set_completer_delims ( [string] ) [EOL] [EOL] [EOL] def version_info ( ) : [EOL] [docstring] [EOL] Version = namedtuple ( [string] , [string] ) [EOL] from jedi import __version__ [EOL] tupl = re . findall ( [string] , __version__ ) [EOL] return Version ( * [ x if i == [number] else int ( x ) for i , x in enumerate ( tupl ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Literal , Any , List , Tuple , Set [EOL] import typing_extensions [EOL] import typing [EOL] import textwrap [EOL] from inspect import cleandoc [EOL] [EOL] from jedi . _compatibility import literal_eval , is_py3 [EOL] from jedi . parser . python import tree [EOL] [EOL] _EXECUTE_NODES = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] _FLOW_KEYWORDS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def get_executable_nodes ( node , last_added = False ) : [EOL] [docstring] [EOL] result = [ ] [EOL] typ = node . type [EOL] if typ == [string] : [EOL] next_leaf = node . get_next_leaf ( ) [EOL] if last_added is False and node . parent . type != [string] and next_leaf != [string] : [EOL] result . append ( node ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] [comment] [EOL] result . append ( node ) [EOL] for child in node . children : [EOL] result += get_executable_nodes ( child , last_added = True ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] if node . children [ - [number] ] == [string] : [EOL] node = node . children [ - [number] ] [EOL] if node != [string] : [EOL] result += get_executable_nodes ( node ) [EOL] else : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] if node . type in _EXECUTE_NODES and not last_added : [EOL] result . append ( node ) [EOL] [EOL] for child in children : [EOL] result += get_executable_nodes ( child , last_added ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def get_comp_fors ( comp_for ) : [EOL] yield comp_for [EOL] last = comp_for . children [ - [number] ] [EOL] while True : [EOL] if last . type == [string] : [EOL] yield last [EOL] elif not last . type == [string] : [EOL] break [EOL] last = last . children [ - [number] ] [EOL] [EOL] [EOL] def for_stmt_defines_one_name ( for_stmt ) : [EOL] [docstring] [EOL] return for_stmt . children [ [number] ] . type == [string] [EOL] [EOL] [EOL] def get_flow_branch_keyword ( flow_node , node ) : [EOL] start_pos = node . start_pos [EOL] if not ( flow_node . start_pos < start_pos <= flow_node . end_pos ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] keyword = None [EOL] for i , child in enumerate ( flow_node . children ) : [EOL] if start_pos < child . start_pos : [EOL] return keyword [EOL] first_leaf = child . get_first_leaf ( ) [EOL] if first_leaf in _FLOW_KEYWORDS : [EOL] keyword = first_leaf [EOL] return [number] [EOL] [EOL] def get_statement_of_position ( node , pos ) : [EOL] for c in node . children : [EOL] if c . start_pos <= pos <= c . end_pos : [EOL] if c . type not in ( [string] , [string] , [string] ) \ [EOL] and not isinstance ( c , ( tree . Flow , tree . ClassOrFunc ) ) : [EOL] return c [EOL] else : [EOL] try : [EOL] return get_statement_of_position ( c , pos ) [EOL] except AttributeError : [EOL] pass [comment] [EOL] return None [EOL] [EOL] [EOL] def clean_scope_docstring ( scope_node ) : [EOL] [docstring] [EOL] node = scope_node . get_doc_node ( ) [EOL] if node is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cleaned = cleandoc ( safe_literal_eval ( node . value ) ) [EOL] [comment] [EOL] [comment] [EOL] if is_py3 or isinstance ( cleaned , unicode ) : [EOL] return cleaned [EOL] else : [EOL] return unicode ( cleaned , [string] , [string] ) [EOL] return [string] [EOL] [EOL] [EOL] def safe_literal_eval ( value ) : [EOL] first_two = value [ : [number] ] . lower ( ) [EOL] if first_two [ [number] ] == [string] or first_two in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] [EOL] try : [EOL] return literal_eval ( value ) [EOL] except SyntaxError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] [EOL] [EOL] def get_call_signature ( funcdef , width = [number] , call_string = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if call_string is None : [EOL] if funcdef . type == [string] : [EOL] call_string = [string] [EOL] else : [EOL] call_string = funcdef . name . value [EOL] if funcdef . type == [string] : [EOL] p = [string] + [string] . join ( param . get_code ( ) for param in funcdef . params ) . strip ( ) + [string] [EOL] else : [EOL] p = funcdef . children [ [number] ] . get_code ( ) [EOL] code = call_string + p [EOL] [EOL] return [string] . join ( textwrap . wrap ( code , width ) ) [EOL] [EOL] [EOL] def get_doc_with_call_signature ( scope_node ) : [EOL] [docstring] [EOL] call_signature = None [EOL] if scope_node . type == [string] : [EOL] for funcdef in scope_node . iter_funcdefs ( ) : [EOL] if funcdef . name . value == [string] : [EOL] call_signature = get_call_signature ( funcdef , call_string = scope_node . name . value ) [EOL] elif scope_node . type in ( [string] , [string] ) : [EOL] call_signature = get_call_signature ( scope_node ) [EOL] [EOL] doc = clean_scope_docstring ( scope_node ) [EOL] if call_signature is None : [EOL] return doc [EOL] return [string] % ( call_signature , doc ) [EOL] [EOL] [EOL] def move ( node , line_offset ) : [EOL] [docstring] [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] node . line += line_offset [EOL] else : [EOL] for c in children : [EOL] move ( c , line_offset ) [EOL] [EOL] [EOL] def get_following_comment_same_line ( node ) : [EOL] [docstring] [EOL] try : [EOL] if node . type == [string] : [EOL] whitespace = node . children [ [number] ] . get_first_leaf ( ) . prefix [EOL] elif node . type == [string] : [EOL] whitespace = node . children [ [number] ] . get_first_leaf ( ) . prefix [EOL] else : [EOL] whitespace = node . get_last_leaf ( ) . get_next_leaf ( ) . prefix [EOL] except AttributeError : [EOL] return None [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] if [string] not in whitespace : [EOL] return None [EOL] comment = whitespace [ whitespace . index ( [string] ) : ] [EOL] if [string] in comment : [EOL] comment = comment [ : comment . index ( [string] ) ] [EOL] if [string] in comment : [EOL] comment = comment [ : comment . index ( [string] ) ] [EOL] return comment [EOL] [EOL] [EOL] def is_scope ( node ) : [EOL] return node . type in ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def get_parent_scope ( node , include_flows = False ) : [EOL] [docstring] [EOL] scope = node . parent [EOL] while scope is not None : [EOL] if include_flows and isinstance ( scope , tree . Flow ) : [EOL] return scope [EOL] if is_scope ( scope ) : [EOL] break [EOL] scope = scope . parent [EOL] return scope [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __version__ = [string] [EOL] [EOL] from jedi . api import Script , Interpreter , NotFoundError , set_debug_function [EOL] from jedi . api import preload_module , defined_names , names [EOL] from jedi import settings [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Union , Type , Match , List , Tuple [EOL] import typing [EOL] import types [EOL] [docstring] [EOL] import sys [EOL] import contextlib [EOL] import functools [EOL] import re [EOL] from ast import literal_eval [EOL] [EOL] from jedi . _compatibility import unicode , reraise [EOL] from jedi import settings [EOL] [EOL] [EOL] class UncaughtAttributeError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def safe_property ( func ) : [EOL] return property ( reraise_uncaught ( func ) ) [EOL] [EOL] [EOL] def reraise_uncaught ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwds ) : [EOL] try : [EOL] return func ( * args , ** kwds ) [EOL] except AttributeError : [EOL] exc_info = sys . exc_info ( ) [EOL] reraise ( UncaughtAttributeError ( exc_info [ [number] ] ) , exc_info [ [number] ] ) [EOL] return wrapper [EOL] [EOL] [EOL] class PushBackIterator ( object ) : [EOL] def __init__ ( self , iterator ) : [EOL] self . pushes = [ ] [EOL] self . iterator = iterator [EOL] self . current = None [EOL] [EOL] def push_back ( self , value ) : [EOL] self . pushes . append ( value ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def next ( self ) : [EOL] [docstring] [EOL] return self . __next__ ( ) [EOL] [EOL] def __next__ ( self ) : [EOL] if self . pushes : [EOL] self . current = self . pushes . pop ( ) [EOL] else : [EOL] self . current = next ( self . iterator ) [EOL] return self . current [EOL] [EOL] [EOL] @ contextlib . contextmanager def scale_speed_settings ( factor ) : [EOL] a = settings . max_executions [EOL] b = settings . max_until_execution_unique [EOL] settings . max_executions *= factor [EOL] settings . max_until_execution_unique *= factor [EOL] try : [EOL] yield [EOL] finally : [EOL] settings . max_executions = a [EOL] settings . max_until_execution_unique = b [EOL] [EOL] [EOL] def indent_block ( text , indention = [string] ) : [EOL] [docstring] [EOL] temp = [string] [EOL] while text and text [ - [number] ] == [string] : [EOL] temp += text [ - [number] ] [EOL] text = text [ : - [number] ] [EOL] lines = text . split ( [string] ) [EOL] return [string] . join ( map ( lambda s : indention + s , lines ) ) + temp [EOL] [EOL] [EOL] @ contextlib . contextmanager def ignored ( * exceptions ) : [EOL] [docstring] [EOL] try : [EOL] yield [EOL] except exceptions : [EOL] pass [EOL] [EOL] [EOL] def source_to_unicode ( source , encoding = None ) : [EOL] def detect_encoding ( ) : [EOL] [docstring] [EOL] byte_mark = literal_eval ( [string] ) [EOL] if source . startswith ( byte_mark ) : [EOL] [comment] [EOL] return [string] [EOL] [EOL] first_two_lines = re . match ( [string] , source ) . group ( [number] ) [EOL] possible_encoding = re . search ( [string] , first_two_lines ) [EOL] if possible_encoding : [EOL] return possible_encoding . group ( [number] ) [EOL] else : [EOL] [comment] [EOL] return encoding if encoding is not None else [string] [EOL] [EOL] if isinstance ( source , unicode ) : [EOL] [comment] [EOL] return source [EOL] [EOL] encoding = detect_encoding ( ) [EOL] if not isinstance ( encoding , unicode ) : [EOL] encoding = unicode ( encoding , [string] , [string] ) [EOL] [comment] [EOL] return unicode ( source , encoding , [string] ) [EOL] [EOL] [EOL] def splitlines ( string , keepends = False ) : [EOL] [docstring] [EOL] if keepends : [EOL] lst = string . splitlines ( True ) [EOL] [EOL] [comment] [EOL] merge = [ ] [EOL] for i , line in enumerate ( lst ) : [EOL] if line . endswith ( [string] ) : [EOL] merge . append ( i ) [EOL] [EOL] for index in reversed ( merge ) : [EOL] try : [EOL] lst [ index ] = lst [ index ] + lst [ index + [number] ] [EOL] del lst [ index + [number] ] [EOL] except IndexError : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if string . endswith ( [string] ) or string == [string] : [EOL] lst . append ( [string] ) [EOL] return lst [EOL] else : [EOL] return re . split ( [string] , string ) [EOL] [EOL] [EOL] def unite ( iterable ) : [EOL] [docstring] [EOL] return set ( typ for types in iterable for typ in types ) [EOL] [EOL] [EOL] def to_list ( func ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] return list ( func ( * args , ** kwargs ) ) [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Optional , Any , Callable [EOL] import _importlib_modulespec [EOL] import typing [EOL] import inspect [EOL] from jedi . _compatibility import encoding , is_py3 , u [EOL] import inspect [EOL] import os [EOL] import time [EOL] [EOL] def _lazy_colorama_init ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] _inited = False [EOL] [EOL] try : [EOL] if os . name == [string] : [EOL] [comment] [EOL] raise ImportError [EOL] else : [EOL] [comment] [EOL] from colorama import Fore , init [EOL] from colorama import initialise [EOL] def _lazy_colorama_init ( ) : [EOL] [docstring] [EOL] global _inited [EOL] if not _inited : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] initialise . atexit_done = True [EOL] try : [EOL] init ( ) [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] _inited = True [EOL] [EOL] except ImportError : [EOL] class Fore ( object ) : [EOL] RED = [string] [EOL] GREEN = [string] [EOL] YELLOW = [string] [EOL] MAGENTA = [string] [EOL] RESET = [string] [EOL] [EOL] NOTICE = object ( ) [EOL] WARNING = object ( ) [EOL] SPEED = object ( ) [EOL] [EOL] enable_speed = False [EOL] enable_warning = False [EOL] enable_notice = False [EOL] [EOL] [comment] [EOL] debug_function = None [EOL] ignored_modules = [ [string] ] [EOL] _debug_indent = [number] [EOL] _start_time = time . time ( ) [EOL] [EOL] [EOL] def reset_time ( ) : [EOL] global _start_time , _debug_indent [EOL] _start_time = time . time ( ) [EOL] _debug_indent = [number] [EOL] [EOL] [EOL] def increase_indent ( func ) : [EOL] [docstring] [EOL] def wrapper ( * args , ** kwargs ) : [EOL] global _debug_indent [EOL] _debug_indent += [number] [EOL] try : [EOL] return func ( * args , ** kwargs ) [EOL] finally : [EOL] _debug_indent -= [number] [EOL] return wrapper [EOL] [EOL] [EOL] def dbg ( message , * args , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] color = kwargs . pop ( [string] , [string] ) [EOL] assert color [EOL] [EOL] if debug_function and enable_notice : [EOL] frm = inspect . stack ( ) [ [number] ] [EOL] mod = inspect . getmodule ( frm [ [number] ] ) [EOL] if not ( mod . __name__ in ignored_modules ) : [EOL] i = [string] * _debug_indent [EOL] _lazy_colorama_init ( ) [EOL] debug_function ( color , i + [string] + message % tuple ( u ( repr ( a ) ) for a in args ) ) [EOL] [EOL] [EOL] def warning ( message , * args , ** kwargs ) : [EOL] format = kwargs . pop ( [string] , True ) [EOL] assert not kwargs [EOL] [EOL] if debug_function and enable_warning : [EOL] i = [string] * _debug_indent [EOL] if format : [EOL] message = message % tuple ( u ( repr ( a ) ) for a in args ) [EOL] debug_function ( [string] , i + [string] + message ) [EOL] [EOL] [EOL] def speed ( name ) : [EOL] if debug_function and enable_speed : [EOL] now = time . time ( ) [EOL] i = [string] * _debug_indent [EOL] debug_function ( [string] , i + [string] + [string] % ( name , now - _start_time ) ) [EOL] [EOL] [EOL] def print_to_stdout ( color , str_out ) : [EOL] [docstring] [EOL] col = getattr ( Fore , color ) [EOL] _lazy_colorama_init ( ) [EOL] if not is_py3 : [EOL] str_out = str_out . encode ( encoding , [string] ) [EOL] print ( col + str_out + Fore . RESET ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] import inspect [EOL] [EOL] from jedi import settings [EOL] from jedi . parser . cache import parser_cache [EOL] [EOL] _time_caches = { } [EOL] [EOL] [EOL] def underscore_memoization ( func ) : [EOL] [docstring] [EOL] name = [string] + func . __name__ [EOL] [EOL] def wrapper ( self ) : [EOL] try : [EOL] return getattr ( self , name ) [EOL] except AttributeError : [EOL] result = func ( self ) [EOL] if inspect . isgenerator ( result ) : [EOL] result = list ( result ) [EOL] setattr ( self , name , result ) [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def clear_time_caches ( delete_all = False ) : [EOL] [docstring] [EOL] global _time_caches [EOL] [EOL] if delete_all : [EOL] for cache in _time_caches . values ( ) : [EOL] cache . clear ( ) [EOL] parser_cache . clear ( ) [EOL] else : [EOL] [comment] [EOL] for tc in _time_caches . values ( ) : [EOL] [comment] [EOL] for key , ( t , value ) in list ( tc . items ( ) ) : [EOL] if t < time . time ( ) : [EOL] [comment] [EOL] del tc [ key ] [EOL] [EOL] [EOL] def time_cache ( time_add_setting ) : [EOL] [docstring] [EOL] def _temp ( key_func ) : [EOL] dct = { } [EOL] _time_caches [ time_add_setting ] = dct [EOL] [EOL] def wrapper ( * args , ** kwargs ) : [EOL] generator = key_func ( * args , ** kwargs ) [EOL] key = next ( generator ) [EOL] try : [EOL] expiry , value = dct [ key ] [EOL] if expiry > time . time ( ) : [EOL] return value [EOL] except KeyError : [EOL] pass [EOL] [EOL] value = next ( generator ) [EOL] time_add = getattr ( settings , time_add_setting ) [EOL] if key is not None : [EOL] dct [ key ] = time . time ( ) + time_add , value [EOL] return value [EOL] return wrapper [EOL] return _temp [EOL] [EOL] [EOL] def memoize_method ( method ) : [EOL] [docstring] [EOL] def wrapper ( self , * args , ** kwargs ) : [EOL] cache_dict = self . __dict__ . setdefault ( [string] , { } ) [EOL] dct = cache_dict . setdefault ( method , { } ) [EOL] key = ( args , frozenset ( kwargs . items ( ) ) ) [EOL] try : [EOL] return dct [ key ] [EOL] except KeyError : [EOL] result = method ( self , * args , ** kwargs ) [EOL] dct [ key ] = result [EOL] return result [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import difflib [EOL] [EOL] from jedi import common [EOL] from jedi . evaluate import helpers [EOL] from jedi . parser . python import tree as pt [EOL] [EOL] [EOL] class Refactoring ( object ) : [EOL] def __init__ ( self , change_dct ) : [EOL] [docstring] [EOL] self . change_dct = change_dct [EOL] [EOL] def old_files ( self ) : [EOL] dct = { } [EOL] for old_path , ( new_path , old_l , new_l ) in self . change_dct . items ( ) : [EOL] dct [ old_path ] = [string] . join ( old_l ) [EOL] return dct [EOL] [EOL] def new_files ( self ) : [EOL] dct = { } [EOL] for old_path , ( new_path , old_l , new_l ) in self . change_dct . items ( ) : [EOL] dct [ new_path ] = [string] . join ( new_l ) [EOL] return dct [EOL] [EOL] def diff ( self ) : [EOL] texts = [ ] [EOL] for old_path , ( new_path , old_l , new_l ) in self . change_dct . items ( ) : [EOL] if old_path : [EOL] udiff = difflib . unified_diff ( old_l , new_l ) [EOL] else : [EOL] udiff = difflib . unified_diff ( old_l , new_l , old_path , new_path ) [EOL] texts . append ( [string] . join ( udiff ) ) [EOL] return [string] . join ( texts ) [EOL] [EOL] [EOL] def rename ( script , new_name ) : [EOL] [docstring] [EOL] return Refactoring ( _rename ( script . usages ( ) , new_name ) ) [EOL] [EOL] [EOL] def _rename ( names , replace_str ) : [EOL] [docstring] [EOL] order = sorted ( names , key = lambda x : ( x . module_path , x . line , x . column ) , reverse = True ) [EOL] [EOL] def process ( path , old_lines , new_lines ) : [EOL] if new_lines is not None : [comment] [EOL] dct [ path ] = path , old_lines , new_lines [EOL] [EOL] dct = { } [EOL] current_path = object ( ) [EOL] new_lines = old_lines = None [EOL] for name in order : [EOL] if name . in_builtin_module ( ) : [EOL] continue [EOL] if current_path != name . module_path : [EOL] current_path = name . module_path [EOL] [EOL] process ( current_path , old_lines , new_lines ) [EOL] if current_path is not None : [EOL] [comment] [EOL] with open ( current_path ) as f : [EOL] source = f . read ( ) [EOL] [EOL] new_lines = common . splitlines ( common . source_to_unicode ( source ) ) [EOL] old_lines = new_lines [ : ] [EOL] [EOL] nr , indent = name . line , name . column [EOL] line = new_lines [ nr - [number] ] [EOL] new_lines [ nr - [number] ] = line [ : indent ] + replace_str + line [ indent + len ( name . name ) : ] [EOL] process ( current_path , old_lines , new_lines ) [EOL] return dct [EOL] [EOL] [EOL] def extract ( script , new_name ) : [EOL] [docstring] [EOL] new_lines = common . splitlines ( common . source_to_unicode ( script . source ) ) [EOL] old_lines = new_lines [ : ] [EOL] [EOL] user_stmt = script . _parser . user_stmt ( ) [EOL] [EOL] [comment] [EOL] dct = { } [EOL] if user_stmt : [EOL] pos = script . _pos [EOL] line_index = pos [ [number] ] - [number] [EOL] arr , index = helpers . array_for_pos ( user_stmt , pos ) [EOL] if arr is not None : [EOL] start_pos = arr [ index ] . start_pos [EOL] end_pos = arr [ index ] . end_pos [EOL] [EOL] [comment] [EOL] e = end_pos [ [number] ] if end_pos [ [number] ] == start_pos [ [number] ] else None [EOL] start_line = new_lines [ start_pos [ [number] ] - [number] ] [EOL] text = start_line [ start_pos [ [number] ] : e ] [EOL] for l in range ( start_pos [ [number] ] , end_pos [ [number] ] - [number] ) : [EOL] text += [string] + l [EOL] if e is None : [EOL] end_line = new_lines [ end_pos [ [number] ] - [number] ] [EOL] text += [string] + end_line [ : end_pos [ [number] ] ] [EOL] [EOL] [comment] [EOL] t = text . lstrip ( ) [EOL] del_start = start_pos [ [number] ] + len ( text ) - len ( t ) [EOL] [EOL] text = t . rstrip ( ) [EOL] del_end = len ( t ) - len ( text ) [EOL] if e is None : [EOL] new_lines [ end_pos [ [number] ] - [number] ] = end_line [ end_pos [ [number] ] - del_end : ] [EOL] e = len ( start_line ) [EOL] else : [EOL] e = e - del_end [EOL] start_line = start_line [ : del_start ] + new_name + start_line [ e : ] [EOL] new_lines [ start_pos [ [number] ] - [number] ] = start_line [EOL] new_lines [ start_pos [ [number] ] : end_pos [ [number] ] - [number] ] = [ ] [EOL] [EOL] [comment] [EOL] open_brackets = [ [string] , [string] , [string] ] [EOL] close_brackets = [ [string] , [string] , [string] ] [EOL] if [string] in text and not ( text [ [number] ] in open_brackets and text [ - [number] ] == close_brackets [ open_brackets . index ( text [ [number] ] ) ] ) : [EOL] text = [string] % text [EOL] [EOL] [comment] [EOL] indent = user_stmt . start_pos [ [number] ] [EOL] new = [string] % ( [string] * indent , new_name , text ) [EOL] new_lines . insert ( line_index , new ) [EOL] dct [ script . path ] = script . path , old_lines , new_lines [EOL] return Refactoring ( dct ) [EOL] [EOL] [EOL] def inline ( script ) : [EOL] [docstring] [EOL] new_lines = common . splitlines ( common . source_to_unicode ( script . source ) ) [EOL] [EOL] dct = { } [EOL] [EOL] definitions = script . goto_assignments ( ) [EOL] with common . ignored ( AssertionError ) : [EOL] assert len ( definitions ) == [number] [EOL] stmt = definitions [ [number] ] . _definition [EOL] usages = script . usages ( ) [EOL] inlines = [ r for r in usages if not stmt . start_pos <= ( r . line , r . column ) <= stmt . end_pos ] [EOL] inlines = sorted ( inlines , key = lambda x : ( x . module_path , x . line , x . column ) , reverse = True ) [EOL] expression_list = stmt . expression_list ( ) [EOL] [comment] [EOL] assert stmt . start_pos [ [number] ] == stmt . end_pos [ [number] ] [EOL] index = stmt . start_pos [ [number] ] - [number] [EOL] [EOL] line = new_lines [ index ] [EOL] replace_str = line [ expression_list [ [number] ] . start_pos [ [number] ] : stmt . end_pos [ [number] ] + [number] ] [EOL] replace_str = replace_str . strip ( ) [EOL] [comment] [EOL] if expression_list and isinstance ( expression_list [ [number] ] , pr . Array ) : [EOL] arr = expression_list [ [number] ] [EOL] if replace_str [ [number] ] not in [ [string] , [string] , [string] ] and len ( arr ) > [number] : [EOL] replace_str = [string] % replace_str [EOL] [EOL] [comment] [EOL] if len ( stmt . get_defined_names ( ) ) == [number] : [EOL] line = line [ : stmt . start_pos [ [number] ] ] + line [ stmt . end_pos [ [number] ] : ] [EOL] [EOL] dct = _rename ( inlines , replace_str ) [EOL] [comment] [EOL] new_lines = dct [ script . path ] [ [number] ] [EOL] if line . strip ( ) : [EOL] new_lines [ index ] = line [EOL] else : [EOL] new_lines . pop ( index ) [EOL] [EOL] return Refactoring ( dct ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import sys [EOL] from os . path import join , dirname , abspath , isdir [EOL] [EOL] [EOL] def _start_linter ( ) : [EOL] [docstring] [EOL] import jedi [EOL] [EOL] if [string] in sys . argv : [EOL] jedi . set_debug_function ( ) [EOL] [EOL] for path in sys . argv [ [number] : ] : [EOL] if path . startswith ( [string] ) : [EOL] continue [EOL] if isdir ( path ) : [EOL] import fnmatch [EOL] import os [EOL] [EOL] paths = [ ] [EOL] for root , dirnames , filenames in os . walk ( path ) : [EOL] for filename in fnmatch . filter ( filenames , [string] ) : [EOL] paths . append ( os . path . join ( root , filename ) ) [EOL] else : [EOL] paths = [ path ] [EOL] [EOL] try : [EOL] for path in paths : [EOL] for error in jedi . Script ( path = path ) . _analysis ( ) : [EOL] print ( error ) [EOL] except Exception : [EOL] if [string] in sys . argv : [EOL] import traceback [EOL] traceback . print_exc ( ) [EOL] import pdb [EOL] pdb . post_mortem ( ) [EOL] else : [EOL] raise [EOL] [EOL] [EOL] if len ( sys . argv ) == [number] and sys . argv [ [number] ] == [string] : [EOL] [comment] [EOL] [comment] [EOL] print ( join ( dirname ( abspath ( __file__ ) ) , [string] , [string] ) ) [EOL] elif len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] _start_linter ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import inspect [EOL] [EOL] NO_DEFAULT = object ( ) [EOL] [EOL] [EOL] def memoize_default ( default = NO_DEFAULT , evaluator_is_first_arg = False , second_arg_is_evaluator = False ) : [EOL] [docstring] [EOL] def func ( function ) : [EOL] def wrapper ( obj , * args , ** kwargs ) : [EOL] if evaluator_is_first_arg : [EOL] cache = obj . memoize_cache [EOL] elif second_arg_is_evaluator : [comment] [EOL] cache = args [ [number] ] . memoize_cache [EOL] else : [EOL] cache = obj . evaluator . memoize_cache [EOL] [EOL] try : [EOL] memo = cache [ function ] [EOL] except KeyError : [EOL] memo = { } [EOL] cache [ function ] = memo [EOL] [EOL] key = ( obj , args , frozenset ( kwargs . items ( ) ) ) [EOL] if key in memo : [EOL] return memo [ key ] [EOL] else : [EOL] if default is not NO_DEFAULT : [EOL] memo [ key ] = default [EOL] rv = function ( obj , * args , ** kwargs ) [EOL] if inspect . isgenerator ( rv ) : [EOL] rv = list ( rv ) [EOL] memo [ key ] = rv [EOL] return rv [EOL] return wrapper [EOL] return func [EOL] [EOL] [EOL] class CachedMetaClass ( type ) : [EOL] [docstring] [EOL] @ memoize_default ( None , second_arg_is_evaluator = True ) def __call__ ( self , * args , ** kwargs ) : [EOL] return super ( CachedMetaClass , self ) . __call__ ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match , List , Pattern , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] from ast import literal_eval [EOL] import re [EOL] from textwrap import dedent [EOL] [EOL] from jedi . _compatibility import u [EOL] from jedi . common import unite [EOL] from jedi . evaluate import context [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . parser . python import parse [EOL] from jedi . common import indent_block [EOL] from jedi . evaluate . iterable import SequenceLiteralContext , FakeSequence [EOL] [EOL] [EOL] DOCSTRING_PARAM_PATTERNS = [ [string] , [string] , [string] , ] [EOL] [EOL] DOCSTRING_RETURN_PATTERNS = [ re . compile ( [string] , re . M ) , re . compile ( [string] , re . M ) , ] [EOL] [EOL] REST_ROLE_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] try : [EOL] from numpydoc . docscrape import NumpyDocString [EOL] except ImportError : [EOL] def _search_param_in_numpydocstr ( docstr , param_str ) : [EOL] return [ ] [EOL] else : [EOL] def _search_param_in_numpydocstr ( docstr , param_str ) : [EOL] [docstring] [EOL] params = NumpyDocString ( docstr ) . _parsed_data [ [string] ] [EOL] for p_name , p_type , p_descr in params : [EOL] if p_name == param_str : [EOL] m = re . match ( [string] , p_type ) [EOL] if m : [EOL] p_type = m . group ( [number] ) [EOL] [EOL] if p_type . startswith ( [string] ) : [EOL] types = set ( type ( x ) . __name__ for x in literal_eval ( p_type ) ) [EOL] return list ( types ) [EOL] else : [EOL] return [ p_type ] [EOL] return [ ] [EOL] [EOL] [EOL] def _search_param_in_docstr ( docstr , param_str ) : [EOL] [docstring] [EOL] [comment] [EOL] patterns = [ re . compile ( p % re . escape ( param_str ) ) for p in DOCSTRING_PARAM_PATTERNS ] [EOL] for pattern in patterns : [EOL] match = pattern . search ( docstr ) [EOL] if match : [EOL] return [ _strip_rst_role ( match . group ( [number] ) ) ] [EOL] [EOL] return ( _search_param_in_numpydocstr ( docstr , param_str ) or [ ] ) [EOL] [EOL] [EOL] def _strip_rst_role ( type_str ) : [EOL] [docstring] [EOL] match = REST_ROLE_PATTERN . match ( type_str ) [EOL] if match : [EOL] return match . group ( [number] ) [EOL] else : [EOL] return type_str [EOL] [EOL] [EOL] def _evaluate_for_statement_string ( module_context , string ) : [EOL] code = dedent ( u ( [string] ) ) [EOL] if string is None : [EOL] return [ ] [EOL] [EOL] for element in re . findall ( [string] , string ) : [EOL] [comment] [EOL] [comment] [EOL] string = [string] % element + string [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] module = parse ( code . format ( indent_block ( string ) ) ) [EOL] try : [EOL] funcdef = next ( module . iter_funcdefs ( ) ) [EOL] [comment] [EOL] [comment] [EOL] stmt = funcdef . children [ - [number] ] . children [ - [number] ] . children [ - [number] ] [EOL] except ( AttributeError , IndexError ) : [EOL] return [ ] [EOL] [EOL] from jedi . evaluate . param import ValuesArguments [EOL] from jedi . evaluate . representation import FunctionContext [EOL] function_context = FunctionContext ( module_context . evaluator , module_context , funcdef ) [EOL] func_execution_context = function_context . get_function_execution ( ValuesArguments ( [ ] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return list ( _execute_types_in_stmt ( func_execution_context , stmt ) ) [EOL] [EOL] [EOL] def _execute_types_in_stmt ( module_context , stmt ) : [EOL] [docstring] [EOL] definitions = module_context . eval_node ( stmt ) [EOL] return unite ( _execute_array_values ( module_context . evaluator , d ) for d in definitions ) [EOL] [EOL] [EOL] def _execute_array_values ( evaluator , array ) : [EOL] [docstring] [EOL] if isinstance ( array , SequenceLiteralContext ) : [EOL] values = [ ] [EOL] for lazy_context in array . py__iter__ ( ) : [EOL] objects = unite ( _execute_array_values ( evaluator , typ ) for typ in lazy_context . infer ( ) ) [EOL] values . append ( context . LazyKnownContexts ( objects ) ) [EOL] return set ( [ FakeSequence ( evaluator , array . array_type , values ) ] ) [EOL] else : [EOL] return array . execute_evaluated ( ) [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_param ( execution_context , param ) : [EOL] from jedi . evaluate . instance import InstanceFunctionExecution [EOL] [EOL] def eval_docstring ( docstring ) : [EOL] return set ( p for param_str in _search_param_in_docstr ( docstring , param . name . value ) for p in _evaluate_for_statement_string ( module_context , param_str ) ) [EOL] module_context = execution_context . get_root_context ( ) [EOL] func = param . get_parent_function ( ) [EOL] if func . type == [string] : [EOL] return set ( ) [EOL] [EOL] types = eval_docstring ( execution_context . py__doc__ ( ) ) [EOL] if isinstance ( execution_context , InstanceFunctionExecution ) and execution_context . function_context . name . string_name == [string] : [EOL] class_context = execution_context . instance . class_context [EOL] types |= eval_docstring ( class_context . py__doc__ ( ) ) [EOL] [EOL] return types [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_return_types ( function_context ) : [EOL] def search_return_in_docstr ( code ) : [EOL] for p in DOCSTRING_RETURN_PATTERNS : [EOL] match = p . search ( code ) [EOL] if match : [EOL] return _strip_rst_role ( match . group ( [number] ) ) [EOL] [EOL] type_str = search_return_in_docstr ( function_context . py__doc__ ( ) ) [EOL] return _evaluate_for_statement_string ( function_context . get_root_context ( ) , type_str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Union , Type , List , Tuple , Iterator , Dict [EOL] import typing [EOL] [docstring] [EOL] from jedi import debug [EOL] from jedi . parser . python import tree [EOL] from jedi . evaluate . compiled import CompiledObject [EOL] [EOL] [EOL] CODES = { [string] : ( [number] , AttributeError , [string] ) , [string] : ( [number] , NameError , [string] ) , [string] : ( [number] , ImportError , [string] ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , TypeError , None ) , [string] : ( [number] , ValueError , None ) , [string] : ( [number] , ValueError , None ) , } [EOL] [EOL] [EOL] class Error ( object ) : [EOL] def __init__ ( self , name , module_path , start_pos , message = None ) : [EOL] self . path = module_path [EOL] self . _start_pos = start_pos [EOL] self . name = name [EOL] if message is None : [EOL] message = CODES [ self . name ] [ [number] ] [EOL] self . message = message [EOL] [EOL] @ property def line ( self ) : [EOL] return self . _start_pos [ [number] ] [EOL] [EOL] @ property def column ( self ) : [EOL] return self . _start_pos [ [number] ] [EOL] [EOL] @ property def code ( self ) : [EOL] [comment] [EOL] first = self . __class__ . __name__ [ [number] ] [EOL] return first + str ( CODES [ self . name ] [ [number] ] ) [EOL] [EOL] def __unicode__ ( self ) : [EOL] return [string] % ( self . path , self . line , self . column , self . code , self . message ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . __unicode__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . path == other . path and self . name == other . name and self . _start_pos == other . _start_pos ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . path , self . _start_pos , self . name ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . name , self . path , self . _start_pos [ [number] ] , self . _start_pos [ [number] ] ) [EOL] [EOL] [EOL] class Warning ( Error ) : [EOL] pass [EOL] [EOL] [EOL] def add ( node_context , error_name , node , message = None , typ = Error , payload = None ) : [EOL] exception = CODES [ error_name ] [ [number] ] [EOL] if _check_for_exception_catch ( node_context , node , exception , payload ) : [EOL] return [EOL] [EOL] [comment] [EOL] module_context = node_context . get_root_context ( ) [EOL] module_path = module_context . py__file__ ( ) [EOL] instance = typ ( error_name , module_path , node . start_pos , message ) [EOL] debug . warning ( str ( instance ) , format = False ) [EOL] node_context . evaluator . analysis . append ( instance ) [EOL] [EOL] [EOL] def _check_for_setattr ( instance ) : [EOL] [docstring] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] module = instance . get_root_context ( ) [EOL] if not isinstance ( module , ModuleContext ) : [EOL] return False [EOL] [EOL] node = module . tree_node [EOL] try : [EOL] stmts = node . get_used_names ( ) [ [string] ] [EOL] except KeyError : [EOL] return False [EOL] [EOL] return any ( node . start_pos < stmt . start_pos < node . end_pos for stmt in stmts ) [EOL] [EOL] [EOL] def add_attribute_error ( name_context , lookup_context , name ) : [EOL] message = ( [string] % ( lookup_context , name ) ) [EOL] from jedi . evaluate . instance import AbstractInstanceContext , CompiledInstanceName [EOL] [comment] [EOL] [comment] [EOL] typ = Error [EOL] if isinstance ( lookup_context , AbstractInstanceContext ) : [EOL] slot_names = lookup_context . get_function_slot_names ( [string] ) + lookup_context . get_function_slot_names ( [string] ) [EOL] for n in slot_names : [EOL] if isinstance ( name , CompiledInstanceName ) and n . parent_context . obj == object : [EOL] typ = Warning [EOL] break [EOL] [EOL] if _check_for_setattr ( lookup_context ) : [EOL] typ = Warning [EOL] [EOL] payload = lookup_context , name [EOL] add ( name_context , [string] , name , message , typ , payload ) [EOL] [EOL] [EOL] def _check_for_exception_catch ( node_context , jedi_name , exception , payload = None ) : [EOL] [docstring] [EOL] def check_match ( cls , exception ) : [EOL] try : [EOL] return isinstance ( cls , CompiledObject ) and issubclass ( exception , cls . obj ) [EOL] except TypeError : [EOL] return False [EOL] [EOL] def check_try_for_except ( obj , exception ) : [EOL] [comment] [EOL] iterator = iter ( obj . children ) [EOL] for branch_type in iterator : [EOL] colon = next ( iterator ) [EOL] suite = next ( iterator ) [EOL] if branch_type == [string] \ [EOL] and not ( branch_type . start_pos < jedi_name . start_pos <= suite . end_pos ) : [EOL] return False [EOL] [EOL] for node in obj . get_except_clause_tests ( ) : [EOL] if node is None : [EOL] return True [comment] [EOL] else : [EOL] except_classes = node_context . eval_node ( node ) [EOL] for cls in except_classes : [EOL] from jedi . evaluate import iterable [EOL] if isinstance ( cls , iterable . AbstractSequence ) and cls . array_type == [string] : [EOL] [comment] [EOL] for lazy_context in cls . py__iter__ ( ) : [EOL] for typ in lazy_context . infer ( ) : [EOL] if check_match ( typ , exception ) : [EOL] return True [EOL] else : [EOL] if check_match ( cls , exception ) : [EOL] return True [EOL] [EOL] def check_hasattr ( node , suite ) : [EOL] try : [EOL] assert suite . start_pos <= jedi_name . start_pos < suite . end_pos [EOL] assert node . type in ( [string] , [string] ) [EOL] base = node . children [ [number] ] [EOL] assert base . type == [string] and base . value == [string] [EOL] trailer = node . children [ [number] ] [EOL] assert trailer . type == [string] [EOL] arglist = trailer . children [ [number] ] [EOL] assert arglist . type == [string] [EOL] from jedi . evaluate . param import TreeArguments [EOL] args = list ( TreeArguments ( node_context . evaluator , node_context , arglist ) . unpack ( ) ) [EOL] [comment] [EOL] assert len ( args ) == [number] [EOL] [EOL] [comment] [EOL] key , lazy_context = args [ [number] ] [EOL] names = list ( lazy_context . infer ( ) ) [EOL] assert len ( names ) == [number] and isinstance ( names [ [number] ] , CompiledObject ) [EOL] assert names [ [number] ] . obj == payload [ [number] ] . value [EOL] [EOL] [comment] [EOL] key , lazy_context = args [ [number] ] [EOL] objects = lazy_context . infer ( ) [EOL] return payload [ [number] ] in objects [EOL] except AssertionError : [EOL] return False [EOL] [EOL] obj = jedi_name [EOL] while obj is not None and not isinstance ( obj , ( tree . Function , tree . Class ) ) : [EOL] if isinstance ( obj , tree . Flow ) : [EOL] [comment] [EOL] if obj . type == [string] and check_try_for_except ( obj , exception ) : [EOL] return True [EOL] [comment] [EOL] if exception == AttributeError and obj . type in ( [string] , [string] ) : [EOL] if check_hasattr ( obj . children [ [number] ] , obj . children [ [number] ] ) : [EOL] return True [EOL] obj = obj . parent [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,typing.Type[typing.Union[builtins.AttributeError,builtins.ImportError,builtins.NameError,builtins.TypeError,builtins.ValueError]],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match , List , Set , Dict [EOL] import typing [EOL] [docstring] [EOL] import collections [EOL] import re [EOL] [EOL] from jedi . common import unite [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate . instance import InstanceFunctionExecution , AbstractInstanceContext , CompiledInstance , BoundMethod [EOL] from jedi . evaluate import iterable [EOL] from jedi . parser . python import parse [EOL] from jedi import debug [EOL] from jedi . evaluate import precedence [EOL] from jedi . evaluate import param [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate . context import LazyTreeContext , ContextualizedNode [EOL] [EOL] [EOL] class NotInStdLib ( LookupError ) : [EOL] pass [EOL] [EOL] [EOL] def execute ( evaluator , obj , arguments ) : [EOL] if isinstance ( obj , BoundMethod ) : [EOL] raise NotInStdLib ( ) [EOL] [EOL] try : [EOL] obj_name = obj . name . string_name [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] if obj . parent_context == evaluator . BUILTINS : [EOL] module_name = [string] [EOL] elif isinstance ( obj . parent_context , er . ModuleContext ) : [EOL] module_name = obj . parent_context . name . string_name [EOL] else : [EOL] module_name = [string] [EOL] [EOL] [comment] [EOL] try : [EOL] func = _implemented [ module_name ] [ obj_name ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] return func ( evaluator , obj , arguments ) [EOL] raise NotInStdLib ( ) [EOL] [EOL] [EOL] def _follow_param ( evaluator , arguments , index ) : [EOL] try : [EOL] key , lazy_context = list ( arguments . unpack ( ) ) [ index ] [EOL] except IndexError : [EOL] return set ( ) [EOL] else : [EOL] return lazy_context . infer ( ) [EOL] [EOL] [EOL] def argument_clinic ( string , want_obj = False , want_context = False , want_arguments = False ) : [EOL] [docstring] [EOL] clinic_args = [ ] [EOL] allow_kwargs = False [EOL] optional = False [EOL] while string : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] match = re . match ( [string] , string ) [EOL] string = string [ len ( match . group ( [number] ) ) : ] [EOL] if not match . group ( [number] ) : [comment] [EOL] allow_kwargs = True [EOL] continue [EOL] optional = optional or bool ( match . group ( [number] ) ) [EOL] word = match . group ( [number] ) [EOL] clinic_args . append ( ( word , optional , allow_kwargs ) ) [EOL] [EOL] def f ( func ) : [EOL] def wrapper ( evaluator , obj , arguments ) : [EOL] debug . dbg ( [string] % obj , color = [string] ) [EOL] try : [EOL] lst = list ( arguments . eval_argument_clinic ( clinic_args ) ) [EOL] except ValueError : [EOL] return set ( ) [EOL] else : [EOL] kwargs = { } [EOL] if want_context : [EOL] kwargs [ [string] ] = arguments . context [EOL] if want_obj : [EOL] kwargs [ [string] ] = obj [EOL] if want_arguments : [EOL] kwargs [ [string] ] = arguments [EOL] return func ( evaluator , * lst , ** kwargs ) [EOL] finally : [EOL] debug . dbg ( [string] , color = [string] ) [EOL] [EOL] return wrapper [EOL] return f [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def builtins_next ( evaluator , iterators , defaults ) : [EOL] [docstring] [EOL] if evaluator . python_version [ [number] ] == [number] : [EOL] name = [string] [EOL] else : [EOL] name = [string] [EOL] [EOL] types = set ( ) [EOL] for iterator in iterators : [EOL] if isinstance ( iterator , AbstractInstanceContext ) : [EOL] for filter in iterator . get_filters ( include_self_names = True ) : [EOL] for n in filter . get ( name ) : [EOL] for context in n . infer ( ) : [EOL] types |= context . execute_evaluated ( ) [EOL] if types : [EOL] return types [EOL] return defaults [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def builtins_getattr ( evaluator , objects , names , defaults = None ) : [EOL] [comment] [EOL] for obj in objects : [EOL] for name in names : [EOL] if precedence . is_string ( name ) : [EOL] return obj . py__getattribute__ ( name . obj ) [EOL] else : [EOL] debug . warning ( [string] ) [EOL] continue [EOL] return set ( ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def builtins_type ( evaluator , objects , bases , dicts ) : [EOL] if bases or dicts : [EOL] [comment] [EOL] return set ( ) [EOL] else : [EOL] return set ( [ o . py__class__ ( ) for o in objects ] ) [EOL] [EOL] [EOL] class SuperInstance ( AbstractInstanceContext ) : [EOL] [docstring] [EOL] def __init__ ( self , evaluator , cls ) : [EOL] su = cls . py_mro ( ) [ [number] ] [EOL] super ( ) . __init__ ( evaluator , su and su [ [number] ] or self ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] , want_context = True ) def builtins_super ( evaluator , types , objects , context ) : [EOL] [comment] [EOL] if isinstance ( context , InstanceFunctionExecution ) : [EOL] su = context . instance . py__class__ ( ) . py__bases__ ( ) [EOL] return unite ( context . execute_evaluated ( ) for context in su [ [number] ] . infer ( ) ) [EOL] return set ( ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] , want_obj = True , want_arguments = True ) def builtins_reversed ( evaluator , sequences , obj , arguments ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] key , lazy_context = next ( arguments . unpack ( ) ) [EOL] cn = None [EOL] if isinstance ( lazy_context , LazyTreeContext ) : [EOL] [comment] [EOL] cn = ContextualizedNode ( lazy_context . _context , lazy_context . data ) [EOL] ordered = list ( iterable . py__iter__ ( evaluator , sequences , cn ) ) [EOL] [EOL] rev = list ( reversed ( ordered ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] seq = iterable . FakeSequence ( evaluator , [string] , rev ) [EOL] arguments = param . ValuesArguments ( [ [ seq ] ] ) [EOL] return set ( [ CompiledInstance ( evaluator , evaluator . BUILTINS , obj , arguments ) ] ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] , want_arguments = True ) def builtins_isinstance ( evaluator , objects , types , arguments ) : [EOL] bool_results = set ( [ ] ) [EOL] for o in objects : [EOL] try : [EOL] mro_func = o . py__class__ ( ) . py__mro__ [EOL] except AttributeError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return set ( [ compiled . create ( True ) , compiled . create ( False ) ] ) [EOL] [EOL] mro = mro_func ( ) [EOL] [EOL] for cls_or_tup in types : [EOL] if cls_or_tup . is_class ( ) : [EOL] bool_results . add ( cls_or_tup in mro ) [EOL] elif cls_or_tup . name . string_name == [string] \ [EOL] and cls_or_tup . get_root_context ( ) == evaluator . BUILTINS : [EOL] [comment] [EOL] classes = unite ( lazy_context . infer ( ) for lazy_context in cls_or_tup . py__iter__ ( ) ) [EOL] bool_results . add ( any ( cls in mro for cls in classes ) ) [EOL] else : [EOL] _ , lazy_context = list ( arguments . unpack ( ) ) [ [number] ] [EOL] if isinstance ( lazy_context , LazyTreeContext ) : [EOL] node = lazy_context . data [EOL] message = [string] [string] [string] % cls_or_tup [EOL] analysis . add ( lazy_context . _context , [string] , node , message ) [EOL] [EOL] return set ( compiled . create ( evaluator , x ) for x in bool_results ) [EOL] [EOL] [EOL] def collections_namedtuple ( evaluator , obj , arguments ) : [EOL] [docstring] [EOL] [comment] [EOL] if not hasattr ( collections , [string] ) : [EOL] return set ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] name = list ( _follow_param ( evaluator , arguments , [number] ) ) [ [number] ] . obj [EOL] _fields = list ( _follow_param ( evaluator , arguments , [number] ) ) [ [number] ] [EOL] if isinstance ( _fields , compiled . CompiledObject ) : [EOL] fields = _fields . obj . replace ( [string] , [string] ) . split ( ) [EOL] elif isinstance ( _fields , iterable . AbstractSequence ) : [EOL] fields = [ v . obj for lazy_context in _fields . py__iter__ ( ) for v in lazy_context . infer ( ) if hasattr ( v , [string] ) ] [EOL] else : [EOL] return set ( ) [EOL] [EOL] [comment] [EOL] source = collections . _class_template . format ( typename = name , field_names = fields , num_fields = len ( fields ) , arg_list = [string] . join ( fields ) , repr_fmt = [string] . join ( collections . _repr_template . format ( name = name ) for name in fields ) , field_defs = [string] . join ( collections . _field_template . format ( index = index , name = name ) for index , name in enumerate ( fields ) ) ) [EOL] [EOL] [comment] [EOL] generated_class = next ( parse ( source , grammar = evaluator . grammar ) . iter_classdefs ( ) ) [EOL] return set ( [ er . ClassContext ( evaluator , generated_class , evaluator . BUILTINS ) ] ) [EOL] [EOL] [EOL] @ argument_clinic ( [string] ) def _return_first_param ( evaluator , firsts ) : [EOL] return firsts [EOL] [EOL] [EOL] _implemented = { [string] : { [string] : builtins_getattr , [string] : builtins_type , [string] : builtins_super , [string] : builtins_reversed , [string] : builtins_isinstance , } , [string] : { [string] : _return_first_param , [string] : _return_first_param , } , [string] : { [string] : lambda * args : set ( ) , [string] : lambda * args : set ( ) , } , [string] : { [string] : collections_namedtuple , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from contextlib import contextmanager [EOL] [EOL] from jedi import debug [EOL] from jedi import settings [EOL] [EOL] [EOL] class RecursionDetector ( object ) : [EOL] def __init__ ( self ) : [EOL] self . pushed_nodes = [ ] [EOL] [EOL] [EOL] @ contextmanager def execution_allowed ( evaluator , node ) : [EOL] [docstring] [EOL] pushed_nodes = evaluator . recursion_detector . pushed_nodes [EOL] [EOL] if node in pushed_nodes : [EOL] debug . warning ( [string] , node , node . start_pos ) [EOL] yield False [EOL] else : [EOL] pushed_nodes . append ( node ) [EOL] yield True [EOL] pushed_nodes . pop ( ) [EOL] [EOL] [EOL] def execution_recursion_decorator ( default = set ( ) ) : [EOL] def decorator ( func ) : [EOL] def wrapper ( execution , ** kwargs ) : [EOL] detector = execution . evaluator . execution_recursion_detector [EOL] allowed = detector . push_execution ( execution ) [EOL] try : [EOL] if allowed : [EOL] result = default [EOL] else : [EOL] result = func ( execution , ** kwargs ) [EOL] finally : [EOL] detector . pop_execution ( ) [EOL] return result [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] class ExecutionRecursionDetector ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , evaluator ) : [EOL] self . recursion_level = [number] [EOL] self . parent_execution_funcs = [ ] [EOL] self . execution_funcs = set ( ) [EOL] self . execution_count = [number] [EOL] self . _evaluator = evaluator [EOL] [EOL] def __call__ ( self , execution ) : [EOL] debug . dbg ( [string] , execution , self . recursion_level , self . execution_count , len ( self . execution_funcs ) ) [EOL] if self . check_recursion ( execution ) : [EOL] result = set ( ) [EOL] else : [EOL] result = self . func ( execution ) [EOL] self . pop_execution ( ) [EOL] return result [EOL] [EOL] def pop_execution ( self ) : [EOL] self . parent_execution_funcs . pop ( ) [EOL] self . recursion_level -= [number] [EOL] [EOL] def push_execution ( self , execution ) : [EOL] in_par_execution_funcs = execution . tree_node in self . parent_execution_funcs [EOL] in_execution_funcs = execution . tree_node in self . execution_funcs [EOL] self . recursion_level += [number] [EOL] self . execution_count += [number] [EOL] self . execution_funcs . add ( execution . tree_node ) [EOL] self . parent_execution_funcs . append ( execution . tree_node ) [EOL] [EOL] if self . execution_count > settings . max_executions : [EOL] return True [EOL] [EOL] module = execution . get_root_context ( ) [EOL] if module == self . _evaluator . BUILTINS : [EOL] return False [EOL] [EOL] if in_par_execution_funcs : [EOL] if self . recursion_level > settings . max_function_recursion_level : [EOL] return True [EOL] if in_execution_funcs and len ( self . execution_funcs ) > settings . max_until_execution_unique : [EOL] return True [EOL] if self . execution_count > settings . max_executions_without_builtins : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Set [EOL] import typing [EOL] import glob [EOL] import os [EOL] import sys [EOL] from jedi . evaluate . site import addsitedir [EOL] [EOL] from jedi . _compatibility import exec_function , unicode [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . python import parse [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi import debug [EOL] from jedi import common [EOL] from jedi . evaluate . compiled import CompiledObject [EOL] from jedi . evaluate . context import ContextualizedNode [EOL] [EOL] [EOL] def get_venv_path ( venv ) : [EOL] [docstring] [EOL] sys_path = _get_venv_path_dirs ( venv ) [EOL] with common . ignored ( ValueError ) : [EOL] sys_path . remove ( [string] ) [EOL] sys_path = _get_sys_path_with_egglinks ( sys_path ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return sys_path + sys . path [EOL] [EOL] [EOL] def _get_sys_path_with_egglinks ( sys_path ) : [EOL] [docstring] [EOL] result = [ ] [EOL] for p in sys_path : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for egg_link in sorted ( glob . glob ( os . path . join ( p , [string] ) ) ) : [EOL] with open ( egg_link ) as fd : [EOL] for line in fd : [EOL] line = line . strip ( ) [EOL] if line : [EOL] result . append ( os . path . join ( p , line ) ) [EOL] [comment] [EOL] [comment] [EOL] break [EOL] result . append ( p ) [EOL] return result [EOL] [EOL] [EOL] def _get_venv_path_dirs ( venv ) : [EOL] [docstring] [EOL] venv = os . path . abspath ( venv ) [EOL] sitedir = _get_venv_sitepackages ( venv ) [EOL] sys_path = [ ] [EOL] addsitedir ( sys_path , sitedir ) [EOL] return sys_path [EOL] [EOL] [EOL] def _get_venv_sitepackages ( venv ) : [EOL] if os . name == [string] : [EOL] p = os . path . join ( venv , [string] , [string] ) [EOL] else : [EOL] p = os . path . join ( venv , [string] , [string] % sys . version_info [ : [number] ] , [string] ) [EOL] return p [EOL] [EOL] [EOL] def _execute_code ( module_path , code ) : [EOL] c = [string] [EOL] variables = { [string] : module_path } [EOL] try : [EOL] exec_function ( c % code , variables ) [EOL] except Exception : [EOL] debug . warning ( [string] ) [EOL] else : [EOL] try : [EOL] res = variables [ [string] ] [EOL] if isinstance ( res , str ) : [EOL] return [ os . path . abspath ( res ) ] [EOL] except KeyError : [EOL] pass [EOL] return [ ] [EOL] [EOL] [EOL] def _paths_from_assignment ( module_context , expr_stmt ) : [EOL] [docstring] [EOL] for assignee , operator in zip ( expr_stmt . children [ : : [number] ] , expr_stmt . children [ [number] : : [number] ] ) : [EOL] try : [EOL] assert operator in [ [string] , [string] ] [EOL] assert assignee . type in ( [string] , [string] ) and len ( assignee . children ) > [number] [EOL] c = assignee . children [EOL] assert c [ [number] ] . type == [string] and c [ [number] ] . value == [string] [EOL] trailer = c [ [number] ] [EOL] assert trailer . children [ [number] ] == [string] and trailer . children [ [number] ] . value == [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] except AssertionError : [EOL] continue [EOL] [EOL] from jedi . evaluate . iterable import py__iter__ [EOL] from jedi . evaluate . precedence import is_string [EOL] cn = ContextualizedNode ( module_context . create_context ( expr_stmt ) , expr_stmt ) [EOL] for lazy_context in py__iter__ ( module_context . evaluator , cn . infer ( ) , cn ) : [EOL] for context in lazy_context . infer ( ) : [EOL] if is_string ( context ) : [EOL] yield context . obj [EOL] [EOL] [EOL] def _paths_from_list_modifications ( module_path , trailer1 , trailer2 ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if not ( trailer1 . type == [string] and trailer1 . children [ [number] ] == [string] [EOL] and trailer2 . type == [string] and trailer2 . children [ [number] ] == [string] [EOL] and len ( trailer2 . children ) == [number] ) : [EOL] return [ ] [EOL] [EOL] name = trailer1 . children [ [number] ] . value [EOL] if name not in [ [string] , [string] ] : [EOL] return [ ] [EOL] arg = trailer2 . children [ [number] ] [EOL] if name == [string] and len ( arg . children ) in ( [number] , [number] ) : [comment] [EOL] arg = arg . children [ [number] ] [EOL] return _execute_code ( module_path , arg . get_code ( ) ) [EOL] [EOL] [EOL] def _check_module ( module_context ) : [EOL] [docstring] [EOL] def get_sys_path_powers ( names ) : [EOL] for name in names : [EOL] power = name . parent . parent [EOL] if power . type in ( [string] , [string] ) : [EOL] c = power . children [EOL] if isinstance ( c [ [number] ] , tree . Name ) and c [ [number] ] . value == [string] \ [EOL] and c [ [number] ] . type == [string] : [EOL] n = c [ [number] ] . children [ [number] ] [EOL] if isinstance ( n , tree . Name ) and n . value == [string] : [EOL] yield name , power [EOL] [EOL] sys_path = list ( module_context . evaluator . sys_path ) [comment] [EOL] if isinstance ( module_context , CompiledObject ) : [EOL] return sys_path [EOL] [EOL] try : [EOL] possible_names = module_context . tree_node . get_used_names ( ) [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] for name , power in get_sys_path_powers ( possible_names ) : [EOL] stmt = name . get_definition ( ) [EOL] if len ( power . children ) >= [number] : [EOL] sys_path . extend ( _paths_from_list_modifications ( module_context . py__file__ ( ) , * power . children [ [number] : [number] ] ) ) [EOL] elif name . get_definition ( ) . type == [string] : [EOL] sys_path . extend ( _paths_from_assignment ( module_context , stmt ) ) [EOL] return sys_path [EOL] [EOL] [EOL] @ memoize_default ( evaluator_is_first_arg = True , default = [ ] ) def sys_path_with_modifications ( evaluator , module_context ) : [EOL] path = module_context . py__file__ ( ) [EOL] if path is None : [EOL] [comment] [EOL] [comment] [EOL] return list ( evaluator . sys_path ) [EOL] [EOL] curdir = os . path . abspath ( os . curdir ) [EOL] [comment] [EOL] with common . ignored ( OSError ) : [EOL] os . chdir ( os . path . dirname ( path ) ) [EOL] [EOL] buildout_script_paths = set ( ) [EOL] [EOL] result = _check_module ( module_context ) [EOL] result += _detect_django_path ( path ) [EOL] for buildout_script_path in _get_buildout_script_paths ( path ) : [EOL] for path in _get_paths_from_buildout_script ( evaluator , buildout_script_path ) : [EOL] buildout_script_paths . add ( path ) [EOL] [comment] [EOL] os . chdir ( curdir ) [EOL] return list ( result ) + list ( buildout_script_paths ) [EOL] [EOL] [EOL] def _get_paths_from_buildout_script ( evaluator , buildout_script_path ) : [EOL] try : [EOL] module_node = parse ( path = buildout_script_path , grammar = evaluator . grammar , cache = True ) [EOL] except IOError : [EOL] debug . warning ( [string] , buildout_script_path ) [EOL] return [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] for path in _check_module ( ModuleContext ( evaluator , module_node , buildout_script_path ) ) : [EOL] yield path [EOL] [EOL] [EOL] def traverse_parents ( path ) : [EOL] while True : [EOL] new = os . path . dirname ( path ) [EOL] if new == path : [EOL] return [EOL] path = new [EOL] yield path [EOL] [EOL] [EOL] def _get_parent_dir_with_file ( path , filename ) : [EOL] for parent in traverse_parents ( path ) : [EOL] if os . path . isfile ( os . path . join ( parent , filename ) ) : [EOL] return parent [EOL] return None [EOL] [EOL] [EOL] def _detect_django_path ( module_path ) : [EOL] [docstring] [EOL] result = [ ] [EOL] [EOL] for parent in traverse_parents ( module_path ) : [EOL] with common . ignored ( IOError ) : [EOL] with open ( parent + os . path . sep + [string] ) : [EOL] debug . dbg ( [string] , module_path ) [EOL] result . append ( parent ) [EOL] return result [EOL] [EOL] [EOL] def _get_buildout_script_paths ( module_path ) : [EOL] [docstring] [EOL] project_root = _get_parent_dir_with_file ( module_path , [string] ) [EOL] if not project_root : [EOL] return [ ] [EOL] bin_path = os . path . join ( project_root , [string] ) [EOL] if not os . path . exists ( bin_path ) : [EOL] return [ ] [EOL] extra_module_paths = [ ] [EOL] for filename in os . listdir ( bin_path ) : [EOL] try : [EOL] filepath = os . path . join ( bin_path , filename ) [EOL] with open ( filepath , [string] ) as f : [EOL] firstline = f . readline ( ) [EOL] if firstline . startswith ( [string] ) and [string] in firstline : [EOL] extra_module_paths . append ( filepath ) [EOL] except ( UnicodeDecodeError , IOError ) as e : [EOL] [comment] [EOL] [comment] [EOL] debug . warning ( unicode ( e ) ) [EOL] continue [EOL] return extra_module_paths [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Iterable , Type , List , Tuple , Set , Iterator , Dict , Callable [EOL] import typing [EOL] [docstring] [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi import common [EOL] from jedi . common import unite , safe_property [EOL] from jedi . _compatibility import unicode , zip_longest , is_py3 [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate import context [EOL] from jedi . evaluate import precedence [EOL] from jedi . evaluate import recursion [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate . filters import DictFilter , AbstractNameDefinition , ParserTreeFilter [EOL] from jedi . parser_utils import get_comp_fors [EOL] [EOL] [EOL] class AbstractSequence ( context . Context ) : [EOL] builtin_methods = { } [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , evaluator ) : [EOL] super ( AbstractSequence , self ) . __init__ ( evaluator , evaluator . BUILTINS ) [EOL] [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def name ( self ) : [EOL] return compiled . CompiledContextName ( self , self . array_type ) [EOL] [EOL] [EOL] class BuiltinMethod ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , builtin_context , method , builtin_func ) : [EOL] self . _builtin_context = builtin_context [EOL] self . _method = method [EOL] self . _builtin_func = builtin_func [EOL] [EOL] def py__call__ ( self , params ) : [EOL] return self . _method ( self . _builtin_context ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _builtin_func , name ) [EOL] [EOL] [EOL] class SpecialMethodFilter ( DictFilter ) : [EOL] [docstring] [EOL] class SpecialMethodName ( AbstractNameDefinition ) : [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , parent_context , string_name , callable_ , builtin_context ) : [EOL] self . parent_context = parent_context [EOL] self . string_name = string_name [EOL] self . _callable = callable_ [EOL] self . _builtin_context = builtin_context [EOL] [EOL] def infer ( self ) : [EOL] filter = next ( self . _builtin_context . get_filters ( ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] builtin_func = next ( iter ( filter . get ( self . string_name ) [ [number] ] . infer ( ) ) ) [EOL] return set ( [ BuiltinMethod ( self . parent_context , self . _callable , builtin_func ) ] ) [EOL] [EOL] def __init__ ( self , context , dct , builtin_context ) : [EOL] super ( SpecialMethodFilter , self ) . __init__ ( dct ) [EOL] self . context = context [EOL] self . _builtin_context = builtin_context [EOL] [docstring] [EOL] [EOL] def _convert ( self , name , value ) : [EOL] return self . SpecialMethodName ( self . context , name , value , self . _builtin_context ) [EOL] [EOL] [EOL] def has_builtin_methods ( cls ) : [EOL] base_dct = { } [EOL] [comment] [EOL] [comment] [EOL] for base_cls in reversed ( cls . __bases__ ) : [EOL] try : [EOL] base_dct . update ( base_cls . builtin_methods ) [EOL] except AttributeError : [EOL] pass [EOL] [EOL] cls . builtin_methods = base_dct [EOL] for func in cls . __dict__ . values ( ) : [EOL] try : [EOL] cls . builtin_methods . update ( func . registered_builtin_methods ) [EOL] except AttributeError : [EOL] pass [EOL] return cls [EOL] [EOL] [EOL] def register_builtin_method ( method_name , python_version_match = None ) : [EOL] def wrapper ( func ) : [EOL] if python_version_match and python_version_match != [number] + int ( is_py3 ) : [EOL] [comment] [EOL] return func [EOL] dct = func . __dict__ . setdefault ( [string] , { } ) [EOL] dct [ method_name ] = func [EOL] return func [EOL] return wrapper [EOL] [EOL] [EOL] @ has_builtin_methods class GeneratorMixin ( object ) : [EOL] array_type = None [EOL] [EOL] @ register_builtin_method ( [string] ) @ register_builtin_method ( [string] , python_version_match = [number] ) @ register_builtin_method ( [string] , python_version_match = [number] ) def py__next__ ( self ) : [EOL] [comment] [EOL] return unite ( lazy_context . infer ( ) for lazy_context in self . py__iter__ ( ) ) [EOL] [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] gen_obj = compiled . get_special_object ( self . evaluator , [string] ) [EOL] yield SpecialMethodFilter ( self , self . builtin_methods , gen_obj ) [EOL] for filter in gen_obj . get_filters ( search_global ) : [EOL] yield filter [EOL] [EOL] def py__bool__ ( self ) : [EOL] return True [EOL] [EOL] def py__class__ ( self ) : [EOL] gen_obj = compiled . get_special_object ( self . evaluator , [string] ) [EOL] return gen_obj . py__class__ ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] return compiled . CompiledContextName ( self , [string] ) [EOL] [EOL] [EOL] class Generator ( GeneratorMixin , context . Context ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , evaluator , func_execution_context ) : [EOL] super ( Generator , self ) . __init__ ( evaluator , parent_context = evaluator . BUILTINS ) [EOL] self . _func_execution_context = func_execution_context [EOL] [EOL] def py__iter__ ( self ) : [EOL] return self . _func_execution_context . get_yield_values ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _func_execution_context ) [EOL] [EOL] [EOL] class CompForContext ( context . TreeContext ) : [EOL] @ classmethod def from_comp_for ( cls , parent_context , comp_for ) : [EOL] return cls ( parent_context . evaluator , parent_context , comp_for ) [EOL] [EOL] def __init__ ( self , evaluator , parent_context , comp_for ) : [EOL] super ( CompForContext , self ) . __init__ ( evaluator , parent_context ) [EOL] self . tree_node = comp_for [EOL] [EOL] def get_node ( self ) : [EOL] return self . tree_node [EOL] [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] yield ParserTreeFilter ( self . evaluator , self ) [EOL] [EOL] [EOL] class Comprehension ( AbstractSequence ) : [EOL] @ staticmethod def from_atom ( evaluator , context , atom ) : [EOL] bracket = atom . children [ [number] ] [EOL] if bracket == [string] : [EOL] if atom . children [ [number] ] . children [ [number] ] == [string] : [EOL] cls = DictComprehension [EOL] else : [EOL] cls = SetComprehension [EOL] elif bracket == [string] : [EOL] cls = GeneratorComprehension [EOL] elif bracket == [string] : [EOL] cls = ListComprehension [EOL] return cls ( evaluator , context , atom ) [EOL] [EOL] def __init__ ( self , evaluator , defining_context , atom ) : [EOL] super ( Comprehension , self ) . __init__ ( evaluator ) [EOL] self . _defining_context = defining_context [EOL] self . _atom = atom [EOL] [EOL] def _get_comprehension ( self ) : [EOL] [comment] [EOL] return self . _atom . children [ [number] ] [EOL] [EOL] def _get_comp_for ( self ) : [EOL] [comment] [EOL] return self . _get_comprehension ( ) . children [ [number] ] [EOL] [EOL] def _eval_node ( self , index = [number] ) : [EOL] [docstring] [EOL] return self . _get_comprehension ( ) . children [ index ] [EOL] [EOL] @ memoize_default ( ) def _get_comp_for_context ( self , parent_context , comp_for ) : [EOL] [comment] [EOL] return CompForContext . from_comp_for ( parent_context , comp_for ) [EOL] [EOL] def _nested ( self , comp_fors , parent_context = None ) : [EOL] evaluator = self . evaluator [EOL] comp_for = comp_fors [ [number] ] [EOL] input_node = comp_for . children [ [number] ] [EOL] parent_context = parent_context or self . _defining_context [EOL] input_types = parent_context . eval_node ( input_node ) [EOL] [EOL] cn = context . ContextualizedNode ( parent_context , input_node ) [EOL] iterated = py__iter__ ( evaluator , input_types , cn ) [EOL] exprlist = comp_for . children [ [number] ] [EOL] for i , lazy_context in enumerate ( iterated ) : [EOL] types = lazy_context . infer ( ) [EOL] dct = unpack_tuple_to_dict ( parent_context , types , exprlist ) [EOL] context_ = self . _get_comp_for_context ( parent_context , comp_for , ) [EOL] with helpers . predefine_names ( context_ , comp_for , dct ) : [EOL] try : [EOL] for result in self . _nested ( comp_fors [ [number] : ] , context_ ) : [EOL] yield result [EOL] except IndexError : [EOL] iterated = context_ . eval_node ( self . _eval_node ( ) ) [EOL] if self . array_type == [string] : [EOL] yield iterated , context_ . eval_node ( self . _eval_node ( [number] ) ) [EOL] else : [EOL] yield iterated [EOL] [EOL] @ memoize_default ( default = [ ] ) @ common . to_list def _iterate ( self ) : [EOL] comp_fors = tuple ( get_comp_fors ( self . _get_comp_for ( ) ) ) [EOL] for result in self . _nested ( comp_fors ) : [EOL] yield result [EOL] [EOL] def py__iter__ ( self ) : [EOL] for set_ in self . _iterate ( ) : [EOL] yield context . LazyKnownContexts ( set_ ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _atom ) [EOL] [EOL] [EOL] class ArrayMixin ( object ) : [EOL] def get_filters ( self , search_global , until_position = None , origin_scope = None ) : [EOL] [comment] [EOL] compiled_obj = compiled . builtin_from_name ( self . evaluator , self . array_type ) [EOL] yield SpecialMethodFilter ( self , self . builtin_methods , compiled_obj ) [EOL] for typ in compiled_obj . execute_evaluated ( self ) : [EOL] for filter in typ . get_filters ( ) : [EOL] yield filter [EOL] [EOL] def py__bool__ ( self ) : [EOL] return None [comment] [EOL] [EOL] def py__class__ ( self ) : [EOL] return compiled . builtin_from_name ( self . evaluator , self . array_type ) [EOL] [EOL] @ safe_property def parent ( self ) : [EOL] return self . evaluator . BUILTINS [EOL] [EOL] def dict_values ( self ) : [EOL] return unite ( self . _defining_context . eval_node ( v ) for k , v in self . _items ( ) ) [EOL] [EOL] [EOL] class ListComprehension ( ArrayMixin , Comprehension ) : [EOL] array_type = [string] [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] if isinstance ( index , slice ) : [EOL] return set ( [ self ] ) [EOL] [EOL] all_types = list ( self . py__iter__ ( ) ) [EOL] return all_types [ index ] . infer ( ) [EOL] [EOL] [EOL] class SetComprehension ( ArrayMixin , Comprehension ) : [EOL] array_type = [string] [EOL] [EOL] [EOL] @ has_builtin_methods class DictComprehension ( ArrayMixin , Comprehension ) : [EOL] array_type = [string] [EOL] [EOL] def _get_comp_for ( self ) : [EOL] return self . _get_comprehension ( ) . children [ [number] ] [EOL] [EOL] def py__iter__ ( self ) : [EOL] for keys , values in self . _iterate ( ) : [EOL] yield context . LazyKnownContexts ( keys ) [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] for keys , values in self . _iterate ( ) : [EOL] for k in keys : [EOL] if isinstance ( k , compiled . CompiledObject ) : [EOL] if k . obj == index : [EOL] return values [EOL] return self . dict_values ( ) [EOL] [EOL] def dict_values ( self ) : [EOL] return unite ( values for keys , values in self . _iterate ( ) ) [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_values ( self ) : [EOL] lazy_context = context . LazyKnownContexts ( self . dict_values ( ) ) [EOL] return set ( [ FakeSequence ( self . evaluator , [string] , [ lazy_context ] ) ] ) [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_items ( self ) : [EOL] items = set ( FakeSequence ( self . evaluator , [string] ( context . LazyKnownContexts ( keys ) , context . LazyKnownContexts ( values ) ) ) for keys , values in self . _iterate ( ) ) [EOL] [EOL] return create_evaluated_sequence_set ( self . evaluator , items , sequence_type = [string] ) [EOL] [EOL] [EOL] class GeneratorComprehension ( GeneratorMixin , Comprehension ) : [EOL] pass [EOL] [EOL] [EOL] class SequenceLiteralContext ( ArrayMixin , AbstractSequence ) : [EOL] mapping = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] def __init__ ( self , evaluator , defining_context , atom ) : [EOL] super ( SequenceLiteralContext , self ) . __init__ ( evaluator ) [EOL] self . atom = atom [EOL] self . _defining_context = defining_context [EOL] [EOL] if self . atom . type in ( [string] , [string] ) : [EOL] self . array_type = [string] [EOL] else : [EOL] self . array_type = SequenceLiteralContext . mapping [ atom . children [ [number] ] ] [EOL] [docstring] [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] [docstring] [EOL] if self . array_type == [string] : [EOL] for key , value in self . _items ( ) : [EOL] for k in self . _defining_context . eval_node ( key ) : [EOL] if isinstance ( k , compiled . CompiledObject ) \ [EOL] and index == k . obj : [EOL] return self . _defining_context . eval_node ( value ) [EOL] raise KeyError ( [string] % self ) [EOL] [EOL] [comment] [EOL] if isinstance ( index , slice ) : [EOL] return set ( [ self ] ) [EOL] else : [EOL] return self . _defining_context . eval_node ( self . _items ( ) [ index ] ) [EOL] [EOL] def py__iter__ ( self ) : [EOL] [docstring] [EOL] if self . array_type == [string] : [EOL] [comment] [EOL] types = set ( ) [EOL] for k , _ in self . _items ( ) : [EOL] types |= self . _defining_context . eval_node ( k ) [EOL] [comment] [EOL] [comment] [EOL] for _ in types : [EOL] yield context . LazyKnownContexts ( types ) [EOL] else : [EOL] for node in self . _items ( ) : [EOL] yield context . LazyTreeContext ( self . _defining_context , node ) [EOL] [EOL] for addition in check_array_additions ( self . _defining_context , self ) : [EOL] yield addition [EOL] [EOL] def _values ( self ) : [EOL] [docstring] [EOL] if self . array_type == [string] : [EOL] return unite ( v for k , v in self . _items ( ) ) [EOL] else : [EOL] return self . _items ( ) [EOL] [EOL] def _items ( self ) : [EOL] c = self . atom . children [EOL] [EOL] if self . atom . type in ( [string] , [string] ) : [EOL] return c [ : : [number] ] [EOL] [EOL] array_node = c [ [number] ] [EOL] if array_node in ( [string] , [string] , [string] ) : [EOL] return [ ] [comment] [EOL] [EOL] if array_node . type == [string] : [EOL] return array_node . children [ : : [number] ] [EOL] elif array_node . type == [string] : [EOL] kv = [ ] [EOL] iterator = iter ( array_node . children ) [EOL] for key in iterator : [EOL] op = next ( iterator , None ) [EOL] if op is None or op == [string] : [EOL] kv . append ( key ) [comment] [EOL] else : [EOL] assert op == [string] [comment] [EOL] kv . append ( ( key , next ( iterator ) ) ) [EOL] next ( iterator , None ) [comment] [EOL] return kv [EOL] else : [EOL] return [ array_node ] [EOL] [EOL] def exact_key_items ( self ) : [EOL] [docstring] [EOL] for key_node , value in self . _items ( ) : [EOL] for key in self . _defining_context . eval_node ( key_node ) : [EOL] if precedence . is_string ( key ) : [EOL] yield key . obj , context . LazyTreeContext ( self . _defining_context , value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . atom ) [EOL] [EOL] [EOL] @ has_builtin_methods class DictLiteralContext ( SequenceLiteralContext ) : [EOL] array_type = [string] [EOL] [EOL] def __init__ ( self , evaluator , defining_context , atom ) : [EOL] super ( SequenceLiteralContext , self ) . __init__ ( evaluator ) [EOL] self . _defining_context = defining_context [EOL] self . atom = atom [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_values ( self ) : [EOL] lazy_context = context . LazyKnownContexts ( self . dict_values ( ) ) [EOL] return set ( [ FakeSequence ( self . evaluator , [string] , [ lazy_context ] ) ] ) [EOL] [EOL] @ register_builtin_method ( [string] ) def _imitate_items ( self ) : [EOL] lazy_contexts = [ context . LazyKnownContext ( FakeSequence ( self . evaluator , [string] , ( context . LazyTreeContext ( self . _defining_context , key_node ) , context . LazyTreeContext ( self . _defining_context , value_node ) ) ) ) for key_node , value_node in self . _items ( ) ] [EOL] [EOL] return set ( [ FakeSequence ( self . evaluator , [string] , lazy_contexts ) ] ) [EOL] [EOL] [EOL] class _FakeArray ( SequenceLiteralContext ) : [EOL] def __init__ ( self , evaluator , container , type ) : [EOL] super ( SequenceLiteralContext , self ) . __init__ ( evaluator ) [EOL] self . array_type = type [EOL] self . atom = container [EOL] [comment] [EOL] [EOL] [EOL] class FakeSequence ( _FakeArray ) : [EOL] def __init__ ( self , evaluator , array_type , lazy_context_list ) : [EOL] [docstring] [EOL] super ( FakeSequence , self ) . __init__ ( evaluator , None , array_type ) [EOL] self . _lazy_context_list = lazy_context_list [EOL] [EOL] def _items ( self ) : [EOL] raise DeprecationWarning [EOL] return self . _context_list [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] return set ( self . _lazy_context_list [ index ] . infer ( ) ) [EOL] [EOL] def py__iter__ ( self ) : [EOL] return self . _lazy_context_list [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _lazy_context_list ) [EOL] [EOL] [EOL] class FakeDict ( _FakeArray ) : [EOL] def __init__ ( self , evaluator , dct ) : [EOL] super ( FakeDict , self ) . __init__ ( evaluator , dct , [string] ) [EOL] self . _dct = dct [EOL] [EOL] def py__iter__ ( self ) : [EOL] for key in self . _dct : [EOL] yield context . LazyKnownContext ( compiled . create ( self . evaluator , key ) ) [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] return self . _dct [ index ] . infer ( ) [EOL] [EOL] def dict_values ( self ) : [EOL] return unite ( lazy_context . infer ( ) for lazy_context in self . _dct . values ( ) ) [EOL] [EOL] def _items ( self ) : [EOL] raise DeprecationWarning [EOL] for key , values in self . _dct . items ( ) : [EOL] [comment] [EOL] yield key , values [ [number] ] [EOL] [EOL] def exact_key_items ( self ) : [EOL] return self . _dct . items ( ) [EOL] [EOL] [EOL] class MergedArray ( _FakeArray ) : [EOL] def __init__ ( self , evaluator , arrays ) : [EOL] super ( MergedArray , self ) . __init__ ( evaluator , arrays , arrays [ - [number] ] . array_type ) [EOL] self . _arrays = arrays [EOL] [EOL] def py__iter__ ( self ) : [EOL] for array in self . _arrays : [EOL] for lazy_context in array . py__iter__ ( ) : [EOL] yield lazy_context [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] return unite ( lazy_context . infer ( ) for lazy_context in self . py__iter__ ( ) ) [EOL] [EOL] def _items ( self ) : [EOL] for array in self . _arrays : [EOL] for a in array . _items ( ) : [EOL] yield a [EOL] [EOL] def __len__ ( self ) : [EOL] return sum ( len ( a ) for a in self . _arrays ) [EOL] [EOL] [EOL] def unpack_tuple_to_dict ( context , types , exprlist ) : [EOL] [docstring] [EOL] if exprlist . type == [string] : [EOL] return { exprlist . value : types } [EOL] elif exprlist . type == [string] and exprlist . children [ [number] ] in [string] : [EOL] return unpack_tuple_to_dict ( context , types , exprlist . children [ [number] ] ) [EOL] elif exprlist . type in ( [string] , [string] , [string] , [string] ) : [EOL] dct = { } [EOL] parts = iter ( exprlist . children [ : : [number] ] ) [EOL] n = [number] [EOL] for lazy_context in py__iter__ ( context . evaluator , types , exprlist ) : [EOL] n += [number] [EOL] try : [EOL] part = next ( parts ) [EOL] except StopIteration : [EOL] [comment] [EOL] analysis . add ( context , [string] , part , message = [string] % n ) [EOL] else : [EOL] dct . update ( unpack_tuple_to_dict ( context , lazy_context . infer ( ) , part ) ) [EOL] has_parts = next ( parts , None ) [EOL] if types and has_parts is not None : [EOL] [comment] [EOL] analysis . add ( context , [string] , has_parts , message = [string] % n ) [EOL] return dct [EOL] elif exprlist . type == [string] or exprlist . type == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return { } [EOL] elif exprlist . type == [string] : [comment] [EOL] [comment] [EOL] return { } [EOL] raise NotImplementedError [EOL] [EOL] [EOL] def py__iter__ ( evaluator , types , contextualized_node = None ) : [EOL] debug . dbg ( [string] ) [EOL] type_iters = [ ] [EOL] for typ in types : [EOL] try : [EOL] iter_method = typ . py__iter__ [EOL] except AttributeError : [EOL] if contextualized_node is not None : [EOL] analysis . add ( contextualized_node . context , [string] , contextualized_node . _node , message = [string] % typ ) [EOL] else : [EOL] type_iters . append ( iter_method ( ) ) [EOL] [EOL] for lazy_contexts in zip_longest ( * type_iters ) : [EOL] yield context . get_merged_lazy_context ( [ l for l in lazy_contexts if l is not None ] ) [EOL] [EOL] [EOL] def py__iter__types ( evaluator , types , contextualized_node = None ) : [EOL] [docstring] [EOL] return unite ( lazy_context . infer ( ) for lazy_context in py__iter__ ( evaluator , types , contextualized_node ) ) [EOL] [EOL] [EOL] def py__getitem__ ( evaluator , context , types , trailer ) : [EOL] from jedi . evaluate . representation import ClassContext [EOL] from jedi . evaluate . instance import TreeInstance [EOL] result = set ( ) [EOL] [EOL] trailer_op , node , trailer_cl = trailer . children [EOL] assert trailer_op == [string] [EOL] assert trailer_cl == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for typ in list ( types ) : [EOL] if isinstance ( typ , ( ClassContext , TreeInstance ) ) : [EOL] typing_module_types = pep0484 . py__getitem__ ( context , typ , node ) [EOL] if typing_module_types is not None : [EOL] types . remove ( typ ) [EOL] result |= typing_module_types [EOL] [EOL] if not types : [EOL] [comment] [EOL] return result [EOL] [EOL] for index in create_index_types ( evaluator , context , node ) : [EOL] if isinstance ( index , ( compiled . CompiledObject , Slice ) ) : [EOL] index = index . obj [EOL] [EOL] if type ( index ) not in ( float , int , str , unicode , slice ) : [EOL] [comment] [EOL] [comment] [EOL] for typ in list ( types ) : [EOL] if isinstance ( typ , AbstractSequence ) and typ . array_type == [string] : [EOL] types . remove ( typ ) [EOL] result |= typ . dict_values ( ) [EOL] return result | py__iter__types ( evaluator , types ) [EOL] [EOL] for typ in types : [EOL] [comment] [EOL] try : [EOL] getitem = typ . py__getitem__ [EOL] except AttributeError : [EOL] [comment] [EOL] analysis . add ( context , [string] , trailer_op , message = [string] % typ ) [EOL] else : [EOL] try : [EOL] result |= getitem ( index ) [EOL] except IndexError : [EOL] result |= py__iter__types ( evaluator , set ( [ typ ] ) ) [EOL] except KeyError : [EOL] [comment] [EOL] result |= typ . dict_values ( ) [EOL] return result [EOL] [EOL] [EOL] def check_array_additions ( context , sequence ) : [EOL] [docstring] [EOL] if sequence . array_type not in ( [string] , [string] ) : [EOL] [comment] [EOL] return set ( ) [EOL] [EOL] return _check_array_additions ( context , sequence ) [EOL] [EOL] [EOL] @ memoize_default ( default = set ( ) ) @ debug . increase_indent def _check_array_additions ( context , sequence ) : [EOL] [docstring] [EOL] from jedi . evaluate import param [EOL] [EOL] debug . dbg ( [string] % sequence , color = [string] ) [EOL] module_context = context . get_root_context ( ) [EOL] if not settings . dynamic_array_additions or isinstance ( module_context , compiled . CompiledObject ) : [EOL] debug . dbg ( [string] , color = [string] ) [EOL] return set ( ) [EOL] [EOL] def find_additions ( context , arglist , add_name ) : [EOL] params = list ( param . TreeArguments ( context . evaluator , context , arglist ) . unpack ( ) ) [EOL] result = set ( ) [EOL] if add_name in [ [string] ] : [EOL] params = params [ [number] : ] [EOL] if add_name in [ [string] , [string] , [string] ] : [EOL] for key , lazy_context in params : [EOL] result . add ( lazy_context ) [EOL] elif add_name in [ [string] , [string] ] : [EOL] for key , lazy_context in params : [EOL] result |= set ( py__iter__ ( context . evaluator , lazy_context . infer ( ) ) ) [EOL] return result [EOL] [EOL] temp_param_add , settings . dynamic_params_for_other_modules = settings . dynamic_params_for_other_modules , False [EOL] [EOL] is_list = sequence . name . string_name == [string] [EOL] search_names = ( [ [string] , [string] , [string] ] if is_list else [ [string] , [string] ] ) [EOL] [EOL] added_types = set ( ) [EOL] for add_name in search_names : [EOL] try : [EOL] possible_names = module_context . tree_node . get_used_names ( ) [ add_name ] [EOL] except KeyError : [EOL] continue [EOL] else : [EOL] for name in possible_names : [EOL] context_node = context . tree_node [EOL] if not ( context_node . start_pos < name . start_pos < context_node . end_pos ) : [EOL] continue [EOL] trailer = name . parent [EOL] power = trailer . parent [EOL] trailer_pos = power . children . index ( trailer ) [EOL] try : [EOL] execution_trailer = power . children [ trailer_pos + [number] ] [EOL] except IndexError : [EOL] continue [EOL] else : [EOL] if execution_trailer . type != [string] or execution_trailer . children [ [number] ] != [string] or execution_trailer . children [ [number] ] == [string] : [EOL] continue [EOL] [EOL] random_context = context . create_context ( name ) [EOL] [EOL] with recursion . execution_allowed ( context . evaluator , power ) as allowed : [EOL] if allowed : [EOL] found = helpers . evaluate_call_of_leaf ( random_context , name , cut_own_trailer = True ) [EOL] if sequence in found : [EOL] [comment] [EOL] added_types |= find_additions ( random_context , execution_trailer . children [ [number] ] , add_name ) [EOL] [EOL] [comment] [EOL] settings . dynamic_params_for_other_modules = temp_param_add [EOL] debug . dbg ( [string] % added_types , color = [string] ) [EOL] return added_types [EOL] [EOL] [EOL] def get_dynamic_array_instance ( instance ) : [EOL] [docstring] [EOL] if not settings . dynamic_array_additions : [EOL] return instance . var_args [EOL] [EOL] ai = _ArrayInstance ( instance ) [EOL] from jedi . evaluate import param [EOL] return param . ValuesArguments ( [ [ ai ] ] ) [EOL] [EOL] [EOL] class _ArrayInstance ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , instance ) : [EOL] self . instance = instance [EOL] self . var_args = instance . var_args [EOL] [EOL] def py__iter__ ( self ) : [EOL] var_args = self . var_args [EOL] try : [EOL] _ , lazy_context = next ( var_args . unpack ( ) ) [EOL] except StopIteration : [EOL] pass [EOL] else : [EOL] for lazy in py__iter__ ( self . instance . evaluator , lazy_context . infer ( ) ) : [EOL] yield lazy [EOL] [EOL] from jedi . evaluate import param [EOL] if isinstance ( var_args , param . TreeArguments ) : [EOL] additions = _check_array_additions ( var_args . context , self . instance ) [EOL] for addition in additions : [EOL] yield addition [EOL] [EOL] [EOL] class Slice ( context . Context ) : [EOL] def __init__ ( self , context , start , stop , step ) : [EOL] super ( Slice , self ) . __init__ ( context . evaluator , parent_context = context . evaluator . BUILTINS ) [EOL] self . _context = context [EOL] [comment] [EOL] self . _start = start [EOL] self . _stop = stop [EOL] self . _step = step [EOL] [EOL] @ property def obj ( self ) : [EOL] [docstring] [EOL] def get ( element ) : [EOL] if element is None : [EOL] return None [EOL] [EOL] result = self . _context . eval_node ( element ) [EOL] if len ( result ) != [number] : [EOL] [comment] [EOL] [comment] [EOL] raise IndexError [EOL] try : [EOL] return list ( result ) [ [number] ] . obj [EOL] except AttributeError : [EOL] return None [EOL] [EOL] try : [EOL] return slice ( get ( self . _start ) , get ( self . _stop ) , get ( self . _step ) ) [EOL] except IndexError : [EOL] return slice ( None , None , None ) [EOL] [EOL] [EOL] def create_index_types ( evaluator , context , index ) : [EOL] [docstring] [EOL] if index == [string] : [EOL] [comment] [EOL] return set ( [ Slice ( context , None , None , None ) ] ) [EOL] elif index . type == [string] : [comment] [EOL] [comment] [EOL] result = [ ] [EOL] for el in index . children : [EOL] if el == [string] : [EOL] if not result : [EOL] result . append ( None ) [EOL] elif el . type == [string] : [EOL] if len ( el . children ) == [number] : [EOL] result . append ( el . children [ [number] ] ) [EOL] else : [EOL] result . append ( el ) [EOL] result += [ None ] * ( [number] - len ( result ) ) [EOL] [EOL] return set ( [ Slice ( context , * result ) ] ) [EOL] [EOL] [comment] [EOL] return context . eval_node ( index ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[[None,typing.Iterable[typing.Optional[Variable[_T]]]],typing.Iterator[Variable[_T]]][[typing.Callable[[Variable[_T]],typing.Any],typing.Iterable[Variable[_T]]],typing.Iterator[Variable[_T]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Callable[[[None,typing.Iterable[typing.Optional[Variable[_T]]]],typing.Iterator[Variable[_T]]][[typing.Callable[[Variable[_T]],typing.Any],typing.Iterable[Variable[_T]]],typing.Iterator[Variable[_T]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , Union [EOL] import typing_extensions [EOL] import typing [EOL] from abc import abstractproperty [EOL] [EOL] from jedi . _compatibility import is_py3 [EOL] from jedi . common import unite [EOL] from jedi import debug [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import filters [EOL] from jedi . evaluate . context import Context , LazyKnownContext , LazyKnownContexts [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . cache import memoize_method [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate . dynamic import search_params [EOL] from jedi . evaluate import iterable [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] class AbstractInstanceContext ( Context ) : [EOL] [docstring] [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , evaluator , parent_context , class_context , var_args ) : [EOL] super ( AbstractInstanceContext , self ) . __init__ ( evaluator , parent_context ) [EOL] [comment] [EOL] [comment] [EOL] self . class_context = class_context [EOL] self . var_args = var_args [EOL] [EOL] def is_class ( self ) : [EOL] return False [EOL] [EOL] @ property def py__call__ ( self ) : [EOL] names = self . get_function_slot_names ( [string] ) [EOL] if not names : [EOL] [comment] [EOL] raise AttributeError [EOL] [EOL] def execute ( arguments ) : [EOL] return unite ( name . execute ( arguments ) for name in names ) [EOL] [EOL] return execute [EOL] [EOL] def py__class__ ( self ) : [EOL] return self . class_context [EOL] [EOL] def py__bool__ ( self ) : [EOL] [comment] [EOL] return None [EOL] [EOL] def get_function_slot_names ( self , name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for filter in self . get_filters ( include_self_names = False ) : [EOL] names = filter . get ( name ) [EOL] if names : [EOL] return names [EOL] return [ ] [EOL] [EOL] def execute_function_slots ( self , names , * evaluated_args ) : [EOL] return unite ( name . execute_evaluated ( * evaluated_args ) for name in names ) [EOL] [EOL] def py__get__ ( self , obj ) : [EOL] [comment] [EOL] [comment] [EOL] names = self . get_function_slot_names ( [string] ) [EOL] if names : [EOL] if isinstance ( obj , AbstractInstanceContext ) : [EOL] return self . execute_function_slots ( names , obj , obj . class_context ) [EOL] else : [EOL] none_obj = compiled . create ( self . evaluator , None ) [EOL] return self . execute_function_slots ( names , none_obj , obj ) [EOL] else : [EOL] return set ( [ self ] ) [EOL] [EOL] def get_filters ( self , search_global = None , until_position = None , origin_scope = None , include_self_names = True ) : [EOL] if include_self_names : [EOL] for cls in self . class_context . py__mro__ ( ) : [EOL] if isinstance ( cls , compiled . CompiledObject ) : [EOL] if cls . tree_node is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] yield SelfNameFilter ( self . evaluator , self , cls , origin_scope ) [EOL] else : [EOL] yield SelfNameFilter ( self . evaluator , self , cls , origin_scope ) [EOL] [EOL] for cls in self . class_context . py__mro__ ( ) : [EOL] if isinstance ( cls , compiled . CompiledObject ) : [EOL] yield CompiledInstanceClassFilter ( self . evaluator , self , cls ) [EOL] else : [EOL] yield InstanceClassFilter ( self . evaluator , self , cls , origin_scope ) [EOL] [EOL] def py__getitem__ ( self , index ) : [EOL] try : [EOL] names = self . get_function_slot_names ( [string] ) [EOL] except KeyError : [EOL] debug . warning ( [string] ) [EOL] return set ( ) [EOL] else : [EOL] index_obj = compiled . create ( self . evaluator , index ) [EOL] return self . execute_function_slots ( names , index_obj ) [EOL] [EOL] def py__iter__ ( self ) : [EOL] iter_slot_names = self . get_function_slot_names ( [string] ) [EOL] if not iter_slot_names : [EOL] debug . warning ( [string] % self ) [EOL] return [EOL] [EOL] for generator in self . execute_function_slots ( iter_slot_names ) : [EOL] if isinstance ( generator , AbstractInstanceContext ) : [EOL] [comment] [EOL] name = [string] if is_py3 else [string] [EOL] iter_slot_names = generator . get_function_slot_names ( name ) [EOL] if iter_slot_names : [EOL] yield LazyKnownContexts ( generator . execute_function_slots ( iter_slot_names ) ) [EOL] else : [EOL] debug . warning ( [string] , generator ) [EOL] else : [EOL] for lazy_context in generator . py__iter__ ( ) : [EOL] yield lazy_context [EOL] [EOL] @ abstractproperty def name ( self ) : [EOL] pass [EOL] [EOL] def _create_init_execution ( self , class_context , func_node ) : [EOL] bound_method = BoundMethod ( self . evaluator , self , class_context , self . parent_context , func_node ) [EOL] return InstanceFunctionExecution ( self , class_context . parent_context , bound_method , self . var_args ) [EOL] [EOL] def create_init_executions ( self ) : [EOL] for name in self . get_function_slot_names ( [string] ) : [EOL] if isinstance ( name , LazyInstanceName ) : [EOL] yield self . _create_init_execution ( name . class_context , name . tree_name . parent ) [EOL] [EOL] @ memoize_default ( ) def create_instance_context ( self , class_context , node ) : [EOL] if node . parent . type in ( [string] , [string] ) : [EOL] node = node . parent [EOL] scope = get_parent_scope ( node ) [EOL] if scope == class_context . tree_node : [EOL] return class_context [EOL] else : [EOL] parent_context = self . create_instance_context ( class_context , scope ) [EOL] if scope . type == [string] : [EOL] if scope . name . value == [string] and parent_context == class_context : [EOL] return self . _create_init_execution ( class_context , scope ) [EOL] else : [EOL] bound_method = BoundMethod ( self . evaluator , self , class_context , self . parent_context , scope ) [EOL] return bound_method . get_function_execution ( ) [EOL] else : [EOL] raise NotImplementedError [EOL] return class_context [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . class_context , self . var_args ) [EOL] [EOL] [EOL] class CompiledInstance ( AbstractInstanceContext ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( CompiledInstance , self ) . __init__ ( * args , ** kwargs ) [EOL] [comment] [EOL] [comment] [EOL] if self . class_context . name . string_name in [ [string] , [string] ] \ [EOL] and self . parent_context . get_root_context ( ) == self . evaluator . BUILTINS : [EOL] [comment] [EOL] self . var_args = iterable . get_dynamic_array_instance ( self ) [EOL] [EOL] @ property def name ( self ) : [EOL] return compiled . CompiledContextName ( self , self . class_context . name . string_name ) [EOL] [EOL] def create_instance_context ( self , class_context , node ) : [EOL] if get_parent_scope ( node ) . type == [string] : [EOL] return class_context [EOL] else : [EOL] return super ( CompiledInstance , self ) . create_instance_context ( class_context , node ) [EOL] [EOL] [EOL] class TreeInstance ( AbstractInstanceContext ) : [EOL] def __init__ ( self , evaluator , parent_context , class_context , var_args ) : [EOL] super ( TreeInstance , self ) . __init__ ( evaluator , parent_context , class_context , var_args ) [EOL] self . tree_node = class_context . tree_node [EOL] [EOL] @ property def name ( self ) : [EOL] return filters . ContextName ( self , self . class_context . name . tree_name ) [EOL] [EOL] [EOL] class AnonymousInstance ( TreeInstance ) : [EOL] def __init__ ( self , evaluator , parent_context , class_context ) : [EOL] super ( AnonymousInstance , self ) . __init__ ( evaluator , parent_context , class_context , var_args = None ) [EOL] [EOL] [EOL] class CompiledInstanceName ( compiled . CompiledName ) : [EOL] def __init__ ( self , evaluator , instance , parent_context , name ) : [EOL] super ( CompiledInstanceName , self ) . __init__ ( evaluator , parent_context , name ) [EOL] self . _instance = instance [EOL] [EOL] def infer ( self ) : [EOL] for result_context in super ( CompiledInstanceName , self ) . infer ( ) : [EOL] if isinstance ( result_context , er . FunctionContext ) : [EOL] parent_context = result_context . parent_context [EOL] while parent_context . is_class ( ) : [EOL] parent_context = parent_context . parent_context [EOL] [EOL] yield BoundMethod ( result_context . evaluator , self . _instance , self . parent_context , parent_context , result_context . tree_node ) [EOL] else : [EOL] if result_context . api_type == [string] : [EOL] yield CompiledBoundMethod ( result_context ) [EOL] else : [EOL] yield result_context [EOL] [EOL] [EOL] class CompiledInstanceClassFilter ( compiled . CompiledObjectFilter ) : [EOL] name_class = CompiledInstanceName [EOL] [EOL] def __init__ ( self , evaluator , instance , compiled_object ) : [EOL] super ( CompiledInstanceClassFilter , self ) . __init__ ( evaluator , compiled_object , is_instance = True , ) [EOL] self . _instance = instance [EOL] [EOL] def _create_name ( self , name ) : [EOL] return self . name_class ( self . _evaluator , self . _instance , self . _compiled_object , name ) [EOL] [EOL] [EOL] class BoundMethod ( er . FunctionContext ) : [EOL] def __init__ ( self , evaluator , instance , class_context , * args , ** kwargs ) : [EOL] super ( BoundMethod , self ) . __init__ ( evaluator , * args , ** kwargs ) [EOL] self . _instance = instance [EOL] self . _class_context = class_context [EOL] [EOL] def get_function_execution ( self , arguments = None ) : [EOL] if arguments is None : [EOL] return AnonymousInstanceFunctionExecution ( self . _instance , self . parent_context , self ) [EOL] else : [EOL] return InstanceFunctionExecution ( self . _instance , self . parent_context , self , arguments ) [EOL] [EOL] [EOL] class CompiledBoundMethod ( compiled . CompiledObject ) : [EOL] def __init__ ( self , func ) : [EOL] super ( CompiledBoundMethod , self ) . __init__ ( func . evaluator , func . obj , func . parent_context , func . tree_node ) [EOL] [EOL] def get_param_names ( self ) : [EOL] return list ( super ( CompiledBoundMethod , self ) . get_param_names ( ) ) [ [number] : ] [EOL] [EOL] [EOL] class InstanceNameDefinition ( filters . TreeNameDefinition ) : [EOL] def infer ( self ) : [EOL] contexts = super ( InstanceNameDefinition , self ) . infer ( ) [EOL] for context in contexts : [EOL] yield context [EOL] [EOL] [EOL] class LazyInstanceName ( filters . TreeNameDefinition ) : [EOL] [docstring] [EOL] def __init__ ( self , instance , class_context , tree_name ) : [EOL] self . _instance = instance [EOL] self . class_context = class_context [EOL] self . tree_name = tree_name [EOL] [EOL] @ property def parent_context ( self ) : [EOL] return self . _instance . create_instance_context ( self . class_context , self . tree_name ) [EOL] [EOL] [EOL] class LazyInstanceClassName ( LazyInstanceName ) : [EOL] def infer ( self ) : [EOL] for result_context in super ( LazyInstanceClassName , self ) . infer ( ) : [EOL] if isinstance ( result_context , er . FunctionContext ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parent_context = result_context . parent_context [EOL] while parent_context . is_class ( ) : [EOL] parent_context = parent_context . parent_context [EOL] [EOL] yield BoundMethod ( result_context . evaluator , self . _instance , self . class_context , parent_context , result_context . tree_node ) [EOL] else : [EOL] for c in er . apply_py__get__ ( result_context , self . _instance ) : [EOL] yield c [EOL] [EOL] [EOL] class InstanceClassFilter ( filters . ParserTreeFilter ) : [EOL] name_class = LazyInstanceClassName [EOL] [EOL] def __init__ ( self , evaluator , context , class_context , origin_scope ) : [EOL] super ( InstanceClassFilter , self ) . __init__ ( evaluator = evaluator , context = context , node_context = class_context , origin_scope = origin_scope ) [EOL] self . _class_context = class_context [EOL] [EOL] def _equals_origin_scope ( self ) : [EOL] node = self . _origin_scope [EOL] while node is not None : [EOL] if node == self . _parser_scope or node == self . context : [EOL] return True [EOL] node = get_parent_scope ( node ) [EOL] return False [EOL] [EOL] def _access_possible ( self , name ) : [EOL] return not name . value . startswith ( [string] ) or name . value . endswith ( [string] ) or self . _equals_origin_scope ( ) [EOL] [EOL] def _filter ( self , names ) : [EOL] names = super ( InstanceClassFilter , self ) . _filter ( names ) [EOL] return [ name for name in names if self . _access_possible ( name ) ] [EOL] [EOL] def _convert_names ( self , names ) : [EOL] return [ self . name_class ( self . context , self . _class_context , name ) for name in names ] [EOL] [EOL] [EOL] class SelfNameFilter ( InstanceClassFilter ) : [EOL] name_class = LazyInstanceName [EOL] [EOL] def _filter ( self , names ) : [EOL] names = self . _filter_self_names ( names ) [EOL] if isinstance ( self . _parser_scope , compiled . CompiledObject ) and False : [EOL] [comment] [EOL] return list ( names ) [EOL] else : [EOL] start , end = self . _parser_scope . start_pos , self . _parser_scope . end_pos [EOL] return [ n for n in names if start < n . start_pos < end ] [EOL] [EOL] def _filter_self_names ( self , names ) : [EOL] for name in names : [EOL] trailer = name . parent [EOL] if trailer . type == [string] \ [EOL] and len ( trailer . children ) == [number] \ [EOL] and trailer . children [ [number] ] == [string] : [EOL] if name . is_definition ( ) and self . _access_possible ( name ) : [EOL] yield name [EOL] [EOL] def _check_flows ( self , names ) : [EOL] return names [EOL] [EOL] [EOL] class ParamArguments ( object ) : [EOL] [docstring] [EOL] class LazyParamContext ( object ) : [EOL] def __init__ ( self , fucking_param ) : [EOL] self . _param = fucking_param [EOL] [EOL] def infer ( self ) : [EOL] return self . _param . infer ( ) [EOL] [EOL] def __init__ ( self , execution_context , funcdef ) : [EOL] self . _execution_context = execution_context [EOL] self . _funcdef = funcdef [EOL] [EOL] def unpack ( self , func = None ) : [EOL] params = search_params ( self . _execution_context . evaluator , self . _execution_context , self . _funcdef ) [EOL] is_first = True [EOL] for p in params : [EOL] [comment] [EOL] if is_first : [EOL] is_first = False [EOL] continue [EOL] yield None , self . LazyParamContext ( p ) [EOL] [EOL] [EOL] class InstanceVarArgs ( object ) : [EOL] def __init__ ( self , execution_context , funcdef , var_args ) : [EOL] self . _execution_context = execution_context [EOL] self . _funcdef = funcdef [EOL] self . _var_args = var_args [EOL] [EOL] @ memoize_method def _get_var_args ( self ) : [EOL] if self . _var_args is None : [EOL] [comment] [EOL] return ParamArguments ( self . _execution_context , self . _funcdef ) [EOL] [EOL] return self . _var_args [EOL] [EOL] def unpack ( self , func = None ) : [EOL] yield None , LazyKnownContext ( self . _execution_context . instance ) [EOL] for values in self . _get_var_args ( ) . unpack ( func ) : [EOL] yield values [EOL] [EOL] def get_calling_nodes ( self ) : [EOL] return self . _get_var_args ( ) . get_calling_nodes ( ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _var_args , name ) [EOL] [EOL] [EOL] class InstanceFunctionExecution ( er . FunctionExecutionContext ) : [EOL] def __init__ ( self , instance , parent_context , function_context , var_args ) : [EOL] self . instance = instance [EOL] var_args = InstanceVarArgs ( self , function_context . tree_node , var_args ) [EOL] [EOL] super ( InstanceFunctionExecution , self ) . __init__ ( instance . evaluator , parent_context , function_context , var_args ) [EOL] [EOL] [EOL] class AnonymousInstanceFunctionExecution ( InstanceFunctionExecution ) : [EOL] function_execution_filter = filters . AnonymousInstanceFunctionExecutionFilter [EOL] [EOL] def __init__ ( self , instance , parent_context , function_context ) : [EOL] super ( AnonymousInstanceFunctionExecution , self ) . __init__ ( instance , parent_context , function_context , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from abc import abstractmethod [EOL] [EOL] from jedi . parser . tree import search_ancestor [EOL] from jedi . evaluate import flow_analysis [EOL] from jedi . common import to_list , unite [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] class AbstractNameDefinition ( object ) : [EOL] start_pos = None [EOL] string_name = None [EOL] parent_context = None [EOL] tree_name = None [EOL] [EOL] @ abstractmethod def infer ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def get_root_context ( self ) : [EOL] return self . parent_context . get_root_context ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] if self . start_pos is None : [EOL] return [string] % ( self . __class__ . __name__ , self . string_name ) [EOL] return [string] % ( self . __class__ . __name__ , self . string_name , self . start_pos ) [EOL] [EOL] def execute ( self , arguments ) : [EOL] return unite ( context . execute ( arguments ) for context in self . infer ( ) ) [EOL] [EOL] def execute_evaluated ( self , * args , ** kwargs ) : [EOL] return unite ( context . execute_evaluated ( * args , ** kwargs ) for context in self . infer ( ) ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] return self . parent_context . api_type [EOL] [EOL] [EOL] class AbstractTreeName ( AbstractNameDefinition ) : [EOL] def __init__ ( self , parent_context , tree_name ) : [EOL] self . parent_context = parent_context [EOL] self . tree_name = tree_name [EOL] [EOL] @ property def string_name ( self ) : [EOL] return self . tree_name . value [EOL] [EOL] @ property def start_pos ( self ) : [EOL] return self . tree_name . start_pos [EOL] [EOL] [EOL] class ContextNameMixin ( object ) : [EOL] def infer ( self ) : [EOL] return set ( [ self . _context ] ) [EOL] [EOL] def get_root_context ( self ) : [EOL] if self . parent_context is None : [EOL] return self . _context [EOL] return super ( ContextNameMixin , self ) . get_root_context ( ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] return self . _context . api_type [EOL] [EOL] [EOL] class ContextName ( ContextNameMixin , AbstractTreeName ) : [EOL] def __init__ ( self , context , tree_name ) : [EOL] super ( ContextName , self ) . __init__ ( context . parent_context , tree_name ) [EOL] self . _context = context [EOL] [EOL] [EOL] class TreeNameDefinition ( AbstractTreeName ) : [EOL] def infer ( self ) : [EOL] [comment] [EOL] from jedi . evaluate . finder import _name_to_types [EOL] return _name_to_types ( self . parent_context . evaluator , self . parent_context , self . tree_name ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] definition = self . tree_name . get_definition ( ) [EOL] return dict ( import_name = [string] , import_from = [string] , funcdef = [string] , param = [string] , classdef = [string] , ) . get ( definition . type , [string] ) [EOL] [EOL] [EOL] class ParamName ( AbstractTreeName ) : [EOL] api_type = [string] [EOL] [EOL] def __init__ ( self , parent_context , tree_name ) : [EOL] self . parent_context = parent_context [EOL] self . tree_name = tree_name [EOL] [EOL] def infer ( self ) : [EOL] return self . get_param ( ) . infer ( ) [EOL] [EOL] def get_param ( self ) : [EOL] params = self . parent_context . get_params ( ) [EOL] param_node = search_ancestor ( self . tree_name , [string] ) [EOL] return params [ param_node . position_index ] [EOL] [EOL] [EOL] class AnonymousInstanceParamName ( ParamName ) : [EOL] def infer ( self ) : [EOL] param_node = search_ancestor ( self . tree_name , [string] ) [EOL] if param_node . position_index == [number] : [EOL] [comment] [EOL] [comment] [EOL] return set ( [ self . parent_context . instance ] ) [EOL] else : [EOL] return self . get_param ( ) . infer ( ) [EOL] [EOL] [EOL] class AbstractFilter ( object ) : [EOL] _until_position = None [EOL] [EOL] def _filter ( self , names ) : [EOL] if self . _until_position is not None : [EOL] return [ n for n in names if n . start_pos < self . _until_position ] [EOL] return names [EOL] [EOL] @ abstractmethod def get ( self , name ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def values ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class AbstractUsedNamesFilter ( AbstractFilter ) : [EOL] name_class = TreeNameDefinition [EOL] [EOL] def __init__ ( self , context , parser_scope ) : [EOL] self . _parser_scope = parser_scope [EOL] self . _used_names = self . _parser_scope . get_root_node ( ) . get_used_names ( ) [EOL] self . context = context [EOL] [EOL] def get ( self , name ) : [EOL] try : [EOL] names = self . _used_names [ str ( name ) ] [EOL] except KeyError : [EOL] return [ ] [EOL] [EOL] return self . _convert_names ( self . _filter ( names ) ) [EOL] [EOL] def _convert_names ( self , names ) : [EOL] return [ self . name_class ( self . context , name ) for name in names ] [EOL] [EOL] def values ( self ) : [EOL] return self . _convert_names ( name for name_list in self . _used_names . values ( ) for name in self . _filter ( name_list ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . context ) [EOL] [EOL] [EOL] class ParserTreeFilter ( AbstractUsedNamesFilter ) : [EOL] def __init__ ( self , evaluator , context , node_context = None , until_position = None , origin_scope = None ) : [EOL] [docstring] [EOL] if node_context is None : [EOL] node_context = context [EOL] super ( ParserTreeFilter , self ) . __init__ ( context , node_context . tree_node ) [EOL] self . _node_context = node_context [EOL] self . _origin_scope = origin_scope [EOL] self . _until_position = until_position [EOL] [EOL] def _filter ( self , names ) : [EOL] names = super ( ParserTreeFilter , self ) . _filter ( names ) [EOL] names = [ n for n in names if self . _is_name_reachable ( n ) ] [EOL] return list ( self . _check_flows ( names ) ) [EOL] [EOL] def _is_name_reachable ( self , name ) : [EOL] if not name . is_definition ( ) : [EOL] return False [EOL] parent = name . parent [EOL] if parent . type == [string] : [EOL] return False [EOL] base_node = parent if parent . type in ( [string] , [string] ) else name [EOL] return get_parent_scope ( base_node ) == self . _parser_scope [EOL] [EOL] def _check_flows ( self , names ) : [EOL] for name in sorted ( names , key = lambda name : name . start_pos , reverse = True ) : [EOL] check = flow_analysis . reachability_check ( self . _node_context , self . _parser_scope , name , self . _origin_scope ) [EOL] if check is not flow_analysis . UNREACHABLE : [EOL] yield name [EOL] [EOL] if check is flow_analysis . REACHABLE : [EOL] break [EOL] [EOL] [EOL] class FunctionExecutionFilter ( ParserTreeFilter ) : [EOL] param_name = ParamName [EOL] [EOL] def __init__ ( self , evaluator , context , node_context = None , until_position = None , origin_scope = None ) : [EOL] super ( FunctionExecutionFilter , self ) . __init__ ( evaluator , context , node_context , until_position , origin_scope ) [EOL] [EOL] @ to_list def _convert_names ( self , names ) : [EOL] for name in names : [EOL] param = search_ancestor ( name , [string] ) [EOL] if param : [EOL] yield self . param_name ( self . context , name ) [EOL] else : [EOL] yield TreeNameDefinition ( self . context , name ) [EOL] [EOL] [EOL] class AnonymousInstanceFunctionExecutionFilter ( FunctionExecutionFilter ) : [EOL] param_name = AnonymousInstanceParamName [EOL] [EOL] [EOL] class GlobalNameFilter ( AbstractUsedNamesFilter ) : [EOL] def __init__ ( self , context , parser_scope ) : [EOL] super ( GlobalNameFilter , self ) . __init__ ( context , parser_scope ) [EOL] [EOL] @ to_list def _filter ( self , names ) : [EOL] for name in names : [EOL] if name . parent . type == [string] : [EOL] yield name [EOL] [EOL] [EOL] class DictFilter ( AbstractFilter ) : [EOL] def __init__ ( self , dct ) : [EOL] self . _dct = dct [EOL] [EOL] def get ( self , name ) : [EOL] try : [EOL] value = self . _convert ( name , self . _dct [ str ( name ) ] ) [EOL] except KeyError : [EOL] return [ ] [EOL] [EOL] return list ( self . _filter ( [ value ] ) ) [EOL] [EOL] def values ( self ) : [EOL] return self . _filter ( self . _convert ( * item ) for item in self . _dct . items ( ) ) [EOL] [EOL] def _convert ( self , name , value ) : [EOL] return value [EOL] [EOL] [EOL] def get_global_filters ( evaluator , context , until_position , origin_scope ) : [EOL] [docstring] [EOL] from jedi . evaluate . representation import FunctionExecutionContext [EOL] while context is not None : [EOL] [comment] [EOL] for filter in context . get_filters ( search_global = True , until_position = until_position , origin_scope = origin_scope ) : [EOL] yield filter [EOL] if isinstance ( context , FunctionExecutionContext ) : [EOL] [comment] [EOL] until_position = None [EOL] [EOL] context = context . parent_context [EOL] [EOL] [comment] [EOL] for filter in evaluator . BUILTINS . get_filters ( search_global = True ) : [EOL] yield filter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Callable , Any , Set [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import sys [EOL] import os [EOL] [EOL] [EOL] def makepath ( * paths ) : [EOL] dir = os . path . join ( * paths ) [EOL] try : [EOL] dir = os . path . abspath ( dir ) [EOL] except OSError : [EOL] pass [EOL] return dir , os . path . normcase ( dir ) [EOL] [EOL] [EOL] def _init_pathinfo ( sys_path ) : [EOL] [docstring] [EOL] d = set ( ) [EOL] for dir in sys_path : [EOL] try : [EOL] if os . path . isdir ( dir ) : [EOL] dir , dircase = makepath ( dir ) [EOL] d . add ( dircase ) [EOL] except TypeError : [EOL] continue [EOL] return d [EOL] [EOL] [EOL] def addpackage ( sys_path , sitedir , name , known_paths ) : [EOL] [docstring] [EOL] if known_paths is None : [EOL] known_paths = _init_pathinfo ( sys_path ) [EOL] reset = [number] [EOL] else : [EOL] reset = [number] [EOL] fullname = os . path . join ( sitedir , name ) [EOL] try : [EOL] f = open ( fullname , [string] ) [EOL] except OSError : [EOL] return [EOL] with f : [EOL] for n , line in enumerate ( f ) : [EOL] if line . startswith ( [string] ) : [EOL] continue [EOL] try : [EOL] if line . startswith ( ( [string] , [string] ) ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] line = line . rstrip ( ) [EOL] dir , dircase = makepath ( sitedir , line ) [EOL] if not dircase in known_paths and os . path . exists ( dir ) : [EOL] sys_path . append ( dir ) [EOL] known_paths . add ( dircase ) [EOL] except Exception : [EOL] print ( [string] . format ( n + [number] , fullname ) , file = sys . stderr ) [EOL] import traceback [EOL] for record in traceback . format_exception ( * sys . exc_info ( ) ) : [EOL] for line in record . splitlines ( ) : [EOL] print ( [string] + line , file = sys . stderr ) [EOL] print ( [string] , file = sys . stderr ) [EOL] break [EOL] if reset : [EOL] known_paths = None [EOL] return known_paths [EOL] [EOL] [EOL] def addsitedir ( sys_path , sitedir , known_paths = None ) : [EOL] [docstring] [EOL] if known_paths is None : [EOL] known_paths = _init_pathinfo ( sys_path ) [EOL] reset = [number] [EOL] else : [EOL] reset = [number] [EOL] sitedir , sitedircase = makepath ( sitedir ) [EOL] if not sitedircase in known_paths : [EOL] sys_path . append ( sitedir ) [comment] [EOL] known_paths . add ( sitedircase ) [EOL] try : [EOL] names = os . listdir ( sitedir ) [EOL] except OSError : [EOL] return [EOL] names = [ name for name in names if name . endswith ( [string] ) ] [EOL] for name in sorted ( names ) : [EOL] addpackage ( sys_path , sitedir , name , known_paths ) [EOL] if reset : [EOL] known_paths = None [EOL] return known_paths [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] try : [EOL] from collections import abc [EOL] except ImportError : [EOL] [comment] [EOL] import collections as abc [EOL] [EOL] [EOL] def factory ( typing_name , indextypes ) : [EOL] class Iterable ( abc . Iterable ) : [EOL] def __iter__ ( self ) : [EOL] while True : [EOL] yield indextypes [ [number] ] ( ) [EOL] [EOL] class Iterator ( Iterable , abc . Iterator ) : [EOL] def next ( self ) : [EOL] [docstring] [EOL] return self . __next__ ( ) [EOL] [EOL] def __next__ ( self ) : [EOL] return indextypes [ [number] ] ( ) [EOL] [EOL] class Sequence ( abc . Sequence ) : [EOL] def __getitem__ ( self , index ) : [EOL] return indextypes [ [number] ] ( ) [EOL] [EOL] class MutableSequence ( Sequence , abc . MutableSequence ) : [EOL] pass [EOL] [EOL] class List ( MutableSequence , list ) : [EOL] pass [EOL] [EOL] class Tuple ( Sequence , tuple ) : [EOL] def __getitem__ ( self , index ) : [EOL] if indextypes [ [number] ] == Ellipsis : [EOL] [comment] [EOL] [comment] [EOL] return indextypes [ [number] ] ( ) [EOL] else : [EOL] return indextypes [ index ] ( ) [EOL] [EOL] class AbstractSet ( Iterable , abc . Set ) : [EOL] pass [EOL] [EOL] class MutableSet ( AbstractSet , abc . MutableSet ) : [EOL] pass [EOL] [EOL] class KeysView ( Iterable , abc . KeysView ) : [EOL] pass [EOL] [EOL] class ValuesView ( abc . ValuesView ) : [EOL] def __iter__ ( self ) : [EOL] while True : [EOL] yield indextypes [ [number] ] ( ) [EOL] [EOL] class ItemsView ( abc . ItemsView ) : [EOL] def __iter__ ( self ) : [EOL] while True : [EOL] yield ( indextypes [ [number] ] ( ) , indextypes [ [number] ] ( ) ) [EOL] [EOL] class Mapping ( Iterable , abc . Mapping ) : [EOL] def __getitem__ ( self , item ) : [EOL] return indextypes [ [number] ] ( ) [EOL] [EOL] def keys ( self ) : [EOL] return KeysView ( ) [EOL] [EOL] def values ( self ) : [EOL] return ValuesView ( ) [EOL] [EOL] def items ( self ) : [EOL] return ItemsView ( ) [EOL] [EOL] class MutableMapping ( Mapping , abc . MutableMapping ) : [EOL] pass [EOL] [EOL] class Dict ( MutableMapping , dict ) : [EOL] pass [EOL] [EOL] dct = { [string] : Sequence , [string] : MutableSequence , [string] : List , [string] : Iterable , [string] : Iterator , [string] : AbstractSet , [string] : MutableSet , [string] : Mapping , [string] : MutableMapping , [string] : Tuple , [string] : KeysView , [string] : ItemsView , [string] : ValuesView , [string] : Dict , } [EOL] return dct [ typing_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import copy [EOL] from itertools import chain [EOL] from contextlib import contextmanager [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] def deep_ast_copy ( obj ) : [EOL] [docstring] [EOL] [comment] [EOL] new_obj = copy . copy ( obj ) [EOL] [EOL] [comment] [EOL] new_children = [ ] [EOL] for child in obj . children : [EOL] if isinstance ( child , tree . Leaf ) : [EOL] new_child = copy . copy ( child ) [EOL] new_child . parent = new_obj [EOL] else : [EOL] new_child = deep_ast_copy ( child ) [EOL] new_child . parent = new_obj [EOL] new_children . append ( new_child ) [EOL] new_obj . children = new_children [EOL] [EOL] return new_obj [EOL] [EOL] [EOL] def evaluate_call_of_leaf ( context , leaf , cut_own_trailer = False ) : [EOL] [docstring] [EOL] trailer = leaf . parent [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if trailer . type != [string] or leaf not in ( trailer . children [ [number] ] , trailer . children [ - [number] ] ) : [EOL] if trailer . type == [string] : [EOL] return context . eval_node ( trailer ) [EOL] return context . eval_node ( leaf ) [EOL] [EOL] power = trailer . parent [EOL] index = power . children . index ( trailer ) [EOL] if cut_own_trailer : [EOL] cut = index [EOL] else : [EOL] cut = index + [number] [EOL] [EOL] if power . type == [string] : [EOL] start = index [EOL] while True : [EOL] start -= [number] [EOL] base = power . children [ start ] [EOL] if base . type != [string] : [EOL] break [EOL] trailers = power . children [ start + [number] : index + [number] ] [EOL] else : [EOL] base = power . children [ [number] ] [EOL] trailers = power . children [ [number] : cut ] [EOL] [EOL] values = context . eval_node ( base ) [EOL] for trailer in trailers : [EOL] values = context . eval_trailer ( values , trailer ) [EOL] return values [EOL] [EOL] [EOL] def call_of_leaf ( leaf ) : [EOL] [docstring] [EOL] [comment] [EOL] trailer = leaf . parent [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if trailer . type != [string] or leaf not in ( trailer . children [ [number] ] , trailer . children [ - [number] ] ) : [EOL] if trailer . type == [string] : [EOL] return trailer [EOL] return leaf [EOL] [EOL] power = trailer . parent [EOL] index = power . children . index ( trailer ) [EOL] [EOL] new_power = copy . copy ( power ) [EOL] new_power . children = list ( new_power . children ) [EOL] new_power . children [ index + [number] : ] = [ ] [EOL] [EOL] if power . type == [string] : [EOL] start = index [EOL] while True : [EOL] start -= [number] [EOL] if power . children [ start ] . type != [string] : [EOL] break [EOL] transformed = tree . Node ( [string] , power . children [ start : ] ) [EOL] transformed . parent = power . parent [EOL] return transformed [EOL] [EOL] return power [EOL] [EOL] [EOL] def get_names_of_node ( node ) : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] if node . type == [string] : [EOL] return [ node ] [EOL] else : [EOL] return [ ] [EOL] else : [EOL] return list ( chain . from_iterable ( get_names_of_node ( c ) for c in children ) ) [EOL] [EOL] [EOL] def get_module_names ( module , all_scopes ) : [EOL] [docstring] [EOL] names = chain . from_iterable ( module . get_used_names ( ) . values ( ) ) [EOL] if not all_scopes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] names = [ n for n in names if get_parent_scope ( n ) . parent in ( module , None ) ] [EOL] return names [EOL] [EOL] [EOL] @ contextmanager def predefine_names ( context , flow_scope , dct ) : [EOL] predefined = context . predefined_names [EOL] if flow_scope in predefined : [EOL] raise NotImplementedError ( [string] ) [EOL] predefined [ flow_scope ] = dct [EOL] try : [EOL] yield [EOL] finally : [EOL] del predefined [ flow_scope ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from jedi . _compatibility import Python3Method [EOL] from jedi . common import unite [EOL] from jedi . parser . python . tree import ExprStmt , CompFor [EOL] from jedi . parser_utils import clean_scope_docstring , get_doc_with_call_signature [EOL] [EOL] [EOL] class Context ( object ) : [EOL] api_type = None [EOL] [docstring] [EOL] predefined_names = { } [EOL] tree_node = None [EOL] [EOL] def __init__ ( self , evaluator , parent_context = None ) : [EOL] self . evaluator = evaluator [EOL] self . parent_context = parent_context [EOL] [EOL] def get_root_context ( self ) : [EOL] context = self [EOL] while True : [EOL] if context . parent_context is None : [EOL] return context [EOL] context = context . parent_context [EOL] [EOL] def execute ( self , arguments ) : [EOL] return self . evaluator . execute ( self , arguments ) [EOL] [EOL] def execute_evaluated ( self , * value_list ) : [EOL] [docstring] [EOL] from jedi . evaluate . param import ValuesArguments [EOL] arguments = ValuesArguments ( [ [ value ] for value in value_list ] ) [EOL] return self . execute ( arguments ) [EOL] [EOL] def eval_node ( self , node ) : [EOL] return self . evaluator . eval_element ( self , node ) [EOL] [EOL] def eval_stmt ( self , stmt , seek_name = None ) : [EOL] return self . evaluator . eval_statement ( self , stmt , seek_name ) [EOL] [EOL] def eval_trailer ( self , types , trailer ) : [EOL] return self . evaluator . eval_trailer ( self , types , trailer ) [EOL] [EOL] @ Python3Method def py__getattribute__ ( self , name_or_str , name_context = None , position = None , search_global = False , is_goto = False ) : [EOL] if name_context is None : [EOL] name_context = self [EOL] return self . evaluator . find_types ( self , name_or_str , name_context , position , search_global , is_goto ) [EOL] [EOL] def create_context ( self , node , node_is_context = False , node_is_object = False ) : [EOL] return self . evaluator . create_context ( self , node , node_is_context , node_is_object ) [EOL] [EOL] def is_class ( self ) : [EOL] return False [EOL] [EOL] def py__bool__ ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def py__doc__ ( self , include_call_signature = False ) : [EOL] try : [EOL] self . tree_node . get_doc_node [EOL] except AttributeError : [EOL] return [string] [EOL] else : [EOL] if include_call_signature : [EOL] return get_doc_with_call_signature ( self . tree_node ) [EOL] else : [EOL] return clean_scope_docstring ( self . tree_node ) [EOL] return None [EOL] [EOL] [EOL] class TreeContext ( Context ) : [EOL] def __init__ ( self , evaluator , parent_context = None ) : [EOL] super ( TreeContext , self ) . __init__ ( evaluator , parent_context ) [EOL] self . predefined_names = { } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . tree_node ) [EOL] [EOL] [EOL] class AbstractLazyContext ( object ) : [EOL] def __init__ ( self , data ) : [EOL] self . data = data [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . data ) [EOL] [EOL] def infer ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class LazyKnownContext ( AbstractLazyContext ) : [EOL] [docstring] [EOL] def infer ( self ) : [EOL] return set ( [ self . data ] ) [EOL] [EOL] [EOL] class LazyKnownContexts ( AbstractLazyContext ) : [EOL] [docstring] [EOL] def infer ( self ) : [EOL] return self . data [EOL] [EOL] [EOL] class LazyUnknownContext ( AbstractLazyContext ) : [EOL] def __init__ ( self ) : [EOL] super ( LazyUnknownContext , self ) . __init__ ( None ) [EOL] [EOL] def infer ( self ) : [EOL] return set ( ) [EOL] [EOL] [EOL] class LazyTreeContext ( AbstractLazyContext ) : [EOL] def __init__ ( self , context , node ) : [EOL] super ( LazyTreeContext , self ) . __init__ ( node ) [EOL] self . _context = context [EOL] [comment] [EOL] [comment] [EOL] self . _predefined_names = dict ( context . predefined_names ) [EOL] [EOL] def infer ( self ) : [EOL] old , self . _context . predefined_names = self . _context . predefined_names , self . _predefined_names [EOL] try : [EOL] return self . _context . eval_node ( self . data ) [EOL] finally : [EOL] self . _context . predefined_names = old [EOL] [EOL] [EOL] def get_merged_lazy_context ( lazy_contexts ) : [EOL] if len ( lazy_contexts ) > [number] : [EOL] return MergedLazyContexts ( lazy_contexts ) [EOL] else : [EOL] return lazy_contexts [ [number] ] [EOL] [EOL] [EOL] class MergedLazyContexts ( AbstractLazyContext ) : [EOL] [docstring] [EOL] def infer ( self ) : [EOL] return unite ( l . infer ( ) for l in self . data ) [EOL] [EOL] [EOL] class ContextualizedNode ( object ) : [EOL] def __init__ ( self , context , node ) : [EOL] self . context = context [EOL] self . _node = node [EOL] [EOL] def get_root_context ( self ) : [EOL] return self . context . get_root_context ( ) [EOL] [EOL] def infer ( self ) : [EOL] return self . context . eval_node ( self . _node ) [EOL] [EOL] [EOL] class ContextualizedName ( ContextualizedNode ) : [EOL] [comment] [EOL] @ property def name ( self ) : [EOL] return self . _node [EOL] [EOL] def assignment_indexes ( self ) : [EOL] [docstring] [EOL] indexes = [ ] [EOL] node = self . _node . parent [EOL] compare = self . _node [EOL] while node is not None : [EOL] if node . type in ( [string] , [string] , [string] ) : [EOL] for i , child in enumerate ( node . children ) : [EOL] if child == compare : [EOL] indexes . insert ( [number] , ( int ( i / [number] ) , node ) ) [EOL] break [EOL] else : [EOL] raise LookupError ( [string] ) [EOL] elif isinstance ( node , ( ExprStmt , CompFor ) ) : [EOL] break [EOL] [EOL] compare = node [EOL] node = node . parent [EOL] return indexes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import List , Any , Set [EOL] import typing [EOL] from jedi . parser_utils import get_flow_branch_keyword , is_scope , get_parent_scope [EOL] [EOL] [EOL] class Status ( object ) : [EOL] lookup_table = { } [EOL] [EOL] def __init__ ( self , value , name ) : [EOL] self . _value = value [EOL] self . _name = name [EOL] Status . lookup_table [ value ] = self [EOL] [EOL] def invert ( self ) : [EOL] if self is REACHABLE : [EOL] return UNREACHABLE [EOL] elif self is UNREACHABLE : [EOL] return REACHABLE [EOL] else : [EOL] return UNSURE [EOL] [EOL] def __and__ ( self , other ) : [EOL] if UNSURE in ( self , other ) : [EOL] return UNSURE [EOL] else : [EOL] return REACHABLE if self . _value and other . _value else UNREACHABLE [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . _name ) [EOL] [EOL] [EOL] REACHABLE = Status ( True , [string] ) [EOL] UNREACHABLE = Status ( False , [string] ) [EOL] UNSURE = Status ( None , [string] ) [EOL] [EOL] [EOL] def _get_flow_scopes ( node ) : [EOL] while True : [EOL] node = get_parent_scope ( node , include_flows = True ) [EOL] if node is None or is_scope ( node ) : [EOL] return [EOL] yield node [EOL] [EOL] [EOL] def reachability_check ( context , context_scope , node , origin_scope = None ) : [EOL] first_flow_scope = get_parent_scope ( node , include_flows = True ) [EOL] if origin_scope is not None : [EOL] origin_flow_scopes = list ( _get_flow_scopes ( origin_scope ) ) [EOL] node_flow_scopes = list ( _get_flow_scopes ( node ) ) [EOL] [EOL] branch_matches = True [EOL] for flow_scope in origin_flow_scopes : [EOL] if flow_scope in node_flow_scopes : [EOL] node_keyword = get_flow_branch_keyword ( flow_scope , node ) [EOL] origin_keyword = get_flow_branch_keyword ( flow_scope , origin_scope ) [EOL] branch_matches = node_keyword == origin_keyword [EOL] if flow_scope . type == [string] : [EOL] if not branch_matches : [EOL] return UNREACHABLE [EOL] elif flow_scope . type == [string] : [EOL] if not branch_matches and origin_keyword == [string] \ [EOL] and node_keyword == [string] : [EOL] return UNREACHABLE [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while origin_scope is not None : [EOL] if first_flow_scope == origin_scope and branch_matches : [EOL] return REACHABLE [EOL] origin_scope = origin_scope . parent [EOL] [EOL] return _break_check ( context , context_scope , first_flow_scope , node ) [EOL] [EOL] [EOL] def _break_check ( context , context_scope , flow_scope , node ) : [EOL] reachable = REACHABLE [EOL] if flow_scope . type == [string] : [EOL] if flow_scope . is_node_after_else ( node ) : [EOL] for check_node in flow_scope . get_test_nodes ( ) : [EOL] reachable = _check_if ( context , check_node ) [EOL] if reachable in ( REACHABLE , UNSURE ) : [EOL] break [EOL] reachable = reachable . invert ( ) [EOL] else : [EOL] flow_node = flow_scope . get_corresponding_test_node ( node ) [EOL] if flow_node is not None : [EOL] reachable = _check_if ( context , flow_node ) [EOL] elif flow_scope . type in ( [string] , [string] ) : [EOL] return UNSURE [EOL] [EOL] [comment] [EOL] if reachable in ( UNREACHABLE , UNSURE ) : [EOL] return reachable [EOL] [EOL] if context_scope != flow_scope and context_scope != flow_scope . parent : [EOL] flow_scope = get_parent_scope ( flow_scope , include_flows = True ) [EOL] return reachable & _break_check ( context , context_scope , flow_scope , node ) [EOL] else : [EOL] return reachable [EOL] [EOL] [EOL] def _check_if ( context , node ) : [EOL] types = context . eval_node ( node ) [EOL] values = set ( x . py__bool__ ( ) for x in types ) [EOL] if len ( values ) == [number] : [EOL] return Status . lookup_table [ values . pop ( ) ] [EOL] else : [EOL] return UNSURE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Dict , Any [EOL] import typing [EOL] from collections import defaultdict [EOL] [EOL] from jedi . _compatibility import zip_longest [EOL] from jedi import debug [EOL] from jedi import common [EOL] from jedi . parser . python import tree [EOL] from jedi . evaluate import iterable [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate import context [EOL] from jedi . evaluate import docstrings [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate . filters import ParamName [EOL] [EOL] [EOL] def add_argument_issue ( parent_context , error_name , lazy_context , message ) : [EOL] if isinstance ( lazy_context , context . LazyTreeContext ) : [EOL] node = lazy_context . data [EOL] if node . parent . type == [string] : [EOL] node = node . parent [EOL] analysis . add ( parent_context , error_name , node , message ) [EOL] [EOL] [EOL] def try_iter_content ( types , depth = [number] ) : [EOL] [docstring] [EOL] if depth > [number] : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] for typ in types : [EOL] try : [EOL] f = typ . py__iter__ [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] for lazy_context in f ( ) : [EOL] try_iter_content ( lazy_context . infer ( ) , depth + [number] ) [EOL] [EOL] [EOL] class AbstractArguments ( ) : [EOL] context = None [EOL] [EOL] def eval_argument_clinic ( self , parameters ) : [EOL] [docstring] [EOL] iterator = self . unpack ( ) [EOL] for i , ( name , optional , allow_kwargs ) in enumerate ( parameters ) : [EOL] key , argument = next ( iterator , ( None , None ) ) [EOL] if key is not None : [EOL] raise NotImplementedError [EOL] if argument is None and not optional : [EOL] debug . warning ( [string] , name , len ( parameters ) , i ) [EOL] raise ValueError [EOL] values = set ( ) if argument is None else argument . infer ( ) [EOL] [EOL] if not values and not optional : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] debug . warning ( [string] , name ) [EOL] raise ValueError [EOL] yield values [EOL] [EOL] def eval_all ( self , funcdef = None ) : [EOL] [docstring] [EOL] for key , lazy_context in self . unpack ( ) : [EOL] types = lazy_context . infer ( ) [EOL] try_iter_content ( types ) [EOL] [EOL] [EOL] class TreeArguments ( AbstractArguments ) : [EOL] def __init__ ( self , evaluator , context , argument_node , trailer = None ) : [EOL] [docstring] [EOL] self . argument_node = argument_node [EOL] self . context = context [EOL] self . _evaluator = evaluator [EOL] self . trailer = trailer [comment] [EOL] [EOL] def _split ( self ) : [EOL] if isinstance ( self . argument_node , ( tuple , list ) ) : [EOL] for el in self . argument_node : [EOL] yield [number] , el [EOL] else : [EOL] if not ( self . argument_node . type == [string] or ( ( self . argument_node . type == [string] ) and self . argument_node . children [ [number] ] in ( [string] , [string] ) ) ) : [EOL] yield [number] , self . argument_node [EOL] return [EOL] [EOL] iterator = iter ( self . argument_node . children ) [EOL] for child in iterator : [EOL] if child == [string] : [EOL] continue [EOL] elif child in ( [string] , [string] ) : [EOL] yield len ( child . value ) , next ( iterator ) [EOL] elif child . type == [string] and child . children [ [number] ] in ( [string] , [string] ) : [EOL] assert len ( child . children ) == [number] [EOL] yield len ( child . children [ [number] ] . value ) , child . children [ [number] ] [EOL] else : [EOL] yield [number] , child [EOL] [EOL] def unpack ( self , funcdef = None ) : [EOL] named_args = [ ] [EOL] for star_count , el in self . _split ( ) : [EOL] if star_count == [number] : [EOL] arrays = self . context . eval_node ( el ) [EOL] iterators = [ _iterate_star_args ( self . context , a , el , funcdef ) for a in arrays ] [EOL] iterators = list ( iterators ) [EOL] for values in list ( zip_longest ( * iterators ) ) : [EOL] [comment] [EOL] [comment] [EOL] yield None , context . get_merged_lazy_context ( [ v for v in values if v is not None ] ) [EOL] elif star_count == [number] : [EOL] arrays = self . _evaluator . eval_element ( self . context , el ) [EOL] for dct in arrays : [EOL] for key , values in _star_star_dict ( self . context , dct , el , funcdef ) : [EOL] yield key , values [EOL] else : [EOL] if el . type == [string] : [EOL] c = el . children [EOL] if len ( c ) == [number] : [comment] [EOL] named_args . append ( ( c [ [number] ] . value , context . LazyTreeContext ( self . context , c [ [number] ] ) , ) ) [EOL] else : [comment] [EOL] [comment] [EOL] comp = iterable . GeneratorComprehension ( self . _evaluator , self . context , self . argument_node . parent ) [EOL] yield None , context . LazyKnownContext ( comp ) [EOL] else : [EOL] yield None , context . LazyTreeContext ( self . context , el ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for named_arg in named_args : [EOL] yield named_arg [EOL] [EOL] def as_tree_tuple_objects ( self ) : [EOL] for star_count , argument in self . _split ( ) : [EOL] if argument . type == [string] : [EOL] argument , default = argument . children [ : : [number] ] [EOL] else : [EOL] default = None [EOL] yield argument , default , star_count [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . argument_node ) [EOL] [EOL] def get_calling_nodes ( self ) : [EOL] from jedi . evaluate . dynamic import MergedExecutedParams [EOL] old_arguments_list = [ ] [EOL] arguments = self [EOL] [EOL] while arguments not in old_arguments_list : [EOL] if not isinstance ( arguments , TreeArguments ) : [EOL] break [EOL] [EOL] old_arguments_list . append ( arguments ) [EOL] for name , default , star_count in reversed ( list ( arguments . as_tree_tuple_objects ( ) ) ) : [EOL] if not star_count or not isinstance ( name , tree . Name ) : [EOL] continue [EOL] [EOL] names = self . _evaluator . goto ( arguments . context , name ) [EOL] if len ( names ) != [number] : [EOL] break [EOL] if not isinstance ( names [ [number] ] , ParamName ) : [EOL] break [EOL] param = names [ [number] ] . get_param ( ) [EOL] if isinstance ( param , MergedExecutedParams ) : [EOL] [comment] [EOL] return [ ] [EOL] if not isinstance ( param , ExecutedParam ) : [EOL] break [EOL] if param . var_args is None : [EOL] break [EOL] arguments = param . var_args [EOL] break [EOL] [EOL] return [ arguments . argument_node or arguments . trailer ] [EOL] [EOL] [EOL] class ValuesArguments ( AbstractArguments ) : [EOL] def __init__ ( self , values_list ) : [EOL] self . _values_list = values_list [EOL] [EOL] def unpack ( self , funcdef = None ) : [EOL] for values in self . _values_list : [EOL] yield None , context . LazyKnownContexts ( values ) [EOL] [EOL] def get_calling_nodes ( self ) : [EOL] return [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . _values_list ) [EOL] [EOL] [EOL] class ExecutedParam ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , execution_context , param_node , lazy_context ) : [EOL] self . _execution_context = execution_context [EOL] self . _param_node = param_node [EOL] self . _lazy_context = lazy_context [EOL] self . string_name = param_node . name . value [EOL] [EOL] def infer ( self ) : [EOL] pep0484_hints = pep0484 . infer_param ( self . _execution_context , self . _param_node ) [EOL] doc_params = docstrings . infer_param ( self . _execution_context , self . _param_node ) [EOL] if pep0484_hints or doc_params : [EOL] return list ( set ( pep0484_hints ) | set ( doc_params ) ) [EOL] [EOL] return self . _lazy_context . infer ( ) [EOL] [EOL] @ property def var_args ( self ) : [EOL] return self . _execution_context . var_args [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . string_name ) [EOL] [EOL] [EOL] def get_params ( execution_context , var_args ) : [EOL] result_params = [ ] [EOL] param_dict = { } [EOL] funcdef = execution_context . tree_node [EOL] parent_context = execution_context . parent_context [EOL] [EOL] for param in funcdef . params : [EOL] param_dict [ param . name . value ] = param [EOL] unpacked_va = list ( var_args . unpack ( funcdef ) ) [EOL] var_arg_iterator = common . PushBackIterator ( iter ( unpacked_va ) ) [EOL] [EOL] non_matching_keys = defaultdict ( lambda : [ ] ) [EOL] keys_used = { } [EOL] keys_only = False [EOL] had_multiple_value_error = False [EOL] for param in funcdef . params : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] key , argument = next ( var_arg_iterator , ( None , None ) ) [EOL] while key is not None : [EOL] keys_only = True [EOL] try : [EOL] key_param = param_dict [ key ] [EOL] except KeyError : [EOL] non_matching_keys [ key ] = argument [EOL] else : [EOL] if key in keys_used : [EOL] had_multiple_value_error = True [EOL] m = ( [string] % ( funcdef . name , key ) ) [EOL] for node in var_args . get_calling_nodes ( ) : [EOL] analysis . add ( parent_context , [string] , node , message = m ) [EOL] else : [EOL] keys_used [ key ] = ExecutedParam ( execution_context , key_param , argument ) [EOL] key , argument = next ( var_arg_iterator , ( None , None ) ) [EOL] [EOL] try : [EOL] result_params . append ( keys_used [ param . name . value ] ) [EOL] continue [EOL] except KeyError : [EOL] pass [EOL] [EOL] if param . star_count == [number] : [EOL] [comment] [EOL] lazy_context_list = [ ] [EOL] if argument is not None : [EOL] lazy_context_list . append ( argument ) [EOL] for key , argument in var_arg_iterator : [EOL] [comment] [EOL] if key : [EOL] var_arg_iterator . push_back ( ( key , argument ) ) [EOL] break [EOL] lazy_context_list . append ( argument ) [EOL] seq = iterable . FakeSequence ( execution_context . evaluator , [string] , lazy_context_list ) [EOL] result_arg = context . LazyKnownContext ( seq ) [EOL] elif param . star_count == [number] : [EOL] [comment] [EOL] dct = iterable . FakeDict ( execution_context . evaluator , dict ( non_matching_keys ) ) [EOL] result_arg = context . LazyKnownContext ( dct ) [EOL] non_matching_keys = { } [EOL] else : [EOL] [comment] [EOL] if argument is None : [EOL] [comment] [EOL] if param . default is None : [EOL] result_arg = context . LazyUnknownContext ( ) [EOL] if not keys_only : [EOL] for node in var_args . get_calling_nodes ( ) : [EOL] m = _error_argument_count ( funcdef , len ( unpacked_va ) ) [EOL] analysis . add ( parent_context , [string] , node , message = m ) [EOL] else : [EOL] result_arg = context . LazyTreeContext ( parent_context , param . default ) [EOL] else : [EOL] result_arg = argument [EOL] [EOL] result_params . append ( ExecutedParam ( execution_context , param , result_arg ) ) [EOL] if not isinstance ( result_arg , context . LazyUnknownContext ) : [EOL] keys_used [ param . name . value ] = result_params [ - [number] ] [EOL] [EOL] if keys_only : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k in set ( param_dict ) - set ( keys_used ) : [EOL] param = param_dict [ k ] [EOL] [EOL] if not ( non_matching_keys or had_multiple_value_error or param . star_count or param . default ) : [EOL] [comment] [EOL] for node in var_args . get_calling_nodes ( ) : [EOL] m = _error_argument_count ( funcdef , len ( unpacked_va ) ) [EOL] analysis . add ( parent_context , [string] , node , message = m ) [EOL] [EOL] for key , lazy_context in non_matching_keys . items ( ) : [EOL] m = [string] % ( funcdef . name , key ) [EOL] add_argument_issue ( parent_context , [string] , lazy_context , message = m ) [EOL] [EOL] remaining_arguments = list ( var_arg_iterator ) [EOL] if remaining_arguments : [EOL] m = _error_argument_count ( funcdef , len ( unpacked_va ) ) [EOL] [comment] [EOL] [comment] [EOL] first_key , lazy_context = remaining_arguments [ [number] ] [EOL] if var_args . get_calling_nodes ( ) : [EOL] [comment] [EOL] add_argument_issue ( parent_context , [string] , lazy_context , message = m ) [EOL] return result_params [EOL] [EOL] [EOL] def _iterate_star_args ( context , array , input_node , funcdef = None ) : [EOL] try : [EOL] iter_ = array . py__iter__ [EOL] except AttributeError : [EOL] if funcdef is not None : [EOL] [comment] [EOL] m = [string] % ( funcdef . name . value , array ) [EOL] analysis . add ( context , [string] , input_node , message = m ) [EOL] else : [EOL] for lazy_context in iter_ ( ) : [EOL] yield lazy_context [EOL] [EOL] [EOL] def _star_star_dict ( context , array , input_node , funcdef ) : [EOL] from jedi . evaluate . instance import CompiledInstance [EOL] if isinstance ( array , CompiledInstance ) and array . name . string_name == [string] : [EOL] [comment] [EOL] [comment] [EOL] return { } [EOL] elif isinstance ( array , iterable . AbstractSequence ) and array . array_type == [string] : [EOL] return array . exact_key_items ( ) [EOL] else : [EOL] if funcdef is not None : [EOL] m = [string] % ( funcdef . name . value , array ) [EOL] analysis . add ( context , [string] , input_node , message = m ) [EOL] return { } [EOL] [EOL] [EOL] def _error_argument_count ( funcdef , actual_count ) : [EOL] default_arguments = sum ( [number] for p in funcdef . params if p . default or p . star_count ) [EOL] [EOL] if default_arguments == [number] : [EOL] before = [string] [EOL] else : [EOL] before = [string] % ( len ( funcdef . params ) - default_arguments ) [EOL] return ( [string] % ( funcdef . name , before , len ( funcdef . params ) , actual_count ) ) [EOL] [EOL] [EOL] def create_default_param ( execution_context , param ) : [EOL] if param . star_count == [number] : [EOL] result_arg = context . LazyKnownContext ( iterable . FakeSequence ( execution_context . evaluator , [string] , [ ] ) ) [EOL] elif param . star_count == [number] : [EOL] result_arg = context . LazyKnownContext ( iterable . FakeDict ( execution_context . evaluator , { } ) ) [EOL] elif param . default is None : [EOL] result_arg = context . LazyUnknownContext ( ) [EOL] else : [EOL] result_arg = context . LazyTreeContext ( execution_context . parent_context , param . default ) [EOL] return ExecutedParam ( execution_context , param , result_arg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , Tuple , Iterator [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi import settings [EOL] from jedi import debug [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate . param import TreeArguments , create_default_param [EOL] from jedi . common import to_list , unite [EOL] from jedi . parser_utils import get_parent_scope [EOL] [EOL] [EOL] MAX_PARAM_SEARCHES = [number] [EOL] [EOL] [EOL] class ParamListener ( object ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . param_possibilities = [ ] [EOL] [EOL] def execute ( self , params ) : [EOL] self . param_possibilities += params [EOL] [EOL] [EOL] class MergedExecutedParams ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , executed_params ) : [EOL] self . _executed_params = executed_params [EOL] [EOL] def infer ( self ) : [EOL] return unite ( p . infer ( ) for p in self . _executed_params ) [EOL] [EOL] [EOL] @ debug . increase_indent def search_params ( evaluator , execution_context , funcdef ) : [EOL] [docstring] [EOL] if not settings . dynamic_params : [EOL] return set ( ) [EOL] [EOL] evaluator . dynamic_params_depth += [number] [EOL] try : [EOL] debug . dbg ( [string] , funcdef . name . value , color = [string] ) [EOL] module_context = execution_context . get_root_context ( ) [EOL] function_executions = _search_function_executions ( evaluator , module_context , funcdef ) [EOL] if function_executions : [EOL] zipped_params = zip ( * list ( function_execution . get_params ( ) for function_execution in function_executions ) ) [EOL] params = [ MergedExecutedParams ( executed_params ) for executed_params in zipped_params ] [EOL] [comment] [EOL] else : [EOL] params = [ create_default_param ( execution_context , p ) for p in funcdef . params ] [EOL] debug . dbg ( [string] , color = [string] ) [EOL] return params [EOL] finally : [EOL] evaluator . dynamic_params_depth -= [number] [EOL] [EOL] [EOL] @ memoize_default ( [ ] , evaluator_is_first_arg = True ) @ to_list def _search_function_executions ( evaluator , module_context , funcdef ) : [EOL] [docstring] [EOL] from jedi . evaluate import representation as er [EOL] [EOL] func_string_name = funcdef . name . value [EOL] compare_node = funcdef [EOL] if func_string_name == [string] : [EOL] cls = get_parent_scope ( funcdef ) [EOL] if isinstance ( cls , tree . Class ) : [EOL] func_string_name = cls . name . value [EOL] compare_node = cls [EOL] [EOL] found_executions = False [EOL] i = [number] [EOL] for for_mod_context in imports . get_modules_containing_name ( evaluator , [ module_context ] , func_string_name ) : [EOL] if not isinstance ( module_context , er . ModuleContext ) : [EOL] return [EOL] for name , trailer in _get_possible_nodes ( for_mod_context , func_string_name ) : [EOL] i += [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if i * evaluator . dynamic_params_depth > MAX_PARAM_SEARCHES : [EOL] return [EOL] [EOL] random_context = evaluator . create_context ( for_mod_context , name ) [EOL] for function_execution in _check_name_for_execution ( evaluator , random_context , compare_node , name , trailer ) : [EOL] found_executions = True [EOL] yield function_execution [EOL] [EOL] [comment] [EOL] [comment] [EOL] if found_executions : [EOL] return [EOL] [EOL] [EOL] def _get_possible_nodes ( module_context , func_string_name ) : [EOL] try : [EOL] names = module_context . tree_node . get_used_names ( ) [ func_string_name ] [EOL] except KeyError : [EOL] return [EOL] [EOL] for name in names : [EOL] bracket = name . get_next_leaf ( ) [EOL] trailer = bracket . parent [EOL] if trailer . type == [string] and bracket == [string] : [EOL] yield name , trailer [EOL] [EOL] [EOL] def _check_name_for_execution ( evaluator , context , compare_node , name , trailer ) : [EOL] from jedi . evaluate import representation as er , instance [EOL] [EOL] def create_func_excs ( ) : [EOL] arglist = trailer . children [ [number] ] [EOL] if arglist == [string] : [EOL] arglist = ( ) [EOL] args = TreeArguments ( evaluator , context , arglist , trailer ) [EOL] if value_node . type == [string] : [EOL] yield value . get_function_execution ( args ) [EOL] else : [EOL] created_instance = instance . TreeInstance ( evaluator , value . parent_context , value , args ) [EOL] for execution in created_instance . create_init_executions ( ) : [EOL] yield execution [EOL] [EOL] for value in evaluator . goto_definitions ( context , name ) : [EOL] value_node = value . tree_node [EOL] if compare_node == value_node : [EOL] for func_execution in create_func_excs ( ) : [EOL] yield func_execution [EOL] elif isinstance ( value . parent_context , er . FunctionExecutionContext ) and compare_node . type == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] params = value . parent_context . get_params ( ) [EOL] if len ( params ) != [number] : [EOL] continue [EOL] values = params [ [number] ] . infer ( ) [EOL] nodes = [ v . tree_node for v in values ] [EOL] if nodes == [ compare_node ] : [EOL] [comment] [EOL] module_context = context . get_root_context ( ) [EOL] execution_context = next ( create_func_excs ( ) ) [EOL] for name , trailer in _get_possible_nodes ( module_context , params [ [number] ] . string_name ) : [EOL] if value_node . start_pos < name . start_pos < value_node . end_pos : [EOL] random_context = evaluator . create_context ( execution_context , name ) [EOL] iterator = _check_name_for_execution ( evaluator , random_context , compare_node , name , trailer ) [EOL] for function_execution in iterator : [EOL] yield function_execution [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Union , Type , Set , Iterator , Dict , Callable [EOL] import typing [EOL] import operator [EOL] [docstring] [EOL] import operator as op [EOL] [EOL] from jedi . _compatibility import unicode [EOL] from jedi . parser . python import tree [EOL] from jedi import debug [EOL] from jedi . evaluate . compiled import CompiledObject , create , builtin_from_name [EOL] from jedi . evaluate import analysis [EOL] [EOL] [comment] [EOL] COMPARISON_OPERATORS = { [string] : op . eq , [string] : op . ne , [string] : op . is_ , [string] : op . is_not , [string] : op . lt , [string] : op . le , [string] : op . gt , [string] : op . ge , } [EOL] [EOL] [EOL] def literals_to_types ( evaluator , result ) : [EOL] [comment] [EOL] [comment] [EOL] new_result = set ( ) [EOL] for typ in result : [EOL] if is_literal ( typ ) : [EOL] [comment] [EOL] [comment] [EOL] cls = builtin_from_name ( evaluator , typ . name . string_name ) [EOL] new_result |= cls . execute_evaluated ( ) [EOL] else : [EOL] new_result . add ( typ ) [EOL] return new_result [EOL] [EOL] [EOL] def calculate_children ( evaluator , context , children ) : [EOL] [docstring] [EOL] iterator = iter ( children ) [EOL] types = context . eval_node ( next ( iterator ) ) [EOL] for operator in iterator : [EOL] right = next ( iterator ) [EOL] if operator . type == [string] : [comment] [EOL] operator = [string] . join ( c . value for c in operator . children ) [EOL] [EOL] [comment] [EOL] if operator in ( [string] , [string] ) : [EOL] left_bools = set ( [ left . py__bool__ ( ) for left in types ] ) [EOL] if left_bools == set ( [ True ] ) : [EOL] if operator == [string] : [EOL] types = context . eval_node ( right ) [EOL] elif left_bools == set ( [ False ] ) : [EOL] if operator != [string] : [EOL] types = context . eval_node ( right ) [EOL] [comment] [EOL] else : [EOL] types = calculate ( evaluator , context , types , operator , context . eval_node ( right ) ) [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] [EOL] def calculate ( evaluator , context , left_result , operator , right_result ) : [EOL] result = set ( ) [EOL] if not left_result or not right_result : [EOL] [comment] [EOL] result = ( left_result or set ( ) ) | ( right_result or set ( ) ) [EOL] result = literals_to_types ( evaluator , result ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( left_result ) * len ( right_result ) > [number] : [EOL] result = literals_to_types ( evaluator , left_result | right_result ) [EOL] else : [EOL] for left in left_result : [EOL] for right in right_result : [EOL] result |= _element_calculate ( evaluator , context , left , operator , right ) [EOL] return result [EOL] [EOL] [EOL] def factor_calculate ( evaluator , types , operator ) : [EOL] [docstring] [EOL] for typ in types : [EOL] if operator == [string] : [EOL] if _is_number ( typ ) : [EOL] yield create ( evaluator , - typ . obj ) [EOL] elif operator == [string] : [EOL] value = typ . py__bool__ ( ) [EOL] if value is None : [comment] [EOL] return [EOL] yield create ( evaluator , not value ) [EOL] else : [EOL] yield typ [EOL] [EOL] [EOL] def _is_number ( obj ) : [EOL] return isinstance ( obj , CompiledObject ) \ [EOL] and isinstance ( obj . obj , ( int , float ) ) [EOL] [EOL] [EOL] def is_string ( obj ) : [EOL] return isinstance ( obj , CompiledObject ) \ [EOL] and isinstance ( obj . obj , ( str , unicode ) ) [EOL] [EOL] [EOL] def is_literal ( obj ) : [EOL] return _is_number ( obj ) or is_string ( obj ) [EOL] [EOL] [EOL] def _is_tuple ( obj ) : [EOL] from jedi . evaluate import iterable [EOL] return isinstance ( obj , iterable . AbstractSequence ) and obj . array_type == [string] [EOL] [EOL] [EOL] def _is_list ( obj ) : [EOL] from jedi . evaluate import iterable [EOL] return isinstance ( obj , iterable . AbstractSequence ) and obj . array_type == [string] [EOL] [EOL] [EOL] def _element_calculate ( evaluator , context , left , operator , right ) : [EOL] from jedi . evaluate import iterable , instance [EOL] l_is_num = _is_number ( left ) [EOL] r_is_num = _is_number ( right ) [EOL] if operator == [string] : [EOL] [comment] [EOL] if isinstance ( left , iterable . AbstractSequence ) or is_string ( left ) : [EOL] return set ( [ left ] ) [EOL] elif isinstance ( right , iterable . AbstractSequence ) or is_string ( right ) : [EOL] return set ( [ right ] ) [EOL] elif operator == [string] : [EOL] if l_is_num and r_is_num or is_string ( left ) and is_string ( right ) : [EOL] return set ( [ create ( evaluator , left . obj + right . obj ) ] ) [EOL] elif _is_tuple ( left ) and _is_tuple ( right ) or _is_list ( left ) and _is_list ( right ) : [EOL] return set ( [ iterable . MergedArray ( evaluator , ( left , right ) ) ] ) [EOL] elif operator == [string] : [EOL] if l_is_num and r_is_num : [EOL] return set ( [ create ( evaluator , left . obj - right . obj ) ] ) [EOL] elif operator == [string] : [EOL] [comment] [EOL] [comment] [EOL] return set ( [ left ] ) [EOL] elif operator in COMPARISON_OPERATORS : [EOL] operation = COMPARISON_OPERATORS [ operator ] [EOL] if isinstance ( left , CompiledObject ) and isinstance ( right , CompiledObject ) : [EOL] [comment] [EOL] left = left . obj [EOL] right = right . obj [EOL] [EOL] try : [EOL] result = operation ( left , right ) [EOL] except TypeError : [EOL] [comment] [EOL] return set ( [ create ( evaluator , True ) , create ( evaluator , False ) ] ) [EOL] else : [EOL] return set ( [ create ( evaluator , result ) ] ) [EOL] elif operator == [string] : [EOL] return set ( ) [EOL] [EOL] def check ( obj ) : [EOL] [docstring] [EOL] return isinstance ( obj , instance . CompiledInstance ) and obj . name . string_name in ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] if operator in ( [string] , [string] ) and l_is_num != r_is_num \ [EOL] and not ( check ( left ) or check ( right ) ) : [EOL] message = [string] [EOL] analysis . add ( context , [string] , operator , message % ( left , right ) ) [EOL] [EOL] return set ( [ left , right ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match , List , Set , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import itertools [EOL] [EOL] import os [EOL] from jedi . parser import ParserSyntaxError [EOL] from jedi . parser . python import parse , tree [EOL] from jedi . common import unite [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate . context import LazyTreeContext [EOL] from jedi import debug [EOL] from jedi import _compatibility [EOL] from jedi import parser_utils [EOL] import re [EOL] [EOL] [EOL] def _evaluate_for_annotation ( context , annotation , index = None ) : [EOL] [docstring] [EOL] if annotation is not None : [EOL] definitions = context . eval_node ( _fix_forward_reference ( context , annotation ) ) [EOL] if index is not None : [EOL] definitions = list ( itertools . chain . from_iterable ( definition . py__getitem__ ( index ) for definition in definitions if definition . array_type == [string] and len ( list ( definition . py__iter__ ( ) ) ) >= index ) ) [EOL] return unite ( d . execute_evaluated ( ) for d in definitions ) [EOL] else : [EOL] return set ( ) [EOL] [EOL] [EOL] def _fix_forward_reference ( context , node ) : [EOL] evaled_nodes = context . eval_node ( node ) [EOL] if len ( evaled_nodes ) != [number] : [EOL] debug . warning ( [string] [string] % ( node , evaled_nodes ) ) [EOL] return node [EOL] evaled_node = list ( evaled_nodes ) [ [number] ] [EOL] if isinstance ( evaled_node , compiled . CompiledObject ) and isinstance ( evaled_node . obj , str ) : [EOL] try : [EOL] new_node = parse ( _compatibility . unicode ( evaled_node . obj ) , start_symbol = [string] , error_recovery = False ) [EOL] except ParserSyntaxError : [EOL] debug . warning ( [string] % evaled_node . obj ) [EOL] return node [EOL] else : [EOL] module = node . get_root_node ( ) [EOL] parser_utils . move ( new_node , module . end_pos [ [number] ] ) [EOL] new_node . parent = context . tree_node [EOL] return new_node [EOL] else : [EOL] return node [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_param ( execution_context , param ) : [EOL] annotation = param . annotation [EOL] module_context = execution_context . get_root_context ( ) [EOL] return _evaluate_for_annotation ( module_context , annotation ) [EOL] [EOL] [EOL] def py__annotations__ ( funcdef ) : [EOL] return_annotation = funcdef . annotation [EOL] if return_annotation : [EOL] dct = { [string] : return_annotation } [EOL] else : [EOL] dct = { } [EOL] for function_param in funcdef . params : [EOL] param_annotation = function_param . annotation [EOL] if param_annotation is not None : [EOL] dct [ function_param . name . value ] = param_annotation [EOL] return dct [EOL] [EOL] [EOL] @ memoize_default ( ) def infer_return_types ( function_context ) : [EOL] annotation = py__annotations__ ( function_context . tree_node ) . get ( [string] , None ) [EOL] module_context = function_context . get_root_context ( ) [EOL] return _evaluate_for_annotation ( module_context , annotation ) [EOL] [EOL] [EOL] _typing_module = None [EOL] [EOL] [EOL] def _get_typing_replacement_module ( ) : [EOL] [docstring] [EOL] global _typing_module [EOL] if _typing_module is None : [EOL] typing_path = os . path . abspath ( os . path . join ( __file__ , [string] ) ) [EOL] with open ( typing_path ) as f : [EOL] code = _compatibility . unicode ( f . read ( ) ) [EOL] _typing_module = parse ( code ) [EOL] return _typing_module [EOL] [EOL] [EOL] def py__getitem__ ( context , typ , node ) : [EOL] if not typ . get_root_context ( ) . name . string_name == [string] : [EOL] return None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if node . type == [string] : [EOL] nodes = node . children [ : : [number] ] [comment] [EOL] else : [EOL] nodes = [ node ] [EOL] del node [EOL] [EOL] nodes = [ _fix_forward_reference ( context , node ) for node in nodes ] [EOL] type_name = typ . name . string_name [EOL] [EOL] [comment] [EOL] if type_name in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return unite ( context . eval_node ( node ) for node in nodes ) [EOL] if type_name in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return context . eval_node ( nodes [ [number] ] ) [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] typing = ModuleContext ( context . evaluator , module_node = _get_typing_replacement_module ( ) , path = None ) [EOL] factories = typing . py__getattribute__ ( [string] ) [EOL] assert len ( factories ) == [number] [EOL] factory = list ( factories ) [ [number] ] [EOL] assert factory [EOL] function_body_nodes = factory . tree_node . children [ [number] ] . children [EOL] valid_classnames = set ( child . name . value for child in function_body_nodes if isinstance ( child , tree . Class ) ) [EOL] if type_name not in valid_classnames : [EOL] return None [EOL] compiled_classname = compiled . create ( context . evaluator , type_name ) [EOL] [EOL] from jedi . evaluate . iterable import FakeSequence [EOL] args = FakeSequence ( context . evaluator , [string] , [ LazyTreeContext ( context , n ) for n in nodes ] ) [EOL] [EOL] result = factory . execute_evaluated ( compiled_classname , args ) [EOL] return result [EOL] [EOL] [EOL] def find_type_from_comment_hint_for ( context , node , name ) : [EOL] return _find_type_from_comment_hint ( context , node , node . children [ [number] ] , name ) [EOL] [EOL] [EOL] def find_type_from_comment_hint_with ( context , node , name ) : [EOL] assert len ( node . children [ [number] ] . children ) == [number] , [string] [EOL] varlist = node . children [ [number] ] . children [ [number] ] [EOL] return _find_type_from_comment_hint ( context , node , varlist , name ) [EOL] [EOL] [EOL] def find_type_from_comment_hint_assign ( context , node , name ) : [EOL] return _find_type_from_comment_hint ( context , node , node . children [ [number] ] , name ) [EOL] [EOL] [EOL] def _find_type_from_comment_hint ( context , node , varlist , name ) : [EOL] index = None [EOL] if varlist . type in ( [string] , [string] ) : [EOL] [comment] [EOL] index = [number] [EOL] for child in varlist . children : [EOL] if child == name : [EOL] break [EOL] if child . type == [string] : [EOL] continue [EOL] index += [number] [EOL] else : [EOL] return [ ] [EOL] [EOL] comment = parser_utils . get_following_comment_same_line ( node ) [EOL] if comment is None : [EOL] return [ ] [EOL] match = re . match ( [string] , comment ) [EOL] if not match : [EOL] return [ ] [EOL] annotation = tree . String ( repr ( str ( match . group ( [number] ) . strip ( ) ) ) , node . start_pos ) [EOL] annotation . parent = node . parent [EOL] return _evaluate_for_annotation ( context , annotation , index ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] import copy [EOL] import sys [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi import debug [EOL] from jedi . common import unite [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate import recursion [EOL] from jedi . evaluate import iterable [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate import stdlib [EOL] from jedi . evaluate import finder [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import precedence [EOL] from jedi . evaluate import param [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate . filters import TreeNameDefinition , ParamName [EOL] from jedi . evaluate . instance import AnonymousInstance , BoundMethod [EOL] from jedi . evaluate . context import ContextualizedName , ContextualizedNode [EOL] from jedi import parser_utils [EOL] [EOL] [EOL] class Evaluator ( object ) : [EOL] def __init__ ( self , grammar , sys_path = None ) : [EOL] self . grammar = grammar [EOL] self . memoize_cache = { } [comment] [EOL] [comment] [EOL] self . modules = { } [comment] [EOL] self . compiled_cache = { } [comment] [EOL] self . mixed_cache = { } [comment] [EOL] self . analysis = [ ] [EOL] self . dynamic_params_depth = [number] [EOL] self . is_analysis = False [EOL] self . python_version = sys . version_info [ : [number] ] [EOL] [EOL] if sys_path is None : [EOL] sys_path = sys . path [EOL] self . sys_path = copy . copy ( sys_path ) [EOL] try : [EOL] self . sys_path . remove ( [string] ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] self . reset_recursion_limitations ( ) [EOL] [EOL] [comment] [EOL] self . BUILTINS = compiled . get_special_object ( self , [string] ) [EOL] [EOL] def reset_recursion_limitations ( self ) : [EOL] self . recursion_detector = recursion . RecursionDetector ( ) [EOL] self . execution_recursion_detector = recursion . ExecutionRecursionDetector ( self ) [EOL] [EOL] def find_types ( self , context , name_or_str , name_context , position = None , search_global = False , is_goto = False ) : [EOL] [docstring] [EOL] f = finder . NameFinder ( self , context , name_context , name_or_str , position ) [EOL] filters = f . get_filters ( search_global ) [EOL] if is_goto : [EOL] return f . filter_name ( filters ) [EOL] return f . find ( filters , attribute_lookup = not search_global ) [EOL] [EOL] def eval_statement ( self , context , stmt , seek_name = None ) : [EOL] with recursion . execution_allowed ( self , stmt ) as allowed : [EOL] if allowed or context . get_root_context ( ) == self . BUILTINS : [EOL] return self . _eval_stmt ( context , stmt , seek_name ) [EOL] return set ( ) [EOL] [EOL] [comment] [EOL] @ debug . increase_indent def _eval_stmt ( self , context , stmt , seek_name = None ) : [EOL] [docstring] [EOL] debug . dbg ( [string] , stmt , seek_name ) [EOL] rhs = stmt . get_rhs ( ) [EOL] types = self . eval_element ( context , rhs ) [EOL] [EOL] if seek_name : [EOL] c_node = ContextualizedName ( context , seek_name ) [EOL] types = finder . check_tuple_assignments ( self , c_node , types ) [EOL] [EOL] first_operator = next ( stmt . yield_operators ( ) , None ) [EOL] if first_operator not in ( [string] , None ) and first_operator . type == [string] : [EOL] [comment] [EOL] operator = copy . copy ( first_operator ) [EOL] operator . value = operator . value [ : - [number] ] [EOL] name = stmt . get_defined_names ( ) [ [number] ] . value [EOL] left = context . py__getattribute__ ( name , position = stmt . start_pos , search_global = True ) [EOL] [EOL] for_stmt = tree . search_ancestor ( stmt , [string] ) [EOL] if for_stmt is not None and for_stmt . type == [string] and types \ [EOL] and parser_utils . for_stmt_defines_one_name ( for_stmt ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] node = for_stmt . get_testlist ( ) [EOL] cn = ContextualizedNode ( context , node ) [EOL] ordered = list ( iterable . py__iter__ ( self , cn . infer ( ) , cn ) ) [EOL] [EOL] for lazy_context in ordered : [EOL] dct = { for_stmt . children [ [number] ] . value : lazy_context . infer ( ) } [EOL] with helpers . predefine_names ( context , for_stmt , dct ) : [EOL] t = self . eval_element ( context , rhs ) [EOL] left = precedence . calculate ( self , context , left , operator , t ) [EOL] types = left [EOL] else : [EOL] types = precedence . calculate ( self , context , left , operator , types ) [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] def eval_element ( self , context , element ) : [EOL] if isinstance ( context , iterable . CompForContext ) : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] [EOL] if_stmt = element [EOL] while if_stmt is not None : [EOL] if_stmt = if_stmt . parent [EOL] if if_stmt . type in ( [string] , [string] ) : [EOL] break [EOL] if parser_utils . is_scope ( if_stmt ) : [EOL] if_stmt = None [EOL] break [EOL] predefined_if_name_dict = context . predefined_names . get ( if_stmt ) [EOL] if predefined_if_name_dict is None and if_stmt and if_stmt . type == [string] : [EOL] if_stmt_test = if_stmt . children [ [number] ] [EOL] name_dicts = [ { } ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if element . start_pos > if_stmt_test . end_pos : [EOL] [comment] [EOL] [comment] [EOL] if_names = helpers . get_names_of_node ( if_stmt_test ) [EOL] element_names = helpers . get_names_of_node ( element ) [EOL] str_element_names = [ e . value for e in element_names ] [EOL] if any ( i . value in str_element_names for i in if_names ) : [EOL] for if_name in if_names : [EOL] definitions = self . goto_definitions ( context , if_name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( definitions ) > [number] : [EOL] if len ( name_dicts ) * len ( definitions ) > [number] : [EOL] debug . dbg ( [string] , if_stmt ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] name_dicts = [ { } ] [EOL] break [EOL] [EOL] original_name_dicts = list ( name_dicts ) [EOL] name_dicts = [ ] [EOL] for definition in definitions : [EOL] new_name_dicts = list ( original_name_dicts ) [EOL] for i , name_dict in enumerate ( new_name_dicts ) : [EOL] new_name_dicts [ i ] = name_dict . copy ( ) [EOL] new_name_dicts [ i ] [ if_name . value ] = set ( [ definition ] ) [EOL] [EOL] name_dicts += new_name_dicts [EOL] else : [EOL] for name_dict in name_dicts : [EOL] name_dict [ if_name . value ] = definitions [EOL] if len ( name_dicts ) > [number] : [EOL] result = set ( ) [EOL] for name_dict in name_dicts : [EOL] with helpers . predefine_names ( context , if_stmt , name_dict ) : [EOL] result |= self . _eval_element_not_cached ( context , element ) [EOL] return result [EOL] else : [EOL] return self . _eval_element_if_evaluated ( context , element ) [EOL] else : [EOL] if predefined_if_name_dict : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] else : [EOL] return self . _eval_element_if_evaluated ( context , element ) [EOL] [EOL] def _eval_element_if_evaluated ( self , context , element ) : [EOL] [docstring] [EOL] parent = element [EOL] while parent is not None : [EOL] parent = parent . parent [EOL] predefined_if_name_dict = context . predefined_names . get ( parent ) [EOL] if predefined_if_name_dict is not None : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] return self . _eval_element_cached ( context , element ) [EOL] [EOL] @ memoize_default ( default = set ( ) , evaluator_is_first_arg = True ) def _eval_element_cached ( self , context , element ) : [EOL] return self . _eval_element_not_cached ( context , element ) [EOL] [EOL] @ debug . increase_indent def _eval_element_not_cached ( self , context , element ) : [EOL] debug . dbg ( [string] , element , element . start_pos ) [EOL] types = set ( ) [EOL] typ = element . type [EOL] if typ in ( [string] , [string] , [string] , [string] ) : [EOL] types = self . eval_atom ( context , element ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] if element . value in ( [string] , [string] , [string] ) : [EOL] types . add ( compiled . builtin_from_name ( self , element . value ) ) [EOL] [comment] [EOL] elif typ == [string] : [EOL] types = set ( [ er . FunctionContext ( self , context , element ) ] ) [EOL] elif typ == [string] : [EOL] types = self . eval_statement ( context , element ) [EOL] elif typ in ( [string] , [string] ) : [EOL] first_child = element . children [ [number] ] [EOL] if not ( first_child . type == [string] and first_child . value == [string] ) : [EOL] types = self . eval_atom ( context , first_child ) [EOL] for trailer in element . children [ [number] : ] : [EOL] if trailer == [string] : [comment] [EOL] right = self . eval_element ( context , element . children [ [number] ] ) [EOL] types = set ( precedence . calculate ( self , context , types , trailer , right ) ) [EOL] break [EOL] types = self . eval_trailer ( context , types , trailer ) [EOL] elif typ in ( [string] , [string] , ) : [EOL] [comment] [EOL] types = set ( [ iterable . SequenceLiteralContext ( self , context , element ) ] ) [EOL] elif typ in ( [string] , [string] ) : [EOL] types = self . eval_element ( context , element . children [ - [number] ] ) [EOL] for operator in element . children [ : - [number] ] : [EOL] types = set ( precedence . factor_calculate ( self , types , operator ) ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] types = ( self . eval_element ( context , element . children [ [number] ] ) | self . eval_element ( context , element . children [ - [number] ] ) ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] assert element . value == [string] [EOL] types = set ( [ compiled . create ( self , Ellipsis ) ] ) [EOL] elif typ == [string] : [EOL] types = self . eval_atom ( context , element . children [ [number] ] ) [EOL] for next_name in element . children [ [number] : : [number] ] : [EOL] [comment] [EOL] types = unite ( typ . py__getattribute__ ( next_name , name_context = context ) for typ in types ) [EOL] types = types [EOL] elif typ == [string] : [EOL] types = self . _eval_element_not_cached ( context , element . children [ [number] ] ) [EOL] elif typ == [string] : [EOL] types = pep0484 . _evaluate_for_annotation ( context , element . children [ [number] ] ) [EOL] else : [EOL] types = precedence . calculate_children ( self , context , element . children ) [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] def eval_atom ( self , context , atom ) : [EOL] [docstring] [EOL] if atom . type == [string] : [EOL] [comment] [EOL] stmt = atom . get_definition ( ) [EOL] if stmt . type == [string] : [EOL] stmt = tree . search_ancestor ( stmt , [string] , [string] , [string] , [string] ) [EOL] if stmt is None or stmt . type != [string] : [EOL] [comment] [EOL] [comment] [EOL] stmt = atom [EOL] return context . py__getattribute__ ( name_or_str = atom , position = stmt . start_pos , search_global = True ) [EOL] elif isinstance ( atom , tree . Literal ) : [EOL] string = parser_utils . safe_literal_eval ( atom . value ) [EOL] return set ( [ compiled . create ( self , string ) ] ) [EOL] else : [EOL] c = atom . children [EOL] if c [ [number] ] . type == [string] : [EOL] [comment] [EOL] types = self . eval_atom ( context , c [ [number] ] ) [EOL] for string in c [ [number] : ] : [EOL] right = self . eval_atom ( context , string ) [EOL] types = precedence . calculate ( self , context , types , [string] , right ) [EOL] return types [EOL] [comment] [EOL] elif c [ [number] ] == [string] and not len ( c ) == [number] \ [EOL] and not ( c [ [number] ] . type == [string] and len ( c [ [number] ] . children ) > [number] ) : [EOL] return self . eval_element ( context , c [ [number] ] ) [EOL] [EOL] try : [EOL] comp_for = c [ [number] ] . children [ [number] ] [EOL] except ( IndexError , AttributeError ) : [EOL] pass [EOL] else : [EOL] if comp_for == [string] : [EOL] [comment] [EOL] try : [EOL] comp_for = c [ [number] ] . children [ [number] ] [EOL] except IndexError : [EOL] pass [EOL] [EOL] if comp_for . type == [string] : [EOL] return set ( [ iterable . Comprehension . from_atom ( self , context , atom ) ] ) [EOL] [EOL] [comment] [EOL] array_node = c [ [number] ] [EOL] try : [EOL] array_node_c = array_node . children [EOL] except AttributeError : [EOL] array_node_c = [ ] [EOL] if c [ [number] ] == [string] and ( array_node == [string] or [string] in array_node_c ) : [EOL] context = iterable . DictLiteralContext ( self , context , atom ) [EOL] else : [EOL] context = iterable . SequenceLiteralContext ( self , context , atom ) [EOL] return set ( [ context ] ) [EOL] [EOL] def eval_trailer ( self , context , types , trailer ) : [EOL] trailer_op , node = trailer . children [ : [number] ] [EOL] if node == [string] : [comment] [EOL] node = ( ) [EOL] [EOL] new_types = set ( ) [EOL] if trailer_op == [string] : [EOL] new_types |= iterable . py__getitem__ ( self , context , types , trailer ) [EOL] else : [EOL] for typ in types : [EOL] debug . dbg ( [string] , trailer , typ ) [EOL] if trailer_op == [string] : [EOL] new_types |= typ . py__getattribute__ ( name_context = context , name_or_str = node ) [EOL] elif trailer_op == [string] : [EOL] arguments = param . TreeArguments ( self , context , node , trailer ) [EOL] new_types |= self . execute ( typ , arguments ) [EOL] return new_types [EOL] [EOL] @ debug . increase_indent def execute ( self , obj , arguments ) : [EOL] if not isinstance ( arguments , param . AbstractArguments ) : [EOL] raise NotImplementedError [EOL] arguments = param . Arguments ( self , arguments ) [EOL] [EOL] if self . is_analysis : [EOL] arguments . eval_all ( ) [EOL] [EOL] debug . dbg ( [string] , obj , arguments ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] return stdlib . execute ( self , obj , arguments ) [EOL] except stdlib . NotInStdLib : [EOL] pass [EOL] [EOL] try : [EOL] func = obj . py__call__ [EOL] except AttributeError : [EOL] debug . warning ( [string] , obj ) [EOL] return set ( ) [EOL] else : [EOL] types = func ( arguments ) [EOL] debug . dbg ( [string] , types , obj ) [EOL] return types [EOL] [EOL] def goto_definitions ( self , context , name ) : [EOL] def_ = name . get_definition ( ) [EOL] is_simple_name = name . parent . type not in ( [string] , [string] ) [EOL] if is_simple_name : [EOL] if name . parent . type == [string] and name . parent . name == name : [EOL] return [ er . ClassContext ( self , name . parent , context ) ] [EOL] elif name . parent . type == [string] : [EOL] return [ er . FunctionContext ( self , context , name . parent ) ] [EOL] elif name . parent . type == [string] : [EOL] raise NotImplementedError [EOL] if def_ . type == [string] and name in def_ . get_defined_names ( ) : [EOL] return self . eval_statement ( context , def_ , name ) [EOL] elif def_ . type == [string] and name . start_pos < def_ . children [ [number] ] . end_pos : [EOL] container_types = self . eval_element ( context , def_ . children [ [number] ] ) [EOL] cn = ContextualizedNode ( context , def_ . children [ [number] ] ) [EOL] for_types = iterable . py__iter__types ( self , container_types , cn ) [EOL] c_node = ContextualizedName ( context , name ) [EOL] return finder . check_tuple_assignments ( self , c_node , for_types ) [EOL] elif def_ . type in ( [string] , [string] ) : [EOL] return imports . infer_import ( context , name ) [EOL] [EOL] return helpers . evaluate_call_of_leaf ( context , name ) [EOL] [EOL] def goto ( self , context , name ) : [EOL] stmt = name . get_definition ( ) [EOL] par = name . parent [EOL] typ = par . type [EOL] if typ == [string] and par . children [ [number] ] == [string] and par . children [ [number] ] == name : [EOL] [comment] [EOL] trailer = par . parent [EOL] if trailer . type == [string] : [EOL] trailer = trailer . parent [EOL] if trailer . type != [string] : [EOL] if trailer . type == [string] : [EOL] types = self . eval_element ( context , trailer . children [ [number] ] ) [EOL] else : [EOL] i = trailer . parent . children . index ( trailer ) [EOL] to_evaluate = trailer . parent . children [ : i ] [EOL] types = self . eval_element ( context , to_evaluate [ [number] ] ) [EOL] for trailer in to_evaluate [ [number] : ] : [EOL] types = self . eval_trailer ( context , types , trailer ) [EOL] param_names = [ ] [EOL] for typ in types : [EOL] try : [EOL] get_param_names = typ . get_param_names [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] for param_name in get_param_names ( ) : [EOL] if param_name . string_name == name . value : [EOL] param_names . append ( param_name ) [EOL] return param_names [EOL] elif typ == [string] and name in par . get_defined_names ( ) : [EOL] [comment] [EOL] [comment] [EOL] return [ TreeNameDefinition ( context , name ) ] [EOL] elif typ == [string] and par . name : [EOL] return [ ParamName ( context , name ) ] [EOL] elif typ in ( [string] , [string] , [string] ) and par . name is name : [EOL] return [ TreeNameDefinition ( context , name ) ] [EOL] elif isinstance ( stmt , tree . Import ) : [EOL] module_names = imports . infer_import ( context , name , is_goto = True ) [EOL] return module_names [EOL] elif typ == [string] : [comment] [EOL] index = par . children . index ( name ) [EOL] if index > [number] : [EOL] new_dotted = helpers . deep_ast_copy ( par ) [EOL] new_dotted . children [ index - [number] : ] = [ ] [EOL] values = self . eval_element ( context , new_dotted ) [EOL] return unite ( value . py__getattribute__ ( name , name_context = context , is_goto = True ) for value in values ) [EOL] [EOL] if typ == [string] and par . children [ [number] ] == [string] : [EOL] values = helpers . evaluate_call_of_leaf ( context , name , cut_own_trailer = True ) [EOL] return unite ( value . py__getattribute__ ( name , name_context = context , is_goto = True ) for value in values ) [EOL] else : [EOL] if stmt . type != [string] : [EOL] [comment] [EOL] [comment] [EOL] stmt = name [EOL] return context . py__getattribute__ ( name , position = stmt . start_pos , search_global = True , is_goto = True ) [EOL] [EOL] def create_context ( self , base_context , node , node_is_context = False , node_is_object = False ) : [EOL] def parent_scope ( node ) : [EOL] while True : [EOL] node = node . parent [EOL] [EOL] if parser_utils . is_scope ( node ) : [EOL] return node [EOL] elif node . type in ( [string] , [string] ) : [EOL] if node . children [ [number] ] . type == [string] : [EOL] return node . children [ [number] ] [EOL] elif node . type == [string] : [EOL] for n in node . children [ [number] : [number] ] : [EOL] [comment] [EOL] if n . type == [string] : [EOL] return n [EOL] [EOL] def from_scope_node ( scope_node , child_is_funcdef = None , is_nested = True , node_is_object = False ) : [EOL] if scope_node == base_node : [EOL] return base_context [EOL] [EOL] is_funcdef = scope_node . type in ( [string] , [string] ) [EOL] parent_scope = parser_utils . get_parent_scope ( scope_node ) [EOL] parent_context = from_scope_node ( parent_scope , child_is_funcdef = is_funcdef ) [EOL] [EOL] if is_funcdef : [EOL] if isinstance ( parent_context , AnonymousInstance ) : [EOL] func = BoundMethod ( self , parent_context , parent_context . class_context , parent_context . parent_context , scope_node ) [EOL] else : [EOL] func = er . FunctionContext ( self , parent_context , scope_node ) [EOL] if is_nested and not node_is_object : [EOL] return func . get_function_execution ( ) [EOL] return func [EOL] elif scope_node . type == [string] : [EOL] class_context = er . ClassContext ( self , scope_node , parent_context ) [EOL] if child_is_funcdef : [EOL] [comment] [EOL] return AnonymousInstance ( self , parent_context , class_context ) [EOL] else : [EOL] return class_context [EOL] elif scope_node . type == [string] : [EOL] if node . start_pos >= scope_node . children [ - [number] ] . start_pos : [EOL] return parent_context [EOL] return iterable . CompForContext . from_comp_for ( parent_context , scope_node ) [EOL] raise Exception ( [string] ) [EOL] [EOL] base_node = base_context . tree_node [EOL] [EOL] if node_is_context and parser_utils . is_scope ( node ) : [EOL] scope_node = node [EOL] else : [EOL] if node . parent . type in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] node = node . parent [EOL] scope_node = parent_scope ( node ) [EOL] return from_scope_node ( scope_node , is_nested = True , node_is_object = node_is_object ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , List , Tuple , Set [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import imp [EOL] import os [EOL] import pkgutil [EOL] import sys [EOL] [EOL] from jedi . _compatibility import find_module , unicode , ImplicitNSInfo [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi . common import source_to_unicode , unite [EOL] from jedi . parser . python import parse [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . tree import search_ancestor [EOL] from jedi . parser . cache import parser_cache [EOL] from jedi . evaluate import sys_path [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate . cache import memoize_default [EOL] from jedi . evaluate . filters import AbstractNameDefinition [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ memoize_default ( default = set ( ) ) def infer_import ( context , tree_name , is_goto = False ) : [EOL] module_context = context . get_root_context ( ) [EOL] import_node = search_ancestor ( tree_name , [string] , [string] ) [EOL] import_path = import_node . get_path_for_name ( tree_name ) [EOL] from_import_name = None [EOL] evaluator = context . evaluator [EOL] try : [EOL] from_names = import_node . get_from_names ( ) [EOL] except AttributeError : [EOL] [comment] [EOL] pass [EOL] else : [EOL] if len ( from_names ) + [number] == len ( import_path ) : [EOL] [comment] [EOL] [comment] [EOL] from_import_name = import_path [ - [number] ] [EOL] import_path = from_names [EOL] [EOL] importer = Importer ( evaluator , tuple ( import_path ) , module_context , import_node . level ) [EOL] [EOL] types = importer . follow ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if from_import_name is not None : [EOL] types = unite ( t . py__getattribute__ ( from_import_name . value if isinstance ( from_import_name , tree . Name ) else from_import_name , name_context = context , is_goto = is_goto ) for t in types ) [EOL] [EOL] if not types : [EOL] path = import_path + [ from_import_name ] [EOL] importer = Importer ( evaluator , tuple ( path ) , module_context , import_node . level ) [EOL] types = importer . follow ( ) [EOL] [comment] [EOL] if is_goto : [EOL] types = set ( s . name for s in types ) [EOL] else : [EOL] [comment] [EOL] if is_goto : [EOL] types = set ( s . name for s in types ) [EOL] [EOL] debug . dbg ( [string] , types ) [EOL] return types [EOL] [EOL] [EOL] class NestedImportModule ( tree . Module ) : [EOL] [docstring] [EOL] def __init__ ( self , module , nested_import ) : [EOL] self . _module = module [EOL] self . _nested_import = nested_import [EOL] [EOL] def _get_nested_import_name ( self ) : [EOL] [docstring] [EOL] i = self . _nested_import [EOL] [comment] [EOL] [comment] [EOL] zero = ( [number] , [number] ) [EOL] names = [ unicode ( name ) for name in i . namespace_names [ [number] : ] ] [EOL] name = helpers . FakeName ( names , self . _nested_import ) [EOL] new = tree . Import ( i . _sub_module , zero , zero , name ) [EOL] new . parent = self . _module [EOL] debug . dbg ( [string] , new ) [EOL] return helpers . FakeName ( str ( i . namespace_names [ [number] ] ) , new ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _module , name ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . _module , self . _nested_import ) [EOL] [EOL] [EOL] def _add_error ( context , name , message = None ) : [EOL] [comment] [EOL] if hasattr ( name , [string] ) : [EOL] analysis . add ( context , [string] , name , message ) [EOL] [EOL] [EOL] def get_init_path ( directory_path ) : [EOL] [docstring] [EOL] for suffix , _ , _ in imp . get_suffixes ( ) : [EOL] path = os . path . join ( directory_path , [string] + suffix ) [EOL] if os . path . exists ( path ) : [EOL] return path [EOL] return None [EOL] [EOL] [EOL] class ImportName ( AbstractNameDefinition ) : [EOL] start_pos = ( [number] , [number] ) [EOL] [EOL] def __init__ ( self , parent_context , string_name ) : [EOL] self . parent_context = parent_context [EOL] self . string_name = string_name [EOL] [EOL] def infer ( self ) : [EOL] return Importer ( self . parent_context . evaluator , [ self . string_name ] , self . parent_context , ) . follow ( ) [EOL] [EOL] def get_root_context ( self ) : [EOL] [comment] [EOL] return self . parent_context . get_root_context ( ) [EOL] [EOL] @ property def api_type ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class SubModuleName ( ImportName ) : [EOL] def infer ( self ) : [EOL] return Importer ( self . parent_context . evaluator , [ self . string_name ] , self . parent_context , level = [number] ) . follow ( ) [EOL] [EOL] [EOL] class Importer ( object ) : [EOL] def __init__ ( self , evaluator , import_path , module_context , level = [number] ) : [EOL] [docstring] [EOL] debug . speed ( [string] % ( import_path , ) ) [EOL] self . _evaluator = evaluator [EOL] self . level = level [EOL] self . module_context = module_context [EOL] try : [EOL] self . file_path = module_context . py__file__ ( ) [EOL] except AttributeError : [EOL] [comment] [EOL] self . file_path = None [EOL] [EOL] if level : [EOL] base = module_context . py__package__ ( ) . split ( [string] ) [EOL] if base == [ [string] ] : [EOL] base = [ ] [EOL] if level > len ( base ) : [EOL] path = module_context . py__file__ ( ) [EOL] if path is not None : [EOL] import_path = list ( import_path ) [EOL] p = path [EOL] for i in range ( level ) : [EOL] p = os . path . dirname ( p ) [EOL] dir_name = os . path . basename ( p ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if dir_name : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if path . endswith ( os . path . sep + [string] ) : [EOL] import_path . insert ( [number] , [string] ) [EOL] else : [EOL] import_path . insert ( [number] , dir_name ) [EOL] else : [EOL] _add_error ( module_context , import_path [ - [number] ] ) [EOL] import_path = [ ] [EOL] [comment] [EOL] debug . warning ( [string] ) [EOL] else : [EOL] [comment] [EOL] import_path = tuple ( base ) + tuple ( import_path ) [EOL] self . import_path = import_path [EOL] [EOL] @ property def str_import_path ( self ) : [EOL] [docstring] [EOL] return tuple ( name . value if isinstance ( name , tree . Name ) else name for name in self . import_path ) [EOL] [EOL] def sys_path_with_modifications ( self ) : [EOL] in_path = [ ] [EOL] sys_path_mod = list ( sys_path . sys_path_with_modifications ( self . _evaluator , self . module_context ) ) [EOL] if self . file_path is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . import_path : [comment] [EOL] for path in sys_path . traverse_parents ( self . file_path ) : [EOL] if os . path . basename ( path ) == self . str_import_path [ [number] ] : [EOL] in_path . append ( os . path . dirname ( path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys_path_mod . insert ( [number] , os . path . dirname ( self . file_path ) ) [EOL] [EOL] return in_path + sys_path_mod [EOL] [EOL] def follow ( self ) : [EOL] if not self . import_path : [EOL] return set ( ) [EOL] return self . _do_import ( self . import_path , self . sys_path_with_modifications ( ) ) [EOL] [EOL] def _do_import ( self , import_path , sys_path ) : [EOL] [docstring] [EOL] import_parts = [ i . value if isinstance ( i , tree . Name ) else i for i in import_path ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if len ( import_path ) > [number] and import_parts [ : [number] ] == [ [string] , [string] ] : [EOL] [comment] [EOL] ipath = ( [string] + str ( import_parts [ [number] ] ) , ) + import_path [ [number] : ] [EOL] modules = self . _do_import ( ipath , sys_path ) [EOL] if modules : [EOL] return modules [EOL] else : [EOL] [comment] [EOL] return self . _do_import ( ( [string] , ) + import_path [ [number] : ] , sys_path ) [EOL] [EOL] module_name = [string] . join ( import_parts ) [EOL] try : [EOL] return set ( [ self . _evaluator . modules [ module_name ] ] ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] if len ( import_path ) > [number] : [EOL] [comment] [EOL] [comment] [EOL] bases = self . _do_import ( import_path [ : - [number] ] , sys_path ) [EOL] if not bases : [EOL] return set ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parent_module = list ( bases ) [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if import_parts == [ [string] , [string] ] : [EOL] return parent_module . py__getattribute__ ( [string] ) [EOL] [EOL] try : [EOL] method = parent_module . py__path__ [EOL] except AttributeError : [EOL] [comment] [EOL] _add_error ( self . module_context , import_path [ - [number] ] ) [EOL] return set ( ) [EOL] else : [EOL] paths = method ( ) [EOL] debug . dbg ( [string] , module_name , paths ) [EOL] for path in paths : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] if not isinstance ( path , list ) : [EOL] path = [ path ] [EOL] module_file , module_path , is_pkg = find_module ( import_parts [ - [number] ] , path , fullname = module_name ) [EOL] break [EOL] except ImportError : [EOL] module_path = None [EOL] if module_path is None : [EOL] _add_error ( self . module_context , import_path [ - [number] ] ) [EOL] return set ( ) [EOL] else : [EOL] parent_module = None [EOL] try : [EOL] debug . dbg ( [string] , import_parts [ - [number] ] , self . file_path ) [EOL] [comment] [EOL] [comment] [EOL] sys . path , temp = sys_path , sys . path [EOL] try : [EOL] module_file , module_path , is_pkg = find_module ( import_parts [ - [number] ] , fullname = module_name ) [EOL] finally : [EOL] sys . path = temp [EOL] except ImportError : [EOL] [comment] [EOL] _add_error ( self . module_context , import_path [ - [number] ] ) [EOL] return set ( ) [EOL] [EOL] code = None [EOL] if is_pkg : [EOL] [comment] [EOL] [comment] [EOL] if module_path . endswith ( ( [string] , [string] ) ) : [EOL] code = module_file . loader . get_source ( module_name ) [EOL] else : [EOL] module_path = get_init_path ( module_path ) [EOL] elif module_file : [EOL] code = module_file . read ( ) [EOL] module_file . close ( ) [EOL] [EOL] if isinstance ( module_path , ImplicitNSInfo ) : [EOL] from jedi . evaluate . representation import ImplicitNamespaceContext [EOL] fullname , paths = module_path . name , module_path . paths [EOL] module = ImplicitNamespaceContext ( self . _evaluator , fullname = fullname ) [EOL] module . paths = paths [EOL] elif module_file is None and not module_path . endswith ( ( [string] , [string] , [string] ) ) : [EOL] module = compiled . load_module ( self . _evaluator , module_path ) [EOL] else : [EOL] module = _load_module ( self . _evaluator , module_path , code , sys_path , parent_module ) [EOL] [EOL] if module is None : [EOL] [comment] [EOL] [comment] [EOL] return set ( ) [EOL] [EOL] self . _evaluator . modules [ module_name ] = module [EOL] return set ( [ module ] ) [EOL] [EOL] def _generate_name ( self , name , in_module = None ) : [EOL] [comment] [EOL] if in_module is None : [EOL] return ImportName ( self . module_context , name ) [EOL] return SubModuleName ( in_module , name ) [EOL] [EOL] def _get_module_names ( self , search_path = None , in_module = None ) : [EOL] [docstring] [EOL] [EOL] names = [ ] [EOL] [comment] [EOL] if search_path is None and in_module is None : [EOL] names += [ self . _generate_name ( name ) for name in sys . builtin_module_names ] [EOL] [EOL] if search_path is None : [EOL] search_path = self . sys_path_with_modifications ( ) [EOL] for module_loader , name , is_pkg in pkgutil . iter_modules ( search_path ) : [EOL] names . append ( self . _generate_name ( name , in_module = in_module ) ) [EOL] return names [EOL] [EOL] def completion_names ( self , evaluator , only_modules = False ) : [EOL] [docstring] [EOL] from jedi . evaluate . representation import ModuleContext , ImplicitNamespaceContext [EOL] names = [ ] [EOL] if self . import_path : [EOL] [comment] [EOL] if self . str_import_path == ( [string] , [string] ) : [EOL] [comment] [EOL] for mod in self . _get_module_names ( ) : [EOL] modname = mod . string_name [EOL] if modname . startswith ( [string] ) : [EOL] extname = modname [ len ( [string] ) : ] [EOL] names . append ( self . _generate_name ( extname ) ) [EOL] [comment] [EOL] for dir in self . sys_path_with_modifications ( ) : [EOL] flaskext = os . path . join ( dir , [string] ) [EOL] if os . path . isdir ( flaskext ) : [EOL] names += self . _get_module_names ( [ flaskext ] ) [EOL] [EOL] for context in self . follow ( ) : [EOL] [comment] [EOL] if context . api_type != [string] : [comment] [EOL] continue [EOL] [comment] [EOL] if isinstance ( context , ModuleContext ) and context . py__file__ ( ) . endswith ( [string] ) : [EOL] paths = context . py__path__ ( ) [EOL] names += self . _get_module_names ( paths , in_module = context ) [EOL] [EOL] [comment] [EOL] elif isinstance ( context , ImplicitNamespaceContext ) : [EOL] paths = context . paths [EOL] names += self . _get_module_names ( paths ) [EOL] [EOL] if only_modules : [EOL] [comment] [EOL] [comment] [EOL] if ( [string] , ) == self . str_import_path and not self . level : [EOL] [comment] [EOL] [comment] [EOL] names . append ( self . _generate_name ( [string] , context ) ) [EOL] [EOL] continue [EOL] [EOL] for filter in context . get_filters ( search_global = False ) : [EOL] names += filter . values ( ) [EOL] else : [EOL] [comment] [EOL] if not self . level : [EOL] names += self . _get_module_names ( ) [EOL] [EOL] if self . file_path is not None : [EOL] path = os . path . abspath ( self . file_path ) [EOL] for i in range ( self . level - [number] ) : [EOL] path = os . path . dirname ( path ) [EOL] names += self . _get_module_names ( [ path ] ) [EOL] [EOL] return names [EOL] [EOL] [EOL] def _load_module ( evaluator , path = None , code = None , sys_path = None , parent_module = None ) : [EOL] if sys_path is None : [EOL] sys_path = evaluator . sys_path [EOL] [EOL] dotted_path = path and compiled . dotted_from_fs_path ( path , sys_path ) [EOL] if path is not None and path . endswith ( ( [string] , [string] , [string] ) ) \ [EOL] and dotted_path not in settings . auto_import_modules : [EOL] [EOL] module_node = parse ( code = code , path = path , cache = True , diff_cache = True ) [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] return ModuleContext ( evaluator , module_node , path = path ) [EOL] else : [EOL] return compiled . load_module ( evaluator , path ) [EOL] [EOL] [EOL] def add_module ( evaluator , module_name , module ) : [EOL] if [string] not in module_name : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] evaluator . modules [ module_name ] = module [EOL] [EOL] [EOL] def get_modules_containing_name ( evaluator , modules , name ) : [EOL] [docstring] [EOL] from jedi . evaluate import representation as er [EOL] [EOL] def check_python_file ( path ) : [EOL] try : [EOL] node_cache_item = parser_cache [ path ] [EOL] except KeyError : [EOL] try : [EOL] return check_fs ( path ) [EOL] except IOError : [EOL] return None [EOL] else : [EOL] module_node = node_cache_item . node [EOL] return er . ModuleContext ( evaluator , module_node , path = path ) [EOL] [EOL] def check_fs ( path ) : [EOL] with open ( path , [string] ) as f : [EOL] code = source_to_unicode ( f . read ( ) ) [EOL] if name in code : [EOL] module_name = os . path . basename ( path ) [ : - [number] ] [comment] [EOL] module = _load_module ( evaluator , path , code ) [EOL] add_module ( evaluator , module_name , module ) [EOL] return module [EOL] [EOL] [comment] [EOL] used_mod_paths = set ( ) [EOL] for m in modules : [EOL] try : [EOL] path = m . py__file__ ( ) [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] used_mod_paths . add ( path ) [EOL] yield m [EOL] [EOL] if not settings . dynamic_params_for_other_modules : [EOL] return [EOL] [EOL] paths = set ( settings . additional_dynamic_modules ) [EOL] for p in used_mod_paths : [EOL] if p is not None : [EOL] [comment] [EOL] [comment] [EOL] d = os . path . dirname ( os . path . abspath ( p ) ) [EOL] for file_name in os . listdir ( d ) : [EOL] path = os . path . join ( d , file_name ) [EOL] if path not in used_mod_paths and path not in paths : [EOL] if file_name . endswith ( [string] ) : [EOL] paths . add ( path ) [EOL] [EOL] [comment] [EOL] for p in sorted ( paths ) : [EOL] [comment] [EOL] m = check_python_file ( p ) [EOL] if m is not None and not isinstance ( m , compiled . CompiledObject ) : [EOL] yield m [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Any , Set [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . tree import search_ancestor [EOL] from jedi import debug [EOL] from jedi . common import unite [EOL] from jedi import settings [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate . instance import AbstractInstanceContext [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate import pep0484 [EOL] from jedi . evaluate import iterable [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate import analysis [EOL] from jedi . evaluate import flow_analysis [EOL] from jedi . evaluate import param [EOL] from jedi . evaluate import helpers [EOL] from jedi . evaluate . filters import get_global_filters [EOL] from jedi . evaluate . context import ContextualizedName , ContextualizedNode [EOL] from jedi . parser_utils import is_scope , get_parent_scope [EOL] [EOL] [EOL] class NameFinder ( object ) : [EOL] def __init__ ( self , evaluator , context , name_context , name_or_str , position = None ) : [EOL] self . _evaluator = evaluator [EOL] [comment] [EOL] self . _context = context [EOL] self . _name_context = name_context [EOL] self . _name = name_or_str [EOL] if isinstance ( name_or_str , tree . Name ) : [EOL] self . _string_name = name_or_str . value [EOL] else : [EOL] self . _string_name = name_or_str [EOL] self . _position = position [EOL] self . _found_predefined_types = None [EOL] [EOL] @ debug . increase_indent def find ( self , filters , attribute_lookup ) : [EOL] [docstring] [EOL] names = self . filter_name ( filters ) [EOL] if self . _found_predefined_types is not None and names : [EOL] check = flow_analysis . reachability_check ( self . _context , self . _context . tree_node , self . _name ) [EOL] if check is flow_analysis . UNREACHABLE : [EOL] return set ( ) [EOL] return self . _found_predefined_types [EOL] [EOL] types = self . _names_to_types ( names , attribute_lookup ) [EOL] [EOL] if not names and not types \ [EOL] and not ( isinstance ( self . _name , tree . Name ) and isinstance ( self . _name . parent . parent , tree . Param ) ) : [EOL] if isinstance ( self . _name , tree . Name ) : [EOL] if attribute_lookup : [EOL] analysis . add_attribute_error ( self . _name_context , self . _context , self . _name ) [EOL] else : [EOL] message = ( [string] % self . _string_name ) [EOL] analysis . add ( self . _name_context , [string] , self . _name , message ) [EOL] [EOL] return types [EOL] [EOL] def _get_origin_scope ( self ) : [EOL] if isinstance ( self . _name , tree . Name ) : [EOL] scope = self . _name [EOL] while scope . parent is not None : [EOL] [comment] [EOL] if not isinstance ( scope , tree . Scope ) : [EOL] break [EOL] scope = scope . parent [EOL] return scope [EOL] else : [EOL] return None [EOL] [EOL] def get_filters ( self , search_global = False ) : [EOL] origin_scope = self . _get_origin_scope ( ) [EOL] if search_global : [EOL] return get_global_filters ( self . _evaluator , self . _context , self . _position , origin_scope ) [EOL] else : [EOL] return self . _context . get_filters ( search_global , self . _position , origin_scope = origin_scope ) [EOL] [EOL] def filter_name ( self , filters ) : [EOL] [docstring] [EOL] names = [ ] [EOL] if self . _context . predefined_names : [EOL] [comment] [EOL] node = self . _name [EOL] while node is not None and not is_scope ( node ) : [EOL] node = node . parent [EOL] if node . type in ( [string] , [string] , [string] ) : [EOL] try : [EOL] name_dict = self . _context . predefined_names [ node ] [EOL] types = name_dict [ self . _string_name ] [EOL] except KeyError : [EOL] continue [EOL] else : [EOL] self . _found_predefined_types = types [EOL] break [EOL] [EOL] for filter in filters : [EOL] names = filter . get ( self . _string_name ) [EOL] if names : [EOL] break [EOL] debug . dbg ( [string] , self . _string_name , self . _context , names , self . _position ) [EOL] return list ( names ) [EOL] [EOL] def _check_getattr ( self , inst ) : [EOL] [docstring] [EOL] [comment] [EOL] name = compiled . create ( self . _evaluator , self . _string_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] names = ( inst . get_function_slot_names ( [string] ) or inst . get_function_slot_names ( [string] ) ) [EOL] return inst . execute_function_slots ( names , name ) [EOL] [EOL] def _names_to_types ( self , names , attribute_lookup ) : [EOL] types = set ( ) [EOL] [EOL] types = unite ( name . infer ( ) for name in names ) [EOL] [EOL] debug . dbg ( [string] , names , types ) [EOL] if not names and isinstance ( self . _context , AbstractInstanceContext ) : [EOL] [comment] [EOL] return self . _check_getattr ( self . _context ) [EOL] [EOL] [comment] [EOL] if not types and isinstance ( self . _name , tree . Name ) and not isinstance ( self . _name_context , AbstractInstanceContext ) : [EOL] flow_scope = self . _name [EOL] base_node = self . _name_context . tree_node [EOL] if base_node . type == [string] : [EOL] return types [EOL] while True : [EOL] flow_scope = get_parent_scope ( flow_scope , include_flows = True ) [EOL] n = _check_flow_information ( self . _name_context , flow_scope , self . _name , self . _position ) [EOL] if n is not None : [EOL] return n [EOL] if flow_scope == base_node : [EOL] break [EOL] return types [EOL] [EOL] [EOL] def _name_to_types ( evaluator , context , tree_name ) : [EOL] types = [ ] [EOL] node = tree_name . get_definition ( ) [EOL] typ = node . type [EOL] if typ == [string] : [EOL] types = pep0484 . find_type_from_comment_hint_for ( context , node , tree_name ) [EOL] if types : [EOL] return types [EOL] if typ == [string] : [EOL] types = pep0484 . find_type_from_comment_hint_with ( context , node , tree_name ) [EOL] if types : [EOL] return types [EOL] if typ in ( [string] , [string] ) : [EOL] try : [EOL] types = context . predefined_names [ node ] [ tree_name . value ] [EOL] except KeyError : [EOL] cn = ContextualizedNode ( context , node . children [ [number] ] ) [EOL] for_types = iterable . py__iter__types ( evaluator , cn . infer ( ) , cn ) [EOL] c_node = ContextualizedName ( context , tree_name ) [EOL] types = check_tuple_assignments ( evaluator , c_node , for_types ) [EOL] elif typ == [string] : [EOL] types = _remove_statements ( evaluator , context , node , tree_name ) [EOL] elif typ == [string] : [EOL] types = context . eval_node ( node . get_context_manager_from_name ( tree_name ) ) [EOL] elif typ in ( [string] , [string] ) : [EOL] types = imports . infer_import ( context , tree_name ) [EOL] elif typ in ( [string] , [string] ) : [EOL] types = _apply_decorators ( evaluator , context , node ) [EOL] elif typ == [string] : [EOL] context = evaluator . create_context ( context , tree_name ) [EOL] finder = NameFinder ( evaluator , context , context , tree_name . value ) [EOL] filters = finder . get_filters ( search_global = True ) [EOL] [comment] [EOL] [comment] [EOL] filters = [ next ( filters ) ] [EOL] types += finder . find ( filters , attribute_lookup = False ) [EOL] elif typ == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exceptions = context . eval_node ( tree_name . get_previous_sibling ( ) . get_previous_sibling ( ) ) [EOL] types = unite ( evaluator . execute ( t , param . ValuesArguments ( [ ] ) ) for t in exceptions ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] return types [EOL] [EOL] [EOL] def _apply_decorators ( evaluator , context , node ) : [EOL] [docstring] [EOL] if node . type == [string] : [EOL] decoratee_context = er . ClassContext ( evaluator , parent_context = context , classdef = node ) [EOL] else : [EOL] decoratee_context = er . FunctionContext ( evaluator , parent_context = context , funcdef = node ) [EOL] initial = values = set ( [ decoratee_context ] ) [EOL] for dec in reversed ( node . get_decorators ( ) ) : [EOL] debug . dbg ( [string] , dec , values ) [EOL] dec_values = context . eval_node ( dec . children [ [number] ] ) [EOL] trailer_nodes = dec . children [ [number] : - [number] ] [EOL] if trailer_nodes : [EOL] [comment] [EOL] trailer = tree . PythonNode ( [string] , trailer_nodes ) [EOL] trailer . parent = dec [EOL] dec_values = evaluator . eval_trailer ( context , dec_values , trailer ) [EOL] [EOL] if not len ( dec_values ) : [EOL] debug . warning ( [string] , dec , node ) [EOL] return initial [EOL] [EOL] values = unite ( dec_value . execute ( param . ValuesArguments ( [ values ] ) ) for dec_value in dec_values ) [EOL] if not len ( values ) : [EOL] debug . warning ( [string] , node ) [EOL] return initial [EOL] [EOL] debug . dbg ( [string] , values ) [EOL] return values [EOL] [EOL] [EOL] def _remove_statements ( evaluator , context , stmt , name ) : [EOL] [docstring] [EOL] types = set ( ) [EOL] check_instance = None [EOL] [EOL] pep0484types = pep0484 . find_type_from_comment_hint_assign ( context , stmt , name ) [EOL] if pep0484types : [EOL] return pep0484types [EOL] types |= context . eval_stmt ( stmt , seek_name = name ) [EOL] [EOL] if check_instance is not None : [EOL] [comment] [EOL] types = set ( [ er . get_instance_el ( evaluator , check_instance , a , True ) [EOL] if isinstance ( a , er . Function ) else a for a in types ] ) [EOL] return types [EOL] [EOL] [EOL] def _check_flow_information ( context , flow , search_name , pos ) : [EOL] [docstring] [EOL] if not settings . dynamic_flow_information : [EOL] return None [EOL] [EOL] result = None [EOL] if is_scope ( flow ) : [EOL] [comment] [EOL] module_node = flow . get_root_node ( ) [EOL] try : [EOL] names = module_node . get_used_names ( ) [ search_name . value ] [EOL] except KeyError : [EOL] return None [EOL] names = reversed ( [ n for n in names if flow . start_pos <= n . start_pos < ( pos or flow . end_pos ) ] ) [EOL] [EOL] for name in names : [EOL] ass = search_ancestor ( name , [string] ) [EOL] if ass is not None : [EOL] result = _check_isinstance_type ( context , ass . assertion , search_name ) [EOL] if result is not None : [EOL] return result [EOL] [EOL] if flow . type in ( [string] , [string] ) : [EOL] potential_ifs = [ c for c in flow . children [ [number] : : [number] ] if c != [string] ] [EOL] for if_test in reversed ( potential_ifs ) : [EOL] if search_name . start_pos > if_test . end_pos : [EOL] return _check_isinstance_type ( context , if_test , search_name ) [EOL] return result [EOL] [EOL] [EOL] def _check_isinstance_type ( context , element , search_name ) : [EOL] try : [EOL] assert element . type in ( [string] , [string] ) [EOL] [comment] [EOL] assert len ( element . children ) == [number] [EOL] first , trailer = element . children [EOL] assert first . type == [string] and first . value == [string] [EOL] assert trailer . type == [string] and trailer . children [ [number] ] == [string] [EOL] assert len ( trailer . children ) == [number] [EOL] [EOL] [comment] [EOL] arglist = trailer . children [ [number] ] [EOL] args = param . TreeArguments ( context . evaluator , context , arglist , trailer ) [EOL] param_list = list ( args . unpack ( ) ) [EOL] [comment] [EOL] assert len ( param_list ) == [number] [EOL] ( key1 , lazy_context_object ) , ( key2 , lazy_context_cls ) = param_list [EOL] assert key1 is None and key2 is None [EOL] call = helpers . call_of_leaf ( search_name ) [EOL] is_instance_call = helpers . call_of_leaf ( lazy_context_object . data ) [EOL] [comment] [EOL] [comment] [EOL] assert is_instance_call . get_code ( normalized = True ) == call . get_code ( normalized = True ) [EOL] except AssertionError : [EOL] return None [EOL] [EOL] result = set ( ) [EOL] for cls_or_tup in lazy_context_cls . infer ( ) : [EOL] if isinstance ( cls_or_tup , iterable . AbstractSequence ) and cls_or_tup . array_type == [string] : [EOL] for lazy_context in cls_or_tup . py__iter__ ( ) : [EOL] for context in lazy_context . infer ( ) : [EOL] result |= context . execute_evaluated ( ) [EOL] else : [EOL] result |= cls_or_tup . execute_evaluated ( ) [EOL] return result [EOL] [EOL] [EOL] def check_tuple_assignments ( evaluator , contextualized_name , types ) : [EOL] [docstring] [EOL] lazy_context = None [EOL] for index , node in contextualized_name . assignment_indexes ( ) : [EOL] cn = ContextualizedNode ( contextualized_name . context , node ) [EOL] iterated = iterable . py__iter__ ( evaluator , types , cn ) [EOL] for _ in range ( index + [number] ) : [EOL] try : [EOL] lazy_context = next ( iterated ) [EOL] except StopIteration : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return set ( ) [EOL] types = lazy_context . infer ( ) [EOL] return types [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from jedi . parser . parser import ParserSyntaxError [EOL] from jedi . parser . pgen2 . pgen import generate_grammar [EOL] from jedi . parser import python [EOL] [EOL] [EOL] def parse ( grammar , code ) : [EOL] raise NotImplementedError [EOL] Parser ( grammar , code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] from jedi . _compatibility import is_py3 , is_py35 [EOL] from token import * [EOL] [EOL] [EOL] COMMENT = N_TOKENS [EOL] tok_name [ COMMENT ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] NL = N_TOKENS [EOL] tok_name [ NL ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] if is_py3 : [EOL] BACKQUOTE = N_TOKENS [EOL] tok_name [ BACKQUOTE ] = [string] [EOL] N_TOKENS += [number] [EOL] else : [EOL] RARROW = N_TOKENS [EOL] tok_name [ RARROW ] = [string] [EOL] N_TOKENS += [number] [EOL] ELLIPSIS = N_TOKENS [EOL] tok_name [ ELLIPSIS ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] if not is_py35 : [EOL] ATEQUAL = N_TOKENS [EOL] tok_name [ ATEQUAL ] = [string] [EOL] N_TOKENS += [number] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] opmap_raw = [string] [EOL] [EOL] opmap = { } [EOL] for line in opmap_raw . splitlines ( ) : [EOL] op , name = line . split ( ) [EOL] opmap [ op ] = globals ( ) [ name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from jedi . parser import tree [EOL] from jedi . parser . pgen2 . parse import PgenParser [EOL] [EOL] [EOL] class ParserSyntaxError ( Exception ) : [EOL] [docstring] [EOL] def __init__ ( self , message , position ) : [EOL] self . message = message [EOL] self . position = position [EOL] [EOL] [EOL] class BaseParser ( object ) : [EOL] node_map = { } [EOL] default_node = tree . Node [EOL] [EOL] leaf_map = { } [EOL] default_leaf = tree . Leaf [EOL] [EOL] def __init__ ( self , grammar , start_symbol = [string] , error_recovery = False ) : [EOL] self . _grammar = grammar [EOL] self . _start_symbol = start_symbol [EOL] self . _error_recovery = error_recovery [EOL] [EOL] def parse ( self , tokens ) : [EOL] start_number = self . _grammar . symbol2number [ self . _start_symbol ] [EOL] self . pgen_parser = PgenParser ( self . _grammar , self . convert_node , self . convert_leaf , self . error_recovery , start_number ) [EOL] [EOL] node = self . pgen_parser . parse ( tokens ) [EOL] [comment] [EOL] del self . pgen_parser [EOL] return node [EOL] [EOL] def error_recovery ( self , grammar , stack , arcs , typ , value , start_pos , prefix , add_token_callback ) : [EOL] if self . _error_recovery : [EOL] raise NotImplementedError ( [string] ) [EOL] else : [EOL] raise ParserSyntaxError ( [string] , start_pos ) [EOL] [EOL] def convert_node ( self , grammar , type_ , children ) : [EOL] [comment] [EOL] symbol = grammar . number2symbol [ type_ ] [EOL] try : [EOL] return self . node_map [ symbol ] ( children ) [EOL] except KeyError : [EOL] return self . default_node ( symbol , children ) [EOL] [EOL] def convert_leaf ( self , grammar , type_ , value , prefix , start_pos ) : [EOL] try : [EOL] return self . leaf_map [ type_ ] ( value , start_pos , prefix ) [EOL] except KeyError : [EOL] return self . default_leaf ( value , start_pos , prefix ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import time [EOL] import os [EOL] import sys [EOL] import hashlib [EOL] import gc [EOL] import shutil [EOL] import pickle [EOL] import platform [EOL] import errno [EOL] [EOL] from jedi import settings [EOL] from jedi import debug [EOL] from jedi . _compatibility import FileNotFoundError [EOL] [EOL] [EOL] _PICKLE_VERSION = [number] [EOL] [docstring] [EOL] [EOL] _VERSION_TAG = [string] % ( platform . python_implementation ( ) , sys . version_info [ [number] ] , sys . version_info [ [number] ] , _PICKLE_VERSION ) [EOL] [docstring] [EOL] [EOL] [comment] [EOL] parser_cache = { } [EOL] [EOL] [EOL] [EOL] class _NodeCacheItem ( object ) : [EOL] def __init__ ( self , node , lines , change_time = None ) : [EOL] self . node = node [EOL] self . lines = lines [EOL] if change_time is None : [EOL] change_time = time . time ( ) [EOL] self . change_time = change_time [EOL] [EOL] [EOL] def load_module ( grammar , path ) : [EOL] [docstring] [EOL] try : [EOL] p_time = os . path . getmtime ( path ) [EOL] except FileNotFoundError : [EOL] return None [EOL] [EOL] try : [EOL] [comment] [EOL] module_cache_item = parser_cache [ path ] [EOL] if p_time <= module_cache_item . change_time : [EOL] return module_cache_item . node [EOL] except KeyError : [EOL] if not settings . use_filesystem_cache : [EOL] return None [EOL] [EOL] return _load_from_file_system ( grammar , path , p_time ) [EOL] [EOL] [EOL] def _load_from_file_system ( grammar , path , p_time ) : [EOL] cache_path = _get_hashed_path ( grammar , path ) [EOL] try : [EOL] try : [EOL] if p_time > os . path . getmtime ( cache_path ) : [EOL] [comment] [EOL] return None [EOL] except OSError as e : [EOL] if e . errno == errno . ENOENT : [EOL] [comment] [EOL] raise FileNotFoundError [EOL] else : [EOL] raise [EOL] [EOL] with open ( cache_path , [string] ) as f : [EOL] gc . disable ( ) [EOL] try : [EOL] module_cache_item = pickle . load ( f ) [EOL] finally : [EOL] gc . enable ( ) [EOL] except FileNotFoundError : [EOL] return None [EOL] else : [EOL] parser_cache [ path ] = module_cache_item [EOL] debug . dbg ( [string] , path ) [EOL] return module_cache_item . node [EOL] [EOL] [EOL] def save_module ( grammar , path , module , lines , pickling = True ) : [EOL] try : [EOL] p_time = None if path is None else os . path . getmtime ( path ) [EOL] except OSError : [EOL] p_time = None [EOL] pickling = False [EOL] [EOL] item = _NodeCacheItem ( module , lines , p_time ) [EOL] parser_cache [ path ] = item [EOL] if settings . use_filesystem_cache and pickling and path is not None : [EOL] _save_to_file_system ( grammar , path , item ) [EOL] [EOL] [EOL] def _save_to_file_system ( grammar , path , item ) : [EOL] with open ( _get_hashed_path ( grammar , path ) , [string] ) as f : [EOL] pickle . dump ( item , f , pickle . HIGHEST_PROTOCOL ) [EOL] [EOL] [EOL] def remove_old_modules ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] def clear_cache ( self ) : [EOL] shutil . rmtree ( settings . cache_directory ) [EOL] parser_cache . clear ( ) [EOL] [EOL] [EOL] def _get_hashed_path ( grammar , path ) : [EOL] file_hash = hashlib . sha256 ( path . encode ( [string] ) ) . hexdigest ( ) [EOL] directory = _get_cache_directory_path ( ) [EOL] return os . path . join ( directory , [string] % ( grammar . sha256 , file_hash ) ) [EOL] [EOL] [EOL] def _get_cache_directory_path ( ) : [EOL] directory = os . path . join ( settings . cache_directory , _VERSION_TAG ) [EOL] if not os . path . exists ( directory ) : [EOL] os . makedirs ( directory ) [EOL] return directory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , List , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from jedi . parser import tokenize [EOL] [EOL] [EOL] class InternalParseError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg , type , value , start_pos ) : [EOL] Exception . __init__ ( self , [string] % ( msg , tokenize . tok_name [ type ] , value , start_pos ) ) [EOL] self . msg = msg [EOL] self . type = type [EOL] self . value = value [EOL] self . start_pos = start_pos [EOL] [EOL] [EOL] def token_to_ilabel ( grammar , type_ , value ) : [EOL] [comment] [EOL] if type_ == tokenize . NAME : [EOL] [comment] [EOL] try : [EOL] return grammar . keywords [ value ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] try : [EOL] return grammar . tokens [ type_ ] [EOL] except KeyError : [EOL] return None [EOL] [EOL] [EOL] class PgenParser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , grammar , convert_node , convert_leaf , error_recovery , start ) : [EOL] [docstring] [EOL] self . grammar = grammar [EOL] self . convert_node = convert_node [EOL] self . convert_leaf = convert_leaf [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] newnode = ( start , [ ] ) [EOL] stackentry = ( self . grammar . dfas [ start ] , [number] , newnode ) [EOL] self . stack = [ stackentry ] [EOL] self . rootnode = None [EOL] self . error_recovery = error_recovery [EOL] [EOL] def parse ( self , tokens ) : [EOL] for type_ , value , start_pos , prefix in tokens : [EOL] if self . addtoken ( type_ , value , start_pos , prefix ) : [EOL] break [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . stack : [EOL] raise InternalParseError ( [string] , type_ , value , start_pos ) [EOL] return self . rootnode [EOL] [EOL] def addtoken ( self , type_ , value , start_pos , prefix ) : [EOL] [docstring] [EOL] ilabel = token_to_ilabel ( self . grammar , type_ , value ) [EOL] [EOL] [comment] [EOL] _gram = self . grammar [EOL] _labels = _gram . labels [EOL] _push = self . _push [EOL] _pop = self . _pop [EOL] _shift = self . _shift [EOL] while True : [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] arcs = states [ state ] [EOL] [comment] [EOL] for i , newstate in arcs : [EOL] t , v = _labels [ i ] [EOL] if ilabel == i : [EOL] [comment] [EOL] assert t < [number] [EOL] [comment] [EOL] _shift ( type_ , value , newstate , prefix , start_pos ) [EOL] [comment] [EOL] state = newstate [EOL] while states [ state ] == [ ( [number] , state ) ] : [EOL] _pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] return True [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] [comment] [EOL] return False [EOL] elif t >= [number] : [EOL] [comment] [EOL] itsdfa = _gram . dfas [ t ] [EOL] itsstates , itsfirst = itsdfa [EOL] if ilabel in itsfirst : [EOL] [comment] [EOL] _push ( t , itsdfa , newstate ) [EOL] break [comment] [EOL] else : [EOL] if ( [number] , state ) in arcs : [EOL] [comment] [EOL] _pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] raise InternalParseError ( [string] , type_ , value , start_pos ) [EOL] else : [EOL] self . error_recovery ( self . grammar , self . stack , arcs , type_ , value , start_pos , prefix , self . addtoken ) [EOL] break [EOL] [EOL] def _shift ( self , type_ , value , newstate , prefix , start_pos ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = self . convert_leaf ( self . grammar , type_ , value , prefix , start_pos ) [EOL] node [ - [number] ] . append ( newnode ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] [EOL] def _push ( self , type_ , newdfa , newstate ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = ( type_ , [ ] ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] self . stack . append ( ( newdfa , [number] , newnode ) ) [EOL] [EOL] def _pop ( self ) : [EOL] [docstring] [EOL] popdfa , popstate , ( type_ , children ) = self . stack . pop ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( children ) == [number] : [EOL] newnode = children [ [number] ] [EOL] else : [EOL] newnode = self . convert_node ( self . grammar , type_ , children ) [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . stack [ - [number] ] [ [number] ] [ [number] ] . append ( newnode ) [EOL] except IndexError : [EOL] [comment] [EOL] self . rootnode = newnode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pickle [EOL] import hashlib [EOL] [EOL] [EOL] [EOL] class Grammar ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bnf_text ) : [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] self . states = [ ] [EOL] self . dfas = { } [EOL] self . labels = [ ( [number] , [string] ) ] [EOL] self . keywords = { } [EOL] self . tokens = { } [EOL] self . symbol2label = { } [EOL] self . start = [number] [EOL] self . sha256 = hashlib . sha256 ( bnf_text . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] def dump ( self , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as f : [EOL] pickle . dump ( self . __dict__ , f , [number] ) [EOL] [EOL] def load ( self , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as f : [EOL] d = pickle . load ( f ) [EOL] self . __dict__ . update ( d ) [EOL] [EOL] def copy ( self ) : [EOL] [docstring] [EOL] new = self . __class__ ( ) [EOL] for dict_attr in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] setattr ( new , dict_attr , getattr ( self , dict_attr ) . copy ( ) ) [EOL] new . labels = self . labels [ : ] [EOL] new . states = self . states [ : ] [EOL] new . start = self . start [EOL] return new [EOL] [EOL] def report ( self ) : [EOL] [docstring] [EOL] from pprint import pprint [EOL] print ( [string] ) [EOL] pprint ( self . symbol2number ) [EOL] print ( [string] ) [EOL] pprint ( self . number2symbol ) [EOL] print ( [string] ) [EOL] pprint ( self . states ) [EOL] print ( [string] ) [EOL] pprint ( self . dfas ) [EOL] print ( [string] ) [EOL] pprint ( self . labels ) [EOL] print ( [string] , self . start ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] from jedi import settings [EOL] from jedi . _compatibility import FileNotFoundError [EOL] from jedi . parser . pgen2 . pgen import generate_grammar [EOL] from jedi . parser . python . parser import Parser , _remove_last_newline [EOL] from jedi . parser . python . diff import DiffParser [EOL] from jedi . parser . tokenize import generate_tokens [EOL] from jedi . parser . cache import parser_cache , load_module , save_module [EOL] from jedi . common import splitlines , source_to_unicode [EOL] [EOL] [EOL] _loaded_grammars = { } [EOL] [EOL] [EOL] def load_grammar ( version = None ) : [EOL] [docstring] [EOL] if version is None : [EOL] version = [string] [EOL] [EOL] if version in ( [string] , [string] ) : [EOL] version = [string] [EOL] elif version == [string] : [EOL] version = [string] [EOL] [EOL] file = [string] + version + [string] [EOL] [EOL] global _loaded_grammars [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , file ) [EOL] try : [EOL] return _loaded_grammars [ path ] [EOL] except KeyError : [EOL] try : [EOL] with open ( path ) as f : [EOL] bnf_text = f . read ( ) [EOL] grammar = generate_grammar ( bnf_text ) [EOL] return _loaded_grammars . setdefault ( path , grammar ) [EOL] except FileNotFoundError : [EOL] [comment] [EOL] return load_grammar ( ) [EOL] [EOL] [EOL] def parse ( code = None , path = None , grammar = None , error_recovery = True , start_symbol = [string] , cache = False , diff_cache = False ) : [EOL] [docstring] [EOL] if code is None and path is None : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if grammar is None : [EOL] grammar = load_grammar ( ) [EOL] [EOL] if cache and not code and path is not None : [EOL] [comment] [EOL] module_node = load_module ( grammar , path ) [EOL] if module_node is not None : [EOL] return module_node [EOL] [EOL] if code is None : [EOL] with open ( path , [string] ) as f : [EOL] code = source_to_unicode ( f . read ( ) ) [EOL] [EOL] if diff_cache and settings . fast_parser : [EOL] try : [EOL] module_cache_item = parser_cache [ path ] [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] lines = splitlines ( code , keepends = True ) [EOL] module_node = module_cache_item . node [EOL] old_lines = module_cache_item . lines [EOL] if old_lines == lines : [EOL] save_module ( grammar , path , module_node , lines , pickling = False ) [EOL] return module_node [EOL] [EOL] new_node = DiffParser ( grammar , module_node ) . update ( old_lines = old_lines , new_lines = lines ) [EOL] save_module ( grammar , path , new_node , lines , pickling = cache ) [EOL] return new_node [EOL] [EOL] added_newline = not code . endswith ( [string] ) [EOL] lines = tokenize_lines = splitlines ( code , keepends = True ) [EOL] if added_newline : [EOL] code += [string] [EOL] tokenize_lines = list ( tokenize_lines ) [EOL] tokenize_lines [ - [number] ] += [string] [EOL] tokenize_lines . append ( [string] ) [EOL] [EOL] tokens = generate_tokens ( tokenize_lines , use_exact_op_types = True ) [EOL] [EOL] p = Parser ( grammar , error_recovery = error_recovery , start_symbol = start_symbol ) [EOL] root_node = p . parse ( tokens = tokens ) [EOL] if added_newline : [EOL] _remove_last_newline ( root_node ) [EOL] [EOL] if cache or diff_cache : [EOL] save_module ( grammar , path , root_node , lines , pickling = cache ) [EOL] return root_node [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . _compatibility import utf8_repr , unicode [EOL] from jedi . parser . tree import Node , BaseNode , Leaf , ErrorNode , ErrorLeaf , search_ancestor [EOL] [EOL] [EOL] class DocstringMixin ( object ) : [EOL] __slots__ = ( ) [EOL] [EOL] def get_doc_node ( self ) : [EOL] [docstring] [EOL] if self . type == [string] : [EOL] node = self . children [ [number] ] [EOL] elif isinstance ( self , ClassOrFunc ) : [EOL] node = self . children [ self . children . index ( [string] ) + [number] ] [EOL] if node . type == [string] : [comment] [EOL] node = node . children [ [number] ] [comment] [EOL] else : [comment] [EOL] simple_stmt = self . parent [EOL] c = simple_stmt . parent . children [EOL] index = c . index ( simple_stmt ) [EOL] if not index : [EOL] return None [EOL] node = c [ index - [number] ] [EOL] [EOL] if node . type == [string] : [EOL] node = node . children [ [number] ] [EOL] if node . type == [string] : [EOL] return node [EOL] return None [EOL] [EOL] [EOL] class PythonMixin ( object ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] def get_definition ( self ) : [EOL] if self . type in ( [string] , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] scope = self [EOL] while scope . parent is not None : [EOL] parent = scope . parent [EOL] if isinstance ( scope , ( PythonNode , PythonLeaf ) ) and parent . type != [string] : [EOL] if scope . type == [string] : [EOL] try : [EOL] if scope . children [ [number] ] . type == [string] : [EOL] return scope . children [ [number] ] [EOL] except IndexError : [EOL] pass [EOL] scope = parent [EOL] else : [EOL] break [EOL] return scope [EOL] [EOL] def get_name_of_position ( self , position ) : [EOL] for c in self . children : [EOL] if isinstance ( c , Leaf ) : [EOL] if c . type == [string] and c . start_pos <= position <= c . end_pos : [EOL] return c [EOL] else : [EOL] result = c . get_name_of_position ( position ) [EOL] if result is not None : [EOL] return result [EOL] return None [EOL] [EOL] [EOL] class PythonLeaf ( Leaf , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class _LeafWithoutNewlines ( PythonLeaf ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] @ property def end_pos ( self ) : [EOL] return self . line , self . indent + len ( self . value ) [EOL] [EOL] [EOL] [comment] [EOL] class PythonBaseNode ( BaseNode , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class PythonNode ( Node , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class PythonErrorNode ( ErrorNode , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class PythonErrorLeaf ( ErrorLeaf , PythonMixin ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class EndMarker ( _LeafWithoutNewlines ) : [EOL] __slots__ = ( ) [EOL] type = [string] [EOL] [EOL] [EOL] class Newline ( PythonLeaf ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] type = [string] [EOL] [EOL] @ utf8_repr def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , repr ( self . value ) ) [EOL] [EOL] [EOL] class Name ( _LeafWithoutNewlines ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . value , self . line , self . indent ) [EOL] [EOL] def is_definition ( self ) : [EOL] if self . parent . type in ( [string] , [string] ) : [EOL] [comment] [EOL] return False [EOL] [EOL] stmt = self . get_definition ( ) [EOL] if stmt . type in ( [string] , [string] , [string] ) : [EOL] return self == stmt . name [EOL] elif stmt . type == [string] : [EOL] return self . start_pos < stmt . children [ [number] ] . start_pos [EOL] elif stmt . type == [string] : [EOL] return self . get_previous_sibling ( ) == [string] [EOL] else : [EOL] return stmt . type in ( [string] , [string] , [string] , [string] , [string] ) \ [EOL] and self in stmt . get_defined_names ( ) [EOL] [EOL] [EOL] class Literal ( PythonLeaf ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class Number ( Literal ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class String ( Literal ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class _StringComparisonMixin ( object ) : [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] if isinstance ( other , ( str , unicode ) ) : [EOL] return self . value == other [EOL] [EOL] return self is other [EOL] [EOL] def __ne__ ( self , other ) : [EOL] [docstring] [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] [EOL] class Operator ( _LeafWithoutNewlines , _StringComparisonMixin ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class Keyword ( _LeafWithoutNewlines , _StringComparisonMixin ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class Scope ( PythonBaseNode , DocstringMixin ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Scope , self ) . __init__ ( children ) [EOL] [EOL] def iter_funcdefs ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def iter_classdefs ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def iter_imports ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] , [string] ) [EOL] [EOL] def _search_in_scope ( self , * names ) : [EOL] def scan ( children ) : [EOL] for element in children : [EOL] if element . type in names : [EOL] yield element [EOL] if element . type in ( [string] , [string] , [string] ) or isinstance ( element , Flow ) : [EOL] for e in scan ( element . children ) : [EOL] yield e [EOL] [EOL] return scan ( self . children ) [EOL] [EOL] def get_suite ( self ) : [EOL] [docstring] [EOL] return self . children [ - [number] ] [EOL] [EOL] def __repr__ ( self ) : [EOL] try : [EOL] name = self . name . value [EOL] except AttributeError : [EOL] name = [string] [EOL] [EOL] return [string] % ( type ( self ) . __name__ , name , self . start_pos [ [number] ] , self . end_pos [ [number] ] ) [EOL] [EOL] [EOL] class Module ( Scope ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , ) [EOL] type = [string] [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Module , self ) . __init__ ( children ) [EOL] self . _used_names = None [EOL] [EOL] def iter_future_import_names ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for imp in self . iter_imports ( ) : [EOL] if imp . type == [string] and imp . level == [number] : [EOL] for path in imp . get_paths ( ) : [EOL] names = [ name . value for name in path ] [EOL] if len ( names ) == [number] and names [ [number] ] == [string] : [EOL] yield names [ [number] ] [EOL] [EOL] def has_explicit_absolute_import ( self ) : [EOL] [docstring] [EOL] for name in self . iter_future_import_names ( ) : [EOL] if name == [string] : [EOL] return True [EOL] return False [EOL] [EOL] def get_used_names ( self ) : [EOL] [docstring] [EOL] if self . _used_names is None : [EOL] [comment] [EOL] dct = { } [EOL] [EOL] def recurse ( node ) : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] if node . type == [string] : [EOL] arr = dct . setdefault ( node . value , [ ] ) [EOL] arr . append ( node ) [EOL] else : [EOL] for child in children : [EOL] recurse ( child ) [EOL] [EOL] recurse ( self ) [EOL] self . _used_names = dct [EOL] return self . _used_names [EOL] [EOL] [EOL] class Decorator ( PythonBaseNode ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class ClassOrFunc ( Scope ) : [EOL] __slots__ = ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . children [ [number] ] [EOL] [EOL] def get_decorators ( self ) : [EOL] [docstring] [EOL] decorated = self . parent [EOL] if decorated . type == [string] : [EOL] if decorated . children [ [number] ] . type == [string] : [EOL] return decorated . children [ [number] ] . children [EOL] else : [EOL] return decorated . children [ : [number] ] [EOL] else : [EOL] return [ ] [EOL] [EOL] [EOL] class Class ( ClassOrFunc ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Class , self ) . __init__ ( children ) [EOL] [EOL] def get_super_arglist ( self ) : [EOL] [docstring] [EOL] if self . children [ [number] ] != [string] : [comment] [EOL] return None [EOL] else : [EOL] if self . children [ [number] ] == [string] : [comment] [EOL] return None [EOL] else : [EOL] return self . children [ [number] ] [EOL] [EOL] [EOL] def _create_params ( parent , argslist_list ) : [EOL] [docstring] [EOL] def check_python2_nested_param ( node ) : [EOL] [docstring] [EOL] return node . type == [string] and node . children [ [number] ] == [string] [EOL] [EOL] try : [EOL] first = argslist_list [ [number] ] [EOL] except IndexError : [EOL] return [ ] [EOL] [EOL] if first . type in ( [string] , [string] ) : [EOL] if check_python2_nested_param ( first ) : [EOL] return [ first ] [EOL] else : [EOL] return [ Param ( [ first ] , parent ) ] [EOL] elif first == [string] : [EOL] return [ first ] [EOL] else : [comment] [EOL] children = first . children [EOL] new_children = [ ] [EOL] start = [number] [EOL] [comment] [EOL] for end , child in enumerate ( children + [ None ] , [number] ) : [EOL] if child is None or child == [string] : [EOL] param_children = children [ start : end ] [EOL] if param_children : [comment] [EOL] if check_python2_nested_param ( param_children [ [number] ] ) : [EOL] new_children += param_children [EOL] elif param_children [ [number] ] == [string] and param_children [ [number] ] == [string] : [EOL] new_children += param_children [EOL] else : [EOL] new_children . append ( Param ( param_children , parent ) ) [EOL] start = end [EOL] return new_children [EOL] [EOL] [EOL] class Function ( ClassOrFunc ) : [EOL] [docstring] [EOL] type = [string] [EOL] [EOL] def __init__ ( self , children ) : [EOL] super ( Function , self ) . __init__ ( children ) [EOL] parameters = self . children [ [number] ] [comment] [EOL] parameters . children [ [number] : - [number] ] = _create_params ( parameters , parameters . children [ [number] : - [number] ] ) [EOL] [EOL] def _get_param_nodes ( self ) : [EOL] return self . children [ [number] ] . children [EOL] [EOL] @ property def params ( self ) : [EOL] [docstring] [EOL] return [ p for p in self . _get_param_nodes ( ) if p . type == [string] ] [EOL] [EOL] @ property def name ( self ) : [EOL] return self . children [ [number] ] [comment] [EOL] [EOL] def iter_yield_exprs ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def iter_return_stmts ( self ) : [EOL] [docstring] [EOL] return self . _search_in_scope ( [string] ) [EOL] [EOL] def is_generator ( self ) : [EOL] [docstring] [EOL] return next ( self . iter_yield_exprs ( ) , None ) is not None [EOL] [EOL] @ property def annotation ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . children [ [number] ] == [string] : [EOL] return self . children [ [number] ] [EOL] assert self . children [ [number] ] == [string] [EOL] return None [EOL] except IndexError : [EOL] return None [EOL] [EOL] class Lambda ( Function ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , children ) : [EOL] [comment] [EOL] super ( Function , self ) . __init__ ( children ) [EOL] [comment] [EOL] self . children [ [number] : - [number] ] = _create_params ( self , self . children [ [number] : - [number] ] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] raise AttributeError ( [string] ) [EOL] [EOL] def _get_param_nodes ( self ) : [EOL] return self . children [ [number] : - [number] ] [EOL] [EOL] @ property def annotation ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . start_pos ) [EOL] [EOL] [EOL] class Flow ( PythonBaseNode ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class IfStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_test_nodes ( self ) : [EOL] [docstring] [EOL] for i , c in enumerate ( self . children ) : [EOL] if c in ( [string] , [string] ) : [EOL] yield self . children [ i + [number] ] [EOL] [EOL] def get_corresponding_test_node ( self , node ) : [EOL] [docstring] [EOL] start_pos = node . start_pos [EOL] for check_node in reversed ( list ( self . get_test_nodes ( ) ) ) : [EOL] if check_node . start_pos < start_pos : [EOL] if start_pos < check_node . end_pos : [EOL] return None [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] return check_node [EOL] [EOL] def is_node_after_else ( self , node ) : [EOL] [docstring] [EOL] for c in self . children : [EOL] if c == [string] : [EOL] if node . start_pos > c . start_pos : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class WhileStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class ForStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_testlist ( self ) : [EOL] [docstring] [EOL] return self . children [ [number] ] [EOL] [EOL] [EOL] class TryStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_except_clause_tests ( self ) : [EOL] [docstring] [EOL] for node in self . children : [EOL] [comment] [EOL] if node . type == [string] : [EOL] yield node . children [ [number] ] [EOL] elif node == [string] : [EOL] yield None [EOL] [EOL] [EOL] class WithStmt ( Flow ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] names = [ ] [EOL] for with_item in self . children [ [number] : - [number] : [number] ] : [EOL] [comment] [EOL] if with_item . type == [string] : [EOL] names += _defined_names ( with_item . children [ [number] ] ) [EOL] return names [EOL] [EOL] def get_context_manager_from_name ( self , name ) : [EOL] [comment] [EOL] node = name . parent [EOL] if node . type != [string] : [EOL] raise ValueError ( [string] ) [EOL] return node . children [ [number] ] [EOL] [EOL] [EOL] class Import ( PythonBaseNode ) : [EOL] __slots__ = ( ) [EOL] [EOL] def get_path_for_name ( self , name ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] name = self . _aliases ( ) [ name ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] for path in self . get_paths ( ) : [EOL] if name in path : [EOL] return path [ : path . index ( name ) + [number] ] [EOL] raise ValueError ( [string] ) [EOL] [EOL] def is_nested ( self ) : [EOL] return False [comment] [EOL] [EOL] def is_star_import ( self ) : [EOL] return self . children [ - [number] ] == [string] [EOL] [EOL] [EOL] class ImportFrom ( Import ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] return [ alias or name for name , alias in self . _as_name_tuples ( ) ] [EOL] [EOL] def _aliases ( self ) : [EOL] [docstring] [EOL] return dict ( ( alias , name ) for name , alias in self . _as_name_tuples ( ) if alias is not None ) [EOL] [EOL] def get_from_names ( self ) : [EOL] for n in self . children [ [number] : ] : [EOL] if n not in ( [string] , [string] ) : [EOL] break [EOL] if n . type == [string] : [comment] [EOL] return n . children [ : : [number] ] [EOL] elif n == [string] : [comment] [EOL] return [ ] [EOL] else : [comment] [EOL] return [ n ] [EOL] [EOL] @ property def level ( self ) : [EOL] [docstring] [EOL] level = [number] [EOL] for n in self . children [ [number] : ] : [EOL] if n in ( [string] , [string] ) : [EOL] level += len ( n . value ) [EOL] else : [EOL] break [EOL] return level [EOL] [EOL] def _as_name_tuples ( self ) : [EOL] last = self . children [ - [number] ] [EOL] if last == [string] : [EOL] last = self . children [ - [number] ] [EOL] elif last == [string] : [EOL] return [comment] [EOL] [EOL] if last . type == [string] : [EOL] as_names = last . children [ : : [number] ] [EOL] else : [EOL] as_names = [ last ] [EOL] for as_name in as_names : [EOL] if as_name . type == [string] : [EOL] yield as_name , None [EOL] else : [EOL] yield as_name . children [ : : [number] ] [comment] [EOL] [EOL] def get_paths ( self ) : [EOL] [docstring] [EOL] dotted = self . get_from_names ( ) [EOL] [EOL] if self . children [ - [number] ] == [string] : [EOL] return [ dotted ] [EOL] return [ dotted + [ name ] for name , alias in self . _as_name_tuples ( ) ] [EOL] [EOL] [EOL] class ImportName ( Import ) : [EOL] [docstring] [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] return [ alias or path [ [number] ] for path , alias in self . _dotted_as_names ( ) ] [EOL] [EOL] @ property def level ( self ) : [EOL] [docstring] [EOL] return [number] [comment] [EOL] [EOL] def get_paths ( self ) : [EOL] return [ path for path , alias in self . _dotted_as_names ( ) ] [EOL] [EOL] def _dotted_as_names ( self ) : [EOL] [docstring] [EOL] dotted_as_names = self . children [ [number] ] [EOL] if dotted_as_names . type == [string] : [EOL] as_names = dotted_as_names . children [ : : [number] ] [EOL] else : [EOL] as_names = [ dotted_as_names ] [EOL] [EOL] for as_name in as_names : [EOL] if as_name . type == [string] : [EOL] alias = as_name . children [ [number] ] [EOL] as_name = as_name . children [ [number] ] [EOL] else : [EOL] alias = None [EOL] if as_name . type == [string] : [EOL] yield [ as_name ] , alias [EOL] else : [EOL] [comment] [EOL] yield as_name . children [ : : [number] ] , alias [EOL] [EOL] def is_nested ( self ) : [EOL] [docstring] [EOL] return bool ( [ [number] for path , alias in self . _dotted_as_names ( ) if alias is None and len ( path ) > [number] ] ) [EOL] [EOL] def _aliases ( self ) : [EOL] [docstring] [EOL] return dict ( ( alias , path [ - [number] ] ) for path , alias in self . _dotted_as_names ( ) if alias is not None ) [EOL] [EOL] [EOL] class KeywordStatement ( PythonBaseNode ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] @ property def type ( self ) : [EOL] [docstring] [EOL] return [string] % self . keyword [EOL] [EOL] @ property def keyword ( self ) : [EOL] return self . children [ [number] ] . value [EOL] [EOL] [EOL] class AssertStmt ( KeywordStatement ) : [EOL] __slots__ = ( ) [EOL] [EOL] @ property def assertion ( self ) : [EOL] return self . children [ [number] ] [EOL] [EOL] [EOL] class GlobalStmt ( KeywordStatement ) : [EOL] __slots__ = ( ) [EOL] [EOL] def get_global_names ( self ) : [EOL] return self . children [ [number] : : [number] ] [EOL] [EOL] [EOL] class ReturnStmt ( KeywordStatement ) : [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] class YieldExpr ( PythonBaseNode ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] [EOL] def _defined_names ( current ) : [EOL] [docstring] [EOL] names = [ ] [EOL] if current . type in ( [string] , [string] , [string] ) : [EOL] for child in current . children [ : : [number] ] : [EOL] names += _defined_names ( child ) [EOL] elif current . type in ( [string] , [string] ) : [EOL] names += _defined_names ( current . children [ [number] ] ) [EOL] elif current . type in ( [string] , [string] ) : [EOL] if current . children [ - [number] ] != [string] : [comment] [EOL] trailer = current . children [ - [number] ] [EOL] if trailer . children [ [number] ] == [string] : [EOL] names . append ( trailer . children [ [number] ] ) [EOL] else : [EOL] names . append ( current ) [EOL] return names [EOL] [EOL] [EOL] class ExprStmt ( PythonBaseNode , DocstringMixin ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] names = [ ] [EOL] if self . children [ [number] ] . type == [string] : [EOL] names = _defined_names ( self . children [ [number] ] ) [EOL] return [ name for i in range ( [number] , len ( self . children ) - [number] , [number] ) if [string] in self . children [ i + [number] ] . value for name in _defined_names ( self . children [ i ] ) ] + names [EOL] [EOL] def get_rhs ( self ) : [EOL] [docstring] [EOL] return self . children [ - [number] ] [EOL] [EOL] def yield_operators ( self ) : [EOL] [docstring] [EOL] first = self . children [ [number] ] [EOL] if first . type == [string] : [EOL] if len ( first . children ) <= [number] : [EOL] return [comment] [EOL] [EOL] first = first . children [ [number] ] [EOL] yield first [EOL] [EOL] for operator in self . children [ [number] : : [number] ] : [EOL] yield operator [EOL] [EOL] [EOL] class Param ( PythonBaseNode ) : [EOL] [docstring] [EOL] type = [string] [EOL] [EOL] def __init__ ( self , children , parent ) : [EOL] super ( Param , self ) . __init__ ( children ) [EOL] self . parent = parent [EOL] for child in children : [EOL] child . parent = self [EOL] [EOL] @ property def star_count ( self ) : [EOL] [docstring] [EOL] first = self . children [ [number] ] [EOL] if first in ( [string] , [string] ) : [EOL] return len ( first . value ) [EOL] return [number] [EOL] [EOL] @ property def default ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . children [ int ( self . children [ [number] ] in ( [string] , [string] ) ) + [number] ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] @ property def annotation ( self ) : [EOL] [docstring] [EOL] tfpdef = self . _tfpdef ( ) [EOL] if tfpdef . type == [string] : [EOL] assert tfpdef . children [ [number] ] == [string] [EOL] assert len ( tfpdef . children ) == [number] [EOL] annotation = tfpdef . children [ [number] ] [EOL] return annotation [EOL] else : [EOL] return None [EOL] [EOL] def _tfpdef ( self ) : [EOL] [docstring] [EOL] offset = int ( self . children [ [number] ] in ( [string] , [string] ) ) [EOL] return self . children [ offset ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . _tfpdef ( ) . type == [string] : [EOL] return self . _tfpdef ( ) . children [ [number] ] [EOL] else : [EOL] return self . _tfpdef ( ) [EOL] [EOL] @ property def position_index ( self ) : [EOL] [docstring] [EOL] index = self . parent . children . index ( self ) [EOL] try : [EOL] keyword_only_index = self . parent . children . index ( [string] ) [EOL] if index > keyword_only_index : [EOL] [comment] [EOL] index -= [number] [EOL] except ValueError : [EOL] pass [EOL] return index - [number] [EOL] [EOL] def get_parent_function ( self ) : [EOL] [docstring] [EOL] return search_ancestor ( self , [string] , [string] ) [EOL] [EOL] def get_code ( self , normalized = False , include_prefix = True , include_comma = True ) : [EOL] [docstring] [EOL] if include_comma : [EOL] return super ( Param , self ) . get_code ( normalized , include_prefix ) [EOL] [EOL] children = self . children [EOL] if children [ - [number] ] == [string] : [EOL] children = children [ : - [number] ] [EOL] return self . _get_code_for_children ( children , normalized = False , include_prefix = include_prefix ) [EOL] [EOL] def __repr__ ( self ) : [EOL] default = [string] if self . default is None else [string] % self . default . get_code ( ) [EOL] return [string] % ( type ( self ) . __name__ , str ( self . _tfpdef ( ) ) + default ) [EOL] [EOL] [EOL] class CompFor ( PythonBaseNode ) : [EOL] type = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def get_defined_names ( self ) : [EOL] [docstring] [EOL] return _defined_names ( self . children [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , List , Tuple , Iterator [EOL] import typing_extensions [EOL] import difflib [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] import difflib [EOL] from collections import namedtuple [EOL] [EOL] from jedi . common import splitlines [EOL] from jedi . parser . python . parser import Parser , _remove_last_newline [EOL] from jedi . parser . python . tree import EndMarker [EOL] from jedi import debug [EOL] from jedi . parser . tokenize import ( generate_tokens , NEWLINE , TokenInfo , ENDMARKER , INDENT , DEDENT ) [EOL] [EOL] [EOL] def _get_last_line ( node_or_leaf ) : [EOL] last_leaf = node_or_leaf . get_last_leaf ( ) [EOL] if _ends_with_newline ( last_leaf ) : [EOL] return last_leaf . start_pos [ [number] ] [EOL] else : [EOL] return last_leaf . end_pos [ [number] ] [EOL] [EOL] [EOL] def _ends_with_newline ( leaf , suffix = [string] ) : [EOL] if leaf . type == [string] : [EOL] typ = leaf . original_type [EOL] else : [EOL] typ = leaf . type [EOL] [EOL] return typ == [string] or suffix . endswith ( [string] ) [EOL] [EOL] [EOL] def _flows_finished ( grammar , stack ) : [EOL] [docstring] [EOL] for dfa , newstate , ( symbol_number , nodes ) in stack : [EOL] if grammar . number2symbol [ symbol_number ] in ( [string] , [string] , [string] , [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def suite_or_file_input_is_valid ( grammar , stack ) : [EOL] if not _flows_finished ( grammar , stack ) : [EOL] return False [EOL] [EOL] for dfa , newstate , ( symbol_number , nodes ) in reversed ( stack ) : [EOL] if grammar . number2symbol [ symbol_number ] == [string] : [EOL] [comment] [EOL] return len ( nodes ) > [number] [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] [EOL] [EOL] def _is_flow_node ( node ) : [EOL] try : [EOL] value = node . children [ [number] ] . value [EOL] except AttributeError : [EOL] return False [EOL] return value in ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class _PositionUpdatingFinished ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def _update_positions ( nodes , line_offset , last_leaf ) : [EOL] for node in nodes : [EOL] try : [EOL] children = node . children [EOL] except AttributeError : [EOL] [comment] [EOL] node . line += line_offset [EOL] if node is last_leaf : [EOL] raise _PositionUpdatingFinished [EOL] else : [EOL] _update_positions ( children , line_offset , last_leaf ) [EOL] [EOL] [EOL] class DiffParser ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , grammar , module ) : [EOL] self . _grammar = grammar [EOL] self . _module = module [EOL] [EOL] def _reset ( self ) : [EOL] self . _copy_count = [number] [EOL] self . _parser_count = [number] [EOL] [EOL] self . _nodes_stack = _NodesStack ( self . _module ) [EOL] [EOL] def update ( self , old_lines , new_lines ) : [EOL] [docstring] [EOL] debug . speed ( [string] ) [EOL] [comment] [EOL] self . _module . _used_names = None [EOL] [EOL] self . _parser_lines_new = new_lines [EOL] self . _added_newline = False [EOL] if new_lines [ - [number] ] != [string] : [EOL] [comment] [EOL] [comment] [EOL] self . _parser_lines_new = list ( new_lines ) [EOL] self . _parser_lines_new [ - [number] ] += [string] [EOL] self . _parser_lines_new . append ( [string] ) [EOL] self . _added_newline = True [EOL] [EOL] self . _reset ( ) [EOL] [EOL] line_length = len ( new_lines ) [EOL] sm = difflib . SequenceMatcher ( None , old_lines , self . _parser_lines_new ) [EOL] opcodes = sm . get_opcodes ( ) [EOL] debug . speed ( [string] ) [EOL] debug . dbg ( [string] % ( len ( old_lines ) , line_length ) ) [EOL] [EOL] for operation , i1 , i2 , j1 , j2 in opcodes : [EOL] debug . dbg ( [string] , operation , i1 + [number] , i2 , j1 + [number] , j2 ) [EOL] [EOL] if j2 == line_length + int ( self . _added_newline ) : [EOL] [comment] [EOL] j2 -= [number] [EOL] [EOL] if operation == [string] : [EOL] line_offset = j1 - i1 [EOL] self . _copy_from_old_parser ( line_offset , i2 , j2 ) [EOL] elif operation == [string] : [EOL] self . _parse ( until_line = j2 ) [EOL] elif operation == [string] : [EOL] self . _parse ( until_line = j2 ) [EOL] else : [EOL] assert operation == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _nodes_stack . close ( ) [EOL] [EOL] if self . _added_newline : [EOL] _remove_last_newline ( self . _module ) [EOL] [EOL] [comment] [EOL] if debug . debug_function : [EOL] self . _enabled_debugging ( old_lines , new_lines ) [EOL] last_pos = self . _module . end_pos [ [number] ] [EOL] if last_pos != line_length : [EOL] current_lines = splitlines ( self . _module . get_code ( ) , keepends = True ) [EOL] diff = difflib . unified_diff ( current_lines , new_lines ) [EOL] raise Exception ( [string] % ( last_pos , line_length , [string] . join ( diff ) ) ) [EOL] [EOL] debug . speed ( [string] ) [EOL] return self . _module [EOL] [EOL] def _enabled_debugging ( self , old_lines , lines_new ) : [EOL] if self . _module . get_code ( ) != [string] . join ( lines_new ) : [EOL] debug . warning ( [string] , [string] . join ( old_lines ) , [string] . join ( lines_new ) ) [EOL] [EOL] def _copy_from_old_parser ( self , line_offset , until_line_old , until_line_new ) : [EOL] copied_nodes = [ None ] [EOL] [EOL] last_until_line = - [number] [EOL] while until_line_new > self . _nodes_stack . parsed_until_line : [EOL] parsed_until_line_old = self . _nodes_stack . parsed_until_line - line_offset [EOL] line_stmt = self . _get_old_line_stmt ( parsed_until_line_old + [number] ) [EOL] if line_stmt is None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _parse ( self . _nodes_stack . parsed_until_line + [number] ) [EOL] elif not copied_nodes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _parse ( until_line_new ) [EOL] else : [EOL] p_children = line_stmt . parent . children [EOL] index = p_children . index ( line_stmt ) [EOL] [EOL] copied_nodes = self . _nodes_stack . copy_nodes ( p_children [ index : ] , until_line_old , line_offset ) [EOL] [comment] [EOL] if copied_nodes : [EOL] self . _copy_count += [number] [EOL] [EOL] from_ = copied_nodes [ [number] ] . get_start_pos_of_prefix ( ) [ [number] ] + line_offset [EOL] to = self . _nodes_stack . parsed_until_line [EOL] [EOL] debug . dbg ( [string] , from_ , to ) [EOL] [comment] [EOL] [comment] [EOL] assert last_until_line != self . _nodes_stack . parsed_until_line or not copied_nodes , last_until_line [EOL] last_until_line = self . _nodes_stack . parsed_until_line [EOL] [EOL] def _get_old_line_stmt ( self , old_line ) : [EOL] leaf = self . _module . get_leaf_for_position ( ( old_line , [number] ) , include_prefixes = True ) [EOL] [EOL] if _ends_with_newline ( leaf ) : [EOL] leaf = leaf . get_next_leaf ( ) [EOL] if leaf . get_start_pos_of_prefix ( ) [ [number] ] == old_line : [EOL] node = leaf [EOL] while node . parent . type not in ( [string] , [string] ) : [EOL] node = node . parent [EOL] return node [EOL] [comment] [EOL] return None [EOL] [EOL] def _get_before_insertion_node ( self ) : [EOL] if self . _nodes_stack . is_empty ( ) : [EOL] return None [EOL] [EOL] line = self . _nodes_stack . parsed_until_line + [number] [EOL] node = self . _new_module . get_last_leaf ( ) [EOL] while True : [EOL] parent = node . parent [EOL] if parent . type in ( [string] , [string] ) : [EOL] assert node . end_pos [ [number] ] <= line [EOL] assert node . end_pos [ [number] ] == [number] or [string] in self . _prefix [EOL] return node [EOL] node = parent [EOL] [EOL] def _parse ( self , until_line ) : [EOL] [docstring] [EOL] last_until_line = [number] [EOL] while until_line > self . _nodes_stack . parsed_until_line : [EOL] node = self . _try_parse_part ( until_line ) [EOL] nodes = self . _get_children_nodes ( node ) [EOL] [comment] [EOL] [EOL] self . _nodes_stack . add_parsed_nodes ( nodes ) [EOL] debug . dbg ( [string] , nodes [ [number] ] . get_start_pos_of_prefix ( ) [ [number] ] , self . _nodes_stack . parsed_until_line , node . end_pos [ [number] ] - [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert last_until_line != self . _nodes_stack . parsed_until_line , last_until_line [EOL] last_until_line = self . _nodes_stack . parsed_until_line [EOL] [EOL] def _get_children_nodes ( self , node ) : [EOL] nodes = node . children [EOL] first_element = nodes [ [number] ] [EOL] [comment] [EOL] if first_element . type == [string] and first_element . original_type == [string] : [EOL] assert False , str ( nodes ) [EOL] [EOL] return nodes [EOL] [EOL] def _try_parse_part ( self , until_line ) : [EOL] [docstring] [EOL] self . _parser_count += [number] [EOL] [comment] [EOL] [comment] [EOL] parsed_until_line = self . _nodes_stack . parsed_until_line [EOL] lines_after = self . _parser_lines_new [ parsed_until_line : ] [EOL] [comment] [EOL] tokens = self . _diff_tokenize ( lines_after , until_line , line_offset = parsed_until_line ) [EOL] self . _active_parser = Parser ( self . _grammar , error_recovery = True ) [EOL] return self . _active_parser . parse ( tokens = tokens ) [EOL] [EOL] def _diff_tokenize ( self , lines , until_line , line_offset = [number] ) : [EOL] is_first_token = True [EOL] omitted_first_indent = False [EOL] indents = [ ] [EOL] tokens = generate_tokens ( lines , use_exact_op_types = True ) [EOL] stack = self . _active_parser . pgen_parser . stack [EOL] for typ , string , start_pos , prefix in tokens : [EOL] start_pos = start_pos [ [number] ] + line_offset , start_pos [ [number] ] [EOL] if typ == INDENT : [EOL] indents . append ( start_pos [ [number] ] ) [EOL] if is_first_token : [EOL] omitted_first_indent = True [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] is_first_token = False [EOL] continue [EOL] is_first_token = False [EOL] [EOL] if typ == DEDENT : [EOL] indents . pop ( ) [EOL] if omitted_first_indent and not indents : [EOL] [comment] [EOL] [comment] [EOL] typ , string , start_pos , prefix = next ( tokens ) [EOL] if [string] in prefix : [EOL] prefix = re . sub ( [string] , [string] , prefix ) [EOL] else : [EOL] prefix = [string] [EOL] yield TokenInfo ( ENDMARKER , [string] , ( start_pos [ [number] ] + line_offset , [number] ) , prefix ) [EOL] break [EOL] elif typ == NEWLINE and start_pos [ [number] ] >= until_line : [EOL] yield TokenInfo ( typ , string , start_pos , prefix ) [EOL] [comment] [EOL] if suite_or_file_input_is_valid ( self . _grammar , stack ) : [EOL] start_pos = start_pos [ [number] ] + [number] , [number] [EOL] while len ( indents ) > int ( omitted_first_indent ) : [EOL] indents . pop ( ) [EOL] yield TokenInfo ( DEDENT , [string] , start_pos , [string] ) [EOL] [EOL] yield TokenInfo ( ENDMARKER , [string] , start_pos , [string] ) [EOL] break [EOL] else : [EOL] continue [EOL] [EOL] yield TokenInfo ( typ , string , start_pos , prefix ) [EOL] [EOL] [EOL] class _NodesStackNode ( object ) : [EOL] ChildrenGroup = namedtuple ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , tree_node , parent = None ) : [EOL] self . tree_node = tree_node [EOL] self . children_groups = [ ] [EOL] self . parent = parent [EOL] [EOL] def close ( self ) : [EOL] children = [ ] [EOL] for children_part , line_offset , last_line_offset_leaf in self . children_groups : [EOL] if line_offset != [number] : [EOL] try : [EOL] _update_positions ( children_part , line_offset , last_line_offset_leaf ) [EOL] except _PositionUpdatingFinished : [EOL] pass [EOL] children += children_part [EOL] self . tree_node . children = children [EOL] [comment] [EOL] for node in children : [EOL] node . parent = self . tree_node [EOL] [EOL] def add ( self , children , line_offset = [number] , last_line_offset_leaf = None ) : [EOL] group = self . ChildrenGroup ( children , line_offset , last_line_offset_leaf ) [EOL] self . children_groups . append ( group ) [EOL] [EOL] def get_last_line ( self , suffix ) : [EOL] line = [number] [EOL] if self . children_groups : [EOL] children_group = self . children_groups [ - [number] ] [EOL] last_leaf = children_group . children [ - [number] ] . get_last_leaf ( ) [EOL] line = last_leaf . end_pos [ [number] ] [EOL] [EOL] [comment] [EOL] offset = children_group . line_offset [EOL] if offset : [EOL] [comment] [EOL] [comment] [EOL] if last_leaf . line <= children_group . last_line_offset_leaf . line : [EOL] line += children_group . line_offset [EOL] [EOL] [comment] [EOL] [comment] [EOL] if _ends_with_newline ( last_leaf , suffix ) : [EOL] line -= [number] [EOL] line += suffix . count ( [string] ) [EOL] return line [EOL] [EOL] [EOL] class _NodesStack ( object ) : [EOL] endmarker_type = [string] [EOL] [EOL] def __init__ ( self , module ) : [EOL] [comment] [EOL] self . _tos = self . _base_node = _NodesStackNode ( module ) [EOL] self . _module = module [EOL] self . _last_prefix = [string] [EOL] self . prefix = [string] [EOL] [EOL] def is_empty ( self ) : [EOL] return not self . _base_node . children [EOL] [EOL] @ property def parsed_until_line ( self ) : [EOL] return self . _tos . get_last_line ( self . prefix ) [EOL] [EOL] def _get_insertion_node ( self , indentation_node ) : [EOL] indentation = indentation_node . start_pos [ [number] ] [EOL] [EOL] [comment] [EOL] node = self . _tos [EOL] while True : [EOL] tree_node = node . tree_node [EOL] if tree_node . type == [string] : [EOL] [comment] [EOL] node_indentation = tree_node . children [ [number] ] . start_pos [ [number] ] [EOL] [EOL] if indentation >= node_indentation : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return node [EOL] [EOL] elif tree_node . type == [string] : [EOL] return node [EOL] [EOL] node = self . _close_tos ( ) [EOL] [EOL] def _close_tos ( self ) : [EOL] self . _tos . close ( ) [EOL] self . _tos = self . _tos . parent [EOL] return self . _tos [EOL] [EOL] def add_parsed_nodes ( self , tree_nodes ) : [EOL] tree_nodes = self . _remove_endmarker ( tree_nodes ) [EOL] if not tree_nodes : [EOL] return [EOL] [EOL] assert tree_nodes [ [number] ] . type != [string] [EOL] [EOL] node = self . _get_insertion_node ( tree_nodes [ [number] ] ) [EOL] assert node . tree_node . type in ( [string] , [string] ) [EOL] node . add ( tree_nodes ) [EOL] self . _update_tos ( tree_nodes [ - [number] ] ) [EOL] [EOL] def _remove_endmarker ( self , tree_nodes ) : [EOL] [docstring] [EOL] last_leaf = tree_nodes [ - [number] ] . get_last_leaf ( ) [EOL] is_endmarker = last_leaf . type == self . endmarker_type [EOL] self . _last_prefix = [string] [EOL] if is_endmarker : [EOL] try : [EOL] separation = last_leaf . prefix . rindex ( [string] ) [EOL] except ValueError : [EOL] pass [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] last_leaf . prefix , self . _last_prefix = last_leaf . prefix [ : separation + [number] ] , last_leaf . prefix [ separation + [number] : ] [EOL] [EOL] first_leaf = tree_nodes [ [number] ] . get_first_leaf ( ) [EOL] first_leaf . prefix = self . prefix + first_leaf . prefix [EOL] self . prefix = [string] [EOL] [EOL] if is_endmarker : [EOL] self . prefix = last_leaf . prefix [EOL] [EOL] tree_nodes = tree_nodes [ : - [number] ] [EOL] [EOL] return tree_nodes [EOL] [EOL] def copy_nodes ( self , tree_nodes , until_line , line_offset ) : [EOL] [docstring] [EOL] tos = self . _get_insertion_node ( tree_nodes [ [number] ] ) [EOL] [EOL] new_nodes , self . _tos = self . _copy_nodes ( tos , tree_nodes , until_line , line_offset ) [EOL] return new_nodes [EOL] [EOL] def _copy_nodes ( self , tos , nodes , until_line , line_offset ) : [EOL] new_nodes = [ ] [EOL] [EOL] new_tos = tos [EOL] for node in nodes : [EOL] if node . type == [string] : [EOL] [comment] [EOL] break [EOL] [EOL] if node . start_pos [ [number] ] > until_line : [EOL] break [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if _get_last_line ( node ) > until_line : [EOL] [comment] [EOL] if node . type in ( [string] , [string] ) and node . children [ - [number] ] . type == [string] : [EOL] new_nodes . append ( node ) [EOL] break [EOL] [EOL] new_nodes . append ( node ) [EOL] [EOL] if not new_nodes : [EOL] return [ ] , tos [EOL] [EOL] last_node = new_nodes [ - [number] ] [EOL] line_offset_index = - [number] [EOL] if last_node . type in ( [string] , [string] ) : [EOL] suite = last_node . children [ - [number] ] [EOL] if suite . type == [string] : [EOL] suite_tos = _NodesStackNode ( suite ) [EOL] [comment] [EOL] [comment] [EOL] suite_nodes , recursive_tos = self . _copy_nodes ( suite_tos , suite . children , until_line , line_offset ) [EOL] if len ( suite_nodes ) < [number] : [EOL] [comment] [EOL] new_nodes . pop ( ) [EOL] else : [EOL] suite_tos . parent = tos [EOL] new_tos = recursive_tos [EOL] line_offset_index = - [number] [EOL] [EOL] elif ( new_nodes [ - [number] ] . type in ( [string] , [string] ) or _is_flow_node ( new_nodes [ - [number] ] ) ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] new_nodes . pop ( ) [EOL] while new_nodes : [EOL] last_node = new_nodes [ - [number] ] [EOL] if last_node . get_last_leaf ( ) . type == [string] : [EOL] break [EOL] new_nodes . pop ( ) [EOL] [EOL] if new_nodes : [EOL] try : [EOL] last_line_offset_leaf = new_nodes [ line_offset_index ] . get_last_leaf ( ) [EOL] except IndexError : [EOL] line_offset = [number] [EOL] [comment] [EOL] [comment] [EOL] last_line_offset_leaf = None [EOL] tos . add ( new_nodes , line_offset , last_line_offset_leaf ) [EOL] return new_nodes , new_tos [EOL] [EOL] def _update_tos ( self , tree_node ) : [EOL] if tree_node . type in ( [string] , [string] ) : [EOL] self . _tos = _NodesStackNode ( tree_node , self . _tos ) [EOL] self . _tos . add ( list ( tree_node . children ) ) [EOL] self . _update_tos ( tree_node . children [ - [number] ] ) [EOL] elif tree_node . type in ( [string] , [string] ) : [EOL] self . _update_tos ( tree_node . children [ - [number] ] ) [EOL] [EOL] def close ( self ) : [EOL] while self . _tos is not None : [EOL] self . _close_tos ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] last_leaf = self . _module . get_last_leaf ( ) [EOL] end_pos = list ( last_leaf . end_pos ) [EOL] except IndexError : [EOL] end_pos = [ [number] , [number] ] [EOL] lines = splitlines ( self . prefix ) [EOL] assert len ( lines ) > [number] [EOL] if len ( lines ) == [number] : [EOL] end_pos [ [number] ] += len ( lines [ [number] ] ) [EOL] else : [EOL] end_pos [ [number] ] += len ( lines ) - [number] [EOL] end_pos [ [number] ] = len ( lines [ - [number] ] ) [EOL] [EOL] endmarker = EndMarker ( [string] , tuple ( end_pos ) , self . prefix + self . _last_prefix ) [EOL] endmarker . parent = self . _module [EOL] self . _module . children . append ( endmarker ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $difflib.SequenceMatcher[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 $difflib.SequenceMatcher[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List , Tuple , Any [EOL] import typing [EOL] from jedi . parser . python import tree [EOL] from jedi . parser import tokenize [EOL] from jedi . parser . token import ( DEDENT , INDENT , ENDMARKER , NEWLINE , NUMBER , STRING , tok_name ) [EOL] from jedi . parser . parser import BaseParser [EOL] from jedi . common import splitlines [EOL] [EOL] [EOL] class Parser ( BaseParser ) : [EOL] [docstring] [EOL] [EOL] node_map = { [string] : tree . ExprStmt , [string] : tree . Class , [string] : tree . Function , [string] : tree . Module , [string] : tree . ImportName , [string] : tree . ImportFrom , [string] : tree . KeywordStatement , [string] : tree . KeywordStatement , [string] : tree . ReturnStmt , [string] : tree . KeywordStatement , [string] : tree . YieldExpr , [string] : tree . KeywordStatement , [string] : tree . KeywordStatement , [string] : tree . GlobalStmt , [string] : tree . KeywordStatement , [string] : tree . KeywordStatement , [string] : tree . AssertStmt , [string] : tree . IfStmt , [string] : tree . WithStmt , [string] : tree . ForStmt , [string] : tree . WhileStmt , [string] : tree . TryStmt , [string] : tree . CompFor , [string] : tree . Decorator , [string] : tree . Lambda , [string] : tree . Lambda , [string] : tree . Lambda , } [EOL] default_node = tree . PythonNode [EOL] [EOL] def __init__ ( self , grammar , error_recovery = True , start_symbol = [string] ) : [EOL] super ( Parser , self ) . __init__ ( grammar , start_symbol , error_recovery = error_recovery ) [EOL] [EOL] self . syntax_errors = [ ] [EOL] self . _omit_dedent_list = [ ] [EOL] self . _indent_counter = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def parse ( self , tokens ) : [EOL] if self . _error_recovery : [EOL] if self . _start_symbol != [string] : [EOL] raise NotImplementedError [EOL] [EOL] tokens = self . _recovery_tokenize ( tokens ) [EOL] [EOL] node = super ( Parser , self ) . parse ( tokens ) [EOL] [EOL] if self . _start_symbol == [string] != node . type : [EOL] [comment] [EOL] [comment] [EOL] node = self . convert_node ( self . _grammar , self . _grammar . symbol2number [ [string] ] , [ node ] ) [EOL] [EOL] return node [EOL] [EOL] def convert_node ( self , grammar , type , children ) : [EOL] [docstring] [EOL] [comment] [EOL] symbol = grammar . number2symbol [ type ] [EOL] try : [EOL] return self . node_map [ symbol ] ( children ) [EOL] except KeyError : [EOL] if symbol == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] children = [ children [ [number] ] ] + children [ [number] : - [number] ] [EOL] return self . default_node ( symbol , children ) [EOL] [EOL] def convert_leaf ( self , grammar , type , value , prefix , start_pos ) : [EOL] [comment] [EOL] if type == tokenize . NAME : [EOL] if value in grammar . keywords : [EOL] return tree . Keyword ( value , start_pos , prefix ) [EOL] else : [EOL] return tree . Name ( value , start_pos , prefix ) [EOL] elif type == STRING : [EOL] return tree . String ( value , start_pos , prefix ) [EOL] elif type == NUMBER : [EOL] return tree . Number ( value , start_pos , prefix ) [EOL] elif type == NEWLINE : [EOL] return tree . Newline ( value , start_pos , prefix ) [EOL] elif type == ENDMARKER : [EOL] return tree . EndMarker ( value , start_pos , prefix ) [EOL] else : [EOL] return tree . Operator ( value , start_pos , prefix ) [EOL] [EOL] def error_recovery ( self , grammar , stack , arcs , typ , value , start_pos , prefix , add_token_callback ) : [EOL] [docstring] [EOL] if not self . _error_recovery : [EOL] return super ( Parser , self ) . error_recovery ( grammar , stack , arcs , typ , value , start_pos , prefix , add_token_callback ) [EOL] [EOL] def current_suite ( stack ) : [EOL] [comment] [EOL] [comment] [EOL] for index , ( dfa , state , ( type_ , nodes ) ) in reversed ( list ( enumerate ( stack ) ) ) : [EOL] [comment] [EOL] symbol = grammar . number2symbol [ type_ ] [EOL] if symbol == [string] : [EOL] break [EOL] elif symbol == [string] and len ( nodes ) > [number] : [EOL] [comment] [EOL] break [EOL] return index , symbol , nodes [EOL] [EOL] index , symbol , nodes = current_suite ( stack ) [EOL] [EOL] [comment] [EOL] if self . _stack_removal ( grammar , stack , arcs , index + [number] , value , start_pos ) : [EOL] add_token_callback ( typ , value , start_pos , prefix ) [EOL] else : [EOL] if typ == INDENT : [EOL] [comment] [EOL] [comment] [EOL] self . _omit_dedent_list . append ( self . _indent_counter ) [EOL] else : [EOL] error_leaf = tree . PythonErrorLeaf ( tok_name [ typ ] . lower ( ) , value , start_pos , prefix ) [EOL] stack [ - [number] ] [ [number] ] [ [number] ] . append ( error_leaf ) [EOL] [EOL] def _stack_removal ( self , grammar , stack , arcs , start_index , value , start_pos ) : [EOL] failed_stack = [ ] [EOL] found = False [EOL] all_nodes = [ ] [EOL] for dfa , state , ( typ , nodes ) in stack [ start_index : ] : [EOL] if nodes : [EOL] found = True [EOL] if found : [EOL] symbol = grammar . number2symbol [ typ ] [EOL] failed_stack . append ( ( symbol , nodes ) ) [EOL] all_nodes += nodes [EOL] if failed_stack : [EOL] stack [ start_index - [number] ] [ [number] ] [ [number] ] . append ( tree . PythonErrorNode ( all_nodes ) ) [EOL] [EOL] stack [ start_index : ] = [ ] [EOL] return failed_stack [EOL] [EOL] def _recovery_tokenize ( self , tokens ) : [EOL] for typ , value , start_pos , prefix in tokens : [EOL] [comment] [EOL] if typ == DEDENT : [EOL] [comment] [EOL] [comment] [EOL] o = self . _omit_dedent_list [EOL] if o and o [ - [number] ] == self . _indent_counter : [EOL] o . pop ( ) [EOL] continue [EOL] [EOL] self . _indent_counter -= [number] [EOL] elif typ == INDENT : [EOL] self . _indent_counter += [number] [EOL] [EOL] yield typ , value , start_pos , prefix [EOL] [EOL] [EOL] def _remove_last_newline ( node ) : [EOL] endmarker = node . children [ - [number] ] [EOL] [comment] [EOL] [comment] [EOL] prefix = endmarker . prefix [EOL] leaf = endmarker . get_previous_leaf ( ) [EOL] if prefix : [EOL] text = prefix [EOL] else : [EOL] if leaf is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] text = leaf . value [EOL] [EOL] if not text . endswith ( [string] ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] text = text [ : - [number] ] [EOL] if prefix : [EOL] endmarker . prefix = text [EOL] [EOL] if leaf is None : [EOL] end_pos = ( [number] , [number] ) [EOL] else : [EOL] end_pos = leaf . end_pos [EOL] [EOL] lines = splitlines ( text , keepends = True ) [EOL] if len ( lines ) == [number] : [EOL] end_pos = end_pos [ [number] ] , end_pos [ [number] ] + len ( lines [ [number] ] ) [EOL] else : [EOL] end_pos = end_pos [ [number] ] + len ( lines ) - [number] , len ( lines [ - [number] ] ) [EOL] endmarker . start_pos = end_pos [EOL] else : [EOL] leaf . value = text [EOL] endmarker . start_pos = leaf . end_pos [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Type , Match , List , Dict [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] from collections import namedtuple [EOL] [EOL] from jedi . _compatibility import u [EOL] from jedi . evaluate . helpers import evaluate_call_of_leaf [EOL] from jedi . parser . python . parser import Parser [EOL] from jedi . parser . python import tree [EOL] from jedi . parser import tokenize [EOL] from jedi . cache import time_cache [EOL] from jedi import common [EOL] [EOL] [EOL] CompletionParts = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def sorted_definitions ( defs ) : [EOL] [comment] [EOL] return sorted ( defs , key = lambda x : ( x . module_path or [string] , x . line or [number] , x . column or [number] ) ) [EOL] [EOL] [EOL] def get_on_completion_name ( module_node , lines , position ) : [EOL] leaf = module_node . get_leaf_for_position ( position ) [EOL] if leaf is None or leaf . type in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] line = lines [ position [ [number] ] - [number] ] [EOL] [comment] [EOL] return re . search ( [string] , line [ : position [ [number] ] ] ) . group ( [number] ) [EOL] elif leaf . type not in ( [string] , [string] ) : [EOL] return [string] [EOL] [EOL] return leaf . value [ : position [ [number] ] - leaf . start_pos [ [number] ] ] [EOL] [EOL] [EOL] def _get_code ( code_lines , start_pos , end_pos ) : [EOL] [comment] [EOL] lines = code_lines [ start_pos [ [number] ] - [number] : end_pos [ [number] ] ] [EOL] [comment] [EOL] lines [ - [number] ] = lines [ - [number] ] [ : end_pos [ [number] ] ] [EOL] [comment] [EOL] lines [ [number] ] = lines [ [number] ] [ start_pos [ [number] ] : ] [EOL] return [string] . join ( lines ) [EOL] [EOL] [EOL] class OnErrorLeaf ( Exception ) : [EOL] @ property def error_leaf ( self ) : [EOL] return self . args [ [number] ] [EOL] [EOL] [EOL] def _is_on_comment ( leaf , position ) : [EOL] comment_lines = common . splitlines ( leaf . prefix ) [EOL] difference = leaf . start_pos [ [number] ] - position [ [number] ] [EOL] prefix_start_pos = leaf . get_start_pos_of_prefix ( ) [EOL] if difference == [number] : [EOL] indent = leaf . start_pos [ [number] ] [EOL] elif position [ [number] ] == prefix_start_pos [ [number] ] : [EOL] indent = prefix_start_pos [ [number] ] [EOL] else : [EOL] indent = [number] [EOL] line = comment_lines [ - difference - [number] ] [ : position [ [number] ] - indent ] [EOL] return [string] in line [EOL] [EOL] [EOL] def _get_code_for_stack ( code_lines , module_node , position ) : [EOL] leaf = module_node . get_leaf_for_position ( position , include_prefixes = True ) [EOL] [comment] [EOL] [comment] [EOL] if leaf . start_pos >= position : [EOL] if _is_on_comment ( leaf , position ) : [EOL] return u ( [string] ) [EOL] [EOL] [comment] [EOL] leaf = leaf . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return u ( [string] ) [comment] [EOL] [EOL] is_after_newline = leaf . type == [string] [EOL] while leaf . type == [string] : [EOL] leaf = leaf . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return u ( [string] ) [EOL] [EOL] if leaf . type == [string] or leaf . type == [string] : [EOL] if leaf . start_pos [ [number] ] < position [ [number] ] : [EOL] [comment] [EOL] return u ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] raise OnErrorLeaf ( leaf ) [EOL] else : [EOL] if leaf == [string] : [EOL] user_stmt = leaf . parent [EOL] else : [EOL] user_stmt = leaf . get_definition ( ) [EOL] if user_stmt . parent . type == [string] : [EOL] user_stmt = user_stmt . parent [EOL] [EOL] if is_after_newline : [EOL] if user_stmt . start_pos [ [number] ] > position [ [number] ] : [EOL] [comment] [EOL] [comment] [EOL] return u ( [string] ) [EOL] [EOL] [comment] [EOL] return _get_code ( code_lines , user_stmt . get_start_pos_of_prefix ( ) , position ) [EOL] [EOL] [EOL] def get_stack_at_position ( grammar , code_lines , module_node , pos ) : [EOL] [docstring] [EOL] class EndMarkerReached ( Exception ) : [EOL] pass [EOL] [EOL] def tokenize_without_endmarker ( code ) : [EOL] tokens = tokenize . source_tokens ( code , use_exact_op_types = True ) [EOL] for token_ in tokens : [EOL] if token_ . string == safeword : [EOL] raise EndMarkerReached ( ) [EOL] else : [EOL] yield token_ [EOL] [EOL] code = _get_code_for_stack ( code_lines , module_node , pos ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] safeword = [string] [EOL] code = code + safeword [EOL] [EOL] p = Parser ( grammar , error_recovery = True ) [EOL] try : [EOL] p . parse ( tokens = tokenize_without_endmarker ( code ) ) [EOL] except EndMarkerReached : [EOL] return Stack ( p . pgen_parser . stack ) [EOL] raise SystemError ( [string] ) [EOL] [EOL] [EOL] class Stack ( list ) : [EOL] def get_node_names ( self , grammar ) : [EOL] for dfa , state , ( node_number , nodes ) in self : [EOL] yield grammar . number2symbol [ node_number ] [EOL] [EOL] def get_nodes ( self ) : [EOL] for dfa , state , ( node_number , nodes ) in self : [EOL] for node in nodes : [EOL] yield node [EOL] [EOL] [EOL] def get_possible_completion_types ( grammar , stack ) : [EOL] def add_results ( label_index ) : [EOL] try : [EOL] grammar_labels . append ( inversed_tokens [ label_index ] ) [EOL] except KeyError : [EOL] try : [EOL] keywords . append ( inversed_keywords [ label_index ] ) [EOL] except KeyError : [EOL] t , v = grammar . labels [ label_index ] [EOL] assert t >= [number] [EOL] [comment] [EOL] inversed_keywords [EOL] itsdfa = grammar . dfas [ t ] [EOL] itsstates , itsfirst = itsdfa [EOL] for first_label_index in itsfirst . keys ( ) : [EOL] add_results ( first_label_index ) [EOL] [EOL] inversed_keywords = dict ( ( v , k ) for k , v in grammar . keywords . items ( ) ) [EOL] inversed_tokens = dict ( ( v , k ) for k , v in grammar . tokens . items ( ) ) [EOL] [EOL] keywords = [ ] [EOL] grammar_labels = [ ] [EOL] [EOL] def scan_stack ( index ) : [EOL] dfa , state , node = stack [ index ] [EOL] states , first = dfa [EOL] arcs = states [ state ] [EOL] [EOL] for label_index , new_state in arcs : [EOL] if label_index == [number] : [EOL] [comment] [EOL] scan_stack ( index - [number] ) [EOL] else : [EOL] add_results ( label_index ) [EOL] [EOL] scan_stack ( - [number] ) [EOL] [EOL] return keywords , grammar_labels [EOL] [EOL] [EOL] def evaluate_goto_definition ( evaluator , context , leaf ) : [EOL] if leaf . type == [string] : [EOL] [comment] [EOL] [comment] [EOL] return evaluator . goto_definitions ( context , leaf ) [EOL] [EOL] parent = leaf . parent [EOL] if parent . type == [string] : [EOL] return context . eval_node ( leaf . parent ) [EOL] elif parent . type == [string] : [EOL] return evaluate_call_of_leaf ( context , leaf ) [EOL] elif isinstance ( leaf , tree . Literal ) : [EOL] return context . evaluator . eval_atom ( context , leaf ) [EOL] return [ ] [EOL] [EOL] [EOL] CallSignatureDetails = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def _get_index_and_key ( nodes , position ) : [EOL] [docstring] [EOL] nodes_before = [ c for c in nodes if c . start_pos < position ] [EOL] if nodes_before [ - [number] ] . type == [string] : [EOL] nodes_before = [ c for c in nodes_before [ - [number] ] . children if c . start_pos < position ] [EOL] [EOL] key_str = None [EOL] [EOL] if nodes_before : [EOL] last = nodes_before [ - [number] ] [EOL] if last . type == [string] and last . children [ [number] ] . end_pos <= position : [EOL] [comment] [EOL] key_str = last . children [ [number] ] . value [EOL] elif last == [string] : [EOL] key_str = nodes_before [ - [number] ] . value [EOL] [EOL] return nodes_before . count ( [string] ) , key_str [EOL] [EOL] [EOL] def _get_call_signature_details_from_error_node ( node , position ) : [EOL] for index , element in reversed ( list ( enumerate ( node . children ) ) ) : [EOL] [comment] [EOL] if element == [string] and element . end_pos <= position and index > [number] : [EOL] [comment] [EOL] [comment] [EOL] children = node . children [ index : ] [EOL] name = element . get_previous_leaf ( ) [EOL] if name is None : [EOL] continue [EOL] if name . type == [string] or name . parent . type in ( [string] , [string] ) : [EOL] return CallSignatureDetails ( element , * _get_index_and_key ( children , position ) ) [EOL] [EOL] [EOL] def get_call_signature_details ( module , position ) : [EOL] leaf = module . get_leaf_for_position ( position , include_prefixes = True ) [EOL] if leaf . start_pos >= position : [EOL] [comment] [EOL] leaf = leaf . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return None [EOL] [EOL] if leaf == [string] : [EOL] if leaf . end_pos == position : [EOL] leaf = leaf . get_next_leaf ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] node = leaf . parent [EOL] while node is not None : [EOL] if node . type in ( [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] [EOL] for n in node . children [ : : - [number] ] : [EOL] if n . start_pos < position and n . type == [string] : [EOL] result = _get_call_signature_details_from_error_node ( n , position ) [EOL] if result is not None : [EOL] return result [EOL] [EOL] if node . type == [string] and node . children [ [number] ] == [string] : [EOL] leaf = node . get_previous_leaf ( ) [EOL] if leaf is None : [EOL] return None [EOL] return CallSignatureDetails ( node . children [ [number] ] , * _get_index_and_key ( node . children , position ) ) [EOL] [EOL] node = node . parent [EOL] [EOL] return None [EOL] [EOL] [EOL] @ time_cache ( [string] ) def cache_call_signatures ( evaluator , context , bracket_leaf , code_lines , user_pos ) : [EOL] [docstring] [EOL] index = user_pos [ [number] ] - [number] [EOL] [EOL] before_cursor = code_lines [ index ] [ : user_pos [ [number] ] ] [EOL] other_lines = code_lines [ bracket_leaf . start_pos [ [number] ] : index ] [EOL] whole = [string] . join ( other_lines + [ before_cursor ] ) [EOL] before_bracket = re . match ( [string] , whole , re . DOTALL ) [EOL] [EOL] module_path = context . get_root_context ( ) . py__file__ ( ) [EOL] if module_path is None : [EOL] yield None [comment] [EOL] else : [EOL] yield ( module_path , before_bracket , bracket_leaf . start_pos ) [EOL] yield evaluate_goto_definition ( evaluator , context , bracket_leaf . get_previous_leaf ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CompletionParts]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CallSignatureDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CallSignatureDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[CallSignatureDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import jedi . utils [EOL] from jedi import __version__ as __jedi_version__ [EOL] [EOL] print ( [string] % __jedi_version__ ) [EOL] jedi . utils . setup_readline ( ) [EOL] [EOL] del jedi [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] from jedi . api import classes [EOL] from jedi . parser . python import tree [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate . filters import TreeNameDefinition [EOL] from jedi . evaluate . representation import ModuleContext [EOL] [EOL] [EOL] def compare_contexts ( c1 , c2 ) : [EOL] return c1 == c2 or ( c1 [ [number] ] == c2 [ [number] ] and c1 [ [number] ] . tree_node == c2 [ [number] ] . tree_node ) [EOL] [EOL] [EOL] def usages ( evaluator , definition_names , mods ) : [EOL] [docstring] [EOL] def resolve_names ( definition_names ) : [EOL] for name in definition_names : [EOL] if name . api_type == [string] : [EOL] found = False [EOL] for context in name . infer ( ) : [EOL] if isinstance ( context , ModuleContext ) : [EOL] found = True [EOL] yield context . name [EOL] if not found : [EOL] yield name [EOL] else : [EOL] yield name [EOL] [EOL] def compare_array ( definition_names ) : [EOL] [docstring] [EOL] return [ ( name . get_root_context ( ) , name . start_pos ) for name in resolve_names ( definition_names ) ] [EOL] [EOL] search_name = list ( definition_names ) [ [number] ] . string_name [EOL] compare_definitions = compare_array ( definition_names ) [EOL] mods = mods | set ( [ d . get_root_context ( ) for d in definition_names ] ) [EOL] definition_names = set ( resolve_names ( definition_names ) ) [EOL] for m in imports . get_modules_containing_name ( evaluator , mods , search_name ) : [EOL] if isinstance ( m , ModuleContext ) : [EOL] for name_node in m . tree_node . get_used_names ( ) . get ( search_name , [ ] ) : [EOL] context = evaluator . create_context ( m , name_node ) [EOL] result = evaluator . goto ( context , name_node ) [EOL] if any ( compare_contexts ( c1 , c2 ) for c1 in compare_array ( result ) for c2 in compare_definitions ) : [EOL] name = TreeNameDefinition ( context , name_node ) [EOL] definition_names . add ( name ) [EOL] [comment] [EOL] [comment] [EOL] compare_definitions += compare_array ( [ name ] ) [EOL] else : [EOL] [comment] [EOL] definition_names . add ( m . name ) [EOL] [EOL] return [ classes . Definition ( evaluator , n ) for n in definition_names ] [EOL] [EOL] [EOL] def resolve_potential_imports ( evaluator , definitions ) : [EOL] [docstring] [EOL] new = set ( ) [EOL] for d in definitions : [EOL] if isinstance ( d , TreeNameDefinition ) : [EOL] imp_or_stmt = d . tree_name . get_definition ( ) [EOL] if isinstance ( imp_or_stmt , tree . Import ) : [EOL] new |= resolve_potential_imports ( evaluator , set ( imports . infer_import ( d . parent_context , d . tree_name , is_goto = True ) ) ) [EOL] return set ( definitions ) | new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jedi . evaluate . representation import ModuleContext [EOL] from jedi . evaluate import compiled [EOL] from jedi . evaluate . compiled import mixed [EOL] from jedi . evaluate . context import Context [EOL] [EOL] [EOL] class NamespaceObject ( object ) : [EOL] def __init__ ( self , dct ) : [EOL] self . __dict__ = dct [EOL] [EOL] [EOL] class MixedModuleContext ( Context ) : [EOL] resets_positions = True [EOL] type = [string] [EOL] [EOL] def __init__ ( self , evaluator , tree_module , namespaces , path ) : [EOL] self . evaluator = evaluator [EOL] self . _namespaces = namespaces [EOL] [EOL] self . _namespace_objects = [ NamespaceObject ( n ) for n in namespaces ] [EOL] self . _module_context = ModuleContext ( evaluator , tree_module , path = path ) [EOL] self . tree_node = tree_module [EOL] [EOL] def get_node ( self ) : [EOL] return self . tree_node [EOL] [EOL] def get_filters ( self , * args , ** kwargs ) : [EOL] for filter in self . _module_context . get_filters ( * args , ** kwargs ) : [EOL] yield filter [EOL] [EOL] for namespace_obj in self . _namespace_objects : [EOL] compiled_object = compiled . create ( self . evaluator , namespace_obj ) [EOL] mixed_object = mixed . MixedObject ( self . evaluator , parent_context = self , compiled_object = compiled_object , tree_context = self . _module_context ) [EOL] for filter in mixed_object . get_filters ( * args , ** kwargs ) : [EOL] yield filter [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _module_context , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , Tuple , Dict [EOL] import typing [EOL] from jedi . parser import token [EOL] from jedi . parser . python import tree [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi . api import classes [EOL] from jedi . api import helpers [EOL] from jedi . evaluate import imports [EOL] from jedi . api import keywords [EOL] from jedi . evaluate . helpers import evaluate_call_of_leaf [EOL] from jedi . evaluate . filters import get_global_filters [EOL] from jedi . parser_utils import get_statement_of_position [EOL] [EOL] [EOL] def get_call_signature_param_names ( call_signatures ) : [EOL] [comment] [EOL] for call_sig in call_signatures : [EOL] for p in call_sig . params : [EOL] [comment] [EOL] tree_name = p . _name . tree_name [EOL] [comment] [EOL] if tree_name is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tree_param = tree . search_ancestor ( tree_name , [string] ) [EOL] if tree_param . star_count == [number] : [comment] [EOL] yield p . _name [EOL] [EOL] [EOL] def filter_names ( evaluator , completion_names , stack , like_name ) : [EOL] comp_dct = { } [EOL] for name in completion_names : [EOL] if settings . case_insensitive_completion \ [EOL] and name . string_name . lower ( ) . startswith ( like_name . lower ( ) ) or name . string_name . startswith ( like_name ) : [EOL] [EOL] new = classes . Completion ( evaluator , name , stack , len ( like_name ) ) [EOL] k = ( new . name , new . complete ) [comment] [EOL] if k in comp_dct and settings . no_completion_duplicates : [EOL] comp_dct [ k ] . _same_name_completions . append ( new ) [EOL] else : [EOL] comp_dct [ k ] = new [EOL] yield new [EOL] [EOL] [EOL] def get_user_scope ( module_context , position ) : [EOL] [docstring] [EOL] user_stmt = get_statement_of_position ( module_context . tree_node , position ) [EOL] if user_stmt is None : [EOL] def scan ( scope ) : [EOL] for s in scope . children : [EOL] if s . start_pos <= position <= s . end_pos : [EOL] if isinstance ( s , ( tree . Scope , tree . Flow ) ) : [EOL] return scan ( s ) or s [EOL] elif s . type in ( [string] , [string] ) : [EOL] return scan ( s ) [EOL] return None [EOL] [EOL] scanned_node = scan ( module_context . tree_node ) [EOL] if scanned_node : [EOL] return module_context . create_context ( scanned_node , node_is_context = True ) [EOL] return module_context [EOL] else : [EOL] return module_context . create_context ( user_stmt ) [EOL] [EOL] [EOL] def get_flow_scope_node ( module_node , position ) : [EOL] node = module_node . get_leaf_for_position ( position , include_prefixes = True ) [EOL] while not isinstance ( node , ( tree . Scope , tree . Flow ) ) : [EOL] node = node . parent [EOL] [EOL] return node [EOL] [EOL] [EOL] class Completion : [EOL] def __init__ ( self , evaluator , module , code_lines , position , call_signatures_method ) : [EOL] self . _evaluator = evaluator [EOL] self . _module_context = module [EOL] self . _module_node = module . tree_node [EOL] self . _code_lines = code_lines [EOL] [EOL] [comment] [EOL] self . _like_name = helpers . get_on_completion_name ( self . _module_node , code_lines , position ) [EOL] [comment] [EOL] [comment] [EOL] self . _position = position [ [number] ] , position [ [number] ] - len ( self . _like_name ) [EOL] self . _call_signatures_method = call_signatures_method [EOL] [EOL] def completions ( self ) : [EOL] completion_names = self . _get_context_completions ( ) [EOL] [EOL] completions = filter_names ( self . _evaluator , completion_names , self . stack , self . _like_name ) [EOL] [EOL] return sorted ( completions , key = lambda x : ( x . name . startswith ( [string] ) , x . name . startswith ( [string] ) , x . name . lower ( ) ) ) [EOL] [EOL] def _get_context_completions ( self ) : [EOL] [docstring] [EOL] [EOL] grammar = self . _evaluator . grammar [EOL] [EOL] try : [EOL] self . stack = helpers . get_stack_at_position ( grammar , self . _code_lines , self . _module_node , self . _position ) [EOL] except helpers . OnErrorLeaf as e : [EOL] self . stack = None [EOL] if e . error_leaf . value == [string] : [EOL] [comment] [EOL] [comment] [EOL] return [ ] [EOL] [comment] [EOL] [EOL] return self . _global_completions ( ) [EOL] [EOL] allowed_keywords , allowed_tokens = helpers . get_possible_completion_types ( grammar , self . stack ) [EOL] [EOL] completion_names = list ( self . _get_keyword_completion_names ( allowed_keywords ) ) [EOL] [EOL] if token . NAME in allowed_tokens or token . INDENT in allowed_tokens : [EOL] [comment] [EOL] [EOL] symbol_names = list ( self . stack . get_node_names ( grammar ) ) [EOL] [EOL] nodes = list ( self . stack . get_nodes ( ) ) [EOL] [EOL] if [string] in symbol_names : [EOL] level = [number] [EOL] only_modules = True [EOL] level , names = self . _parse_dotted_names ( nodes ) [EOL] if [string] in symbol_names : [EOL] if [string] in nodes : [EOL] only_modules = False [EOL] else : [EOL] assert [string] in symbol_names [EOL] [EOL] completion_names += self . _get_importer_names ( names , level , only_modules ) [EOL] elif nodes and nodes [ - [number] ] in ( [string] , [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return list ( self . _get_class_context_completions ( is_function = True ) ) [EOL] elif symbol_names [ - [number] ] in ( [string] , [string] ) and nodes [ - [number] ] == [string] : [EOL] dot = self . _module_node . get_leaf_for_position ( self . _position ) [EOL] completion_names += self . _trailer_completions ( dot . get_previous_leaf ( ) ) [EOL] else : [EOL] completion_names += self . _global_completions ( ) [EOL] completion_names += self . _get_class_context_completions ( is_function = False ) [EOL] [EOL] if [string] in symbol_names : [EOL] call_signatures = self . _call_signatures_method ( ) [EOL] completion_names += get_call_signature_param_names ( call_signatures ) [EOL] [EOL] return completion_names [EOL] [EOL] def _get_keyword_completion_names ( self , keywords_ ) : [EOL] for k in keywords_ : [EOL] yield keywords . keyword ( self . _evaluator , k ) . name [EOL] [EOL] def _global_completions ( self ) : [EOL] context = get_user_scope ( self . _module_context , self . _position ) [EOL] debug . dbg ( [string] , context ) [EOL] flow_scope_node = get_flow_scope_node ( self . _module_node , self . _position ) [EOL] filters = get_global_filters ( self . _evaluator , context , self . _position , origin_scope = flow_scope_node ) [EOL] completion_names = [ ] [EOL] for filter in filters : [EOL] completion_names += filter . values ( ) [EOL] return completion_names [EOL] [EOL] def _trailer_completions ( self , previous_leaf ) : [EOL] user_context = get_user_scope ( self . _module_context , self . _position ) [EOL] evaluation_context = self . _evaluator . create_context ( self . _module_context , previous_leaf ) [EOL] contexts = evaluate_call_of_leaf ( evaluation_context , previous_leaf ) [EOL] completion_names = [ ] [EOL] debug . dbg ( [string] , contexts ) [EOL] for context in contexts : [EOL] for filter in context . get_filters ( search_global = False , origin_scope = user_context . tree_node ) : [EOL] completion_names += filter . values ( ) [EOL] return completion_names [EOL] [EOL] def _parse_dotted_names ( self , nodes ) : [EOL] level = [number] [EOL] names = [ ] [EOL] for node in nodes [ [number] : ] : [EOL] if node in ( [string] , [string] ) : [EOL] if not names : [EOL] level += len ( node . value ) [EOL] elif node . type == [string] : [EOL] names += node . children [ : : [number] ] [EOL] elif node . type == [string] : [EOL] names . append ( node ) [EOL] else : [EOL] break [EOL] return level , names [EOL] [EOL] def _get_importer_names ( self , names , level = [number] , only_modules = True ) : [EOL] names = [ n . value for n in names ] [EOL] i = imports . Importer ( self . _evaluator , names , self . _module_context , level ) [EOL] return i . completion_names ( self . _evaluator , only_modules = only_modules ) [EOL] [EOL] def _get_class_context_completions ( self , is_function = True ) : [EOL] [docstring] [EOL] leaf = self . _module_node . get_leaf_for_position ( self . _position , include_prefixes = True ) [EOL] cls = tree . search_ancestor ( leaf , [string] ) [EOL] if isinstance ( cls , ( tree . Class , tree . Function ) ) : [EOL] [comment] [EOL] random_context = self . _module_context . create_context ( cls , node_is_context = True ) [EOL] else : [EOL] return [EOL] [EOL] if cls . start_pos [ [number] ] >= leaf . start_pos [ [number] ] : [EOL] return [EOL] [EOL] filters = random_context . get_filters ( search_global = False , is_instance = True ) [EOL] [comment] [EOL] next ( filters ) [EOL] for filter in filters : [EOL] for name in filter . values ( ) : [EOL] if ( name . api_type == [string] ) == is_function : [EOL] yield name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[cls]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Any , Set [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import warnings [EOL] import sys [EOL] [EOL] from jedi . parser . python import load_grammar [EOL] from jedi . parser . python import tree [EOL] from jedi . parser . python import parse [EOL] from jedi . parser_utils import get_executable_nodes , get_statement_of_position [EOL] from jedi import debug [EOL] from jedi import settings [EOL] from jedi import common [EOL] from jedi import cache [EOL] from jedi . api import classes [EOL] from jedi . api import interpreter [EOL] from jedi . api import usages [EOL] from jedi . api import helpers [EOL] from jedi . api . completion import Completion [EOL] from jedi . evaluate import Evaluator [EOL] from jedi . evaluate import representation as er [EOL] from jedi . evaluate import imports [EOL] from jedi . evaluate . param import try_iter_content [EOL] from jedi . evaluate . helpers import get_module_names [EOL] from jedi . evaluate . sys_path import get_venv_path [EOL] from jedi . evaluate . iterable import unpack_tuple_to_dict [EOL] from jedi . evaluate . filters import TreeNameDefinition [EOL] [EOL] [comment] [EOL] [comment] [EOL] sys . setrecursionlimit ( [number] ) [EOL] [EOL] [EOL] class NotFoundError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Script ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , source = None , line = None , column = None , path = None , encoding = [string] , source_path = None , source_encoding = None , sys_path = None ) : [EOL] if source_path is not None : [EOL] warnings . warn ( [string] , DeprecationWarning , stacklevel = [number] ) [EOL] path = source_path [EOL] if source_encoding is not None : [EOL] warnings . warn ( [string] , DeprecationWarning , stacklevel = [number] ) [EOL] encoding = source_encoding [EOL] [EOL] self . _orig_path = path [EOL] [comment] [EOL] self . path = os . path . abspath ( path ) if path else None [EOL] [EOL] if source is None : [EOL] [comment] [EOL] with open ( path , [string] ) as f : [EOL] source = f . read ( ) [EOL] [EOL] self . _source = common . source_to_unicode ( source , encoding ) [EOL] self . _code_lines = common . splitlines ( self . _source ) [EOL] line = max ( len ( self . _code_lines ) , [number] ) if line is None else line [EOL] if not ( [number] < line <= len ( self . _code_lines ) ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] line_len = len ( self . _code_lines [ line - [number] ] ) [EOL] column = line_len if column is None else column [EOL] if not ( [number] <= column <= line_len ) : [EOL] raise ValueError ( [string] ) [EOL] self . _pos = line , column [EOL] self . _path = path [EOL] [EOL] cache . clear_time_caches ( ) [EOL] debug . reset_time ( ) [EOL] self . _grammar = load_grammar ( version = [string] % sys . version_info [ : [number] ] ) [EOL] if sys_path is None : [EOL] venv = os . getenv ( [string] ) [EOL] if venv : [EOL] sys_path = list ( get_venv_path ( venv ) ) [EOL] self . _evaluator = Evaluator ( self . _grammar , sys_path = sys_path ) [EOL] debug . speed ( [string] ) [EOL] [EOL] @ cache . memoize_method def _get_module_node ( self ) : [EOL] return parse ( code = self . _source , path = self . path , grammar = self . _grammar , cache = False , diff_cache = True , ) [EOL] [EOL] @ cache . memoize_method def _get_module ( self ) : [EOL] module = er . ModuleContext ( self . _evaluator , self . _get_module_node ( ) , self . path ) [EOL] imports . add_module ( self . _evaluator , module . name . string_name , module ) [EOL] return module [EOL] [EOL] @ property def source_path ( self ) : [EOL] [docstring] [EOL] warnings . warn ( [string] , DeprecationWarning , stacklevel = [number] ) [EOL] return self . path [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , repr ( self . _orig_path ) ) [EOL] [EOL] def completions ( self ) : [EOL] [docstring] [EOL] debug . speed ( [string] ) [EOL] completion = Completion ( self . _evaluator , self . _get_module ( ) , self . _code_lines , self . _pos , self . call_signatures ) [EOL] completions = completion . completions ( ) [EOL] debug . speed ( [string] ) [EOL] return completions [EOL] [EOL] def goto_definitions ( self ) : [EOL] [docstring] [EOL] module_node = self . _get_module_node ( ) [EOL] leaf = module_node . get_name_of_position ( self . _pos ) [EOL] if leaf is None : [EOL] leaf = module_node . get_leaf_for_position ( self . _pos ) [EOL] if leaf is None : [EOL] return [ ] [EOL] [EOL] context = self . _evaluator . create_context ( self . _get_module ( ) , leaf ) [EOL] definitions = helpers . evaluate_goto_definition ( self . _evaluator , context , leaf ) [EOL] [EOL] names = [ s . name for s in definitions ] [EOL] defs = [ classes . Definition ( self . _evaluator , name ) for name in names ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return helpers . sorted_definitions ( set ( defs ) ) [EOL] [EOL] def goto_assignments ( self , follow_imports = False ) : [EOL] [docstring] [EOL] def filter_follow_imports ( names ) : [EOL] for name in names : [EOL] if isinstance ( name , ( imports . ImportName , TreeNameDefinition ) ) : [EOL] for context in name . infer ( ) : [EOL] yield context . name [EOL] else : [EOL] yield name [EOL] [EOL] names = self . _goto ( ) [EOL] if follow_imports : [EOL] names = filter_follow_imports ( names ) [EOL] [EOL] defs = [ classes . Definition ( self . _evaluator , d ) for d in set ( names ) ] [EOL] return helpers . sorted_definitions ( defs ) [EOL] [EOL] def _goto ( self ) : [EOL] [docstring] [EOL] name = self . _get_module_node ( ) . get_name_of_position ( self . _pos ) [EOL] if name is None : [EOL] return [ ] [EOL] context = self . _evaluator . create_context ( self . _get_module ( ) , name ) [EOL] return list ( self . _evaluator . goto ( context , name ) ) [EOL] [EOL] def usages ( self , additional_module_paths = ( ) ) : [EOL] [docstring] [EOL] temp , settings . dynamic_flow_information = settings . dynamic_flow_information , False [EOL] try : [EOL] module_node = self . _get_module_node ( ) [EOL] user_stmt = get_statement_of_position ( module_node , self . _pos ) [EOL] definition_names = self . _goto ( ) [EOL] if not definition_names and isinstance ( user_stmt , tree . Import ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] name = user_stmt . get_name_of_position ( self . _pos ) [EOL] if name is None : [EOL] [comment] [EOL] return [ ] [EOL] definition_names = [ TreeNameDefinition ( self . _get_module ( ) , name ) ] [EOL] [EOL] if not definition_names : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] definition_names = usages . resolve_potential_imports ( self . _evaluator , definition_names ) [EOL] [EOL] modules = set ( [ d . get_root_context ( ) for d in definition_names ] ) [EOL] modules . add ( self . _get_module ( ) ) [EOL] definitions = usages . usages ( self . _evaluator , definition_names , modules ) [EOL] finally : [EOL] settings . dynamic_flow_information = temp [EOL] [EOL] return helpers . sorted_definitions ( set ( definitions ) ) [EOL] [EOL] def call_signatures ( self ) : [EOL] [docstring] [EOL] call_signature_details = helpers . get_call_signature_details ( self . _get_module_node ( ) , self . _pos ) [EOL] if call_signature_details is None : [EOL] return [ ] [EOL] [EOL] context = self . _evaluator . create_context ( self . _get_module ( ) , call_signature_details . bracket_leaf ) [EOL] with common . scale_speed_settings ( settings . scale_call_signatures ) : [EOL] definitions = helpers . cache_call_signatures ( self . _evaluator , context , call_signature_details . bracket_leaf , self . _code_lines , self . _pos ) [EOL] debug . speed ( [string] ) [EOL] [EOL] return [ classes . CallSignature ( self . _evaluator , d . name , call_signature_details . bracket_leaf . start_pos , call_signature_details . call_index , call_signature_details . keyword_name_str ) for d in definitions if hasattr ( d , [string] ) ] [EOL] [EOL] def _analysis ( self ) : [EOL] self . _evaluator . is_analysis = True [EOL] module_node = self . _get_module_node ( ) [EOL] self . _evaluator . analysis_modules = [ module_node ] [EOL] try : [EOL] for node in get_executable_nodes ( module_node ) : [EOL] context = self . _get_module ( ) . create_context ( node ) [EOL] if node . type in ( [string] , [string] ) : [EOL] [comment] [EOL] from jedi . evaluate . finder import _name_to_types [EOL] [comment] [EOL] _name_to_types ( self . _evaluator , context , node . children [ [number] ] ) [EOL] elif isinstance ( node , tree . Import ) : [EOL] import_names = set ( node . get_defined_names ( ) ) [EOL] if node . is_nested ( ) : [EOL] import_names |= set ( path [ - [number] ] for path in node . get_paths ( ) ) [EOL] for n in import_names : [EOL] imports . infer_import ( context , n ) [EOL] elif node . type == [string] : [EOL] types = context . eval_node ( node ) [EOL] for testlist in node . children [ : - [number] : [number] ] : [EOL] [comment] [EOL] unpack_tuple_to_dict ( context , types , testlist ) [EOL] else : [EOL] try_iter_content ( self . _evaluator . goto_definitions ( context , node ) ) [EOL] self . _evaluator . reset_recursion_limitations ( ) [EOL] [EOL] ana = [ a for a in self . _evaluator . analysis if self . path == a . path ] [EOL] return sorted ( set ( ana ) , key = lambda x : x . line ) [EOL] finally : [EOL] self . _evaluator . is_analysis = False [EOL] [EOL] [EOL] class Interpreter ( Script ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source , namespaces , ** kwds ) : [EOL] [docstring] [EOL] try : [EOL] namespaces = [ dict ( n ) for n in namespaces ] [EOL] except Exception : [EOL] raise TypeError ( [string] ) [EOL] [EOL] super ( Interpreter , self ) . __init__ ( source , ** kwds ) [EOL] self . namespaces = namespaces [EOL] [EOL] def _get_module ( self ) : [EOL] parser_module = super ( Interpreter , self ) . _get_module_node ( ) [EOL] return interpreter . MixedModuleContext ( self . _evaluator , parser_module , self . namespaces , path = self . path ) [EOL] [EOL] [EOL] def defined_names ( source , path = None , encoding = [string] ) : [EOL] [docstring] [EOL] warnings . warn ( [string] , DeprecationWarning ) [EOL] return names ( source , path , encoding ) [EOL] [EOL] [EOL] def names ( source = None , path = None , encoding = [string] , all_scopes = False , definitions = True , references = False ) : [EOL] [docstring] [EOL] def def_ref_filter ( _def ) : [EOL] is_def = _def . _name . tree_name . is_definition ( ) [EOL] return definitions and is_def or references and not is_def [EOL] [EOL] [comment] [EOL] script = Script ( source , line = [number] , column = [number] , path = path , encoding = encoding ) [EOL] module_context = script . _get_module ( ) [EOL] defs = [ classes . Definition ( script . _evaluator , TreeNameDefinition ( module_context . create_context ( name . parent ) , name ) ) for name in get_module_names ( script . _get_module_node ( ) , all_scopes ) ] [EOL] return sorted ( filter ( def_ref_filter , defs ) , key = lambda x : ( x . line , x . column ) ) [EOL] [EOL] [EOL] def preload_module ( * modules ) : [EOL] [docstring] [EOL] for m in modules : [EOL] s = [string] % m [EOL] Script ( s , [number] , len ( s ) , None ) . completions ( ) [EOL] [EOL] [EOL] def set_debug_function ( func_cb = debug . print_to_stdout , warnings = True , notices = True , speed = True ) : [EOL] [docstring] [EOL] debug . debug_function = func_cb [EOL] debug . enable_warning = warnings [EOL] debug . enable_notice = notices [EOL] debug . enable_speed = speed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import urllib [EOL] import typing [EOL] import socket [EOL] import os [EOL] import socket [EOL] [EOL] from urllib . parse import urlparse , parse_qs [EOL] [EOL] import sublime [EOL] [EOL] from . . logger import Log [EOL] from . . unix_socket import UnixSocketPath [EOL] from . . helpers import project_name , debug_enabled [EOL] from . . helpers import get_settings , active_view , get_interpreter [EOL] from . . vagrant import VagrantIPAddressGlobal , VagrantMachineGlobalInfo [EOL] [EOL] [EOL] class Interpreter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter_string ) : [EOL] self . __data = { } [EOL] self . __raw_interpreter = interpreter_string [EOL] self . __parse_raw_interpreter ( ) [EOL] self . __project_name = [string] [EOL] [EOL] def __getattr__ ( self , attr_name ) : [EOL] [docstring] [EOL] [EOL] return self . __data . get ( attr_name , None ) [EOL] [EOL] @ property def raw_interpreter ( self ) : [EOL] return self . __raw_interpreter [EOL] [EOL] @ property def for_local ( self ) : [EOL] [docstring] [EOL] [EOL] return self . scheme == [string] [EOL] [EOL] @ property def for_remote ( self ) : [EOL] [docstring] [EOL] [EOL] return self . scheme == [string] [EOL] [EOL] @ property def for_vagrant ( self ) : [EOL] [docstring] [EOL] [EOL] return self . scheme == [string] [EOL] [EOL] @ property def project_name ( self ) : [EOL] [docstring] [EOL] [EOL] if not self . __project_name : [EOL] self . __project_name = project_name ( ) [EOL] [EOL] return self . __project_name [EOL] [EOL] def renew_interpreter ( self ) : [EOL] [docstring] [EOL] [EOL] if not self . for_local : [EOL] return [EOL] [EOL] self . __prepare_local_interpreter ( ) [EOL] [EOL] def __prepare_local_interpreter ( self ) : [EOL] [docstring] [EOL] [EOL] view = active_view ( ) [EOL] self . __extract_port ( view ) [EOL] self . __extract_paths ( view ) [EOL] self . __extract_python_interpreter ( view ) [EOL] self . __extract_script ( ) [EOL] [EOL] args = [ self . python , [string] , self . script_file , [string] , self . project_name ] [EOL] if self . port is not None : [EOL] args . append ( str ( self . port ) ) [EOL] if len ( self . paths ) > [number] : [EOL] paths = [ p for p in self . paths if os . path . exists ( p ) ] [EOL] args . extend ( [ [string] , [string] . join ( paths ) ] ) [EOL] args . extend ( [ str ( os . getpid ( ) ) ] ) [EOL] [EOL] kwargs = { } [EOL] folders = sublime . active_window ( ) . folders ( ) [EOL] if len ( folders ) > [number] and os . path . exists ( folders [ [number] ] ) : [EOL] kwargs [ [string] ] = folders [ [number] ] [EOL] [EOL] self . __data [ [string] ] = ( args , kwargs ) [EOL] [EOL] def __extract_port ( self , view ) : [EOL] [docstring] [EOL] [EOL] if sublime . platform ( ) != [string] : [EOL] self . __data [ [string] ] = [string] [EOL] else : [EOL] self . __data [ [string] ] = self . __get_unix_domain_socket ( ) [EOL] return [EOL] [EOL] if debug_enabled ( view ) : [EOL] port = get_settings ( view , [string] , [number] ) [EOL] self . __data [ [string] ] = port [EOL] return [EOL] [EOL] if sublime . platform ( ) != [string] : [EOL] s = socket . socket ( ) [EOL] s . bind ( ( [string] , [number] ) ) [EOL] self . __data [ [string] ] = s . getsockname ( ) [ [number] ] [EOL] s . close ( ) [EOL] [EOL] def __extract_paths ( self , view ) : [EOL] [docstring] [EOL] [EOL] extra = get_settings ( view , [string] , [ ] ) [EOL] paths = [ os . path . expanduser ( os . path . expandvars ( p ) ) for p in extra ] [EOL] [EOL] try : [EOL] paths . extend ( sublime . active_window ( ) . folders ( ) ) [EOL] except AttributeError : [EOL] Log . warning ( [string] [string] ) [EOL] paths = paths . split ( [string] ) [EOL] paths . extend ( sublime . active_window ( ) . folder ( ) ) [EOL] [EOL] self . __data [ [string] ] = paths [EOL] [EOL] def __extract_python_interpreter ( self , view ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] python = os . path . expanduser ( os . path . expandvars ( get_interpreter ( view ) ) ) [EOL] if [string] in python : [EOL] Log . warning ( [string] [string] [string] . format ( python ) ) [EOL] except : [EOL] python = [string] [EOL] finally : [EOL] self . __data [ [string] ] = python [EOL] [EOL] def __extract_script ( self ) : [EOL] [docstring] [EOL] [EOL] self . __data [ [string] ] = os . path . join ( os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) ) , [string] , [string] ) [EOL] [EOL] def __get_unix_domain_socket ( self ) : [EOL] [docstring] [EOL] [EOL] if sublime . platform ( ) != [string] : [EOL] return [string] [EOL] [EOL] return UnixSocketPath ( self . project_name ) . socket [EOL] [EOL] def __parse_raw_interpreter ( self ) : [EOL] [docstring] [EOL] [EOL] urldata = urlparse ( self . __raw_interpreter ) [EOL] self . __data [ [string] ] = urldata . scheme if urldata . scheme else [string] [EOL] if len ( self . __data [ [string] ] ) == [number] : [EOL] self . __data [ [string] ] = [string] [EOL] [EOL] if self . for_local : [EOL] [comment] [EOL] return self . __prepare_local_interpreter ( ) [EOL] [EOL] if urldata . query and [string] in urldata . query : [EOL] self . __data [ [string] ] = [string] [EOL] [EOL] netloc = urldata . netloc [EOL] if [string] in urldata . netloc : [EOL] left , netloc = netloc . split ( [string] ) [EOL] self . __data [ [string] ] , self . __data [ [string] ] = left . split ( [string] ) [EOL] [EOL] if self . for_remote : [EOL] self . __data [ [string] ] , self . __data [ [string] ] = netloc . split ( [string] ) [EOL] [EOL] if self . for_vagrant : [EOL] self . __data [ [string] ] , self . __data [ [string] ] = netloc . split ( [string] ) [EOL] [EOL] if urldata . query : [EOL] options = parse_qs ( urldata . query ) [EOL] for key , value in options . items ( ) : [EOL] self . __data [ key ] = ( value if key in [ [string] , [string] ] else value [ [number] ] ) [EOL] [EOL] if self . for_vagrant : [EOL] self . __data [ [string] ] = self . __data . get ( [string] , [string] ) [EOL] self . __data [ [string] ] = ( self . __data . get ( [string] , [string] ) ) [EOL] _vagrant_hosts = { [string] : [string] , [string] : self . address , [string] : VagrantIPAddressGlobal ( VagrantMachineGlobalInfo ( self . machine ) . machine_id , self . dev ) . ip_address } [EOL] self . __data [ [string] ] = _vagrant_hosts [ self . network ] [EOL] [EOL] pathmap = { } [EOL] for map_data in self . __data . get ( [string] , [ ] ) : [EOL] split_data = map_data . split ( [string] ) [EOL] if len ( split_data ) != [number] : [EOL] Log . warning ( [string] . format ( map_data ) ) [EOL] continue [EOL] [EOL] local_path = os . path . expanduser ( os . path . expandvars ( split_data [ [number] ] ) ) [EOL] remote_path = os . path . expanduser ( os . path . expandvars ( split_data [ [number] ] ) ) [EOL] pathmap [ local_path ] = remote_path [EOL] [EOL] self . __data [ [string] ] = pathmap [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] return [string] . join ( self . arguments [ [number] ] ) [EOL] except TypeError : [EOL] rep = [string] [EOL] for k , v in self . __data . items ( ) : [EOL] rep + k + [string] + v + [string] [EOL] return rep [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from . local_process import LocalProcess [EOL] from . remote_process import StubProcess [EOL] from . vagrant_process import VagrantProcess [EOL] [EOL] [EOL] class WorkerProcess ( object ) : [EOL] [docstring] [EOL] [EOL] _processers = { [string] : StubProcess , [string] : VagrantProcess } [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . _interpreter = interpreter [EOL] [EOL] def take ( self ) : [EOL] scheme = self . _interpreter . scheme [EOL] return self . _processers . get ( scheme , LocalProcess ) ( self . _interpreter ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class StubProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . _process = None [EOL] self . _interpreter = None [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Any , Union , List , Dict [EOL] import typing_extensions [EOL] import typing [EOL] import socket [EOL] import os [EOL] import time [EOL] import shlex [EOL] import socket [EOL] import subprocess [EOL] [EOL] from . . logger import Log [EOL] from . . helpers import create_subprocess [EOL] from . . helpers import debug_enabled , active_view , get_settings [EOL] [EOL] [EOL] class VagrantProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . interpreter = interpreter [EOL] self . _process = None [EOL] self . errpr = [string] [EOL] self . tip = [string] [EOL] [EOL] @ property def healthy ( self ) : [EOL] [docstring] [EOL] [EOL] if debug_enabled : [EOL] return True [EOL] [EOL] if self . _process . poll ( ) is not None : [EOL] self . error = [string] [EOL] self . tip = [string] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if self . interpreter . manual is not None or self . _up_already ( ) : [EOL] return True [EOL] [EOL] args , kwargs = self . _prepare_arguments ( ) [EOL] self . _process = create_subprocess ( args , ** kwargs ) [EOL] time . sleep ( [number] ) [comment] [EOL] if self . _process is None or self . _process . poll ( ) is not None : [EOL] [comment] [EOL] output , error = self . _process . communicate ( ) [EOL] if error == [string] : [EOL] return True [comment] [EOL] self . error = ( [string] [string] . format ( [string] . join ( args ) , output . decode ( [string] ) , error . decode ( [string] ) . replace ( [string] , [string] ) ) ) [EOL] self . tip = [string] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _up_already ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] s . settimeout ( [number] ) [EOL] s . connect ( ( self . interpreter . host , self . interpreter . port ) ) [EOL] s . close ( ) [EOL] self . interpreter . manual = True [EOL] except : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _prepare_arguments ( self ) : [EOL] [docstring] [EOL] [EOL] script_file = self . _compose_script_file ( ) [EOL] paths = self . _compose_extra_paths ( ) [EOL] cmd = [string] . format ( self . interpreter . machine_id , [string] . format ( self . interpreter . interpreter , script_file , self . interpreter . project_name , [string] . format ( [string] + [string] . join ( paths ) if paths else [string] ) , self . interpreter . port ) ) [EOL] [EOL] kwargs = { [string] : subprocess . PIPE , [string] : subprocess . PIPE } [EOL] return shlex . split ( cmd , posix = os . name != [string] ) , kwargs [EOL] [EOL] def _compose_script_file ( self ) : [EOL] [docstring] [EOL] [EOL] target_os = self . interpreter . os [EOL] target_os = [string] if target_os is None else target_os . lower ( ) [EOL] sep = [string] if target_os == [string] else [string] [EOL] shared = self . interpreter . shared [EOL] if shared is None : [EOL] shared = [string] if target_os == [string] else [string] [EOL] [EOL] return [string] . format ( shared , sep ) [EOL] [EOL] def _compose_extra_paths ( self ) : [EOL] [docstring] [EOL] [EOL] extra_paths = [ ] [EOL] try : [EOL] self . interpreter . extra . extend ( [ ] ) [EOL] except AttributeError : [EOL] if self . interpreter . extra is not None : [EOL] Log . warning ( [string] [string] ) [EOL] extra_paths . extend ( self . interpreter . extra . split ( [string] ) ) [EOL] else : [EOL] extra_paths . extend ( self . interpreter . extra ) [EOL] [EOL] extra_paths . extend ( get_settings ( active_view ( ) , [string] , [ ] ) ) [EOL] return extra_paths [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] [EOL] from . . helpers import create_subprocess [EOL] from . . helpers import debug_enabled , active_view [EOL] [EOL] [EOL] class LocalProcess ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interpreter ) : [EOL] self . interpreter = interpreter [EOL] self . _process = None [EOL] self . error = [string] [EOL] self . tip = [string] [EOL] [EOL] @ property def healthy ( self ) : [EOL] [docstring] [EOL] [EOL] if debug_enabled ( active_view ( ) ) : [EOL] [comment] [EOL] return True [EOL] [EOL] if self . _process . poll ( ) is not None : [EOL] self . error = [string] [EOL] self . tip = [string] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] if debug_enabled ( active_view ( ) ) : [EOL] [comment] [EOL] return True [EOL] [EOL] args , kwargs = self . interpreter . arguments [EOL] self . _process = create_subprocess ( args , ** kwargs ) [EOL] if self . _process is None : [EOL] [comment] [EOL] self . _set_wrong_config_error ( ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] [EOL] if self . _process is not None and self . _process . poll ( ) is None : [EOL] self . _process . kill ( ) [EOL] self . _process = None [EOL] [EOL] def _set_wrong_config_error ( self ) : [EOL] [docstring] [EOL] [EOL] example = [string] [EOL] if os . name == [string] : [EOL] example = [string] [EOL] [EOL] self . error = ( [string] [string] . format ( self . interpreter . raw_interpreter ) ) [EOL] self . tip = ( [string] [string] [string] . format ( example ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class PortugueseStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( PortugueseStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PortugueseStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( PortugueseStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab3 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_residual_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_residual_form ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PortugueseStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . r_residual_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_residual_form ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_9 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_10 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_10 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , PortugueseStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class PorterStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_WXY = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] B_Y_found = False [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_Y_found = other . B_Y_found [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_shortv ( self ) : [EOL] [comment] [EOL] if not self . out_grouping_b ( PorterStemmer . g_v_WXY , [number] , [number] ) : [EOL] return False [EOL] if not self . in_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] if not self . out_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_1a ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_1b ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor != self . I_p1 : [EOL] return False [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] return False [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] return True [EOL] [EOL] def r_Step_1c ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_2 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_3 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_4 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( PorterStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_5a ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] raise lab2 ( ) [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_5b ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_Y_found = False [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_4 [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_4 [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab8 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab11 ( ) [EOL] raise lab10 ( ) [EOL] except lab11 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab10 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab13 ( ) [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab12 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( PorterStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab7 : pass [EOL] self . cursor = v_5 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1a ( ) : [EOL] raise lab16 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1b ( ) : [EOL] raise lab17 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1c ( ) : [EOL] raise lab18 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_12 [EOL] [comment] [EOL] v_13 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_2 ( ) : [EOL] raise lab19 ( ) [EOL] except lab19 : pass [EOL] self . cursor = self . limit - v_13 [EOL] [comment] [EOL] v_14 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_3 ( ) : [EOL] raise lab20 ( ) [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_14 [EOL] [comment] [EOL] v_15 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_4 ( ) : [EOL] raise lab21 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_15 [EOL] [comment] [EOL] v_16 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_5a ( ) : [EOL] raise lab22 ( ) [EOL] except lab22 : pass [EOL] self . cursor = self . limit - v_16 [EOL] [comment] [EOL] v_17 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_5b ( ) : [EOL] raise lab23 ( ) [EOL] except lab23 : pass [EOL] self . cursor = self . limit - v_17 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_18 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . B_Y_found : [EOL] raise lab24 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_19 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_20 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab29 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_20 [EOL] raise lab28 ( ) [EOL] except lab29 : pass [EOL] self . cursor = v_20 [EOL] if self . cursor >= self . limit : [EOL] raise lab27 ( ) [EOL] self . cursor += [number] [EOL] except lab28 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab26 ( ) [EOL] except lab27 : pass [EOL] self . cursor = v_19 [EOL] raise lab25 ( ) [EOL] except lab26 : pass [EOL] except lab25 : pass [EOL] except lab24 : pass [EOL] self . cursor = v_18 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , PorterStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL] class lab22 ( BaseException ) : pass [EOL] class lab23 ( BaseException ) : pass [EOL] class lab24 ( BaseException ) : pass [EOL] class lab25 ( BaseException ) : pass [EOL] class lab26 ( BaseException ) : pass [EOL] class lab27 ( BaseException ) : pass [EOL] class lab28 ( BaseException ) : pass [EOL] class lab29 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class GermanStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] ] [EOL] [EOL] g_st_ending = [ [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab11 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab11 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab10 ( ) [EOL] except lab11 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab10 : pass [EOL] self . cursor = v_5 [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_5 [EOL] if self . cursor >= self . limit : [EOL] raise lab7 ( ) [EOL] self . cursor += [number] [EOL] except lab8 : pass [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_4 [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] except lab5 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( GermanStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( GermanStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab0 ( ) [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( GermanStemmer . g_s_ending , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab2 ( ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( GermanStemmer . g_st_ending , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] c = self . cursor - [number] [EOL] if self . limit_backward > c or c > self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor = c [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab3 ( ) [EOL] if among_var == [number] : [EOL] raise lab3 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab4 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] raise lab3 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab7 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab7 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( GermanStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_10 [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_10 [EOL] raise lab10 ( ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_10 [EOL] raise lab10 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab10 : pass [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_4 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , GermanStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] __all__ = ( [string] , [string] ) [EOL] [EOL] from . danish_stemmer import DanishStemmer [EOL] from . dutch_stemmer import DutchStemmer [EOL] from . english_stemmer import EnglishStemmer [EOL] from . finnish_stemmer import FinnishStemmer [EOL] from . french_stemmer import FrenchStemmer [EOL] from . german_stemmer import GermanStemmer [EOL] from . hungarian_stemmer import HungarianStemmer [EOL] from . italian_stemmer import ItalianStemmer [EOL] from . norwegian_stemmer import NorwegianStemmer [EOL] from . porter_stemmer import PorterStemmer [EOL] from . portuguese_stemmer import PortugueseStemmer [EOL] from . romanian_stemmer import RomanianStemmer [EOL] from . russian_stemmer import RussianStemmer [EOL] from . spanish_stemmer import SpanishStemmer [EOL] from . swedish_stemmer import SwedishStemmer [EOL] from . turkish_stemmer import TurkishStemmer [EOL] [EOL] _languages = { [string] : DanishStemmer , [string] : DutchStemmer , [string] : EnglishStemmer , [string] : FinnishStemmer , [string] : FrenchStemmer , [string] : GermanStemmer , [string] : HungarianStemmer , [string] : ItalianStemmer , [string] : NorwegianStemmer , [string] : PorterStemmer , [string] : PortugueseStemmer , [string] : RomanianStemmer , [string] : RussianStemmer , [string] : SpanishStemmer , [string] : SwedishStemmer , [string] : TurkishStemmer , } [EOL] [EOL] try : [EOL] import Stemmer [EOL] cext_available = True [EOL] except ImportError : [EOL] cext_available = False [EOL] [EOL] def algorithms ( ) : [EOL] if cext_available : [EOL] return Stemmer . language ( ) [EOL] else : [EOL] return list ( _languages . keys ( ) ) [EOL] [EOL] def stemmer ( lang ) : [EOL] if cext_available : [EOL] return Stemmer . Stemmer ( lang ) [EOL] if lang . lower ( ) in _languages : [EOL] return _languages [ lang . lower ( ) ] ( ) [EOL] else : [EOL] raise KeyError ( [string] % lang ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class FrenchStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_keep_with_s = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = v_4 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab7 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_4 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab7 : pass [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab5 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab5 : pass [EOL] self . cursor = v_2 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] try : [EOL] [comment] [EOL] if self . find_among ( FrenchStemmer . a_0 , [number] ) == [number] : [EOL] raise lab3 ( ) [EOL] raise lab1 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab14 ( ) [EOL] raise lab13 ( ) [EOL] except lab14 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab13 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab6 : pass [EOL] self . cursor = v_4 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( FrenchStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab5 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab4 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab3 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab7 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab9 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab6 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab11 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab11 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab11 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab13 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab12 : pass [EOL] except lab11 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab15 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab14 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if not self . out_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . in_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return False [EOL] return True [EOL] [EOL] def r_i_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . out_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_residual_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( FrenchStemmer . g_keep_with_s , [number] , [number] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_4 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FrenchStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] except lab1 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_4 [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_4 [EOL] return True [EOL] [EOL] def r_un_double ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( FrenchStemmer . a_8 , [number] ) == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_un_accent ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] try : [EOL] if not self . out_grouping_b ( FrenchStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] v_1 -= [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] if v_1 > [number] : [EOL] return False [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab3 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] try : [EOL] [comment] [EOL] if not self . r_i_verb_suffix ( ) : [EOL] raise lab7 ( ) [EOL] raise lab5 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_7 [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab9 : pass [EOL] except lab8 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . r_residual_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_un_double ( ) : [EOL] raise lab11 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_un_accent ( ) : [EOL] raise lab12 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_10 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_11 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab13 ( ) [EOL] except lab13 : pass [EOL] self . cursor = v_11 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , FrenchStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class ItalianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_AEIO = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_CG = [ [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( ItalianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = v_5 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab8 : pass [EOL] self . cursor = v_4 [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_4 [EOL] if self . cursor >= self . limit : [EOL] raise lab5 ( ) [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_3 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] except lab3 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( ItalianStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( ItalianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_attached_pronoun ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( ItalianStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab3 : pass [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( ItalianStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_vowel_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping_b ( ItalianStemmer . g_AEIO , [number] , [number] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if not self . in_grouping_b ( ItalianStemmer . g_CG , [number] , [number] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_attached_pronoun ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_vowel_suffix ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_7 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_7 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , ItalianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class Among ( object ) : [EOL] def __init__ ( self , s , substring_i , result , method = None ) : [EOL] [docstring] [EOL] self . s_size = len ( s ) [EOL] self . s = s [EOL] self . substring_i = substring_i [EOL] self . result = result [EOL] self . method = method [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class DutchStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_I = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_j = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] B_e_found = False [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . B_e_found = other . B_e_found [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( DutchStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] self . cursor = v_3 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab3 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab9 : pass [EOL] self . cursor = v_5 [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = v_5 [EOL] if self . cursor >= self . limit : [EOL] raise lab6 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_4 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not self . I_p1 < [number] : [EOL] raise lab4 ( ) [EOL] self . I_p1 = [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( DutchStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_undouble ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( DutchStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_e_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_e_found = False [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( DutchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . B_e_found = True [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_en_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( DutchStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DutchStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_en_ending ( ) : [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] raise lab0 ( ) [EOL] if not self . out_grouping_b ( DutchStemmer . g_v_j , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_e_ending ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_en_ending ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DutchStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] raise lab4 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] raise lab4 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_e_ending ( ) : [EOL] raise lab4 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . B_e_found : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping_b ( DutchStemmer . g_v_I , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( DutchStemmer . a_5 , [number] ) == [number] : [EOL] raise lab9 ( ) [EOL] if not self . out_grouping_b ( DutchStemmer . g_v , [number] , [number] ) : [EOL] raise lab9 ( ) [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab9 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_4 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , DutchStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class HungarianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_10 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_11 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . out_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] self . cursor = v_2 [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if self . find_among ( HungarianStemmer . a_0 , [number] ) == [number] : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] if not self . out_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( HungarianStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_v_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_double ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( HungarianStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_1 [EOL] return True [EOL] [EOL] def r_undouble ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] c = self . cursor - [number] [EOL] if self . limit_backward > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_instrum ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( HungarianStemmer . a_4 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_v_ending ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case_special ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case_other ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_factive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_double ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_plural ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_owned ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_9 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_sing_owner ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_10 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_plur_owner ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( HungarianStemmer . a_11 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_instrum ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case_special ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case_other ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_factive ( ) : [EOL] raise lab5 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_owned ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_sing_owner ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_plur_owner ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_plural ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_10 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , HungarianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class FinnishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] , [string] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] g_AEI = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_V1 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_V2 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_particle_end = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] B_ending_removed = False [EOL] S_x = [string] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_ending_removed = other . B_ending_removed [EOL] self . S_x = other . S_x [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_1 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_3 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = v_3 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_3 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_particle_etc ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( FinnishStemmer . g_particle_end , [number] , [number] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_possessive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_1 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_3 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_LONG ( self ) : [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_5 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_VI ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] if not self . in_grouping_b ( FinnishStemmer . g_V2 , [number] , [number] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_case_ending ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_LONG ( ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] return False [EOL] if not self . out_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . B_ending_removed = True [EOL] return True [EOL] [EOL] def r_other_endings ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p2 : [EOL] return False [EOL] self . cursor = self . I_p2 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_i_plural ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( FinnishStemmer . a_8 , [number] ) == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_t_plural ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p2 : [EOL] return False [EOL] self . cursor = self . I_p2 [EOL] v_5 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( FinnishStemmer . a_9 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_5 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_5 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_tidy ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . r_LONG ( ) : [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab0 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping_b ( FinnishStemmer . g_AEI , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if not self . out_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_8 [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] if not self . out_grouping_b ( FinnishStemmer . g_V1 , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] self . cursor = self . limit - v_9 [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_9 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] self . S_x = self . slice_to ( self . S_x ) [EOL] if self . S_x == [string] : [EOL] return False [EOL] [comment] [EOL] if not self . eq_v_b ( self . S_x ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . B_ending_removed = False [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_particle_etc ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_possessive ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_case_ending ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_endings ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . B_ending_removed : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_i_plural ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_t_plural ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_8 [EOL] except lab5 : pass [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_tidy ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , FinnishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class SpanishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SpanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( SpanishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_attached_pronoun ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( SpanishStemmer . a_1 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab1 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab2 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab3 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab3 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_y_verb_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_4 [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_residual_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SpanishStemmer . a_9 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_attached_pronoun ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_4 [EOL] try : [EOL] [comment] [EOL] if not self . r_y_verb_suffix ( ) : [EOL] raise lab5 ( ) [EOL] raise lab3 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_residual_suffix ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_5 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_6 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , SpanishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class NorwegianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( NorwegianStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( NorwegianStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_main_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( NorwegianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( NorwegianStemmer . g_s_ending , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] if not self . out_grouping_b ( NorwegianStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_consonant_pair ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( NorwegianStemmer . a_1 , [number] ) == [number] : [EOL] self . limit_backward = v_3 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_3 [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_other_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( NorwegianStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_main_suffix ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , NorwegianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] class BaseStemmer ( object ) : [EOL] def __init__ ( self ) : [EOL] self . set_current ( [string] ) [EOL] self . maxCacheSize = [number] [EOL] self . _cache = { } [EOL] self . _counter = [number] [EOL] [EOL] def set_current ( self , value ) : [EOL] [docstring] [EOL] self . current = value [EOL] self . cursor = [number] [EOL] self . limit = len ( self . current ) [EOL] self . limit_backward = [number] [EOL] self . bra = self . cursor [EOL] self . ket = self . limit [EOL] [EOL] def get_current ( self ) : [EOL] [docstring] [EOL] return self . current [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . current = other . current [EOL] self . cursor = other . cursor [EOL] self . limit = other . limit [EOL] self . limit_backward = other . limit_backward [EOL] self . bra = other . bra [EOL] self . ket = other . ket [EOL] [EOL] def in_grouping ( self , s , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] return False [EOL] self . cursor += [number] [EOL] return True [EOL] [EOL] def in_grouping_b ( self , s , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] return False [EOL] self . cursor -= [number] [EOL] return True [EOL] [EOL] def out_grouping ( self , s , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if ch > max or ch < min : [EOL] self . cursor += [number] [EOL] return True [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] self . cursor += [number] [EOL] return True [EOL] return False [EOL] [EOL] def out_grouping_b ( self , s , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if ch > max or ch < min : [EOL] self . cursor -= [number] [EOL] return True [EOL] ch -= min [EOL] if ( s [ ch >> [number] ] & ( [number] << ( ch & [number] ) ) ) == [number] : [EOL] self . cursor -= [number] [EOL] return True [EOL] return False [EOL] [EOL] def in_range ( self , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] self . cursor += [number] [EOL] return True [EOL] [EOL] def in_range_b ( self , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if ch > max or ch < min : [EOL] return False [EOL] self . cursor -= [number] [EOL] return True [EOL] [EOL] def out_range ( self , min , max ) : [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor ] ) [EOL] if not ( ch > max or ch < min ) : [EOL] return False [EOL] self . cursor += [number] [EOL] return True [EOL] [EOL] def out_range_b ( self , min , max ) : [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] ch = ord ( self . current [ self . cursor - [number] ] ) [EOL] if not ( ch > max or ch < min ) : [EOL] return False [EOL] self . cursor -= [number] [EOL] return True [EOL] [EOL] def eq_s ( self , s_size , s ) : [EOL] if self . limit - self . cursor < s_size : [EOL] return False [EOL] if self . current [ self . cursor : self . cursor + s_size ] != s : [EOL] return False [EOL] self . cursor += s_size [EOL] return True [EOL] [EOL] def eq_s_b ( self , s_size , s ) : [EOL] if self . cursor - self . limit_backward < s_size : [EOL] return False [EOL] if self . current [ self . cursor - s_size : self . cursor ] != s : [EOL] return False [EOL] self . cursor -= s_size [EOL] return True [EOL] [EOL] def eq_v ( self , s ) : [EOL] return self . eq_s ( len ( s ) , s ) [EOL] [EOL] def eq_v_b ( self , s ) : [EOL] return self . eq_s_b ( len ( s ) , s ) [EOL] [EOL] def find_among ( self , v , v_size ) : [EOL] i = [number] [EOL] j = v_size [EOL] [EOL] c = self . cursor [EOL] l = self . limit [EOL] [EOL] common_i = [number] [EOL] common_j = [number] [EOL] [EOL] first_key_inspected = False [EOL] [EOL] while True : [EOL] k = i + ( ( j - i ) >> [number] ) [EOL] diff = [number] [EOL] common = min ( common_i , common_j ) [comment] [EOL] w = v [ k ] [EOL] for i2 in range ( common , w . s_size ) : [EOL] if c + common == l : [EOL] diff = - [number] [EOL] break [EOL] diff = ord ( self . current [ c + common ] ) - ord ( w . s [ i2 ] ) [EOL] if diff != [number] : [EOL] break [EOL] common += [number] [EOL] if diff < [number] : [EOL] j = k [EOL] common_j = common [EOL] else : [EOL] i = k [EOL] common_i = common [EOL] if j - i <= [number] : [EOL] if i > [number] : [EOL] break [comment] [EOL] if j == i : [EOL] break [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if first_key_inspected : [EOL] break [EOL] first_key_inspected = True [EOL] while True : [EOL] w = v [ i ] [EOL] if common_i >= w . s_size : [EOL] self . cursor = c + w . s_size [EOL] if w . method is None : [EOL] return w . result [EOL] method = getattr ( self , w . method ) [EOL] res = method ( ) [EOL] self . cursor = c + w . s_size [EOL] if res : [EOL] return w . result [EOL] i = w . substring_i [EOL] if i < [number] : [EOL] return [number] [EOL] return - [number] [comment] [EOL] [EOL] def find_among_b ( self , v , v_size ) : [EOL] [docstring] [EOL] i = [number] [EOL] j = v_size [EOL] [EOL] c = self . cursor [EOL] lb = self . limit_backward ; [EOL] [EOL] common_i = [number] [EOL] common_j = [number] [EOL] [EOL] first_key_inspected = False [EOL] [EOL] while True : [EOL] k = i + ( ( j - i ) >> [number] ) [EOL] diff = [number] [EOL] common = min ( common_i , common_j ) [EOL] w = v [ k ] [EOL] for i2 in range ( w . s_size - [number] - common , - [number] , - [number] ) : [EOL] if c - common == lb : [EOL] diff = - [number] [EOL] break [EOL] diff = ord ( self . current [ c - [number] - common ] ) - ord ( w . s [ i2 ] ) [EOL] if diff != [number] : [EOL] break [EOL] common += [number] [EOL] if diff < [number] : [EOL] j = k [EOL] common_j = common [EOL] else : [EOL] i = k [EOL] common_i = common [EOL] if j - i <= [number] : [EOL] if i > [number] : [EOL] break [EOL] if j == i : [EOL] break [EOL] if first_key_inspected : [EOL] break [EOL] first_key_inspected = True [EOL] while True : [EOL] w = v [ i ] [EOL] if common_i >= w . s_size : [EOL] self . cursor = c - w . s_size [EOL] if w . method is None : [EOL] return w . result [EOL] method = getattr ( self , w . method ) [EOL] res = method ( ) [EOL] self . cursor = c - w . s_size [EOL] if res : [EOL] return w . result [EOL] i = w . substring_i [EOL] if i < [number] : [EOL] return [number] [EOL] return - [number] [comment] [EOL] [EOL] def replace_s ( self , c_bra , c_ket , s ) : [EOL] [docstring] [EOL] adjustment = len ( s ) - ( c_ket - c_bra ) [EOL] self . current = self . current [ [number] : c_bra ] + s + self . current [ c_ket : ] [EOL] self . limit += adjustment [EOL] if self . cursor >= c_ket : [EOL] self . cursor += adjustment [EOL] elif self . cursor > c_bra : [EOL] self . cursor = c_bra [EOL] return adjustment [EOL] [EOL] def slice_check ( self ) : [EOL] if self . bra < [number] or self . bra > self . ket or self . ket > self . limit or self . limit > len ( self . current ) : [EOL] return False [EOL] return True [EOL] [EOL] def slice_from ( self , s ) : [EOL] [docstring] [EOL] result = False [EOL] if self . slice_check ( ) : [EOL] self . replace_s ( self . bra , self . ket , s ) [EOL] result = True [EOL] return result [EOL] [EOL] def slice_del ( self ) : [EOL] return self . slice_from ( [string] ) [EOL] [EOL] def insert ( self , c_bra , c_ket , s ) : [EOL] [docstring] [EOL] adjustment = self . replace_s ( c_bra , c_ket , s ) [EOL] if c_bra <= self . bra : [EOL] self . bra += adjustment [EOL] if c_bra <= self . ket : [EOL] self . ket += adjustment [EOL] [EOL] def slice_to ( self , s ) : [EOL] [docstring] [EOL] result = [string] [EOL] if self . slice_check ( ) : [EOL] result = self . current [ self . bra : self . ket ] [EOL] return result [EOL] [EOL] def assign_to ( self , s ) : [EOL] [docstring] [EOL] return self . current [ [number] : self . limit ] [EOL] [EOL] def _stem_word ( self , word ) : [EOL] cache = self . _cache . get ( word ) [EOL] if cache is None : [EOL] self . set_current ( word ) [EOL] self . _stem ( ) [EOL] result = self . get_current ( ) [EOL] self . _cache [ word ] = [ result , self . _counter ] [EOL] else : [EOL] cache [ [number] ] = self . _counter [EOL] result = cache [ [number] ] [EOL] self . _counter += [number] [EOL] return result [EOL] [EOL] def _clear_cache ( self ) : [EOL] removecount = int ( len ( self . _cache ) - self . maxCacheSize * [number] / [number] ) [EOL] oldcaches = sorted ( self . _cache . items ( ) , key = lambda cache : cache [ [number] ] [ [number] ] ) [ [number] : removecount ] [EOL] for key , value in oldcaches : [EOL] del self . _cache [ key ] [EOL] [EOL] def stemWord ( self , word ) : [EOL] result = self . _stem_word ( word ) [EOL] if len ( self . _cache ) > self . maxCacheSize : [EOL] self . _clear_cache ( ) [EOL] return result [EOL] [EOL] def stemWords ( self , words ) : [EOL] result = [ self . _stem_word ( word ) for word in words ] [EOL] if len ( self . _cache ) > self . maxCacheSize : [EOL] self . _clear_cache ( ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class RussianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] I_p2 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_p2 = other . I_p2 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RussianStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_perfective_gerund ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_adjective ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_adjectival ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_adjective ( ) : [EOL] return False [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_reflexive ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_verb ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_noun ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_derivational ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_tidy_up ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RussianStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_perfective_gerund ( ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_reflexive ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_adjectival ( ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] if not self . r_verb ( ) : [EOL] raise lab7 ( ) [EOL] raise lab5 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . r_noun ( ) : [EOL] raise lab1 ( ) [EOL] except lab5 : pass [EOL] except lab2 : pass [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab8 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab8 : pass [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_derivational ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_tidy_up ( ) : [EOL] raise lab10 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_10 [EOL] self . limit_backward = v_3 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , RussianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class DanishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p1 = [number] [EOL] S_ch = [string] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p1 = other . I_p1 [EOL] self . S_ch = other . S_ch [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( DanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( DanishStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_main_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DanishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( DanishStemmer . g_s_ending , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_consonant_pair ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( DanishStemmer . a_1 , [number] ) == [number] : [EOL] self . limit_backward = v_3 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_3 [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_other_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_3 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( DanishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_3 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_3 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_4 [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_undouble ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . out_grouping_b ( DanishStemmer . g_v , [number] , [number] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] self . S_ch = self . slice_to ( self . S_ch ) [EOL] if self . S_ch == [string] : [EOL] return False [EOL] self . limit_backward = v_2 [EOL] [comment] [EOL] if not self . eq_v_b ( self . S_ch ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_main_suffix ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_undouble ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , DanishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class EnglishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , - [number] ) , Among ( [string] , [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_10 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] g_v_WXY = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_valid_LI = [ [number] , [number] , [number] ] [EOL] [EOL] B_Y_found = False [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_Y_found = other . B_Y_found [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_Y_found = False [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_5 [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = v_5 [EOL] if self . cursor >= self . limit : [EOL] raise lab5 ( ) [EOL] self . cursor += [number] [EOL] except lab6 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_Y_found = True [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_4 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] self . cursor = v_3 [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if self . find_among ( EnglishStemmer . a_0 , [number] ) == [number] : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] return True [EOL] [EOL] def r_shortv ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v_WXY , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if self . cursor > self . limit_backward : [EOL] return False [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_1a ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] except lab0 : pass [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor - [number] [EOL] if self . limit_backward > c or c > self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor = c [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab1 : pass [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_1b ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor != self . I_p1 : [EOL] return False [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] return False [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] return True [EOL] [EOL] def r_Step_1c ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if not self . out_grouping_b ( EnglishStemmer . g_v , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if self . cursor > self . limit_backward : [EOL] raise lab2 ( ) [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_Step_2 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( EnglishStemmer . g_valid_LI , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_3 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_6 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_4 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_7 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_Step_5 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( EnglishStemmer . a_8 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_shortv ( ) : [EOL] raise lab2 ( ) [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_2 [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_exception2 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . find_among_b ( EnglishStemmer . a_9 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if self . cursor > self . limit_backward : [EOL] return False [EOL] return True [EOL] [EOL] def r_exception1 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( EnglishStemmer . a_10 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor < self . limit : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . B_Y_found : [EOL] return False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] self . cursor = v_2 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_exception1 ( ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] try : [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] raise lab3 ( ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab4 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] v_4 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab5 ( ) [EOL] except lab5 : pass [EOL] self . cursor = v_4 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1a ( ) : [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_exception2 ( ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1b ( ) : [EOL] raise lab9 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_1c ( ) : [EOL] raise lab10 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_2 ( ) : [EOL] raise lab11 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_3 ( ) : [EOL] raise lab12 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_4 ( ) : [EOL] raise lab13 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_Step_5 ( ) : [EOL] raise lab14 ( ) [EOL] except lab14 : pass [EOL] self . cursor = self . limit - v_12 [EOL] except lab7 : pass [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_13 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab15 ( ) [EOL] except lab15 : pass [EOL] self . cursor = v_13 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , EnglishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class SwedishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_s_ending = [ [number] , [number] , [number] ] [EOL] [EOL] I_x = [number] [EOL] I_p1 = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . I_x = other . I_x [EOL] self . I_p1 = other . I_p1 [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_p1 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] c = self . cursor + [number] [EOL] if [number] > c or c > self . limit : [EOL] return False [EOL] self . cursor = c [EOL] [comment] [EOL] self . I_x = self . cursor [EOL] self . cursor = v_1 [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] if not self . in_grouping ( SwedishStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( SwedishStemmer . g_v , [number] , [number] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] [comment] [EOL] if not ( self . I_p1 < self . I_x ) : [EOL] raise lab4 ( ) [EOL] self . I_p1 = self . I_x [EOL] except lab4 : pass [EOL] return True [EOL] [EOL] def r_main_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SwedishStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] self . limit_backward = v_2 [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] if not self . in_grouping_b ( SwedishStemmer . g_s_ending , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_consonant_pair ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] [comment] [EOL] if self . find_among_b ( SwedishStemmer . a_1 , [number] ) == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_other_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_p1 : [EOL] return False [EOL] self . cursor = self . I_p1 [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( SwedishStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_main_suffix ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_consonant_pair ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_other_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , SwedishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class TurkishStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_6 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_7 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_8 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_9 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_10 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_11 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_12 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_13 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_14 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_15 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_16 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_17 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_18 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_19 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_20 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_21 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_22 = [ Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) , Among ( [string] , - [number] , - [number] ) ] [EOL] [EOL] a_23 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_vowel = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_U = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel1 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel2 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel3 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] g_vowel4 = [ [number] ] [EOL] [EOL] g_vowel5 = [ [number] ] [EOL] [EOL] g_vowel6 = [ [number] ] [EOL] [EOL] B_continue_stemming_noun_suffixes = False [EOL] I_strlen = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_continue_stemming_noun_suffixes = other . B_continue_stemming_noun_suffixes [EOL] self . I_strlen = other . I_strlen [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_check_vowel_harmony ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab0 : pass [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel1 , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = self . limit - v_4 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_4 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab3 ( ) [EOL] self . cursor -= [number] [EOL] except lab4 : pass [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel2 , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_5 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab6 ( ) [EOL] self . cursor -= [number] [EOL] except lab7 : pass [EOL] raise lab2 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab9 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel3 , [number] , [number] ) : [EOL] raise lab11 ( ) [EOL] self . cursor = self . limit - v_6 [EOL] raise lab10 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_6 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab9 ( ) [EOL] self . cursor -= [number] [EOL] except lab10 : pass [EOL] raise lab2 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab12 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel4 , [number] , [number] ) : [EOL] raise lab14 ( ) [EOL] self . cursor = self . limit - v_7 [EOL] raise lab13 ( ) [EOL] except lab14 : pass [EOL] self . cursor = self . limit - v_7 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab12 ( ) [EOL] self . cursor -= [number] [EOL] except lab13 : pass [EOL] raise lab2 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab15 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel5 , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] self . cursor = self . limit - v_8 [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_8 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab15 ( ) [EOL] self . cursor -= [number] [EOL] except lab16 : pass [EOL] raise lab2 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab18 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel6 , [number] , [number] ) : [EOL] raise lab20 ( ) [EOL] self . cursor = self . limit - v_9 [EOL] raise lab19 ( ) [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_9 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab18 ( ) [EOL] self . cursor -= [number] [EOL] except lab19 : pass [EOL] raise lab2 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab21 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel5 , [number] , [number] ) : [EOL] raise lab23 ( ) [EOL] self . cursor = self . limit - v_10 [EOL] raise lab22 ( ) [EOL] except lab23 : pass [EOL] self . cursor = self . limit - v_10 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab21 ( ) [EOL] self . cursor -= [number] [EOL] except lab22 : pass [EOL] raise lab2 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel6 , [number] , [number] ) : [EOL] raise lab25 ( ) [EOL] self . cursor = self . limit - v_11 [EOL] raise lab24 ( ) [EOL] except lab25 : pass [EOL] self . cursor = self . limit - v_11 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab24 : pass [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_1 [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_n_consonant ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_s_consonant ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_y_consonant ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_suffix_with_optional_U_vowel ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab1 ( ) [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] self . cursor = self . limit - v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] return False [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] if not self . out_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] return False [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit - v_6 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_possessives ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_0 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_U_vowel ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_sU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_s_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_lArI ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_1 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] if not self . in_grouping_b ( TurkishStemmer . g_U , [number] , [number] ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_2 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nUn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_3 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_n_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_4 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_5 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_DA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_6 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ndA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_7 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_DAn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_8 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ndAn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_9 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ylA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_10 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ki ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ncA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_11 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_n_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yUm ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_12 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_sUn ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_13 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yUz ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_14 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_sUnUz ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_15 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_lAr ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_16 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_nUz ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_17 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_DUr ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_18 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_cAsInA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_19 , [number] ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yDU ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_20 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ysA ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_21 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_ymUs_ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_check_vowel_harmony ( ) : [EOL] return False [EOL] [comment] [EOL] if self . find_among_b ( TurkishStemmer . a_22 , [number] ) == [number] : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_mark_yken ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_suffix_with_optional_y_consonant ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_stem_nominal_verb_suffixes ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] self . B_continue_stemming_noun_suffixes = True [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_2 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yDU ( ) : [EOL] raise lab4 ( ) [EOL] raise lab2 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_2 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ysA ( ) : [EOL] raise lab5 ( ) [EOL] raise lab2 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . r_mark_yken ( ) : [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_cAsInA ( ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUnUz ( ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab9 ( ) [EOL] raise lab7 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUm ( ) : [EOL] raise lab10 ( ) [EOL] raise lab7 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUn ( ) : [EOL] raise lab11 ( ) [EOL] raise lab7 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUz ( ) : [EOL] raise lab12 ( ) [EOL] raise lab7 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_3 [EOL] except lab7 : pass [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] raise lab6 ( ) [EOL] raise lab0 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab13 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_DUr ( ) : [EOL] raise lab16 ( ) [EOL] raise lab15 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_5 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yDU ( ) : [EOL] raise lab17 ( ) [EOL] raise lab15 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_5 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ysA ( ) : [EOL] raise lab18 ( ) [EOL] raise lab15 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] except lab14 : pass [EOL] [comment] [EOL] self . B_continue_stemming_noun_suffixes = False [EOL] raise lab0 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_nUz ( ) : [EOL] raise lab19 ( ) [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yDU ( ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_mark_ysA ( ) : [EOL] raise lab19 ( ) [EOL] except lab20 : pass [EOL] raise lab0 ( ) [EOL] except lab19 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUnUz ( ) : [EOL] raise lab24 ( ) [EOL] raise lab23 ( ) [EOL] except lab24 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUz ( ) : [EOL] raise lab25 ( ) [EOL] raise lab23 ( ) [EOL] except lab25 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUn ( ) : [EOL] raise lab26 ( ) [EOL] raise lab23 ( ) [EOL] except lab26 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . r_mark_yUm ( ) : [EOL] raise lab22 ( ) [EOL] except lab23 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] self . cursor = self . limit - v_8 [EOL] raise lab27 ( ) [EOL] except lab27 : pass [EOL] raise lab0 ( ) [EOL] except lab22 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_DUr ( ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUnUz ( ) : [EOL] raise lab30 ( ) [EOL] raise lab29 ( ) [EOL] except lab30 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab31 ( ) [EOL] raise lab29 ( ) [EOL] except lab31 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUm ( ) : [EOL] raise lab32 ( ) [EOL] raise lab29 ( ) [EOL] except lab32 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_sUn ( ) : [EOL] raise lab33 ( ) [EOL] raise lab29 ( ) [EOL] except lab33 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yUz ( ) : [EOL] raise lab34 ( ) [EOL] raise lab29 ( ) [EOL] except lab34 : pass [EOL] self . cursor = self . limit - v_10 [EOL] except lab29 : pass [EOL] [comment] [EOL] if not self . r_mark_ymUs_ ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab28 ( ) [EOL] except lab28 : pass [EOL] except lab0 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def r_stem_suffix_chain_before_ki ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_ki ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_DA ( ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_4 [EOL] raise lab5 ( ) [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_5 [EOL] raise lab6 ( ) [EOL] except lab6 : pass [EOL] except lab3 : pass [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_nUn ( ) : [EOL] raise lab7 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_7 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab13 ( ) [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab14 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab14 ( ) [EOL] except lab14 : pass [EOL] raise lab9 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] except lab8 : pass [EOL] raise lab0 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_ndA ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab16 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab15 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_10 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab17 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_11 [EOL] raise lab18 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_11 [EOL] raise lab18 ( ) [EOL] except lab18 : pass [EOL] raise lab15 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] return False [EOL] except lab15 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_stem_noun_suffixes ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab1 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_2 [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_ncA ( ) : [EOL] raise lab3 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_4 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab9 ( ) [EOL] raise lab8 ( ) [EOL] except lab9 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab10 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_6 [EOL] raise lab10 ( ) [EOL] except lab10 : pass [EOL] raise lab5 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_3 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] except lab4 : pass [EOL] raise lab0 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ndA ( ) : [EOL] raise lab13 ( ) [EOL] raise lab12 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] if not self . r_mark_nA ( ) : [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab15 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_8 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab16 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab17 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_9 [EOL] raise lab17 ( ) [EOL] except lab17 : pass [EOL] raise lab14 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_8 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] raise lab11 ( ) [EOL] except lab14 : pass [EOL] raise lab0 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_10 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_ndAn ( ) : [EOL] raise lab20 ( ) [EOL] raise lab19 ( ) [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] if not self . r_mark_nU ( ) : [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab22 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_12 [EOL] raise lab23 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_12 [EOL] raise lab23 ( ) [EOL] except lab23 : pass [EOL] raise lab21 ( ) [EOL] except lab22 : pass [EOL] self . cursor = self . limit - v_11 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab18 ( ) [EOL] except lab21 : pass [EOL] raise lab0 ( ) [EOL] except lab18 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_DAn ( ) : [EOL] raise lab24 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_13 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_14 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab27 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_15 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_15 [EOL] raise lab28 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_15 [EOL] raise lab28 ( ) [EOL] except lab28 : pass [EOL] raise lab26 ( ) [EOL] except lab27 : pass [EOL] self . cursor = self . limit - v_14 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab29 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_16 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_16 [EOL] raise lab30 ( ) [EOL] except lab30 : pass [EOL] raise lab26 ( ) [EOL] except lab29 : pass [EOL] self . cursor = self . limit - v_14 [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_13 [EOL] raise lab25 ( ) [EOL] except lab26 : pass [EOL] except lab25 : pass [EOL] raise lab0 ( ) [EOL] except lab24 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_17 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_nUn ( ) : [EOL] raise lab33 ( ) [EOL] raise lab32 ( ) [EOL] except lab33 : pass [EOL] self . cursor = self . limit - v_17 [EOL] [comment] [EOL] if not self . r_mark_ylA ( ) : [EOL] raise lab31 ( ) [EOL] except lab32 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_18 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_19 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] raise lab36 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] raise lab36 ( ) [EOL] raise lab35 ( ) [EOL] except lab36 : pass [EOL] self . cursor = self . limit - v_19 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_20 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab39 ( ) [EOL] raise lab38 ( ) [EOL] except lab39 : pass [EOL] self . cursor = self . limit - v_20 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] raise lab37 ( ) [EOL] except lab38 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_21 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_21 [EOL] raise lab40 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_21 [EOL] raise lab40 ( ) [EOL] except lab40 : pass [EOL] raise lab35 ( ) [EOL] except lab37 : pass [EOL] self . cursor = self . limit - v_19 [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_18 [EOL] raise lab34 ( ) [EOL] except lab35 : pass [EOL] except lab34 : pass [EOL] raise lab0 ( ) [EOL] except lab31 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lArI ( ) : [EOL] raise lab41 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] raise lab0 ( ) [EOL] except lab41 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] raise lab42 ( ) [EOL] raise lab0 ( ) [EOL] except lab42 : pass [EOL] self . cursor = self . limit - v_1 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_22 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_DA ( ) : [EOL] raise lab45 ( ) [EOL] raise lab44 ( ) [EOL] except lab45 : pass [EOL] self . cursor = self . limit - v_22 [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_yU ( ) : [EOL] raise lab46 ( ) [EOL] raise lab44 ( ) [EOL] except lab46 : pass [EOL] self . cursor = self . limit - v_22 [EOL] [comment] [EOL] if not self . r_mark_yA ( ) : [EOL] raise lab43 ( ) [EOL] except lab44 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_23 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_24 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab49 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_25 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_25 [EOL] raise lab50 ( ) [EOL] except lab50 : pass [EOL] raise lab48 ( ) [EOL] except lab49 : pass [EOL] self . cursor = self . limit - v_24 [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_23 [EOL] raise lab47 ( ) [EOL] except lab48 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_23 [EOL] raise lab47 ( ) [EOL] except lab47 : pass [EOL] raise lab0 ( ) [EOL] except lab43 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] try : [EOL] v_26 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_possessives ( ) : [EOL] raise lab52 ( ) [EOL] raise lab51 ( ) [EOL] except lab52 : pass [EOL] self . cursor = self . limit - v_26 [EOL] [comment] [EOL] if not self . r_mark_sU ( ) : [EOL] return False [EOL] except lab51 : pass [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] v_27 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] if not self . r_mark_lAr ( ) : [EOL] self . cursor = self . limit - v_27 [EOL] raise lab53 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if not self . r_stem_suffix_chain_before_ki ( ) : [EOL] self . cursor = self . limit - v_27 [EOL] raise lab53 ( ) [EOL] except lab53 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_post_process_last_consonants ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( TurkishStemmer . a_23 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_append_U_to_stems_ending_with_d_or_g ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab5 ( ) [EOL] self . cursor = self . limit - v_5 [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] self . cursor = self . limit - v_5 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab3 ( ) [EOL] self . cursor -= [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab7 ( ) [EOL] raise lab6 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_8 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] self . cursor = self . limit - v_8 [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = self . limit - v_8 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab8 ( ) [EOL] self . cursor -= [number] [EOL] except lab9 : pass [EOL] [comment] [EOL] try : [EOL] v_9 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] self . cursor = self . limit - v_9 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab8 ( ) [EOL] except lab11 : pass [EOL] self . cursor = self . limit - v_7 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab8 : pass [EOL] self . cursor = self . limit - v_3 [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] v_10 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_11 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] self . cursor = self . limit - v_11 [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] self . cursor = self . limit - v_11 [EOL] if self . cursor <= self . limit_backward : [EOL] raise lab13 ( ) [EOL] self . cursor -= [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] v_12 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] self . cursor = self . limit - v_12 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab13 ( ) [EOL] except lab16 : pass [EOL] self . cursor = self . limit - v_10 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] raise lab2 ( ) [EOL] except lab13 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] [comment] [EOL] v_13 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_14 = self . limit - self . cursor [EOL] try : [EOL] if not self . in_grouping_b ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] self . cursor = self . limit - v_14 [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] self . cursor = self . limit - v_14 [EOL] if self . cursor <= self . limit_backward : [EOL] return False [EOL] self . cursor -= [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] v_15 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] self . cursor = self . limit - v_15 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] except lab20 : pass [EOL] self . cursor = self . limit - v_13 [EOL] [comment] [EOL] c = self . cursor [EOL] self . insert ( self . cursor , self . cursor , [string] ) [EOL] self . cursor = c [EOL] except lab2 : pass [EOL] return True [EOL] [EOL] def r_more_than_one_syllable_word ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] v_2 = [number] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( TurkishStemmer . g_vowel , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] v_2 -= [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_3 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] if v_2 > [number] : [EOL] return False [EOL] self . cursor = v_1 [EOL] return True [EOL] [EOL] def r_is_reserved_word ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] v_2 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab3 ( ) [EOL] raise lab2 ( ) [EOL] except lab3 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor += [number] [EOL] except lab2 : pass [EOL] [comment] [EOL] self . I_strlen = [number] ; [EOL] [comment] [EOL] if not self . I_strlen == self . limit : [EOL] raise lab1 ( ) [EOL] self . cursor = v_2 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_4 = self . cursor [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab5 ( ) [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] if self . cursor >= self . limit : [EOL] return False [EOL] self . cursor += [number] [EOL] except lab4 : pass [EOL] [comment] [EOL] self . I_strlen = [number] [EOL] [comment] [EOL] if not self . I_strlen == self . limit : [EOL] return False [EOL] self . cursor = v_4 [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . r_is_reserved_word ( ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_append_U_to_stems_ending_with_d_or_g ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_post_process_last_consonants ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] self . cursor = self . limit_backward [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not self . r_more_than_one_syllable_word ( ) : [EOL] return False [EOL] [comment] [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_stem_nominal_verb_suffixes ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . B_continue_stemming_noun_suffixes : [EOL] return False [EOL] [comment] [EOL] v_2 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_stem_noun_suffixes ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_2 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , TurkishStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL] class lab22 ( BaseException ) : pass [EOL] class lab23 ( BaseException ) : pass [EOL] class lab24 ( BaseException ) : pass [EOL] class lab25 ( BaseException ) : pass [EOL] class lab26 ( BaseException ) : pass [EOL] class lab27 ( BaseException ) : pass [EOL] class lab28 ( BaseException ) : pass [EOL] class lab29 ( BaseException ) : pass [EOL] class lab30 ( BaseException ) : pass [EOL] class lab31 ( BaseException ) : pass [EOL] class lab32 ( BaseException ) : pass [EOL] class lab33 ( BaseException ) : pass [EOL] class lab34 ( BaseException ) : pass [EOL] class lab35 ( BaseException ) : pass [EOL] class lab36 ( BaseException ) : pass [EOL] class lab37 ( BaseException ) : pass [EOL] class lab38 ( BaseException ) : pass [EOL] class lab39 ( BaseException ) : pass [EOL] class lab40 ( BaseException ) : pass [EOL] class lab41 ( BaseException ) : pass [EOL] class lab42 ( BaseException ) : pass [EOL] class lab43 ( BaseException ) : pass [EOL] class lab44 ( BaseException ) : pass [EOL] class lab45 ( BaseException ) : pass [EOL] class lab46 ( BaseException ) : pass [EOL] class lab47 ( BaseException ) : pass [EOL] class lab48 ( BaseException ) : pass [EOL] class lab49 ( BaseException ) : pass [EOL] class lab50 ( BaseException ) : pass [EOL] class lab51 ( BaseException ) : pass [EOL] class lab52 ( BaseException ) : pass [EOL] class lab53 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from . basestemmer import BaseStemmer [EOL] from . among import Among [EOL] [EOL] [EOL] class RomanianStemmer ( BaseStemmer ) : [EOL] [docstring] [EOL] serialVersionUID = [number] [EOL] [EOL] a_0 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_1 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) ] [EOL] [EOL] a_2 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_3 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_4 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] a_5 = [ Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , [number] , [number] ) , Among ( [string] , - [number] , [number] ) , Among ( [string] , - [number] , [number] ) ] [EOL] [EOL] g_v = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] B_standard_suffix_removed = False [EOL] I_p2 = [number] [EOL] I_p1 = [number] [EOL] I_pV = [number] [EOL] [EOL] def copy_from ( self , other ) : [EOL] self . B_standard_suffix_removed = other . B_standard_suffix_removed [EOL] self . I_p2 = other . I_p2 [EOL] self . I_p1 = other . I_p1 [EOL] self . I_pV = other . I_pV [EOL] super . copy_from ( other ) [EOL] [EOL] [EOL] def r_prelude ( self ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s ( [number] , [string] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] except lab5 : pass [EOL] self . cursor = v_2 [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_2 [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_mark_regions ( self ) : [EOL] [comment] [EOL] self . I_pV = self . limit ; [EOL] self . I_p1 = self . limit ; [EOL] self . I_p2 = self . limit ; [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] v_3 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab4 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab4 ( ) [EOL] self . cursor += [number] [EOL] except lab5 : pass [EOL] raise lab3 ( ) [EOL] except lab4 : pass [EOL] self . cursor = v_3 [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab8 ( ) [EOL] raise lab7 ( ) [EOL] except lab8 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] except lab7 : pass [EOL] except lab3 : pass [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] try : [EOL] v_6 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab10 ( ) [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab12 ( ) [EOL] raise lab11 ( ) [EOL] except lab12 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab10 ( ) [EOL] self . cursor += [number] [EOL] except lab11 : pass [EOL] raise lab9 ( ) [EOL] except lab10 : pass [EOL] self . cursor = v_6 [EOL] [comment] [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab0 ( ) [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab0 ( ) [EOL] self . cursor += [number] [EOL] except lab9 : pass [EOL] except lab1 : pass [EOL] [comment] [EOL] self . I_pV = self . cursor [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab15 ( ) [EOL] raise lab14 ( ) [EOL] except lab15 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab14 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab17 ( ) [EOL] raise lab16 ( ) [EOL] except lab17 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab16 : pass [EOL] [comment] [EOL] self . I_p1 = self . cursor [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . in_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab19 ( ) [EOL] raise lab18 ( ) [EOL] except lab19 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab18 : pass [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] if not self . out_grouping ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab21 ( ) [EOL] raise lab20 ( ) [EOL] except lab21 : pass [EOL] if self . cursor >= self . limit : [EOL] raise lab13 ( ) [EOL] self . cursor += [number] [EOL] except lab20 : pass [EOL] [comment] [EOL] self . I_p2 = self . cursor [EOL] except lab13 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def r_postlude ( self ) : [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] among_var = self . find_among ( RomanianStemmer . a_0 , [number] ) [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] [comment] [EOL] self . ket = self . cursor [EOL] if among_var == [number] : [EOL] raise lab2 ( ) [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if self . cursor >= self . limit : [EOL] raise lab2 ( ) [EOL] self . cursor += [number] [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] return True [EOL] [EOL] def r_RV ( self ) : [EOL] if not self . I_pV <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R1 ( self ) : [EOL] if not self . I_p1 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_R2 ( self ) : [EOL] if not self . I_p2 <= self . cursor : [EOL] return False [EOL] return True [EOL] [EOL] def r_step_0 ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_1 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] raise lab0 ( ) [EOL] return False [EOL] except lab0 : pass [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] def r_combo_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_2 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R1 ( ) : [EOL] return False [EOL] [comment] [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_standard_suffix_removed = True [EOL] self . cursor = self . limit - v_1 [EOL] return True [EOL] [EOL] def r_standard_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . B_standard_suffix_removed = False [EOL] [comment] [EOL] try : [EOL] while True : [EOL] try : [EOL] v_1 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_combo_suffix ( ) : [EOL] raise lab2 ( ) [EOL] raise lab1 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_1 [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] except lab0 : pass [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_3 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_R2 ( ) : [EOL] return False [EOL] [comment] [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_from ( [string] ) : [EOL] return False [EOL] [comment] [EOL] self . B_standard_suffix_removed = True [EOL] return True [EOL] [EOL] def r_verb_suffix ( self ) : [EOL] [comment] [EOL] v_1 = self . limit - self . cursor [EOL] [comment] [EOL] if self . cursor < self . I_pV : [EOL] return False [EOL] self . cursor = self . I_pV [EOL] v_2 = self . limit_backward [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit - v_1 [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_4 , [number] ) [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] if among_var == [number] : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] if not self . out_grouping_b ( RomanianStemmer . g_v , [number] , [number] ) : [EOL] raise lab1 ( ) [EOL] raise lab0 ( ) [EOL] except lab1 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] if not self . eq_s_b ( [number] , [string] ) : [EOL] self . limit_backward = v_2 [EOL] return False [EOL] except lab0 : pass [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] self . limit_backward = v_2 [EOL] return True [EOL] [EOL] def r_vowel_suffix ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . ket = self . cursor [EOL] [comment] [EOL] among_var = self . find_among_b ( RomanianStemmer . a_5 , [number] ) [EOL] if among_var == [number] : [EOL] return False [EOL] [comment] [EOL] self . bra = self . cursor [EOL] [comment] [EOL] if not self . r_RV ( ) : [EOL] return False [EOL] if among_var == [number] : [EOL] return False [EOL] elif among_var == [number] : [EOL] [comment] [EOL] [comment] [EOL] if not self . slice_del ( ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _stem ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v_1 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_prelude ( ) : [EOL] raise lab0 ( ) [EOL] except lab0 : pass [EOL] self . cursor = v_1 [EOL] [comment] [EOL] v_2 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_mark_regions ( ) : [EOL] raise lab1 ( ) [EOL] except lab1 : pass [EOL] self . cursor = v_2 [EOL] [comment] [EOL] self . limit_backward = self . cursor [EOL] self . cursor = self . limit [EOL] [comment] [EOL] [comment] [EOL] v_3 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_step_0 ( ) : [EOL] raise lab2 ( ) [EOL] except lab2 : pass [EOL] self . cursor = self . limit - v_3 [EOL] [comment] [EOL] v_4 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_standard_suffix ( ) : [EOL] raise lab3 ( ) [EOL] except lab3 : pass [EOL] self . cursor = self . limit - v_4 [EOL] [comment] [EOL] v_5 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] v_6 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . B_standard_suffix_removed : [EOL] raise lab6 ( ) [EOL] raise lab5 ( ) [EOL] except lab6 : pass [EOL] self . cursor = self . limit - v_6 [EOL] [comment] [EOL] if not self . r_verb_suffix ( ) : [EOL] raise lab4 ( ) [EOL] except lab5 : pass [EOL] except lab4 : pass [EOL] self . cursor = self . limit - v_5 [EOL] [comment] [EOL] v_7 = self . limit - self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_vowel_suffix ( ) : [EOL] raise lab7 ( ) [EOL] except lab7 : pass [EOL] self . cursor = self . limit - v_7 [EOL] self . cursor = self . limit_backward [EOL] [comment] [EOL] v_8 = self . cursor [EOL] try : [EOL] [comment] [EOL] if not self . r_postlude ( ) : [EOL] raise lab8 ( ) [EOL] except lab8 : pass [EOL] self . cursor = v_8 [EOL] return True [EOL] [EOL] def equals ( self , o ) : [EOL] return isinstance ( o , RomanianStemmer ) [EOL] [EOL] def hashCode ( self ) : [EOL] return hash ( [string] ) [EOL] class lab0 ( BaseException ) : pass [EOL] class lab1 ( BaseException ) : pass [EOL] class lab2 ( BaseException ) : pass [EOL] class lab3 ( BaseException ) : pass [EOL] class lab4 ( BaseException ) : pass [EOL] class lab5 ( BaseException ) : pass [EOL] class lab6 ( BaseException ) : pass [EOL] class lab7 ( BaseException ) : pass [EOL] class lab8 ( BaseException ) : pass [EOL] class lab9 ( BaseException ) : pass [EOL] class lab10 ( BaseException ) : pass [EOL] class lab11 ( BaseException ) : pass [EOL] class lab12 ( BaseException ) : pass [EOL] class lab13 ( BaseException ) : pass [EOL] class lab14 ( BaseException ) : pass [EOL] class lab15 ( BaseException ) : pass [EOL] class lab16 ( BaseException ) : pass [EOL] class lab17 ( BaseException ) : pass [EOL] class lab18 ( BaseException ) : pass [EOL] class lab19 ( BaseException ) : pass [EOL] class lab20 ( BaseException ) : pass [EOL] class lab21 ( BaseException ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Union , List , Tuple , Dict [EOL] import subprocess [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import shlex [EOL] import logging [EOL] import subprocess [EOL] from subprocess import PIPE , Popen [EOL] [EOL] [EOL] MYPY_SUPPORTED = False [EOL] MYPY_VERSION = None [EOL] try : [EOL] from mypy import main as mypy [EOL] MYPY_SUPPORTED = True [EOL] MYPY_VERSION = tuple ( int ( i ) for i in mypy . __version__ . replace ( [string] , [string] ) . split ( [string] ) ) [EOL] del mypy [EOL] except ImportError : [EOL] print ( [string] ) [EOL] logging . info ( [string] ) [EOL] pass [EOL] [EOL] [EOL] class MyPy ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , filename , mypypath , settings ) : [EOL] self . code = code [EOL] self . filename = filename [EOL] self . mypypath = mypypath [EOL] self . settings = settings [EOL] [EOL] @ property def silent ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] in self . settings [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] if not MYPY_SUPPORTED : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] errors = [ ] [EOL] try : [EOL] errors = self . check_source ( ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] logging . error ( error ) [EOL] [EOL] return errors [EOL] [EOL] def check_source ( self ) : [EOL] [docstring] [EOL] [EOL] err_ctx = [string] [EOL] if MYPY_VERSION < ( [number] , [number] , [number] ) : [EOL] err_ctx = [string] [EOL] [EOL] args = shlex . split ( [string] . format ( sys . executable , err_ctx , [string] . join ( self . settings [ : - [number] ] ) , self . filename ) ) [EOL] env = os . environ . copy ( ) [EOL] if self . mypypath is not None and self . mypypath != [string] : [EOL] env [ [string] ] = self . mypypath [EOL] [EOL] kwargs = { [string] : os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] : - [number] , [string] : env } [EOL] if os . name == [string] : [EOL] startupinfo = subprocess . STARTUPINFO ( ) [EOL] startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] kwargs [ [string] ] = startupinfo [EOL] [EOL] proc = Popen ( args , stdout = PIPE , stderr = PIPE , ** kwargs ) [EOL] out , err = proc . communicate ( ) [EOL] if err is not None and len ( err ) > [number] : [EOL] if sys . version_info >= ( [number] , ) : [EOL] err = err . decode ( [string] ) [EOL] raise RuntimeError ( err ) [EOL] [EOL] if sys . version_info >= ( [number] , ) : [EOL] out = out . decode ( [string] ) [EOL] [EOL] errors = [ ] [EOL] for line in out . splitlines ( ) : [EOL] if ( self . settings [ - [number] ] and not self . silent and [string] in line . lower ( ) ) : [EOL] continue [EOL] [EOL] data = line . split ( [string] ) if os . name != [string] else line [ [number] : ] . split ( [string] ) [EOL] errors . append ( { [string] : [string] , [string] : int ( data [ [number] ] ) , [string] : [number] , [string] : [string] , [string] : [string] . format ( data [ [number] ] , data [ [number] ] ) , [string] : [string] , [string] : True } ) [EOL] [EOL] return errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] try : [EOL] import pydocstyle [EOL] [EOL] class PEP257 ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , filename , ignore ) : [EOL] self . code = code [EOL] self . filename = filename [EOL] self . ignore = [ ] if ignore is None else ignore [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] try : [EOL] for error in pydocstyle . ConventionChecker ( ) . check_source ( self . code , self . filename ) : [EOL] error_code = getattr ( error , [string] , None ) [EOL] if error_code is not None and error_code not in self . ignore : [comment] [EOL] errors . append ( self . _convert ( error ) ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] [EOL] return errors [EOL] [EOL] def _convert ( self , error ) : [EOL] [docstring] [EOL] [EOL] return { [string] : [string] , [string] : error . line , [string] : [number] , [string] : error . code , [string] : [string] . format ( error . code , error . message . split ( [string] , [number] ) [ [number] ] ) , [string] : [string] , [string] : True } [EOL] except SyntaxError : [EOL] [comment] [EOL] class PEP257 ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , code , filename , ignore ) : [EOL] pass [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Optional , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import re [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . dirname ( __file__ ) ) [EOL] [EOL] import _ast [comment] [EOL] [EOL] import pycodestyle as pep8 [comment] [EOL] import pyflakes . checker as pyflakes [comment] [EOL] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] def cmp_to_key ( mycmp ) : [EOL] [docstring] [EOL] [EOL] class K ( object ) : [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , obj , * args ) : [EOL] self . obj = obj [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) < [number] [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) > [number] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) == [number] [EOL] [EOL] def __le__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) <= [number] [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) >= [number] [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return mycmp ( self . obj , other . obj ) != [number] [EOL] [EOL] def __hash__ ( self ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] return K [EOL] else : [EOL] from functools import cmp_to_key [EOL] [EOL] [EOL] pyflakes . messages . Message . __str__ = ( lambda self : self . message % self . message_args ) [EOL] [EOL] [EOL] class LintError ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , level , message , message_args , ** kwargs ) : [EOL] self . lineno = loc [EOL] self . level = level [EOL] self . message = message [EOL] self . message_args = message_args [EOL] [EOL] for k , v in kwargs . items ( ) : [EOL] setattr ( self , k , v ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] [EOL] return self . message % self . message_args [EOL] [EOL] [EOL] class Pep8Error ( LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text ) : [EOL] super ( Pep8Error , self ) . __init__ ( filename , loc , [string] , [string] , ( code , text ) , offset = offset , text = text ) [EOL] [EOL] [EOL] class Pep8Warning ( LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text ) : [EOL] super ( Pep8Warning , self ) . __init__ ( filename , loc , [string] , [string] , ( code , text ) , offset = offset , text = text ) [EOL] [EOL] [EOL] class PythonError ( LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , text ) : [EOL] super ( PythonError , self ) . __init__ ( filename , loc , [string] , [string] , ( text , ) , text = text ) [EOL] [EOL] [EOL] class OffsetError ( LintError ) : [EOL] [EOL] def __init__ ( self , filename , loc , text , offset ) : [EOL] super ( OffsetError , self ) . __init__ ( filename , loc , [string] , [string] , ( text , ) , offset = offset + [number] , text = text ) [EOL] [EOL] [EOL] class Linter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [EOL] self . enabled = False [EOL] [EOL] def pyflakes_check ( self , code , filename , ignore = None ) : [EOL] [docstring] [EOL] [EOL] class FakeLoc : [EOL] lineno = [number] [EOL] [EOL] try : [EOL] code = code . encode ( [string] ) + [string] [EOL] tree = compile ( code , filename or [string] , [string] , _ast . PyCF_ONLY_AST ) [EOL] except ( SyntaxError , IndentationError ) : [EOL] return self . _handle_syntactic_error ( code , filename ) [EOL] except ValueError as error : [EOL] return [ PythonError ( filename , FakeLoc ( ) , error . args [ [number] ] ) ] [EOL] else : [EOL] [comment] [EOL] w = pyflakes . Checker ( tree , filename , ignore ) [EOL] [EOL] return w . messages [EOL] [EOL] def pep8_check ( self , code , filename , rcfile , ignore , max_line_length ) : [EOL] [docstring] [EOL] [EOL] messages = [ ] [EOL] _lines = code . split ( [string] ) [EOL] [EOL] if _lines : [EOL] class FakeCol : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , line_number ) : [EOL] self . lineno = line_number [EOL] [EOL] class SublimeLinterReport ( pep8 . BaseReport ) : [EOL] [docstring] [EOL] [EOL] def error ( self , line_number , offset , text , check ) : [EOL] [docstring] [EOL] col = FakeCol ( line_number ) [EOL] code = text [ : [number] ] [EOL] message = text [ [number] : ] [EOL] [EOL] if self . _ignore_code ( code ) : [EOL] return [EOL] [EOL] if code in self . counters : [EOL] self . counters [ code ] += [number] [EOL] else : [EOL] self . counters [ code ] = [number] [EOL] self . messages [ code ] = message [EOL] [EOL] if code in self . expected : [EOL] return [EOL] [EOL] self . file_errors += [number] [EOL] self . total_errors += [number] [EOL] [EOL] pep8_error = code . startswith ( [string] ) [EOL] klass = Pep8Error if pep8_error else Pep8Warning [EOL] messages . append ( klass ( filename , col , offset , code , message ) ) [EOL] [EOL] return code [EOL] [EOL] params = { [string] : SublimeLinterReport } [EOL] if not rcfile : [EOL] _ignore = ignore + pep8 . DEFAULT_IGNORE . split ( [string] ) [EOL] params [ [string] ] = _ignore [EOL] else : [EOL] params [ [string] ] = os . path . expanduser ( rcfile ) [EOL] [EOL] options = pep8 . StyleGuide ( ** params ) . options [EOL] if not rcfile : [EOL] options . max_line_length = max_line_length [EOL] [EOL] good_lines = [ l + [string] for l in _lines ] [EOL] good_lines [ - [number] ] = good_lines [ - [number] ] . rstrip ( [string] ) [EOL] [EOL] if not good_lines [ - [number] ] : [EOL] good_lines = good_lines [ : - [number] ] [EOL] [EOL] pep8 . Checker ( filename , good_lines , options = options ) . check_all ( ) [EOL] [EOL] return messages [EOL] [EOL] def run_linter ( self , settings , code , filename ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] [EOL] if settings . get ( [string] , True ) : [EOL] check_params = { [string] : settings . get ( [string] , [ ] ) , [string] : settings . get ( [string] , pep8 . MAX_LINE_LENGTH ) } [EOL] errors . extend ( self . pep8_check ( code , filename , settings . get ( [string] ) , ** check_params ) ) [EOL] [EOL] pyflakes_ignore = settings . get ( [string] , None ) [EOL] pyflakes_disabled = settings . get ( [string] , False ) [EOL] explicit_ignore = settings . get ( [string] , [ ] ) [EOL] [EOL] if not pyflakes_disabled and not settings . get ( [string] ) : [EOL] errors . extend ( self . pyflakes_check ( code , filename , pyflakes_ignore ) ) [EOL] [EOL] return self . parse_errors ( errors , explicit_ignore ) [EOL] [EOL] def sort_errors ( self , errors ) : [EOL] [docstring] [EOL] errors . sort ( key = cmp_to_key ( lambda a , b : a . lineno < b . lineno ) ) [EOL] [EOL] def prepare_error_level ( self , error ) : [EOL] [docstring] [EOL] return [string] if not hasattr ( error , [string] ) else error . level [EOL] [EOL] def parse_errors ( self , errors , explicit_ignore ) : [EOL] [docstring] [EOL] [EOL] errors_list = [ ] [EOL] if errors is None : [EOL] return errors_list [EOL] [EOL] errors . sort ( key = cmp_to_key ( lambda a , b : a . lineno < b . lineno ) ) [EOL] for error in errors : [EOL] error_level = [string] if not hasattr ( error , [string] ) else error . level [EOL] message = error . message . capitalize ( ) [EOL] [EOL] offset = None [EOL] if hasattr ( error , [string] ) : [EOL] offset = error . offset [EOL] elif hasattr ( error , [string] ) : [EOL] offset = error . col [EOL] [EOL] error_data = { [string] : False , [string] : error_level , [string] : error . lineno , [string] : offset , [string] : message , [string] : str ( error ) } [EOL] [EOL] if isinstance ( error , ( Pep8Error , Pep8Warning , OffsetError ) ) : [EOL] error_data [ [string] ] = True [EOL] errors_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . RedefinedWhileUnused , pyflakes . messages . RedefinedInListComp , pyflakes . messages . UndefinedName , pyflakes . messages . UndefinedExport , pyflakes . messages . UndefinedLocal , pyflakes . messages . Redefined , pyflakes . messages . UnusedVariable ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] regex = ( [string] [string] . format ( re . escape ( error . message_args [ [number] ] ) ) ) [EOL] error_data [ [string] ] = len ( error . message_args [ [number] ] ) [EOL] error_data [ [string] ] = regex [EOL] errors_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . ImportShadowedByLoopVar ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] errors_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . UnusedImport , pyflakes . messages . ImportStarUsed ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] if isinstance ( error , pyflakes . messages . ImportStarUsed ) : [EOL] word = [string] [EOL] else : [EOL] word = error . message_args [ [number] ] [EOL] [EOL] linematch = [string] [EOL] r = [string] . format ( re . escape ( word ) ) [EOL] error_data [ [string] ] = r [EOL] error_data [ [string] ] = linematch [EOL] errors_list . append ( error_data ) [EOL] elif ( isinstance ( error , pyflakes . messages . DuplicateArgument ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] errors_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . LateFutureImport ) : [EOL] pass [EOL] elif isinstance ( error , PythonError ) : [EOL] print ( error ) [EOL] else : [EOL] print ( [string] , type ( error ) ) [EOL] [EOL] return errors_list [EOL] [EOL] def _handle_syntactic_error ( self , code , filename ) : [EOL] [docstring] [EOL] [EOL] value = sys . exc_info ( ) [ [number] ] [EOL] msg = value . args [ [number] ] [EOL] [EOL] lineno , offset , text = value . lineno , value . offset , value . text [EOL] [EOL] if text is None : [comment] [EOL] if msg . startswith ( [string] ) : [EOL] arg = msg . split ( [string] , [number] ) [ [number] ] . split ( [string] , [number] ) [ [number] ] . strip ( [string] ) [EOL] error = pyflakes . messages . DuplicateArgument ( filename , lineno , arg ) [EOL] else : [EOL] error = PythonError ( filename , value , msg ) [EOL] else : [EOL] line = text . splitlines ( ) [ - [number] ] [EOL] [EOL] if offset is not None : [EOL] offset = offset - ( len ( text ) - len ( line ) ) [EOL] [EOL] if offset is not None : [EOL] error = OffsetError ( filename , value , msg , offset ) [EOL] else : [EOL] error = PythonError ( filename , value , msg ) [EOL] [EOL] error . lineno = lineno [EOL] [EOL] return [ error ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.BaseException]$ 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $builtins.int$ 0 $typing.Optional[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import logging [EOL] import subprocess [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] from io import StringIO [EOL] else : [EOL] try : [EOL] from cStringIO import StringIO [EOL] except ImportError : [EOL] from StringIO import StringIO [EOL] assert StringIO [EOL] [EOL] [EOL] from pylint . __pkginfo__ import numversion [EOL] [EOL] from process import spawn [EOL] [EOL] PIPE = subprocess . PIPE [EOL] [EOL] [EOL] class PyLinter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , rcfile ) : [EOL] self . filename = filename [EOL] self . rcfile = rcfile [EOL] self . output = None [EOL] [EOL] self . execute ( ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [EOL] if numversion < ( [number] , [number] , [number] ) : [EOL] args = [string] . split ( [string] ) [EOL] else : [EOL] args = [string] . split ( [string] ) [EOL] [EOL] if self . rcfile : [EOL] args . append ( [string] . format ( os . path . expanduser ( self . rcfile ) ) ) [EOL] [EOL] args . append ( self . filename ) [EOL] args = [ sys . executable , [string] , [string] ] + args [EOL] [EOL] proc = spawn ( args , stdout = PIPE , stderr = PIPE , cwd = os . getcwd ( ) ) [EOL] if proc is None : [EOL] return { [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] [EOL] self . output , _ = proc . communicate ( ) [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] self . output = self . output . decode ( [string] ) [EOL] [EOL] def parse_errors ( self ) : [EOL] [docstring] [EOL] [EOL] errors = { [string] : [ ] , [string] : [ ] , [string] : [ ] } [EOL] data = self . output [EOL] [EOL] for error in data . splitlines ( ) : [EOL] if [string] in error : [EOL] _ , module = error . split ( [string] ) [EOL] if module not in self . filename : [EOL] continue [EOL] else : [EOL] offset = None [EOL] try : [EOL] if numversion >= ( [number] , [number] , [number] ) : [EOL] code , line , offset , message = error . split ( [string] , [number] ) [EOL] else : [EOL] code , line , message = error . split ( [string] , [number] ) [EOL] except ValueError as exception : [EOL] logging . debug ( [string] [string] . format ( exception ) ) [EOL] logging . debug ( [string] [string] . format ( error ) ) [EOL] continue [EOL] [EOL] if numversion < ( [number] , [number] , [number] ) : [EOL] try : [EOL] line , offset = line . split ( [string] ) [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] errors [ self . _map_code ( code ) [ [number] ] ] . append ( { [string] : int ( line ) , [string] : offset , [string] : self . _map_code ( code ) [ [number] ] , [string] : [string] . format ( self . _map_code ( code ) [ [number] ] , message ) } ) [EOL] [EOL] return errors [EOL] [EOL] def _map_code ( self , code ) : [EOL] [docstring] [EOL] [EOL] mapping = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return ( mapping [ code [ [number] ] ] , code [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Tuple , Any [EOL] import typing [EOL] import os [EOL] [EOL] import pycodestyle as pep8 [EOL] from linting import linter [EOL] [EOL] [EOL] class Pep8Error ( linter . LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text , level = [string] ) : [EOL] ct_tuple = ( code , text ) [EOL] err_str = [string] . format ( level ) [EOL] super ( Pep8Error , self ) . __init__ ( filename , loc , level , err_str , ct_tuple , offset = offset , text = text ) [EOL] [EOL] [EOL] class Pep8Warning ( linter . LintError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , offset , code , text , level = [string] ) : [EOL] ct_tuple = ( code , text ) [EOL] err_str = [string] . format ( level ) [EOL] super ( Pep8Warning , self ) . __init__ ( filename , loc , level , err_str , ct_tuple , offset = offset , text = text ) [EOL] [EOL] [EOL] class Pep8Linter ( linter . Linter ) : [EOL] [docstring] [EOL] [EOL] def lint ( self , settings , code , filename ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] check_params = { [string] : settings . get ( [string] , [ ] ) , [string] : settings . get ( [string] , pep8 . MAX_LINE_LENGTH ) , [string] : settings . get ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } ) } [EOL] errors . extend ( self . check ( code , filename , settings . get ( [string] ) , ** check_params ) ) [EOL] [EOL] return self . parse ( errors ) [EOL] [EOL] def check ( self , code , filename , rcfile , ignore , max_line_length , levels ) : [EOL] [docstring] [EOL] [EOL] messages = [ ] [EOL] _lines = code . split ( [string] ) [EOL] [EOL] if _lines : [EOL] class AnacondaReport ( pep8 . BaseReport ) : [EOL] [docstring] [EOL] [EOL] def error ( self , line_number , offset , text , check ) : [EOL] [docstring] [EOL] [EOL] col = line_number [EOL] code = text [ : [number] ] [EOL] message = text [ [number] : ] [EOL] [EOL] if self . _ignore_code ( code ) : [EOL] return [EOL] [EOL] if code in self . counters : [EOL] self . counters [ code ] += [number] [EOL] else : [EOL] self . counters [ code ] = [number] [EOL] self . messages [ code ] = message [EOL] [EOL] if code in self . expected : [EOL] return [EOL] [EOL] self . file_errors += [number] [EOL] self . total_errors += [number] [EOL] [EOL] pep8_error = code . startswith ( [string] ) [EOL] klass = Pep8Error if pep8_error else Pep8Warning [EOL] messages . append ( klass ( filename , col , offset , code , message , levels [ code [ [number] ] ] ) ) [EOL] [EOL] return code [EOL] [EOL] params = { [string] : AnacondaReport } [EOL] if not rcfile : [EOL] _ignore = ignore [EOL] params [ [string] ] = _ignore [EOL] else : [EOL] params [ [string] ] = os . path . expanduser ( rcfile ) [EOL] [EOL] options = pep8 . StyleGuide ( ** params ) . options [EOL] if not rcfile : [EOL] options . max_line_length = max_line_length [EOL] [EOL] good_lines = [ l + [string] for l in _lines ] [EOL] good_lines [ - [number] ] = good_lines [ - [number] ] . rstrip ( [string] ) [EOL] [EOL] if not good_lines [ - [number] ] : [EOL] good_lines = good_lines [ : - [number] ] [EOL] [EOL] pep8 . Checker ( filename , good_lines , options = options ) . check_all ( ) [EOL] [EOL] return messages [EOL] [EOL] def parse ( self , errors ) : [EOL] errors_list = [ ] [EOL] if errors is None : [EOL] return errors_list [EOL] [EOL] self . sort_errors ( errors ) [EOL] for error in errors : [EOL] error_level = self . prepare_error_level ( error ) [EOL] message = error . message . capitalize ( ) [EOL] offset = error . offset [EOL] [EOL] error_data = { [string] : True , [string] : error_level , [string] : error . lineno , [string] : offset , [string] : message , [string] : str ( error ) } [EOL] errors_list . append ( error_data ) [EOL] [EOL] return errors_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ast [EOL] [EOL] from . mccabe import McCabeChecker [EOL] [EOL] [EOL] class AnacondaMcCabe ( object ) : [EOL] [docstring] [EOL] [EOL] checker = McCabeChecker [EOL] [EOL] def __init__ ( self , code , filename ) : [EOL] self . code = code [EOL] self . filename = filename [EOL] [EOL] @ property def tree ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] code = self . code . encode ( [string] ) + [string] [EOL] return compile ( code , self . filename , [string] , ast . PyCF_ONLY_AST ) [EOL] except SyntaxError : [EOL] return None [EOL] [EOL] def get_code_complexity ( self , threshold = [number] ) : [EOL] [docstring] [EOL] [EOL] if self . tree is not None : [EOL] self . checker . max_complexity = threshold [EOL] return self . parse ( self . checker ( self . tree , self . filename ) . run ( ) ) [EOL] [EOL] return None [EOL] [EOL] def parse ( self , complexities ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] for complexity in complexities : [EOL] errors . append ( { [string] : int ( complexity [ [number] ] ) , [string] : int ( complexity [ [number] ] + [number] ) , [string] : complexity [ [number] ] . split ( [string] , [number] ) [ [number] ] , [string] : complexity [ [number] ] . split ( [string] , [number] ) [ [number] ] } ) [EOL] [EOL] return errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import List , Optional , Any [EOL] import optparse [EOL] import typing [EOL] [docstring] [EOL] from __future__ import with_statement [EOL] [EOL] import optparse [EOL] import sys [EOL] from collections import defaultdict [EOL] try : [EOL] import ast [EOL] from ast import iter_child_nodes [EOL] except ImportError : [comment] [EOL] from flake8 . util import ast , iter_child_nodes [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] class ASTVisitor ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . node = None [EOL] self . _cache = { } [EOL] [EOL] def default ( self , node , * args ) : [EOL] for child in iter_child_nodes ( node ) : [EOL] self . dispatch ( child , * args ) [EOL] [EOL] def dispatch ( self , node , * args ) : [EOL] self . node = node [EOL] klass = node . __class__ [EOL] meth = self . _cache . get ( klass ) [EOL] if meth is None : [EOL] className = klass . __name__ [EOL] meth = getattr ( self . visitor , [string] + className , self . default ) [EOL] self . _cache [ klass ] = meth [EOL] return meth ( node , * args ) [EOL] [EOL] def preorder ( self , tree , visitor , * args ) : [EOL] [docstring] [EOL] self . visitor = visitor [EOL] visitor . visit = self . dispatch [EOL] self . dispatch ( tree , * args ) [comment] [EOL] [EOL] [EOL] class PathNode ( object ) : [EOL] def __init__ ( self , name , look = [string] ) : [EOL] self . name = name [EOL] self . look = look [EOL] [EOL] def to_dot ( self ) : [EOL] print ( [string] % ( self . look , self . name , self . dot_id ( ) ) ) [EOL] [EOL] def dot_id ( self ) : [EOL] return id ( self ) [EOL] [EOL] [EOL] class PathGraph ( object ) : [EOL] def __init__ ( self , name , entity , lineno ) : [EOL] self . name = name [EOL] self . entity = entity [EOL] self . lineno = lineno [EOL] self . nodes = defaultdict ( list ) [EOL] [EOL] def connect ( self , n1 , n2 ) : [EOL] self . nodes [ n1 ] . append ( n2 ) [EOL] [EOL] def to_dot ( self ) : [EOL] print ( [string] ) [EOL] for node in self . nodes : [EOL] node . to_dot ( ) [EOL] for node , nexts in self . nodes . items ( ) : [EOL] for next in nexts : [EOL] print ( [string] % ( node . dot_id ( ) , next . dot_id ( ) ) ) [EOL] print ( [string] ) [EOL] [EOL] def complexity ( self ) : [EOL] [docstring] [EOL] num_edges = sum ( [ len ( n ) for n in self . nodes . values ( ) ] ) [EOL] num_nodes = len ( self . nodes ) [EOL] return num_edges - num_nodes + [number] [EOL] [EOL] [EOL] class PathGraphingAstVisitor ( ASTVisitor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( PathGraphingAstVisitor , self ) . __init__ ( ) [EOL] self . classname = [string] [EOL] self . graphs = { } [EOL] self . reset ( ) [EOL] [EOL] def reset ( self ) : [EOL] self . graph = None [EOL] self . tail = None [EOL] [EOL] def dispatch_list ( self , node_list ) : [EOL] for node in node_list : [EOL] self . dispatch ( node ) [EOL] [EOL] def visitFunctionDef ( self , node ) : [EOL] [EOL] if self . classname : [EOL] entity = [string] % ( self . classname , node . name ) [EOL] else : [EOL] entity = node . name [EOL] [EOL] name = [string] % ( node . lineno , entity ) [EOL] [EOL] if self . graph is not None : [EOL] [comment] [EOL] pathnode = self . appendPathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] self . graph . connect ( self . tail , bottom ) [EOL] self . graph . connect ( pathnode , bottom ) [EOL] self . tail = bottom [EOL] else : [EOL] self . graph = PathGraph ( name , entity , node . lineno ) [EOL] pathnode = PathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] self . graphs [ [string] % ( self . classname , node . name ) ] = self . graph [EOL] self . reset ( ) [EOL] [EOL] def visitClassDef ( self , node ) : [EOL] old_classname = self . classname [EOL] self . classname += node . name + [string] [EOL] self . dispatch_list ( node . body ) [EOL] self . classname = old_classname [EOL] [EOL] def appendPathNode ( self , name ) : [EOL] if not self . tail : [EOL] return [EOL] pathnode = PathNode ( name ) [EOL] self . graph . connect ( self . tail , pathnode ) [EOL] self . tail = pathnode [EOL] return pathnode [EOL] [EOL] def visitSimpleStatement ( self , node ) : [EOL] if node . lineno is None : [EOL] lineno = [number] [EOL] else : [EOL] lineno = node . lineno [EOL] name = [string] % lineno [EOL] self . appendPathNode ( name ) [EOL] [EOL] visitAssert = visitAssign = visitAugAssign = visitDelete = visitPrint = visitRaise = visitYield = visitImport = visitCall = visitSubscript = visitPass = visitContinue = visitBreak = visitGlobal = visitReturn = visitSimpleStatement [EOL] [EOL] def visitLoop ( self , node ) : [EOL] name = [string] % node . lineno [EOL] [EOL] if self . graph is None : [EOL] [comment] [EOL] self . graph = PathGraph ( name , name , node . lineno ) [EOL] pathnode = PathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] self . graphs [ [string] % ( self . classname , name ) ] = self . graph [EOL] self . reset ( ) [EOL] else : [EOL] pathnode = self . appendPathNode ( name ) [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . body ) [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] self . graph . connect ( self . tail , bottom ) [EOL] self . graph . connect ( pathnode , bottom ) [EOL] self . tail = bottom [EOL] [EOL] [comment] [EOL] [EOL] visitFor = visitWhile = visitLoop [EOL] [EOL] def visitIf ( self , node ) : [EOL] name = [string] % node . lineno [EOL] pathnode = self . appendPathNode ( name ) [EOL] loose_ends = [ ] [EOL] self . dispatch_list ( node . body ) [EOL] loose_ends . append ( self . tail ) [EOL] if node . orelse : [EOL] self . tail = pathnode [EOL] self . dispatch_list ( node . orelse ) [EOL] loose_ends . append ( self . tail ) [EOL] else : [EOL] loose_ends . append ( pathnode ) [EOL] if pathnode : [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] for le in loose_ends : [EOL] self . graph . connect ( le , bottom ) [EOL] self . tail = bottom [EOL] [EOL] def visitTryExcept ( self , node ) : [EOL] name = [string] % node . lineno [EOL] pathnode = self . appendPathNode ( name ) [EOL] loose_ends = [ ] [EOL] self . dispatch_list ( node . body ) [EOL] loose_ends . append ( self . tail ) [EOL] for handler in node . handlers : [EOL] self . tail = pathnode [EOL] self . dispatch_list ( handler . body ) [EOL] loose_ends . append ( self . tail ) [EOL] if pathnode : [EOL] bottom = PathNode ( [string] , look = [string] ) [EOL] for le in loose_ends : [EOL] self . graph . connect ( le , bottom ) [EOL] self . tail = bottom [EOL] [EOL] def visitWith ( self , node ) : [EOL] name = [string] % node . lineno [EOL] self . appendPathNode ( name ) [EOL] self . dispatch_list ( node . body ) [EOL] [EOL] [EOL] class McCabeChecker ( object ) : [EOL] [docstring] [EOL] name = [string] [EOL] version = __version__ [EOL] _code = [string] [EOL] _error_tmpl = [string] [EOL] max_complexity = [number] [EOL] [EOL] def __init__ ( self , tree , filename ) : [EOL] self . tree = tree [EOL] [EOL] @ classmethod def add_options ( cls , parser ) : [EOL] parser . add_option ( [string] , default = - [number] , action = [string] , type = [string] , help = [string] ) [EOL] parser . config_options . append ( [string] ) [EOL] [EOL] @ classmethod def parse_options ( cls , options ) : [EOL] cls . max_complexity = options . max_complexity [EOL] [EOL] def run ( self ) : [EOL] if self . max_complexity < [number] : [EOL] return [EOL] visitor = PathGraphingAstVisitor ( ) [EOL] visitor . preorder ( self . tree , visitor ) [EOL] for graph in visitor . graphs . values ( ) : [EOL] if graph . complexity ( ) >= self . max_complexity : [EOL] text = self . _error_tmpl % ( graph . entity , graph . complexity ( ) ) [EOL] yield graph . lineno , [number] , text , type ( self ) [EOL] [EOL] [EOL] def get_code_complexity ( code , threshold = [number] , filename = [string] ) : [EOL] try : [EOL] tree = compile ( code , filename , [string] , ast . PyCF_ONLY_AST ) [EOL] except SyntaxError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] sys . stderr . write ( [string] % ( filename , e ) ) [EOL] return [number] [EOL] [EOL] complx = [ ] [EOL] McCabeChecker . max_complexity = threshold [EOL] for lineno , offset , text , check in McCabeChecker ( tree , filename ) . run ( ) : [EOL] complx . append ( [string] % ( filename , lineno , text ) ) [EOL] [EOL] if len ( complx ) == [number] : [EOL] return [number] [EOL] print ( [string] . join ( complx ) ) [EOL] return len ( complx ) [EOL] [EOL] [EOL] def get_module_complexity ( module_path , threshold = [number] ) : [EOL] [docstring] [EOL] with open ( module_path , [string] ) as mod : [EOL] code = mod . read ( ) [EOL] return get_code_complexity ( code , threshold , filename = module_path ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] opar = optparse . OptionParser ( ) [EOL] opar . add_option ( [string] , [string] , dest = [string] , help = [string] , action = [string] ) [EOL] opar . add_option ( [string] , [string] , dest = [string] , help = [string] , type = [string] , default = [number] ) [EOL] [EOL] options , args = opar . parse_args ( argv ) [EOL] [EOL] with open ( args [ [number] ] , [string] ) as mod : [EOL] code = mod . read ( ) [EOL] tree = compile ( code , args [ [number] ] , [string] , ast . PyCF_ONLY_AST ) [EOL] visitor = PathGraphingAstVisitor ( ) [EOL] visitor . preorder ( tree , visitor ) [EOL] [EOL] if options . dot : [EOL] print ( [string] ) [EOL] for graph in visitor . graphs . values ( ) : [EOL] if graph . complexity ( ) >= options . threshold : [EOL] graph . to_dot ( ) [EOL] print ( [string] ) [EOL] else : [EOL] for graph in visitor . graphs . values ( ) : [EOL] if graph . complexity ( ) >= options . threshold : [EOL] print ( graph . name , graph . complexity ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import re [EOL] import _ast [EOL] [EOL] from linting import linter [EOL] import pyflakes . checker as pyflakes [EOL] [EOL] [EOL] pyflakes . messages . Message . __str__ = ( lambda self : self . message % self . message_args ) [EOL] [EOL] [EOL] class PyFlakesError ( pyflakes . messages . Message ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , loc , level , message , message_args , ** kwargs ) : [EOL] super ( PyFlakesError , self ) . __init__ ( filename , loc ) [EOL] [EOL] self . level = level [EOL] self . message = message [EOL] self . message_args = message_args [EOL] [EOL] [EOL] class PyFlakesLinter ( linter . Linter ) : [EOL] [docstring] [EOL] [EOL] def lint ( self , settings , code , filename ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] pyflakes_ignore = settings . get ( [string] , None ) [EOL] pyflakes_disabled = settings . get ( [string] , False ) [EOL] explicit_ignore = settings . get ( [string] , [ ] ) [EOL] [EOL] if not pyflakes_disabled and not settings . get ( [string] ) : [EOL] errors . extend ( self . check ( code , filename , pyflakes_ignore ) ) [EOL] [EOL] return self . parse ( errors , explicit_ignore ) [EOL] [EOL] def check ( self , code , filename , ignore = None ) : [EOL] [docstring] [EOL] [EOL] class FakeLoc : [EOL] lineno = [number] [EOL] [EOL] try : [EOL] fname = [string] [EOL] if filename is not None : [EOL] fname = filename . encode ( [string] ) or [string] [EOL] code = code . encode ( [string] ) + [string] [EOL] tree = compile ( code , fname , [string] , _ast . PyCF_ONLY_AST ) [EOL] except ( SyntaxError , IndentationError ) : [EOL] return self . _handle_syntactic_error ( code , filename ) [EOL] except ValueError as error : [EOL] return [ PyFlakesError ( filename , FakeLoc ( ) , [string] , error . args [ [number] ] ) , [ ] ] [EOL] else : [EOL] [comment] [EOL] w = pyflakes . Checker ( tree , filename , ignore ) [EOL] [EOL] return w . messages [EOL] [EOL] def parse ( self , errors , explicit_ignore ) : [EOL] [docstring] [EOL] [EOL] error_list = [ ] [EOL] if errors is None : [EOL] return error_list [EOL] [EOL] errors . sort ( key = linter . cmp_to_key ( lambda a , b : a . lineno < b . lineno ) ) [EOL] for error in errors : [EOL] error_level = [string] if not hasattr ( error , [string] ) else error . level [EOL] message = error . message . capitalize ( ) [EOL] [EOL] error_data = { [string] : False , [string] : error_level , [string] : error . lineno , [string] : message , [string] : str ( error ) } [EOL] if hasattr ( error , [string] ) : [EOL] error_data [ [string] ] = error . offset [EOL] elif hasattr ( error , [string] ) : [EOL] error_data [ [string] ] = error . col [EOL] [EOL] if ( isinstance ( error , ( linter . OffsetError ) ) ) : [EOL] error_data [ [string] ] = True [EOL] error_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . RedefinedWhileUnused , pyflakes . messages . RedefinedInListComp , pyflakes . messages . UndefinedName , pyflakes . messages . UndefinedExport , pyflakes . messages . UndefinedLocal , pyflakes . messages . UnusedVariable ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] [EOL] error_data [ [string] ] = len ( error . message_args [ [number] ] ) [EOL] error_data [ [string] ] = ( [string] [string] . format ( re . escape ( error . message_args [ [number] ] ) ) ) [EOL] error_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . ImportShadowedByLoopVar ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] error_list . append ( error_data ) [EOL] elif ( isinstance ( error , ( pyflakes . messages . UnusedImport , pyflakes . messages . ImportStarUsed ) ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] if isinstance ( error , pyflakes . messages . ImportStarUsed ) : [EOL] word = [string] [EOL] else : [EOL] word = error . message_args [ [number] ] [EOL] [EOL] linematch = [string] [EOL] r = [string] . format ( re . escape ( word ) ) [EOL] error_data [ [string] ] = r [EOL] error_data [ [string] ] = linematch [EOL] error_list . append ( error_data ) [EOL] elif ( isinstance ( error , pyflakes . messages . DuplicateArgument ) and error . __class__ . __name__ not in explicit_ignore ) : [EOL] regex = [string] . format ( re . escape ( error . message_args [ [number] ] ) ) [EOL] error_data [ [string] ] = regex [EOL] error_list . append ( error_data ) [EOL] elif isinstance ( error , pyflakes . messages . LateFutureImport ) : [EOL] pass [EOL] elif isinstance ( error , linter . PythonError ) : [EOL] print ( error ) [EOL] else : [EOL] print ( [string] , type ( error ) ) [EOL] [EOL] return error_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0
import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class Message ( object ) : [EOL] message = [string] [EOL] message_args = ( ) [EOL] [EOL] def __init__ ( self , filename , loc ) : [EOL] self . filename = filename [EOL] self . lineno = loc . lineno [EOL] self . col = getattr ( loc , [string] , [number] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . filename , self . lineno , self . message % self . message_args ) [EOL] [EOL] [EOL] class UnusedImport ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class RedefinedWhileUnused ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class RedefinedInListComp ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class ImportShadowedByLoopVar ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class ImportStarNotPermitted ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , modname ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( modname , ) [EOL] [EOL] [EOL] class ImportStarUsed ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , modname ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( modname , ) [EOL] [EOL] [EOL] class ImportStarUsage ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name , from_list ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , from_list ) [EOL] [EOL] [EOL] class UndefinedName ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class DoctestSyntaxError ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , position = None ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] if position : [EOL] ( self . lineno , self . col ) = position [EOL] self . message_args = ( ) [EOL] [EOL] [EOL] class UndefinedExport ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class UndefinedLocal ( Message ) : [EOL] message = ( [string] [string] ) [EOL] [EOL] def __init__ ( self , filename , loc , name , orig_loc ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , orig_loc . lineno ) [EOL] [EOL] [EOL] class DuplicateArgument ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class MultiValueRepeatedKeyLiteral ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , key ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( key , ) [EOL] [EOL] [EOL] class MultiValueRepeatedKeyVariable ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , key ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( key , ) [EOL] [EOL] [EOL] class LateFutureImport ( Message ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , names ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( ) [EOL] [EOL] [EOL] class FutureFeatureNotDefined ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , name ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class UnusedVariable ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] def __init__ ( self , filename , loc , names ) : [EOL] Message . __init__ ( self , filename , loc ) [EOL] self . message_args = ( names , ) [EOL] [EOL] [EOL] class ReturnWithArgsInsideGenerator ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class ReturnOutsideFunction ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class YieldOutsideFunction ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class ContinueOutsideLoop ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class BreakOutsideLoop ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class ContinueInFinally ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class DefaultExceptNotLast ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class TwoStarredExpressions ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class TooManyExpressionsInStarredAssignment ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL] [EOL] [EOL] class AssertTuple ( Message ) : [EOL] [docstring] [EOL] message = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] import threading [EOL] [EOL] from . autopep8_lib import autopep8 [EOL] [EOL] [EOL] class AnacondaAutopep8 ( threading . Thread ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , settings , code , callback ) : [EOL] threading . Thread . __init__ ( self ) [EOL] self . code = code [EOL] self . callback = callback [EOL] self . options , _ = autopep8 . parse_args ( self . parse_settings ( settings ) ) [EOL] [EOL] def run ( self ) : [EOL] self . callback ( autopep8 . fix_string ( self . code , options = self . options ) ) [EOL] [EOL] def parse_settings ( self , settings ) : [EOL] [docstring] [EOL] [EOL] args = [ ] [EOL] args += [ [string] ] * settings . get ( [string] , [number] ) [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] if len ( settings . get ( [string] , [ ] ) ) > [number] : [EOL] args += [ [string] . format ( [string] . join ( settings . get ( [string] ) ) ) ] [EOL] [EOL] args += [ [string] . format ( settings . get ( [string] , [number] ) ) ] [EOL] args += [ [string] ] [EOL] [EOL] return args [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from . autopep_wrapper import AnacondaAutopep8 [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Optional , Any , Union , Literal , DefaultDict , Type , Match , List , Tuple , Pattern , Set , Iterator , Dict [EOL] import typing_extensions [EOL] import argparse [EOL] import io [EOL] import multiprocessing [EOL] import typing [EOL] import configparser [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] import codecs [EOL] import collections [EOL] import copy [EOL] import difflib [EOL] import fnmatch [EOL] import inspect [EOL] import io [EOL] import keyword [EOL] import locale [EOL] import os [EOL] import re [EOL] import signal [EOL] import sys [EOL] import textwrap [EOL] import token [EOL] import tokenize [EOL] [EOL] import pycodestyle [EOL] [EOL] [EOL] try : [EOL] unicode [EOL] except NameError : [EOL] unicode = str [EOL] [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] CR = [string] [EOL] LF = [string] [EOL] CRLF = [string] [EOL] [EOL] [EOL] PYTHON_SHEBANG_REGEX = re . compile ( [string] ) [EOL] LAMBDA_REGEX = re . compile ( [string] ) [EOL] COMPARE_NEGATIVE_REGEX = re . compile ( [string] ) [EOL] COMPARE_NEGATIVE_REGEX_THROUGH = re . compile ( [string] ) [EOL] BARE_EXCEPT_REGEX = re . compile ( [string] ) [EOL] STARTSWITH_DEF_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] SHORTEN_OPERATOR_GROUPS = frozenset ( [ frozenset ( [ [string] ] ) , frozenset ( [ [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , frozenset ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) , ] ) [EOL] [EOL] [EOL] DEFAULT_IGNORE = [string] [EOL] DEFAULT_INDENT_SIZE = [number] [EOL] [EOL] [EOL] [comment] [EOL] CODE_TO_2TO3 = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] [EOL] if sys . platform == [string] : [comment] [EOL] DEFAULT_CONFIG = os . path . expanduser ( [string] ) [EOL] else : [EOL] DEFAULT_CONFIG = os . path . join ( os . getenv ( [string] ) or os . path . expanduser ( [string] ) , [string] ) [EOL] PROJECT_CONFIG = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] MAX_PYTHON_FILE_DETECTION_BYTES = [number] [EOL] [EOL] [EOL] def open_with_encoding ( filename , encoding = None , mode = [string] , limit_byte_check = - [number] ) : [EOL] [docstring] [EOL] if not encoding : [EOL] encoding = detect_encoding ( filename , limit_byte_check = limit_byte_check ) [EOL] [EOL] return io . open ( filename , mode = mode , encoding = encoding , newline = [string] ) [comment] [EOL] [EOL] [EOL] def detect_encoding ( filename , limit_byte_check = - [number] ) : [EOL] [docstring] [EOL] try : [EOL] with open ( filename , [string] ) as input_file : [EOL] from lib2to3 . pgen2 import tokenize as lib2to3_tokenize [EOL] encoding = lib2to3_tokenize . detect_encoding ( input_file . readline ) [ [number] ] [EOL] [EOL] with open_with_encoding ( filename , encoding ) as test_file : [EOL] test_file . read ( limit_byte_check ) [EOL] [EOL] return encoding [EOL] except ( LookupError , SyntaxError , UnicodeDecodeError ) : [EOL] return [string] [EOL] [EOL] [EOL] def readlines_from_file ( filename ) : [EOL] [docstring] [EOL] with open_with_encoding ( filename ) as input_file : [EOL] return input_file . readlines ( ) [EOL] [EOL] [EOL] def extended_blank_lines ( logical_line , blank_lines , blank_before , indent_level , previous_logical ) : [EOL] [docstring] [EOL] if previous_logical . startswith ( [string] ) : [EOL] if blank_lines and pycodestyle . DOCSTRING_REGEX . match ( logical_line ) : [EOL] yield ( [number] , [string] . format ( blank_lines ) ) [EOL] elif pycodestyle . DOCSTRING_REGEX . match ( previous_logical ) : [EOL] [comment] [EOL] if ( indent_level and not blank_lines and not blank_before and logical_line . startswith ( ( [string] ) ) and [string] in logical_line ) : [EOL] yield ( [number] , [string] ) [EOL] [EOL] [EOL] pycodestyle . register_check ( extended_blank_lines ) [EOL] [EOL] [EOL] def continued_indentation ( logical_line , tokens , indent_level , indent_char , noqa ) : [EOL] [docstring] [EOL] first_row = tokens [ [number] ] [ [number] ] [ [number] ] [EOL] nrows = [number] + tokens [ - [number] ] [ [number] ] [ [number] ] - first_row [EOL] if noqa or nrows == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] indent_next = logical_line . endswith ( [string] ) [EOL] [EOL] row = depth = [number] [EOL] valid_hangs = ( ( DEFAULT_INDENT_SIZE , ) [EOL] if indent_char != [string] else ( DEFAULT_INDENT_SIZE , [number] * DEFAULT_INDENT_SIZE ) ) [EOL] [EOL] [comment] [EOL] parens = [ [number] ] * nrows [EOL] [EOL] [comment] [EOL] rel_indent = [ [number] ] * nrows [EOL] [EOL] [comment] [EOL] open_rows = [ [ [number] ] ] [EOL] [comment] [EOL] hangs = [ None ] [EOL] [EOL] [comment] [EOL] indent_chances = { } [EOL] last_indent = tokens [ [number] ] [ [number] ] [EOL] indent = [ last_indent [ [number] ] ] [EOL] [EOL] last_token_multiline = None [EOL] line = None [EOL] last_line = [string] [EOL] last_line_begins_with_multiline = False [EOL] for token_type , text , start , end , line in tokens : [EOL] [EOL] newline = row < start [ [number] ] - first_row [EOL] if newline : [EOL] row = start [ [number] ] - first_row [EOL] newline = ( not last_token_multiline and token_type not in ( tokenize . NL , tokenize . NEWLINE ) ) [EOL] last_line_begins_with_multiline = last_token_multiline [EOL] [EOL] if newline : [EOL] [comment] [EOL] last_indent = start [EOL] [EOL] [comment] [EOL] rel_indent [ row ] = pycodestyle . expand_indent ( line ) - indent_level [EOL] [EOL] [comment] [EOL] close_bracket = ( token_type == tokenize . OP and text in [string] ) [EOL] [EOL] [comment] [EOL] for open_row in reversed ( open_rows [ depth ] ) : [EOL] hang = rel_indent [ row ] - rel_indent [ open_row ] [EOL] hanging_indent = hang in valid_hangs [EOL] if hanging_indent : [EOL] break [EOL] if hangs [ depth ] : [EOL] hanging_indent = ( hang == hangs [ depth ] ) [EOL] [EOL] visual_indent = ( not close_bracket and hang > [number] and indent_chances . get ( start [ [number] ] ) ) [EOL] [EOL] if close_bracket and indent [ depth ] : [EOL] [comment] [EOL] if start [ [number] ] != indent [ depth ] : [EOL] yield ( start , [string] . format ( indent [ depth ] ) ) [EOL] elif close_bracket and not hang : [EOL] pass [EOL] elif indent [ depth ] and start [ [number] ] < indent [ depth ] : [EOL] [comment] [EOL] yield ( start , [string] . format ( indent [ depth ] ) ) [EOL] elif ( hanging_indent or ( indent_next and rel_indent [ row ] == [number] * DEFAULT_INDENT_SIZE ) ) : [EOL] [comment] [EOL] if close_bracket : [EOL] yield ( start , [string] . format ( indent_level + rel_indent [ open_row ] ) ) [EOL] hangs [ depth ] = hang [EOL] elif visual_indent is True : [EOL] [comment] [EOL] indent [ depth ] = start [ [number] ] [EOL] elif visual_indent in ( text , unicode ) : [EOL] [comment] [EOL] pass [EOL] else : [EOL] one_indented = ( indent_level + rel_indent [ open_row ] + DEFAULT_INDENT_SIZE ) [EOL] [comment] [EOL] if hang <= [number] : [EOL] error = ( [string] , one_indented ) [EOL] elif indent [ depth ] : [EOL] error = ( [string] , indent [ depth ] ) [EOL] elif not close_bracket and hangs [ depth ] : [EOL] error = ( [string] , one_indented ) [EOL] elif hang > DEFAULT_INDENT_SIZE : [EOL] error = ( [string] , one_indented ) [EOL] else : [EOL] hangs [ depth ] = hang [EOL] error = ( [string] , one_indented ) [EOL] [EOL] yield ( start , [string] . format ( * error ) ) [EOL] [EOL] [comment] [EOL] if ( parens [ row ] and token_type not in ( tokenize . NL , tokenize . COMMENT ) and not indent [ depth ] ) : [EOL] indent [ depth ] = start [ [number] ] [EOL] indent_chances [ start [ [number] ] ] = True [EOL] [comment] [EOL] elif ( token_type in ( tokenize . STRING , tokenize . COMMENT ) or text in ( [string] , [string] , [string] , [string] ) ) : [EOL] indent_chances [ start [ [number] ] ] = unicode [EOL] [comment] [EOL] [comment] [EOL] elif not indent_chances and not row and not depth and text == [string] : [EOL] indent_chances [ end [ [number] ] + [number] ] = True [EOL] elif text == [string] and line [ end [ [number] ] : ] . isspace ( ) : [EOL] open_rows [ depth ] . append ( row ) [EOL] [EOL] [comment] [EOL] if token_type == tokenize . OP : [EOL] if text in [string] : [EOL] depth += [number] [EOL] indent . append ( [number] ) [EOL] hangs . append ( None ) [EOL] if len ( open_rows ) == depth : [EOL] open_rows . append ( [ ] ) [EOL] open_rows [ depth ] . append ( row ) [EOL] parens [ row ] += [number] [EOL] elif text in [string] and depth > [number] : [EOL] [comment] [EOL] prev_indent = indent . pop ( ) or last_indent [ [number] ] [EOL] hangs . pop ( ) [EOL] for d in range ( depth ) : [EOL] if indent [ d ] > prev_indent : [EOL] indent [ d ] = [number] [EOL] for ind in list ( indent_chances ) : [EOL] if ind >= prev_indent : [EOL] del indent_chances [ ind ] [EOL] del open_rows [ depth + [number] : ] [EOL] depth -= [number] [EOL] if depth : [EOL] indent_chances [ indent [ depth ] ] = True [EOL] for idx in range ( row , - [number] , - [number] ) : [EOL] if parens [ idx ] : [EOL] parens [ idx ] -= [number] [EOL] break [EOL] assert len ( indent ) == depth + [number] [EOL] if ( start [ [number] ] not in indent_chances and not last_line . rstrip ( ) . endswith ( [string] ) ) : [EOL] [comment] [EOL] indent_chances [ start [ [number] ] ] = text [EOL] [EOL] last_token_multiline = ( start [ [number] ] != end [ [number] ] ) [EOL] if last_token_multiline : [EOL] rel_indent [ end [ [number] ] - first_row ] = rel_indent [ row ] [EOL] [EOL] last_line = line [EOL] [EOL] if ( indent_next and not last_line_begins_with_multiline and pycodestyle . expand_indent ( line ) == indent_level + DEFAULT_INDENT_SIZE ) : [EOL] pos = ( start [ [number] ] , indent [ [number] ] + [number] ) [EOL] desired_indent = indent_level + [number] * DEFAULT_INDENT_SIZE [EOL] if visual_indent : [EOL] yield ( pos , [string] . format ( desired_indent ) ) [EOL] else : [EOL] yield ( pos , [string] . format ( desired_indent ) ) [EOL] [EOL] [EOL] del pycodestyle . _checks [ [string] ] [ pycodestyle . continued_indentation ] [EOL] pycodestyle . register_check ( continued_indentation ) [EOL] [EOL] [EOL] class FixPEP8 ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , options , contents = None , long_line_ignore_cache = None ) : [EOL] self . filename = filename [EOL] if contents is None : [EOL] self . source = readlines_from_file ( filename ) [EOL] else : [EOL] sio = io . StringIO ( contents ) [EOL] self . source = sio . readlines ( ) [EOL] self . options = options [EOL] self . indent_word = _get_indentword ( [string] . join ( self . source ) ) [EOL] [EOL] self . long_line_ignore_cache = ( set ( ) if long_line_ignore_cache is None [EOL] else long_line_ignore_cache ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . fix_e115 = self . fix_e112 [EOL] self . fix_e116 = self . fix_e113 [EOL] self . fix_e121 = self . _fix_reindent [EOL] self . fix_e122 = self . _fix_reindent [EOL] self . fix_e123 = self . _fix_reindent [EOL] self . fix_e124 = self . _fix_reindent [EOL] self . fix_e126 = self . _fix_reindent [EOL] self . fix_e127 = self . _fix_reindent [EOL] self . fix_e128 = self . _fix_reindent [EOL] self . fix_e129 = self . _fix_reindent [EOL] self . fix_e202 = self . fix_e201 [EOL] self . fix_e203 = self . fix_e201 [EOL] self . fix_e211 = self . fix_e201 [EOL] self . fix_e221 = self . fix_e271 [EOL] self . fix_e222 = self . fix_e271 [EOL] self . fix_e223 = self . fix_e271 [EOL] self . fix_e226 = self . fix_e225 [EOL] self . fix_e227 = self . fix_e225 [EOL] self . fix_e228 = self . fix_e225 [EOL] self . fix_e241 = self . fix_e271 [EOL] self . fix_e242 = self . fix_e224 [EOL] self . fix_e261 = self . fix_e262 [EOL] self . fix_e272 = self . fix_e271 [EOL] self . fix_e273 = self . fix_e271 [EOL] self . fix_e274 = self . fix_e271 [EOL] self . fix_e306 = self . fix_e301 [EOL] self . fix_e501 = ( self . fix_long_line_logically if [EOL] options and ( options . aggressive >= [number] or options . experimental ) else [EOL] self . fix_long_line_physically ) [EOL] self . fix_e703 = self . fix_e702 [EOL] self . fix_w293 = self . fix_w291 [EOL] [EOL] def _fix_source ( self , results ) : [EOL] try : [EOL] ( logical_start , logical_end ) = _find_logical ( self . source ) [EOL] logical_support = True [EOL] except ( SyntaxError , tokenize . TokenError ) : [comment] [EOL] logical_support = False [EOL] [EOL] completed_lines = set ( ) [EOL] for result in sorted ( results , key = _priority_key ) : [EOL] if result [ [string] ] in completed_lines : [EOL] continue [EOL] [EOL] fixed_methodname = [string] + result [ [string] ] . lower ( ) [EOL] if hasattr ( self , fixed_methodname ) : [EOL] fix = getattr ( self , fixed_methodname ) [EOL] [EOL] line_index = result [ [string] ] - [number] [EOL] original_line = self . source [ line_index ] [EOL] [EOL] is_logical_fix = len ( _get_parameters ( fix ) ) > [number] [EOL] if is_logical_fix : [EOL] logical = None [EOL] if logical_support : [EOL] logical = _get_logical ( self . source , result , logical_start , logical_end ) [EOL] if logical and set ( range ( logical [ [number] ] [ [number] ] + [number] , logical [ [number] ] [ [number] ] + [number] ) ) . intersection ( completed_lines ) : [EOL] continue [EOL] [EOL] modified_lines = fix ( result , logical ) [EOL] else : [EOL] modified_lines = fix ( result ) [EOL] [EOL] if modified_lines is None : [EOL] [comment] [EOL] assert not is_logical_fix [EOL] [EOL] if self . source [ line_index ] == original_line : [EOL] modified_lines = [ ] [EOL] [EOL] if modified_lines : [EOL] completed_lines . update ( modified_lines ) [EOL] elif modified_lines == [ ] : [comment] [EOL] if self . options . verbose >= [number] : [EOL] print ( [string] . format ( error = result [ [string] ] , line = result [ [string] ] ) , file = sys . stderr ) [EOL] else : [comment] [EOL] completed_lines . add ( result [ [string] ] ) [EOL] else : [EOL] if self . options . verbose >= [number] : [EOL] print ( [string] . format ( fixed_methodname ) , file = sys . stderr ) [EOL] [EOL] info = result [ [string] ] . strip ( ) [EOL] print ( [string] . format ( self . filename , result [ [string] ] , result [ [string] ] , info ) , file = sys . stderr ) [EOL] [EOL] def fix ( self ) : [EOL] [docstring] [EOL] pep8_options = { [string] : self . options . ignore , [string] : self . options . select , [string] : self . options . max_line_length , } [EOL] results = _execute_pep8 ( pep8_options , self . source ) [EOL] [EOL] if self . options . verbose : [EOL] progress = { } [EOL] for r in results : [EOL] if r [ [string] ] not in progress : [EOL] progress [ r [ [string] ] ] = set ( ) [EOL] progress [ r [ [string] ] ] . add ( r [ [string] ] ) [EOL] print ( [string] . format ( n = len ( results ) , progress = progress ) , file = sys . stderr ) [EOL] [EOL] if self . options . line_range : [EOL] start , end = self . options . line_range [EOL] results = [ r for r in results if start <= r [ [string] ] <= end ] [EOL] [EOL] self . _fix_source ( filter_results ( source = [string] . join ( self . source ) , results = results , aggressive = self . options . aggressive ) ) [EOL] [EOL] if self . options . line_range : [EOL] [comment] [EOL] count = sum ( sline . count ( [string] ) for sline in self . source [ start - [number] : end ] ) [EOL] self . options . line_range [ [number] ] = start + count - [number] [EOL] [EOL] return [string] . join ( self . source ) [EOL] [EOL] def _fix_reindent ( self , result ) : [EOL] [docstring] [EOL] num_indent_spaces = int ( result [ [string] ] . split ( ) [ [number] ] ) [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] self . source [ line_index ] = [string] * num_indent_spaces + target . lstrip ( ) [EOL] [EOL] def fix_e112 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] if not target . lstrip ( ) . startswith ( [string] ) : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] self . source [ line_index ] = self . indent_word + target [EOL] [EOL] def fix_e113 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] indent = _get_indentation ( target ) [EOL] stripped = target . lstrip ( ) [EOL] [EOL] if not stripped . startswith ( [string] ) : [EOL] [comment] [EOL] return [ ] [EOL] [EOL] self . source [ line_index ] = indent [ [number] : ] + stripped [EOL] [EOL] def fix_e125 ( self , result ) : [EOL] [docstring] [EOL] num_indent_spaces = int ( result [ [string] ] . split ( ) [ [number] ] ) [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] spaces_to_add = num_indent_spaces - len ( _get_indentation ( target ) ) [EOL] indent = len ( _get_indentation ( target ) ) [EOL] modified_lines = [ ] [EOL] [EOL] while len ( _get_indentation ( self . source [ line_index ] ) ) >= indent : [EOL] self . source [ line_index ] = ( [string] * spaces_to_add + self . source [ line_index ] ) [EOL] modified_lines . append ( [number] + line_index ) [comment] [EOL] line_index -= [number] [EOL] [EOL] return modified_lines [EOL] [EOL] def fix_e131 ( self , result ) : [EOL] [docstring] [EOL] num_indent_spaces = int ( result [ [string] ] . split ( ) [ [number] ] ) [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] spaces_to_add = num_indent_spaces - len ( _get_indentation ( target ) ) [EOL] [EOL] if spaces_to_add >= [number] : [EOL] self . source [ line_index ] = ( [string] * spaces_to_add + self . source [ line_index ] ) [EOL] else : [EOL] offset = abs ( spaces_to_add ) [EOL] self . source [ line_index ] = self . source [ line_index ] [ offset : ] [EOL] [EOL] def fix_e201 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] - [number] [EOL] [EOL] fixed = fix_whitespace ( target , offset = offset , replacement = [string] ) [EOL] [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_e224 ( self , result ) : [EOL] [docstring] [EOL] target = self . source [ result [ [string] ] - [number] ] [EOL] offset = result [ [string] ] - [number] [EOL] fixed = target [ : offset ] + target [ offset : ] . replace ( [string] , [string] ) [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] [EOL] def fix_e225 ( self , result ) : [EOL] [docstring] [EOL] target = self . source [ result [ [string] ] - [number] ] [EOL] offset = result [ [string] ] - [number] [EOL] fixed = target [ : offset ] + [string] + target [ offset : ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( fixed . replace ( [string] , [string] ) == target . replace ( [string] , [string] ) and _get_indentation ( fixed ) == _get_indentation ( target ) ) : [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] error_code = result . get ( [string] , [number] ) [EOL] try : [EOL] ts = generate_tokens ( fixed ) [EOL] except tokenize . TokenError : [EOL] return [EOL] if not check_syntax ( fixed . lstrip ( ) ) : [EOL] return [EOL] errors = list ( pycodestyle . missing_whitespace_around_operator ( fixed , ts ) ) [EOL] for e in reversed ( errors ) : [EOL] if error_code != e [ [number] ] . split ( ) [ [number] ] : [EOL] continue [EOL] offset = e [ [number] ] [ [number] ] [EOL] fixed = fixed [ : offset ] + [string] + fixed [ offset : ] [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] else : [EOL] return [ ] [EOL] [EOL] def fix_e231 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] [EOL] fixed = target [ : offset ] . rstrip ( ) + [string] + target [ offset : ] . lstrip ( ) [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_e251 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] c = min ( result [ [string] ] - [number] , len ( target ) - [number] ) [EOL] [EOL] if target [ c ] . strip ( ) : [EOL] fixed = target [EOL] else : [EOL] fixed = target [ : c ] . rstrip ( ) + target [ c : ] . lstrip ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if fixed . endswith ( ( [string] , [string] , [string] ) ) : [EOL] self . source [ line_index ] = fixed . rstrip ( [string] ) [EOL] self . source [ line_index + [number] ] = self . source [ line_index + [number] ] . lstrip ( ) [EOL] return [ line_index + [number] , line_index + [number] ] [comment] [EOL] [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] [EOL] def fix_e262 ( self , result ) : [EOL] [docstring] [EOL] target = self . source [ result [ [string] ] - [number] ] [EOL] offset = result [ [string] ] [EOL] [EOL] code = target [ : offset ] . rstrip ( [string] ) [EOL] comment = target [ offset : ] . lstrip ( [string] ) [EOL] [EOL] fixed = code + ( [string] + comment if comment . strip ( ) else [string] ) [EOL] [EOL] self . source [ result [ [string] ] - [number] ] = fixed [EOL] [EOL] def fix_e271 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] - [number] [EOL] [EOL] fixed = fix_whitespace ( target , offset = offset , replacement = [string] ) [EOL] [EOL] if fixed == target : [EOL] return [ ] [EOL] else : [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_e301 ( self , result ) : [EOL] [docstring] [EOL] cr = [string] [EOL] self . source [ result [ [string] ] - [number] ] = cr + self . source [ result [ [string] ] - [number] ] [EOL] [EOL] def fix_e302 ( self , result ) : [EOL] [docstring] [EOL] add_linenum = [number] - int ( result [ [string] ] . split ( ) [ - [number] ] ) [EOL] cr = [string] * add_linenum [EOL] self . source [ result [ [string] ] - [number] ] = cr + self . source [ result [ [string] ] - [number] ] [EOL] [EOL] def fix_e303 ( self , result ) : [EOL] [docstring] [EOL] delete_linenum = int ( result [ [string] ] . split ( [string] ) [ [number] ] . split ( [string] ) [ [number] ] ) - [number] [EOL] delete_linenum = max ( [number] , delete_linenum ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] cnt = [number] [EOL] line = result [ [string] ] - [number] [EOL] modified_lines = [ ] [EOL] while cnt < delete_linenum and line >= [number] : [EOL] if not self . source [ line ] . strip ( ) : [EOL] self . source [ line ] = [string] [EOL] modified_lines . append ( [number] + line ) [comment] [EOL] cnt += [number] [EOL] line -= [number] [EOL] [EOL] return modified_lines [EOL] [EOL] def fix_e304 ( self , result ) : [EOL] [docstring] [EOL] line = result [ [string] ] - [number] [EOL] if not self . source [ line ] . strip ( ) : [EOL] self . source [ line ] = [string] [EOL] [EOL] def fix_e305 ( self , result ) : [EOL] [docstring] [EOL] cr = [string] [EOL] [comment] [EOL] offset = result [ [string] ] - [number] [EOL] while True : [EOL] if offset < [number] : [EOL] break [EOL] line = self . source [ offset ] . lstrip ( ) [EOL] if not line : [EOL] break [EOL] if line [ [number] ] != [string] : [EOL] break [EOL] offset -= [number] [EOL] offset += [number] [EOL] self . source [ offset ] = cr + self . source [ offset ] [EOL] [EOL] def fix_e401 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] offset = result [ [string] ] - [number] [EOL] [EOL] if not target . lstrip ( ) . startswith ( [string] ) : [EOL] return [ ] [EOL] [EOL] indentation = re . split ( pattern = [string] , string = target , maxsplit = [number] ) [ [number] ] [EOL] fixed = ( target [ : offset ] . rstrip ( [string] ) + [string] + indentation + [string] + target [ offset : ] . lstrip ( [string] ) ) [EOL] self . source [ line_index ] = fixed [EOL] [EOL] def fix_long_line_logically ( self , result , logical ) : [EOL] [docstring] [EOL] if ( not logical or len ( logical [ [number] ] ) == [number] or self . source [ result [ [string] ] - [number] ] . lstrip ( ) . startswith ( [string] ) ) : [EOL] return self . fix_long_line_physically ( result ) [EOL] [EOL] start_line_index = logical [ [number] ] [ [number] ] [EOL] end_line_index = logical [ [number] ] [ [number] ] [EOL] logical_lines = logical [ [number] ] [EOL] [EOL] previous_line = get_item ( self . source , start_line_index - [number] , default = [string] ) [EOL] next_line = get_item ( self . source , end_line_index + [number] , default = [string] ) [EOL] [EOL] single_line = join_logical_line ( [string] . join ( logical_lines ) ) [EOL] [EOL] try : [EOL] fixed = self . fix_long_line ( target = single_line , previous_line = previous_line , next_line = next_line , original = [string] . join ( logical_lines ) ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] return self . fix_long_line_physically ( result ) [EOL] [EOL] if fixed : [EOL] for line_index in range ( start_line_index , end_line_index + [number] ) : [EOL] self . source [ line_index ] = [string] [EOL] self . source [ start_line_index ] = fixed [EOL] return range ( start_line_index + [number] , end_line_index + [number] ) [EOL] [EOL] return [ ] [EOL] [EOL] def fix_long_line_physically ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] previous_line = get_item ( self . source , line_index - [number] , default = [string] ) [EOL] next_line = get_item ( self . source , line_index + [number] , default = [string] ) [EOL] [EOL] try : [EOL] fixed = self . fix_long_line ( target = target , previous_line = previous_line , next_line = next_line , original = target ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] return [ ] [EOL] [EOL] if fixed : [EOL] self . source [ line_index ] = fixed [EOL] return [ line_index + [number] ] [EOL] [EOL] return [ ] [EOL] [EOL] def fix_long_line ( self , target , previous_line , next_line , original ) : [EOL] cache_entry = ( target , previous_line , next_line ) [EOL] if cache_entry in self . long_line_ignore_cache : [EOL] return [ ] [EOL] [EOL] if target . lstrip ( ) . startswith ( [string] ) : [EOL] if self . options . aggressive : [EOL] [comment] [EOL] return shorten_comment ( line = target , max_line_length = self . options . max_line_length , last_comment = not next_line . lstrip ( ) . startswith ( [string] ) ) [EOL] else : [EOL] return [ ] [EOL] [EOL] fixed = get_fixed_long_line ( target = target , previous_line = previous_line , original = original , indent_word = self . indent_word , max_line_length = self . options . max_line_length , aggressive = self . options . aggressive , experimental = self . options . experimental , verbose = self . options . verbose ) [EOL] [EOL] if fixed and not code_almost_equal ( original , fixed ) : [EOL] return fixed [EOL] [EOL] self . long_line_ignore_cache . add ( cache_entry ) [EOL] return None [EOL] [EOL] def fix_e502 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] self . source [ line_index ] = target . rstrip ( [string] ) + [string] [EOL] [EOL] def fix_e701 ( self , result ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] c = result [ [string] ] [EOL] [EOL] fixed_source = ( target [ : c ] + [string] + _get_indentation ( target ) + self . indent_word + target [ c : ] . lstrip ( [string] ) ) [EOL] self . source [ result [ [string] ] - [number] ] = fixed_source [EOL] return [ result [ [string] ] , result [ [string] ] + [number] ] [EOL] [EOL] def fix_e702 ( self , result , logical ) : [EOL] [docstring] [EOL] if not logical : [EOL] return [ ] [comment] [EOL] logical_lines = logical [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for line in logical_lines : [EOL] if [string] in line : [EOL] return [ ] [EOL] [EOL] line_index = result [ [string] ] - [number] [EOL] target = self . source [ line_index ] [EOL] [EOL] if target . rstrip ( ) . endswith ( [string] ) : [EOL] [comment] [EOL] self . source [ line_index ] = target . rstrip ( [string] ) [EOL] self . source [ line_index + [number] ] = self . source [ line_index + [number] ] . lstrip ( ) [EOL] return [ line_index + [number] , line_index + [number] ] [EOL] [EOL] if target . rstrip ( ) . endswith ( [string] ) : [EOL] self . source [ line_index ] = target . rstrip ( [string] ) + [string] [EOL] return [ line_index + [number] ] [EOL] [EOL] offset = result [ [string] ] - [number] [EOL] first = target [ : offset ] . rstrip ( [string] ) . rstrip ( ) [EOL] second = ( _get_indentation ( logical_lines [ [number] ] ) + target [ offset : ] . lstrip ( [string] ) . lstrip ( ) ) [EOL] [EOL] [comment] [EOL] inline_comment = None [EOL] if target [ offset : ] . lstrip ( [string] ) . lstrip ( ) [ : [number] ] == [string] : [EOL] inline_comment = target [ offset : ] . lstrip ( [string] ) [EOL] [EOL] if inline_comment : [EOL] self . source [ line_index ] = first + inline_comment [EOL] else : [EOL] self . source [ line_index ] = first + [string] + second [EOL] return [ line_index + [number] ] [EOL] [EOL] def fix_e704 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] match = STARTSWITH_DEF_REGEX . match ( target ) [EOL] if match : [EOL] self . source [ line_index ] = [string] . format ( match . group ( [number] ) , _get_indentation ( target ) + self . indent_word , target [ match . end ( [number] ) : ] . lstrip ( ) ) [EOL] [EOL] def fix_e711 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , offset , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] right_offset = offset + [number] [EOL] if right_offset >= len ( target ) : [EOL] return [ ] [EOL] [EOL] left = target [ : offset ] . rstrip ( ) [EOL] center = target [ offset : right_offset ] [EOL] right = target [ right_offset : ] . lstrip ( ) [EOL] [EOL] if not right . startswith ( [string] ) : [EOL] return [ ] [EOL] [EOL] if center . strip ( ) == [string] : [EOL] new_center = [string] [EOL] elif center . strip ( ) == [string] : [EOL] new_center = [string] [EOL] else : [EOL] return [ ] [EOL] [EOL] self . source [ line_index ] = [string] . join ( [ left , new_center , right ] ) [EOL] [EOL] def fix_e712 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , offset , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] [comment] [EOL] if re . match ( [string] , target ) : [EOL] self . source [ line_index ] = re . sub ( [string] , [string] , target , count = [number] ) [EOL] elif re . match ( [string] , target ) : [EOL] self . source [ line_index ] = re . sub ( [string] , [string] , target , count = [number] ) [EOL] else : [EOL] right_offset = offset + [number] [EOL] if right_offset >= len ( target ) : [EOL] return [ ] [EOL] [EOL] left = target [ : offset ] . rstrip ( ) [EOL] center = target [ offset : right_offset ] [EOL] right = target [ right_offset : ] . lstrip ( ) [EOL] [EOL] [comment] [EOL] new_right = None [EOL] if center . strip ( ) == [string] : [EOL] if re . match ( [string] , right ) : [EOL] new_right = re . sub ( [string] , [string] , right , count = [number] ) [EOL] elif center . strip ( ) == [string] : [EOL] if re . match ( [string] , right ) : [EOL] new_right = re . sub ( [string] , [string] , right , count = [number] ) [EOL] [EOL] if new_right is None : [EOL] return [ ] [EOL] [EOL] if new_right [ [number] ] . isalnum ( ) : [EOL] new_right = [string] + new_right [EOL] [EOL] self . source [ line_index ] = left + new_right [EOL] [EOL] def fix_e713 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , offset , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] [comment] [EOL] before_target = target [ : offset ] [EOL] target = target [ offset : ] [EOL] match_notin = COMPARE_NEGATIVE_REGEX_THROUGH . search ( target ) [EOL] notin_pos_start , notin_pos_end = [number] , [number] [EOL] if match_notin : [EOL] notin_pos_start = match_notin . start ( [number] ) [EOL] notin_pos_end = match_notin . end ( ) [EOL] target = [string] . format ( target [ : notin_pos_start ] , [string] , target [ notin_pos_end : ] ) [EOL] [EOL] [comment] [EOL] match = COMPARE_NEGATIVE_REGEX . search ( target ) [EOL] if match : [EOL] if match . group ( [number] ) == [string] : [EOL] pos_start = match . start ( [number] ) [EOL] new_target = [string] . format ( target [ : pos_start ] , match . group ( [number] ) , match . group ( [number] ) , match . group ( [number] ) , target [ match . end ( ) : ] , before_target ) [EOL] if match_notin : [EOL] [comment] [EOL] pos_start = notin_pos_start + offset [EOL] pos_end = notin_pos_end + offset - [number] [comment] [EOL] new_target = [string] . format ( new_target [ : pos_start ] , [string] , new_target [ pos_end : ] ) [EOL] self . source [ line_index ] = new_target [EOL] [EOL] def fix_e714 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] [EOL] match = COMPARE_NEGATIVE_REGEX . search ( target ) [EOL] if match : [EOL] if match . group ( [number] ) == [string] : [EOL] pos_start = match . start ( [number] ) [EOL] self . source [ line_index ] = [string] . format ( target [ : pos_start ] , match . group ( [number] ) , match . group ( [number] ) , match . group ( [number] ) , target [ match . end ( ) : ] ) [EOL] [EOL] def fix_e722 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] match = BARE_EXCEPT_REGEX . search ( target ) [EOL] if match : [EOL] self . source [ line_index ] = [string] . format ( target [ : result [ [string] ] - [number] ] , [string] , target [ match . end ( ) : ] ) [EOL] [EOL] def fix_e731 ( self , result ) : [EOL] [docstring] [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] match = LAMBDA_REGEX . search ( target ) [EOL] if match : [EOL] end = match . end ( ) [EOL] self . source [ line_index ] = [string] . format ( target [ : match . start ( [number] ) ] , match . group ( [number] ) , match . group ( [number] ) , target [ end : ] . lstrip ( ) ) [EOL] [EOL] def fix_w291 ( self , result ) : [EOL] [docstring] [EOL] fixed_line = self . source [ result [ [string] ] - [number] ] . rstrip ( ) [EOL] self . source [ result [ [string] ] - [number] ] = fixed_line + [string] [EOL] [EOL] def fix_w391 ( self , _ ) : [EOL] [docstring] [EOL] blank_count = [number] [EOL] for line in reversed ( self . source ) : [EOL] line = line . rstrip ( ) [EOL] if line : [EOL] break [EOL] else : [EOL] blank_count += [number] [EOL] [EOL] original_length = len ( self . source ) [EOL] self . source = self . source [ : original_length - blank_count ] [EOL] return range ( [number] , [number] + original_length ) [EOL] [EOL] def fix_w503 ( self , result ) : [EOL] ( line_index , _ , target ) = get_index_offset_contents ( result , self . source ) [EOL] one_string_token = target . split ( ) [ [number] ] [EOL] try : [EOL] ts = generate_tokens ( one_string_token ) [EOL] except tokenize . TokenError : [EOL] return [EOL] if not _is_binary_operator ( ts [ [number] ] [ [number] ] , one_string_token ) : [EOL] return [EOL] [comment] [EOL] comment_index = None [EOL] for i in range ( [number] ) : [EOL] [comment] [EOL] if ( line_index - i ) < [number] : [EOL] break [EOL] from_index = line_index - i - [number] [EOL] to_index = line_index + [number] [EOL] try : [EOL] ts = generate_tokens ( [string] . join ( self . source [ from_index : to_index ] ) ) [EOL] except Exception : [EOL] continue [EOL] newline_count = [number] [EOL] newline_index = [ ] [EOL] for i , t in enumerate ( ts ) : [EOL] if t [ [number] ] in ( tokenize . NEWLINE , tokenize . NL ) : [EOL] newline_index . append ( i ) [EOL] newline_count += [number] [EOL] if newline_count > [number] : [EOL] tts = ts [ newline_index [ - [number] ] : ] [EOL] else : [EOL] tts = ts [EOL] old = None [EOL] for t in tts : [EOL] if tokenize . COMMENT == t [ [number] ] : [EOL] if old is None : [EOL] comment_index = [number] [EOL] else : [EOL] comment_index = old [ [number] ] [ [number] ] [EOL] break [EOL] old = t [EOL] break [EOL] i = target . index ( one_string_token ) [EOL] self . source [ line_index ] = [string] . format ( target [ : i ] , target [ i + len ( one_string_token ) : ] ) [EOL] nl = find_newline ( self . source [ line_index - [number] : line_index ] ) [EOL] before_line = self . source [ line_index - [number] ] [EOL] bl = before_line . index ( nl ) [EOL] if comment_index : [EOL] self . source [ line_index - [number] ] = [string] . format ( before_line [ : comment_index ] , one_string_token , before_line [ comment_index + [number] : ] ) [EOL] else : [EOL] self . source [ line_index - [number] ] = [string] . format ( before_line [ : bl ] , one_string_token , before_line [ bl : ] ) [EOL] [EOL] [EOL] def get_index_offset_contents ( result , source ) : [EOL] [docstring] [EOL] line_index = result [ [string] ] - [number] [EOL] return ( line_index , result [ [string] ] - [number] , source [ line_index ] ) [EOL] [EOL] [EOL] def get_fixed_long_line ( target , previous_line , original , indent_word = [string] , max_line_length = [number] , aggressive = False , experimental = False , verbose = False ) : [EOL] [docstring] [EOL] indent = _get_indentation ( target ) [EOL] source = target [ len ( indent ) : ] [EOL] assert source . lstrip ( ) == source [EOL] assert not target . lstrip ( ) . startswith ( [string] ) [EOL] [EOL] [comment] [EOL] tokens = list ( generate_tokens ( source ) ) [EOL] [EOL] candidates = shorten_line ( tokens , source , indent , indent_word , max_line_length , aggressive = aggressive , experimental = experimental , previous_line = previous_line ) [EOL] [EOL] [comment] [EOL] candidates = sorted ( sorted ( set ( candidates ) . union ( [ target , original ] ) ) , key = lambda x : line_shortening_rank ( x , indent_word , max_line_length , experimental = experimental ) ) [EOL] [EOL] if verbose >= [number] : [EOL] print ( ( [string] * [number] + [string] ) . join ( [ [string] ] + candidates + [ [string] ] ) , file = wrap_output ( sys . stderr , [string] ) ) [EOL] [EOL] if candidates : [EOL] best_candidate = candidates [ [number] ] [EOL] [EOL] [comment] [EOL] if longest_line_length ( best_candidate ) > longest_line_length ( original ) : [EOL] return None [EOL] [EOL] return best_candidate [EOL] [EOL] [EOL] def longest_line_length ( code ) : [EOL] [docstring] [EOL] return max ( len ( line ) for line in code . splitlines ( ) ) [EOL] [EOL] [EOL] def join_logical_line ( logical_line ) : [EOL] [docstring] [EOL] indentation = _get_indentation ( logical_line ) [EOL] [EOL] return indentation + untokenize_without_newlines ( generate_tokens ( logical_line . lstrip ( ) ) ) + [string] [EOL] [EOL] [EOL] def untokenize_without_newlines ( tokens ) : [EOL] [docstring] [EOL] text = [string] [EOL] last_row = [number] [EOL] last_column = - [number] [EOL] [EOL] for t in tokens : [EOL] token_string = t [ [number] ] [EOL] ( start_row , start_column ) = t [ [number] ] [EOL] ( end_row , end_column ) = t [ [number] ] [EOL] [EOL] if start_row > last_row : [EOL] last_column = [number] [EOL] if ( ( start_column > last_column or token_string == [string] ) and not text . endswith ( [string] ) ) : [EOL] text += [string] [EOL] [EOL] if token_string != [string] : [EOL] text += token_string [EOL] [EOL] last_row = end_row [EOL] last_column = end_column [EOL] [EOL] return text . rstrip ( ) [EOL] [EOL] [EOL] def _find_logical ( source_lines ) : [EOL] [comment] [EOL] logical_start = [ ] [EOL] logical_end = [ ] [EOL] last_newline = True [EOL] parens = [number] [EOL] for t in generate_tokens ( [string] . join ( source_lines ) ) : [EOL] if t [ [number] ] in [ tokenize . COMMENT , tokenize . DEDENT , tokenize . INDENT , tokenize . NL , tokenize . ENDMARKER ] : [EOL] continue [EOL] if not parens and t [ [number] ] in [ tokenize . NEWLINE , tokenize . SEMI ] : [EOL] last_newline = True [EOL] logical_end . append ( ( t [ [number] ] [ [number] ] - [number] , t [ [number] ] [ [number] ] ) ) [EOL] continue [EOL] if last_newline and not parens : [EOL] logical_start . append ( ( t [ [number] ] [ [number] ] - [number] , t [ [number] ] [ [number] ] ) ) [EOL] last_newline = False [EOL] if t [ [number] ] == tokenize . OP : [EOL] if t [ [number] ] in [string] : [EOL] parens += [number] [EOL] elif t [ [number] ] in [string] : [EOL] parens -= [number] [EOL] return ( logical_start , logical_end ) [EOL] [EOL] [EOL] def _get_logical ( source_lines , result , logical_start , logical_end ) : [EOL] [docstring] [EOL] row = result [ [string] ] - [number] [EOL] col = result [ [string] ] - [number] [EOL] ls = None [EOL] le = None [EOL] for i in range ( [number] , len ( logical_start ) , [number] ) : [EOL] assert logical_end [EOL] x = logical_end [ i ] [EOL] if x [ [number] ] > row or ( x [ [number] ] == row and x [ [number] ] > col ) : [EOL] le = x [EOL] ls = logical_start [ i ] [EOL] break [EOL] if ls is None : [EOL] return None [EOL] original = source_lines [ ls [ [number] ] : le [ [number] ] + [number] ] [EOL] return ls , le , original [EOL] [EOL] [EOL] def get_item ( items , index , default = None ) : [EOL] if [number] <= index < len ( items ) : [EOL] return items [ index ] [EOL] [EOL] return default [EOL] [EOL] [EOL] def reindent ( source , indent_size ) : [EOL] [docstring] [EOL] reindenter = Reindenter ( source ) [EOL] return reindenter . run ( indent_size ) [EOL] [EOL] [EOL] def code_almost_equal ( a , b ) : [EOL] [docstring] [EOL] split_a = split_and_strip_non_empty_lines ( a ) [EOL] split_b = split_and_strip_non_empty_lines ( b ) [EOL] [EOL] if len ( split_a ) != len ( split_b ) : [EOL] return False [EOL] [EOL] for ( index , _ ) in enumerate ( split_a ) : [EOL] if [string] . join ( split_a [ index ] . split ( ) ) != [string] . join ( split_b [ index ] . split ( ) ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def split_and_strip_non_empty_lines ( text ) : [EOL] [docstring] [EOL] return [ line . strip ( ) for line in text . splitlines ( ) if line . strip ( ) ] [EOL] [EOL] [EOL] def fix_e265 ( source , aggressive = False ) : [comment] [EOL] [docstring] [EOL] if [string] not in source : [EOL] [comment] [EOL] return source [EOL] [EOL] ignored_line_numbers = multiline_string_lines ( source , include_docstrings = True ) | set ( commented_out_code_lines ( source ) ) [EOL] [EOL] fixed_lines = [ ] [EOL] sio = io . StringIO ( source ) [EOL] for ( line_number , line ) in enumerate ( sio . readlines ( ) , start = [number] ) : [EOL] if ( line . lstrip ( ) . startswith ( [string] ) and line_number not in ignored_line_numbers and not pycodestyle . noqa ( line ) ) : [EOL] indentation = _get_indentation ( line ) [EOL] line = line . lstrip ( ) [EOL] [EOL] [comment] [EOL] if len ( line ) > [number] : [EOL] pos = next ( ( index for index , c in enumerate ( line ) if c != [string] ) ) [EOL] if ( ( line [ : pos ] . count ( [string] ) > [number] or line [ [number] ] . isalnum ( ) ) and not line . rstrip ( ) . endswith ( [string] ) ) : [EOL] line = [string] + line . lstrip ( [string] ) [EOL] [EOL] fixed_lines . append ( indentation + line ) [EOL] else : [EOL] fixed_lines . append ( line ) [EOL] [EOL] return [string] . join ( fixed_lines ) [EOL] [EOL] [EOL] def refactor ( source , fixer_names , ignore = None , filename = [string] ) : [EOL] [docstring] [EOL] from lib2to3 import pgen2 [EOL] try : [EOL] new_text = refactor_with_2to3 ( source , fixer_names = fixer_names , filename = filename ) [EOL] except ( pgen2 . parse . ParseError , SyntaxError , UnicodeDecodeError , UnicodeEncodeError ) : [EOL] return source [EOL] [EOL] if ignore : [EOL] if ignore in new_text and ignore not in source : [EOL] return source [EOL] [EOL] return new_text [EOL] [EOL] [EOL] def code_to_2to3 ( select , ignore ) : [EOL] fixes = set ( ) [EOL] for code , fix in CODE_TO_2TO3 . items ( ) : [EOL] if code_match ( code , select = select , ignore = ignore ) : [EOL] fixes |= set ( fix ) [EOL] return fixes [EOL] [EOL] [EOL] def fix_2to3 ( source , aggressive = True , select = None , ignore = None , filename = [string] ) : [EOL] [docstring] [EOL] if not aggressive : [EOL] return source [EOL] [EOL] select = select or [ ] [EOL] ignore = ignore or [ ] [EOL] [EOL] return refactor ( source , code_to_2to3 ( select = select , ignore = ignore ) , filename = filename ) [EOL] [EOL] [EOL] def fix_w602 ( source , aggressive = True ) : [EOL] [docstring] [EOL] if not aggressive : [EOL] return source [EOL] [EOL] return refactor ( source , [ [string] ] , ignore = [string] ) [EOL] [EOL] [EOL] def find_newline ( source ) : [EOL] [docstring] [EOL] assert not isinstance ( source , unicode ) [EOL] [EOL] counter = collections . defaultdict ( int ) [EOL] for line in source : [EOL] if line . endswith ( CRLF ) : [EOL] counter [ CRLF ] += [number] [EOL] elif line . endswith ( CR ) : [EOL] counter [ CR ] += [number] [EOL] elif line . endswith ( LF ) : [EOL] counter [ LF ] += [number] [EOL] [EOL] return ( sorted ( counter , key = counter . get , reverse = True ) or [ LF ] ) [ [number] ] [EOL] [EOL] [EOL] def _get_indentword ( source ) : [EOL] [docstring] [EOL] indent_word = [string] [comment] [EOL] try : [EOL] for t in generate_tokens ( source ) : [EOL] if t [ [number] ] == token . INDENT : [EOL] indent_word = t [ [number] ] [EOL] break [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] pass [EOL] return indent_word [EOL] [EOL] [EOL] def _get_indentation ( line ) : [EOL] [docstring] [EOL] if line . strip ( ) : [EOL] non_whitespace_index = len ( line ) - len ( line . lstrip ( ) ) [EOL] return line [ : non_whitespace_index ] [EOL] [EOL] return [string] [EOL] [EOL] [EOL] def get_diff_text ( old , new , filename ) : [EOL] [docstring] [EOL] newline = [string] [EOL] diff = difflib . unified_diff ( old , new , [string] + filename , [string] + filename , lineterm = newline ) [EOL] [EOL] text = [string] [EOL] for line in diff : [EOL] text += line [EOL] [EOL] [comment] [EOL] if text and not line . endswith ( newline ) : [EOL] text += newline + [string] + newline [EOL] [EOL] return text [EOL] [EOL] [EOL] def _priority_key ( pep8_result ) : [EOL] [docstring] [EOL] priority = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] middle_index = [number] [EOL] lowest_priority = [ [string] , [string] ] [EOL] key = pep8_result [ [string] ] . lower ( ) [EOL] try : [EOL] return priority . index ( key ) [EOL] except ValueError : [EOL] try : [EOL] return middle_index + lowest_priority . index ( key ) + [number] [EOL] except ValueError : [EOL] return middle_index [EOL] [EOL] [EOL] def shorten_line ( tokens , source , indentation , indent_word , max_line_length , aggressive = False , experimental = False , previous_line = [string] ) : [EOL] [docstring] [EOL] for candidate in _shorten_line ( tokens = tokens , source = source , indentation = indentation , indent_word = indent_word , aggressive = aggressive , previous_line = previous_line ) : [EOL] yield candidate [EOL] [EOL] if aggressive : [EOL] for key_token_strings in SHORTEN_OPERATOR_GROUPS : [EOL] shortened = _shorten_line_at_tokens ( tokens = tokens , source = source , indentation = indentation , indent_word = indent_word , key_token_strings = key_token_strings , aggressive = aggressive ) [EOL] [EOL] if shortened is not None and shortened != source : [EOL] yield shortened [EOL] [EOL] if experimental : [EOL] for shortened in _shorten_line_at_tokens_new ( tokens = tokens , source = source , indentation = indentation , max_line_length = max_line_length ) : [EOL] [EOL] yield shortened [EOL] [EOL] [EOL] def _shorten_line ( tokens , source , indentation , indent_word , aggressive = False , previous_line = [string] ) : [EOL] [docstring] [EOL] for ( token_type , token_string , start_offset , end_offset ) in token_offsets ( tokens ) : [EOL] [EOL] if ( token_type == tokenize . COMMENT and not is_probably_part_of_multiline ( previous_line ) and not is_probably_part_of_multiline ( source ) and not source [ start_offset + [number] : ] . strip ( ) . lower ( ) . startswith ( ( [string] , [string] , [string] ) ) ) : [EOL] [comment] [EOL] first = source [ : start_offset ] [EOL] second = source [ start_offset : ] [EOL] yield ( indentation + second . strip ( ) + [string] + indentation + first . strip ( ) + [string] ) [EOL] elif token_type == token . OP and token_string != [string] : [EOL] [comment] [EOL] [EOL] assert token_type != token . INDENT [EOL] [EOL] first = source [ : end_offset ] [EOL] [EOL] second_indent = indentation [EOL] if first . rstrip ( ) . endswith ( [string] ) : [EOL] second_indent += indent_word [EOL] elif [string] in first : [EOL] second_indent += [string] * ( [number] + first . find ( [string] ) ) [EOL] else : [EOL] second_indent += indent_word [EOL] [EOL] second = ( second_indent + source [ end_offset : ] . lstrip ( ) ) [EOL] if ( not second . strip ( ) or second . lstrip ( ) . startswith ( [string] ) ) : [EOL] continue [EOL] [EOL] [comment] [EOL] if second . lstrip ( ) . startswith ( [string] ) : [EOL] continue [EOL] [comment] [EOL] if first . rstrip ( ) . endswith ( [string] ) : [EOL] continue [EOL] if token_string in [string] : [EOL] fixed = first + [string] + [string] + second [EOL] else : [EOL] fixed = first + [string] + second [EOL] [EOL] [comment] [EOL] if check_syntax ( normalize_multiline ( fixed ) [EOL] if aggressive else fixed ) : [EOL] yield indentation + fixed [EOL] [EOL] [EOL] def _is_binary_operator ( token_type , text ) : [EOL] return ( ( token_type == tokenize . OP or text in [ [string] , [string] ] ) and text not in [string] ) [EOL] [EOL] [EOL] [comment] [EOL] Token = collections . namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class ReformattedLines ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class _Indent ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , indent_amt ) : [EOL] self . _indent_amt = indent_amt [EOL] [EOL] def emit ( self ) : [EOL] return [string] * self . _indent_amt [EOL] [EOL] @ property def size ( self ) : [EOL] return self . _indent_amt [EOL] [EOL] class _Space ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def emit ( self ) : [EOL] return [string] [EOL] [EOL] @ property def size ( self ) : [EOL] return [number] [EOL] [EOL] class _LineBreak ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def emit ( self ) : [EOL] return [string] [EOL] [EOL] @ property def size ( self ) : [EOL] return [number] [EOL] [EOL] def __init__ ( self , max_line_length ) : [EOL] self . _max_line_length = max_line_length [EOL] self . _lines = [ ] [EOL] self . _bracket_depth = [number] [EOL] self . _prev_item = None [EOL] self . _prev_prev_item = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . emit ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def add ( self , obj , indent_amt , break_after_open_bracket ) : [EOL] if isinstance ( obj , Atom ) : [EOL] self . _add_item ( obj , indent_amt ) [EOL] return [EOL] [EOL] self . _add_container ( obj , indent_amt , break_after_open_bracket ) [EOL] [EOL] def add_comment ( self , item ) : [EOL] num_spaces = [number] [EOL] if len ( self . _lines ) > [number] : [EOL] if isinstance ( self . _lines [ - [number] ] , self . _Space ) : [EOL] num_spaces -= [number] [EOL] if len ( self . _lines ) > [number] : [EOL] if isinstance ( self . _lines [ - [number] ] , self . _Space ) : [EOL] num_spaces -= [number] [EOL] [EOL] while num_spaces > [number] : [EOL] self . _lines . append ( self . _Space ( ) ) [EOL] num_spaces -= [number] [EOL] self . _lines . append ( item ) [EOL] [EOL] def add_indent ( self , indent_amt ) : [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] [EOL] def add_line_break ( self , indent ) : [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . add_indent ( len ( indent ) ) [EOL] [EOL] def add_line_break_at ( self , index , indent_amt ) : [EOL] self . _lines . insert ( index , self . _LineBreak ( ) ) [EOL] self . _lines . insert ( index + [number] , self . _Indent ( indent_amt ) ) [EOL] [EOL] def add_space_if_needed ( self , curr_text , equal = False ) : [EOL] if ( not self . _lines or isinstance ( self . _lines [ - [number] ] , ( self . _LineBreak , self . _Indent , self . _Space ) ) ) : [EOL] return [EOL] [EOL] prev_text = unicode ( self . _prev_item ) [EOL] prev_prev_text = ( unicode ( self . _prev_prev_item ) if self . _prev_prev_item else [string] ) [EOL] [EOL] if ( ( ( self . _prev_item . is_keyword or self . _prev_item . is_string or self . _prev_item . is_name or self . _prev_item . is_number ) and ( curr_text [ [number] ] not in [string] or ( curr_text [ [number] ] == [string] and equal ) ) ) or ( ( prev_prev_text != [string] and prev_text [ - [number] ] != [string] and curr_text != [string] ) and curr_text [ [number] ] != [string] and ( ( prev_text [ - [number] ] in [string] and curr_text [ [number] ] not in [string] ) or prev_text [ - [number] ] in [string] or ( equal and prev_text == [string] ) or ( ( self . _prev_prev_item and ( prev_text not in [string] and ( self . _prev_prev_item . is_name or self . _prev_prev_item . is_number or self . _prev_prev_item . is_string ) ) and prev_text in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) ) ) ) ) : [EOL] self . _lines . append ( self . _Space ( ) ) [EOL] [EOL] def previous_item ( self ) : [EOL] [docstring] [EOL] return self . _prev_item [EOL] [EOL] def fits_on_current_line ( self , item_extent ) : [EOL] return self . current_size ( ) + item_extent <= self . _max_line_length [EOL] [EOL] def current_size ( self ) : [EOL] [docstring] [EOL] size = [number] [EOL] for item in reversed ( self . _lines ) : [EOL] size += item . size [EOL] if isinstance ( item , self . _LineBreak ) : [EOL] break [EOL] [EOL] return size [EOL] [EOL] def line_empty ( self ) : [EOL] return ( self . _lines and isinstance ( self . _lines [ - [number] ] , ( self . _LineBreak , self . _Indent ) ) ) [EOL] [EOL] def emit ( self ) : [EOL] string = [string] [EOL] for item in self . _lines : [EOL] if isinstance ( item , self . _LineBreak ) : [EOL] string = string . rstrip ( ) [EOL] string += item . emit ( ) [EOL] [EOL] return string . rstrip ( ) + [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _add_item ( self , item , indent_amt ) : [EOL] [docstring] [EOL] if self . _prev_item and self . _prev_item . is_string and item . is_string : [EOL] [comment] [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] [EOL] item_text = unicode ( item ) [EOL] if self . _lines and self . _bracket_depth : [EOL] [comment] [EOL] self . _prevent_default_initializer_splitting ( item , indent_amt ) [EOL] [EOL] if item_text in [string] : [EOL] self . _split_after_delimiter ( item , indent_amt ) [EOL] [EOL] elif self . _lines and not self . line_empty ( ) : [EOL] [comment] [EOL] if self . fits_on_current_line ( len ( item_text ) ) : [EOL] self . _enforce_space ( item ) [EOL] [EOL] else : [EOL] [comment] [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] [EOL] self . _lines . append ( item ) [EOL] self . _prev_item , self . _prev_prev_item = item , self . _prev_item [EOL] [EOL] if item_text in [string] : [EOL] self . _bracket_depth += [number] [EOL] [EOL] elif item_text in [string] : [EOL] self . _bracket_depth -= [number] [EOL] assert self . _bracket_depth >= [number] [EOL] [EOL] def _add_container ( self , container , indent_amt , break_after_open_bracket ) : [EOL] actual_indent = indent_amt + [number] [EOL] [EOL] if ( unicode ( self . _prev_item ) != [string] and not self . line_empty ( ) and not self . fits_on_current_line ( container . size + self . _bracket_depth + [number] ) ) : [EOL] [EOL] if unicode ( container ) [ [number] ] == [string] and self . _prev_item . is_name : [EOL] [comment] [EOL] break_after_open_bracket = True [EOL] actual_indent = indent_amt + [number] [EOL] elif ( break_after_open_bracket or unicode ( self . _prev_item ) not in [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _lines . append ( self . _LineBreak ( ) ) [EOL] self . _lines . append ( self . _Indent ( indent_amt ) ) [EOL] break_after_open_bracket = False [EOL] else : [EOL] actual_indent = self . current_size ( ) + [number] [EOL] break_after_open_bracket = False [EOL] [EOL] if isinstance ( container , ( ListComprehension , IfExpression ) ) : [EOL] actual_indent = indent_amt [EOL] [EOL] [comment] [EOL] [comment] [EOL] container . reflow ( self , [string] * actual_indent , break_after_open_bracket = break_after_open_bracket ) [EOL] [EOL] def _prevent_default_initializer_splitting ( self , item , indent_amt ) : [EOL] [docstring] [EOL] if unicode ( item ) == [string] : [EOL] [comment] [EOL] [comment] [EOL] self . _delete_whitespace ( ) [EOL] return [EOL] [EOL] if ( not self . _prev_item or not self . _prev_prev_item or unicode ( self . _prev_item ) != [string] ) : [EOL] return [EOL] [EOL] self . _delete_whitespace ( ) [EOL] prev_prev_index = self . _lines . index ( self . _prev_prev_item ) [EOL] [EOL] if ( isinstance ( self . _lines [ prev_prev_index - [number] ] , self . _Indent ) or self . fits_on_current_line ( item . size + [number] ) ) : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] if isinstance ( self . _lines [ prev_prev_index - [number] ] , self . _Space ) : [EOL] del self . _lines [ prev_prev_index - [number] ] [EOL] [EOL] self . add_line_break_at ( self . _lines . index ( self . _prev_prev_item ) , indent_amt ) [EOL] [EOL] def _split_after_delimiter ( self , item , indent_amt ) : [EOL] [docstring] [EOL] self . _delete_whitespace ( ) [EOL] [EOL] if self . fits_on_current_line ( item . size ) : [EOL] return [EOL] [EOL] last_space = None [EOL] for current_item in reversed ( self . _lines ) : [EOL] if ( last_space and ( not isinstance ( current_item , Atom ) or not current_item . is_colon ) ) : [EOL] break [EOL] else : [EOL] last_space = None [EOL] if isinstance ( current_item , self . _Space ) : [EOL] last_space = current_item [EOL] if isinstance ( current_item , ( self . _LineBreak , self . _Indent ) ) : [EOL] return [EOL] [EOL] if not last_space : [EOL] return [EOL] [EOL] self . add_line_break_at ( self . _lines . index ( last_space ) , indent_amt ) [EOL] [EOL] def _enforce_space ( self , item ) : [EOL] [docstring] [EOL] if isinstance ( self . _lines [ - [number] ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : [EOL] return [EOL] [EOL] if not self . _prev_item : [EOL] return [EOL] [EOL] item_text = unicode ( item ) [EOL] prev_text = unicode ( self . _prev_item ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( ( item_text == [string] and prev_text == [string] ) or ( item_text == [string] and prev_text == [string] ) or ( item_text == [string] and prev_text == [string] ) ) : [EOL] self . _lines . append ( self . _Space ( ) ) [EOL] [EOL] def _delete_whitespace ( self ) : [EOL] [docstring] [EOL] while isinstance ( self . _lines [ - [number] ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : [EOL] del self . _lines [ - [number] ] [EOL] [EOL] [EOL] class Atom ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , atom ) : [EOL] self . _atom = atom [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . _atom . token_string [EOL] [EOL] def __len__ ( self ) : [EOL] return self . size [EOL] [EOL] def reflow ( self , reflowed_lines , continued_indent , extent , break_after_open_bracket = False , is_list_comp_or_if_expr = False , next_is_dot = False ) : [EOL] if self . _atom . token_type == tokenize . COMMENT : [EOL] reflowed_lines . add_comment ( self ) [EOL] return [EOL] [EOL] total_size = extent if extent else self . size [EOL] [EOL] if self . _atom . token_string not in [string] : [EOL] [comment] [EOL] total_size += [number] [EOL] [EOL] prev_item = reflowed_lines . previous_item ( ) [EOL] if ( not is_list_comp_or_if_expr and not reflowed_lines . fits_on_current_line ( total_size ) and not ( next_is_dot and reflowed_lines . fits_on_current_line ( self . size + [number] ) ) and not reflowed_lines . line_empty ( ) and not self . is_colon and not ( prev_item and prev_item . is_name and unicode ( self ) == [string] ) ) : [EOL] [comment] [EOL] [comment] [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] else : [EOL] reflowed_lines . add_space_if_needed ( unicode ( self ) ) [EOL] [EOL] reflowed_lines . add ( self , len ( continued_indent ) , break_after_open_bracket ) [EOL] [EOL] def emit ( self ) : [EOL] return self . __repr__ ( ) [EOL] [EOL] @ property def is_keyword ( self ) : [EOL] return keyword . iskeyword ( self . _atom . token_string ) [EOL] [EOL] @ property def is_string ( self ) : [EOL] return self . _atom . token_type == tokenize . STRING [EOL] [EOL] @ property def is_name ( self ) : [EOL] return self . _atom . token_type == tokenize . NAME [EOL] [EOL] @ property def is_number ( self ) : [EOL] return self . _atom . token_type == tokenize . NUMBER [EOL] [EOL] @ property def is_comma ( self ) : [EOL] return self . _atom . token_string == [string] [EOL] [EOL] @ property def is_colon ( self ) : [EOL] return self . _atom . token_string == [string] [EOL] [EOL] @ property def size ( self ) : [EOL] return len ( self . _atom . token_string ) [EOL] [EOL] [EOL] class Container ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , items ) : [EOL] self . _items = items [EOL] [EOL] def __repr__ ( self ) : [EOL] string = [string] [EOL] last_was_keyword = False [EOL] [EOL] for item in self . _items : [EOL] if item . is_comma : [EOL] string += [string] [EOL] elif item . is_colon : [EOL] string += [string] [EOL] else : [EOL] item_string = unicode ( item ) [EOL] if ( string and ( last_was_keyword or ( not string . endswith ( tuple ( [string] ) ) and not item_string . startswith ( tuple ( [string] ) ) ) ) ) : [EOL] string += [string] [EOL] string += item_string [EOL] [EOL] last_was_keyword = item . is_keyword [EOL] return string [EOL] [EOL] def __iter__ ( self ) : [EOL] for element in self . _items : [EOL] yield element [EOL] [EOL] def __getitem__ ( self , idx ) : [EOL] return self . _items [ idx ] [EOL] [EOL] def reflow ( self , reflowed_lines , continued_indent , break_after_open_bracket = False ) : [EOL] last_was_container = False [EOL] for ( index , item ) in enumerate ( self . _items ) : [EOL] next_item = get_item ( self . _items , index + [number] ) [EOL] [EOL] if isinstance ( item , Atom ) : [EOL] is_list_comp_or_if_expr = ( isinstance ( self , ( ListComprehension , IfExpression ) ) ) [EOL] item . reflow ( reflowed_lines , continued_indent , self . _get_extent ( index ) , is_list_comp_or_if_expr = is_list_comp_or_if_expr , next_is_dot = ( next_item and unicode ( next_item ) == [string] ) ) [EOL] if last_was_container and item . is_comma : [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] last_was_container = False [EOL] else : [comment] [EOL] reflowed_lines . add ( item , len ( continued_indent ) , break_after_open_bracket ) [EOL] last_was_container = not isinstance ( item , ( ListComprehension , IfExpression ) ) [EOL] [EOL] if ( break_after_open_bracket and index == [number] and unicode ( item ) == self . open_bracket and ( not next_item or unicode ( next_item ) != self . close_bracket ) and ( len ( self . _items ) != [number] or not isinstance ( next_item , Atom ) ) ) : [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] break_after_open_bracket = False [EOL] else : [EOL] next_next_item = get_item ( self . _items , index + [number] ) [EOL] if ( unicode ( item ) not in [ [string] , [string] , [string] ] and next_item and not isinstance ( next_item , Container ) and unicode ( next_item ) != [string] and next_next_item and ( not isinstance ( next_next_item , Atom ) or unicode ( next_item ) == [string] ) and not reflowed_lines . line_empty ( ) and not reflowed_lines . fits_on_current_line ( self . _get_extent ( index + [number] ) + [number] ) ) : [EOL] reflowed_lines . add_line_break ( continued_indent ) [EOL] [EOL] def _get_extent ( self , index ) : [EOL] [docstring] [EOL] extent = [number] [EOL] prev_item = get_item ( self . _items , index - [number] ) [EOL] seen_dot = prev_item and unicode ( prev_item ) == [string] [EOL] while index < len ( self . _items ) : [EOL] item = get_item ( self . _items , index ) [EOL] index += [number] [EOL] [EOL] if isinstance ( item , ( ListComprehension , IfExpression ) ) : [EOL] break [EOL] [EOL] if isinstance ( item , Container ) : [EOL] if prev_item and prev_item . is_name : [EOL] if seen_dot : [EOL] extent += [number] [EOL] else : [EOL] extent += item . size [EOL] [EOL] prev_item = item [EOL] continue [EOL] elif ( unicode ( item ) not in [ [string] , [string] , [string] , [string] ] and not item . is_name and not item . is_string ) : [EOL] break [EOL] [EOL] if unicode ( item ) == [string] : [EOL] seen_dot = True [EOL] [EOL] extent += item . size [EOL] prev_item = item [EOL] [EOL] return extent [EOL] [EOL] @ property def is_string ( self ) : [EOL] return False [EOL] [EOL] @ property def size ( self ) : [EOL] return len ( self . __repr__ ( ) ) [EOL] [EOL] @ property def is_keyword ( self ) : [EOL] return False [EOL] [EOL] @ property def is_name ( self ) : [EOL] return False [EOL] [EOL] @ property def is_comma ( self ) : [EOL] return False [EOL] [EOL] @ property def is_colon ( self ) : [EOL] return False [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return None [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return None [EOL] [EOL] [EOL] class Tuple ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return [string] [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class List ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return [string] [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class DictOrSet ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def open_bracket ( self ) : [EOL] return [string] [EOL] [EOL] @ property def close_bracket ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ListComprehension ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ property def size ( self ) : [EOL] length = [number] [EOL] for item in self . _items : [EOL] if isinstance ( item , IfExpression ) : [EOL] break [EOL] length += item . size [EOL] return length [EOL] [EOL] [EOL] class IfExpression ( Container ) : [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def _parse_container ( tokens , index , for_or_if = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] items = [ Atom ( Token ( * tokens [ index ] ) ) ] [EOL] index += [number] [EOL] [EOL] num_tokens = len ( tokens ) [EOL] while index < num_tokens : [EOL] tok = Token ( * tokens [ index ] ) [EOL] [EOL] if tok . token_string in [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if for_or_if == [string] : [EOL] return ( ListComprehension ( items ) , index - [number] ) [EOL] [EOL] elif for_or_if == [string] : [EOL] return ( IfExpression ( items ) , index - [number] ) [EOL] [EOL] [comment] [EOL] items . append ( Atom ( tok ) ) [EOL] [EOL] [comment] [EOL] if tok . token_string == [string] : [EOL] [comment] [EOL] return ( Tuple ( items ) , index ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] [comment] [EOL] return ( List ( items ) , index ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] [comment] [EOL] return ( DictOrSet ( items ) , index ) [EOL] [EOL] elif tok . token_string in [string] : [EOL] [comment] [EOL] ( container , index ) = _parse_container ( tokens , index ) [EOL] items . append ( container ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] ( container , index ) = _parse_container ( tokens , index , [string] ) [EOL] items . append ( container ) [EOL] [EOL] elif tok . token_string == [string] : [EOL] ( container , index ) = _parse_container ( tokens , index , [string] ) [EOL] items . append ( container ) [EOL] [EOL] else : [EOL] items . append ( Atom ( tok ) ) [EOL] [EOL] index += [number] [EOL] [EOL] return ( None , None ) [EOL] [EOL] [EOL] def _parse_tokens ( tokens ) : [EOL] [docstring] [EOL] [EOL] index = [number] [EOL] parsed_tokens = [ ] [EOL] [EOL] num_tokens = len ( tokens ) [EOL] while index < num_tokens : [EOL] tok = Token ( * tokens [ index ] ) [EOL] [EOL] assert tok . token_type != token . INDENT [EOL] if tok . token_type == tokenize . NEWLINE : [EOL] [comment] [EOL] break [EOL] [EOL] if tok . token_string in [string] : [EOL] ( container , index ) = _parse_container ( tokens , index ) [EOL] if not container : [EOL] return None [EOL] parsed_tokens . append ( container ) [EOL] else : [EOL] parsed_tokens . append ( Atom ( tok ) ) [EOL] [EOL] index += [number] [EOL] [EOL] return parsed_tokens [EOL] [EOL] [EOL] def _reflow_lines ( parsed_tokens , indentation , max_line_length , start_on_prefix_line ) : [EOL] [docstring] [EOL] [EOL] if unicode ( parsed_tokens [ [number] ] ) == [string] : [EOL] [comment] [EOL] continued_indent = indentation + [string] * [number] * DEFAULT_INDENT_SIZE [EOL] else : [EOL] continued_indent = indentation + [string] * DEFAULT_INDENT_SIZE [EOL] [EOL] break_after_open_bracket = not start_on_prefix_line [EOL] [EOL] lines = ReformattedLines ( max_line_length ) [EOL] lines . add_indent ( len ( indentation . lstrip ( [string] ) ) ) [EOL] [EOL] if not start_on_prefix_line : [EOL] [comment] [EOL] [comment] [EOL] first_token = get_item ( parsed_tokens , [number] ) [EOL] second_token = get_item ( parsed_tokens , [number] ) [EOL] [EOL] if ( first_token and second_token and unicode ( second_token ) [ [number] ] == [string] and len ( indentation ) + len ( first_token ) + [number] == len ( continued_indent ) ) : [EOL] return None [EOL] [EOL] for item in parsed_tokens : [EOL] lines . add_space_if_needed ( unicode ( item ) , equal = True ) [EOL] [EOL] save_continued_indent = continued_indent [EOL] if start_on_prefix_line and isinstance ( item , Container ) : [EOL] start_on_prefix_line = False [EOL] continued_indent = [string] * ( lines . current_size ( ) + [number] ) [EOL] [EOL] item . reflow ( lines , continued_indent , break_after_open_bracket ) [EOL] continued_indent = save_continued_indent [EOL] [EOL] return lines . emit ( ) [EOL] [EOL] [EOL] def _shorten_line_at_tokens_new ( tokens , source , indentation , max_line_length ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] yield indentation + source [EOL] [EOL] parsed_tokens = _parse_tokens ( tokens ) [EOL] [EOL] if parsed_tokens : [EOL] [comment] [EOL] [comment] [EOL] fixed = _reflow_lines ( parsed_tokens , indentation , max_line_length , start_on_prefix_line = True ) [EOL] if fixed and check_syntax ( normalize_multiline ( fixed . lstrip ( ) ) ) : [EOL] yield fixed [EOL] [EOL] fixed = _reflow_lines ( parsed_tokens , indentation , max_line_length , start_on_prefix_line = False ) [EOL] if fixed and check_syntax ( normalize_multiline ( fixed . lstrip ( ) ) ) : [EOL] yield fixed [EOL] [EOL] [EOL] def _shorten_line_at_tokens ( tokens , source , indentation , indent_word , key_token_strings , aggressive ) : [EOL] [docstring] [EOL] offsets = [ ] [EOL] for ( index , _t ) in enumerate ( token_offsets ( tokens ) ) : [EOL] ( token_type , token_string , start_offset , end_offset ) = _t [EOL] [EOL] assert token_type != token . INDENT [EOL] [EOL] if token_string in key_token_strings : [EOL] [comment] [EOL] unwanted_next_token = { [string] : [string] , [string] : [string] , [string] : [string] } . get ( token_string ) [EOL] if unwanted_next_token : [EOL] if ( get_item ( tokens , index + [number] , default = [ None , None ] ) [ [number] ] == unwanted_next_token or get_item ( tokens , index + [number] , default = [ None , None ] ) [ [number] ] == unwanted_next_token ) : [EOL] continue [EOL] [EOL] if ( index > [number] and token_string == [string] and tokens [ index - [number] ] [ [number] ] in [string] ) : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] [EOL] if end_offset < len ( source ) - [number] : [EOL] [comment] [EOL] offsets . append ( end_offset ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] previous_token = get_item ( tokens , index - [number] ) [EOL] if ( token_type == tokenize . STRING and previous_token and previous_token [ [number] ] == tokenize . STRING ) : [EOL] offsets . append ( start_offset ) [EOL] [EOL] current_indent = None [EOL] fixed = None [EOL] for line in split_at_offsets ( source , offsets ) : [EOL] if fixed : [EOL] fixed += [string] + current_indent + line [EOL] [EOL] for symbol in [string] : [EOL] if line . endswith ( symbol ) : [EOL] current_indent += indent_word [EOL] else : [EOL] [comment] [EOL] fixed = line [EOL] assert not current_indent [EOL] current_indent = indent_word [EOL] [EOL] assert fixed is not None [EOL] [EOL] if check_syntax ( normalize_multiline ( fixed ) [EOL] if aggressive > [number] else fixed ) : [EOL] return indentation + fixed [EOL] [EOL] return None [EOL] [EOL] [EOL] def token_offsets ( tokens ) : [EOL] [docstring] [EOL] end_offset = [number] [EOL] previous_end_row = [number] [EOL] previous_end_column = [number] [EOL] for t in tokens : [EOL] token_type = t [ [number] ] [EOL] token_string = t [ [number] ] [EOL] ( start_row , start_column ) = t [ [number] ] [EOL] ( end_row , end_column ) = t [ [number] ] [EOL] [EOL] [comment] [EOL] end_offset += start_column [EOL] if previous_end_row == start_row : [EOL] end_offset -= previous_end_column [EOL] [EOL] [comment] [EOL] start_offset = end_offset [EOL] [EOL] [comment] [EOL] end_offset += len ( token_string ) [EOL] [EOL] yield ( token_type , token_string , start_offset , end_offset ) [EOL] [EOL] previous_end_row = end_row [EOL] previous_end_column = end_column [EOL] [EOL] [EOL] def normalize_multiline ( line ) : [EOL] [docstring] [EOL] if line . startswith ( [string] ) and line . rstrip ( ) . endswith ( [string] ) : [EOL] return line + [string] [EOL] elif line . startswith ( [string] ) : [EOL] return [string] + line [EOL] elif line . startswith ( [string] ) : [EOL] return line + [string] [EOL] elif line . startswith ( [string] ) : [EOL] return line + [string] [EOL] elif line . startswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] return line + [string] [EOL] [EOL] return line [EOL] [EOL] [EOL] def fix_whitespace ( line , offset , replacement ) : [EOL] [docstring] [EOL] [comment] [EOL] left = line [ : offset ] . rstrip ( [string] ) [EOL] right = line [ offset : ] . lstrip ( [string] ) [EOL] if right . startswith ( [string] ) : [EOL] return line [EOL] [EOL] return left + replacement + right [EOL] [EOL] [EOL] def _execute_pep8 ( pep8_options , source ) : [EOL] [docstring] [EOL] class QuietReport ( pycodestyle . BaseReport ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , options ) : [EOL] super ( QuietReport , self ) . __init__ ( options ) [EOL] self . __full_error_results = [ ] [EOL] [EOL] def error ( self , line_number , offset , text , check ) : [EOL] [docstring] [EOL] code = super ( QuietReport , self ) . error ( line_number , offset , text , check ) [EOL] if code : [EOL] self . __full_error_results . append ( { [string] : code , [string] : line_number , [string] : offset + [number] , [string] : text } ) [EOL] [EOL] def full_error_results ( self ) : [EOL] [docstring] [EOL] return self . __full_error_results [EOL] [EOL] checker = pycodestyle . Checker ( [string] , lines = source , reporter = QuietReport , ** pep8_options ) [EOL] checker . check_all ( ) [EOL] return checker . report . full_error_results ( ) [EOL] [EOL] [EOL] def _remove_leading_and_normalize ( line ) : [EOL] return line . lstrip ( ) . rstrip ( CR + LF ) + [string] [EOL] [EOL] [EOL] class Reindenter ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , input_text ) : [EOL] sio = io . StringIO ( input_text ) [EOL] source_lines = sio . readlines ( ) [EOL] [EOL] self . string_content_line_numbers = multiline_string_lines ( input_text ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . lines = [ ] [EOL] for line_number , line in enumerate ( source_lines , start = [number] ) : [EOL] [comment] [EOL] if line_number in self . string_content_line_numbers : [EOL] self . lines . append ( line ) [EOL] else : [EOL] [comment] [EOL] self . lines . append ( _get_indentation ( line ) . expandtabs ( ) + _remove_leading_and_normalize ( line ) ) [EOL] [EOL] self . lines . insert ( [number] , None ) [EOL] self . index = [number] [comment] [EOL] self . input_text = input_text [EOL] [EOL] def run ( self , indent_size = DEFAULT_INDENT_SIZE ) : [EOL] [docstring] [EOL] if indent_size < [number] : [EOL] return self . input_text [EOL] [EOL] try : [EOL] stats = _reindent_stats ( tokenize . generate_tokens ( self . getline ) ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] return self . input_text [EOL] [comment] [EOL] lines = self . lines [EOL] [comment] [EOL] stats . append ( ( len ( lines ) , [number] ) ) [EOL] [comment] [EOL] have2want = { } [EOL] [comment] [EOL] after = [ ] [EOL] [comment] [EOL] [comment] [EOL] i = stats [ [number] ] [ [number] ] [EOL] after . extend ( lines [ [number] : i ] ) [EOL] for i in range ( len ( stats ) - [number] ) : [EOL] thisstmt , thislevel = stats [ i ] [EOL] nextstmt = stats [ i + [number] ] [ [number] ] [EOL] have = _leading_space_count ( lines [ thisstmt ] ) [EOL] want = thislevel * indent_size [EOL] if want < [number] : [EOL] [comment] [EOL] if have : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] want = have2want . get ( have , - [number] ) [EOL] if want < [number] : [EOL] [comment] [EOL] for j in range ( i + [number] , len ( stats ) - [number] ) : [EOL] jline , jlevel = stats [ j ] [EOL] if jlevel >= [number] : [EOL] if have == _leading_space_count ( lines [ jline ] ) : [EOL] want = jlevel * indent_size [EOL] break [EOL] if want < [number] : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for j in range ( i - [number] , - [number] , - [number] ) : [EOL] jline , jlevel = stats [ j ] [EOL] if jlevel >= [number] : [EOL] want = ( have + _leading_space_count ( after [ jline - [number] ] ) - _leading_space_count ( lines [ jline ] ) ) [EOL] break [EOL] if want < [number] : [EOL] [comment] [EOL] want = have [EOL] else : [EOL] want = [number] [EOL] assert want >= [number] [EOL] have2want [ have ] = want [EOL] diff = want - have [EOL] if diff == [number] or have == [number] : [EOL] after . extend ( lines [ thisstmt : nextstmt ] ) [EOL] else : [EOL] for line_number , line in enumerate ( lines [ thisstmt : nextstmt ] , start = thisstmt ) : [EOL] if line_number in self . string_content_line_numbers : [EOL] after . append ( line ) [EOL] elif diff > [number] : [EOL] if line == [string] : [EOL] after . append ( line ) [EOL] else : [EOL] after . append ( [string] * diff + line ) [EOL] else : [EOL] remove = min ( _leading_space_count ( line ) , - diff ) [EOL] after . append ( line [ remove : ] ) [EOL] [EOL] return [string] . join ( after ) [EOL] [EOL] def getline ( self ) : [EOL] [docstring] [EOL] if self . index >= len ( self . lines ) : [EOL] line = [string] [EOL] else : [EOL] line = self . lines [ self . index ] [EOL] self . index += [number] [EOL] return line [EOL] [EOL] [EOL] def _reindent_stats ( tokens ) : [EOL] [docstring] [EOL] find_stmt = [number] [comment] [EOL] level = [number] [comment] [EOL] stats = [ ] [EOL] [EOL] for t in tokens : [EOL] token_type = t [ [number] ] [EOL] sline = t [ [number] ] [ [number] ] [EOL] line = t [ [number] ] [EOL] [EOL] if token_type == tokenize . NEWLINE : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] find_stmt = [number] [EOL] [EOL] elif token_type == tokenize . INDENT : [EOL] find_stmt = [number] [EOL] level += [number] [EOL] [EOL] elif token_type == tokenize . DEDENT : [EOL] find_stmt = [number] [EOL] level -= [number] [EOL] [EOL] elif token_type == tokenize . COMMENT : [EOL] if find_stmt : [EOL] stats . append ( ( sline , - [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] elif token_type == tokenize . NL : [EOL] pass [EOL] [EOL] elif find_stmt : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] find_stmt = [number] [EOL] if line : [comment] [EOL] stats . append ( ( sline , level ) ) [EOL] [EOL] return stats [EOL] [EOL] [EOL] def _leading_space_count ( line ) : [EOL] [docstring] [EOL] i = [number] [EOL] while i < len ( line ) and line [ i ] == [string] : [EOL] i += [number] [EOL] return i [EOL] [EOL] [EOL] def refactor_with_2to3 ( source_text , fixer_names , filename = [string] ) : [EOL] [docstring] [EOL] from lib2to3 . refactor import RefactoringTool [EOL] fixers = [ [string] + name for name in fixer_names ] [EOL] tool = RefactoringTool ( fixer_names = fixers , explicit = fixers ) [EOL] [EOL] from lib2to3 . pgen2 import tokenize as lib2to3_tokenize [EOL] try : [EOL] [comment] [EOL] return unicode ( tool . refactor_string ( source_text , name = filename ) ) [EOL] except lib2to3_tokenize . TokenError : [EOL] return source_text [EOL] [EOL] [EOL] def check_syntax ( code ) : [EOL] [docstring] [EOL] try : [EOL] return compile ( code , [string] , [string] ) [EOL] except ( SyntaxError , TypeError , UnicodeDecodeError ) : [EOL] return False [EOL] [EOL] [EOL] def filter_results ( source , results , aggressive ) : [EOL] [docstring] [EOL] non_docstring_string_line_numbers = multiline_string_lines ( source , include_docstrings = False ) [EOL] all_string_line_numbers = multiline_string_lines ( source , include_docstrings = True ) [EOL] [EOL] commented_out_code_line_numbers = commented_out_code_lines ( source ) [EOL] [EOL] has_e901 = any ( result [ [string] ] . lower ( ) == [string] for result in results ) [EOL] [EOL] for r in results : [EOL] issue_id = r [ [string] ] . lower ( ) [EOL] [EOL] if r [ [string] ] in non_docstring_string_line_numbers : [EOL] if issue_id . startswith ( ( [string] , [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if r [ [string] ] in all_string_line_numbers : [EOL] if issue_id in [ [string] ] : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not aggressive and ( r [ [string] ] + [number] ) in all_string_line_numbers : [EOL] [comment] [EOL] [comment] [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if aggressive <= [number] : [EOL] if issue_id . startswith ( ( [string] , [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if aggressive <= [number] : [EOL] if issue_id . startswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if aggressive <= [number] : [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] if r [ [string] ] in commented_out_code_line_numbers : [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if has_e901 : [EOL] if issue_id . startswith ( ( [string] , [string] ) ) : [EOL] continue [EOL] [EOL] yield r [EOL] [EOL] [EOL] def multiline_string_lines ( source , include_docstrings = False ) : [EOL] [docstring] [EOL] line_numbers = set ( ) [EOL] previous_token_type = [string] [EOL] try : [EOL] for t in generate_tokens ( source ) : [EOL] token_type = t [ [number] ] [EOL] start_row = t [ [number] ] [ [number] ] [EOL] end_row = t [ [number] ] [ [number] ] [EOL] [EOL] if token_type == tokenize . STRING and start_row != end_row : [EOL] if ( include_docstrings or previous_token_type != tokenize . INDENT ) : [EOL] [comment] [EOL] [comment] [EOL] line_numbers |= set ( range ( [number] + start_row , [number] + end_row ) ) [EOL] [EOL] previous_token_type = token_type [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] pass [EOL] [EOL] return line_numbers [EOL] [EOL] [EOL] def commented_out_code_lines ( source ) : [EOL] [docstring] [EOL] line_numbers = [ ] [EOL] try : [EOL] for t in generate_tokens ( source ) : [EOL] token_type = t [ [number] ] [EOL] token_string = t [ [number] ] [EOL] start_row = t [ [number] ] [ [number] ] [EOL] line = t [ [number] ] [EOL] [EOL] [comment] [EOL] if not line . lstrip ( ) . startswith ( [string] ) : [EOL] continue [EOL] [EOL] if token_type == tokenize . COMMENT : [EOL] stripped_line = token_string . lstrip ( [string] ) . strip ( ) [EOL] if ( [string] in stripped_line and [string] not in stripped_line and check_syntax ( stripped_line ) ) : [EOL] line_numbers . append ( start_row ) [EOL] except ( SyntaxError , tokenize . TokenError ) : [EOL] pass [EOL] [EOL] return line_numbers [EOL] [EOL] [EOL] def shorten_comment ( line , max_line_length , last_comment = False ) : [EOL] [docstring] [EOL] assert len ( line ) > max_line_length [EOL] line = line . rstrip ( ) [EOL] [EOL] [comment] [EOL] indentation = _get_indentation ( line ) + [string] [EOL] max_line_length = min ( max_line_length , len ( indentation ) + [number] ) [EOL] [EOL] MIN_CHARACTER_REPEAT = [number] [EOL] if ( len ( line ) - len ( line . rstrip ( line [ - [number] ] ) ) >= MIN_CHARACTER_REPEAT and not line [ - [number] ] . isalnum ( ) ) : [EOL] [comment] [EOL] return line [ : max_line_length ] + [string] [EOL] elif last_comment and re . match ( [string] , line ) : [EOL] split_lines = textwrap . wrap ( line . lstrip ( [string] ) , initial_indent = indentation , subsequent_indent = indentation , width = max_line_length , break_long_words = False , break_on_hyphens = False ) [EOL] return [string] . join ( split_lines ) + [string] [EOL] [EOL] return line + [string] [EOL] [EOL] [EOL] def normalize_line_endings ( lines , newline ) : [EOL] [docstring] [EOL] return [ line . rstrip ( [string] ) + newline for line in lines ] [EOL] [EOL] [EOL] def mutual_startswith ( a , b ) : [EOL] return b . startswith ( a ) or a . startswith ( b ) [EOL] [EOL] [EOL] def code_match ( code , select , ignore ) : [EOL] if ignore : [EOL] assert not isinstance ( ignore , unicode ) [EOL] for ignored_code in [ c . strip ( ) for c in ignore ] : [EOL] if mutual_startswith ( code . lower ( ) , ignored_code . lower ( ) ) : [EOL] return False [EOL] [EOL] if select : [EOL] assert not isinstance ( select , unicode ) [EOL] for selected_code in [ c . strip ( ) for c in select ] : [EOL] if mutual_startswith ( code . lower ( ) , selected_code . lower ( ) ) : [EOL] return True [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def fix_code ( source , options = None , encoding = None , apply_config = False ) : [EOL] [docstring] [EOL] options = _get_options ( options , apply_config ) [EOL] [EOL] if not isinstance ( source , unicode ) : [EOL] source = source . decode ( encoding or get_encoding ( ) ) [EOL] [EOL] sio = io . StringIO ( source ) [EOL] return fix_lines ( sio . readlines ( ) , options = options ) [EOL] [EOL] [EOL] def _get_options ( raw_options , apply_config ) : [EOL] [docstring] [EOL] if not raw_options : [EOL] return parse_args ( [ [string] ] , apply_config = apply_config ) [EOL] [EOL] if isinstance ( raw_options , dict ) : [EOL] options = parse_args ( [ [string] ] , apply_config = apply_config ) [EOL] for name , value in raw_options . items ( ) : [EOL] if not hasattr ( options , name ) : [EOL] raise ValueError ( [string] . format ( name ) ) [EOL] [EOL] [comment] [EOL] expected_type = type ( getattr ( options , name ) ) [EOL] if not isinstance ( expected_type , ( str , unicode ) ) : [EOL] if isinstance ( value , ( str , unicode ) ) : [EOL] raise ValueError ( [string] . format ( name ) ) [EOL] setattr ( options , name , value ) [EOL] else : [EOL] options = raw_options [EOL] [EOL] return options [EOL] [EOL] [EOL] def fix_lines ( source_lines , options , filename = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] original_newline = find_newline ( source_lines ) [EOL] tmp_source = [string] . join ( normalize_line_endings ( source_lines , [string] ) ) [EOL] [EOL] [comment] [EOL] previous_hashes = set ( ) [EOL] [EOL] if options . line_range : [EOL] [comment] [EOL] fixed_source = tmp_source [EOL] else : [EOL] [comment] [EOL] fixed_source = apply_global_fixes ( tmp_source , options , filename = filename ) [EOL] [EOL] passes = [number] [EOL] long_line_ignore_cache = set ( ) [EOL] while hash ( fixed_source ) not in previous_hashes : [EOL] if options . pep8_passes >= [number] and passes > options . pep8_passes : [EOL] break [EOL] passes += [number] [EOL] [EOL] previous_hashes . add ( hash ( fixed_source ) ) [EOL] [EOL] tmp_source = copy . copy ( fixed_source ) [EOL] [EOL] fix = FixPEP8 ( filename , options , contents = tmp_source , long_line_ignore_cache = long_line_ignore_cache ) [EOL] [EOL] fixed_source = fix . fix ( ) [EOL] [EOL] sio = io . StringIO ( fixed_source ) [EOL] return [string] . join ( normalize_line_endings ( sio . readlines ( ) , original_newline ) ) [EOL] [EOL] [EOL] def fix_file ( filename , options = None , output = None , apply_config = False ) : [EOL] if not options : [EOL] options = parse_args ( [ filename ] , apply_config = apply_config ) [EOL] [EOL] original_source = readlines_from_file ( filename ) [EOL] [EOL] fixed_source = original_source [EOL] [EOL] if options . in_place or output : [EOL] encoding = detect_encoding ( filename ) [EOL] [EOL] if output : [EOL] output = LineEndingWrapper ( wrap_output ( output , encoding = encoding ) ) [EOL] [EOL] fixed_source = fix_lines ( fixed_source , options , filename = filename ) [EOL] [EOL] if options . diff : [EOL] new = io . StringIO ( fixed_source ) [EOL] new = new . readlines ( ) [EOL] diff = get_diff_text ( original_source , new , filename ) [EOL] if output : [EOL] output . write ( diff ) [EOL] output . flush ( ) [EOL] else : [EOL] return diff [EOL] elif options . in_place : [EOL] fp = open_with_encoding ( filename , encoding = encoding , mode = [string] ) [EOL] fp . write ( fixed_source ) [EOL] fp . close ( ) [EOL] else : [EOL] if output : [EOL] output . write ( fixed_source ) [EOL] output . flush ( ) [EOL] else : [EOL] return fixed_source [EOL] [EOL] [EOL] def global_fixes ( ) : [EOL] [docstring] [EOL] for function in list ( globals ( ) . values ( ) ) : [EOL] if inspect . isfunction ( function ) : [EOL] arguments = _get_parameters ( function ) [EOL] if arguments [ : [number] ] != [ [string] ] : [EOL] continue [EOL] [EOL] code = extract_code_from_function ( function ) [EOL] if code : [EOL] yield ( code , function ) [EOL] [EOL] [EOL] def _get_parameters ( function ) : [EOL] [comment] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if inspect . ismethod ( function ) : [EOL] function = function . __func__ [EOL] [EOL] return list ( inspect . signature ( function ) . parameters ) [EOL] else : [EOL] return inspect . getargspec ( function ) [ [number] ] [EOL] [EOL] [EOL] def apply_global_fixes ( source , options , where = [string] , filename = [string] ) : [EOL] [docstring] [EOL] if any ( code_match ( code , select = options . select , ignore = options . ignore ) for code in [ [string] , [string] ] ) : [EOL] source = reindent ( source , indent_size = options . indent_size ) [EOL] [EOL] for ( code , function ) in global_fixes ( ) : [EOL] if code_match ( code , select = options . select , ignore = options . ignore ) : [EOL] if options . verbose : [EOL] print ( [string] . format ( where , code . upper ( ) ) , file = sys . stderr ) [EOL] source = function ( source , aggressive = options . aggressive ) [EOL] [EOL] source = fix_2to3 ( source , aggressive = options . aggressive , select = options . select , ignore = options . ignore , filename = filename ) [EOL] [EOL] return source [EOL] [EOL] [EOL] def extract_code_from_function ( function ) : [EOL] [docstring] [EOL] if not function . __name__ . startswith ( [string] ) : [EOL] return None [EOL] [EOL] code = re . sub ( [string] , [string] , function . __name__ ) [EOL] if not code : [EOL] return None [EOL] [EOL] try : [EOL] int ( code [ [number] : ] ) [EOL] except ValueError : [EOL] return None [EOL] [EOL] return code [EOL] [EOL] [EOL] def _get_package_version ( ) : [EOL] packages = [ [string] . format ( pycodestyle . __version__ ) ] [EOL] return [string] . join ( packages ) [EOL] [EOL] [EOL] def create_parser ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] import argparse [EOL] [EOL] parser = argparse . ArgumentParser ( description = docstring_summary ( __doc__ ) , prog = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , version = [string] . format ( __version__ , _get_package_version ( ) ) ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = DEFAULT_CONFIG , help = [string] [string] [string] . format ( DEFAULT_CONFIG ) ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , type = int , metavar = [string] , default = [number] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , default = - [number] , type = int , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = [string] , help = [string] [string] . format ( DEFAULT_IGNORE ) ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = [number] , type = int , help = [string] [string] ) [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , default = None , type = int , nargs = [number] , help = [string] [string] [string] ) [EOL] parser . add_argument ( [string] , default = DEFAULT_INDENT_SIZE , type = int , help = argparse . SUPPRESS ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] def parse_args ( arguments , apply_config = False ) : [EOL] [docstring] [EOL] parser = create_parser ( ) [EOL] args = parser . parse_args ( arguments ) [EOL] [EOL] if not args . files and not args . list_fixes : [EOL] parser . error ( [string] ) [EOL] [EOL] args . files = [ decode_filename ( name ) for name in args . files ] [EOL] [EOL] if apply_config : [EOL] parser = read_config ( args , parser ) [EOL] args = parser . parse_args ( arguments ) [EOL] args . files = [ decode_filename ( name ) for name in args . files ] [EOL] [EOL] if [string] in args . files : [EOL] if len ( args . files ) > [number] : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . diff : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . in_place : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . recursive : [EOL] parser . error ( [string] ) [EOL] [EOL] if len ( args . files ) > [number] and not ( args . in_place or args . diff ) : [EOL] parser . error ( [string] [string] [string] ) [EOL] [EOL] if args . recursive and not ( args . in_place or args . diff ) : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . in_place and args . diff : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . max_line_length <= [number] : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . select : [EOL] args . select = _split_comma_separated ( args . select ) [EOL] [EOL] if args . ignore : [EOL] args . ignore = _split_comma_separated ( args . ignore ) [EOL] elif not args . select : [EOL] if args . aggressive : [EOL] [comment] [EOL] args . select = set ( [ [string] , [string] ] ) [EOL] else : [EOL] args . ignore = _split_comma_separated ( DEFAULT_IGNORE ) [EOL] [EOL] if args . exclude : [EOL] args . exclude = _split_comma_separated ( args . exclude ) [EOL] else : [EOL] args . exclude = set ( [ ] ) [EOL] [EOL] if args . jobs < [number] : [EOL] [comment] [EOL] [comment] [EOL] import multiprocessing [EOL] args . jobs = multiprocessing . cpu_count ( ) [EOL] [EOL] if args . jobs > [number] and not args . in_place : [EOL] parser . error ( [string] ) [EOL] [EOL] if args . line_range : [EOL] if args . line_range [ [number] ] <= [number] : [EOL] parser . error ( [string] ) [EOL] if args . line_range [ [number] ] > args . line_range [ [number] ] : [EOL] parser . error ( [string] [string] ) [EOL] [EOL] return args [EOL] [EOL] [EOL] def read_config ( args , parser ) : [EOL] [docstring] [EOL] try : [EOL] from configparser import ConfigParser as SafeConfigParser [EOL] from configparser import Error [EOL] except ImportError : [EOL] from ConfigParser import SafeConfigParser [EOL] from ConfigParser import Error [EOL] [EOL] config = SafeConfigParser ( ) [EOL] [EOL] try : [EOL] config . read ( args . global_config ) [EOL] [EOL] if not args . ignore_local_config : [EOL] parent = tail = args . files and os . path . abspath ( os . path . commonprefix ( args . files ) ) [EOL] while tail : [EOL] if config . read ( [ os . path . join ( parent , fn ) for fn in PROJECT_CONFIG ] ) : [EOL] break [EOL] ( parent , tail ) = os . path . split ( parent ) [EOL] [EOL] defaults = dict ( ) [EOL] option_list = dict ( [ ( o . dest , o . type or type ( o . default ) ) for o in parser . _actions ] ) [EOL] [EOL] for section in [ [string] , [string] ] : [EOL] if not config . has_section ( section ) : [EOL] continue [EOL] for ( k , _ ) in config . items ( section ) : [EOL] norm_opt = k . lstrip ( [string] ) . replace ( [string] , [string] ) [EOL] opt_type = option_list [ norm_opt ] [EOL] if opt_type is int : [EOL] value = config . getint ( section , k ) [EOL] elif opt_type is bool : [EOL] value = config . getboolean ( section , k ) [EOL] else : [EOL] value = config . get ( section , k ) [EOL] defaults [ norm_opt ] = value [EOL] [EOL] parser . set_defaults ( ** defaults ) [EOL] except Error : [EOL] [comment] [EOL] pass [EOL] [EOL] return parser [EOL] [EOL] [EOL] def _split_comma_separated ( string ) : [EOL] [docstring] [EOL] return set ( text . strip ( ) for text in string . split ( [string] ) if text . strip ( ) ) [EOL] [EOL] [EOL] def decode_filename ( filename ) : [EOL] [docstring] [EOL] if isinstance ( filename , unicode ) : [EOL] return filename [EOL] [EOL] return filename . decode ( sys . getfilesystemencoding ( ) ) [EOL] [EOL] [EOL] def supported_fixes ( ) : [EOL] [docstring] [EOL] yield ( [string] , docstring_summary ( reindent . __doc__ ) ) [EOL] [EOL] instance = FixPEP8 ( filename = None , options = None , contents = [string] ) [EOL] for attribute in dir ( instance ) : [EOL] code = re . match ( [string] , attribute ) [EOL] if code : [EOL] yield ( code . group ( [number] ) . upper ( ) , re . sub ( [string] , [string] , docstring_summary ( getattr ( instance , attribute ) . __doc__ ) ) ) [EOL] [EOL] for ( code , function ) in sorted ( global_fixes ( ) ) : [EOL] yield ( code . upper ( ) + ( [number] - len ( code ) ) * [string] , re . sub ( [string] , [string] , docstring_summary ( function . __doc__ ) ) ) [EOL] [EOL] for code in sorted ( CODE_TO_2TO3 ) : [EOL] yield ( code . upper ( ) + ( [number] - len ( code ) ) * [string] , re . sub ( [string] , [string] , docstring_summary ( fix_2to3 . __doc__ ) ) ) [EOL] [EOL] [EOL] def docstring_summary ( docstring ) : [EOL] [docstring] [EOL] return docstring . split ( [string] ) [ [number] ] if docstring else [string] [EOL] [EOL] [EOL] def line_shortening_rank ( candidate , indent_word , max_line_length , experimental = False ) : [EOL] [docstring] [EOL] if not candidate . strip ( ) : [EOL] return [number] [EOL] [EOL] rank = [number] [EOL] lines = candidate . rstrip ( ) . split ( [string] ) [EOL] [EOL] offset = [number] [EOL] if ( not lines [ [number] ] . lstrip ( ) . startswith ( [string] ) and lines [ [number] ] . rstrip ( ) [ - [number] ] not in [string] ) : [EOL] for ( opening , closing ) in ( [string] , [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] opening_loc = lines [ [number] ] . find ( opening ) [EOL] closing_loc = lines [ [number] ] . find ( closing ) [EOL] if opening_loc >= [number] : [EOL] if closing_loc < [number] or closing_loc != opening_loc + [number] : [EOL] offset = max ( offset , [number] + opening_loc ) [EOL] [EOL] current_longest = max ( offset + len ( x . strip ( ) ) for x in lines ) [EOL] [EOL] rank += [number] * max ( [number] , current_longest - max_line_length ) [EOL] [EOL] rank += len ( lines ) [EOL] [EOL] [comment] [EOL] rank += [number] * standard_deviation ( len ( line ) for line in lines ) [EOL] [EOL] bad_staring_symbol = { [string] : [string] , [string] : [string] , [string] : [string] } . get ( lines [ [number] ] [ - [number] ] ) [EOL] [EOL] if len ( lines ) > [number] : [EOL] if ( bad_staring_symbol and lines [ [number] ] . lstrip ( ) . startswith ( bad_staring_symbol ) ) : [EOL] rank += [number] [EOL] [EOL] for lineno , current_line in enumerate ( lines ) : [EOL] current_line = current_line . strip ( ) [EOL] [EOL] if current_line . startswith ( [string] ) : [EOL] continue [EOL] [EOL] for bad_start in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] if current_line . startswith ( bad_start ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if current_line == bad_start : [EOL] rank += [number] [EOL] [EOL] if ( current_line . endswith ( ( [string] , [string] , [string] , [string] , [string] ) ) and [string] in current_line ) : [EOL] rank += [number] [EOL] [EOL] if current_line . endswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] [comment] [EOL] if len ( current_line ) <= len ( indent_word ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if ( current_line . endswith ( [string] ) and current_line [ : - [number] ] . rstrip ( ) . endswith ( [string] ) ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if ( current_line . endswith ( [string] ) and len ( current_line ) > [number] and ( current_line [ - [number] ] . isalnum ( ) or current_line [ - [number] ] in [string] ) ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if current_line . endswith ( [string] ) : [EOL] rank += [number] [EOL] [EOL] if has_arithmetic_operator ( current_line ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if re . match ( [string] , current_line . rstrip ( [string] ) ) : [EOL] rank += [number] [EOL] [EOL] if re . match ( [string] , current_line . rstrip ( [string] ) ) : [EOL] rank += [number] [EOL] [EOL] if current_line . endswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] rank -= [number] [EOL] [EOL] [comment] [EOL] if current_line . startswith ( [string] ) : [EOL] rank -= [number] [EOL] [EOL] if current_line . endswith ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] total_len = len ( current_line ) [EOL] lineno += [number] [EOL] while lineno < len ( lines ) : [EOL] total_len += len ( lines [ lineno ] ) [EOL] [EOL] if lines [ lineno ] . lstrip ( ) . startswith ( [string] ) : [EOL] total_len = max_line_length [EOL] break [EOL] [EOL] if not lines [ lineno ] . endswith ( [string] ) : [EOL] break [EOL] [EOL] lineno += [number] [EOL] [EOL] if total_len < max_line_length : [EOL] rank += [number] [EOL] else : [EOL] rank += [number] if experimental else [number] [EOL] [EOL] [comment] [EOL] if [string] in current_line and current_line . endswith ( [string] ) : [EOL] rank += [number] [EOL] [EOL] [comment] [EOL] if current_line . endswith ( [string] ) : [EOL] rank += [number] [EOL] [EOL] rank += [number] * count_unbalanced_brackets ( current_line ) [EOL] [EOL] return max ( [number] , rank ) [EOL] [EOL] [EOL] def standard_deviation ( numbers ) : [EOL] [docstring] [EOL] numbers = list ( numbers ) [EOL] if not numbers : [EOL] return [number] [EOL] mean = sum ( numbers ) / len ( numbers ) [EOL] return ( sum ( ( n - mean ) ** [number] for n in numbers ) / len ( numbers ) ) ** [number] [EOL] [EOL] [EOL] def has_arithmetic_operator ( line ) : [EOL] [docstring] [EOL] for operator in pycodestyle . ARITHMETIC_OP : [EOL] if operator in line : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def count_unbalanced_brackets ( line ) : [EOL] [docstring] [EOL] count = [number] [EOL] for opening , closing in [ [string] , [string] , [string] ] : [EOL] count += abs ( line . count ( opening ) - line . count ( closing ) ) [EOL] [EOL] return count [EOL] [EOL] [EOL] def split_at_offsets ( line , offsets ) : [EOL] [docstring] [EOL] result = [ ] [EOL] [EOL] previous_offset = [number] [EOL] current_offset = [number] [EOL] for current_offset in sorted ( offsets ) : [EOL] if current_offset < len ( line ) and previous_offset != current_offset : [EOL] result . append ( line [ previous_offset : current_offset ] . strip ( ) ) [EOL] previous_offset = current_offset [EOL] [EOL] result . append ( line [ current_offset : ] ) [EOL] [EOL] return result [EOL] [EOL] [EOL] class LineEndingWrapper ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output ) : [EOL] self . __output = output [EOL] [EOL] def write ( self , s ) : [EOL] self . __output . write ( s . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] [EOL] def flush ( self ) : [EOL] self . __output . flush ( ) [EOL] [EOL] [EOL] def match_file ( filename , exclude ) : [EOL] [docstring] [EOL] base_name = os . path . basename ( filename ) [EOL] [EOL] if base_name . startswith ( [string] ) : [EOL] return False [EOL] [EOL] for pattern in exclude : [EOL] if fnmatch . fnmatch ( base_name , pattern ) : [EOL] return False [EOL] if fnmatch . fnmatch ( filename , pattern ) : [EOL] return False [EOL] [EOL] if not os . path . isdir ( filename ) and not is_python_file ( filename ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def find_files ( filenames , recursive , exclude ) : [EOL] [docstring] [EOL] while filenames : [EOL] name = filenames . pop ( [number] ) [EOL] if recursive and os . path . isdir ( name ) : [EOL] for root , directories , children in os . walk ( name ) : [EOL] filenames += [ os . path . join ( root , f ) for f in children if match_file ( os . path . join ( root , f ) , exclude ) ] [EOL] directories [ : ] = [ d for d in directories if match_file ( os . path . join ( root , d ) , exclude ) ] [EOL] else : [EOL] yield name [EOL] [EOL] [EOL] def _fix_file ( parameters ) : [EOL] [docstring] [EOL] if parameters [ [number] ] . verbose : [EOL] print ( [string] . format ( parameters [ [number] ] ) , file = sys . stderr ) [EOL] try : [EOL] fix_file ( * parameters ) [EOL] except IOError as error : [EOL] print ( unicode ( error ) , file = sys . stderr ) [EOL] [EOL] [EOL] def fix_multiple_files ( filenames , options , output = None ) : [EOL] [docstring] [EOL] filenames = find_files ( filenames , options . recursive , options . exclude ) [EOL] if options . jobs > [number] : [EOL] import multiprocessing [EOL] pool = multiprocessing . Pool ( options . jobs ) [EOL] pool . map ( _fix_file , [ ( name , options ) for name in filenames ] ) [EOL] else : [EOL] for name in filenames : [EOL] _fix_file ( ( name , options , output ) ) [EOL] [EOL] [EOL] def is_python_file ( filename ) : [EOL] [docstring] [EOL] if filename . endswith ( [string] ) : [EOL] return True [EOL] [EOL] try : [EOL] with open_with_encoding ( filename , limit_byte_check = MAX_PYTHON_FILE_DETECTION_BYTES ) as f : [EOL] text = f . read ( MAX_PYTHON_FILE_DETECTION_BYTES ) [EOL] if not text : [EOL] return False [EOL] first_line = text . splitlines ( ) [ [number] ] [EOL] except ( IOError , IndexError ) : [EOL] return False [EOL] [EOL] if not PYTHON_SHEBANG_REGEX . match ( first_line ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def is_probably_part_of_multiline ( line ) : [EOL] [docstring] [EOL] return ( [string] in line or [string] in line or line . rstrip ( ) . endswith ( [string] ) ) [EOL] [EOL] [EOL] def wrap_output ( output , encoding ) : [EOL] [docstring] [EOL] return codecs . getwriter ( encoding ) ( output . buffer [EOL] if hasattr ( output , [string] ) [EOL] else output ) [EOL] [EOL] [EOL] def get_encoding ( ) : [EOL] [docstring] [EOL] return locale . getpreferredencoding ( ) or sys . getdefaultencoding ( ) [EOL] [EOL] [EOL] def main ( argv = None , apply_config = True ) : [EOL] [docstring] [EOL] if argv is None : [EOL] argv = sys . argv [EOL] [EOL] try : [EOL] [comment] [EOL] signal . signal ( signal . SIGPIPE , signal . SIG_DFL ) [EOL] except AttributeError : [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] try : [EOL] args = parse_args ( argv [ [number] : ] , apply_config = apply_config ) [EOL] [EOL] if args . list_fixes : [EOL] for code , description in sorted ( supported_fixes ( ) ) : [EOL] print ( [string] . format ( code = code , description = description ) ) [EOL] return [number] [EOL] [EOL] if args . files == [ [string] ] : [EOL] assert not args . in_place [EOL] [EOL] encoding = sys . stdin . encoding or get_encoding ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] wrap_output ( sys . stdout , encoding = encoding ) . write ( fix_code ( sys . stdin . read ( ) , args , encoding = encoding ) ) [EOL] else : [EOL] if args . in_place or args . diff : [EOL] args . files = list ( set ( args . files ) ) [EOL] else : [EOL] assert len ( args . files ) == [number] [EOL] assert not args . recursive [EOL] [EOL] fix_multiple_files ( args . files , args , sys . stdout ) [EOL] except KeyboardInterrupt : [EOL] return [number] [comment] [EOL] [EOL] [EOL] class CachedTokenizer ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . last_text = None [EOL] self . last_tokens = None [EOL] [EOL] def generate_tokens ( self , text ) : [EOL] [docstring] [EOL] if text != self . last_text : [EOL] string_io = io . StringIO ( text ) [EOL] self . last_tokens = list ( tokenize . generate_tokens ( string_io . readline ) ) [EOL] self . last_text = text [EOL] return self . last_tokens [EOL] [EOL] [EOL] _cached_tokenizer = CachedTokenizer ( ) [EOL] generate_tokens = _cached_tokenizer . generate_tokens [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Tuple , Any [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import pickle [EOL] [EOL] [comment] [EOL] from . import token , tokenize [EOL] [EOL] [EOL] class Grammar ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] self . states = [ ] [EOL] self . dfas = { } [EOL] self . labels = [ ( [number] , [string] ) ] [EOL] self . keywords = { } [EOL] self . tokens = { } [EOL] self . symbol2label = { } [EOL] self . start = [number] [EOL] [EOL] def dump ( self , filename ) : [EOL] [docstring] [EOL] f = open ( filename , [string] ) [EOL] pickle . dump ( self . __dict__ , f , [number] ) [EOL] f . close ( ) [EOL] [EOL] def load ( self , filename ) : [EOL] [docstring] [EOL] f = open ( filename , [string] ) [EOL] d = pickle . load ( f ) [EOL] f . close ( ) [EOL] self . __dict__ . update ( d ) [EOL] [EOL] def copy ( self ) : [EOL] [docstring] [EOL] new = self . __class__ ( ) [EOL] for dict_attr in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] setattr ( new , dict_attr , getattr ( self , dict_attr ) . copy ( ) ) [EOL] new . labels = self . labels [ : ] [EOL] new . states = self . states [ : ] [EOL] new . start = self . start [EOL] return new [EOL] [EOL] def report ( self ) : [EOL] [docstring] [EOL] from pprint import pprint [EOL] print ( [string] ) [EOL] pprint ( self . symbol2number ) [EOL] print ( [string] ) [EOL] pprint ( self . number2symbol ) [EOL] print ( [string] ) [EOL] pprint ( self . states ) [EOL] print ( [string] ) [EOL] pprint ( self . dfas ) [EOL] print ( [string] ) [EOL] pprint ( self . labels ) [EOL] print ( [string] , self . start ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] opmap_raw = [string] [EOL] [EOL] opmap = { } [EOL] for line in opmap_raw . splitlines ( ) : [EOL] if line : [EOL] op , name = line . split ( ) [EOL] opmap [ op ] = getattr ( token , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 $io.BufferedWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BufferedReader$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BufferedReader$ 0 0 $io.BufferedReader$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , List , Tuple , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from . import token [EOL] [EOL] class ParseError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg , type , value , context ) : [EOL] Exception . __init__ ( self , [string] % ( msg , type , value , context ) ) [EOL] self . msg = msg [EOL] self . type = type [EOL] self . value = value [EOL] self . context = context [EOL] [EOL] class Parser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , grammar , convert = None ) : [EOL] [docstring] [EOL] self . grammar = grammar [EOL] self . convert = convert or ( lambda grammar , node : node ) [EOL] [EOL] def setup ( self , start = None ) : [EOL] [docstring] [EOL] if start is None : [EOL] start = self . grammar . start [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] newnode = ( start , None , None , [ ] ) [EOL] stackentry = ( self . grammar . dfas [ start ] , [number] , newnode ) [EOL] self . stack = [ stackentry ] [EOL] self . rootnode = None [EOL] self . used_names = set ( ) [comment] [EOL] [EOL] def addtoken ( self , type , value , context ) : [EOL] [docstring] [EOL] [comment] [EOL] ilabel = self . classify ( type , value , context ) [EOL] [comment] [EOL] while True : [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] arcs = states [ state ] [EOL] [comment] [EOL] for i , newstate in arcs : [EOL] t , v = self . grammar . labels [ i ] [EOL] if ilabel == i : [EOL] [comment] [EOL] assert t < [number] [EOL] [comment] [EOL] self . shift ( type , value , newstate , context ) [EOL] [comment] [EOL] state = newstate [EOL] while states [ state ] == [ ( [number] , state ) ] : [EOL] self . pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] return True [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] states , first = dfa [EOL] [comment] [EOL] return False [EOL] elif t >= [number] : [EOL] [comment] [EOL] itsdfa = self . grammar . dfas [ t ] [EOL] itsstates , itsfirst = itsdfa [EOL] if ilabel in itsfirst : [EOL] [comment] [EOL] self . push ( t , self . grammar . dfas [ t ] , newstate , context ) [EOL] break [comment] [EOL] else : [EOL] if ( [number] , state ) in arcs : [EOL] [comment] [EOL] self . pop ( ) [EOL] if not self . stack : [EOL] [comment] [EOL] raise ParseError ( [string] , type , value , context ) [EOL] else : [EOL] [comment] [EOL] raise ParseError ( [string] , type , value , context ) [EOL] [EOL] def classify ( self , type , value , context ) : [EOL] [docstring] [EOL] if type == token . NAME : [EOL] [comment] [EOL] self . used_names . add ( value ) [EOL] [comment] [EOL] ilabel = self . grammar . keywords . get ( value ) [EOL] if ilabel is not None : [EOL] return ilabel [EOL] ilabel = self . grammar . tokens . get ( type ) [EOL] if ilabel is None : [EOL] raise ParseError ( [string] , type , value , context ) [EOL] return ilabel [EOL] [EOL] def shift ( self , type , value , newstate , context ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = ( type , value , context , None ) [EOL] newnode = self . convert ( self . grammar , newnode ) [EOL] if newnode is not None : [EOL] node [ - [number] ] . append ( newnode ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] [EOL] def push ( self , type , newdfa , newstate , context ) : [EOL] [docstring] [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] newnode = ( type , None , context , [ ] ) [EOL] self . stack [ - [number] ] = ( dfa , newstate , node ) [EOL] self . stack . append ( ( newdfa , [number] , newnode ) ) [EOL] [EOL] def pop ( self ) : [EOL] [docstring] [EOL] popdfa , popstate , popnode = self . stack . pop ( ) [EOL] newnode = self . convert ( self . grammar , popnode ) [EOL] if newnode is not None : [EOL] if self . stack : [EOL] dfa , state , node = self . stack [ - [number] ] [EOL] node [ - [number] ] . append ( newnode ) [EOL] else : [EOL] self . rootnode = newnode [EOL] self . rootnode . used_names = self . used_names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,None,None,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[unknown,None,None,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,None,None,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing_extensions.Literal,typing.Tuple[unknown,None,None,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,None,typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,None,typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , List , Tuple , Pattern , Dict [EOL] import codecs [EOL] import typing [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __credits__ = [string] [EOL] [EOL] import string , re [EOL] from codecs import BOM_UTF8 , lookup [EOL] from lib2to3 . pgen2 . token import * [EOL] [EOL] from . import token [EOL] __all__ = [ x for x in dir ( token ) if x [ [number] ] != [string] ] + [ [string] , [string] , [string] ] [EOL] del token [EOL] [EOL] try : [EOL] bytes [EOL] except NameError : [EOL] [comment] [EOL] [comment] [EOL] bytes = str [EOL] [EOL] def group ( * choices ) : return [string] + [string] . join ( choices ) + [string] [EOL] def any ( * choices ) : return group ( * choices ) + [string] [EOL] def maybe ( * choices ) : return group ( * choices ) + [string] [EOL] [EOL] Whitespace = [string] [EOL] Comment = [string] [EOL] Ignore = Whitespace + any ( [string] + Whitespace ) + maybe ( Comment ) [EOL] Name = [string] [EOL] [EOL] Binnumber = [string] [EOL] Hexnumber = [string] [EOL] Octnumber = [string] [EOL] Decnumber = [string] [EOL] Intnumber = group ( Binnumber , Hexnumber , Octnumber , Decnumber ) [EOL] Exponent = [string] [EOL] Pointfloat = group ( [string] , [string] ) + maybe ( Exponent ) [EOL] Expfloat = [string] + Exponent [EOL] Floatnumber = group ( Pointfloat , Expfloat ) [EOL] Imagnumber = group ( [string] , Floatnumber + [string] ) [EOL] Number = group ( Imagnumber , Floatnumber , Intnumber ) [EOL] [EOL] [comment] [EOL] Single = [string] [EOL] [comment] [EOL] Double = [string] [EOL] [comment] [EOL] Single3 = [string] [EOL] [comment] [EOL] Double3 = [string] [EOL] Triple = group ( [string] , [string] ) [EOL] [comment] [EOL] String = group ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] Operator = group ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] Bracket = [string] [EOL] Special = group ( [string] , [string] ) [EOL] Funny = group ( Operator , Bracket , Special ) [EOL] [EOL] PlainToken = group ( Number , Funny , String , Name ) [EOL] Token = Ignore + PlainToken [EOL] [EOL] [comment] [EOL] ContStr = group ( [string] + group ( [string] , [string] ) , [string] + group ( [string] , [string] ) ) [EOL] PseudoExtras = group ( [string] , Comment , Triple ) [EOL] PseudoToken = Whitespace + group ( PseudoExtras , Number , Funny , ContStr , Name ) [EOL] [EOL] tokenprog , pseudoprog , single3prog , double3prog = list ( map ( re . compile , ( Token , PseudoToken , Single3 , Double3 ) ) ) [EOL] endprogs = { [string] : re . compile ( Single ) , [string] : re . compile ( Double ) , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : single3prog , [string] : double3prog , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None } [EOL] [EOL] triple_quoted = { } [EOL] for t in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] triple_quoted [ t ] = t [EOL] single_quoted = { } [EOL] for t in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] single_quoted [ t ] = t [EOL] [EOL] tabsize = [number] [EOL] [EOL] class TokenError ( Exception ) : pass [EOL] [EOL] class StopTokenizing ( Exception ) : pass [EOL] [EOL] def printtoken ( type , token , xxx_todo_changeme , xxx_todo_changeme1 , line ) : [comment] [EOL] ( srow , scol ) = xxx_todo_changeme [EOL] ( erow , ecol ) = xxx_todo_changeme1 [EOL] print ( [string] % ( srow , scol , erow , ecol , tok_name [ type ] , repr ( token ) ) ) [EOL] [EOL] def tokenize ( readline , tokeneater = printtoken ) : [EOL] [docstring] [EOL] try : [EOL] tokenize_loop ( readline , tokeneater ) [EOL] except StopTokenizing : [EOL] pass [EOL] [EOL] [comment] [EOL] def tokenize_loop ( readline , tokeneater ) : [EOL] for token_info in generate_tokens ( readline ) : [EOL] tokeneater ( * token_info ) [EOL] [EOL] class Untokenizer : [EOL] [EOL] def __init__ ( self ) : [EOL] self . tokens = [ ] [EOL] self . prev_row = [number] [EOL] self . prev_col = [number] [EOL] [EOL] def add_whitespace ( self , start ) : [EOL] row , col = start [EOL] assert row <= self . prev_row [EOL] col_offset = col - self . prev_col [EOL] if col_offset : [EOL] self . tokens . append ( [string] * col_offset ) [EOL] [EOL] def untokenize ( self , iterable ) : [EOL] for t in iterable : [EOL] if len ( t ) == [number] : [EOL] self . compat ( t , iterable ) [EOL] break [EOL] tok_type , token , start , end , line = t [EOL] self . add_whitespace ( start ) [EOL] self . tokens . append ( token ) [EOL] self . prev_row , self . prev_col = end [EOL] if tok_type in ( NEWLINE , NL ) : [EOL] self . prev_row += [number] [EOL] self . prev_col = [number] [EOL] return [string] . join ( self . tokens ) [EOL] [EOL] def compat ( self , token , iterable ) : [EOL] startline = False [EOL] indents = [ ] [EOL] toks_append = self . tokens . append [EOL] toknum , tokval = token [EOL] if toknum in ( NAME , NUMBER ) : [EOL] tokval += [string] [EOL] if toknum in ( NEWLINE , NL ) : [EOL] startline = True [EOL] for tok in iterable : [EOL] toknum , tokval = tok [ : [number] ] [EOL] [EOL] if toknum in ( NAME , NUMBER ) : [EOL] tokval += [string] [EOL] [EOL] if toknum == INDENT : [EOL] indents . append ( tokval ) [EOL] continue [EOL] elif toknum == DEDENT : [EOL] indents . pop ( ) [EOL] continue [EOL] elif toknum in ( NEWLINE , NL ) : [EOL] startline = True [EOL] elif startline and indents : [EOL] toks_append ( indents [ - [number] ] ) [EOL] startline = False [EOL] toks_append ( tokval ) [EOL] [EOL] cookie_re = re . compile ( [string] ) [EOL] [EOL] def _get_normal_name ( orig_enc ) : [EOL] [docstring] [EOL] [comment] [EOL] enc = orig_enc [ : [number] ] . lower ( ) . replace ( [string] , [string] ) [EOL] if enc == [string] or enc . startswith ( [string] ) : [EOL] return [string] [EOL] if enc in ( [string] , [string] , [string] ) or enc . startswith ( ( [string] , [string] , [string] ) ) : [EOL] return [string] [EOL] return orig_enc [EOL] [EOL] def detect_encoding ( readline ) : [EOL] [docstring] [EOL] bom_found = False [EOL] encoding = None [EOL] default = [string] [EOL] def read_or_stop ( ) : [EOL] try : [EOL] return readline ( ) [EOL] except StopIteration : [EOL] return bytes ( ) [EOL] [EOL] def find_cookie ( line ) : [EOL] try : [EOL] line_string = line . decode ( [string] ) [EOL] except UnicodeDecodeError : [EOL] return None [EOL] [EOL] matches = cookie_re . findall ( line_string ) [EOL] if not matches : [EOL] return None [EOL] encoding = _get_normal_name ( matches [ [number] ] ) [EOL] try : [EOL] codec = lookup ( encoding ) [EOL] except LookupError : [EOL] [comment] [EOL] raise SyntaxError ( [string] + encoding ) [EOL] [EOL] if bom_found : [EOL] if codec . name != [string] : [EOL] [comment] [EOL] raise SyntaxError ( [string] ) [EOL] encoding += [string] [EOL] return encoding [EOL] [EOL] first = read_or_stop ( ) [EOL] if first . startswith ( BOM_UTF8 ) : [EOL] bom_found = True [EOL] first = first [ [number] : ] [EOL] default = [string] [EOL] if not first : [EOL] return default , [ ] [EOL] [EOL] encoding = find_cookie ( first ) [EOL] if encoding : [EOL] return encoding , [ first ] [EOL] [EOL] second = read_or_stop ( ) [EOL] if not second : [EOL] return default , [ first ] [EOL] [EOL] encoding = find_cookie ( second ) [EOL] if encoding : [EOL] return encoding , [ first , second ] [EOL] [EOL] return default , [ first , second ] [EOL] [EOL] def untokenize ( iterable ) : [EOL] [docstring] [EOL] ut = Untokenizer ( ) [EOL] return ut . untokenize ( iterable ) [EOL] [EOL] def generate_tokens ( readline ) : [EOL] [docstring] [EOL] lnum = parenlev = continued = [number] [EOL] namechars , numchars = string . ascii_letters + [string] , [string] [EOL] contstr , needcont = [string] , [number] [EOL] contline = None [EOL] indents = [ [number] ] [EOL] [EOL] while [number] : [comment] [EOL] try : [EOL] line = readline ( ) [EOL] except StopIteration : [EOL] line = [string] [EOL] lnum = lnum + [number] [EOL] pos , max = [number] , len ( line ) [EOL] [EOL] if contstr : [comment] [EOL] if not line : [EOL] raise TokenError ( [string] , strstart ) [EOL] endmatch = endprog . match ( line ) [EOL] if endmatch : [EOL] pos = end = endmatch . end ( [number] ) [EOL] yield ( STRING , contstr + line [ : end ] , strstart , ( lnum , end ) , contline + line ) [EOL] contstr , needcont = [string] , [number] [EOL] contline = None [EOL] elif needcont and line [ - [number] : ] != [string] and line [ - [number] : ] != [string] : [EOL] yield ( ERRORTOKEN , contstr + line , strstart , ( lnum , len ( line ) ) , contline ) [EOL] contstr = [string] [EOL] contline = None [EOL] continue [EOL] else : [EOL] contstr = contstr + line [EOL] contline = contline + line [EOL] continue [EOL] [EOL] elif parenlev == [number] and not continued : [comment] [EOL] if not line : break [EOL] column = [number] [EOL] while pos < max : [comment] [EOL] if line [ pos ] == [string] : column = column + [number] [EOL] elif line [ pos ] == [string] : column = ( column // tabsize + [number] ) * tabsize [EOL] elif line [ pos ] == [string] : column = [number] [EOL] else : break [EOL] pos = pos + [number] [EOL] if pos == max : break [EOL] [EOL] if line [ pos ] in [string] : [comment] [EOL] if line [ pos ] == [string] : [EOL] comment_token = line [ pos : ] . rstrip ( [string] ) [EOL] nl_pos = pos + len ( comment_token ) [EOL] yield ( COMMENT , comment_token , ( lnum , pos ) , ( lnum , pos + len ( comment_token ) ) , line ) [EOL] yield ( NL , line [ nl_pos : ] , ( lnum , nl_pos ) , ( lnum , len ( line ) ) , line ) [EOL] else : [EOL] yield ( ( NL , COMMENT ) [ line [ pos ] == [string] ] , line [ pos : ] , ( lnum , pos ) , ( lnum , len ( line ) ) , line ) [EOL] continue [EOL] [EOL] if column > indents [ - [number] ] : [comment] [EOL] indents . append ( column ) [EOL] yield ( INDENT , line [ : pos ] , ( lnum , [number] ) , ( lnum , pos ) , line ) [EOL] while column < indents [ - [number] ] : [EOL] if column not in indents : [EOL] raise IndentationError ( [string] , ( [string] , lnum , pos , line ) ) [EOL] indents = indents [ : - [number] ] [EOL] yield ( DEDENT , [string] , ( lnum , pos ) , ( lnum , pos ) , line ) [EOL] [EOL] else : [comment] [EOL] if not line : [EOL] raise TokenError ( [string] , ( lnum , [number] ) ) [EOL] continued = [number] [EOL] [EOL] while pos < max : [EOL] pseudomatch = pseudoprog . match ( line , pos ) [EOL] if pseudomatch : [comment] [EOL] start , end = pseudomatch . span ( [number] ) [EOL] spos , epos , pos = ( lnum , start ) , ( lnum , end ) , end [EOL] token , initial = line [ start : end ] , line [ start ] [EOL] [EOL] if initial in numchars or ( initial == [string] and token != [string] ) : [comment] [EOL] yield ( NUMBER , token , spos , epos , line ) [EOL] elif initial in [string] : [EOL] newline = NEWLINE [EOL] if parenlev > [number] : [EOL] newline = NL [EOL] yield ( newline , token , spos , epos , line ) [EOL] elif initial == [string] : [EOL] assert not token . endswith ( [string] ) [EOL] yield ( COMMENT , token , spos , epos , line ) [EOL] elif token in triple_quoted : [EOL] endprog = endprogs [ token ] [EOL] endmatch = endprog . match ( line , pos ) [EOL] if endmatch : [comment] [EOL] pos = endmatch . end ( [number] ) [EOL] token = line [ start : pos ] [EOL] yield ( STRING , token , spos , ( lnum , pos ) , line ) [EOL] else : [EOL] strstart = ( lnum , start ) [comment] [EOL] contstr = line [ start : ] [EOL] contline = line [EOL] break [EOL] elif initial in single_quoted or token [ : [number] ] in single_quoted or token [ : [number] ] in single_quoted : [EOL] if token [ - [number] ] == [string] : [comment] [EOL] strstart = ( lnum , start ) [EOL] endprog = ( endprogs [ initial ] or endprogs [ token [ [number] ] ] or endprogs [ token [ [number] ] ] ) [EOL] contstr , needcont = line [ start : ] , [number] [EOL] contline = line [EOL] break [EOL] else : [comment] [EOL] yield ( STRING , token , spos , epos , line ) [EOL] elif initial in namechars : [comment] [EOL] yield ( NAME , token , spos , epos , line ) [EOL] elif initial == [string] : [comment] [EOL] [comment] [EOL] yield ( NL , token , spos , ( lnum , pos ) , line ) [EOL] continued = [number] [EOL] else : [EOL] if initial in [string] : parenlev = parenlev + [number] [EOL] elif initial in [string] : parenlev = parenlev - [number] [EOL] yield ( OP , token , spos , epos , line ) [EOL] else : [EOL] yield ( ERRORTOKEN , line [ pos ] , ( lnum , pos ) , ( lnum , pos + [number] ) , line ) [EOL] pos = pos + [number] [EOL] [EOL] for indent in indents [ [number] : ] : [comment] [EOL] yield ( DEDENT , [string] , ( lnum , [number] ) , ( lnum , [number] ) , [string] ) [EOL] yield ( ENDMARKER , [string] , ( lnum , [number] ) , ( lnum , [number] ) , [string] ) [EOL] [EOL] if __name__ == [string] : [comment] [EOL] import sys [EOL] if len ( sys . argv ) > [number] : tokenize ( open ( sys . argv [ [number] ] ) . readline ) [EOL] else : tokenize ( sys . stdin . readline ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] ENDMARKER = [number] [EOL] NAME = [number] [EOL] NUMBER = [number] [EOL] STRING = [number] [EOL] NEWLINE = [number] [EOL] INDENT = [number] [EOL] DEDENT = [number] [EOL] LPAR = [number] [EOL] RPAR = [number] [EOL] LSQB = [number] [EOL] RSQB = [number] [EOL] COLON = [number] [EOL] COMMA = [number] [EOL] SEMI = [number] [EOL] PLUS = [number] [EOL] MINUS = [number] [EOL] STAR = [number] [EOL] SLASH = [number] [EOL] VBAR = [number] [EOL] AMPER = [number] [EOL] LESS = [number] [EOL] GREATER = [number] [EOL] EQUAL = [number] [EOL] DOT = [number] [EOL] PERCENT = [number] [EOL] BACKQUOTE = [number] [EOL] LBRACE = [number] [EOL] RBRACE = [number] [EOL] EQEQUAL = [number] [EOL] NOTEQUAL = [number] [EOL] LESSEQUAL = [number] [EOL] GREATEREQUAL = [number] [EOL] TILDE = [number] [EOL] CIRCUMFLEX = [number] [EOL] LEFTSHIFT = [number] [EOL] RIGHTSHIFT = [number] [EOL] DOUBLESTAR = [number] [EOL] PLUSEQUAL = [number] [EOL] MINEQUAL = [number] [EOL] STAREQUAL = [number] [EOL] SLASHEQUAL = [number] [EOL] PERCENTEQUAL = [number] [EOL] AMPEREQUAL = [number] [EOL] VBAREQUAL = [number] [EOL] CIRCUMFLEXEQUAL = [number] [EOL] LEFTSHIFTEQUAL = [number] [EOL] RIGHTSHIFTEQUAL = [number] [EOL] DOUBLESTAREQUAL = [number] [EOL] DOUBLESLASH = [number] [EOL] DOUBLESLASHEQUAL = [number] [EOL] AT = [number] [EOL] OP = [number] [EOL] COMMENT = [number] [EOL] NL = [number] [EOL] RARROW = [number] [EOL] ERRORTOKEN = [number] [EOL] N_TOKENS = [number] [EOL] NT_OFFSET = [number] [EOL] [comment] [EOL] [EOL] tok_name = { } [EOL] for _name , _value in list ( globals ( ) . items ( ) ) : [EOL] if type ( _value ) is type ( [number] ) : [EOL] tok_name [ _value ] = _name [EOL] [EOL] [EOL] def ISTERMINAL ( x ) : [EOL] return x < NT_OFFSET [EOL] [EOL] def ISNONTERMINAL ( x ) : [EOL] return x >= NT_OFFSET [EOL] [EOL] def ISEOF ( x ) : [EOL] return x == ENDMARKER [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Dict , Optional , Any [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import re [EOL] [EOL] [comment] [EOL] from pgen2 import grammar , token [EOL] [EOL] [EOL] class Converter ( grammar . Grammar ) : [EOL] [docstring] [EOL] [EOL] def run ( self , graminit_h , graminit_c ) : [EOL] [docstring] [EOL] self . parse_graminit_h ( graminit_h ) [EOL] self . parse_graminit_c ( graminit_c ) [EOL] self . finish_off ( ) [EOL] [EOL] def parse_graminit_h ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] f = open ( filename ) [EOL] except IOError as err : [EOL] print ( [string] % ( filename , err ) ) [EOL] return False [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] lineno = [number] [EOL] for line in f : [EOL] lineno += [number] [EOL] mo = re . match ( [string] , line ) [EOL] if not mo and line . strip ( ) : [EOL] print ( [string] % ( filename , lineno , line . strip ( ) ) ) [EOL] else : [EOL] symbol , number = mo . groups ( ) [EOL] number = int ( number ) [EOL] assert symbol not in self . symbol2number [EOL] assert number not in self . number2symbol [EOL] self . symbol2number [ symbol ] = number [EOL] self . number2symbol [ number ] = symbol [EOL] return True [EOL] [EOL] def parse_graminit_c ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] f = open ( filename ) [EOL] except IOError as err : [EOL] print ( [string] % ( filename , err ) ) [EOL] return False [EOL] [comment] [EOL] lineno = [number] [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] allarcs = { } [EOL] states = [ ] [EOL] while line . startswith ( [string] ) : [EOL] while line . startswith ( [string] ) : [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] n , m , k = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs = [ ] [EOL] for _ in range ( k ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] i , j = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs . append ( ( i , j ) ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] allarcs [ ( n , m ) ] = arcs [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] s , t = list ( map ( int , mo . groups ( ) ) ) [EOL] assert s == len ( states ) , ( lineno , line ) [EOL] state = [ ] [EOL] for _ in range ( t ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] k , n , m = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs = allarcs [ n , m ] [EOL] assert k == len ( arcs ) , ( lineno , line ) [EOL] state . append ( arcs ) [EOL] states . append ( state ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] self . states = states [EOL] [EOL] [comment] [EOL] dfas = { } [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] ndfas = int ( mo . group ( [number] ) ) [EOL] for i in range ( ndfas ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] symbol = mo . group ( [number] ) [EOL] number , x , y , z = list ( map ( int , mo . group ( [number] , [number] , [number] , [number] ) ) ) [EOL] assert self . symbol2number [ symbol ] == number , ( lineno , line ) [EOL] assert self . number2symbol [ number ] == symbol , ( lineno , line ) [EOL] assert x == [number] , ( lineno , line ) [EOL] state = states [ z ] [EOL] assert y == len ( state ) , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] first = { } [EOL] rawbitset = eval ( mo . group ( [number] ) ) [EOL] for i , c in enumerate ( rawbitset ) : [EOL] byte = ord ( c ) [EOL] for j in range ( [number] ) : [EOL] if byte & ( [number] << j ) : [EOL] first [ i * [number] + j ] = [number] [EOL] dfas [ number ] = ( state , first ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] self . dfas = dfas [EOL] [EOL] [comment] [EOL] labels = [ ] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] nlabels = int ( mo . group ( [number] ) ) [EOL] for i in range ( nlabels ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] x , y = mo . groups ( ) [EOL] x = int ( x ) [EOL] if y == [string] : [EOL] y = None [EOL] else : [EOL] y = eval ( y ) [EOL] labels . append ( ( x , y ) ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] self . labels = labels [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] ndfas = int ( mo . group ( [number] ) ) [EOL] assert ndfas == len ( self . dfas ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] nlabels = int ( mo . group ( [number] ) ) [EOL] assert nlabels == len ( self . labels ) , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] start = int ( mo . group ( [number] ) ) [EOL] assert start in self . number2symbol , ( lineno , line ) [EOL] self . start = start [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] try : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] except StopIteration : [EOL] pass [EOL] else : [EOL] assert [number] , ( lineno , line ) [EOL] [EOL] def finish_off ( self ) : [EOL] [docstring] [EOL] self . keywords = { } [comment] [EOL] self . tokens = { } [comment] [EOL] for ilabel , ( type , value ) in enumerate ( self . labels ) : [EOL] if type == token . NAME and value is not None : [EOL] self . keywords [ value ] = ilabel [EOL] elif value is None : [EOL] self . tokens [ type ] = ilabel [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] simple_escapes = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] def escape ( m ) : [EOL] all , tail = m . group ( [number] , [number] ) [EOL] assert all . startswith ( [string] ) [EOL] esc = simple_escapes . get ( tail ) [EOL] if esc is not None : [EOL] return esc [EOL] if tail . startswith ( [string] ) : [EOL] hexes = tail [ [number] : ] [EOL] if len ( hexes ) < [number] : [EOL] raise ValueError ( [string] % tail ) [EOL] try : [EOL] i = int ( hexes , [number] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % tail ) [EOL] else : [EOL] try : [EOL] i = int ( tail , [number] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % tail ) [EOL] return chr ( i ) [EOL] [EOL] def evalString ( s ) : [EOL] assert s . startswith ( [string] ) or s . startswith ( [string] ) , repr ( s [ : [number] ] ) [EOL] q = s [ [number] ] [EOL] if s [ : [number] ] == q * [number] : [EOL] q = q * [number] [EOL] assert s . endswith ( q ) , repr ( s [ - len ( q ) : ] ) [EOL] assert len ( s ) >= [number] * len ( q ) [EOL] s = s [ len ( q ) : - len ( q ) ] [EOL] return re . sub ( [string] , escape , s ) [EOL] [EOL] def test ( ) : [EOL] for i in range ( [number] ) : [EOL] c = chr ( i ) [EOL] s = repr ( c ) [EOL] e = evalString ( s ) [EOL] if e != c : [EOL] print ( i , c , s , e ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
import python高级2 [EOL] class MusicPlayer ( object ) : [EOL] def __new__ ( cls , * a , ** b ) : [EOL] [EOL] print ( [string] ) [EOL] [comment] [EOL] return super ( ) . __new__ ( cls ) [EOL] [EOL] def __init__ ( self ) : [EOL] print ( [string] ) [EOL] [EOL] a = MusicPlayer ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级2.new方法.MusicPlayer$ 0 0 0 0 0
import python高级2 [EOL] class Game ( object ) : [EOL] [comment] [EOL] top_score = [number] [EOL] [comment] [EOL] @ staticmethod def show_help ( ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] @ classmethod def show_top_score ( cls ) : [EOL] print ( [string] + str ( cls . top_score ) ) [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . player_name = name [EOL] [EOL] def star_game ( self ) : [EOL] print ( [string] ) [EOL] [EOL] xiao_xiao = Game ( [string] ) [EOL] [EOL] Game . show_top_score ( ) [EOL] Game . show_help ( )	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级2.类方法.py.gameB.Game$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] num = int ( input ( [string] ) ) [EOL] result = [number] / num [EOL] print ( result ) [EOL] except ValueError : [EOL] print ( [string] ) [EOL] except ZeroDivisionError : [EOL] print ( [string] ) [EOL]	0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def input_password ( ) : [EOL] pwd = input ( [string] ) [EOL] [EOL] if len ( pwd ) >= [number] : [EOL] return pwd [EOL] [EOL] ex = Exception ( [string] ) [EOL] raise ex [EOL] [EOL] try : [EOL] user_pwd = input_password ( ) [EOL] print ( user_pwd ) [EOL] [EOL] except Exception as result : [EOL] print ( [string] % result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import lianxi2 as apple	0 0 0 0
def apple ( ) : [EOL] print ( [string] ) [EOL] [EOL] apple ( ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import python高级2 [EOL] class Animal ( object ) : [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] def Game ( self ) : [EOL] print ( [string] % self . name ) [EOL] [EOL] class tiger ( Animal ) : [EOL] [EOL] def Game ( self ) : [EOL] print ( [string] % self . name ) [EOL] [EOL] class cat ( object ) : [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] def Game_cat ( self , z ) : [EOL] print ( [string] % ( self . name , z . name ) ) [EOL] [EOL] boluo = Animal ( [string] ) [EOL] boluo . Game ( ) [EOL] lizhi = cat ( [string] ) [EOL] lizhi . Game_cat ( boluo ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级2.多态.py.练习F.Animal$ 0 0 0 0 0 0 $python高级2.多态.py.练习F.Animal$ 0 0 0 0 0 $python高级2.多态.py.练习F.cat$ 0 0 0 0 0 0 $python高级2.多态.py.练习F.cat$ 0 0 0 $python高级2.多态.py.练习F.Animal$ 0 0
[comment] [EOL] import 练习 [EOL] class Cat : [EOL] def __init__ ( self , new_name ) : [EOL] self . name = new_name [EOL] print ( [string] % self . name ) [EOL] [EOL] def __del__ ( self ) : [EOL] print ( [string] % self . name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . name [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] tom = Cat ( [string] ) [EOL] print ( tom )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
for i in range ( [number] , [number] ) : [EOL] k = [number] [EOL] for a in range ( [number] , i ) : [EOL] if i % a == [number] : [EOL] k += [number] [EOL] if k == [number] : [EOL] print ( i ) [EOL] [EOL] [EOL] [EOL] [EOL] count = [number] [EOL] while count <= [number] : [EOL] kongge = [number] [EOL] while kongge < [number] - count : [EOL] print ( end = [string] ) [EOL] kongge += [number] [EOL] [EOL] star = [number] [EOL] while star < count : [EOL] print ( [string] , end = [string] ) [EOL] star += [number] [EOL] print ( [string] ) [EOL] count += [number]	0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Type [EOL] import typing [EOL] import 练习 [EOL] class MusicPlayer ( object ) : [EOL] [EOL] ice = None [EOL] def __new__ ( cls ) : [EOL] if cls . ice is None : [EOL] cls . ice = super ( ) . __new__ ( cls ) [EOL] return cls . ice [EOL] [EOL] def __init__ ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] V = MusicPlayer ( ) [EOL] V1 = MusicPlayer ( ) [EOL] print ( V ) [EOL] print ( V1 )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import 练习 [EOL] class Person ( object ) : [EOL] [EOL] def __init__ ( self , name , weight ) : [EOL] self . name = name [EOL] self . weight = weight [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . name , self . weight ) [EOL] [EOL] def run ( self ) : [EOL] print ( [string] % str ( self . name ) ) [EOL] self . weight -= [number] [EOL] [EOL] def eat ( self ) : [EOL] print ( [string] % str ( self . name ) ) [EOL] self . weight += [number] [EOL] [EOL] [EOL] xiaoming = Person ( [string] , [number] ) [EOL] xiaoming . run ( ) [EOL] xiaoming . eat ( ) [EOL] [EOL] print ( xiaoming )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] print ( [string] ) [EOL] [EOL] [EOL] frist_name = [string] [EOL] last_name = [string] [EOL] full_name = frist_name + last_name [EOL] print ( full_name ) [EOL] print ( [string] ) [EOL] [EOL] heroes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] print ( heroes ) [EOL] [EOL] print ( heroes [ [number] ] ) [EOL] print ( heroes [ [number] ] ) [EOL] [EOL] heroes . append ( [string] ) [EOL] [EOL] heroes . insert ( [number] , [string] ) [EOL] [EOL] [EOL] del heroes [ [number] ] [EOL] [EOL] [EOL] tail = heroes . pop ( ) [EOL] print ( heroes ) [EOL] print ( tail ) [EOL] [EOL] heroes . remove ( [string] ) [EOL] [EOL] [EOL] heroes = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] heroes . sort ( ) [EOL] print ( heroes ) [EOL] [EOL] heroes . sort ( reverse = True ) [EOL] print ( heroes ) [EOL] [EOL] [comment] [EOL] heroes . reverse ( ) [EOL] print ( heroes ) [EOL] [EOL] for hero in heroes : [EOL] if hero == [string] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import python高级 [EOL] class Dog ( object ) : [EOL] [comment] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] def game ( self ) : [EOL] print ( self . name + [string] ) [EOL] [EOL] class XiaoTianDog ( Dog ) : [EOL] [EOL] def game ( self ) : [EOL] print ( self . name + [string] ) [EOL] [EOL] class Person ( object ) : [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] def game_with_dog ( self , dog ) : [EOL] print ( [string] % ( self . name , dog . name ) ) [EOL] [EOL] [docstring] [EOL] feitianwancai = XiaoTianDog ( [string] ) [EOL] [EOL] xiaoming = Person ( [string] ) [EOL] [docstring] [EOL] xiaoming . game_with_dog ( feitianwancai ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级.多态.XiaoTianDog$ 0 0 0 0 0 0 0 $python高级.多态.Person$ 0 0 0 0 0 0 0 0 $python高级.多态.Person$ 0 0 0 $python高级.多态.XiaoTianDog$ 0 0 0
import python高级 [EOL] class Car ( object ) : [EOL] [comment] [EOL] count = [number] [EOL] [comment] [EOL] @ classmethod def move ( cls ) : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] @ staticmethod def benpao ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def __init__ ( self ) : [EOL] self . color = [string] [EOL] [EOL] Car . benpao ( ) [EOL] [EOL] a = Car ( ) [EOL] a . benpao ( ) [EOL] [EOL] [EOL] Car . move ( ) [EOL] [EOL] print ( Car . count ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $python高级.类方法.Car$ 0 0 0 0 0 $python高级.类方法.Car$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import python高级 [EOL] class Person ( object ) : [EOL] [EOL] def __init__ ( self , eye ) : [EOL] self . eye = eye [EOL] [EOL] def walk ( self ) : [EOL] print ( [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] duan_jin_song = Person ( [string] ) [EOL] duan_jin_song . walk [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级.类.Person$ 0 0 0 0 0 0 $python高级.类.Person$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import List [EOL] import io [EOL] import typing [EOL] f = open ( [string] , [string] ) [EOL] [EOL] [EOL] f . close ( ) [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] f = open ( [string] , [string] ) [EOL] [EOL] f . write ( [string] ) [comment] [EOL] f . close ( ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] f = open ( [string] , [string] ) [EOL] content = f . read ( ) [EOL] [EOL] content = f . readlines ( ) [EOL] print ( type ( content ) ) [EOL] [EOL] [EOL] print ( content ) [EOL] f . close ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0
import os [EOL] os . mkdir ( [string] ) [comment] [EOL] [EOL] os . getcwd ( ) [comment] [EOL] [EOL] os . chdir ( [string] ) [comment] [EOL] [EOL] os . listdir ( [string] ) [comment] [EOL] [EOL] os . rmdir ( [string] ) [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import python高级 [EOL] class Car : [EOL] def __init__ ( self , mewname ) : [EOL] self . name = mewname [EOL] self . price = [string] [EOL] [EOL] def move ( self ) : [EOL] print ( self . name , [string] ) [EOL] def toot ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] red_car = Car ( [string] ) [EOL] red_car . move ( ) [EOL] red_car . color = [string] [EOL] [EOL] print ( id ( red_car ) , red_car . color ) [EOL] [EOL] [EOL] blue_car = Car ( [string] ) [EOL] blue_car . toot ( ) [EOL] blue_car . color = [string] [EOL] [EOL] print ( id ( blue_car ) , blue_car . color ) [EOL] [EOL] [EOL] yellow_car = Car ( [string] ) [EOL] yellow_car . move ( ) [EOL] yellow_car . toot ( ) [EOL] [EOL] yellow_car . color = [string] [EOL] [EOL] print ( id ( yellow_car ) , yellow_car . color ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 0 0 0 0 0 0 0 0 $python高级.面向对象.Car$ 0 0 $python高级.面向对象.Car$ 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Type [EOL] import io [EOL] import typing [EOL] f = open ( [string] , [string] ) [EOL] str = f . read ( ) [EOL] print ( str ) [comment] [EOL] [EOL] [EOL] [comment] [EOL] position = f . tell ( ) [EOL] print ( position ) [comment] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] f . seek ( [number] , [number] ) [EOL] [EOL] f . close ( ) [EOL] [EOL] [EOL] [EOL] import os [EOL] os . rename ( ) [comment] [EOL] [EOL] os . remove ( ) [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import python高级 [EOL] class SweetPotato ( ) : [EOL] def __init__ ( self ) : [EOL] self . cookedString = ( [string] ) [EOL] self . cookedLevel = [number] [EOL] self . Condmenets = [ ] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . cookedString , self . cookedLevel , str ( self . Condmenets ) ) [EOL] [EOL] def cook ( self , cooked_time ) : [EOL] self . cookedLevel = cooked_time [EOL] if cooked_time >= [number] and cooked_time < [number] : [EOL] self . cookedString ( [string] ) [EOL] elif cooked_time >= [number] and cooked_time < [number] : [EOL] self . cookedString ( [string] ) [EOL] elif cook_time >= [number] and cook_time < [number] : [EOL] self . cookedString ( [string] ) [EOL] elif cooked_time > [number] : [EOL] self . cookedString ( [string] ) [EOL] [EOL] def addCondmenets ( self , item ) : [EOL] self . Condmenets . append ( item ) [EOL] [EOL] [EOL] [comment] [EOL] di_gua = SweetPotato ( ) [EOL] print ( di_gua ) [EOL] [comment] [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL] di_gua . addCondmenets ( [string] ) [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL] di_gua . addCondmenets ( [string] ) [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL] di_gua . addCondmenets ( [string] ) [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL] di_gua . addCondmenets ( [string] ) [EOL] [EOL] [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL] di_gua . cook ( [number] ) [EOL] print ( di_gua ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0 0 0 0 0 0 0 $python高级.烤地瓜.烤地瓜2.SweetPotato$ 0 0
from typing import Any [EOL] import typing [EOL] import pygame [EOL] [EOL] pygame . init ( ) [comment] [EOL] [EOL] [comment] [EOL] screen = pygame . display . set_mode ( ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] bg = pygame . image . load ( [string] ) [EOL] [EOL] [comment] [EOL] hero_rect = pygame . Rect ( [number] , [number] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] screen . blit ( bg , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] hero = pygame . image . load ( [string] ) [EOL] [comment] [EOL] screen . blit ( hero , hero_rect ) [EOL] [comment] [EOL] pygame . display . update ( ) [EOL] [EOL] clock = pygame . time . Clock ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] i = [number] [EOL] y = [number] [EOL] [EOL] hero_rect = pygame . Rect ( [number] , y , [number] , [number] ) [EOL] [EOL] while True : [EOL] i += [number] [EOL] hero_rect . y -= [number] [EOL] [comment] [EOL] [comment] [EOL] if hero_rect . y + hero_rect . height <= [number] : [EOL] hero_rect . y = [number] [EOL] [EOL] screen . blit ( bg , ( [number] , [number] ) ) [EOL] screen . blit ( hero , hero_rect ) [EOL] pygame . display . update ( ) [EOL] clock . tick ( [number] ) [EOL] [EOL] [comment] [EOL] for event in pygame . event . get ( ) : [EOL] if event . type == pygame . QUIT : [EOL] print ( [string] ) [EOL] pygame . quit ( ) [EOL] exit ( ) [EOL] [EOL] [docstring] [EOL] [EOL] pygame . quit ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aircraft [EOL] import pygame [EOL] import random [EOL] [EOL] [comment] [EOL] SCREEN_RECT = pygame . Rect ( [number] , [number] , [number] , [number] ) [EOL] [comment] [EOL] CREATE_ENEMT_EVENT = pygame . USEREVENT [EOL] [comment] [EOL] HERO_FIRE_EVENT = pygame . USEREVENT + [number] [EOL] [EOL] [EOL] class GameSprite ( pygame . sprite . Sprite ) : [EOL] [docstring] [EOL] def __init__ ( self , image_name , speed = [number] ) : [EOL] [comment] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] self . image = pygame . image . load ( image_name ) [EOL] [comment] [EOL] self . rect = self . image . get_rect ( ) [EOL] [comment] [EOL] self . speed = speed [EOL] [EOL] def update ( self ) : [EOL] [comment] [EOL] self . rect . y += self . speed [EOL] [EOL] class BackGround ( GameSprite ) : [EOL] [docstring] [EOL] def __init__ ( self , is_alt = False ) : [EOL] [EOL] image_name = [string] [EOL] super ( ) . __init__ ( image_name ) [EOL] [comment] [EOL] if is_alt : [EOL] self . rect . y = - self . rect . height [EOL] [EOL] [EOL] def update ( self ) : [EOL] [comment] [EOL] super ( ) . update ( ) [EOL] [comment] [EOL] if self . rect . y >= SCREEN_RECT . height : [EOL] self . rect . y = - self . rect . height [EOL] [EOL] class Enemy ( GameSprite ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] super ( ) . __init__ ( [string] ) [EOL] [EOL] [comment] [EOL] self . speed = random . randint ( [number] , [number] ) [EOL] [comment] [EOL] self . rect . bottom = [number] [EOL] man_x = SCREEN_RECT . width - self . rect . width [EOL] self . rect . x = random . randint ( [number] , man_x ) [EOL] [EOL] def update ( self ) : [EOL] [comment] [EOL] super ( ) . update ( ) [EOL] [comment] [EOL] if self . rect . y >= SCREEN_RECT . height : [EOL] print ( [string] ) [EOL] [comment] [EOL] self . kill ( ) [EOL] [EOL] class Hero ( GameSprite ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] super ( ) . __init__ ( [string] , [number] ) [EOL] [comment] [EOL] self . rect . centerx = SCREEN_RECT . centerx [EOL] [comment] [EOL] self . rect . bottom = SCREEN_RECT . bottom - [number] [EOL] [EOL] self . bullets = pygame . sprite . Group ( ) [EOL] [EOL] def update ( self ) : [EOL] [comment] [EOL] self . rect . x += self . speed [EOL] [comment] [EOL] if self . rect . left <= [number] : [EOL] self . rect . left = [number] [EOL] if self . rect . right >= SCREEN_RECT . right : [EOL] self . rect . right = SCREEN_RECT . right [EOL] [EOL] [EOL] def fire ( self ) : [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] for i in ( [number] , [number] , [number] ) : [EOL] [comment] [EOL] bullet = Bullet ( ) [EOL] [comment] [EOL] bullet . rect . bottom = self . rect . y - [number] * i [EOL] bullet . rect . centerx = self . rect . centerx [EOL] [comment] [EOL] self . bullets . add ( bullet ) [EOL] [EOL] [EOL] class Bullet ( GameSprite ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] , - [number] ) [EOL] [EOL] def update ( self ) : [EOL] super ( ) . update ( ) [EOL] [comment] [EOL] if self . rect . bottom < [number] : [EOL] self . kill ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aircraft.py.plane_sprites.Bullet$ 0 0 0 0 0 0 0 $aircraft.py.plane_sprites.Bullet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aircraft.py.plane_sprites.Bullet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aircraft.py.plane_sprites.Bullet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0