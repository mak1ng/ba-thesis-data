[comment] [EOL] from typing import Optional , Match [EOL] import typing [EOL] import re [EOL] [EOL] from setuptools import setup [EOL] from setuptools_rust import Binding [EOL] from setuptools_rust import RustExtension [EOL] from setuptools_rust import Strip [EOL] [EOL] [EOL] version = [string] [EOL] with open ( [string] ) as f : [EOL] for line in f . readlines ( ) : [EOL] match = re . match ( [string] , line ) [EOL] if match : [EOL] version = match . group ( [string] ) [EOL] break [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] setup ( name = [string] , packages = [ [string] ] , version = version , setup_requires = [ [string] ] , rust_extensions = [ RustExtension ( target = [string] , path = [string] , binding = Binding . PyO3 , strip = Strip . All , features = [ [string] ] , ) , ] , package_data = { [string] : [ [string] ] , } , install_requires = [ [string] , ] , extras_require = { [string] : [ [string] ] , } , package_dir = { [string] : [string] } , zip_safe = False , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] [docstring] [EOL] from os . path import abspath [EOL] from os . path import join [EOL] [EOL] from six . moves . urllib . parse import urljoin [EOL] from rust_swagger_validator import _rust_module [EOL] from rust_swagger_validator . _rust_module import RustSwaggerSpec as SwaggerSpec [EOL] [EOL] print ( _rust_module . __build__ ) [EOL] print ( _rust_module . convert_string ( [number] ) ) [EOL] print ( _rust_module . no_parameters ( ) ) [EOL] print ( _rust_module . __dict__ ) [EOL] [EOL] spec_url = urljoin ( [string] , abspath ( join ( [string] , [string] , [string] ) ) ) [EOL] print ( SwaggerSpec . from_url ( spec_url ) . uri ) [EOL] print ( SwaggerSpec . from_url ( spec_url , False ) . uri ) [EOL] try : [EOL] print ( SwaggerSpec . from_url ( [string] ) . uri ) [EOL] except Exception as exception : [comment] [EOL] print ( [string] . format ( exception ) ) [EOL] try : [EOL] print ( SwaggerSpec . from_url ( [string] , True ) . uri ) [EOL] except Exception as exception : [comment] [EOL] print ( [string] . format ( exception ) ) [EOL] swagger_spec = SwaggerSpec . from_url ( spec_url , False ) [EOL] print ( type ( swagger_spec ) ) [EOL] print ( isinstance ( swagger_spec , SwaggerSpec ) ) [EOL] print ( type ( swagger_spec ) . __bases__ ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] __version__ = [string] [EOL] [EOL] try : [EOL] from rust_swagger_validator . _rust_module import __build__ [comment] [EOL] except ImportError : [comment] [EOL] from _rust_module import __build__ [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] [EOL] def test_is_module_importable ( ) : [EOL] import rust_swagger_validator [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Optional , Any , Tuple [EOL] import typing [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] import subprocess [EOL] import sys [EOL] from contextlib import contextmanager [EOL] from os import environ [EOL] from os . path import expanduser [EOL] from os . path import join [EOL] from os . path import pathsep [EOL] [EOL] from pkg_resources import parse_version [EOL] [EOL] [EOL] @ contextmanager def add_to_path ( * segments ) : [EOL] old_path = environ . get ( [string] ) [EOL] if old_path : [EOL] segments = list ( segments ) + [ old_path ] [EOL] environ [ [string] ] = pathsep . join ( segments ) [EOL] yield [EOL] environ [ [string] ] = old_path [EOL] [EOL] [EOL] [comment] [EOL] MIN_VERSION = [string] [EOL] MIN_DATE = [string] [EOL] [EOL] [EOL] def run_command ( command ) : [EOL] print ( [string] . format ( command = command ) , file = sys . stderr ) [EOL] return_code , output = None , None [EOL] with add_to_path ( join ( expanduser ( [string] ) , [string] , [string] ) ) : [EOL] try : [EOL] return_code , output = [number] , subprocess . check_output ( command , stderr = subprocess . STDOUT , shell = True , ) . decode ( [string] ) [EOL] except subprocess . CalledProcessError as e : [EOL] return_code , output = e . returncode , e . output . decode ( [string] ) [EOL] print ( [string] . format ( return_code = return_code , output = output ) , file = sys . stderr ) [EOL] return return_code , output [EOL] [EOL] [EOL] def check_rustc_version ( ) : [EOL] return_code , rustc_version_output = run_command ( [string] ) [EOL] assert return_code == [number] , [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] rustc_version = parse_version ( [ line . replace ( [string] , [string] ) for line in rustc_version_output . splitlines ( ) if line . startswith ( [string] ) ] [ [number] ] ) [EOL] [EOL] rustc_date = [ line . replace ( [string] , [string] ) for line in rustc_version_output . splitlines ( ) if line . startswith ( [string] ) ] [ [number] ] [EOL] [EOL] assert parse_version ( MIN_VERSION ) <= rustc_version and MIN_DATE <= rustc_date , [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] check_rustc_version ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0