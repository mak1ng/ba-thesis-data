from typing import Optional [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import datetime [EOL] import logging [EOL] import sys [EOL] from typing import Optional [EOL] [EOL] import click [EOL] [EOL] from scraping . CustomExceptions import PasswordFileNotFound , LoginError [EOL] from scraping . cli import Cli [EOL] from . import dash_app [EOL] from . scraper import Scraper [EOL] [EOL] [EOL] @ click . group ( ) def main ( ) : [EOL] [docstring] [EOL] setup_logger ( ) [EOL] [EOL] [EOL] @ main . command ( ) def cli ( ) : [EOL] [docstring] [EOL] Cli ( ) [EOL] [EOL] [EOL] @ main . command ( ) def dash ( ) : [EOL] [docstring] [EOL] dash_app . main ( ) [EOL] [EOL] [EOL] [comment] [EOL] @ main . command ( ) @ click . option ( [string] , required = True , help = [string] ) @ click . option ( [string] , required = False , default = None , help = [string] ) @ click . option ( [string] , required = False , default = False , help = [string] ) @ click . option ( [string] , default = [number] , help = [string] ) @ click . option ( [string] , default = datetime . datetime . now ( ) . year , help = [string] ) @ click . option ( [string] , default = True , help = [string] ) def scrape ( email , password , headless , start , end , extensive ) : [EOL] [docstring] [EOL] try : [EOL] Scraper ( email , password , bool ( headless ) , start , end , extensive ) [EOL] except ( PasswordFileNotFound , LoginError ) : [EOL] exit ( [number] ) [EOL] [EOL] [EOL] def setup_logger ( ) : [EOL] [docstring] [EOL] [EOL] handler = logging . FileHandler ( filename = [string] , mode = [string] ) [EOL] formatter = logging . Formatter ( [string] ) [EOL] handler . setFormatter ( formatter ) [EOL] [EOL] [comment] [EOL] root_logger = logging . getLogger ( [string] ) [EOL] root_logger . handlers . clear ( ) [EOL] root_logger . addHandler ( handler ) [EOL] root_logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class PasswordFileNotFound ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class LoginError ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class OrdersNotFound ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import scraping [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] from __future__ import annotations [EOL] [EOL] import datetime [EOL] from dataclasses import dataclass [EOL] from typing import List , Dict [EOL] [EOL] import dateutil . parser [EOL] [EOL] from . import utils [EOL] [EOL] [EOL] @ dataclass class Item : [EOL] [docstring] [EOL] price = ... [EOL] link = ... [EOL] title = ... [EOL] seller = ... [EOL] [comment] [EOL] category = ... [EOL] [EOL] def to_dict ( self ) : [EOL] [docstring] [EOL] return self . __dict__ [EOL] [EOL] @ staticmethod def from_dict ( item_dict ) : [EOL] [docstring] [EOL] category = { int ( cat [ [number] ] ) : cat [ [number] ] for cat in item_dict [ [string] ] . items ( ) } [EOL] return Item ( item_dict [ [string] ] , item_dict [ [string] ] , item_dict [ [string] ] , item_dict [ [string] ] , category ) [EOL] [EOL] [EOL] @ dataclass class Order : [EOL] [docstring] [EOL] order_id = ... [EOL] price = ... [comment] [EOL] [comment] [EOL] date = ... [EOL] items = ... [EOL] [EOL] def is_equal ( self , order ) : [EOL] [docstring] [EOL] return order . order_id == self . order_id [EOL] [EOL] def to_dict ( self ) : [EOL] [docstring] [EOL] attr_dict = self . __dict__ [EOL] attr_dict [ [string] ] = [ item . to_dict ( ) for item in self . items ] [EOL] attr_dict [ [string] ] = utils . serialize_date ( self . date ) [EOL] return attr_dict [EOL] [EOL] @ staticmethod def from_dict ( order_dict ) : [EOL] [docstring] [EOL] order_id = order_dict [ [string] ] [EOL] price = float ( order_dict [ [string] ] ) [EOL] date = dateutil . parser . parse ( order_dict [ [string] ] ) . date ( ) [EOL] items = [ Item . from_dict ( item ) for item in order_dict [ [string] ] ] [EOL] return Order ( order_id , price , date , items ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Item'$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 $typing.List[Item]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $Order$ 0 0 0 0 0 0 $Order$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $Order$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 $builtins.float$ 0 0 0 $typing.Dict$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $datetime.date$ 0 0 0 $typing.List[scraping.data.Item]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 $datetime.date$ 0 $typing.List[scraping.data.Item]$ 0 0
from typing import Union , Tuple , Callable , List , Dict , Any , Optional [EOL] import datetime [EOL] import scraping [EOL] import typing [EOL] import selenium [EOL] import data [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import datetime [EOL] import json [EOL] import logging [EOL] from typing import List , Tuple , Optional , Dict , Callable [EOL] [EOL] from selenium . common . exceptions import NoSuchElementException [EOL] from selenium . webdriver import Firefox , FirefoxProfile [EOL] from selenium . webdriver . firefox . options import Options [EOL] from selenium . webdriver . firefox . webdriver import WebDriver [EOL] from selenium . webdriver . remote . webelement import WebElement [EOL] from termcolor import colored [EOL] [EOL] from scraping . CustomExceptions import PasswordFileNotFound , LoginError [EOL] from . import file_handler [EOL] from . data import Order , Item [EOL] from . import utils as ut [EOL] [EOL] FILE_NAME = [string] [EOL] [EOL] [EOL] class Scraper : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , email , password , headless , start , end , extensive , progress_observer_callback = None ) : [EOL] assert email , [string] [EOL] assert [string] in email and [string] in email , [string] [comment] [EOL] assert start <= end , [string] [EOL] assert end >= [number] , [string] [EOL] assert end <= datetime . datetime . now ( ) . year , [string] [EOL] [EOL] self . logger = logging . getLogger ( __name__ ) [EOL] self . progress_observer_callback = progress_observer_callback [EOL] [EOL] self . email = email [EOL] self . password = password if password else file_handler . load_password ( ) [EOL] if not self . password : [EOL] self . logger . error ( colored ( [string] , [string] ) ) [EOL] raise PasswordFileNotFound [EOL] [EOL] self . start_date = datetime . date ( year = start , month = [number] , day = [number] ) [EOL] self . end_date = datetime . datetime . now ( ) . date ( ) if end == datetime . datetime . now ( ) . year \ [EOL] else datetime . date ( year = end , month = [number] , day = [number] ) [EOL] self . start_scraping_date = datetime . date ( year = start , month = [number] , day = [number] ) [EOL] [EOL] self . headless = headless [EOL] self . extensive = extensive [EOL] [EOL] self . orders = [ ] [EOL] self . browser = ... [EOL] [EOL] self . _setup_scraping ( ) [EOL] self . _get_orders ( ) [EOL] [EOL] file_handler . save_file ( FILE_NAME , json . dumps ( [ order . to_dict ( ) for order in self . orders ] ) ) [EOL] self . browser . quit ( ) [EOL] [EOL] def _notify_progress_observers ( self , progress ) : [EOL] if self . progress_observer_callback : [EOL] self . progress_observer_callback ( progress ) [EOL] [EOL] def _setup_scraping ( self ) : [EOL] [docstring] [EOL] firefox_profile = FirefoxProfile ( ) [EOL] firefox_profile . set_preference ( [string] , False ) [EOL] firefox_profile . set_preference ( [string] , False ) [EOL] firefox_profile . set_preference ( [string] , False ) [EOL] opts = Options ( ) [EOL] opts . headless = self . headless [EOL] if opts . headless : [EOL] self . logger . info ( colored ( [string] , [string] ) ) [EOL] self . browser = Firefox ( options = opts , firefox_profile = firefox_profile ) [EOL] self . _navigate_to_orders_page ( ) [EOL] self . _complete_sign_in_form ( ) [EOL] if not self . _signed_in_successful ( ) : [EOL] self . logger . error ( colored ( [string] , [string] ) ) [EOL] print ( colored ( [string] , [string] ) ) [EOL] self . browser . quit ( ) [EOL] raise LoginError [EOL] self . _skip_adding_phone_number ( ) [EOL] [EOL] def _navigate_to_orders_page ( self ) : [EOL] [docstring] [EOL] self . browser . get ( [string] ) [EOL] [EOL] def _complete_sign_in_form ( self ) : [EOL] [docstring] [EOL] try : [EOL] email_input = self . browser . find_element_by_id ( [string] ) [EOL] email_input . send_keys ( self . email ) [EOL] [EOL] password_input = self . browser . find_element_by_id ( [string] ) [EOL] password_input . send_keys ( self . password ) [EOL] [EOL] self . browser . find_element_by_name ( [string] ) . click ( ) [EOL] [EOL] sign_in_input = self . browser . find_element_by_id ( [string] ) [EOL] sign_in_input . click ( ) [EOL] except NoSuchElementException : [EOL] self . logger . error ( colored ( [string] , [string] ) ) [EOL] print ( colored ( [string] , [string] ) ) [EOL] [EOL] def _signed_in_successful ( self ) : [EOL] [docstring] [EOL] return bool ( self . browser . current_url != [string] ) [EOL] [EOL] def _skip_adding_phone_number ( self ) : [EOL] [docstring] [EOL] try : [EOL] skip_adding_phone_link = self . browser . find_element_by_id ( [string] ) [EOL] skip_adding_phone_link . click ( ) [EOL] self . logger . info ( colored ( [string] , [string] ) ) [EOL] except NoSuchElementException : [EOL] self . logger . info ( colored ( [string] , [string] ) ) [EOL] [EOL] def _is_custom_date_range ( self ) : [EOL] [docstring] [EOL] return self . start_date . year != [number] or self . end_date . year != datetime . datetime . now ( ) . year [EOL] [EOL] def _are_orders_for_year_available ( self ) : [EOL] [docstring] [EOL] return bool ( self . browser . page_source . find ( [string] ) == - [number] ) [comment] [EOL] [EOL] def _is_next_page_available ( self ) : [EOL] [docstring] [EOL] pagination_element = self . browser . find_element_by_class_name ( [string] ) [EOL] try : [EOL] return [string] not in pagination_element . find_element_by_class_name ( [string] ) . text [EOL] except NoSuchElementException : [EOL] return True [EOL] [EOL] @ staticmethod def _is_digital_order ( order_id ) : [EOL] [docstring] [EOL] return order_id [ : [number] ] == [string] [EOL] [EOL] def _is_paging_menu_available ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . browser . find_element_by_class_name ( [string] ) is not None [EOL] except NoSuchElementException : [EOL] return False [EOL] [EOL] def _get_orders ( self ) : [EOL] [docstring] [EOL] if self . _is_custom_date_range ( ) : [EOL] file_handler . remove_file ( FILE_NAME ) [EOL] else : [EOL] self . orders = file_handler . load_orders ( FILE_NAME ) [EOL] [EOL] if self . orders : [EOL] self . _scrape_partial ( ) [EOL] else : [EOL] self . _scrape_complete ( ) [EOL] self . orders = sorted ( self . orders , key = lambda order : order . date ) [EOL] [EOL] def _get_order_info ( self , order_info_element ) : [EOL] [docstring] [EOL] order_info_list = [ info_field . text for info_field in order_info_element . find_elements_by_class_name ( [string] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( order_info_list ) < [number] : [EOL] order_id = order_info_list [ [number] ] [EOL] else : [EOL] order_id = order_info_list [ [number] ] [EOL] [EOL] [comment] [EOL] order_price_str = order_info_list [ [number] ] [EOL] if order_price_str . find ( [string] ) != - [number] : [EOL] order_price = self . _price_str_to_float ( order_price_str ) [EOL] else : [EOL] order_price = [number] [EOL] [EOL] date_str = order_info_list [ [number] ] [EOL] date = ut . str_to_date ( date_str ) [EOL] return order_id , order_price , date [EOL] [EOL] def _scrape_complete ( self ) : [EOL] [docstring] [EOL] self . orders = self . _scrape_orders ( ) [EOL] [EOL] def _scrape_partial ( self ) : [EOL] [docstring] [EOL] self . orders = sorted ( self . orders , key = lambda order : order . date ) [EOL] self . start_scraping_date = self . orders [ - [number] ] . date [EOL] [EOL] scraped_orders = self . _scrape_orders ( ) [EOL] [EOL] [comment] [EOL] existing_order_ids = list ( map ( lambda order : order . order_id , self . orders ) ) [EOL] new_orders = list ( filter ( lambda order : order . order_id not in existing_order_ids , scraped_orders ) ) [EOL] self . orders . extend ( new_orders ) [EOL] [EOL] def _scrape_orders ( self ) : [EOL] [docstring] [EOL] orders = [ ] [EOL] [comment] [EOL] start_index = [number] + ( datetime . datetime . now ( ) . year - self . end_date . year ) [EOL] end_index = [number] + ( datetime . datetime . now ( ) . year - self . start_scraping_date . year ) + [number] [EOL] [EOL] for order_filter_index in range ( start_index , end_index ) : [EOL] [comment] [EOL] ut . wait_for_element_by_id ( self . browser , [string] ) [EOL] self . browser . find_element_by_id ( [string] ) . click ( ) [EOL] [EOL] [comment] [EOL] id_order_filter = f' [string] { order_filter_index }' [EOL] ut . wait_for_element_by_id ( self . browser , id_order_filter ) [EOL] dropdown_element = self . browser . find_element_by_id ( id_order_filter ) [EOL] dropdown_element . click ( ) [EOL] [EOL] pages_remaining = self . _are_orders_for_year_available ( ) [EOL] while pages_remaining : [EOL] [EOL] orders_on_page = self . _scrape_page_for_orders ( ) [EOL] orders . extend ( orders_on_page ) [EOL] [EOL] current_date = orders_on_page [ - [number] ] . date [EOL] [EOL] if orders_on_page and self . start_scraping_date > current_date : [EOL] break [EOL] if self . _is_paging_menu_available ( ) : [EOL] pagination_element = self . browser . find_element_by_class_name ( [string] ) [EOL] else : [EOL] break [EOL] [EOL] pages_remaining = self . _is_next_page_available ( ) [EOL] if pages_remaining : [EOL] next_page_link = pagination_element . find_element_by_class_name ( [string] ) . find_element_by_css_selector ( [string] ) . get_attribute ( [string] ) [EOL] self . browser . get ( next_page_link ) [EOL] [EOL] return orders [EOL] [EOL] def _scrape_page_for_orders ( self ) : [EOL] [docstring] [EOL] orders = [ ] [EOL] for order_element in self . browser . find_elements_by_class_name ( [string] ) : [EOL] [EOL] ut . wait_for_element_by_class_name ( order_element , [string] , timeout = [number] ) [EOL] order_info_element = order_element . find_element_by_class_name ( [string] ) [EOL] order_id , order_price , date = self . _get_order_info ( order_info_element ) [EOL] [EOL] items = [ ] [EOL] [comment] [EOL] [comment] [EOL] for items_by_seller in order_element . find_elements_by_class_name ( [string] ) [ [number] : ] : [EOL] [EOL] for index , item_element in enumerate ( items_by_seller . find_elements_by_class_name ( [string] ) ) : [EOL] seller = self . _get_item_seller ( item_element ) [EOL] title , link = self . _get_item_title ( item_element ) [EOL] item_price = order_price if self . _is_digital_order ( order_id ) else \ [EOL] self . _get_item_price ( item_element , index , order_element ) [EOL] categories = self . _get_item_categories ( link ) if self . extensive else dict ( ) [EOL] [EOL] items . append ( Item ( item_price , link , title , seller , categories ) ) [EOL] [EOL] orders . append ( Order ( order_id , order_price , date , items ) ) [EOL] [EOL] current_date = orders [ - [number] ] . date [EOL] progress = self . _get_progress ( current_date = current_date ) [EOL] self . _notify_progress_observers ( progress ) [EOL] [EOL] return orders [EOL] [EOL] @ staticmethod def _get_item_seller ( item_element ) : [EOL] [docstring] [EOL] try : [EOL] seller_raw = item_element . text . split ( [string] ) [ [number] ] [EOL] seller = seller_raw . split ( [string] ) [ [number] ] [EOL] return seller [EOL] except IndexError : [EOL] return [string] [EOL] [EOL] @ staticmethod def _get_item_title ( item_element ) : [EOL] [docstring] [EOL] item_elements = item_element . find_element_by_class_name ( [string] ) . find_elements_by_class_name ( [string] ) [EOL] item_title_element = item_elements [ [number] ] [EOL] title = item_title_element . text [EOL] try : [EOL] link = item_title_element . find_element_by_class_name ( [string] ) . get_attribute ( [string] ) [EOL] except NoSuchElementException : [EOL] link = [string] [EOL] [EOL] return title , link [EOL] [EOL] def _get_item_price ( self , item_element , item_index , order_element ) : [EOL] [docstring] [EOL] try : [EOL] item_price_str = item_element . find_element_by_class_name ( [string] ) . text [EOL] item_price = self . _price_str_to_float ( item_price_str ) [EOL] except ( NoSuchElementException , ValueError ) : [EOL] item_price = self . _get_item_price_through_details_page ( order_element , item_index ) [EOL] [EOL] return item_price [EOL] [EOL] def _get_item_price_through_details_page ( self , order_element , item_index ) : [EOL] [docstring] [EOL] item_price = [number] [EOL] [EOL] try : [EOL] order_details_link = order_element . find_element_by_class_name ( [string] ) . get_attribute ( [string] ) [EOL] [EOL] self . browser . execute_script ( f''' [string] { order_details_link } [string] ''' ) [EOL] self . browser . switch_to . window ( self . browser . window_handles [ [number] ] ) [EOL] if not ut . wait_for_element_by_class_name ( self . browser , [string] ) : [EOL] return item_price [EOL] [EOL] od_shipments_element = self . browser . find_element_by_class_name ( [string] ) [EOL] price_fields = od_shipments_element . find_elements_by_class_name ( [string] ) [EOL] item_price = self . _price_str_to_float ( price_fields [ item_index ] . text ) [EOL] [EOL] except ( NoSuchElementException , ValueError ) : [EOL] item_price = [number] [EOL] self . logger . warning ( colored ( f' [string] { order_element . text }' , [string] ) ) [EOL] [EOL] finally : [EOL] self . browser . close ( ) [EOL] self . browser . switch_to . window ( self . browser . window_handles [ [number] ] ) [EOL] return item_price [EOL] [EOL] def _get_item_categories ( self , item_link ) : [EOL] [docstring] [EOL] categories = dict ( ) [EOL] [EOL] self . browser . execute_script ( f''' [string] { item_link } [string] ''' ) [EOL] self . browser . switch_to . window ( self . browser . window_handles [ [number] ] ) [EOL] [EOL] if ut . wait_for_element_by_id ( self . browser , [string] ) : [EOL] categories = self . _get_item_categories_from_normal ( ) [EOL] self . browser . close ( ) [EOL] self . browser . switch_to . window ( self . browser . window_handles [ [number] ] ) [EOL] return categories [EOL] [EOL] if ut . wait_for_element_by_class_name ( self . browser , [string] ) : [EOL] categories = self . _get_item_categories_from_video ( ) [EOL] self . browser . close ( ) [EOL] self . browser . switch_to . window ( self . browser . window_handles [ [number] ] ) [EOL] return categories [EOL] [EOL] self . browser . close ( ) [EOL] self . browser . switch_to . window ( self . browser . window_handles [ [number] ] ) [EOL] [EOL] return categories [EOL] [EOL] def _get_item_categories_from_normal ( self ) : [EOL] [docstring] [EOL] categories = dict ( ) [EOL] categories_element = self . browser . find_element_by_id ( [string] ) [EOL] for index , category_element in enumerate ( categories_element . find_elements_by_class_name ( [string] ) ) : [EOL] element_is_separator = index % [number] == [number] [EOL] if element_is_separator : [EOL] continue [EOL] depth = int ( index // [number] + [number] ) [EOL] categories [ depth ] = category_element . text [EOL] return categories [EOL] [EOL] def _get_item_categories_from_video ( self ) : [EOL] [docstring] [EOL] categories = dict ( ) [EOL] text = self . browser . find_element_by_class_name ( [string] ) . text [EOL] genre = text . split ( [string] ) [ [number] ] [EOL] genre_list = genre . split ( [string] ) [EOL] genre_list [ [number] ] = genre_list [ [number] ] . split ( [string] ) [ [number] ] [EOL] for index , genre in enumerate ( genre_list ) : [EOL] categories [ index ] = genre [EOL] [EOL] categories [ len ( genre_list ) ] = [string] [EOL] return categories [EOL] [EOL] @ staticmethod def _price_str_to_float ( price_str ) : [EOL] [docstring] [EOL] return float ( ( price_str [ [number] : ] ) . replace ( [string] , [string] ) ) [EOL] [EOL] def _get_progress ( self , current_date ) : [EOL] [docstring] [EOL] total_days = self . end_date . day - self . start_scraping_date . day + ( self . end_date . month - self . start_scraping_date . month ) * [number] + ( self . end_date . year - self . start_scraping_date . year ) * [number] * [number] [EOL] scraped_days = self . end_date . day - current_date . day + ( self . end_date . month - current_date . month ) * [number] + ( self . end_date . year - current_date . year ) * [number] * [number] [EOL] progress = scraped_days / total_days if total_days > [number] else [number] [EOL] return progress if progress <= [number] else [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $typing.Callable[[builtins.float],None]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.float],None]$ 0 $typing.Callable[[builtins.float],None]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 $selenium.webdriver.firefox.webdriver.WebDriver$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 $selenium.webdriver.firefox.webdriver.WebDriver$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.float,datetime.date]$ 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $datetime.date$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $datetime.date$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 0 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[data.Order]$ 0 0 0 0 0 $typing.List[scraping.data.Order]$ 0 0 0 $typing.List[data.Order]$ 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 $typing.List[data.Order]$ 0 0 0 $typing.List[data.Order]$ 0 0 0 $datetime.date$ 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[data.Order]$ 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $datetime.date$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $datetime.date$ 0 $datetime.date$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 $typing.Any$ 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 $builtins.int$ 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[selenium.webdriver.remote.webelement.WebElement]$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[selenium.webdriver.remote.webelement.WebElement]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $selenium.webdriver.remote.webelement.WebElement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $datetime.date$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Literal , List , Dict , Any [EOL] import dash_html_components [EOL] import logging [EOL] import dash [EOL] import scraping [EOL] import dash_core_components [EOL] import typing_extensions [EOL] import typing [EOL] import plotly [EOL] import multiprocessing [EOL] import builtins [EOL] import copy [EOL] import logging [EOL] import time [EOL] from typing import Dict [EOL] from multiprocessing import Process [EOL] [EOL] import dash [EOL] import dash_core_components as dcc [EOL] import dash_html_components as html [EOL] import plotly . graph_objs as go [EOL] from dash import Dash [EOL] from termcolor import colored [EOL] [EOL] from scraping import utils [EOL] from scraping . CustomExceptions import OrdersNotFound [EOL] from scraping . evaluation import Evaluation [EOL] from . import evaluation [EOL] from . import file_handler as fh [EOL] [EOL] LAYOUT = dict ( autosize = True , margin = dict ( l = [number] , r = [number] , b = [number] , t = [number] ) , hovermode = [string] , plot_bgcolor = [string] , paper_bgcolor = [string] , legend = dict ( font = dict ( size = [number] ) , orientation = [string] ) , ) [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def main ( ) : [EOL] app = Dash ( __name__ ) [EOL] [EOL] orders = fh . load_orders ( ) [EOL] if not orders : [EOL] raise OrdersNotFound [EOL] evaluated = evaluation . Evaluation ( orders ) [EOL] [EOL] app . layout = html . Div ( children = [ head ( ) , html . Div ( [ general_information ( evaluated ) , gen_stacked_totals_graph ( evaluated ) ] , className = [string] ) , html . Div ( gen_scatter_by_month_graph ( evaluated ) , className = [string] ) , html . Div ( gen_one_bar_graph ( evaluated ) , className = [string] ) ] , id = [string] ) [EOL] [EOL] run_server ( app ) [EOL] [EOL] [EOL] def run_server ( app ) : [EOL] server_process = Process ( target = app . run_server ) [EOL] server_process . daemon = True [EOL] server_process . start ( ) [EOL] LOGGER . info ( colored ( f' [string] { server_process . pid }' , [string] ) ) [EOL] time . sleep ( [number] ) [EOL] webbrowser_process = Process ( target = utils . open_webbrowser , kwargs = { [string] : [string] } ) [EOL] webbrowser_process . daemon = True [EOL] webbrowser_process . start ( ) [EOL] LOGGER . info ( colored ( f' [string] { webbrowser_process . pid }' , [string] ) ) [EOL] [EOL] [EOL] def head ( ) : [EOL] return html . Div ( [ html . H3 ( [string] , style = { [string] : [string] } , ) , html . H5 ( [string] , style = { [string] : [string] } ) , ] , className = [string] , id = [string] , ) [EOL] [EOL] [EOL] def general_information ( evaluated ) : [EOL] return html . Div ( [ html . Div ( [ f" [string] { evaluated . get_total ( ) } [string] " , html . H6 ( [string] ) ] , className = [string] ) , html . Div ( [ f"{ evaluated . get_audible_total ( ) } [string] " , html . H6 ( [string] ) ] , className = [string] ) , html . Div ( [ f"{ evaluated . get_instant_video_total ( ) } [string] " , html . H6 ( [string] ) ] , className = [string] ) , html . Div ( [ f"{ evaluated . get_most_expensive_order ( ) [ [number] ] . price } [string] " , html . H6 ( [string] ) ] , className = [string] ) , html . Div ( [ f"{ len ( evaluated . get_orders_with_most_items ( ) [ [number] ] . items ) } [string] " , html . H6 ( [string] ) ] , className = [string] ) , html . Div ( [ f"{ evaluated . get_order_count ( ) }" , html . H6 ( [string] ) ] , className = [string] ) , html . Div ( [ f"{ evaluated . get_item_count ( ) }" , html . H6 ( [string] ) ] , className = [string] ) , ] , className = [string] , ) [EOL] [EOL] [EOL] def gen_bar ( data , name ) : [EOL] return go . Bar ( x = list ( data . keys ( ) ) , y = list ( data . values ( ) ) , name = name ) [EOL] [EOL] [EOL] def gen_scatter ( data , name ) : [EOL] return go . Scatter ( x = list ( data . keys ( ) ) , y = list ( data . values ( ) ) , name = name ) [EOL] [EOL] [EOL] def gen_stacked_totals_graph ( evaluated ) : [EOL] [docstring] [EOL] fig = go . Figure ( data = [ gen_bar ( evaluated . audible_total_by_year ( ) , [string] ) , gen_bar ( evaluated . instant_video_total_per_year ( ) , [string] ) , gen_bar ( evaluated . prime_member_fee_by_year ( ) , [string] ) , gen_bar ( evaluated . added_balance_per_year ( ) , [string] ) , gen_bar ( evaluated . uncategorized_totals_per_year ( ) , [string] ) , ] , layout = copy . deepcopy ( LAYOUT ) ) [EOL] [EOL] fig . update_layout ( barmode = [string] , yaxis = dict ( title = [string] , titlefont_size = [number] , tickfont_size = [number] ) , xaxis = dict ( title = [string] , titlefont_size = [number] , tickfont_size = [number] ) , legend = dict ( font_size = [number] , bgcolor = [string] ) , height = [number] , title = [string] , titlefont = { [string] : [number] } ) [EOL] [EOL] fig . update_xaxes ( dtick = [number] ) [EOL] [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = fig ) , id = [string] , className = [string] ) [EOL] [EOL] [EOL] def gen_scatter_by_month_graph ( evaluated ) : [EOL] [docstring] [EOL] [EOL] fig = go . Figure ( data = [ gen_scatter ( evaluated . totals_by_month ( ) , [string] ) , gen_scatter ( evaluated . trend_by_month ( ) , [string] ) ] , layout = copy . deepcopy ( LAYOUT ) ) [EOL] [EOL] fig . update_layout ( yaxis = dict ( title = [string] , titlefont_size = [number] , tickfont_size = [number] ) , xaxis = dict ( titlefont_size = [number] , tickfont_size = [number] ) , legend = dict ( font_size = [number] , bgcolor = [string] ) , title = [string] , titlefont = { [string] : [number] } ) [EOL] [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = fig ) , className = [string] ) [EOL] [EOL] [EOL] def gen_one_bar_graph ( evaluated ) : [EOL] [EOL] category_sums = evaluated . total_by_level_1_category ( ) [EOL] total = sum ( category_sums . values ( ) ) [EOL] percentages = { category [ [number] ] : category [ [number] ] / total * [number] for category in category_sums . items ( ) } [EOL] [EOL] data = [ go . Bar ( name = category [ [number] ] , x = [ category [ [number] ] ] , y = [ [number] ] , orientation = [string] ) for category in percentages . items ( ) ] [EOL] [EOL] fig = go . Figure ( data = data , layout = copy . deepcopy ( LAYOUT ) ) [EOL] [EOL] fig . update_layout ( barmode = [string] , yaxis = dict ( tickfont_size = [number] , showticklabels = False ) , xaxis = dict ( tickfont_size = [number] , ticksuffix = [string] ) , legend = dict ( font_size = [number] , bgcolor = [string] ) , title = [string] , titlefont = { [string] : [number] , } , ) [EOL] [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = fig ) , className = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dash_html_components.Div$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dash_html_components.Div$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plotly.graph_objs.Bar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dash_core_components.Graph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dash_html_components.Div$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dash_html_components.Div$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dash_html_components.Div$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Iterator [EOL] import typing [EOL] import builtins [EOL] from __future__ import annotations [EOL] import sys [EOL] import time [EOL] import threading [EOL] [EOL] from typing import Generator , Iterator [EOL] [EOL] [EOL] class Spinner : [EOL] [docstring] [EOL] busy = False [EOL] delay = [number] [EOL] [EOL] @ staticmethod def spinning_cursor ( ) : [EOL] while [number] : [EOL] for cursor in [string] : yield cursor [EOL] [EOL] def __init__ ( self , delay = None ) : [EOL] self . spinner_generator = self . spinning_cursor ( ) [EOL] if delay and float ( delay ) : self . delay = delay [EOL] [EOL] def spinner_task ( self ) : [EOL] while self . busy : [EOL] sys . stdout . write ( next ( self . spinner_generator ) + [string] ) [EOL] sys . stdout . flush ( ) [EOL] time . sleep ( self . delay ) [EOL] sys . stdout . write ( [string] ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] self . busy = True [EOL] threading . Thread ( target = self . spinner_task ) . start ( ) [EOL] [EOL] def __exit__ ( self , exception , value , tb ) : [EOL] self . busy = False [EOL] time . sleep ( self . delay ) [EOL] if exception is not None : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , List [EOL] import logging [EOL] import typing [EOL] import data [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] import json [EOL] import logging [EOL] import os [EOL] from typing import List , Iterable [EOL] [EOL] from termcolor import colored [EOL] [EOL] from . data import Order [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def remove_file ( file_name ) : [EOL] [docstring] [EOL] package_directory = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] path = os . path . join ( package_directory , [string] , file_name ) [EOL] [EOL] if not os . path . isfile ( path ) : [EOL] return False [EOL] [EOL] os . remove ( path ) [EOL] LOGGER . info ( colored ( f"{ file_name } [string] " , [string] ) ) [EOL] return True [EOL] [EOL] [EOL] def load_orders ( file_name = [string] ) : [EOL] [docstring] [EOL] data = read_json_file ( file_name ) [EOL] if not data : [EOL] return [ ] [EOL] [EOL] orders = [ ] [EOL] for order_dict in data : [EOL] orders . append ( Order . from_dict ( order_dict ) ) [EOL] [EOL] return orders [EOL] [EOL] [EOL] def load_password ( file_name = [string] ) : [EOL] [docstring] [EOL] path = to_file_path ( file_name ) [EOL] if not os . path . exists ( path ) : [EOL] LOGGER . warning ( colored ( f" [string] " , [string] ) ) [EOL] return [string] [EOL] [EOL] with open ( path ) as file : [EOL] return file . read ( ) [EOL] [EOL] [EOL] def save_file ( file_name , data ) : [EOL] [docstring] [EOL] package_directory = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] path = os . path . join ( package_directory , [string] , file_name ) [EOL] with open ( path , [string] ) as file : [EOL] file . write ( data ) [EOL] [EOL] [EOL] def read_json_file ( file_name ) : [EOL] [docstring] [EOL] path = to_file_path ( file_name ) [EOL] if not os . path . exists ( path ) : [EOL] LOGGER . warning ( colored ( f"{ file_name } [string] " , [string] ) ) [EOL] return [ ] [EOL] [EOL] with open ( path ) as file : [EOL] return iter ( json . load ( file ) ) [EOL] [EOL] [EOL] def to_file_path ( file_name ) : [EOL] [docstring] [EOL] package_directory = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] path = os . path . join ( package_directory , [string] , file_name ) [EOL] return path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[data.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Callable , List , Dict , Any , Optional [EOL] import logging [EOL] import scraping [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] from __future__ import annotations [EOL] [EOL] import datetime [EOL] import itertools [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] from cmd import Cmd [EOL] from termcolor import colored [EOL] from typing import Tuple , List , Dict , Any , Callable [EOL] [EOL] from scraping import dash_app , utils [EOL] from scraping . CustomExceptions import LoginError , PasswordFileNotFound , OrdersNotFound [EOL] from scraping . scraper import Scraper [EOL] from scraping . spinner import Spinner [EOL] from scraping . utils import OptionType , ArgumentType [EOL] [EOL] [EOL] class Cli ( Cmd ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] self . refresh_cli = False [EOL] self . spinner = itertools . cycle ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] self . prompt = colored ( [string] , [string] ) [EOL] self . SCRAPING_OPTIONS = [ ( [string] , OptionType . REQUIRED , ArgumentType . SINGLE_STRING ) , ( [string] , OptionType . OPTIONAL , ArgumentType . SINGLE_STRING ) , ( [string] , OptionType . OPTIONAL , ArgumentType . SINGLE_INT ) , ( [string] , OptionType . OPTIONAL , ArgumentType . SINGLE_INT ) , ( [string] , OptionType . OPTIONAL , ArgumentType . FLAG ) , ( [string] , OptionType . OPTIONAL , ArgumentType . FLAG ) ] [EOL] [EOL] self . cmdloop ( ) [EOL] [EOL] def emptyline ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def default ( self , line ) : [EOL] [docstring] [EOL] self . refresh_cli = False [EOL] print ( f'{ line } [string] ' ) [EOL] [EOL] def preloop ( self ) : [EOL] [docstring] [EOL] os . system ( [string] ) [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( ) [EOL] [EOL] def postloop ( self ) : [EOL] [docstring] [EOL] os . system ( [string] ) [EOL] [EOL] def postcmd ( self , stop , line ) : [EOL] if self . refresh_cli : [EOL] self . preloop ( ) [EOL] self . refresh_cli = True [EOL] return stop [EOL] [EOL] def completedefault ( self , * ignored ) : [EOL] [docstring] [EOL] return list ( map ( lambda option : option [ [number] ] , self . SCRAPING_OPTIONS ) ) [EOL] [EOL] def do_scrape ( self , line ) : [EOL] [docstring] [EOL] args_dict = self . _get_args ( line ) [EOL] if self . _scrape_check_args ( args_dict ) : [EOL] print ( [string] ) [EOL] try : [EOL] progress_callback = lambda progress : self . _print_progress_bar ( progress * [number] , [number] ) [EOL] with Spinner ( ) : [EOL] self . _print_progress_bar ( [number] , [number] ) [EOL] Scraper ( email = args_dict [ [string] ] , password = args_dict [ [string] ] , headless = args_dict [ [string] ] , start = args_dict [ [string] ] , end = args_dict [ [string] ] , extensive = True , progress_observer_callback = progress_callback ) [EOL] except ( LoginError , PasswordFileNotFound , AssertionError ) : [EOL] pass [EOL] self . refresh_cli = False [EOL] [EOL] def complete_scrape ( self , text , line , begidx , endidx ) : [EOL] [docstring] [EOL] return list ( map ( lambda option : f'{ [string] if line [ begidx - [number] ] != [string] else [string] }' f'{ [string] if line [ begidx - [number] ] != [string] else [string] }' f'{ option [ [number] ] } [string] ' , filter ( lambda option : option [ [number] ] . startswith ( text . lower ( ) ) and f' [string] { option [ [number] ] }' not in line , self . SCRAPING_OPTIONS ) ) ) [EOL] [EOL] def help_scrape ( self ) : [EOL] [docstring] [EOL] print ( f' [string] ' f' [string] ' ) [EOL] for option in self . SCRAPING_OPTIONS : [EOL] print ( f' [string] { option [ [number] ] } [string] { [string] if option [ [number] ] == OptionType . REQUIRED else [string] }' ) [EOL] [EOL] print ( f' [string] ' ) [EOL] [EOL] def do_dash ( self , line ) : [EOL] [docstring] [EOL] args_dict = self . _get_args ( line ) [EOL] if self . _are_all_rec_args_accepted ( received_args = args_dict , accepted_args = [ ] ) \ [EOL] and self . _check_args_value_count ( received_args = args_dict , accepted_args = [ ] ) : [EOL] try : [EOL] dash_app . main ( ) [EOL] except OrdersNotFound : [EOL] print ( colored ( [string] , [string] ) ) [EOL] pass [EOL] [EOL] @ staticmethod def help_dash ( ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] [EOL] @ staticmethod def do_exit ( * _ ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def _scrape_check_args ( self , args ) : [EOL] [docstring] [EOL] is_valid = True [EOL] if not self . _are_all_req_args_given ( self . SCRAPING_OPTIONS , args ) : [EOL] is_valid = False [EOL] if not self . _are_all_rec_args_accepted ( self . SCRAPING_OPTIONS , args ) : [EOL] is_valid = False [EOL] if not self . _check_args_value_count ( self . SCRAPING_OPTIONS , args ) : [EOL] is_valid = False [EOL] [EOL] if [string] in args . keys ( ) : [EOL] email = args [ [string] ] [EOL] if [string] not in email or [string] not in email : [EOL] print ( colored ( f' [string] { email }' , [string] ) ) [EOL] is_valid = False [EOL] [EOL] if [string] in args . keys ( ) and [string] in args . keys ( ) : [EOL] is_valid = False [EOL] [EOL] if ( [string] in args . keys ( ) and [string] in args . keys ( ) ) and args [ [string] ] > args [ [string] ] : [EOL] print ( colored ( f' [string] { args [ [string] ] } [string] { args [ [string] ] } [string] ' , [string] ) ) [EOL] is_valid = False [EOL] [EOL] args [ [string] ] = args [ [string] ] if [string] in args . keys ( ) else datetime . datetime . now ( ) . year [EOL] args [ [string] ] = args [ [string] ] if [string] in args . keys ( ) else [number] [EOL] args [ [string] ] = args [ [string] ] if [string] in args . keys ( ) else [string] [EOL] args [ [string] ] = True if [string] in args . keys ( ) else False [EOL] [EOL] return is_valid [EOL] [EOL] @ staticmethod def _arg_int_parsable ( args , arg_key ) : [EOL] [docstring] [EOL] if arg_key in args . keys ( ) : [EOL] try : [EOL] args [ arg_key ] = int ( args [ arg_key ] ) [EOL] except ValueError : [EOL] print ( colored ( f' [string] { arg_key } [string] { type ( args [ arg_key ] ) } [string] { args [ [string] ] }' , [string] ) ) [EOL] return False [EOL] return True [EOL] [EOL] @ staticmethod def _are_all_req_args_given ( accepted_args , received_args ) : [EOL] [docstring] [EOL] required_args = list ( map ( lambda option : option [ [number] ] , filter ( lambda arg : arg [ [number] ] == OptionType . REQUIRED , accepted_args ) ) ) [EOL] missing_req_args = list ( map ( lambda arg : f' [string] { arg }' , filter ( lambda arg : arg not in received_args . keys ( ) , required_args ) ) ) [EOL] if missing_req_args : [EOL] print ( colored ( f' [string] { missing_req_args }' , [string] ) ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _check_args_value_count ( self , accepted_args , received_args ) : [EOL] [docstring] [EOL] args_value_count_valid = True [EOL] for acc_arg in accepted_args : [EOL] if acc_arg [ [number] ] in received_args . keys ( ) : [EOL] values = list ( filter ( lambda arg_str : arg_str , received_args [ acc_arg [ [number] ] ] . split ( [string] ) ) ) [EOL] if acc_arg [ [number] ] == ArgumentType . FLAG and values : [EOL] print ( colored ( f' [string] { acc_arg [ [number] ] } [string] { [string] if len ( values ) > [number] else [string] } [string] { values }' , [string] ) ) [EOL] args_value_count_valid = args_value_count_valid and False [EOL] elif ( acc_arg [ [number] ] == ArgumentType . SINGLE_STRING or acc_arg [ [number] ] == ArgumentType . SINGLE_INT ) and len ( values ) != [number] : [EOL] print ( colored ( f' [string] { acc_arg [ [number] ] } [string] { values } [string] ' , [string] ) ) [EOL] args_value_count_valid = args_value_count_valid and False [EOL] elif acc_arg [ [number] ] == ArgumentType . SINGLE_INT and not self . _arg_int_parsable ( received_args , acc_arg [ [number] ] ) : [EOL] args_value_count_valid = args_value_count_valid and False [EOL] elif ( acc_arg [ [number] ] == ArgumentType . MULTI_STRING or acc_arg [ [number] ] == ArgumentType . MULTI_INT ) and len ( values ) <= [number] : [EOL] print ( colored ( f' [string] { acc_arg [ [number] ] } [string] { len ( values ) } [string] { values } [string] ' , [string] ) ) [EOL] args_value_count_valid = args_value_count_valid and False [EOL] elif acc_arg [ [number] ] == ArgumentType . MULTI_INT : [EOL] for value in values : [EOL] if not utils . is_int_parsable ( value ) : [EOL] args_value_count_valid = args_value_count_valid and False [EOL] else : [EOL] received_args [ acc_arg [ [number] ] ] = int ( received_args [ acc_arg [ [number] ] ] ) [EOL] [EOL] return args_value_count_valid [EOL] [EOL] @ staticmethod def _are_all_rec_args_accepted ( accepted_args , received_args ) : [EOL] [docstring] [EOL] not_rec_args = list ( filter ( lambda rec_arg : rec_arg not in map ( lambda arg : arg [ [number] ] , accepted_args ) , received_args . keys ( ) ) ) [EOL] if not_rec_args : [EOL] print ( f' [string] { [string] if len ( not_rec_args ) > [number] else [string] } [string] { not_rec_args }' ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] @ staticmethod def _get_args ( line ) : [EOL] [docstring] [EOL] line = f' [string] { line }' [EOL] args_dict = { } [EOL] args = line . split ( [string] ) [ [number] : ] [EOL] [EOL] for arg in args : [EOL] arg_tuple = arg . split ( [string] ) [EOL] args_dict [ arg_tuple [ [number] ] ] = [string] . join ( arg_tuple [ [number] : ] ) [EOL] [EOL] return args_dict [EOL] [EOL] @ staticmethod def _print_progress_bar ( iteration , total , prefix = [string] , suffix = [string] , decimals = [number] , length = [number] , fill = [string] ) : [EOL] [docstring] [EOL] percent = ( [string] + str ( decimals ) + [string] ) . format ( round ( [number] * ( iteration / float ( total ) ) , decimals ) ) [EOL] filled_length = int ( length * iteration // total ) [EOL] bar = fill * filled_length + [string] * ( length - filled_length ) [EOL] print ( [string] % ( prefix , bar , percent , suffix ) , end = [string] ) [EOL] [comment] [EOL] if int ( iteration ) == total : [EOL] print ( [string] ) [EOL] [EOL] def cmdloop ( self , intro = None ) : [EOL] [docstring] [EOL] [EOL] self . preloop ( ) [EOL] if self . use_rawinput and self . completekey : [EOL] try : [EOL] import readline [EOL] self . old_completer = readline . get_completer ( ) [EOL] readline . set_completer ( self . complete ) [EOL] readline . parse_and_bind ( self . completekey + [string] ) [EOL] except ImportError : [EOL] pass [EOL] try : [EOL] if intro is not None : [EOL] self . intro = intro [EOL] if self . intro : [EOL] self . stdout . write ( str ( self . intro ) + [string] ) [EOL] stop = None [EOL] while not stop : [EOL] if self . cmdqueue : [EOL] line = self . cmdqueue . pop ( [number] ) [EOL] else : [EOL] if self . use_rawinput : [EOL] try : [EOL] line = input ( self . prompt ) [EOL] except KeyboardInterrupt : [EOL] self . refresh_cli = False [EOL] print ( [string] ) [EOL] [comment] [EOL] line = [string] [EOL] except EOFError : [EOL] line = [string] [EOL] else : [EOL] self . stdout . write ( self . prompt ) [EOL] self . stdout . flush ( ) [EOL] line = self . stdin . readline ( ) [EOL] if not len ( line ) : [EOL] line = [string] [EOL] else : [EOL] line = line . rstrip ( [string] ) [EOL] line = self . precmd ( line ) [EOL] stop = self . onecmd ( line ) [EOL] stop = self . postcmd ( stop , line ) [EOL] self . postloop ( ) [EOL] finally : [EOL] if self . use_rawinput and self . completekey : [EOL] try : [EOL] import readline [EOL] readline . set_completer ( self . old_completer ) [EOL] except ImportError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0