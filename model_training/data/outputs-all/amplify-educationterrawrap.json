[docstring] [EOL] [EOL] from . version import __version__ , __git_hash__ [EOL]	0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class NotTerraformConfigDirectory ( RuntimeError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __version__ = [string] [EOL] __git_hash__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Optional , Tuple , Dict [EOL] import filelock [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import requests [EOL] import urllib [EOL] [docstring] [EOL] [EOL] import os [EOL] import platform [EOL] import stat [EOL] from typing import Dict , Tuple , Optional [EOL] from urllib . parse import urlparse [EOL] [EOL] import boto3 [EOL] import requests [EOL] from botocore . exceptions import ClientError [EOL] from filelock import FileLock [EOL] [EOL] [EOL] class FileDownloadFailed ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PluginDownload : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , s3_client ) : [EOL] self . s3_client = s3_client or boto3 . client ( [string] ) [EOL] [EOL] def download_plugins ( self , plugin_paths ) : [EOL] [docstring] [EOL] for name , path in plugin_paths . items ( ) : [EOL] home = os . path . expanduser ( [string] ) [EOL] plugin_directory = os . path . join ( home , [string] ) [EOL] os . makedirs ( plugin_directory , exist_ok = True ) [EOL] [EOL] file_path = os . path . join ( plugin_directory , name ) [EOL] [EOL] system = platform . system ( ) [EOL] machine = platform . machine ( ) [EOL] path_with_platform = [string] % ( path , system , machine ) [EOL] [EOL] lock_path = [string] % ( file_path , [string] ) [EOL] lock = FileLock ( lock_path , timeout = [number] ) [EOL] [comment] [EOL] with lock : [EOL] try : [EOL] self . _download_file ( path_with_platform , file_path ) [EOL] except FileDownloadFailed : [EOL] print ( [string] % ( path_with_platform , path ) ) [EOL] self . _download_file ( path , file_path ) [EOL] [EOL] def _download_file ( self , url , file_path ) : [EOL] [docstring] [EOL] [comment] [EOL] etag = None [EOL] etag_path = [string] % ( file_path , [string] ) [EOL] if os . path . isfile ( etag_path ) and os . path . isfile ( file_path ) : [EOL] with ( open ( etag_path , [string] ) ) as etag_file : [EOL] etag = etag_file . read ( ) [EOL] [EOL] download_info = self . _get_file_content ( url , etag ) [EOL] [EOL] if download_info : [EOL] content = download_info [ [number] ] [EOL] etag = download_info [ [number] ] [EOL] [EOL] with ( open ( file_path , [string] ) ) as out_file : [EOL] out_file . write ( content ) [EOL] [EOL] mode = os . stat ( file_path ) [EOL] os . chmod ( file_path , mode . st_mode | stat . S_IEXEC ) [EOL] [EOL] if etag : [EOL] [comment] [EOL] [comment] [EOL] if etag [ [number] ] == [string] : [EOL] etag = etag [ [number] : - [number] ] [EOL] with ( open ( etag_path , [string] ) ) as etag_file : [EOL] etag_file . write ( etag ) [EOL] [EOL] def _get_file_content ( self , url , etag ) : [EOL] [docstring] [EOL] print ( [string] % url ) [EOL] [EOL] parsed_url = urlparse ( url ) [EOL] [EOL] if parsed_url . scheme in ( [string] , [string] ) : [EOL] return self . _get_http_content ( url , etag ) [EOL] [EOL] if parsed_url . scheme == [string] : [EOL] return self . _get_s3_content ( url , etag ) [EOL] [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def _get_http_content ( self , url , etag ) : [EOL] [docstring] [EOL] headers = { } [EOL] [EOL] [comment] [EOL] if etag : [EOL] headers [ [string] ] = etag [EOL] [EOL] try : [EOL] response = requests . get ( url , headers = headers ) [EOL] response . raise_for_status ( ) [EOL] [EOL] if response . status_code == [number] : [EOL] return None [EOL] [EOL] return response . content , response . headers . get ( [string] ) [EOL] except requests . HTTPError : [EOL] raise FileDownloadFailed ( ) [EOL] [EOL] def _get_s3_content ( self , url , etag ) : [EOL] [docstring] [EOL] parsed_url = urlparse ( url ) [EOL] [EOL] args = { [string] : parsed_url . hostname , [string] : parsed_url . path [ [number] : ] } [EOL] [EOL] if etag : [EOL] args [ [string] ] = etag [EOL] [EOL] try : [EOL] response = self . s3_client . get_object ( ** args ) [EOL] return response [ [string] ] . read ( ) , response [ [string] ] [EOL] except ClientError as ex : [EOL] if ex . response [ [string] ] [ [string] ] == [string] : [EOL] return None [EOL] if ex . response [ [string] ] [ [string] ] == [string] : [EOL] raise FileDownloadFailed ( ) from ex [EOL] raise ex [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $filelock.UnixFileLock$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $filelock.UnixFileLock$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 $builtins.bytes$ 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $os.stat_result$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 $builtins.str$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $requests.models.Response$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.bytes,typing.Optional[builtins.str]]]$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import sys [EOL] import tempfile [EOL] import os [EOL] from time import sleep [EOL] [EOL] import requests [EOL] from packaging import version [EOL] from diskcache import Cache [EOL] [EOL] [EOL] ONE_DAY_IN_SECONDS = [number] * [number] * [number] [EOL] cache = Cache ( os . path . join ( tempfile . gettempdir ( ) , [string] ) ) [EOL] [EOL] [EOL] def version_check ( current_version ) : [EOL] [docstring] [EOL] try : [EOL] latest_version = get_latest_version ( current_version = current_version ) [EOL] if version . parse ( latest_version ) <= version . parse ( current_version ) : [EOL] return False [EOL] [EOL] print ( [string] % ( current_version , latest_version , ) , [string] , sep = [string] , file = sys . stderr , ) [EOL] sleep ( [number] ) [EOL] return True [EOL] except Exception as exp : [EOL] print ( [string] % repr ( exp ) , ) [EOL] return False [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ cache . memoize ( expire = ONE_DAY_IN_SECONDS ) def get_latest_version ( current_version ) : [EOL] [docstring] [EOL] response = requests . get ( [string] ) . json ( ) [EOL] return response [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Set , List , Any [EOL] import pathlib [EOL] import networkx [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] from typing import List , Tuple , Any , Dict , Set [EOL] from pathlib import Path [EOL] import networkx [EOL] [EOL] [EOL] def has_cycle ( graph ) : [EOL] [docstring] [EOL] sources = find_source_nodes ( graph ) [EOL] if not sources : [EOL] return True [EOL] [EOL] for source in sources : [EOL] try : [EOL] cycle = networkx . find_cycle ( graph , source ) [EOL] if cycle : [EOL] print ( cycle ) [EOL] return True [EOL] except networkx . NetworkXNoCycle : [EOL] return False [EOL] return False [EOL] [EOL] [EOL] def find_source_nodes ( graph ) : [EOL] [docstring] [EOL] source_nodes = [ ] [EOL] for node in graph : [EOL] preds = list ( graph . predecessors ( node ) ) [EOL] if preds : [EOL] continue [EOL] source_nodes . append ( node ) [EOL] [EOL] return source_nodes [EOL] [EOL] [EOL] def successors ( depth , node , graph ) : [EOL] [docstring] [EOL] node_successors = ( depth , node , list ( graph . successors ( node ) ) ) [EOL] return node_successors [EOL] [EOL] [EOL] def generate_dependencies ( nodes , graph ) : [EOL] [docstring] [EOL] dependencies = [ ] [EOL] depth = [number] [EOL] for node in nodes : [EOL] path = [ ] [EOL] node_successors = successors ( depth , node , graph ) [EOL] path . append ( node_successors ) [EOL] if node_successors [ [number] ] : [EOL] generate_helper ( node_successors [ [number] ] , graph , depth + [number] , path ) [EOL] dependencies . append ( path ) [EOL] return dependencies [EOL] [EOL] [EOL] def generate_helper ( nodes , graph , depth , path ) : [EOL] [docstring] [EOL] for node in nodes : [EOL] node_successors = successors ( depth , node , graph ) [EOL] path . append ( node_successors ) [EOL] if node_successors [ [number] ] : [EOL] generate_helper ( node_successors [ [number] ] , graph , depth + [number] , path ) [EOL] return path [EOL] [EOL] [EOL] def visualize ( dependencies ) : [EOL] [docstring] [EOL] for path in dependencies : [EOL] depth = [number] [EOL] for node in path : [EOL] tab_spacing = int ( node [ [number] ] ) - [number] + depth [EOL] if depth > [number] : [EOL] print ( ) [EOL] relative_node = node [ [number] ] . replace ( os . getcwd ( ) , [string] ) [EOL] print ( ( [string] * tab_spacing ) + [string] , relative_node ) [EOL] depth += [number] [EOL] [EOL] [EOL] def find_symlink_directories ( graph ) : [EOL] [docstring] [EOL] symlinks = [ ] [EOL] [EOL] for node in graph : [EOL] path = Path ( node ) [EOL] if path . is_symlink ( ) : [EOL] symlinks . append ( path ) [EOL] [EOL] return symlinks [EOL] [EOL] [EOL] def connect_symlinks ( graph , symlink_dict ) : [EOL] [docstring] [EOL] for symlink in symlink_dict . keys ( ) : [EOL] current = symlink [EOL] secondary = [number] [EOL] links = list ( symlink_dict [ symlink ] ) [EOL] while secondary is not len ( links ) : [EOL] secondary_link = links [ secondary ] [EOL] graph . add_edge ( current , secondary_link ) [EOL] current = secondary_link [EOL] secondary += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Set , List , Any [EOL] import concurrent [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import concurrent . futures [EOL] import os [EOL] from collections import defaultdict [EOL] from typing import Dict , Set , Tuple [EOL] [EOL] import hcl2 [EOL] [EOL] [EOL] def get_module_usage_map ( root_directory ) : [EOL] [docstring] [EOL] module_map = defaultdict ( set ) [EOL] future_list = [ ] [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as executor : [EOL] [comment] [EOL] for current_dir , dirs , files in os . walk ( root_directory , followlinks = True ) : [EOL] if [string] in current_dir : [EOL] continue [EOL] [EOL] for file in files : [EOL] if not file . endswith ( [string] ) : [EOL] continue [EOL] future = executor . submit ( _get_modules_for_file , current_dir , file ) [EOL] future_list . append ( future ) [EOL] [EOL] for future in concurrent . futures . as_completed ( future_list ) : [EOL] directory , modules = future . result ( ) [EOL] for mod in modules : [EOL] module_source_path = os . path . normpath ( directory + [string] + mod ) [EOL] module_map [ module_source_path ] . add ( os . path . normpath ( directory ) ) [EOL] [EOL] return dict ( module_map ) [EOL] [EOL] [EOL] def _get_modules_for_file ( directory , file_name ) : [EOL] [docstring] [EOL] modules = set ( ) [EOL] with open ( directory + [string] + file_name , [string] ) as file : [EOL] tf_info = hcl2 . load ( file ) [EOL] for module in tf_info . get ( [string] , [ ] ) : [EOL] for module_config in module . values ( ) : [EOL] modules . add ( os . path . normpath ( module_config [ [string] ] [ [number] ] ) ) [EOL] [EOL] return directory , modules [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Set [EOL] [EOL] import os [EOL] from git import Repo [EOL] [EOL] [EOL] def get_git_changed_files ( ) : [EOL] [docstring] [EOL] repo = Repo ( ) [EOL] changed_files = set ( ) [EOL] for change in repo . commit ( [string] ) . diff ( None ) : [EOL] if not change . new_file : [EOL] changed_files . add ( os . path . abspath ( change . a_path ) ) [EOL] if not change . deleted_file : [EOL] changed_files . add ( os . path . abspath ( change . b_path ) ) [EOL] [EOL] return changed_files [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] import boto3 [EOL] from amplify_aws_utils . resource_helper import throttled_call [EOL] [EOL] [EOL] class DynamoDB : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , region , client = None ) : [EOL] self . client = client or boto3 . client ( [string] , region_name = region ) [EOL] [EOL] def upsert_item ( self , table_name , primary_key_name , primary_key_value , attribute_name , attribute_value ) : [EOL] [docstring] [EOL] key = { primary_key_name : { [string] : primary_key_value } } [EOL] expression_attribute_values = { [string] : { [string] : attribute_value } } [EOL] update_expression = [string] . format ( attribute_name ) [EOL] [EOL] return throttled_call ( self . client . update_item , TableName = table_name , Key = key , ExpressionAttributeValues = expression_attribute_values , UpdateExpression = update_expression ) [EOL] [EOL] def delete_item ( self , table_name , primary_key_name , primary_key_value , ) : [EOL] [docstring] [EOL] key = { primary_key_name : { [string] : primary_key_value } } [EOL] [EOL] return throttled_call ( self . client . delete_item , TableName = table_name , Key = key , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0
from typing import Iterable , Match , Dict , Set , Optional , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import re [EOL] import subprocess [EOL] from collections import defaultdict [EOL] from typing import Dict , Set , Iterable , List [EOL] [EOL] [EOL] GIT_REPO_REGEX = [string] [EOL] [EOL] [EOL] def get_absolute_path ( path , root_dir = None ) : [EOL] [docstring] [EOL] if os . path . isabs ( path ) : [EOL] path = os . path . abspath ( path ) [EOL] else : [EOL] path = os . path . abspath ( os . path . join ( root_dir or os . getcwd ( ) , path ) ) [EOL] [EOL] return path [EOL] [EOL] [EOL] def get_symlinks ( directory ) : [EOL] [docstring] [EOL] links = defaultdict ( set ) [EOL] [comment] [EOL] for current_dir , dirs , files in os . walk ( directory , followlinks = True ) : [EOL] if [string] in current_dir : [EOL] continue [EOL] [EOL] if os . path . islink ( current_dir ) : [EOL] link_source = os . path . join ( os . path . dirname ( current_dir ) , os . readlink ( current_dir ) ) [EOL] links [ os . path . normpath ( link_source ) ] . add ( os . path . normpath ( current_dir ) ) [EOL] [EOL] return dict ( links ) [EOL] [EOL] [EOL] def get_directories_for_paths ( paths ) : [EOL] [docstring] [EOL] [comment] [EOL] directories = [ path for path in paths if os . path . isdir ( path ) ] [EOL] [EOL] [comment] [EOL] files = [ path for path in paths if not os . path . isdir ( path ) ] [EOL] [EOL] [comment] [EOL] directories . extend ( [ os . path . dirname ( file ) for file in files ] ) [EOL] [EOL] return directories [EOL] [EOL] [EOL] def calc_repo_path ( path ) : [EOL] [docstring] [EOL] byte_output = subprocess . check_output ( [ [string] , [string] , [string] , [string] , [string] ] , cwd = path ) [EOL] output = byte_output . decode ( [string] , errors = [string] ) [EOL] match = re . search ( GIT_REPO_REGEX , output ) [EOL] if match : [EOL] repo_name = match . group ( [number] ) [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] return [string] % ( repo_name , path [ path . index ( [string] ) + [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Optional , List , Any [EOL] import terrawrap [EOL] import networkx [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import sys [EOL] from typing import Dict , List , Optional , Tuple [EOL] import networkx [EOL] [EOL] import hcl2 [EOL] import jsons [EOL] import yaml [EOL] from ssm_cache import SSMParameterGroup [EOL] [EOL] from terrawrap . exceptions import NotTerraformConfigDirectory [EOL] from terrawrap . models . wrapper_config import ( WrapperConfig , AbstractEnvVarConfig , SSMEnvVarConfig , TextEnvVarConfig , BackendsConfig ) [EOL] from terrawrap . utils . collection_utils import update [EOL] from terrawrap . utils . path import get_absolute_path , calc_repo_path [EOL] [EOL] DEFAULT_REGION = [string] [EOL] SSM_ENVVAR_CACHE = SSMParameterGroup ( max_age = [number] ) [EOL] [EOL] [EOL] def find_variable_files ( path ) : [EOL] [docstring] [EOL] variable_files = [ ] [EOL] [EOL] elements = path . split ( os . path . sep ) [EOL] [EOL] cur_path = os . path . sep [EOL] [EOL] for element in elements : [EOL] cur_path = os . path . join ( cur_path , element ) [EOL] for file in os . listdir ( cur_path ) : [EOL] if file . endswith ( [string] ) : [EOL] variable_files . append ( os . path . join ( cur_path , file ) ) [EOL] [EOL] return variable_files [EOL] [EOL] [EOL] def find_wrapper_config_files ( path ) : [EOL] [docstring] [EOL] wrapper_config_files = [ ] [EOL] [EOL] elements = path . split ( os . path . sep ) [EOL] [EOL] cur_path = os . path . sep [EOL] [EOL] for element in elements : [EOL] cur_path = os . path . join ( cur_path , element ) [EOL] for file in os . listdir ( cur_path ) : [EOL] if file . endswith ( [string] ) or file . endswith ( [string] ) : [EOL] wrapper_config_files . append ( os . path . join ( cur_path , file ) ) [EOL] [EOL] return wrapper_config_files [EOL] [EOL] [EOL] def parse_wrapper_configs ( wrapper_config_files ) : [EOL] [docstring] [EOL] generated_wrapper_config = { } [EOL] [EOL] for wrapper_config_path in wrapper_config_files : [EOL] with open ( wrapper_config_path ) as wrapper_config_file : [EOL] wrapper_config = yaml . safe_load ( wrapper_config_file ) [EOL] if wrapper_config and isinstance ( wrapper_config , dict ) : [EOL] generated_wrapper_config = update ( generated_wrapper_config , wrapper_config ) [EOL] [EOL] wrapper_config_obj = jsons . load ( generated_wrapper_config , WrapperConfig , strict = True ) [EOL] return wrapper_config_obj [EOL] [EOL] [EOL] def is_config_directory ( directory ) : [EOL] [docstring] [EOL] config = False [EOL] for file in os . listdir ( directory ) : [EOL] if file . endswith ( [string] ) : [EOL] config = True [EOL] return config [EOL] [EOL] [EOL] def create_wrapper_config_obj ( config_dir , wrapper_file = None ) : [EOL] [docstring] [EOL] if not wrapper_file : [EOL] for file in os . listdir ( config_dir ) : [EOL] if file . endswith ( [string] ) : [EOL] wrapper_file = os . path . join ( config_dir , file ) [EOL] [EOL] wrapper_config_obj = parse_wrapper_configs ( [ wrapper_file ] ) [EOL] if wrapper_config_obj . depends_on : [EOL] depends_on = [ ] [EOL] for dependency in wrapper_config_obj . depends_on : [EOL] abs_dependency = get_absolute_path ( dependency ) [EOL] if not os . path . isdir ( abs_dependency ) : [EOL] abs_dependency = get_absolute_path ( dependency , config_dir ) [EOL] depends_on . append ( abs_dependency ) [EOL] wrapper_config_obj . depends_on = depends_on [EOL] if not is_config_directory ( config_dir ) : [EOL] wrapper_config_obj . config = False [EOL] return wrapper_config_obj [EOL] [EOL] [EOL] def walk_and_graph_directory ( starting_dir , config_dict ) : [EOL] [docstring] [EOL] graph_list = [ ] [EOL] post_graph_runs = [ ] [EOL] for root , _ , files in os . walk ( starting_dir ) : [EOL] has_tf_wrapper = False [EOL] for file in files : [EOL] if file . endswith ( [string] ) : [EOL] has_tf_wrapper = True [EOL] wrapper_file = os . path . join ( root , file ) [EOL] wrapper_config_obj = create_wrapper_config_obj ( root , wrapper_file ) [EOL] if not wrapper_config_obj . config : [EOL] continue [EOL] if not wrapper_config_obj . apply_automatically : [EOL] continue [EOL] if wrapper_config_obj . depends_on is None : [EOL] post_graph_runs . append ( root ) [EOL] continue [EOL] single_config_dependency_graph = networkx . DiGraph ( ) [EOL] visited = [ ] [EOL] graph_wrapper_dependencies ( root , config_dict , single_config_dependency_graph , visited ) [EOL] graph_list . append ( single_config_dependency_graph ) [EOL] if not has_tf_wrapper and is_config_directory ( root ) : [EOL] post_graph_runs . append ( root ) [EOL] directory_graph = networkx . compose_all ( graph_list ) [EOL] [EOL] return directory_graph , post_graph_runs [EOL] [EOL] [EOL] def walk_without_graph_directory ( starting_dir ) : [EOL] [docstring] [EOL] post_graph_runs = [ ] [EOL] for root , _ , files in os . walk ( starting_dir ) : [EOL] has_tf_wrapper = False [EOL] for file in files : [EOL] if file . endswith ( [string] ) : [EOL] has_tf_wrapper = True [EOL] wrapper_file = os . path . join ( root , file ) [EOL] wrapper_config_obj = create_wrapper_config_obj ( root , wrapper_file ) [EOL] if wrapper_config_obj . depends_on is not None : [EOL] raise ValueError ( [string] ) [EOL] if not wrapper_config_obj . config : [EOL] continue [EOL] if not wrapper_config_obj . apply_automatically : [EOL] continue [EOL] post_graph_runs . append ( root ) [EOL] if not has_tf_wrapper and is_config_directory ( root ) : [EOL] post_graph_runs . append ( root ) [EOL] [EOL] return post_graph_runs [EOL] [EOL] [EOL] [comment] [EOL] def graph_wrapper_dependencies ( config_dir , config_dict , graph , visited ) : [EOL] [docstring] [EOL] if config_dir in visited : [EOL] return [EOL] visited . append ( config_dir ) [EOL] [EOL] if config_dict . get ( config_dir ) : [comment] [EOL] wrapper_config_obj = config_dict [ config_dir ] . get ( [string] ) [EOL] else : [EOL] wrapper_config_obj = create_wrapper_config_obj ( config_dir ) [EOL] config_dict [ config_dir ] = { [string] : wrapper_config_obj } [EOL] [EOL] if wrapper_config_obj . config : [EOL] graph . add_node ( config_dir ) [EOL] [EOL] tf_dependencies = wrapper_config_obj . depends_on [EOL] [EOL] if tf_dependencies is None : [EOL] print ( [string] , config_dir ) [EOL] sys . exit ( [number] ) [EOL] [EOL] for dependency in tf_dependencies : [EOL] graph . add_node ( dependency ) [EOL] if config_dir in graph : [EOL] graph . add_edge ( dependency , config_dir ) [EOL] [EOL] wrappers = find_wrapper_config_files ( config_dir ) [EOL] wrappers . reverse ( ) [comment] [EOL] for wrapper in wrappers : [EOL] wrapper_dir = os . path . dirname ( wrapper ) [EOL] if config_dict . get ( wrapper_dir ) : [comment] [EOL] new_wrapper_config_obj = config_dict [ wrapper_dir ] . get ( [string] ) [EOL] else : [EOL] new_wrapper_config_obj = create_wrapper_config_obj ( wrapper_dir ) [EOL] config_dict [ wrapper_dir ] = { [string] : new_wrapper_config_obj } [EOL] [EOL] if wrapper_dir == config_dir : [EOL] continue [EOL] if new_wrapper_config_obj . depends_on is not None : [EOL] inherited_dependencies = new_wrapper_config_obj . depends_on [EOL] added = False [EOL] for dependency in inherited_dependencies : [EOL] if dependency == config_dir : [EOL] continue [EOL] added = True [EOL] graph . add_node ( dependency ) [EOL] if config_dir in graph : [EOL] graph . add_edge ( dependency , config_dir ) [EOL] if added : [EOL] break [comment] [EOL] [EOL] for predecessor in list ( graph . predecessors ( config_dir ) ) : [EOL] graph_wrapper_dependencies ( predecessor , config_dict , graph , visited ) [EOL] [EOL] [EOL] def resolve_envvars ( envvar_configs ) : [EOL] [docstring] [EOL] resolved_envvars = { } [EOL] for envvar_name , envvar_config in envvar_configs . items ( ) : [EOL] if isinstance ( envvar_config , SSMEnvVarConfig ) : [EOL] resolved_envvars [ envvar_name ] = SSM_ENVVAR_CACHE . parameter ( envvar_config . path ) . value [EOL] if isinstance ( envvar_config , TextEnvVarConfig ) : [EOL] resolved_envvars [ envvar_name ] = envvar_config . value [EOL] return resolved_envvars [EOL] [EOL] [EOL] def calc_backend_config ( path , variables , wrapper_config , existing_backend_config ) : [EOL] [docstring] [EOL] [EOL] backend_config = [ [string] ] [EOL] options = { } [EOL] repo_path = calc_repo_path ( path = path ) [EOL] [EOL] [comment] [EOL] if existing_backend_config . s3 is not None : [EOL] terraform_bucket = [string] . format ( region = variables . get ( [string] ) , account_short_name = variables . get ( [string] ) ) [EOL] [EOL] options = { [string] : variables . get ( [string] , [string] ) , [string] : [string] , [string] : [string] % repo_path , [string] : variables . get ( [string] , [string] ) , [string] : variables . get ( [string] , terraform_bucket ) , [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] if wrapper_config . backends : [EOL] wrapper_options = { } [EOL] if existing_backend_config . gcs is not None and wrapper_config . backends . gcs is not None : [EOL] [comment] [EOL] wrapper_options = vars ( wrapper_config . backends . gcs ) [EOL] wrapper_options [ [string] ] = repo_path [EOL] if existing_backend_config . s3 is not None and wrapper_config . backends . s3 is not None : [EOL] wrapper_options = vars ( wrapper_config . backends . s3 ) [EOL] options . update ( { key : value for key , value in wrapper_options . items ( ) if value is not None } ) [EOL] [EOL] backend_config . extend ( [ [string] % ( key , value ) for key , value in options . items ( ) ] ) [EOL] return backend_config [EOL] [EOL] [EOL] def parse_variable_files ( variable_files ) : [EOL] [docstring] [EOL] variables = { } [EOL] [EOL] for variable_file in variable_files : [EOL] with open ( variable_file ) as var_file : [EOL] flat_vars = { key : values [ [number] ] for key , values in hcl2 . load ( var_file ) . items ( ) } [EOL] variables . update ( flat_vars ) [EOL] [EOL] return variables [EOL] [EOL] [EOL] def parse_backend_config_for_dir ( dir_path ) : [EOL] [docstring] [EOL] has_tf_files = False [EOL] for file_path in os . listdir ( dir_path ) : [EOL] if [string] in file_path or not file_path . endswith ( [string] ) : [EOL] continue [EOL] [EOL] has_tf_files = True [EOL] [EOL] result = _parse_backend_config_for_file ( file_path = os . path . join ( dir_path , file_path ) , ) [EOL] if result : [EOL] return result [EOL] [EOL] if not has_tf_files : [EOL] raise NotTerraformConfigDirectory ( ) [EOL] [EOL] return None [EOL] [EOL] [EOL] def _parse_backend_config_for_file ( file_path ) : [EOL] with open ( file_path ) as tf_file : [EOL] try : [EOL] configs = hcl2 . load ( tf_file ) [EOL] [EOL] terraform_config_blocks = configs . get ( [string] , [ ] ) [EOL] for terraform_config in terraform_config_blocks : [EOL] if [string] in terraform_config : [EOL] return jsons . load ( terraform_config [ [string] ] [ [number] ] , BackendsConfig , strict = True ) [EOL] return None [EOL] except Exception : [EOL] print ( [string] % file_path ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[networkx.DiGraph,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.wrapper_config.BackendsConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.wrapper_config.BackendsConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Dict [EOL] import terrawrap [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from enum import Enum [EOL] from typing import Dict , Optional , List [EOL] [EOL] import jsons [EOL] [EOL] [EOL] class EnvVarSource ( Enum ) : [EOL] SSM = [string] [EOL] TEXT = [string] [EOL] [EOL] [EOL] class AbstractEnvVarConfig : [EOL] def __init__ ( self , source ) : [EOL] self . source = source [EOL] [EOL] [EOL] class SSMEnvVarConfig ( AbstractEnvVarConfig ) : [EOL] def __init__ ( self , path ) : [EOL] super ( ) . __init__ ( EnvVarSource . SSM ) [EOL] self . path = path [EOL] [EOL] [EOL] class TextEnvVarConfig ( AbstractEnvVarConfig ) : [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( EnvVarSource . TEXT ) [EOL] self . value = value [EOL] [EOL] [EOL] class S3BackendConfig : [EOL] def __init__ ( self , bucket , region , dynamodb_table = None , role_arn = None ) : [EOL] self . region = region [EOL] self . bucket = bucket [EOL] self . dynamodb_table = dynamodb_table [EOL] self . role_arn = role_arn [EOL] [EOL] [EOL] class GCSBackendConfig : [EOL] def __init__ ( self , bucket ) : [EOL] self . bucket = bucket [EOL] [EOL] [EOL] class BackendsConfig : [EOL] [comment] [EOL] def __init__ ( self , s3 = None , gcs = None ) : [EOL] self . s3 = s3 [EOL] self . gcs = gcs [EOL] [EOL] [EOL] [comment] [EOL] def env_var_deserializer ( obj_dict , cls , ** kwargs ) : [EOL] [docstring] [EOL] if obj_dict [ [string] ] == EnvVarSource . SSM . value : [EOL] return SSMEnvVarConfig ( obj_dict [ [string] ] ) [EOL] if obj_dict [ [string] ] == EnvVarSource . TEXT . value : [EOL] return TextEnvVarConfig ( obj_dict [ [string] ] ) [EOL] [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] jsons . set_deserializer ( env_var_deserializer , AbstractEnvVarConfig ) [EOL] [EOL] [EOL] [comment] [EOL] class WrapperConfig : [EOL] def __init__ ( self , configure_backend = True , pipeline_check = True , backend_check = True , plan_check = True , envvars = None , backends = None , depends_on = None , config = True , apply_automatically = True , plugins = None ) : [EOL] self . configure_backend = configure_backend [EOL] self . pipeline_check = pipeline_check [EOL] self . backend_check = backend_check [EOL] self . plan_check = plan_check [EOL] self . envvars = envvars or { } [EOL] self . backends = backends [EOL] self . depends_on = depends_on [EOL] self . config = config [EOL] self . apply_automatically = apply_automatically [EOL] self . plugins = plugins or { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.BackendsConfig$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.BackendsConfig$ 0 $terrawrap.models.wrapper_config.BackendsConfig$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0
from typing import Iterable , Tuple , Dict , Optional , List , Any [EOL] import csv [EOL] import builtins [EOL] import typing [EOL] import terrawrap [EOL] import concurrent [EOL] import pathlib [EOL] [docstring] [EOL] import concurrent . futures [EOL] import csv [EOL] from collections import defaultdict [EOL] from pathlib import Path [EOL] from typing import Iterable , Optional , List , DefaultDict [EOL] [EOL] from terrawrap . models . pipeline_entry import PipelineEntry [EOL] [EOL] [EOL] class Pipeline : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , command , pipeline_path ) : [EOL] [docstring] [EOL] self . command = command [EOL] [EOL] self . reverse_pipeline = command == [string] [EOL] [EOL] if not pipeline_path . endswith ( [string] ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] with open ( pipeline_path ) as pipeline_file : [EOL] reader = csv . DictReader ( pipeline_file ) [EOL] [comment] [EOL] [comment] [EOL] entries = defaultdict ( lambda : defaultdict ( list ) ) [EOL] [EOL] for row in reader : [EOL] entry = PipelineEntry ( path = row [ [string] ] , variables = row [ [string] ] . split ( [string] ) if row [ [string] ] else [ ] ) [EOL] seq = int ( row [ [string] ] ) [EOL] path = Path ( row [ [string] ] ) [EOL] if not path . is_symlink ( ) : [EOL] entries [ seq ] [ [string] ] . append ( entry ) [EOL] else : [EOL] entries [ seq ] [ [string] ] . append ( entry ) [EOL] [EOL] self . entries = entries [EOL] [EOL] def execute ( self , num_parallel = [number] , debug = False , print_only_changes = False ) : [EOL] [docstring] [EOL] for sequence in sorted ( self . entries . keys ( ) , reverse = self . reverse_pipeline ) : [EOL] print ( [string] % sequence ) [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = num_parallel ) as executor : [EOL] self . _execute_entries ( command = self . command , entries = self . entries [ sequence ] [ [string] ] , debug = debug , executor = executor , print_only_changes = print_only_changes , ) [EOL] [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) as executor : [EOL] for entry in self . entries [ sequence ] [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _execute_entries ( command = self . command , entries = [ entry ] , debug = debug , executor = executor , print_only_changes = print_only_changes , ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def _execute_entries ( self , entries , executor , command = None , debug = False , print_only_changes = False , ) : [EOL] [docstring] [EOL] command = command or self . command [EOL] futures_to_paths = { } [EOL] failures = [ ] [EOL] [EOL] for entry in entries : [EOL] print ( [string] % ( entry . path , command ) ) [EOL] future = executor . submit ( entry . execute , command , debug = debug ) [EOL] futures_to_paths [ future ] = entry . path [EOL] [EOL] for future in concurrent . futures . as_completed ( futures_to_paths ) : [EOL] exit_code , stdout , changes_detected = future . result ( ) [EOL] path = futures_to_paths [ future ] [EOL] [EOL] if print_only_changes and not changes_detected : [EOL] stdout = [ [string] ] [EOL] [EOL] print ( [string] % ( path , command ) ) [EOL] print ( [string] % [string] . join ( stdout ) . strip ( ) ) [EOL] [EOL] if exit_code != [number] : [EOL] failures . append ( path ) [EOL] [EOL] if failures : [EOL] raise RuntimeError ( [string] % ( command , [string] . join ( failures ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[terrawrap.models.pipeline_entry.PipelineEntry]$ 0 $concurrent.futures.Executor$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Iterable[terrawrap.models.pipeline_entry.PipelineEntry]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 $concurrent.futures._base.Future[typing.Tuple[builtins.int,typing.List[builtins.str],builtins.bool]]$ 0 $concurrent.futures.Executor$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Tuple[builtins.int,typing.List[builtins.str],builtins.bool]]$ 0 0 0 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Tuple[builtins.int,typing.List[builtins.str],builtins.bool]]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $concurrent.futures._base.Future[typing.Tuple[builtins.int,typing.List[builtins.str],builtins.bool]]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Tuple[builtins.int,typing.List[builtins.str],builtins.bool]]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
from typing import List , Tuple , Dict [EOL] import terrawrap [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import tempfile [EOL] from typing import List , Tuple [EOL] [EOL] from terrawrap . utils . cli import execute_command [EOL] from terrawrap . utils . config import find_wrapper_config_files , parse_wrapper_configs , resolve_envvars [EOL] from terrawrap . utils . path import get_absolute_path [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PipelineEntry : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , variables ) : [EOL] [docstring] [EOL] self . path = get_absolute_path ( path = path ) [EOL] wrapper_config_files = find_wrapper_config_files ( self . path ) [EOL] wrapper_config = parse_wrapper_configs ( wrapper_config_files ) [EOL] self . envvars = resolve_envvars ( wrapper_config . envvars ) [EOL] self . variables = variables [EOL] [EOL] [comment] [EOL] def execute ( self , operation , debug = False ) : [EOL] [docstring] [EOL] command_env = os . environ . copy ( ) [EOL] command_env . update ( self . envvars ) [EOL] [EOL] if debug : [EOL] command_env [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] plan_file , plan_file_name = tempfile . mkstemp ( suffix = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] base_args = [ [string] , [string] , self . path ] [EOL] init_args = base_args + [ [string] ] + self . variables [EOL] plan_args = base_args + [ [string] , [string] , [string] % plan_file_name ] + self . variables [EOL] operation_args = base_args + [ operation ] + self . variables [EOL] [EOL] if operation in [ [string] , [string] ] : [EOL] operation_args += [ [string] ] [EOL] [EOL] init_exit_code , output = execute_command ( init_args , print_output = False , capture_stderr = True , env = command_env , ) [EOL] [EOL] if init_exit_code != [number] : [EOL] return init_exit_code , output , True [EOL] [EOL] [comment] [EOL] if operation in [ [string] ] : [EOL] plan_exit_code , plan_stdout = execute_command ( plan_args , print_output = False , capture_stderr = True , env = command_env ) [EOL] [EOL] output += [ [string] ] + plan_stdout [EOL] [EOL] if plan_exit_code != [number] : [EOL] return ( plan_exit_code , output , False , ) [EOL] [EOL] operation_args += [ plan_file_name ] [EOL] [EOL] if operation in [ [string] ] : [EOL] operation_args += [ [string] ] [EOL] [EOL] operation_exit_code , operation_stdout = execute_command ( operation_args , print_output = False , capture_stderr = True , env = command_env ) [EOL] [EOL] output += [ [string] ] + operation_stdout [EOL] [EOL] changes_detected = True [EOL] if operation in [ [string] ] : [EOL] if operation_exit_code == [number] : [EOL] [comment] [EOL] operation_exit_code = [number] [EOL] elif operation_exit_code != [number] : [EOL] changes_detected = False [EOL] [EOL] return ( operation_exit_code , output , changes_detected , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.List[builtins.str],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0
	0
from typing import Dict , Set , Optional , List , Any [EOL] import builtins [EOL] import typing [EOL] import terrawrap [EOL] import concurrent [EOL] import networkx [EOL] [docstring] [EOL] import concurrent . futures [EOL] from typing import List , Dict , Set [EOL] [EOL] import networkx [EOL] [EOL] from terrawrap . utils . graph import find_source_nodes [EOL] from terrawrap . models . graph_entry import GraphEntry [EOL] [EOL] [EOL] class ApplyGraph : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , command , graph , post_graph , prefix ) : [EOL] [docstring] [EOL] self . command = command [EOL] self . graph = graph [EOL] self . graph_dict = { } [EOL] self . post_graph = post_graph [EOL] self . prefix = prefix [EOL] self . not_applied = set ( ) [EOL] self . failures = [ ] [EOL] [EOL] [comment] [EOL] def execute_graph ( self , num_parallel = [number] , debug = False , print_only_changes = False ) : [EOL] [docstring] [EOL] sources = find_source_nodes ( self . graph ) [EOL] futures_to_paths = { } [EOL] [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = num_parallel ) as executor : [EOL] for source in sources : [EOL] entry = self . _get_or_create_entry ( source ) [EOL] if not self . _has_prefix ( entry ) : [EOL] future = executor . submit ( entry . no_op ) [EOL] futures_to_paths [ future ] = entry . path [EOL] continue [EOL] [EOL] print ( [string] % ( entry . path , self . command ) ) [EOL] future = executor . submit ( entry . execute , self . command , debug = debug ) [EOL] futures_to_paths [ future ] = entry . path [EOL] [EOL] for future in concurrent . futures . as_completed ( futures_to_paths ) : [EOL] path = futures_to_paths [ future ] [EOL] if self . _get_or_create_entry ( path ) . state != [string] : [EOL] exit_code , stdout , changes_detected = future . result ( ) [EOL] [EOL] if print_only_changes and not changes_detected : [EOL] stdout = [ [string] ] [EOL] [EOL] print ( [string] % ( path , self . command ) ) [EOL] print ( [string] % [string] . join ( stdout ) . strip ( ) ) [EOL] [EOL] if exit_code != [number] : [EOL] self . failures . append ( path ) [EOL] [EOL] successors = list ( self . graph . successors ( path ) ) [EOL] if successors : [EOL] self . recursive_executor ( executor , successors , num_parallel , debug , print_only_changes ) [EOL] [EOL] for node in self . graph : [EOL] item = self . graph_dict . get ( node ) [EOL] if not item : [EOL] self . not_applied . add ( node ) [EOL] else : [EOL] if item . state == [string] : [EOL] self . not_applied . add ( item . path ) [EOL] [EOL] def recursive_executor ( self , executor , successors , num_parallel , debug , print_only_changes ) : [EOL] [docstring] [EOL] futures_to_paths = { } [EOL] [EOL] for node in successors : [EOL] entry = self . _get_or_create_entry ( node ) [EOL] if entry . state != [string] : [EOL] continue [EOL] if not self . _can_be_applied ( entry ) : [EOL] continue [EOL] [EOL] if not self . _has_prefix ( entry ) : [EOL] future = executor . submit ( entry . no_op ) [EOL] futures_to_paths [ future ] = entry . path [EOL] continue [EOL] [EOL] future = executor . submit ( entry . execute , self . command , debug = debug ) [EOL] futures_to_paths [ future ] = entry . path [EOL] [EOL] for future in concurrent . futures . as_completed ( futures_to_paths ) : [EOL] [EOL] path = futures_to_paths [ future ] [EOL] if self . graph_dict [ path ] . state != [string] : [EOL] exit_code , stdout , changes_detected = future . result ( ) [EOL] [EOL] if print_only_changes and not changes_detected : [EOL] stdout = [ [string] ] [EOL] [EOL] print ( [string] % ( path , self . command ) ) [EOL] print ( [string] % [string] . join ( stdout ) . strip ( ) ) [EOL] if exit_code != [number] : [EOL] self . failures . append ( path ) [EOL] [EOL] next_successors = list ( self . graph . successors ( path ) ) [EOL] if next_successors : [EOL] self . recursive_executor ( executor , next_successors , num_parallel , debug , print_only_changes ) [EOL] [EOL] def execute_post_graph ( self , num_parallel = [number] , debug = False , print_only_changes = False ) : [EOL] [docstring] [EOL] futures_to_paths = { } [EOL] [EOL] with concurrent . futures . ThreadPoolExecutor ( max_workers = num_parallel ) as executor : [EOL] for node in self . post_graph : [EOL] entry = self . _get_or_create_entry ( node ) [EOL] if not self . _has_prefix ( entry ) : [EOL] future = executor . submit ( entry . no_op ) [EOL] futures_to_paths [ future ] = entry . path [EOL] continue [EOL] [EOL] future = executor . submit ( entry . execute , self . command , debug = debug ) [EOL] futures_to_paths [ future ] = entry . path [EOL] [EOL] for future in concurrent . futures . as_completed ( futures_to_paths ) : [EOL] [EOL] path = futures_to_paths [ future ] [EOL] if self . graph_dict [ path ] . state != [string] : [EOL] [EOL] exit_code , stdout , changes_detected = future . result ( ) [EOL] [EOL] if print_only_changes and not changes_detected : [EOL] stdout = [ [string] ] [EOL] [EOL] print ( [string] % ( path , self . command ) ) [EOL] print ( [string] % [string] . join ( stdout ) . strip ( ) ) [EOL] [EOL] if exit_code != [number] : [EOL] self . failures . append ( path ) [EOL] [EOL] for node in self . post_graph : [EOL] item = self . graph_dict . get ( node ) [EOL] if not item : [EOL] self . not_applied . add ( node ) [EOL] else : [EOL] if item . state == [string] : [EOL] self . not_applied . add ( item . path ) [EOL] [EOL] def _can_be_applied ( self , entry ) : [EOL] [docstring] [EOL] if entry : [EOL] path = entry . path [EOL] predecessors = list ( self . graph . predecessors ( path ) ) [EOL] [EOL] for predecessor in predecessors : [EOL] pred_entry = self . graph_dict . get ( predecessor ) [EOL] [EOL] if pred_entry : [EOL] if pred_entry . state not in ( [string] , [string] ) : [EOL] return False [EOL] else : [EOL] return False [EOL] [EOL] else : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def _get_or_create_entry ( self , node ) : [EOL] [docstring] [EOL] if self . graph_dict . get ( node ) : [EOL] entry = self . graph_dict . get ( node ) [EOL] else : [EOL] entry = GraphEntry ( node , [ ] ) [EOL] self . graph_dict [ node ] = entry [EOL] return entry [EOL] [EOL] def _has_prefix ( self , entry ) : [EOL] [docstring] [EOL] if not entry . path . startswith ( self . prefix ) : [EOL] return False [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $concurrent.futures.Executor$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 $concurrent.futures.Executor$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 $concurrent.futures.Executor$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $concurrent.futures.Executor$ 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 $typing.Optional[terrawrap.models.graph_entry.GraphEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 0 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 0 0 0 0 $terrawrap.models.graph_entry.GraphEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import List , Any , Dict [EOL] import terrawrap [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] from unittest import TestCase [EOL] [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] import networkx [EOL] [EOL] from terrawrap . models . wrapper_config import WrapperConfig , BackendsConfig , S3BackendConfig [EOL] from terrawrap . utils . config import ( calc_backend_config , parse_wrapper_configs , find_wrapper_config_files , resolve_envvars , graph_wrapper_dependencies , walk_and_graph_directory , walk_without_graph_directory ) [EOL] [EOL] ROLE_ARN = [string] [EOL] BUCKET = [string] [EOL] REGION = [string] [EOL] LOCK_TABLE = [string] [EOL] [EOL] [EOL] class TestConfig ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . prev_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . normpath ( os . path . dirname ( __file__ ) + [string] ) ) [EOL] self . config_dict = { } [EOL] [EOL] def test_graph_wrapper_dependencies ( self ) : [EOL] [docstring] [EOL] actual_graph = networkx . DiGraph ( ) [EOL] visited = [ ] [EOL] current_dir = os . path . join ( os . getcwd ( ) , [string] ) [EOL] graph_wrapper_dependencies ( current_dir , self . config_dict , actual_graph , visited ) [EOL] [EOL] expected_graph = networkx . DiGraph ( ) [EOL] app3 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app1 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] expected_graph . add_node ( app3 ) [EOL] expected_graph . add_node ( app1 ) [EOL] expected_graph . add_edge ( app1 , app3 ) [EOL] [EOL] self . assertTrue ( networkx . is_isomorphic ( actual_graph , expected_graph ) ) [EOL] [EOL] def test_walk_and_graph_directory ( self ) : [EOL] [docstring] [EOL] starting_dir = os . path . join ( os . getcwd ( ) , [string] ) [EOL] actual_graph , actual_post_graph = walk_and_graph_directory ( starting_dir , self . config_dict ) [EOL] [EOL] expected_graph = networkx . DiGraph ( ) [EOL] app1 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app2 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app4 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app5 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app9 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] expected_graph . add_nodes_from ( [ app1 , app2 , app4 , app5 ] ) [EOL] expected_graph . add_edge ( app4 , app5 ) [EOL] expected_graph . add_edge ( app2 , app4 ) [EOL] expected_graph . add_edge ( app1 , app2 ) [EOL] expected_post_graph = [ os . path . join ( os . getcwd ( ) , [string] ) ] [EOL] [EOL] self . assertTrue ( networkx . is_isomorphic ( actual_graph , expected_graph ) ) [EOL] self . assertEqual ( actual_post_graph , expected_post_graph ) [EOL] self . assertTrue ( app9 not in actual_graph . nodes ) [EOL] self . assertTrue ( app9 not in actual_post_graph ) [EOL] [EOL] def test_walk_without_graph_directory ( self ) : [EOL] [docstring] [EOL] starting_dir = os . path . join ( os . getcwd ( ) , [string] ) [EOL] actual_post_graph = walk_without_graph_directory ( starting_dir ) [EOL] [EOL] app1 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app2 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] [EOL] app_team_4 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] [EOL] expected_post_graph = [ app1 , app2 , app_team_4 ] [EOL] [EOL] expected_post_graph . sort ( ) [EOL] actual_post_graph . sort ( ) [EOL] [EOL] self . assertEqual ( actual_post_graph , expected_post_graph ) [EOL] [EOL] def wont_apply_automatically_in_parrallel ( self ) : [EOL] [docstring] [EOL] starting_dir = os . path . join ( os . getcwd ( ) , [string] ) [EOL] actual_post_graph = walk_without_graph_directory ( starting_dir ) [EOL] [EOL] app1 = os . path . join ( starting_dir , [string] ) [EOL] app3 = os . path . join ( starting_dir , [string] ) [EOL] app4 = os . path . join ( starting_dir , [string] ) [EOL] app7 = os . path . join ( starting_dir , [string] ) [EOL] [EOL] expected_post_graph = [ app1 , app3 , app4 ] [EOL] [EOL] expected_post_graph . sort ( ) [EOL] actual_post_graph . sort ( ) [EOL] [EOL] self . assertEqual ( actual_post_graph , expected_post_graph ) [EOL] self . assertTrue ( app7 not in actual_post_graph ) [EOL] [EOL] def test_calc_backend_config ( self ) : [EOL] [docstring] [EOL] actual_config = calc_backend_config ( [string] , { [string] : REGION , [string] : [string] , } , WrapperConfig ( ) , BackendsConfig ( s3 = S3BackendConfig ( bucket = BUCKET , region = REGION ) ) ) [EOL] [EOL] expected_config = [ [string] , ( [string] % LOCK_TABLE ) , [string] , [string] , ( [string] % REGION ) , ( [string] % BUCKET ) , [string] , [string] ] [EOL] [EOL] self . assertEqual ( expected_config , actual_config ) [EOL] [EOL] def test_calc_backend_config_wrapper_config ( self ) : [EOL] [docstring] [EOL] wrapper_config = WrapperConfig ( backends = BackendsConfig ( s3 = S3BackendConfig ( bucket = BUCKET , region = REGION ) ) ) [EOL] [EOL] actual_config = calc_backend_config ( [string] , { } , wrapper_config , BackendsConfig ( s3 = S3BackendConfig ( bucket = BUCKET , region = REGION ) ) ) [EOL] [EOL] expected_config = [ [string] , [string] % LOCK_TABLE , [string] , [string] , [string] % REGION , [string] % BUCKET , [string] , [string] ] [EOL] [EOL] self . assertEqual ( expected_config , actual_config ) [EOL] [EOL] def test_calc_backend_config_with_role_arn ( self ) : [EOL] [docstring] [EOL] wrapper_config = WrapperConfig ( backends = BackendsConfig ( s3 = S3BackendConfig ( bucket = BUCKET , region = REGION , role_arn = ROLE_ARN ) ) ) [EOL] [EOL] actual_config = calc_backend_config ( [string] , { } , wrapper_config , BackendsConfig ( s3 = S3BackendConfig ( bucket = BUCKET , region = REGION ) ) ) [EOL] [EOL] expected_config = [ [string] , [string] % LOCK_TABLE , [string] , [string] , [string] % REGION , [string] % BUCKET , [string] , [string] , [string] % ROLE_ARN ] [EOL] [EOL] self . assertEqual ( expected_config , actual_config ) [EOL] [EOL] def test_find_wrapper_configs ( self ) : [EOL] [docstring] [EOL] actual_config_files = find_wrapper_config_files ( os . path . join ( os . getcwd ( ) , [string] ) ) [EOL] expected_config_files = [ os . path . join ( os . getcwd ( ) , [string] ) , os . path . join ( os . getcwd ( ) , [string] ) , ] [EOL] [EOL] self . assertEqual ( expected_config_files , actual_config_files ) [EOL] [EOL] def test_parse_wrapper_config ( self ) : [EOL] [docstring] [EOL] wrapper_config = parse_wrapper_configs ( wrapper_config_files = [ os . path . join ( os . getcwd ( ) , [string] ) , os . path . join ( os . getcwd ( ) , [string] ) , ] ) [EOL] [EOL] self . assertEqual ( [string] , wrapper_config . envvars [ [string] ] . value ) [EOL] self . assertEqual ( [string] , wrapper_config . envvars [ [string] ] . value ) [EOL] self . assertEqual ( [string] , wrapper_config . envvars [ [string] ] . path ) [EOL] [EOL] @ patch ( [string] ) def test_resolve_envvars_from_wrapper_config ( self , mock_ssm_cache ) : [EOL] [docstring] [EOL] mock_ssm_cache . parameter . return_value = MagicMock ( value = [string] ) [EOL] wrapper_config = parse_wrapper_configs ( wrapper_config_files = [ os . path . join ( os . getcwd ( ) , [string] ) , os . path . join ( os . getcwd ( ) , [string] ) , ] ) [EOL] [EOL] actual_envvars = resolve_envvars ( wrapper_config . envvars ) [EOL] [EOL] self . assertEqual ( [string] , actual_envvars [ [string] ] ) [EOL] self . assertEqual ( [string] , actual_envvars [ [string] ] ) [EOL] self . assertEqual ( [string] , actual_envvars [ [string] ] ) [EOL] mock_ssm_cache . parameter . assert_called_once_with ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $terrawrap.models.wrapper_config.WrapperConfig$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List [EOL] import terrawrap [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] import os [EOL] [EOL] from mock import patch , call [EOL] import networkx [EOL] [EOL] from terrawrap . models . graph import ApplyGraph [EOL] [EOL] [EOL] class TestApplyGraph ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . prev_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . normpath ( os . path . dirname ( __file__ ) + [string] ) ) [EOL] self . graph = networkx . DiGraph ( ) [EOL] self . graph . add_nodes_from ( [ [string] ] ) [EOL] self . post_graph = [ [string] ] [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . prev_dir ) [EOL] [EOL] @ patch ( [string] ) def test_execute ( self , graph_entry_class ) : [EOL] [docstring] [EOL] graph_entry_class . return_value . state = [string] [EOL] graph_entry_class . return_value . path = [string] [EOL] graph_entry_class . return_value . execute . return_value = ( [number] , [ [string] ] , True ) [EOL] [EOL] graph = ApplyGraph ( [string] , self . graph , [ ] , [string] ) [EOL] [EOL] graph . execute_graph ( ) [EOL] graph . execute_post_graph ( ) [EOL] [EOL] self . assertEqual ( graph_entry_class . return_value . execute . mock_calls , [ call ( [string] , debug = False ) ] ) [EOL] [EOL] @ patch ( [string] ) def test_no_op ( self , graph_entry_class ) : [EOL] [docstring] [EOL] graph_entry_class . return_value . state = [string] [EOL] graph_entry_class . return_value . path = [string] [EOL] graph_entry_class . return_value . execute . return_value = ( [number] , [ [string] ] , True ) [EOL] [EOL] graph = ApplyGraph ( [string] , self . graph , [ ] , [string] ) [EOL] [EOL] graph . execute_graph ( ) [EOL] graph . execute_post_graph ( ) [EOL] [EOL] expected_not_applied = { [string] } [EOL] self . assertEqual ( graph_entry_class . return_value . execute . mock_calls , [ ] ) [EOL] self . assertEqual ( graph . not_applied , expected_not_applied ) [EOL] [EOL] @ patch ( [string] ) def test_post_graph ( self , graph_entry_class ) : [EOL] [docstring] [EOL] graph_entry_class . return_value . state = [string] [EOL] graph_entry_class . return_value . path = [string] [EOL] graph_entry_class . return_value . execute . return_value = ( [number] , [ [string] ] , True ) [EOL] [EOL] graph = ApplyGraph ( [string] , self . graph , self . post_graph , [string] ) [EOL] [EOL] graph . execute_graph ( ) [EOL] graph . execute_post_graph ( ) [EOL] [EOL] self . assertEqual ( graph_entry_class . return_value . execute . mock_calls , [ ] ) [EOL] self . assertEqual ( graph . not_applied , { graph_entry_class . return_value . path } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.graph.ApplyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Optional , Dict [EOL] import terrawrap [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] import os [EOL] [EOL] from terrawrap . utils . tf_variables import ( get_auto_vars , get_nondefault_variables_for_file , get_source_for_variable , get_auto_var_usages , Variable , ) [EOL] [EOL] [EOL] class TestTerraformVariables ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . prev_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . normpath ( os . path . dirname ( __file__ ) + [string] ) ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . prev_dir ) [EOL] [EOL] def test_get_auto_vars ( self ) : [EOL] [docstring] [EOL] actual = get_auto_vars ( [string] ) [EOL] self . assertEqual ( actual , { [string] : { Variable ( [string] , [string] ) , Variable ( [string] , [string] ) , } , [string] : { Variable ( [string] , [string] ) , Variable ( [string] , [string] ) , } , [string] : { Variable ( [string] , [string] ) , Variable ( [string] , [string] ) , } , [string] : { Variable ( [string] , [string] ) , } , [string] : { Variable ( [string] , ( ( ( [string] , [string] ) , ) , ) ) , } , } ) [EOL] [EOL] def test_get_variables_for_file ( self ) : [EOL] [docstring] [EOL] actual = get_nondefault_variables_for_file ( [string] ) [EOL] [EOL] self . assertEqual ( actual , { [string] , [string] } ) [EOL] [EOL] def test_get_source_for_variable ( self ) : [EOL] [docstring] [EOL] actual = get_source_for_variable ( [string] , [string] , { [string] : { Variable ( [string] , [string] ) } , [string] : { Variable ( [string] , [string] ) } } ) [EOL] [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_get_auto_var_usages ( self ) : [EOL] [docstring] [EOL] actual = get_auto_var_usages ( [string] ) [EOL] [EOL] self . assertEqual ( actual , { [string] : { [string] , [string] } , [string] : { [string] } , [string] : { [string] } , [string] : { [string] } } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[terrawrap.utils.tf_variables.Variable]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[terrawrap.utils.tf_variables.Variable]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import terrawrap [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] import os [EOL] [EOL] from mock import patch , call [EOL] [EOL] from terrawrap . models . pipeline import Pipeline [EOL] [EOL] [EOL] class TestPipeline ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . prev_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . normpath ( os . path . dirname ( __file__ ) + [string] ) ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . prev_dir ) [EOL] [EOL] @ patch ( [string] ) def test_execute ( self , pipeline_entry_class ) : [EOL] [docstring] [EOL] pipeline_entry_class . return_value . execute . return_value = ( [number] , [ [string] ] , True ) [EOL] [EOL] pipeline = Pipeline ( [string] , [string] ) [EOL] [EOL] pipeline . execute ( ) [EOL] [EOL] self . assertEqual ( pipeline_entry_class . return_value . execute . mock_calls , [ call ( [string] , debug = False ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterable [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] from terrawrap . utils . collection_utils import flatten_collection , pick_dict_values_by_substring [EOL] [EOL] [EOL] class TestCollections ( TestCase ) : [EOL] [docstring] [EOL] def test_flatten_collection ( self ) : [EOL] [docstring] [EOL] actual = flatten_collection ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] self . assertEqual ( actual , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_pick_dict_values_by_substring ( self ) : [EOL] [docstring] [EOL] actual = pick_dict_values_by_substring ( [ [string] , [string] ] , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] self . assertEqual ( set ( actual ) , { [number] , [number] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import terrawrap [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] from unittest . mock import patch , mock_open , MagicMock , call [EOL] [EOL] import requests_mock [EOL] from botocore . exceptions import ClientError [EOL] [EOL] from terrawrap . utils . plugin_download import FileDownloadFailed , PluginDownload [EOL] [EOL] [EOL] class TestPluginDownload ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . s3_client = MagicMock ( ) [EOL] self . plugin_download = PluginDownload ( self . s3_client ) [EOL] [EOL] @ requests_mock . Mocker ( ) @ patch ( [string] , new_callable = mock_open ) @ patch ( [string] , MagicMock ( return_value = False ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( ) ) def test_file_download ( self , mock_requests , open_mock ) : [EOL] [docstring] [EOL] mock_requests . register_uri ( [string] , [string] , content = [string] ) [EOL] [EOL] self . plugin_download . _download_file ( [string] , [string] ) [EOL] [EOL] file_write_call = call ( [string] ) [EOL] [EOL] open_mock . return_value . write . assert_has_calls ( [ file_write_call ] ) [EOL] [EOL] @ requests_mock . Mocker ( ) @ patch ( [string] , new_callable = mock_open , read_data = [string] ) @ patch ( [string] , MagicMock ( return_value = True ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( ) ) def test_file_download_with_etag ( self , mock_requests , open_mock ) : [EOL] [docstring] [EOL] mock_requests . register_uri ( [string] , [string] , headers = { [string] : [string] } , content = [string] ) [EOL] [EOL] self . plugin_download . _download_file ( [string] , [string] ) [EOL] [EOL] etag_write_call = call ( [string] ) [EOL] file_write_call = call ( [string] ) [EOL] [EOL] open_mock . return_value . write . assert_has_calls ( [ file_write_call , etag_write_call ] ) [EOL] [EOL] @ requests_mock . Mocker ( ) @ patch ( [string] , new_callable = mock_open , read_data = [string] ) @ patch ( [string] , MagicMock ( return_value = True ) ) def test_file_download_cached ( self , mock_requests , open_mock ) : [EOL] [docstring] [EOL] mock_requests . register_uri ( [string] , [string] , status_code = [number] ) [EOL] [EOL] self . plugin_download . _download_file ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] open_mock . return_value . write . assert_has_calls ( [ ] ) [EOL] [EOL] @ patch ( [string] , MagicMock ( return_value = [string] ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( return_value = [string] ) ) @ patch ( [string] , MagicMock ( return_value = [string] ) ) def test_download_plugins ( self ) : [EOL] [docstring] [EOL] with ( patch . object ( self . plugin_download , [string] ) ) as download_file_mock : [EOL] self . plugin_download . download_plugins ( { [string] : [string] } ) [EOL] [EOL] download_file_mock . assert_called_with ( [string] , [string] ) [EOL] [EOL] @ patch ( [string] , MagicMock ( return_value = [string] ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( return_value = [string] ) ) @ patch ( [string] , MagicMock ( return_value = [string] ) ) def test_download_plugins_platform_missing ( self ) : [EOL] [docstring] [EOL] with ( patch . object ( self . plugin_download , [string] ) ) as download_file_mock : [EOL] def _download_mock_side_effect ( url , _ ) : [EOL] if url != [string] : [EOL] raise FileDownloadFailed ( ) [EOL] [EOL] download_file_mock . side_effect = _download_mock_side_effect [EOL] [EOL] self . plugin_download . download_plugins ( { [string] : [string] } ) [EOL] [EOL] platform_specific_call = call ( [string] , [string] ) [EOL] generic_call = call ( [string] , [string] ) [EOL] [EOL] download_file_mock . assert_has_calls ( [ platform_specific_call , generic_call ] ) [EOL] [EOL] @ patch ( [string] , new_callable = mock_open ) @ patch ( [string] , MagicMock ( return_value = False ) ) @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] , MagicMock ( ) ) def test_download_from_s3 ( self , open_mock ) : [EOL] [docstring] [EOL] mock_content = MagicMock ( ) [EOL] mock_content . read . return_value = [string] [EOL] [EOL] self . s3_client . get_object . return_value = { [string] : mock_content , [string] : [string] } [EOL] [EOL] self . plugin_download . _download_file ( [string] , [string] ) [EOL] [EOL] etag_write_call = call ( [string] ) [EOL] file_write_call = call ( [string] ) [EOL] [EOL] open_mock . return_value . write . assert_has_calls ( [ file_write_call , etag_write_call ] ) [EOL] [EOL] @ patch ( [string] , new_callable = mock_open ) @ patch ( [string] , MagicMock ( return_value = False ) ) def test_download_from_s3_cached ( self , open_mock ) : [EOL] [docstring] [EOL] self . s3_client . get_object . side_effect = ClientError ( { [string] : { [string] : [string] } } , [string] ) [EOL] [EOL] self . plugin_download . _download_file ( [string] , [string] ) [EOL] [EOL] open_mock . return_value . write . assert_has_calls ( [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $terrawrap.utils.plugin_download.PluginDownload$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock._Call$ 0 $unittest.mock._Call$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] import os [EOL] [EOL] from terrawrap . utils . module import get_module_usage_map [EOL] [EOL] [EOL] class TestModule ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . prev_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . normpath ( os . path . dirname ( __file__ ) + [string] ) ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . prev_dir ) [EOL] [EOL] def test_get_module_usage_map ( self ) : [EOL] [docstring] [EOL] actual = get_module_usage_map ( [string] ) [EOL] [EOL] self . assertEqual ( actual , { [string] : { [string] , [string] , [string] } } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from unittest import TestCase [EOL] from mock import patch [EOL] [EOL] from terrawrap . utils . cli import execute_command , MAX_RETRIES [EOL] [EOL] [EOL] class TestCli ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . popen_patcher = patch ( [string] ) [EOL] self . mock_popen = self . popen_patcher . start ( ) [EOL] self . mock_process = self . mock_popen . return_value [EOL] [EOL] self . jitter_patcher = patch ( [string] ) [EOL] self . mock_jitter = self . jitter_patcher . start ( ) [EOL] self . mock_jitter . return_value . backoff . return_value = [number] [EOL] [EOL] def tearDown ( self ) : [EOL] self . popen_patcher . stop ( ) [EOL] self . jitter_patcher . stop ( ) [EOL] [EOL] def test_execute_command ( self ) : [EOL] [docstring] [EOL] self . mock_process . poll . return_value = [number] [EOL] exit_code , stdout = execute_command ( [ [string] , [string] ] ) [EOL] [EOL] self . assertEqual ( self . mock_popen . call_count , [number] ) [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ ] ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_execute_command_retry ( self , mock_open , mock_network_error ) : [EOL] [docstring] [EOL] self . mock_process . poll . return_value = [number] [EOL] mock_network_error . side_effect = [ [ [string] ] , [ ] ] [EOL] mock_stdout_read = mock_open . return_value [EOL] mock_stdout_read . readline . return_value = [string] [EOL] [EOL] exit_code , stdout = execute_command ( [ [string] , [string] ] , retry = True ) [EOL] [EOL] self . assertEqual ( self . mock_popen . call_count , [number] ) [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ ] ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_execute_command_max_retry ( self , mock_open , mock_network_error ) : [EOL] [docstring] [EOL] self . mock_process . poll . return_value = [number] [EOL] mock_network_error . side_effect = [ [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] ] [EOL] mock_stdout_read = mock_open . return_value [EOL] mock_stdout_read . readline . return_value = [string] [EOL] [EOL] exit_code , stdout = execute_command ( [ [string] , [string] ] , retry = True ) [EOL] [EOL] self . assertEqual ( self . mock_popen . call_count , MAX_RETRIES ) [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import terrawrap [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] from mock import patch [EOL] [EOL] from terrawrap . models . pipeline_entry import PipelineEntry [EOL] [EOL] [EOL] class TestPipelineEntry ( TestCase ) : [EOL] [docstring] [EOL] [EOL] @ patch ( [string] ) def test_execute ( self , exec_command ) : [EOL] [docstring] [EOL] exec_command . side_effect = [ ( [number] , [ [string] ] ) , ( [number] , [ [string] ] ) , ] [EOL] [EOL] entry = PipelineEntry ( [string] , [ ] ) [EOL] exit_code , stdout , changes_detected = entry . execute ( [string] ) [EOL] [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( changes_detected , False ) [EOL] [EOL] @ patch ( [string] ) def test_execute_fail ( self , exec_command ) : [EOL] [docstring] [EOL] exec_command . side_effect = [ ( [number] , [ [string] ] ) ] [EOL] [EOL] entry = PipelineEntry ( [string] , [ ] ) [EOL] exit_code , stdout , changes_detected = entry . execute ( [string] ) [EOL] [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ [string] ] ) [EOL] self . assertEqual ( changes_detected , True ) [EOL] [EOL] @ patch ( [string] ) def test_execute_apply_changes ( self , exec_command ) : [EOL] [docstring] [EOL] exec_command . side_effect = [ ( [number] , [ [string] ] ) , ( [number] , [ [string] ] ) , ( [number] , [ [string] ] ) , ] [EOL] [EOL] entry = PipelineEntry ( [string] , [ ] ) [EOL] exit_code , stdout , changes_detected = entry . execute ( [string] ) [EOL] [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( changes_detected , True ) [EOL] [EOL] @ patch ( [string] ) def test_execute_apply_no_changes ( self , exec_command ) : [EOL] [docstring] [EOL] exec_command . side_effect = [ ( [number] , [ [string] ] ) , ( [number] , [ [string] ] ) , ] [EOL] [EOL] entry = PipelineEntry ( [string] , [ ] ) [EOL] exit_code , stdout , changes_detected = entry . execute ( [string] ) [EOL] [EOL] self . assertEqual ( exit_code , [number] ) [EOL] self . assertEqual ( stdout , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( changes_detected , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terrawrap.models.pipeline_entry.PipelineEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] from mock import patch , MagicMock [EOL] [EOL] from terrawrap . utils . version import version_check , get_latest_version , cache [EOL] [EOL] [EOL] class TestVersion ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] cache . clear ( ) [EOL] [EOL] @ patch ( [string] , MagicMock ( ) ) @ patch ( [string] ) def test_version_check_older ( self , mock_get_latest_version ) : [EOL] [docstring] [EOL] current_version = [string] [EOL] latest_version = [string] [EOL] mock_get_latest_version . return_value = latest_version [EOL] [EOL] response = version_check ( current_version = current_version ) [EOL] [EOL] self . assertEqual ( response , True , ) [EOL] [EOL] @ patch ( [string] ) def test_version_check_newer ( self , mock_get_latest_version ) : [EOL] [docstring] [EOL] current_version = [string] [EOL] latest_version = [string] [EOL] mock_get_latest_version . return_value = latest_version [EOL] [EOL] response = version_check ( current_version = current_version ) [EOL] [EOL] self . assertEqual ( response , False , ) [EOL] [EOL] @ patch ( [string] ) def test_version_check_equal ( self , mock_get_latest_version ) : [EOL] [docstring] [EOL] current_version = [string] [EOL] latest_version = [string] [EOL] mock_get_latest_version . return_value = latest_version [EOL] [EOL] response = version_check ( current_version = current_version ) [EOL] [EOL] self . assertEqual ( response , False , ) [EOL] [EOL] @ patch ( [string] ) def test_version_check_handles_exception ( self , mock_get_latest_version ) : [EOL] [docstring] [EOL] current_version = [string] [EOL] mock_get_latest_version . side_effect = RuntimeError [EOL] [EOL] response = version_check ( current_version = current_version ) [EOL] [EOL] self . assertEqual ( response , False , ) [EOL] [EOL] @ patch ( [string] ) def test_get_latest_version_happy ( self , mock_get ) : [EOL] [docstring] [EOL] current_version = [string] [EOL] latest_version = [string] [EOL] mock_get . return_value . json . return_value = { [string] : { [string] : latest_version } } [EOL] [EOL] response = get_latest_version ( current_version = current_version ) [EOL] [EOL] self . assertEqual ( response , latest_version , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
from typing import Literal , Tuple , Dict , Set , List , Union , Any [EOL] import pathlib [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] import os [EOL] from pathlib import Path [EOL] import networkx [EOL] [EOL] from terrawrap . utils . graph import ( find_source_nodes , has_cycle , successors , generate_dependencies , visualize , find_symlink_directories , connect_symlinks ) [EOL] [EOL] from terrawrap . utils . path import get_symlinks [EOL] [EOL] ROLE_ARN = [string] [EOL] BUCKET = [string] [EOL] REGION = [string] [EOL] LOCK_TABLE = [string] [EOL] [EOL] [EOL] class TestConfig ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . graph = networkx . DiGraph ( ) [EOL] self . graph . add_nodes_from ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . graph . add_edges_from ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [EOL] def test_find_source_nodes ( self ) : [EOL] [docstring] [EOL] actual_sources = find_source_nodes ( self . graph ) [EOL] expected_sources = [ [string] , [string] ] [EOL] self . assertEqual ( actual_sources , expected_sources ) [EOL] [EOL] def has_no_cycle ( self ) : [EOL] [docstring] [EOL] cycle = has_cycle ( self . graph ) [EOL] self . assertFalse ( cycle ) [EOL] [EOL] def test_has_source_cycle ( self ) : [EOL] [docstring] [EOL] self . graph . add_edges_from ( [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] self . assertTrue ( has_cycle ( self . graph ) ) [EOL] [EOL] def test_has_non_source_cycle ( self ) : [EOL] [docstring] [EOL] self . graph . add_edges_from ( [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] self . assertTrue ( has_cycle ( self . graph ) ) [EOL] [EOL] def test_successors ( self ) : [EOL] [docstring] [EOL] actual_successors = successors ( [number] , [string] , self . graph ) [EOL] expected_successors = ( [number] , [string] , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( actual_successors , expected_successors ) [EOL] [EOL] def test_generate_dependencies ( self ) : [EOL] [docstring] [EOL] sources = find_source_nodes ( self . graph ) [EOL] actual_dependencies = generate_dependencies ( sources , self . graph ) [EOL] expected_dependencies = [ [ ( [number] , [string] , [ [string] , [string] , [string] ] ) , ( [number] , [string] , [ ] ) , ( [number] , [string] , [ ] ) , ( [number] , [string] , [ ] ) ] , [ ( [number] , [string] , [ [string] , [string] ] ) , ( [number] , [string] , [ ] ) , ( [number] , [string] , [ ] ) ] ] [EOL] self . assertEqual ( actual_dependencies , expected_dependencies ) [EOL] [EOL] def test_visualizer ( self ) : [EOL] [docstring] [EOL] sources = find_source_nodes ( self . graph ) [EOL] dependencies = generate_dependencies ( sources , self . graph ) [EOL] visualize ( dependencies ) [EOL] [EOL] def test_symlinks ( self ) : [EOL] [docstring] [EOL] app1 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app2 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] graph = networkx . DiGraph ( ) [EOL] graph . add_nodes_from ( [ app1 , app2 ] ) [EOL] symlinks = find_symlink_directories ( graph ) [EOL] [EOL] self . assertEqual ( symlinks , [ Path ( app2 ) ] ) [EOL] [EOL] def test_connect_symlinks ( self ) : [EOL] [docstring] [EOL] app1 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] app2 = os . path . join ( os . getcwd ( ) , [string] ) [EOL] config_dir = os . path . join ( os . getcwd ( ) , [string] ) [EOL] graph = networkx . DiGraph ( ) [EOL] graph . add_nodes_from ( [ app1 , app2 ] ) [EOL] symlink_dict = get_symlinks ( config_dir ) [EOL] connect_symlinks ( graph , symlink_dict ) [EOL] [EOL] self . assertTrue ( graph . has_edge ( app1 , app2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str,typing.List[builtins.str]]$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[typing.Tuple[builtins.int,builtins.str,typing.List[typing.Any]],typing.Tuple[builtins.int,builtins.str,typing.List[builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.List[typing.Union[typing.Tuple[builtins.int,builtins.str,typing.List[typing.Any]],typing.Tuple[builtins.int,builtins.str,typing.List[builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0
from typing import Set , List , Dict [EOL] import typing [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] import os [EOL] [EOL] from terrawrap . utils . path import get_symlinks , get_directories_for_paths [EOL] [EOL] [EOL] class TestPath ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . prev_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . normpath ( os . path . dirname ( __file__ ) + [string] ) ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . prev_dir ) [EOL] [EOL] def test_get_symlinks ( self ) : [EOL] [docstring] [EOL] actual = get_symlinks ( [string] ) [EOL] self . assertEqual ( actual , { [string] : { [string] } } ) [EOL] [EOL] def test_get_directories_for_paths ( self ) : [EOL] [docstring] [EOL] [EOL] actual = get_directories_for_paths ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( actual , [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import Set , Type [EOL] import test [EOL] import typing [EOL] [docstring] [EOL] from collections import namedtuple [EOL] from unittest import TestCase [EOL] from mock import patch [EOL] [EOL] from terrawrap . utils . git_utils import get_git_changed_files [EOL] [EOL] Change = namedtuple ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class TestGit ( TestCase ) : [EOL] [docstring] [EOL] @ patch ( [string] ) def test_get_git_changed_files ( self , repo ) : [EOL] [docstring] [EOL] repo . return_value . commit . return_value . diff . return_value = [ Change ( [string] , [string] , False , False ) , Change ( None , [string] , True , False ) , Change ( [string] , None , False , True ) ] [EOL] actual = get_git_changed_files ( ) [EOL] [EOL] self . assertEqual ( actual , { [string] , [string] , [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_git.Change]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_git.Change]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_git.Change]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_git.Change]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0