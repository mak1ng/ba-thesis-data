from typing import Any , List [EOL] import typing [EOL] from setuptools import setup [EOL] import os [EOL] [EOL] [EOL] def find_stubs ( package ) : [EOL] stubs = [ ] [EOL] for root , dirs , files in os . walk ( package ) : [EOL] for file in files : [EOL] path = os . path . join ( root , file ) . replace ( package + os . sep , [string] , [number] ) [EOL] stubs . append ( path ) [EOL] return { package : stubs } [EOL] [EOL] [EOL] setup ( name = [string] , description = [string] , url = [string] , license = [string] , version = [string] , packages = [ [string] ] , install_requires = [ [string] ] , package_data = find_stubs ( [string] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , List , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] from mypy import api [EOL] [EOL] TESTS_DIR = os . path . dirname ( __file__ ) [EOL] PASS_DIR = os . path . join ( TESTS_DIR , [string] ) [EOL] FAIL_DIR = os . path . join ( TESTS_DIR , [string] ) [EOL] REVEAL_DIR = os . path . join ( TESTS_DIR , [string] ) [EOL] [EOL] [EOL] def get_test_cases ( directory ) : [EOL] for root , __ , files in os . walk ( directory ) : [EOL] for fname in files : [EOL] if os . path . splitext ( fname ) [ - [number] ] == [string] : [EOL] fullpath = os . path . join ( root , fname ) [EOL] [comment] [EOL] relpath = os . path . relpath ( fullpath , start = directory ) [EOL] skip_py2 = fname . endswith ( [string] ) [EOL] [EOL] for py_version_number in ( [number] , [number] ) : [EOL] if py_version_number == [number] and skip_py2 : [EOL] continue [EOL] py2_arg = [ [string] ] if py_version_number == [number] else [ ] [EOL] [EOL] yield pytest . param ( fullpath , py2_arg , id = [string] . format ( relpath , py_version_number ) , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , get_test_cases ( PASS_DIR ) ) def test_success ( path , py2_arg ) : [EOL] stdout , stderr , exitcode = api . run ( [ path ] + py2_arg ) [EOL] assert stdout == [string] [EOL] assert exitcode == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , get_test_cases ( FAIL_DIR ) ) def test_fail ( path , py2_arg ) : [EOL] stdout , stderr , exitcode = api . run ( [ path ] + py2_arg ) [EOL] [EOL] assert exitcode != [number] [EOL] [EOL] with open ( path ) as fin : [EOL] lines = fin . readlines ( ) [EOL] [EOL] errors = { } [EOL] for error_line in stdout . split ( [string] ) : [EOL] error_line = error_line . strip ( ) [EOL] if not error_line : [EOL] continue [EOL] [EOL] lineno = int ( error_line . split ( [string] ) [ [number] ] ) [EOL] errors [ lineno ] = error_line [EOL] [EOL] for i , line in enumerate ( lines ) : [EOL] lineno = i + [number] [EOL] if [string] not in line and lineno not in errors : [EOL] continue [EOL] [EOL] target_line = lines [ lineno - [number] ] [EOL] if [string] in target_line : [EOL] marker = target_line . split ( [string] ) [ - [number] ] . strip ( ) [EOL] assert lineno in errors , f' [string] { marker } [string] ' [EOL] assert marker in errors [ lineno ] [EOL] else : [EOL] pytest . fail ( f' [string] { repr ( errors [ lineno ] ) } [string] ' ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , get_test_cases ( REVEAL_DIR ) ) def test_reveal ( path , py2_arg ) : [EOL] stdout , stderr , exitcode = api . run ( [ path ] + py2_arg ) [EOL] [EOL] with open ( path ) as fin : [EOL] lines = fin . readlines ( ) [EOL] [EOL] for error_line in stdout . split ( [string] ) : [EOL] error_line = error_line . strip ( ) [EOL] if not error_line : [EOL] continue [EOL] [EOL] lineno = int ( error_line . split ( [string] ) [ [number] ] ) [EOL] assert [string] in error_line [EOL] marker = lines [ lineno - [number] ] . split ( [string] ) [ - [number] ] . strip ( ) [EOL] assert marker in error_line [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tensorflow as tf [EOL] [EOL] tf . train . import_meta_graph ( [number] ) [comment] [EOL] tf . train . import_meta_graph ( [ ] ) [comment] [EOL] [EOL] tf . train . Saver ( ) . restore ( tf . Session ( ) , [number] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tensorflow as tf [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] tf . nn . ctc_beam_search_decoder ( tf . placeholder ( tf . float32 , shape = ( [number] , [number] , [number] ) ) , [string] , beam_width = [number] , top_paths = [number] , merge_repeated = True ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tensorflow as tf [EOL] [EOL] tf . train . import_meta_graph ( [string] ) [EOL] [EOL] [EOL] tf . train . Saver ( ) . restore ( tf . Session ( ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import tensorflow as tf [EOL] [EOL] [comment] [EOL] placeholder = tf . placeholder ( tf . float32 , shape = ( [number] , [number] , [number] ) ) [EOL] [comment] [EOL] sparseTensor = tf . SparseTensor ( indices = [ [ [number] , [number] ] , [ [number] , [number] ] ] , values = [ [number] , [number] ] , dense_shape = [ [number] , [number] ] ) [EOL] [EOL] tf . nn . ctc_beam_search_decoder ( placeholder , [ [number] ] , beam_width = [number] , top_paths = [number] , merge_repeated = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] tf . nn . log_softmax ( placeholder , axis = [number] , name = [string] , dim = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tensorflow as tf [EOL] [EOL] tf . errors . OpError ( None , None , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0