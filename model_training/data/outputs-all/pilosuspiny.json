from typing import List [EOL] import typing [EOL] import builtins [EOL] from subprocess import check_output , CalledProcessError [EOL] [EOL] VERSION_FILE = [string] [EOL] GIT_COMMAND = [string] [EOL] VERSION_FORMAT = [string] [EOL] [EOL] [EOL] def git_version ( tag_only = False ) : [EOL] [docstring] [EOL] [EOL] output = check_output ( GIT_COMMAND . split ( ) ) . decode ( [string] ) . strip ( ) . split ( [string] ) [EOL] tag , count , commit = output [ : [number] ] [EOL] dirty = len ( output ) == [number] [EOL] [EOL] if ( count == [string] and not dirty ) or tag_only : [EOL] return tag [EOL] return VERSION_FORMAT . format ( tag = tag , commit_count = count , commit_hash = commit ) [EOL] [EOL] [EOL] def get_version ( tag_only = False ) : [EOL] [docstring] [EOL] try : [EOL] version = git_version ( tag_only ) [EOL] except CalledProcessError : [EOL] with open ( VERSION_FILE , [string] ) as f : [EOL] version = f . readline ( ) . strip ( ) [EOL] else : [EOL] with open ( VERSION_FILE , [string] ) as f : [EOL] f . write ( version ) [EOL] return version [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Pattern , Type [EOL] import typing [EOL] import piny [EOL] import builtins [EOL] import os [EOL] import re [EOL] from typing import Pattern [EOL] [EOL] import yaml [EOL] [EOL] [EOL] class Matcher ( yaml . SafeLoader ) : [EOL] [docstring] [EOL] [EOL] matcher = re . compile ( [string] ) [EOL] [EOL] @ staticmethod def constructor ( loader , node ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class StrictMatcher ( Matcher ) : [EOL] [docstring] [EOL] [EOL] matcher = re . compile ( [string] ) [EOL] [EOL] @ staticmethod def constructor ( loader , node ) : [EOL] match = StrictMatcher . matcher . match ( node . value ) [EOL] return os . environ . get ( match . groups ( ) [ [number] ] ) [comment] [EOL] [EOL] [EOL] class MatcherWithDefaults ( Matcher ) : [EOL] [docstring] [EOL] [EOL] matcher = re . compile ( [string] ) [EOL] [EOL] @ staticmethod def constructor ( loader , node ) : [EOL] match = MatcherWithDefaults . matcher . match ( node . value ) [EOL] variable , default = match . groups ( ) [comment] [EOL] [EOL] if default : [EOL] [comment] [EOL] [comment] [EOL] default = default [ [number] : ] [EOL] [EOL] return os . environ . get ( variable , default ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] from abc import ABC , abstractmethod [EOL] from typing import Any , Dict , List , Union [EOL] [EOL] from . errors import ValidationError [EOL] [EOL] LoadedData = Union [ Dict [ str , Any ] , List [ Any ] ] [EOL] [EOL] [EOL] class Validator ( ABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , schema , ** params ) : [EOL] self . schema = schema [EOL] self . schema_params = params [EOL] [EOL] @ abstractmethod def load ( self , data , ** params ) : [EOL] [docstring] [EOL] pass [comment] [EOL] [EOL] [EOL] class PydanticValidator ( Validator ) : [EOL] [docstring] [EOL] [EOL] def load ( self , data , ** params ) : [EOL] try : [EOL] return self . schema ( ** data ) . dict ( ) [EOL] except Exception as e : [EOL] raise ValidationError ( origin = e , reason = str ( e ) ) [EOL] [EOL] [EOL] class MarshmallowValidator ( Validator ) : [EOL] [docstring] [EOL] [EOL] def load ( self , data , ** params ) : [EOL] try : [EOL] return self . schema ( ** self . schema_params ) . load ( data , ** params ) . data [EOL] except Exception as e : [EOL] raise ValidationError ( origin = e , reason = str ( e ) ) [EOL] [EOL] [EOL] class TrafaretValidator ( Validator ) : [EOL] [docstring] [EOL] [EOL] def load ( self , data , ** params ) : [EOL] try : [EOL] return self . schema . check ( data ) [EOL] except Exception as e : [EOL] raise ValidationError ( origin = e , reason = str ( e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . errors import ConfigError , LoadingError , ValidationError [EOL] from . loaders import YamlLoader , YamlStreamLoader [EOL] from . matchers import Matcher , MatcherWithDefaults , StrictMatcher [EOL] from . validators import MarshmallowValidator , PydanticValidator , TrafaretValidator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , IO , Dict [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import click [EOL] import yaml [EOL] [EOL] from . loaders import YamlStreamLoader [EOL] from . matchers import MatcherWithDefaults , StrictMatcher [EOL] [EOL] CONTEXT_SETTINGS = dict ( help_option_names = [ [string] , [string] ] ) [EOL] [EOL] [EOL] @ click . command ( context_settings = CONTEXT_SETTINGS ) @ click . argument ( [string] , required = False , type = click . File ( [string] ) ) @ click . argument ( [string] , required = False , type = click . File ( [string] ) ) @ click . option ( [string] , default = True , help = [string] ) def cli ( input , output , strict ) : [EOL] [docstring] [EOL] stdin = click . get_text_stream ( [string] ) [EOL] stdout = click . get_text_stream ( [string] ) [EOL] [EOL] config = YamlStreamLoader ( stream = input or stdin , matcher = StrictMatcher if strict else MatcherWithDefaults ) . load ( ) [EOL] [EOL] yaml . dump ( config , output or stdout ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] [EOL] [EOL] class PinyErrorMixin : [EOL] [docstring] [EOL] [EOL] msg_template = ... [EOL] [EOL] def __init__ ( self , origin = None , ** context ) : [EOL] [docstring] [EOL] self . origin = origin [EOL] self . context = context or None [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . msg_template . format ( ** self . context or { } ) [EOL] [EOL] [EOL] class ConfigError ( PinyErrorMixin , Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class LoadingError ( ConfigError ) : [EOL] [docstring] [EOL] [EOL] msg_template = [string] [EOL] [EOL] [EOL] class ValidationError ( ConfigError ) : [EOL] [docstring] [EOL] [EOL] msg_template = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Union , Any , IO , Type [EOL] import validators [EOL] import matchers [EOL] import piny [EOL] import builtins [EOL] import typing [EOL] from typing import IO , Any , Type , Union [EOL] [EOL] import yaml [EOL] [EOL] from . errors import LoadingError [EOL] from . matchers import Matcher , MatcherWithDefaults [EOL] from . validators import Validator [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class YamlLoader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , * , matcher = MatcherWithDefaults , validator = None , schema = None , ** schema_params , ) : [EOL] [docstring] [EOL] self . path = path [EOL] self . matcher = matcher [EOL] self . validator = validator [EOL] self . schema = schema [EOL] self . schema_params = schema_params [EOL] [EOL] def _init_resolvers ( self ) : [EOL] self . matcher . add_implicit_resolver ( [string] , self . matcher . matcher , None ) [EOL] self . matcher . add_constructor ( [string] , self . matcher . constructor ) [EOL] [EOL] def load ( self , ** params ) : [EOL] [docstring] [EOL] self . _init_resolvers ( ) [EOL] try : [EOL] with open ( self . path ) as fh : [EOL] load = yaml . load ( fh , Loader = self . matcher ) [EOL] except ( yaml . YAMLError , FileNotFoundError ) as e : [EOL] raise LoadingError ( origin = e , reason = str ( e ) ) [EOL] [EOL] if ( self . validator is not None ) and ( self . schema is not None ) : [EOL] return self . validator ( self . schema , ** self . schema_params ) . load ( data = load , ** params ) [EOL] return load [EOL] [EOL] [EOL] class YamlStreamLoader ( YamlLoader ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , stream , * , matcher = MatcherWithDefaults , validator = None , schema = None , ** schema_params , ) : [EOL] self . stream = stream [EOL] self . matcher = matcher [EOL] self . validator = validator [EOL] self . schema = schema [EOL] self . schema_params = schema_params [EOL] [EOL] def load ( self , ** params ) : [EOL] self . _init_resolvers ( ) [EOL] try : [EOL] load = yaml . load ( self . stream , Loader = self . matcher ) [EOL] except yaml . YAMLError as e : [EOL] raise LoadingError ( origin = e , reason = str ( e ) ) [EOL] [EOL] if ( self . validator is not None ) and ( self . schema is not None ) : [EOL] return self . validator ( self . schema , ** self . schema_params ) . load ( data = load , ** params ) [EOL] return load [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[typing.IO[builtins.str],builtins.str]$ 0 0 0 $typing.Type[piny.matchers.Matcher]$ 0 0 0 $typing.Type[piny.validators.Validator]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.IO[builtins.str],builtins.str]$ 0 $typing.Union[typing.IO[builtins.str],builtins.str]$ 0 0 0 $typing.Type[piny.matchers.Matcher]$ 0 $typing.Type[piny.matchers.Matcher]$ 0 0 0 $typing.Type[piny.validators.Validator]$ 0 $typing.Type[piny.validators.Validator]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Union , List , Dict [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . append ( os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] from version import get_version [EOL] release = get_version ( tag_only = True ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] html_theme = [string] [EOL] html_theme_options = { [string] : False , [string] : True , [string] : [string] , [string] : False , [string] : False , [string] : True , [string] : [number] , [string] : True , [string] : False } [EOL] [EOL] [comment] [EOL] html_logo = [string] [EOL] html_favicon = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import trafaret [EOL] from piny import TrafaretValidator , StrictMatcher , YamlLoader [EOL] [EOL] [EOL] DBSchema = trafaret . Dict ( login = trafaret . String , password = trafaret . String ) [EOL] ConfigSchema = trafaret . Dict ( db = DBSchema ) [EOL] [EOL] config = YamlLoader ( path = [string] , matcher = StrictMatcher , validator = TrafaretValidator , schema = ConfigSchema , ) . load ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Union , Optional , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import flask [EOL] import logging [EOL] from flask import Flask [EOL] from flask . logging import default_handler [EOL] from piny import YamlLoader , StrictMatcher , PydanticValidator [EOL] from pydantic import BaseModel , validator [EOL] from typing import Any , Dict , Optional [EOL] from werkzeug . serving import run_simple [EOL] import logging [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class AppSettings ( BaseModel ) : [EOL] company = ... [EOL] secret = ... [EOL] max_content_len = None [EOL] debug = False [EOL] testing = False [EOL] [EOL] [EOL] class LoggingSettings ( BaseModel ) : [EOL] fmt = ... [EOL] date_fmt = ... [EOL] level = ... [EOL] [EOL] @ validator ( [string] ) def validate_name ( cls , value ) : [EOL] upper = value . upper ( ) [EOL] if upper not in logging . _nameToLevel : [EOL] raise ValueError ( [string] ) [EOL] return upper [EOL] [EOL] [EOL] class Configuration ( BaseModel ) : [EOL] app = ... [EOL] logging = ... [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def configure_app ( app , configuration ) : [EOL] [docstring] [EOL] app . settings = configuration [EOL] app . secret_key = app . settings [ [string] ] [ [string] ] . encode ( [string] ) [EOL] [EOL] [EOL] def configure_logging ( app ) : [EOL] [docstring] [EOL] app . logger . removeHandler ( default_handler ) [EOL] log_formatter = logging . Formatter ( fmt = app . settings [ [string] ] [ [string] ] , datefmt = app . settings [ [string] ] [ [string] ] ) [EOL] log_handler = logging . StreamHandler ( ) [EOL] log_handler . setFormatter ( log_formatter ) [EOL] log_handler . setLevel ( app . settings [ [string] ] [ [string] ] ) [EOL] app . logger . addHandler ( log_handler ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def create_app ( path ) : [EOL] [docstring] [EOL] [comment] [EOL] config = YamlLoader ( path = path , matcher = StrictMatcher , validator = PydanticValidator , schema = Configuration , ) . load ( ) [EOL] [EOL] [comment] [EOL] app = Flask ( __name__ ) [EOL] [EOL] [comment] [EOL] configure_app ( app , config ) [EOL] configure_logging ( app ) [EOL] [EOL] return app [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app = create_app ( sys . argv [ [number] ] ) [EOL] [EOL] @ app . route ( [string] ) def hello ( ) : [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] run_simple ( hostname = [string] , port = [number] , application = app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $AppSettings$ 0 0 0 $LoggingSettings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from piny import YamlLoader , StrictMatcher [EOL] [EOL] config = YamlLoader ( path = [string] , matcher = StrictMatcher ) . load ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] import docs [EOL] import marshmallow as ma [EOL] from piny import MarshmallowValidator , StrictMatcher , YamlLoader [EOL] [EOL] [EOL] class DBSchema ( ma . Schema ) : [EOL] login = ma . fields . String ( required = True ) [EOL] password = ma . fields . String ( ) [EOL] [EOL] [EOL] class ConfigSchema ( ma . Schema ) : [EOL] db = ma . fields . Nested ( DBSchema ) [EOL] [EOL] [EOL] config = YamlLoader ( path = [string] , matcher = StrictMatcher , validator = MarshmallowValidator , schema = ConfigSchema , strict = True ) . load ( many = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from piny import YamlLoader [EOL] [EOL] config = YamlLoader ( path = [string] ) . load ( ) [EOL] print ( config ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from pydantic import BaseModel [EOL] from piny import PydanticValidator , StrictMatcher , YamlLoader [EOL] [EOL] [EOL] class DBModel ( BaseModel ) : [EOL] login = ... [EOL] password = ... [EOL] [EOL] [EOL] class ConfigModel ( BaseModel ) : [EOL] db = ... [EOL] [EOL] [EOL] config = YamlLoader ( path = [string] , matcher = StrictMatcher , validator = PydanticValidator , schema = ConfigModel , ) . load ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $DBModel$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from piny import LoadingError , YamlLoader [EOL] [EOL] [EOL] def test_loading_error ( ) : [EOL] with pytest . raises ( LoadingError , match = [string] ) : [EOL] YamlLoader ( path = [string] ) . load ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import re [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] [EOL] from piny import Matcher , MatcherWithDefaults , StrictMatcher , YamlLoader [EOL] [EOL] from . import config_directory , config_map [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_strict_matcher_values_undefined ( name ) : [EOL] config = YamlLoader ( path = config_directory . joinpath ( [string] . format ( name ) ) , matcher = StrictMatcher ) . load ( ) [EOL] assert config [ name ] [ [string] ] is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_strict_matcher_values_set ( name ) : [EOL] with mock . patch ( [string] ) as expand_mock : [EOL] expand_mock . return_value = config_map [ name ] [EOL] config = YamlLoader ( path = config_directory . joinpath ( [string] . format ( name ) ) , matcher = StrictMatcher , ) . load ( ) [EOL] assert config [ name ] [ [string] ] == config_map [ name ] [EOL] [EOL] [EOL] def test_strict_matcher_default_do_not_matched ( ) : [EOL] config = YamlLoader ( path = config_directory . joinpath ( [string] ) , matcher = StrictMatcher ) . load ( ) [EOL] assert config [ [string] ] [ [string] ] is None [EOL] assert ( config [ [string] ] [ [string] ] == [string] ) [EOL] assert config [ [string] ] [ [string] ] == [string] [EOL] assert config [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_matcher_with_defaults_values_undefined ( ) : [EOL] config = YamlLoader ( path = config_directory . joinpath ( [string] ) , matcher = MatcherWithDefaults ) . load ( ) [EOL] assert config [ [string] ] [ [string] ] is None [EOL] assert config [ [string] ] [ [string] ] == [string] [EOL] assert config [ [string] ] [ [string] ] == [string] [EOL] assert config [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_matcher_with_defaults_values_set ( ) : [EOL] with mock . patch ( [string] ) as expand_mock : [EOL] expand_mock . side_effect = lambda v , _ : config_map [ v . split ( [string] ) [ [number] ] . lower ( ) ] [EOL] config = YamlLoader ( path = config_directory . joinpath ( [string] ) , matcher = MatcherWithDefaults ) . load ( ) [EOL] assert config [ [string] ] [ [string] ] == config_map [ [string] ] [EOL] assert config [ [string] ] [ [string] ] == config_map [ [string] ] [EOL] assert config [ [string] ] [ [string] ] == config_map [ [string] ] [EOL] assert config [ [string] ] [ [string] ] == config_map [ [string] ] [EOL] [EOL] [EOL] def test_base_matcher ( ) : [EOL] [docstring] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] with mock . patch ( [string] , new_callable = mock . PropertyMock ) as matcher_mock : [EOL] matcher_mock . return_value = re . compile ( [string] ) [EOL] YamlLoader ( path = config_directory . joinpath ( [string] ) , matcher = Matcher ) . load ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import click [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] import yaml [EOL] from click . testing import CliRunner [EOL] [EOL] from piny import LoadingError [EOL] from piny . cli import cli [EOL] [EOL] from . import config_directory [EOL] [EOL] [EOL] def test_cli_input_stdin_output_stdout ( ) : [EOL] runner = CliRunner ( ) [EOL] with mock . patch ( [string] ) as expand_mock : [EOL] expand_mock . return_value = [string] [EOL] result = runner . invoke ( cli , input = [string] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert result . stdout == [string] [EOL] [EOL] [EOL] def test_cli_input_file_output_file ( ) : [EOL] runner = CliRunner ( ) [EOL] with open ( config_directory . joinpath ( [string] ) , [string] ) as f : [EOL] input_lines = f . readlines ( ) [EOL] [EOL] with runner . isolated_filesystem ( ) : [EOL] with open ( [string] , [string] ) as input_fd : [EOL] input_fd . writelines ( input_lines ) [EOL] [EOL] with mock . patch ( [string] ) as expand_mock : [EOL] expand_mock . return_value = [string] [EOL] result = runner . invoke ( cli , [ [string] , [string] ] ) [EOL] [EOL] with open ( [string] , [string] ) as output_fd : [EOL] output_lines = output_fd . readlines ( ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert [string] in map ( lambda x : x . strip ( ) , output_lines ) [EOL] [EOL] [EOL] def test_cli_fail ( ) : [EOL] runner = CliRunner ( ) [EOL] with mock . patch ( [string] ) as loader_mock : [EOL] loader_mock . side_effect = yaml . YAMLError ( [string] ) [EOL] result = runner . invoke ( cli , input = [string] ) [EOL] assert result . exit_code == [number] [EOL] assert type ( result . exception ) == LoadingError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def pytest_make_parametrize_id ( config , val , argname ) : [EOL] [docstring] [EOL] if isinstance ( val , dict ) : [EOL] return [string] . format ( argname , [string] . join ( [string] . format ( k , v ) for k , v in val . items ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] [EOL] config_directory = Path ( __file__ ) . resolve ( ) . parent . joinpath ( [string] ) [EOL] [EOL] config_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0