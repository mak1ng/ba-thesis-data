[docstring] [EOL] from distutils . core import setup [EOL] [EOL] with open ( [string] ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = ( [string] + [string] ) , long_description = readme , author = [string] , author_email = [string] , packages = [ [string] , [string] ] , classifiers = [ [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterable , Callable , Any [EOL] import typing [EOL] import logging [EOL] import pandas [EOL] import pathlib [EOL] import builtins [EOL] import copy [EOL] import datetime as dt [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Callable , Iterable , List , Tuple [EOL] [EOL] import pandas as pd [EOL] [EOL] from pymint import processing [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class FileManager : [EOL] [docstring] [EOL] [EOL] _data = ... [EOL] _fname = ... [EOL] _processed_data = ... [EOL] _processing_queue = ... [EOL] [EOL] def __init__ ( self , fname ) : [EOL] [docstring] [EOL] if not fname . is_file ( ) : [EOL] raise ValueError ( f" [string] { str ( fname ) } [string] " ) [EOL] [EOL] self . _fname = fname [EOL] self . _data = None [EOL] [EOL] self . _processed_data = None [EOL] self . _processing_queue = [ processing . set_sign_from_type ] [EOL] [EOL] @ property def data ( self ) : [EOL] [docstring] [EOL] if not self . _data : [EOL] self . _data = self . load ( ) [EOL] return self . _data . copy ( ) [EOL] [EOL] @ property def fname ( self ) : [EOL] [docstring] [EOL] return self . _fname [EOL] [EOL] def load ( self , parse_as = [string] ) : [EOL] [docstring] [EOL] if parse_as == [string] or self . _fname . suffix == [string] : [EOL] logger . info ( f" [string] { str ( self . _fname ) }" ) [EOL] data = pd . read_csv ( self . _fname ) [EOL] else : [EOL] raise ValueError ( f" [string] { str ( self . _fname ) } [string] { parse_as }" ) [EOL] [EOL] data [ [string] ] = data . Date . apply ( lambda d : dt . datetime . strptime ( d , [string] ) ) [EOL] data . columns = data . columns . str . lower ( ) . str . replace ( [string] , [string] ) [EOL] data . sort_values ( by = [string] , inplace = True ) [EOL] return data [EOL] [EOL] def process ( self , data , inplace = True , stages = [ ] , ) : [EOL] [docstring] [EOL] stages_ = copy . copy ( self . _processing_queue ) [EOL] for stage in stages : [EOL] stages_ . append ( stage ) [EOL] [EOL] if not inplace : [EOL] data = data . copy ( ) [EOL] [EOL] while len ( stages_ ) : [EOL] func = stages_ . pop ( [number] ) [EOL] data = func ( data = data , inplace = inplace ) [EOL] [EOL] return data [EOL] [EOL] @ property def processed_data ( self ) : [EOL] [docstring] [EOL] if not self . _processed_data : [EOL] [comment] [EOL] [comment] [EOL] self . _processed_data = self . process ( self . data , inplace = True ) [EOL] return self . _processed_data . copy ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pathlib.Path$ 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.List[typing.Callable]$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Callable[...,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 $typing.Iterable[typing.Callable[[pandas.DataFrame,builtins.bool],pandas.DataFrame]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Callable[...,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Callable[[pandas.DataFrame,builtins.bool],pandas.DataFrame]]$ 0 0 $typing.List[typing.Callable[...,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Callable[...,typing.Any]]$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.List[typing.Callable[...,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Callable[...,typing.Any]$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pandas [EOL] import typing [EOL] import pandas as pd [EOL] [EOL] [EOL] def set_sign_from_type ( data , inplace = False ) : [EOL] [docstring] [EOL] if not inplace : [EOL] data = data . copy ( ) [EOL] [EOL] [comment] [EOL] idx = ( data . transaction_type == [string] ) & ( data . amount > [number] ) [EOL] data . loc [ idx , [string] ] = data . loc [ idx , [string] ] . mul ( - [number] ) [EOL] [EOL] [comment] [EOL] idx = ( data . transaction_type == [string] ) & ( data . amount < [number] ) [EOL] data . loc [ idx , [string] ] = data . loc [ idx , [string] ] . mul ( - [number] ) [EOL] [EOL] return data	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . arith import add [EOL]	0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] from pymint . arith import add [EOL] [EOL] [EOL] def test_add ( ) : [EOL] [docstring] [EOL] assert add ( [number] , [number] ) == [number] [EOL] assert add ( - [number] , [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0