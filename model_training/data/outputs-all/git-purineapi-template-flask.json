from typing import Any [EOL] import typing [EOL] from __future__ import with_statement [EOL] [EOL] import os [EOL] import sys [EOL] from logging . config import fileConfig [EOL] [EOL] from alembic import context [EOL] from sqlalchemy import engine_from_config , pool [EOL] [EOL] [EOL] root_dir = os . getcwd ( ) [EOL] sys . path . insert ( [number] , root_dir ) [EOL] [EOL] config = context . config [EOL] fileConfig ( config . config_file_name ) [EOL] [EOL] [EOL] def get_url ( ) : [EOL] return [string] % ( os . getenv ( [string] , [string] ) , os . getenv ( [string] , [string] ) , os . getenv ( [string] , [string] ) , os . getenv ( [string] , [string] ) , os . getenv ( [string] , [string] ) , ) [EOL] [EOL] [EOL] config . set_main_option ( [string] , get_url ( ) ) [EOL] [EOL] [EOL] def run_migrations_offline ( ) : [EOL] from app . repositories . datasources . db_base_model import BaseModel [EOL] target_metadata = BaseModel . metadata [EOL] [EOL] url = config . get_main_option ( [string] ) [EOL] context . configure ( url = url , target_metadata = target_metadata , literal_binds = True ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] def run_migrations_online ( ) : [EOL] from app . repositories . datasources . db_base_model import BaseModel [EOL] target_metadata = BaseModel . metadata [EOL] [EOL] connectable = engine_from_config ( config . get_section ( config . config_ini_section ) , prefix = [string] , poolclass = pool . NullPool ) [EOL] [EOL] with connectable . connect ( ) as connection : [EOL] context . configure ( connection = connection , target_metadata = target_metadata , include_schemas = True , ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] if context . is_offline_mode ( ) : [EOL] run_migrations_offline ( ) [EOL] else : [EOL] run_migrations_online ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from . json_loader import JsonLoader [EOL]	0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , Union [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import json [EOL] from datetime import datetime [EOL] [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] [EOL] [EOL] class JsonLoader : [EOL] [EOL] @ classmethod def load_file ( cls , file_path ) : [EOL] [EOL] with open ( file_path , [string] , encoding = [string] ) as f : [EOL] json_dict = json . load ( f ) [EOL] [EOL] if json_dict : [EOL] for key in json_dict . keys ( ) : [EOL] json_dict [ key ] = cls . add_default ( json_dict [ key ] ) [EOL] [EOL] return json_dict [EOL] [EOL] @ classmethod def add_default ( cls , l ) : [EOL] at = datetime . now ( ) [EOL] entity = { [string] : [string] , [string] : at , [string] : [string] , [string] : at , [string] : False } [EOL] records = [ ] [EOL] for r in l : [EOL] d = { } [EOL] d . update ( entity ) [EOL] d . update ( r ) [EOL] records . append ( d ) [EOL] return records [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,datetime.datetime,builtins.str]]$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,datetime.datetime,builtins.str]]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.list$ 0
from typing import Any , Dict , Tuple [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from datetime import datetime [EOL] [EOL] import sqlalchemy as sa [EOL] from alembic import op [EOL] from sqlalchemy . dialects import postgresql [EOL] from sqlalchemy . sql import column , table [EOL] [EOL] from migrations . utils import JsonLoader [EOL] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = None [EOL] branch_labels = ( [string] , ) [EOL] depends_on = [string] [EOL] [EOL] PATH_JSON_ROOT = [string] [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] roles = table ( [string] , column ( [string] , sa . String ) , column ( [string] , sa . String ) , column ( [string] , postgresql . UUID ) , column ( [string] , sa . DateTime ) , column ( [string] , postgresql . UUID ) , column ( [string] , sa . DateTime ) , column ( [string] , sa . Boolean ) , ) [EOL] roles . schema = [string] [EOL] [EOL] json = JsonLoader . load_file ( PATH_JSON_ROOT + [string] ) [EOL] table_dict = { [string] : roles , } [EOL] for k , v in json . items ( ) : [EOL] op . bulk_insert ( table_dict [ k ] , v ) [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from datetime import datetime [EOL] [EOL] import sqlalchemy as sa [EOL] from alembic import op [EOL] from sqlalchemy . dialects import postgresql [EOL] from sqlalchemy . sql import column , table [EOL] [EOL] from migrations . utils import JsonLoader [EOL] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = [string] [EOL] branch_labels = None [EOL] depends_on = None [EOL] [EOL] PATH_JSON_ROOT = [string] [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] usergroups = table ( [string] , column ( [string] , postgresql . UUID ) , column ( [string] , sa . String ) , column ( [string] , sa . String ) , column ( [string] , postgresql . UUID ) , column ( [string] , sa . DateTime ) , column ( [string] , postgresql . UUID ) , column ( [string] , sa . DateTime ) , column ( [string] , sa . Boolean ) , ) [EOL] usergroups . schema = [string] [EOL] [EOL] users = table ( [string] , column ( [string] , postgresql . UUID ) , column ( [string] , sa . String ) , column ( [string] , sa . String ) , column ( [string] , sa . String ) , column ( [string] , sa . String ) , column ( [string] , sa . Integer ) , column ( [string] , sa . String ) , column ( [string] , postgresql . UUID ) , column ( [string] , sa . DateTime ) , column ( [string] , postgresql . UUID ) , column ( [string] , sa . DateTime ) , column ( [string] , sa . Boolean ) , ) [EOL] users . schema = [string] [EOL] [EOL] usergroup_user_rels = table ( [string] , column ( [string] , postgresql . UUID ) , column ( [string] , postgresql . UUID ) , ) [EOL] usergroup_user_rels . schema = [string] [EOL] [EOL] usergroup_role_rels = table ( [string] , column ( [string] , postgresql . UUID ) , column ( [string] , sa . String ) , ) [EOL] usergroup_role_rels . schema = [string] [EOL] [EOL] json = JsonLoader . load_file ( PATH_JSON_ROOT + [string] ) [EOL] table_dict = { [string] : usergroups , [string] : users , [string] : usergroup_user_rels , [string] : usergroup_role_rels , } [EOL] for k , v in json . items ( ) : [EOL] op . bulk_insert ( table_dict [ k ] , v ) [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = None [EOL] branch_labels = ( [string] , ) [EOL] depends_on = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] op . execute ( [string] ) [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] op . execute ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from . json_importer import JsonImporter [EOL]	0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import builtins [EOL] import flask_sqlalchemy [EOL] import typing [EOL] import json [EOL] from datetime import datetime [EOL] [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] [EOL] [EOL] class JsonImporter : [EOL] [EOL] def __init__ ( self , db , orm_translator ) : [EOL] self . db = db [EOL] self . translator = orm_translator [EOL] [EOL] def import_json_dir ( self , dir_path ) : [EOL] pass [EOL] [EOL] def import_json_file ( self , file_path ) : [EOL] [EOL] with open ( file_path , [string] , encoding = [string] ) as f : [EOL] json_dict = json . load ( f ) [EOL] [EOL] if json_dict : [EOL] for key in json_dict . keys ( ) : [EOL] records = json_dict [ key ] [EOL] self . db . session . bulk_save_objects ( self . translator [ key ] ( records ) ) [EOL] [EOL] self . db . session . commit ( ) [EOL] [EOL] @ classmethod def add_default ( cls , l ) : [EOL] entity = { [string] : [string] , [string] : [string] } [EOL] records = [ ] [EOL] for r in l : [EOL] d = { } [EOL] d . update ( entity ) [EOL] d . update ( r ) [EOL] records . append ( d ) [EOL] return records [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 $builtins.list$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.list$ 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import app [EOL] import typing [EOL] import graphql [EOL] import pytest [EOL] from flask_injector import request [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] from graphql . execution import ExecutionResult [EOL] from injector import Module , singleton [EOL] [EOL] from app . domains import Role , User , Usergroup , Token [EOL] from app . repositories import ITokenRepository , IUserRepository [EOL] from app . schemas import schema [EOL] [EOL] [EOL] class TestCreateToekn : [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def fixture ( self , logger , context , gql , middlewares , mocker ) : [EOL] self . logger = logger [EOL] [EOL] self . context = context [EOL] self . gql = gql [EOL] self . middlewares = middlewares [EOL] self . mocker = mocker [EOL] [EOL] def test_create_token ( self , user_id ) : [EOL] db = self . mocker . Mock ( ) [EOL] r_token = self . mocker . Mock ( ) [EOL] r_user = self . mocker . Mock ( ) [EOL] [EOL] class Testmodule ( Module ) : [EOL] def configure ( self , binder ) : [EOL] binder . bind ( SQLAlchemy , to = db , scope = singleton ) [EOL] binder . bind ( ITokenRepository , to = r_token , scope = request ) [EOL] binder . bind ( IUserRepository , to = r_user , scope = request ) [EOL] [EOL] r_user . get_item_by_unique . return_value = User ( id = user_id , mail = [string] , name = [string] , password_hash = [string] , salt = [string] , stretching = [number] , usergroups = [ Usergroup ( id = [string] , name = [string] , code = [string] , roles = [ Role ( name = [string] , code = [string] , ) ] ) , ] , ) [EOL] [EOL] r_user . get_item . return_value = User ( id = user_id , mail = [string] , name = [string] , password_hash = [string] , salt = [string] , stretching = [number] , usergroups = [ Usergroup ( id = [string] , name = [string] , code = [string] , roles = [ Role ( name = [string] , code = [string] , ) ] ) , ] , ) [EOL] [EOL] r_token . create . return_value = Token ( user_id = user_id , expiration_at = [string] , value = [string] , ) [EOL] [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( ) , middleware = self . middlewares ( [ Testmodule ( ) , ] ) , variables = { [string] : [string] , [string] : [string] , } , ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] assert db . session . commit . call_count == [number] [EOL] db . session . rollback . assert_not_called ( ) [EOL] [EOL] assert not executed . errors [EOL] assert executed . data [ [string] ] [ [string] ] [ [string] ] is not None [EOL] assert executed . data [ [string] ] [ [string] ] [ [string] ] is not None [EOL] assert executed . data [ [string] ] [ [string] ] == { [string] : user_id , [string] : [string] , [string] : [string] , } [EOL] [EOL] def test_create_token_error ( self ) : [EOL] db = self . mocker . Mock ( ) [EOL] r_token = self . mocker . Mock ( ) [EOL] r_user = self . mocker . Mock ( ) [EOL] [EOL] class Testmodule ( Module ) : [EOL] def configure ( self , binder ) : [EOL] binder . bind ( SQLAlchemy , to = db , scope = singleton ) [EOL] binder . bind ( ITokenRepository , to = r_token , scope = request ) [EOL] binder . bind ( IUserRepository , to = r_user , scope = request ) [EOL] [EOL] r_token . create . side_effect = Exception ( [string] ) [EOL] r_user . get_item_by_unique . side_effect = Exception ( [string] ) [EOL] [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( ) , middleware = self . middlewares ( [ Testmodule ( ) , ] ) , variables = { [string] : [string] , [string] : [string] , } , ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] db . session . commit . assert_not_called ( ) [EOL] db . session . rollback . assert_called_once ( ) [EOL] assert str ( executed . errors [ [number] ] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $app.repositories.ITokenRepository$ 0 0 0 0 0 0 0 0 0 $app.repositories.IUserRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.repositories.IUserRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.repositories.IUserRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.repositories.ITokenRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $app.repositories.IUserRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $app.repositories.IUserRepository$ 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import app [EOL] import typing [EOL] import graphql [EOL] import pytest [EOL] from flask_injector import request [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] from graphql . execution import ExecutionResult [EOL] from injector import Module , singleton [EOL] [EOL] from app . domains import Role , User , Usergroup , Token [EOL] from app . repositories import ITokenRepository , IUserRepository [EOL] from app . schemas import schema [EOL] [EOL] [EOL] class TestDeleteToekn : [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def fixture ( self , logger , context , gql , middlewares , mocker ) : [EOL] self . logger = logger [EOL] [EOL] self . context = context [EOL] self . gql = gql [EOL] self . middlewares = middlewares [EOL] self . mocker = mocker [EOL] [EOL] def test_delete_token ( self ) : [EOL] db = self . mocker . Mock ( ) [EOL] r_token = self . mocker . Mock ( ) [EOL] [EOL] class Testmodule ( Module ) : [EOL] def configure ( self , binder ) : [EOL] binder . bind ( SQLAlchemy , to = db , scope = singleton ) [EOL] binder . bind ( ITokenRepository , to = r_token , scope = request ) [EOL] [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( ) , middleware = self . middlewares ( [ Testmodule ( ) , ] ) , ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] db . session . commit . assert_called_once ( ) [EOL] db . session . rollback . assert_not_called ( ) [EOL] [EOL] assert not executed . errors [EOL] assert executed . data == { [string] : { [string] : True } } [EOL] [EOL] def test_delete_token_error ( self ) : [EOL] db = self . mocker . Mock ( ) [EOL] r_token = self . mocker . Mock ( ) [EOL] [EOL] class Testmodule ( Module ) : [EOL] def configure ( self , binder ) : [EOL] binder . bind ( SQLAlchemy , to = db , scope = singleton ) [EOL] binder . bind ( ITokenRepository , to = r_token , scope = request ) [EOL] [EOL] r_token . delete . side_effect = Exception ( [string] ) [EOL] [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( ) , middleware = self . middlewares ( [ Testmodule ( ) , ] ) , ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] db . session . commit . assert_not_called ( ) [EOL] db . session . rollback . assert_called_once ( ) [EOL] assert str ( executed . errors [ [number] ] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $app.repositories.ITokenRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import app [EOL] import typing [EOL] import graphql [EOL] import pytest [EOL] from flask_injector import request [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] from graphql . execution import ExecutionResult [EOL] from injector import Module , singleton [EOL] [EOL] from app . domains import Role , Usergroup [EOL] from app . repositories import IRoleRepository [EOL] from app . schemas import schema [EOL] [EOL] [EOL] class TestRole : [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def fixture ( self , logger , context , gql , middlewares , mocker ) : [EOL] self . logger = logger [EOL] [EOL] self . context = context [EOL] self . gql = gql [EOL] self . middlewares = middlewares [EOL] self . mocker = mocker [EOL] [EOL] def test_role ( self ) : [EOL] db = self . mocker . Mock ( ) [EOL] r_role = self . mocker . Mock ( ) [EOL] [EOL] class Testmodule ( Module ) : [EOL] def configure ( self , binder ) : [EOL] binder . bind ( SQLAlchemy , to = db , scope = singleton ) [EOL] binder . bind ( IRoleRepository , to = r_role , scope = request ) [EOL] [EOL] r_role . get_item . return_value = Role ( code = [string] , name = [string] , usergroups = [ Usergroup ( id = [string] , code = [string] , name = [string] , ) ] ) [EOL] [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( role_codes = [ [string] ] ) , middleware = self . middlewares ( [ Testmodule ( ) , ] ) , variables = { [string] : [string] } ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] db . session . commit . assert_called_once ( ) [EOL] db . session . rollback . assert_not_called ( ) [EOL] [EOL] assert not executed . errors [EOL] assert executed . data == { [string] : { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , } ] , } } [EOL] [EOL] def test_role_error ( self ) : [EOL] db = self . mocker . Mock ( ) [EOL] r_role = self . mocker . Mock ( ) [EOL] [EOL] class Testmodule ( Module ) : [EOL] def configure ( self , binder ) : [EOL] binder . bind ( SQLAlchemy , to = db , scope = singleton ) [EOL] binder . bind ( IRoleRepository , to = r_role , scope = request ) [EOL] [EOL] r_role . get_item . side_effect = Exception ( [string] ) [EOL] [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( role_codes = [ [string] ] ) , middleware = self . middlewares ( [ Testmodule ( ) , ] ) , variables = { [string] : [string] } ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] db . session . commit . assert_not_called ( ) [EOL] db . session . rollback . assert_called_once ( ) [EOL] assert str ( executed . errors [ [number] ] ) == [string] [EOL] [EOL] def test_role_unauthorized ( self ) : [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( authenticated = False ) , middleware = self . middlewares ( [ ] ) , variables = { [string] : [string] } ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] assert str ( executed . errors [ [number] ] ) == [string] [EOL] [EOL] def test_role_forbidden ( self ) : [EOL] executed = schema . execute ( self . gql ( [string] ) , context = self . context ( ) , middleware = self . middlewares ( [ ] ) , variables = { [string] : [string] } ) [EOL] self . logger . debug ( executed . errors ) [EOL] self . logger . debug ( executed . data ) [EOL] assert str ( executed . errors [ [number] ] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $app.repositories.IRoleRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.repositories.IRoleRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 $graphql.execution.ExecutionResult$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , Literal , Type , Union [EOL] import flask [EOL] import typing [EOL] import typing_extensions [EOL] import os [EOL] [EOL] env = os . getenv ( [string] , [string] ) [EOL] db_host = os . getenv ( [string] , [string] ) [EOL] db_port = os . getenv ( [string] , [string] ) [EOL] db_user = os . getenv ( [string] , [string] ) [EOL] db_pass = os . getenv ( [string] , [string] ) [EOL] db_name = os . getenv ( [string] , [string] ) [EOL] db_uri = [string] % ( db_user , db_pass , db_host , db_port , db_name ) [EOL] [EOL] envDict = { [string] : { [string] : True , [string] : True , } , [string] : { [string] : False , [string] : True , } , [string] : { [string] : False , [string] : False , } , } [EOL] [EOL] [EOL] class Config : [EOL] ENV = env [EOL] DEBUG = envDict [ env ] [ [string] ] [EOL] TESTING = envDict [ env ] [ [string] ] [EOL] [comment] [EOL] [EOL] ERROR_404_HELP = False [EOL] RESTPLUS_MASK_SWAGGER = False [EOL] JSONIFY_PRETTYPRINT_REGULAR = False [EOL] [EOL] SQLALCHEMY_DATABASE_URI = db_uri [EOL] [comment] [EOL] SQLALCHEMY_TRACK_MODIFICATIONS = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0