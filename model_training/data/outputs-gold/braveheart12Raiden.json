[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import raiden [EOL] import random [EOL] import signal [EOL] import tempfile [EOL] [EOL] from eth_utils import remove_0x_prefix [EOL] from web3 import HTTPProvider , Web3 [EOL] [EOL] from raiden . tests . utils . eth_node import ( EthNodeDescription , GenesisDescription , run_private_blockchain , ) [EOL] from raiden . utils import privatekey_to_address , sha3 [EOL] from raiden_contracts . constants import NETWORKNAME_TO_ID [EOL] [EOL] NUM_GETH_NODES = [number] [EOL] NUM_RAIDEN_ACCOUNTS = [number] [EOL] START_PORT = [number] [EOL] START_RPCPORT = [number] [EOL] [EOL] [EOL] DEFAULT_ACCOUNTS_SEEDS = [ [string] . format ( START_PORT + i ) . encode ( ) for i in range ( NUM_RAIDEN_ACCOUNTS ) ] [EOL] DEFAULT_ACCOUNTS_KEYS = [ sha3 ( seed ) for seed in DEFAULT_ACCOUNTS_SEEDS ] [EOL] DEFAULT_ACCOUNTS = [ privatekey_to_address ( key ) for key in DEFAULT_ACCOUNTS_KEYS ] [EOL] [EOL] [EOL] def main ( ) : [EOL] tmpdir = tempfile . mkdtemp ( ) [EOL] [EOL] geth_nodes = [ ] [EOL] for i in range ( NUM_GETH_NODES ) : [EOL] is_miner = i == [number] [EOL] node_key = sha3 ( f" [string] { i }" . encode ( ) ) [EOL] p2p_port = START_PORT + i [EOL] rpc_port = START_RPCPORT + i [EOL] [EOL] description = EthNodeDescription ( private_key = node_key , rpc_port = rpc_port , p2p_port = p2p_port , miner = is_miner , extra_config = { } , ) [EOL] [EOL] geth_nodes . append ( description ) [EOL] [EOL] rpc_endpoint = f" [string] { START_RPCPORT }" [EOL] web3 = Web3 ( HTTPProvider ( rpc_endpoint ) ) [EOL] [EOL] verbosity = [number] [EOL] random_marker = remove_0x_prefix ( hex ( random . getrandbits ( [number] ) ) ) [EOL] genesis_description = GenesisDescription ( prefunded_accounts = DEFAULT_ACCOUNTS , random_marker = random_marker , chain_id = NETWORKNAME_TO_ID [ [string] ] , ) [EOL] private_chain = run_private_blockchain ( web3 = web3 , eth_nodes = geth_nodes , base_datadir = tmpdir , log_dir = tmpdir , verbosity = verbosity , genesis_description = genesis_description , ) [EOL] [EOL] with private_chain : [EOL] from IPython import embed [EOL] [EOL] embed ( ) [EOL] [EOL] [EOL] def shutdown_handler ( _signo , _stackframe ) : [EOL] raise SystemExit [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] signal . signal ( signal . SIGTERM , shutdown_handler ) [EOL] signal . signal ( signal . SIGINT , shutdown_handler ) [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , Iterator , List [EOL] import typing [EOL] [docstring] [EOL] import sys [EOL] from difflib import unified_diff [EOL] [EOL] import click [EOL] import yaml [EOL] from yaml . parser import ParserError [EOL] [EOL] [EOL] def _red ( string ) : [EOL] return click . style ( string , fg = [string] ) [EOL] [EOL] [EOL] def _green ( string ) : [EOL] return click . style ( string , fg = [string] ) [EOL] [EOL] [EOL] def _yellow ( string ) : [EOL] return click . style ( string , fg = [string] ) [EOL] [EOL] [EOL] def _check_workflows_align ( config ) : [EOL] [docstring] [EOL] [EOL] jobs_default = config [ [string] ] [ [string] ] [ [string] ] [EOL] jobs_nightly = config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] if jobs_default == jobs_nightly [ : len ( jobs_default ) ] : [EOL] return True , [ ] [EOL] [EOL] job_diff = unified_diff ( [ f"{ line } [string] " for line in jobs_default ] , [ f"{ line } [string] " for line in jobs_nightly [ : len ( jobs_default ) ] ] , [string] , [string] , ) [EOL] message = [ _yellow ( [string] [string] ) ] [EOL] for line in job_diff : [EOL] if line . startswith ( [string] ) : [EOL] message . append ( _red ( line ) ) [EOL] elif line . startswith ( [string] ) : [EOL] message . append ( _green ( line ) ) [EOL] else : [EOL] message . append ( line ) [EOL] [EOL] return False , [string] . join ( message ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] , type = click . File ( [string] ) , default = [string] ) def main ( circle_config_file ) : [EOL] try : [EOL] config = yaml . safe_load ( circle_config_file ) [EOL] except ParserError as ex : [EOL] click . secho ( f" [string] { ex }" , fg = [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] result , message = _check_workflows_align ( config ) [EOL] if result is False : [EOL] click . echo ( message ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Tuple , List [EOL] import datetime [EOL] import typing [EOL] import json [EOL] import os [EOL] from datetime import datetime [EOL] [EOL] import click [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , required = True , help = [string] ) @ click . option ( [string] , default = [string] , help = [string] ) def process_results ( results_dir , plot_filename ) : [EOL] results = [ ] [EOL] [EOL] [comment] [EOL] for filename in os . listdir ( results_dir ) : [EOL] with open ( [string] . format ( results_dir , filename ) , [string] ) as f : [EOL] contents = json . load ( f ) [EOL] if [string] in contents : [EOL] result = contents [ [string] ] [EOL] min_ , max_ = result [ [number] ] , result [ - [number] ] [EOL] print ( [string] . format ( filename , datetime . fromtimestamp ( min_ ) . strftime ( [string] ) , datetime . fromtimestamp ( max_ ) . strftime ( [string] ) , ) ) [EOL] results . append ( result ) [EOL] [EOL] min_ , max_ = results [ [number] ] [ [number] ] , results [ [number] ] [ - [number] ] [EOL] for result in results : [EOL] min_ = min ( min_ , result [ [number] ] ) [EOL] max_ = max ( max_ , result [ - [number] ] ) [EOL] [EOL] print ( [string] . format ( datetime . fromtimestamp ( min_ ) . strftime ( [string] ) ) ) [EOL] print ( [string] . format ( datetime . fromtimestamp ( max_ ) . strftime ( [string] ) ) ) [EOL] [EOL] for result in results : [EOL] result . reverse ( ) [EOL] [EOL] initial_time = int ( min_ ) [EOL] last_time = int ( max_ ) + [number] [EOL] [EOL] amount_per_time = [ [number] ] * ( last_time - initial_time ) [EOL] index = [number] [EOL] max_amount = ( [number] , [number] ) [EOL] for time in range ( initial_time , last_time ) : [EOL] for result in results : [EOL] while len ( result ) > [number] and result [ - [number] ] < time + [number] : [EOL] result . pop ( ) [EOL] amount_per_time [ index ] += [number] [EOL] print ( [string] . format ( datetime . fromtimestamp ( time ) . strftime ( [string] ) , datetime . fromtimestamp ( time + [number] ) . strftime ( [string] ) , amount_per_time [ index ] , ) ) [EOL] if amount_per_time [ index ] > max_amount [ [number] ] : [EOL] max_amount = ( time , amount_per_time [ index ] ) [EOL] index += [number] [EOL] [EOL] print ( [string] . format ( datetime . fromtimestamp ( max_amount [ [number] ] ) . strftime ( [string] ) , datetime . fromtimestamp ( max_amount [ [number] ] + [number] ) . strftime ( [string] ) , max_amount [ [number] ] , ) ) [EOL] [EOL] times = [ time for time in range ( initial_time , last_time ) ] [comment] [EOL] [EOL] if plot_filename : [EOL] try : [EOL] import matplotlib [EOL] [EOL] matplotlib . use ( [string] ) [EOL] import matplotlib . pyplot as plt [EOL] import matplotlib . dates as md [EOL] [EOL] print ( [string] . format ( plot_filename ) ) [EOL] dates = [ datetime . fromtimestamp ( ts ) for ts in times ] [EOL] plt . subplots_adjust ( bottom = [number] ) [EOL] plt . xticks ( rotation = [number] ) [EOL] ax = plt . gca ( ) [EOL] [comment] [EOL] xfmt = md . DateFormatter ( [string] ) [EOL] ax . xaxis . set_major_formatter ( xfmt ) [EOL] plt . plot ( dates , amount_per_time ) [EOL] plt . savefig ( plot_filename ) [EOL] except ImportError as exc : [EOL] print ( [string] . format ( exc ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] process_results ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] import click [EOL] [EOL] ETH_RPC_ENDPOINT_ARG = [string] [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , required = True ) @ click . option ( [string] , required = True ) @ click . option ( [string] , default = [string] , show_default = True ) @ click . argument ( [string] , nargs = - [number] ) def main ( eth_nodes , seed , raiden_executable , raiden_args ) : [EOL] if ETH_RPC_ENDPOINT_ARG in raiden_args : [EOL] raise RuntimeError ( [string] . format ( ETH_RPC_ENDPOINT_ARG ) ) [EOL] eth_nodes = eth_nodes . split ( [string] ) [EOL] offset = sum ( ord ( c ) for c in seed ) % len ( eth_nodes ) [EOL] target_eth_node = eth_nodes [ offset ] [EOL] raiden_args = [ raiden_executable ] + list ( raiden_args ) + [ ETH_RPC_ENDPOINT_ARG , target_eth_node ] [EOL] print ( [string] . join ( raiden_args ) ) [EOL] [comment] [EOL] sys . stdout . flush ( ) [EOL] os . execvp ( raiden_args [ [number] ] , raiden_args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import tools [EOL] import typing [EOL] from pylint . checkers import BaseChecker [EOL] from pylint . interfaces import IAstroidChecker [EOL] [EOL] ASSERT_ID = [string] [EOL] ASSERT_MSG = [string] [EOL] [EOL] [EOL] def register ( linter ) : [EOL] linter . register_checker ( AssertMessage ( linter ) ) [EOL] [EOL] [EOL] class AssertMessage ( BaseChecker ) : [EOL] __implements__ = IAstroidChecker [EOL] [EOL] name = [string] [EOL] priority = - [number] [EOL] msgs = { [string] : ( ASSERT_MSG , ASSERT_ID , [string] ) } [EOL] [EOL] def visit_assert ( self , node ) : [EOL] if len ( list ( node . get_children ( ) ) ) != [number] : [EOL] self . add_message ( ASSERT_ID , node = node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] hiddenimports = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
import os [EOL] [EOL] [docstring] [EOL] [EOL] if not any ( k in os . environ for k in [ [string] , [string] , [string] ] ) : [EOL] print ( [string] ) [EOL] os . environ [ [string] ] = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from gevent . monkey import patch_all [EOL] [EOL] patch_all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] hiddenimports = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from PyInstaller . utils . hooks import collect_data_files [EOL] [EOL] datas = collect_data_files ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict [EOL] import typing [EOL] from eth_utils import denoms , to_hex [EOL] [EOL] from raiden . constants import Environment [EOL] from raiden . utils . typing import FeeAmount , NetworkTimeout , TokenAmount [EOL] [EOL] INITIAL_PORT = [number] [EOL] [EOL] CACHE_TTL = [number] [EOL] GAS_LIMIT = [number] * [number] ** [number] [EOL] GAS_LIMIT_HEX = to_hex ( GAS_LIMIT ) [EOL] GAS_PRICE = denoms . shannon * [number] [comment] [EOL] [EOL] DEFAULT_TRANSPORT_RETRIES_BEFORE_BACKOFF = [number] [EOL] DEFAULT_TRANSPORT_THROTTLE_CAPACITY = [number] [EOL] DEFAULT_TRANSPORT_THROTTLE_FILL_RATE = [number] [EOL] DEFAULT_TRANSPORT_UDP_RETRY_INTERVAL = [number] [EOL] [comment] [EOL] DEFAULT_TRANSPORT_MATRIX_RETRY_INTERVAL = [number] [EOL] DEFAULT_MATRIX_KNOWN_SERVERS = { Environment . PRODUCTION : ( [string] [string] ) , Environment . DEVELOPMENT : ( [string] [string] ) , } [EOL] [EOL] DEFAULT_REVEAL_TIMEOUT = [number] [EOL] DEFAULT_SETTLE_TIMEOUT = [number] [EOL] DEFAULT_RETRY_TIMEOUT = NetworkTimeout ( [number] ) [EOL] DEFAULT_JOINABLE_FUNDS_TARGET = [number] [EOL] DEFAULT_INITIAL_CHANNEL_TARGET = [number] [EOL] DEFAULT_WAIT_FOR_SETTLE = True [EOL] DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS = [number] [EOL] DEFAULT_WAIT_BEFORE_LOCK_REMOVAL = [number] * DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS [EOL] DEFAULT_CHANNEL_SYNC_TIMEOUT = [number] [EOL] [EOL] DEFAULT_NAT_KEEPALIVE_RETRIES = [number] [EOL] DEFAULT_NAT_KEEPALIVE_TIMEOUT = [number] [EOL] DEFAULT_NAT_INVITATION_TIMEOUT = [number] [EOL] [EOL] DEFAULT_SHUTDOWN_TIMEOUT = [number] [EOL] [EOL] DEFAULT_PATHFINDING_MAX_PATHS = [number] [EOL] DEFAULT_PATHFINDING_MAX_FEE = [number] [EOL] DEFAULT_PATHFINDING_IOU_TIMEOUT = [number] [comment] [EOL] [EOL] ORACLE_BLOCKNUMBER_DRIFT_TOLERANCE = [number] [EOL] ETHERSCAN_API = [string] [EOL] [EOL] RED_EYES_CONTRACT_VERSION = [string] [EOL] DEVELOPMENT_CONTRACT_VERSION = [string] [EOL] [EOL] MIN_REI_THRESHOLD = [number] [EOL] [EOL] MONITORING_REWARD = TokenAmount ( [number] ) [EOL] MONITORING_MIN_CAPACITY = TokenAmount ( [number] ) [EOL] [EOL] MEDIATION_FEE = FeeAmount ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , Dict , Optional [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Dict , Optional [EOL] [EOL] [EOL] class RaidenError ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class RaidenRecoverableError ( RaidenError ) : [EOL] pass [EOL] [EOL] [EOL] class RaidenUnrecoverableError ( RaidenError ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HashLengthNot32 ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class UnknownEventType ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ChannelNotFound ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class PaymentConflict ( RaidenRecoverableError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InsufficientFunds ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class DepositOverLimit ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class DepositMismatch ( RaidenRecoverableError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidAddress ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidSecret ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidSecretHash ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidAmount ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidSettleTimeout ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidSignature ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class SamePeerAddress ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnknownAddress ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class UnknownTokenAddress ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class TokenNotRegistered ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class AlreadyRegisteredTokenAddress ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidToken ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class STUNUnavailableException ( RaidenError ) : [EOL] pass [EOL] [EOL] [EOL] class EthNodeCommunicationError ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , error_msg ) : [EOL] super ( ) . __init__ ( error_msg ) [EOL] [EOL] [EOL] class EthNodeInterfaceError ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class AddressWithoutCode ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class AddressWrongContract ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class DuplicatedChannelError ( RaidenRecoverableError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ContractVersionMismatch ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TransactionThrew ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , txname , receipt ) : [EOL] super ( ) . __init__ ( [string] . format ( txname , receipt ) ) [EOL] [EOL] [EOL] class InvalidProtocolMessage ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class APIServerPortInUseError ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class RaidenServicePortInUseError ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidDBData ( RaidenUnrecoverableError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidBlockNumberInput ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NoStateForBlockIdentifier ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidNumberInput ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TransportError ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ReplacementTransactionUnderpriced ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TransactionAlreadyPending ( RaidenUnrecoverableError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ChannelOutdatedError ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InsufficientGasReserve ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ServiceRequestFailed ( RaidenError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ServiceRequestIOURejected ( ServiceRequestFailed ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , message , error_code ) : [EOL] super ( ) . __init__ ( f"{ message } [string] { error_code } [string] " ) [EOL] self . error_code = error_code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0
	0
from typing import Tuple , Optional , Match [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import re [EOL] [EOL] from raiden . constants import EthClient [EOL] from raiden . utils . typing import Optional , Tuple [EOL] [EOL] [EOL] def is_supported_client ( client_version , ) : [EOL] if client_version . startswith ( [string] ) : [EOL] matches = re . search ( [string] , client_version ) [EOL] if matches is None : [EOL] return False , None [EOL] major , minor , patch = [ int ( x ) for x in matches . groups ( ) ] [EOL] if ( major , minor , patch ) >= ( [number] , [number] , [number] ) : [EOL] return True , EthClient . PARITY [EOL] elif client_version . startswith ( [string] ) : [EOL] matches = re . search ( [string] , client_version ) [EOL] if matches is None : [EOL] return False , None [EOL] major , minor , patch = [ int ( x ) for x in matches . groups ( ) ] [EOL] if ( major , minor , patch ) >= ( [number] , [number] , [number] ) : [EOL] return True , EthClient . GETH [EOL] [EOL] return False , None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Tuple[builtins.bool,raiden.utils.typing.Optional[raiden.constants.EthClient]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import web3 [EOL] import builtins [EOL] import raiden [EOL] import typing [EOL] import raiden_contracts [EOL] import structlog [EOL] from eth_utils import decode_hex , event_abi_to_log_topic , to_checksum_address [EOL] from gevent . lock import Semaphore [EOL] from web3 import Web3 [EOL] from web3 . utils . abi import filter_by_type [EOL] from web3 . utils . events import get_event_data [EOL] from web3 . utils . filters import LogFilter , construct_event_filter_params [EOL] [EOL] from raiden . constants import GENESIS_BLOCK_NUMBER [EOL] from raiden . utils import block_specification_to_number [EOL] from raiden . utils . typing import ( Any , BlockNumber , BlockSpecification , ChannelID , Dict , List , TokenNetworkAddress , ) [EOL] from raiden_contracts . constants import CONTRACT_TOKEN_NETWORK , ChannelEvent [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] log = structlog . get_logger ( __name__ ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] FILTER_MAX_BLOCK_RANGE = [number] [EOL] [EOL] [EOL] def get_filter_args_for_specific_event_from_channel ( token_network_address , channel_identifier , event_name , contract_manager , from_block = GENESIS_BLOCK_NUMBER , to_block = [string] , ) : [EOL] [docstring] [EOL] if not event_name : [EOL] raise ValueError ( [string] ) [EOL] [EOL] event_abi = contract_manager . get_event_abi ( CONTRACT_TOKEN_NETWORK , event_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _ , event_filter_params = construct_event_filter_params ( event_abi = event_abi , contract_address = to_checksum_address ( token_network_address ) , argument_filters = { [string] : channel_identifier } , fromBlock = from_block , toBlock = to_block , ) [EOL] [EOL] return event_filter_params [EOL] [EOL] [EOL] def get_filter_args_for_all_events_from_channel ( token_network_address , channel_identifier , contract_manager , from_block = GENESIS_BLOCK_NUMBER , to_block = [string] , ) : [EOL] [docstring] [EOL] [EOL] event_filter_params = get_filter_args_for_specific_event_from_channel ( token_network_address = token_network_address , channel_identifier = channel_identifier , event_name = ChannelEvent . OPENED , contract_manager = contract_manager , from_block = from_block , to_block = to_block , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] event_filter_params [ [string] ] = [ None , event_filter_params [ [string] ] [ [number] ] ] [EOL] [EOL] return event_filter_params [EOL] [EOL] [EOL] def decode_event ( abi , log ) : [EOL] [docstring] [EOL] if isinstance ( log [ [string] ] [ [number] ] , str ) : [EOL] log [ [string] ] [ [number] ] = decode_hex ( log [ [string] ] [ [number] ] ) [EOL] elif isinstance ( log [ [string] ] [ [number] ] , int ) : [EOL] log [ [string] ] [ [number] ] = decode_hex ( hex ( log [ [string] ] [ [number] ] ) ) [EOL] event_id = log [ [string] ] [ [number] ] [EOL] events = filter_by_type ( [string] , abi ) [EOL] topic_to_event_abi = { event_abi_to_log_topic ( event_abi ) : event_abi for event_abi in events } [EOL] event_abi = topic_to_event_abi [ event_id ] [EOL] return get_event_data ( event_abi , log ) [EOL] [EOL] [EOL] class StatelessFilter ( LogFilter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , web3 , filter_params ) : [EOL] super ( ) . __init__ ( web3 , filter_id = None ) [EOL] self . filter_params = filter_params [EOL] self . _last_block = BlockNumber ( - [number] ) [EOL] self . _lock = Semaphore ( ) [EOL] [EOL] def _do_get_new_entries ( self , from_block , to_block ) : [EOL] filter_params = self . filter_params . copy ( ) [EOL] filter_params [ [string] ] = from_block [EOL] filter_params [ [string] ] = to_block [EOL] [EOL] log . debug ( [string] , from_block = from_block , to_block = to_block ) [EOL] result = self . web3 . eth . getLogs ( filter_params ) [EOL] self . _last_block = block_specification_to_number ( block = to_block , web3 = self . web3 ) [EOL] return result [EOL] [EOL] def get_new_entries ( self , target_block_number ) : [EOL] with self . _lock : [EOL] result = [ ] [EOL] filter_from_number = block_specification_to_number ( block = self . filter_params . get ( [string] , GENESIS_BLOCK_NUMBER ) , web3 = self . web3 ) [EOL] from_block_number = max ( filter_from_number , self . _last_block + [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] while from_block_number <= target_block_number : [EOL] to_block = min ( from_block_number + FILTER_MAX_BLOCK_RANGE , target_block_number ) [EOL] result . extend ( self . _do_get_new_entries ( from_block = from_block_number , to_block = to_block ) ) [EOL] from_block_number += FILTER_MAX_BLOCK_RANGE [EOL] [EOL] return result [EOL] [EOL] def get_all_entries ( self , block_number = None ) : [EOL] with self . _lock : [EOL] filter_params = self . filter_params . copy ( ) [EOL] block_number = block_number or self . web3 . eth . blockNumber [EOL] [EOL] if self . filter_params . get ( [string] ) in ( [string] , [string] ) : [EOL] filter_params [ [string] ] = block_number [EOL] [EOL] result = self . web3 . eth . getLogs ( filter_params ) [EOL] to_block = filter_params . get ( [string] ) [EOL] if to_block : [EOL] self . _last_block = block_specification_to_number ( block = to_block , web3 = self . web3 ) [EOL] else : [EOL] self . _last_block = block_number [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.Web3$ 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.BlockSpecification]$ 0 0 0 0 0 0 0 0 0 $web3.Web3$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.BlockSpecification]$ 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.BlockSpecification]$ 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockSpecification$ 0 $raiden.utils.typing.BlockSpecification$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $raiden.utils.typing.BlockSpecification$ 0 $typing.Any$ 0 0 0 0 $raiden.utils.typing.BlockSpecification$ 0 0 $typing.Any$ 0 0 0 0 0 $raiden.utils.typing.BlockSpecification$ 0 $raiden.utils.typing.BlockSpecification$ 0 $raiden.utils.typing.BlockSpecification$ 0 $raiden.utils.typing.BlockSpecification$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockSpecification$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $raiden.utils.typing.List[raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]]$ 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List[raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $raiden.utils.typing.BlockNumber$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $raiden.utils.typing.BlockNumber$ 0 0 $raiden.utils.typing.List[raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $raiden.utils.typing.List[raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , List [EOL] import pathlib [EOL] import builtins [EOL] import raiden [EOL] import typing [EOL] import sqlite3 [EOL] import os [EOL] import sqlite3 [EOL] from contextlib import closing [EOL] from glob import escape , glob [EOL] from pathlib import Path [EOL] [EOL] import filelock [EOL] import structlog [EOL] [EOL] from raiden . constants import RAIDEN_DB_VERSION [EOL] from raiden . storage . migrations . v16_to_v17 import upgrade_v16_to_v17 [EOL] from raiden . storage . migrations . v17_to_v18 import upgrade_v17_to_v18 [EOL] from raiden . storage . migrations . v18_to_v19 import upgrade_v18_to_v19 [EOL] from raiden . storage . migrations . v19_to_v20 import upgrade_v19_to_v20 [EOL] from raiden . storage . migrations . v20_to_v21 import upgrade_v20_to_v21 [EOL] from raiden . storage . migrations . v21_to_v22 import upgrade_v21_to_v22 [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . storage . versions import VERSION_RE , filter_db_names , latest_db_file [EOL] from raiden . utils . typing import Callable , List , NamedTuple [EOL] [EOL] [EOL] class UpgradeRecord ( NamedTuple ) : [EOL] from_version = ... [EOL] function = ... [EOL] [EOL] [EOL] UPGRADES_LIST = [ UpgradeRecord ( from_version = [number] , function = upgrade_v16_to_v17 ) , UpgradeRecord ( from_version = [number] , function = upgrade_v17_to_v18 ) , UpgradeRecord ( from_version = [number] , function = upgrade_v18_to_v19 ) , UpgradeRecord ( from_version = [number] , function = upgrade_v19_to_v20 ) , UpgradeRecord ( from_version = [number] , function = upgrade_v20_to_v21 ) , UpgradeRecord ( from_version = [number] , function = upgrade_v21_to_v22 ) , ] [EOL] [EOL] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] def get_file_lock ( db_filename ) : [EOL] lock_file_name = f"{ db_filename } [string] " [EOL] return filelock . FileLock ( lock_file_name ) [EOL] [EOL] [EOL] def update_version ( storage , version ) : [EOL] cursor = storage . conn . cursor ( ) [EOL] cursor . execute ( [string] , ( str ( version ) , ) ) [EOL] [EOL] [EOL] def get_file_version ( db_path ) : [EOL] match = VERSION_RE . match ( os . path . basename ( db_path ) ) [EOL] assert match , f' [string] { db_path } [string] ' [EOL] file_version = int ( match . group ( [number] ) ) [EOL] return file_version [EOL] [EOL] [EOL] def get_db_version ( db_filename ) : [EOL] [docstring] [EOL] [EOL] assert os . path . exists ( db_filename ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] conn = sqlite3 . connect ( str ( db_filename ) , detect_types = sqlite3 . PARSE_DECLTYPES ) [EOL] cursor = conn . cursor ( ) [EOL] [EOL] try : [EOL] cursor . execute ( [string] ) [EOL] result = cursor . fetchone ( ) [EOL] except sqlite3 . OperationalError : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] if not result : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] return int ( result [ [number] ] ) [EOL] [EOL] [EOL] def _copy ( old_db_filename , current_db_filename ) : [EOL] old_conn = sqlite3 . connect ( old_db_filename , detect_types = sqlite3 . PARSE_DECLTYPES ) [EOL] current_conn = sqlite3 . connect ( current_db_filename , detect_types = sqlite3 . PARSE_DECLTYPES ) [EOL] [EOL] with closing ( old_conn ) , closing ( current_conn ) : [EOL] old_conn . backup ( current_conn ) [EOL] [EOL] [EOL] def delete_dbs_with_failed_migrations ( valid_db_names ) : [EOL] for db_path in valid_db_names : [EOL] file_version = get_file_version ( db_path ) [EOL] [EOL] with get_file_lock ( db_path ) : [EOL] db_version = get_db_version ( db_path ) [EOL] [EOL] [comment] [EOL] if db_version == file_version : [EOL] continue [EOL] [EOL] elif db_version > file_version : [EOL] raise RuntimeError ( f" [string] " f" [string] { db_path } [string] { db_version } [string] " f" [string] " ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] os . remove ( db_path ) [EOL] [EOL] [EOL] class UpgradeManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , db_filename , ** kwargs ) : [EOL] base_name = os . path . basename ( db_filename ) [EOL] match = VERSION_RE . match ( base_name ) [EOL] assert match , f' [string] { base_name } [string] ' [EOL] [EOL] self . _current_db_filename = Path ( db_filename ) [EOL] self . _current_version = get_file_version ( self . _current_db_filename ) [EOL] self . _kwargs = kwargs [EOL] [EOL] def run ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] escaped_path = escape ( str ( self . _current_db_filename . parent ) ) [EOL] paths = glob ( f"{ escaped_path } [string] " ) [EOL] valid_db_names = filter_db_names ( paths ) [EOL] delete_dbs_with_failed_migrations ( valid_db_names ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] paths = glob ( f"{ escaped_path } [string] " ) [EOL] valid_db_names = filter_db_names ( paths ) [EOL] latest_db_path = latest_db_file ( valid_db_names ) [EOL] [EOL] [comment] [EOL] if latest_db_path is None : [EOL] return [EOL] [EOL] file_version = get_file_version ( latest_db_path ) [EOL] [EOL] [comment] [EOL] if file_version == RAIDEN_DB_VERSION : [EOL] return [EOL] [EOL] if file_version > RAIDEN_DB_VERSION : [EOL] raise RuntimeError ( f" [string] { file_version } [string] " f" [string] { RAIDEN_DB_VERSION } [string] " f" [string] " f" [string] " f" [string] " f" [string] " ) [EOL] [EOL] self . _upgrade ( target_file = str ( self . _current_db_filename ) , from_file = latest_db_path , from_version = file_version , ) [EOL] [EOL] def _upgrade ( self , target_file , from_file , from_version ) : [EOL] with get_file_lock ( from_file ) , get_file_lock ( target_file ) : [EOL] _copy ( from_file , target_file ) [EOL] [EOL] storage = SQLiteStorage ( target_file ) [EOL] [EOL] log . debug ( f" [string] { from_version } [string] { RAIDEN_DB_VERSION }" ) [EOL] [EOL] try : [EOL] version_iteration = from_version [EOL] [EOL] with storage . transaction ( ) : [EOL] for upgrade_record in UPGRADES_LIST : [EOL] if upgrade_record . from_version < from_version : [EOL] continue [EOL] [EOL] version_iteration = upgrade_record . function ( storage = storage , old_version = version_iteration , current_version = RAIDEN_DB_VERSION , ** self . _kwargs , ) [EOL] [EOL] update_version ( storage , RAIDEN_DB_VERSION ) [EOL] except BaseException as e : [EOL] log . error ( f" [string] { e }" ) [EOL] raise [EOL] [EOL] storage . conn . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $raiden.utils.typing.Callable$ 0 0 0 0 0 $typing.List[raiden.utils.upgrades.UpgradeRecord]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $builtins.int$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $raiden.storage.sqlite.SQLiteStorage$ 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $raiden.storage.sqlite.SQLiteStorage$ 0 0 0 0 0 0 0 0 0 $typing.List[raiden.utils.upgrades.UpgradeRecord]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $raiden.storage.sqlite.SQLiteStorage$ 0 $raiden.storage.sqlite.SQLiteStorage$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.storage.sqlite.SQLiteStorage$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.storage.sqlite.SQLiteStorage$ 0 0 0 0 0 0 0
from typing import Sequence , Any , Dict [EOL] import gevent [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Sequence [EOL] [EOL] import structlog [EOL] from gevent import Greenlet [EOL] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class Runnable : [EOL] [docstring] [EOL] [EOL] greenlet = None [EOL] args = tuple ( ) [comment] [EOL] kwargs = dict ( ) [comment] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] [EOL] self . greenlet = Greenlet ( self . _run , * self . args , ** self . kwargs ) [EOL] self . greenlet . name = f"{ self . __class__ . __name__ } [string] { self . greenlet . name }" [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] if self . greenlet : [EOL] raise RuntimeError ( f" [string] { self . greenlet !r} [string] " ) [EOL] pristine = ( not self . greenlet . dead [EOL] and tuple ( self . greenlet . args ) == tuple ( self . args ) [EOL] and self . greenlet . kwargs == self . kwargs ) [EOL] if not pristine : [EOL] self . greenlet = Greenlet ( self . _run , * self . args , ** self . kwargs ) [EOL] self . greenlet . name = f"{ self . __class__ . __name__ } [string] { self . greenlet . name }" [EOL] self . greenlet . start ( ) [EOL] [EOL] def _run ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def on_error ( self , subtask ) : [EOL] [docstring] [EOL] log . error ( [string] , this = self , running = bool ( self ) , subtask = subtask , exc = subtask . exception , ) [EOL] if not self . greenlet : [EOL] return [EOL] self . greenlet . kill ( subtask . exception ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __getattr__ ( self , item ) : [EOL] return getattr ( self . greenlet , item ) [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . greenlet ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gevent.Greenlet$ 0 0 0 $typing.Sequence$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 $typing.Sequence[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $gevent.Greenlet$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gevent.Greenlet$ 0 $gevent.Greenlet$ 0 0 0 $gevent.Greenlet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $gevent.Greenlet$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import copy [EOL] import random [EOL] from collections import deque [EOL] [EOL] import gevent [EOL] import structlog [EOL] from gevent . event import Event [EOL] from gevent . lock import BoundedSemaphore [EOL] from gevent . queue import Queue [EOL] from gevent . timeout import Timeout [EOL] [EOL] from raiden . api . python import RaidenAPI [EOL] from raiden . tasks import REMOVE_CALLBACK [EOL] from raiden . transfer import channel [EOL] from raiden . transfer . events import EventPaymentReceivedSuccess [EOL] from raiden . transfer . state import CHANNEL_STATE_OPENED [EOL] from raiden . utils import pex [EOL] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [comment] [EOL] TRANSFER_MEMORY = [number] [EOL] [EOL] [EOL] class EchoNode : [EOL] def __init__ ( self , api , token_address ) : [EOL] assert isinstance ( api , RaidenAPI ) [EOL] self . ready = Event ( ) [EOL] [EOL] self . api = api [EOL] self . token_address = token_address [EOL] [EOL] existing_channels = self . api . get_channel_list ( api . raiden . default_registry . address , self . token_address ) [EOL] [EOL] open_channels = [ channel_state for channel_state in existing_channels if channel . get_status ( channel_state ) == CHANNEL_STATE_OPENED ] [EOL] [EOL] if len ( open_channels ) == [number] : [EOL] token = self . api . raiden . chain . token ( self . token_address ) [EOL] if not token . balance_of ( self . api . raiden . address ) > [number] : [EOL] raise ValueError ( [string] % ( pex ( self . api . raiden . address ) , pex ( self . token_address ) ) ) [EOL] self . api . token_network_connect ( self . api . raiden . default_registry . address , self . token_address , token . balance_of ( self . api . raiden . address ) , initial_channel_target = [number] , joinable_funds_target = [number] , ) [EOL] [EOL] self . last_poll_offset = [number] [EOL] self . received_transfers = Queue ( ) [EOL] self . stop_signal = None [comment] [EOL] self . greenlets = set ( ) [EOL] self . lock = BoundedSemaphore ( ) [EOL] self . seen_transfers = deque ( list ( ) , TRANSFER_MEMORY ) [EOL] self . num_handled_transfers = [number] [EOL] self . lottery_pool = Queue ( ) [EOL] [comment] [EOL] self . api . raiden . alarm . register_callback ( self . echo_node_alarm_callback ) [EOL] self . echo_worker_greenlet = gevent . spawn ( self . echo_worker ) [EOL] log . info ( [string] ) [EOL] [EOL] def echo_node_alarm_callback ( self , block_number ) : [EOL] [docstring] [EOL] if not self . ready . is_set ( ) : [EOL] self . ready . set ( ) [EOL] log . debug ( [string] , block_number = block_number ) [EOL] if self . stop_signal is not None : [EOL] return REMOVE_CALLBACK [EOL] else : [EOL] self . greenlets . add ( gevent . spawn ( self . poll_all_received_events ) ) [EOL] return True [EOL] [EOL] def poll_all_received_events ( self ) : [EOL] [docstring] [EOL] [EOL] locked = False [EOL] try : [EOL] with Timeout ( [number] ) : [EOL] locked = self . lock . acquire ( blocking = False ) [EOL] if not locked : [EOL] return [EOL] else : [EOL] received_transfers = self . api . get_raiden_events_payment_history ( token_address = self . token_address , offset = self . last_poll_offset ) [EOL] [EOL] [comment] [EOL] received_transfers = [ event for event in received_transfers if type ( event ) == EventPaymentReceivedSuccess ] [EOL] [EOL] for event in received_transfers : [EOL] transfer = copy . deepcopy ( event ) [EOL] self . received_transfers . put ( transfer ) [EOL] [EOL] [comment] [EOL] if received_transfers : [EOL] self . last_poll_offset += len ( received_transfers ) [EOL] [EOL] if not self . echo_worker_greenlet . started : [EOL] log . debug ( [string] , dead = self . echo_worker_greenlet . dead , successful = self . echo_worker_greenlet . successful ( ) , exception = self . echo_worker_greenlet . exception , ) [EOL] self . echo_worker_greenlet = gevent . spawn ( self . echo_worker ) [EOL] except Timeout : [EOL] log . info ( [string] ) [EOL] finally : [EOL] if locked : [EOL] self . lock . release ( ) [EOL] [EOL] def echo_worker ( self ) : [EOL] [docstring] [EOL] log . debug ( [string] , qsize = self . received_transfers . qsize ( ) ) [EOL] while self . stop_signal is None : [EOL] if self . received_transfers . qsize ( ) > [number] : [EOL] transfer = self . received_transfers . get ( ) [EOL] if transfer in self . seen_transfers : [EOL] log . debug ( [string] , initiator = pex ( transfer . initiator ) , amount = transfer . amount , identifier = transfer . identifier , ) [EOL] else : [EOL] self . seen_transfers . append ( transfer ) [EOL] self . greenlets . add ( gevent . spawn ( self . on_transfer , transfer ) ) [EOL] else : [EOL] gevent . sleep ( [number] ) [EOL] [EOL] def on_transfer ( self , transfer ) : [EOL] [docstring] [EOL] echo_amount = [number] [EOL] if transfer . amount % [number] == [number] : [EOL] log . info ( [string] , initiator = pex ( transfer . initiator ) , amount = transfer . amount , identifier = transfer . identifier , ) [EOL] echo_amount = transfer . amount - [number] [EOL] [EOL] elif transfer . amount == [number] : [EOL] log . info ( [string] , initiator = pex ( transfer . initiator ) , amount = transfer . amount , identifier = transfer . identifier , poolsize = self . lottery_pool . qsize ( ) , ) [EOL] [EOL] [comment] [EOL] pool = self . lottery_pool . copy ( ) [EOL] tickets = [ pool . get ( ) for _ in range ( pool . qsize ( ) ) ] [EOL] assert pool . empty ( ) [EOL] del pool [EOL] [EOL] if any ( ticket . initiator == transfer . initiator for ticket in tickets ) : [EOL] assert transfer not in tickets [EOL] log . debug ( [string] , initiator = pex ( transfer . initiator ) , identifier = transfer . identifier , poolsize = len ( tickets ) , ) [EOL] [comment] [EOL] echo_amount = len ( tickets ) [EOL] [EOL] [comment] [EOL] elif len ( tickets ) == [number] : [EOL] log . info ( [string] ) [EOL] [comment] [EOL] assert self . lottery_pool . qsize ( ) == [number] [EOL] self . lottery_pool = Queue ( ) [EOL] [comment] [EOL] tickets . append ( transfer ) [EOL] [comment] [EOL] transfer = random . choice ( tickets ) [EOL] echo_amount = [number] [EOL] else : [EOL] self . lottery_pool . put ( transfer ) [EOL] [EOL] else : [EOL] log . debug ( [string] , initiator = pex ( transfer . initiator ) , amount = transfer . amount , identifier = transfer . identifier , ) [EOL] echo_amount = transfer . amount [EOL] [EOL] if echo_amount : [EOL] log . debug ( [string] , target = pex ( transfer . initiator ) , amount = echo_amount , orig_identifier = transfer . identifier , echo_identifier = transfer . identifier + echo_amount , token_address = pex ( self . token_address ) , num_handled_transfers = self . num_handled_transfers + [number] , ) [EOL] [EOL] self . api . transfer ( self . api . raiden . default_registry . address , self . token_address , echo_amount , transfer . initiator , identifier = transfer . identifier + echo_amount , ) [EOL] self . num_handled_transfers += [number] [EOL] [EOL] def stop ( self ) : [EOL] self . stop_signal = True [EOL] self . greenlets . add ( self . echo_worker_greenlet ) [EOL] gevent . joinall ( self . greenlets , raise_error = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict [EOL] import raiden_contracts [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] from eth_utils import to_canonical_address [EOL] [EOL] from raiden . network . rpc . client import JSONRPCClient [EOL] from raiden . utils . typing import Address , Any , Tuple [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] [EOL] def deploy_contract_web3 ( contract_name , deploy_client , contract_manager , constructor_arguments = None , ) : [EOL] compiled = { contract_name : contract_manager . get_contract ( contract_name ) } [EOL] contract_proxy , _ = deploy_client . deploy_solidity_contract ( contract_name = contract_name , all_contracts = compiled , constructor_parameters = constructor_arguments , ) [EOL] return Address ( to_canonical_address ( contract_proxy . contract . address ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] from typing import Any , List [EOL] [EOL] from eth_utils import decode_hex , keccak , remove_0x_prefix [EOL] from web3 . utils . abi import map_abi_data [EOL] from web3 . utils . encoding import hex_encode_abi_type [EOL] from web3 . utils . normalizers import abi_address_to_hex [EOL] [EOL] sha3 = keccak [EOL] [EOL] [EOL] def pack_data ( abi_types , values ) : [EOL] [docstring] [EOL] if len ( abi_types ) != len ( values ) : [EOL] raise ValueError ( [string] [string] . format ( len ( abi_types ) , len ( values ) ) ) [EOL] [EOL] normalized_values = map_abi_data ( [ abi_address_to_hex ] , abi_types , values ) [EOL] [EOL] return decode_hex ( [string] . join ( remove_0x_prefix ( hex_encode_abi_type ( abi_type , value ) ) for abi_type , value in zip ( abi_types , normalized_values ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Optional , Any , Tuple , Literal [EOL] import networkx [EOL] import builtins [EOL] import raiden [EOL] import typing [EOL] import random [EOL] import typing_extensions [EOL] import random [EOL] from collections import defaultdict [EOL] from functools import total_ordering [EOL] from random import Random [EOL] from typing import TYPE_CHECKING , Tuple [EOL] [EOL] import networkx [EOL] from eth_utils import encode_hex , to_canonical_address , to_checksum_address [EOL] [EOL] from raiden . constants import EMPTY_MERKLE_ROOT , UINT64_MAX , UINT256_MAX [EOL] from raiden . encoding import messages [EOL] from raiden . encoding . format import buffer_for [EOL] from raiden . transfer . architecture import ContractSendEvent , SendMessageEvent , State [EOL] from raiden . transfer . identifiers import CanonicalIdentifier , QueueIdentifier [EOL] from raiden . transfer . merkle_tree import merkleroot [EOL] from raiden . transfer . utils import hash_balance_data , pseudo_random_generator_from_json [EOL] from raiden . utils import lpex , pex , serialization , sha3 [EOL] from raiden . utils . serialization import map_dict , map_list , serialize_bytes [EOL] from raiden . utils . typing import ( AdditionalHash , Address , Any , Balance , BalanceHash , BlockExpiration , BlockHash , BlockNumber , BlockTimeout , ChainID , ChannelID , ChannelMap , Dict , FeeAmount , Keccak256 , List , LockHash , Locksroot , MessageID , Nonce , Optional , PaymentNetworkID , PaymentWithFeeAmount , Secret , SecretHash , Signature , T_Address , T_BlockHash , T_BlockNumber , T_ChainID , T_ChannelID , T_Keccak256 , T_PaymentWithFeeAmount , T_Secret , T_Signature , T_TokenAmount , TokenAddress , TokenAmount , TokenNetworkAddress , TokenNetworkID , Union , ) [EOL] [EOL] if TYPE_CHECKING : [EOL] [comment] [EOL] from messages import EnvelopeMessage [EOL] from raiden . transfer . mediated_transfer . state import MediatorTransferState , TargetTransferState [EOL] from raiden . transfer . mediated_transfer . state import InitiatorPaymentState [EOL] [EOL] SecretHashToLock = Dict [ SecretHash , [string] ] [EOL] SecretHashToPartialUnlockProof = Dict [ SecretHash , [string] ] [EOL] QueueIdsToQueues = Dict [ QueueIdentifier , List [ SendMessageEvent ] ] [EOL] OptionalBalanceProofState = Optional [ Union [ [string] , [string] ] ] [EOL] [EOL] CHANNEL_STATE_CLOSED = [string] [EOL] CHANNEL_STATE_CLOSING = [string] [EOL] CHANNEL_STATE_OPENED = [string] [EOL] CHANNEL_STATE_SETTLED = [string] [EOL] CHANNEL_STATE_SETTLING = [string] [EOL] CHANNEL_STATE_UNUSABLE = [string] [EOL] [EOL] CHANNEL_ALL_VALID_STATES = ( CHANNEL_STATE_CLOSED , CHANNEL_STATE_CLOSING , CHANNEL_STATE_OPENED , CHANNEL_STATE_SETTLED , CHANNEL_STATE_SETTLING , CHANNEL_STATE_UNUSABLE , ) [EOL] [EOL] CHANNEL_STATES_PRIOR_TO_CLOSED = ( CHANNEL_STATE_OPENED , CHANNEL_STATE_CLOSING ) [EOL] [EOL] CHANNEL_AFTER_CLOSE_STATES = ( CHANNEL_STATE_CLOSED , CHANNEL_STATE_SETTLING , CHANNEL_STATE_SETTLED ) [EOL] [EOL] NODE_NETWORK_UNKNOWN = [string] [EOL] NODE_NETWORK_UNREACHABLE = [string] [EOL] NODE_NETWORK_REACHABLE = [string] [EOL] [EOL] [EOL] def balanceproof_from_envelope ( envelope_message , ) : [EOL] return BalanceProofSignedState ( nonce = envelope_message . nonce , transferred_amount = envelope_message . transferred_amount , locked_amount = envelope_message . locked_amount , locksroot = envelope_message . locksroot , message_hash = envelope_message . message_hash , signature = envelope_message . signature , sender = envelope_message . sender , canonical_identifier = CanonicalIdentifier ( chain_identifier = envelope_message . chain_id , token_network_address = envelope_message . token_network_address , channel_identifier = envelope_message . channel_identifier , ) , ) [EOL] [EOL] [EOL] def make_empty_merkle_tree ( ) : [EOL] return MerkleTreeState ( [ [ ] , [ Keccak256 ( EMPTY_MERKLE_ROOT ) ] ] ) [EOL] [EOL] [EOL] def message_identifier_from_prng ( prng ) : [EOL] return MessageID ( prng . randint ( [number] , UINT64_MAX ) ) [EOL] [EOL] [EOL] def to_comparable_graph ( network ) : [EOL] return sorted ( sorted ( edge ) for edge in network . edges ( ) ) [EOL] [EOL] [EOL] class TransferTask ( State ) : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] class InitiatorTask ( TransferTask ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , token_network_identifier , manager_state ) : [EOL] self . token_network_identifier = token_network_identifier [EOL] self . manager_state = manager_state [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . token_network_identifier ) , self . manager_state ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , InitiatorTask ) [EOL] and self . token_network_identifier == other . token_network_identifier [EOL] and self . manager_state == other . manager_state ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . token_network_identifier ) , [string] : self . manager_state , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] return cls ( token_network_identifier = to_canonical_address ( data [ [string] ] ) , manager_state = data [ [string] ] , ) [EOL] [EOL] [EOL] class MediatorTask ( TransferTask ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , token_network_identifier , mediator_state ) : [EOL] self . token_network_identifier = token_network_identifier [EOL] self . mediator_state = mediator_state [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . token_network_identifier ) , self . mediator_state ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , MediatorTask ) [EOL] and self . token_network_identifier == other . token_network_identifier [EOL] and self . mediator_state == other . mediator_state ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . token_network_identifier ) , [string] : self . mediator_state , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( token_network_identifier = to_canonical_address ( data [ [string] ] ) , mediator_state = data [ [string] ] , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class TargetTask ( TransferTask ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , canonical_identifier , target_state ) : [EOL] self . canonical_identifier = canonical_identifier [EOL] self . target_state = target_state [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . token_network_identifier ) , self . channel_identifier , self . target_state ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , TargetTask ) [EOL] and self . token_network_identifier == other . token_network_identifier [EOL] and self . target_state == other . target_state [EOL] and self . channel_identifier == other . channel_identifier ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] @ property def token_network_identifier ( self ) : [EOL] return TokenNetworkID ( self . canonical_identifier . token_network_address ) [EOL] [EOL] @ property def channel_identifier ( self ) : [EOL] return self . canonical_identifier . channel_identifier [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . canonical_identifier . to_dict ( ) , [string] : self . target_state , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( canonical_identifier = CanonicalIdentifier . from_dict ( data [ [string] ] ) , target_state = data [ [string] ] , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class ChainState ( State ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pseudo_random_generator , block_number , block_hash , our_address , chain_id , ) : [EOL] if not isinstance ( block_number , T_BlockNumber ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( block_hash , T_BlockHash ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( chain_id , T_ChainID ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . block_number = block_number [EOL] self . block_hash = block_hash [EOL] self . chain_id = chain_id [EOL] self . identifiers_to_paymentnetworks = dict ( ) [EOL] self . nodeaddresses_to_networkstates = dict ( ) [EOL] self . our_address = our_address [EOL] self . payment_mapping = PaymentMappingState ( ) [EOL] self . pending_transactions = list ( ) [EOL] self . pseudo_random_generator = pseudo_random_generator [EOL] self . queueids_to_queues = dict ( ) [EOL] self . last_transport_authdata = None [EOL] self . tokennetworkaddresses_to_paymentnetworkaddresses = { } [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] ) . format ( self . block_number , pex ( self . block_hash ) , lpex ( self . identifiers_to_paymentnetworks . keys ( ) ) , len ( self . payment_mapping . secrethashes_to_task ) , self . chain_id , ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if other is None : [EOL] return False [EOL] [EOL] our_tnpn = self . tokennetworkaddresses_to_paymentnetworkaddresses [EOL] other_tnpn = other . tokennetworkaddresses_to_paymentnetworkaddresses [EOL] [EOL] return ( isinstance ( other , ChainState ) [EOL] and self . block_number == other . block_number [EOL] and self . block_hash == other . block_hash [EOL] and self . pseudo_random_generator . getstate ( ) == other . pseudo_random_generator . getstate ( ) [EOL] and self . queueids_to_queues == other . queueids_to_queues [EOL] and self . identifiers_to_paymentnetworks == other . identifiers_to_paymentnetworks [EOL] and self . nodeaddresses_to_networkstates == other . nodeaddresses_to_networkstates [EOL] and self . payment_mapping == other . payment_mapping [EOL] and self . chain_id == other . chain_id [EOL] and self . last_transport_authdata == other . last_transport_authdata [EOL] and our_tnpn == other_tnpn ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : str ( self . block_number ) , [string] : serialize_bytes ( self . block_hash ) , [string] : self . chain_id , [string] : self . pseudo_random_generator . getstate ( ) , [string] : map_dict ( to_checksum_address , serialization . identity , self . identifiers_to_paymentnetworks ) , [string] : map_dict ( to_checksum_address , serialization . identity , self . nodeaddresses_to_networkstates ) , [string] : to_checksum_address ( self . our_address ) , [string] : self . payment_mapping , [string] : self . pending_transactions , [string] : serialization . serialize_queueid_to_queue ( self . queueids_to_queues ) , [string] : self . last_transport_authdata , [string] : map_dict ( to_checksum_address , to_checksum_address , self . tokennetworkaddresses_to_paymentnetworkaddresses , ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] pseudo_random_generator = pseudo_random_generator_from_json ( data ) [EOL] [EOL] restored = cls ( pseudo_random_generator = pseudo_random_generator , block_number = BlockNumber ( T_BlockNumber ( data [ [string] ] ) ) , block_hash = BlockHash ( serialization . deserialize_bytes ( data [ [string] ] ) ) , our_address = to_canonical_address ( data [ [string] ] ) , chain_id = data [ [string] ] , ) [EOL] [EOL] restored . identifiers_to_paymentnetworks = map_dict ( to_canonical_address , serialization . identity , data [ [string] ] ) [EOL] restored . nodeaddresses_to_networkstates = map_dict ( to_canonical_address , serialization . identity , data [ [string] ] ) [EOL] restored . payment_mapping = data [ [string] ] [EOL] restored . pending_transactions = data [ [string] ] [EOL] restored . queueids_to_queues = serialization . deserialize_queueid_to_queue ( data [ [string] ] ) [EOL] restored . last_transport_authdata = data . get ( [string] ) [EOL] restored . tokennetworkaddresses_to_paymentnetworkaddresses = map_dict ( to_canonical_address , to_canonical_address , data [ [string] ] , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class PaymentNetworkState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , address , token_network_list ) : [EOL] if not isinstance ( address , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . address = address [EOL] self . tokenidentifiers_to_tokennetworks = { token_network . address : token_network for token_network in token_network_list } [EOL] self . tokenaddresses_to_tokenidentifiers = { token_network . token_address : token_network . address for token_network in token_network_list } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . address ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , PaymentNetworkState ) [EOL] and self . address == other . address [EOL] and self . tokenaddresses_to_tokenidentifiers == other . tokenaddresses_to_tokenidentifiers [EOL] and self . tokenidentifiers_to_tokennetworks == other . tokenidentifiers_to_tokennetworks ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . address ) , [string] : [ network for network in self . tokenidentifiers_to_tokennetworks . values ( ) ] , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( address = to_canonical_address ( data [ [string] ] ) , token_network_list = [ network for network in data [ [string] ] ] , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class TokenNetworkState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , address , token_address ) : [EOL] [EOL] if not isinstance ( address , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( token_address , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . address = address [EOL] self . token_address = token_address [EOL] self . network_graph = TokenNetworkGraphState ( self . address ) [EOL] [EOL] self . channelidentifiers_to_channels = dict ( ) [EOL] self . partneraddresses_to_channelidentifiers = defaultdict ( list ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . address ) , pex ( self . token_address ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , TokenNetworkState ) [EOL] and self . address == other . address [EOL] and self . token_address == other . token_address [EOL] and self . network_graph == other . network_graph [EOL] and self . channelidentifiers_to_channels == other . channelidentifiers_to_channels [EOL] and ( self . partneraddresses_to_channelidentifiers == other . partneraddresses_to_channelidentifiers ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . address ) , [string] : to_checksum_address ( self . token_address ) , [string] : self . network_graph , [string] : map_dict ( str , serialization . identity , self . channelidentifiers_to_channels , ) , [string] : map_dict ( to_checksum_address , serialization . identity , self . partneraddresses_to_channelidentifiers , ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( address = to_canonical_address ( data [ [string] ] ) , token_address = to_canonical_address ( data [ [string] ] ) , ) [EOL] restored . network_graph = data [ [string] ] [EOL] restored . channelidentifiers_to_channels = map_dict ( serialization . deserialize_channel_id , serialization . identity , data [ [string] ] , ) [EOL] [EOL] restored_partneraddresses_to_channelidentifiers = map_dict ( to_canonical_address , serialization . identity , data [ [string] ] , ) [EOL] restored . partneraddresses_to_channelidentifiers = defaultdict ( list , restored_partneraddresses_to_channelidentifiers ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class TokenNetworkGraphState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , token_network_address ) : [EOL] self . token_network_id = token_network_address [EOL] self . network = networkx . Graph ( ) [EOL] self . channel_identifier_to_participants = { } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( len ( self . network . edges ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , TokenNetworkGraphState ) [EOL] and self . token_network_id == other . token_network_id [EOL] and to_comparable_graph ( self . network ) == to_comparable_graph ( other . network ) [EOL] and self . channel_identifier_to_participants == other . channel_identifier_to_participants ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . token_network_id ) , [string] : serialization . serialize_networkx_graph ( self . network ) , [string] : map_dict ( str , serialization . serialize_participants_tuple , self . channel_identifier_to_participants , ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( token_network_address = to_canonical_address ( data [ [string] ] ) ) [EOL] restored . network = serialization . deserialize_networkx_graph ( data [ [string] ] ) [EOL] restored . channel_identifier_to_participants = map_dict ( serialization . deserialize_channel_id , serialization . deserialize_participants_tuple , data [ [string] ] , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class PaymentMappingState ( State ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . secrethashes_to_task = dict ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( len ( self . secrethashes_to_task ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , PaymentMappingState ) [EOL] and self . secrethashes_to_task == other . secrethashes_to_task ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : map_dict ( serialization . serialize_bytes , serialization . identity , self . secrethashes_to_task ) } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( ) [EOL] restored . secrethashes_to_task = map_dict ( serialization . deserialize_secret_hash , serialization . identity , data [ [string] ] , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class RouteState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , node_address , channel_identifier ) : [EOL] if not isinstance ( node_address , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . node_address = node_address [EOL] self . channel_identifier = channel_identifier [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( node = pex ( self . node_address ) , channel_identifier = self . channel_identifier ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , RouteState ) [EOL] and self . node_address == other . node_address [EOL] and self . channel_identifier == other . channel_identifier ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . node_address ) , [string] : str ( self . channel_identifier ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( node_address = to_canonical_address ( data [ [string] ] ) , channel_identifier = ChannelID ( int ( data [ [string] ] ) ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class BalanceProofUnsignedState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , nonce , transferred_amount , locked_amount , locksroot , canonical_identifier , ) : [EOL] if not isinstance ( nonce , int ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( transferred_amount , T_TokenAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( locked_amount , T_TokenAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( locksroot , T_Keccak256 ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if nonce <= [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if nonce > UINT64_MAX : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if transferred_amount < [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if transferred_amount > UINT256_MAX : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if len ( locksroot ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] canonical_identifier . validate ( ) [EOL] [EOL] self . nonce = nonce [EOL] self . transferred_amount = transferred_amount [EOL] self . locked_amount = locked_amount [EOL] self . locksroot = locksroot [EOL] self . canonical_identifier = canonical_identifier [EOL] [EOL] @ property def chain_id ( self ) : [EOL] return self . canonical_identifier . chain_identifier [EOL] [EOL] @ property def token_network_identifier ( self ) : [EOL] return TokenNetworkAddress ( self . canonical_identifier . token_network_address ) [EOL] [EOL] @ property def channel_identifier ( self ) : [EOL] return self . canonical_identifier . channel_identifier [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] [string] [string] ) . format ( self . nonce , self . transferred_amount , self . locked_amount , pex ( self . locksroot ) , pex ( self . token_network_identifier ) , self . channel_identifier , self . chain_id , ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , BalanceProofUnsignedState ) [EOL] and self . nonce == other . nonce [EOL] and self . transferred_amount == other . transferred_amount [EOL] and self . locked_amount == other . locked_amount [EOL] and self . locksroot == other . locksroot [EOL] and self . canonical_identifier == other . canonical_identifier ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] @ property def balance_hash ( self ) : [EOL] return hash_balance_data ( transferred_amount = self . transferred_amount , locked_amount = self . locked_amount , locksroot = self . locksroot , ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . nonce , [string] : str ( self . transferred_amount ) , [string] : str ( self . locked_amount ) , [string] : serialization . serialize_bytes ( self . locksroot ) , [string] : self . canonical_identifier . to_dict ( ) , [string] : serialize_bytes ( self . balance_hash ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( nonce = data [ [string] ] , transferred_amount = TokenAmount ( int ( data [ [string] ] ) ) , locked_amount = TokenAmount ( int ( data [ [string] ] ) ) , locksroot = Locksroot ( serialization . deserialize_bytes ( data [ [string] ] ) ) , canonical_identifier = CanonicalIdentifier . from_dict ( data [ [string] ] ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class BalanceProofSignedState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , nonce , transferred_amount , locked_amount , locksroot , message_hash , signature , sender , canonical_identifier , ) : [EOL] if not isinstance ( nonce , int ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( transferred_amount , T_TokenAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( locked_amount , T_TokenAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( locksroot , T_Keccak256 ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( message_hash , T_Keccak256 ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( signature , T_Signature ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( sender , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if nonce <= [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if nonce > UINT64_MAX : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if transferred_amount < [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if transferred_amount > UINT256_MAX : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if len ( locksroot ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if len ( message_hash ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if len ( signature ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] canonical_identifier . validate ( ) [EOL] [EOL] self . nonce = nonce [EOL] self . transferred_amount = transferred_amount [EOL] self . locked_amount = locked_amount [EOL] self . locksroot = locksroot [EOL] self . message_hash = message_hash [EOL] self . signature = signature [EOL] self . sender = sender [EOL] self . canonical_identifier = canonical_identifier [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] [string] [string] [string] [string] ) . format ( self . nonce , self . transferred_amount , self . locked_amount , pex ( self . locksroot ) , pex ( self . token_network_identifier ) , self . channel_identifier , pex ( self . message_hash ) , pex ( self . signature ) , pex ( self . sender ) , self . chain_id , ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , BalanceProofSignedState ) [EOL] and self . nonce == other . nonce [EOL] and self . transferred_amount == other . transferred_amount [EOL] and self . locked_amount == other . locked_amount [EOL] and self . locksroot == other . locksroot [EOL] and self . token_network_identifier == other . token_network_identifier [EOL] and self . channel_identifier == other . channel_identifier [EOL] and self . message_hash == other . message_hash [EOL] and self . signature == other . signature [EOL] and self . sender == other . sender [EOL] and self . chain_id == other . chain_id ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] @ property def balance_hash ( self ) : [EOL] return hash_balance_data ( transferred_amount = self . transferred_amount , locked_amount = self . locked_amount , locksroot = self . locksroot , ) [EOL] [EOL] @ property def chain_id ( self ) : [EOL] return self . canonical_identifier . chain_identifier [EOL] [EOL] @ property def token_network_identifier ( self ) : [EOL] return TokenNetworkAddress ( self . canonical_identifier . token_network_address ) [EOL] [EOL] @ property def channel_identifier ( self ) : [EOL] return self . canonical_identifier . channel_identifier [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . nonce , [string] : str ( self . transferred_amount ) , [string] : str ( self . locked_amount ) , [string] : serialization . serialize_bytes ( self . locksroot ) , [string] : serialization . serialize_bytes ( self . message_hash ) , [string] : serialization . serialize_bytes ( self . signature ) , [string] : to_checksum_address ( self . sender ) , [string] : self . canonical_identifier . to_dict ( ) , [string] : serialize_bytes ( self . balance_hash ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( nonce = Nonce ( data [ [string] ] ) , transferred_amount = TokenAmount ( int ( data [ [string] ] ) ) , locked_amount = TokenAmount ( int ( data [ [string] ] ) ) , locksroot = Locksroot ( serialization . deserialize_bytes ( data [ [string] ] ) ) , message_hash = AdditionalHash ( serialization . deserialize_bytes ( data [ [string] ] ) ) , signature = Signature ( serialization . deserialize_bytes ( data [ [string] ] ) ) , sender = to_canonical_address ( data [ [string] ] ) , canonical_identifier = CanonicalIdentifier . from_dict ( data [ [string] ] ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class HashTimeLockState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , amount , expiration , secrethash ) : [EOL] if not isinstance ( amount , T_PaymentWithFeeAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( expiration , T_BlockNumber ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( secrethash , T_Keccak256 ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] packed = messages . Lock ( buffer_for ( messages . Lock ) ) [EOL] [comment] [EOL] packed . amount = amount [EOL] packed . expiration = expiration [EOL] packed . secrethash = secrethash [EOL] [comment] [EOL] encoded = bytes ( packed . data ) [EOL] [EOL] self . amount = amount [EOL] self . expiration = expiration [EOL] self . secrethash = secrethash [EOL] self . encoded = encoded [EOL] self . lockhash = LockHash ( sha3 ( encoded ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . amount , self . expiration , pex ( self . secrethash ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , HashTimeLockState ) [EOL] and self . amount == other . amount [EOL] and self . expiration == other . expiration [EOL] and self . secrethash == other . secrethash ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . lockhash [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . amount , [string] : self . expiration , [string] : serialization . serialize_bytes ( self . secrethash ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( amount = data [ [string] ] , expiration = data [ [string] ] , secrethash = SecretHash ( serialization . deserialize_bytes ( data [ [string] ] ) ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class UnlockPartialProofState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , lock , secret ) : [EOL] if not isinstance ( lock , HashTimeLockState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( secret , T_Secret ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . lock = lock [EOL] self . secret = secret [EOL] self . amount = lock . amount [EOL] self . expiration = lock . expiration [EOL] self . secrethash = lock . secrethash [EOL] self . encoded = lock . encoded [EOL] self . lockhash = lock . lockhash [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . lock ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , UnlockPartialProofState ) [EOL] and self . lock == other . lock [EOL] and self . secret == other . secret ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . lock , [string] : serialization . serialize_bytes ( self . secret ) } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( lock = data [ [string] ] , secret = Secret ( serialization . deserialize_bytes ( data [ [string] ] ) ) ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class UnlockProofState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , merkle_proof , lock_encoded , secret ) : [EOL] [EOL] if not isinstance ( secret , T_Secret ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . merkle_proof = merkle_proof [EOL] self . lock_encoded = lock_encoded [EOL] self . secret = secret [EOL] [EOL] def __repr__ ( self ) : [EOL] full_proof = [ encode_hex ( entry ) for entry in self . merkle_proof ] [EOL] return f" [string] { full_proof } [string] { encode_hex ( self . lock_encoded ) } [string] " [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , UnlockProofState ) [EOL] and self . merkle_proof == other . merkle_proof [EOL] and self . lock_encoded == other . lock_encoded [EOL] and self . secret == other . secret ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : map_list ( serialization . serialize_bytes , self . merkle_proof ) , [string] : serialization . serialize_bytes ( self . lock_encoded ) , [string] : serialization . serialize_bytes ( self . secret ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( merkle_proof = map_list ( serialization . deserialize_keccak , data [ [string] ] ) , lock_encoded = serialization . deserialize_bytes ( data [ [string] ] ) , secret = Secret ( serialization . deserialize_bytes ( data [ [string] ] ) ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class TransactionExecutionStatus ( State ) : [EOL] [docstring] [EOL] [EOL] SUCCESS = [string] [EOL] FAILURE = [string] [EOL] VALID_RESULT_VALUES = ( SUCCESS , FAILURE ) [EOL] [EOL] def __init__ ( self , started_block_number = None , finished_block_number = None , result = None , ) : [EOL] [EOL] is_valid_start = started_block_number is None or isinstance ( started_block_number , T_BlockNumber ) [EOL] is_valid_finish = finished_block_number is None or isinstance ( finished_block_number , T_BlockNumber ) [EOL] is_valid_result = result is None or result in self . VALID_RESULT_VALUES [EOL] [EOL] if not is_valid_start : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not is_valid_finish : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not is_valid_result : [EOL] raise ValueError ( f" [string] { self . SUCCESS } [string] { self . FAILURE } [string] " ) [EOL] [EOL] self . started_block_number = started_block_number [EOL] self . finished_block_number = finished_block_number [EOL] self . result = result [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . started_block_number , self . finished_block_number , self . result ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , TransactionExecutionStatus ) [EOL] and self . started_block_number == other . started_block_number [EOL] and self . finished_block_number == other . finished_block_number [EOL] and self . result == other . result ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] result = { } [EOL] if self . started_block_number is not None : [EOL] result [ [string] ] = str ( self . started_block_number ) [EOL] if self . finished_block_number is not None : [EOL] result [ [string] ] = str ( self . finished_block_number ) [EOL] if self . result is not None : [EOL] result [ [string] ] = self . result [EOL] [EOL] return result [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] started_optional = data . get ( [string] ) [EOL] started_block_number = BlockNumber ( int ( started_optional ) ) if started_optional else None [EOL] finished_optional = data . get ( [string] ) [EOL] finished_block_number = BlockNumber ( int ( finished_optional ) ) if finished_optional else None [EOL] [EOL] restored = cls ( started_block_number = started_block_number , finished_block_number = finished_block_number , result = data . get ( [string] ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class MerkleTreeState ( State ) : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , layers ) : [EOL] self . layers = layers [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( merkleroot ( self ) ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , MerkleTreeState ) and self . layers == other . layers [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : serialization . serialize_merkletree_layers ( self . layers ) } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( layers = serialization . deserialize_merkletree_layers ( data [ [string] ] ) ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] class NettingChannelEndState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , address , balance ) : [EOL] if not isinstance ( address , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( balance , T_TokenAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . address = address [EOL] self . contract_balance = balance [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . secrethashes_to_lockedlocks = dict ( ) [EOL] [comment] [EOL] [comment] [EOL] self . secrethashes_to_unlockedlocks = dict ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . secrethashes_to_onchain_unlockedlocks = dict ( ) [EOL] self . merkletree = make_empty_merkle_tree ( ) [EOL] self . balance_proof = None [EOL] self . onchain_locksroot = EMPTY_MERKLE_ROOT [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . address ) , self . contract_balance , self . merkletree ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , NettingChannelEndState ) [EOL] and self . address == other . address [EOL] and self . contract_balance == other . contract_balance [EOL] and self . secrethashes_to_lockedlocks == other . secrethashes_to_lockedlocks [EOL] and self . secrethashes_to_unlockedlocks == other . secrethashes_to_unlockedlocks [EOL] and ( self . secrethashes_to_onchain_unlockedlocks == other . secrethashes_to_onchain_unlockedlocks ) [EOL] and self . merkletree == other . merkletree [EOL] and self . balance_proof == other . balance_proof [EOL] and self . onchain_locksroot == other . onchain_locksroot ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] result = { [string] : to_checksum_address ( self . address ) , [string] : str ( self . contract_balance ) , [string] : map_dict ( serialization . serialize_bytes , serialization . identity , self . secrethashes_to_lockedlocks , ) , [string] : map_dict ( serialization . serialize_bytes , serialization . identity , self . secrethashes_to_unlockedlocks , ) , [string] : map_dict ( serialization . serialize_bytes , serialization . identity , self . secrethashes_to_onchain_unlockedlocks , ) , [string] : self . merkletree , [string] : serialization . serialize_bytes ( self . onchain_locksroot ) , } [EOL] if self . balance_proof is not None : [EOL] result [ [string] ] = self . balance_proof [EOL] [EOL] return result [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] onchain_locksroot = EMPTY_MERKLE_ROOT [EOL] if data [ [string] ] : [EOL] onchain_locksroot = Locksroot ( serialization . deserialize_bytes ( data [ [string] ] ) ) [EOL] [EOL] restored = cls ( address = to_canonical_address ( data [ [string] ] ) , balance = Balance ( int ( data [ [string] ] ) ) , ) [EOL] restored . secrethashes_to_lockedlocks = map_dict ( serialization . deserialize_secret_hash , serialization . identity , data [ [string] ] , ) [EOL] restored . secrethashes_to_unlockedlocks = map_dict ( serialization . deserialize_secret_hash , serialization . identity , data [ [string] ] , ) [EOL] restored . secrethashes_to_onchain_unlockedlocks = map_dict ( serialization . deserialize_secret_hash , serialization . identity , data [ [string] ] , ) [EOL] restored . merkletree = data [ [string] ] [EOL] restored . balance_proof = data . get ( [string] ) [EOL] restored . onchain_locksroot = onchain_locksroot [EOL] [EOL] return restored [EOL] [EOL] [EOL] class NettingChannelState ( State ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , canonical_identifier , token_address , payment_network_identifier , reveal_timeout , settle_timeout , mediation_fee , our_state , partner_state , open_transaction , close_transaction = None , settle_transaction = None , update_transaction = None , ) : [EOL] if reveal_timeout >= settle_timeout : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( reveal_timeout , int ) or reveal_timeout <= [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( settle_timeout , int ) or settle_timeout <= [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( open_transaction , TransactionExecutionStatus ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if open_transaction . result != TransactionExecutionStatus . SUCCESS : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( canonical_identifier . channel_identifier , T_ChannelID ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if ( canonical_identifier . channel_identifier < [number] or canonical_identifier . channel_identifier > UINT256_MAX ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] valid_close_transaction = close_transaction is None or isinstance ( close_transaction , TransactionExecutionStatus ) [EOL] if not valid_close_transaction : [EOL] raise ValueError ( [string] ) [EOL] [EOL] valid_settle_transaction = settle_transaction is None or isinstance ( settle_transaction , TransactionExecutionStatus ) [EOL] if not valid_settle_transaction : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . canonical_identifier = canonical_identifier [EOL] self . token_address = token_address [EOL] self . payment_network_identifier = payment_network_identifier [EOL] self . reveal_timeout = reveal_timeout [EOL] self . settle_timeout = settle_timeout [EOL] self . our_state = our_state [EOL] self . partner_state = partner_state [EOL] self . deposit_transaction_queue = list ( ) [EOL] self . open_transaction = open_transaction [EOL] self . close_transaction = close_transaction [EOL] self . settle_transaction = settle_transaction [EOL] self . update_transaction = update_transaction [EOL] self . mediation_fee = mediation_fee [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . canonical_identifier . channel_identifier , self . open_transaction , self . close_transaction , self . settle_transaction , self . update_transaction , ) [EOL] [EOL] @ property def identifier ( self ) : [EOL] return self . canonical_identifier . channel_identifier [EOL] [EOL] @ property def token_network_identifier ( self ) : [EOL] return TokenNetworkID ( self . canonical_identifier . token_network_address ) [EOL] [EOL] @ property def chain_id ( self ) : [EOL] return self . canonical_identifier . chain_identifier [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , NettingChannelState ) [EOL] and self . canonical_identifier == other . canonical_identifier [EOL] and self . payment_network_identifier == other . payment_network_identifier [EOL] and self . our_state == other . our_state [EOL] and self . partner_state == other . partner_state [EOL] and self . token_address == other . token_address [EOL] and self . reveal_timeout == other . reveal_timeout [EOL] and self . settle_timeout == other . settle_timeout [EOL] and self . mediation_fee == other . mediation_fee [EOL] and self . deposit_transaction_queue == other . deposit_transaction_queue [EOL] and self . open_transaction == other . open_transaction [EOL] and self . close_transaction == other . close_transaction [EOL] and self . settle_transaction == other . settle_transaction [EOL] and self . update_transaction == other . update_transaction ) [EOL] [EOL] @ property def our_total_deposit ( self ) : [EOL] return self . our_state . contract_balance [EOL] [EOL] @ property def partner_total_deposit ( self ) : [EOL] return self . partner_state . contract_balance [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] [comment] [EOL] def to_dict ( self ) : [EOL] result = { [string] : self . canonical_identifier . to_dict ( ) , [string] : to_checksum_address ( self . token_address ) , [string] : to_checksum_address ( self . payment_network_identifier ) , [string] : str ( self . reveal_timeout ) , [string] : str ( self . settle_timeout ) , [string] : str ( self . mediation_fee ) , [string] : self . our_state , [string] : self . partner_state , [string] : self . open_transaction , [string] : self . deposit_transaction_queue , } [EOL] [EOL] if self . close_transaction is not None : [EOL] result [ [string] ] = self . close_transaction [EOL] if self . settle_transaction is not None : [EOL] result [ [string] ] = self . settle_transaction [EOL] if self . update_transaction is not None : [EOL] result [ [string] ] = self . update_transaction [EOL] [EOL] return result [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( canonical_identifier = CanonicalIdentifier . from_dict ( data [ [string] ] ) , token_address = to_canonical_address ( data [ [string] ] ) , payment_network_identifier = to_canonical_address ( data [ [string] ] ) , reveal_timeout = BlockTimeout ( int ( data [ [string] ] ) ) , settle_timeout = BlockTimeout ( int ( data [ [string] ] ) ) , mediation_fee = FeeAmount ( int ( data [ [string] ] ) ) , our_state = data [ [string] ] , partner_state = data [ [string] ] , open_transaction = data [ [string] ] , ) [EOL] close_transaction = data . get ( [string] ) [EOL] if close_transaction is not None : [EOL] restored . close_transaction = close_transaction [EOL] settle_transaction = data . get ( [string] ) [EOL] if settle_transaction is not None : [EOL] restored . settle_transaction = settle_transaction [EOL] update_transaction = data . get ( [string] ) [EOL] if update_transaction is not None : [EOL] restored . update_transaction = update_transaction [EOL] [EOL] restored . deposit_transaction_queue = data [ [string] ] [EOL] [EOL] return restored [EOL] [EOL] [EOL] @ total_ordering class TransactionChannelNewBalance ( State ) : [EOL] [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , participant_address , contract_balance , deposit_block_number , ) : [EOL] if not isinstance ( participant_address , T_Address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( contract_balance , T_TokenAmount ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( deposit_block_number , T_BlockNumber ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . participant_address = participant_address [EOL] self . contract_balance = contract_balance [EOL] self . deposit_block_number = deposit_block_number [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . participant_address ) , self . contract_balance , self . deposit_block_number ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , TransactionChannelNewBalance ) : [EOL] return NotImplemented [EOL] return ( self . participant_address == other . participant_address [EOL] and self . contract_balance == other . contract_balance [EOL] and self . deposit_block_number == other . deposit_block_number ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if not isinstance ( other , TransactionChannelNewBalance ) : [EOL] return NotImplemented [EOL] return ( self . participant_address , self . contract_balance , self . deposit_block_number ) < ( other . participant_address , other . contract_balance , other . deposit_block_number , ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : to_checksum_address ( self . participant_address ) , [string] : str ( self . contract_balance ) , [string] : str ( self . deposit_block_number ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( participant_address = to_canonical_address ( data [ [string] ] ) , contract_balance = TokenAmount ( int ( data [ [string] ] ) ) , deposit_block_number = BlockNumber ( int ( data [ [string] ] ) ) , ) [EOL] [EOL] return restored [EOL] [EOL] [EOL] @ total_ordering class TransactionOrder ( State ) : [EOL] def __init__ ( self , block_number , transaction ) : [EOL] self . block_number = block_number [EOL] self . transaction = transaction [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . block_number , self . transaction ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , TransactionOrder ) [EOL] and self . block_number == other . block_number [EOL] and self . transaction == other . transaction ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if not isinstance ( other , TransactionOrder ) : [EOL] return NotImplemented [EOL] return ( self . block_number , self . transaction ) < ( other . block_number , other . transaction ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : str ( self . block_number ) , [string] : self . transaction } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] restored = cls ( block_number = BlockNumber ( int ( data [ [string] ] ) ) , transaction = data [ [string] ] ) [EOL] [EOL] return restored [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $"BalanceProofSignedState"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"MerkleTreeState"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.MessageID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List[raiden.utils.typing.List[raiden.utils.typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"InitiatorTask"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"MediatorTask"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.transfer.state.MediatorTask$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.transfer.state.MediatorTask$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $raiden.transfer.identifiers.CanonicalIdentifier$ 0 0 0 0 0 0 0 $raiden.transfer.identifiers.CanonicalIdentifier$ 0 $raiden.transfer.identifiers.CanonicalIdentifier$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChannelID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TargetTask"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.transfer.state.TargetTask$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.transfer.state.TargetTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $random.Random$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.PaymentNetworkID,PaymentNetworkState]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.transfer.state.PaymentMappingState$ 0 0 0 0 0 0 0 $raiden.utils.typing.List[raiden.transfer.architecture.ContractSendEvent]$ 0 0 0 0 0 0 0 $random.Random$ 0 $random.Random$ 0 0 0 $QueueIdsToQueues$ 0 0 0 0 0 0 0 $raiden.utils.typing.Optional[builtins.str]$ 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.TokenNetworkAddress,raiden.utils.typing.PaymentNetworkID]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ChainState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $raiden.utils.typing.List["TokenNetworkState"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.TokenNetworkID,TokenNetworkState]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List["TokenNetworkState"]$ 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.TokenAddress,raiden.utils.typing.TokenNetworkID]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List["TokenNetworkState"]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"PaymentNetworkState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChannelMap$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.utils.typing.List[raiden.utils.typing.ChannelID]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TokenNetworkState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $raiden.utils.typing.TokenNetworkID$ 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.ChannelID,typing.Tuple[raiden.utils.typing.Address,raiden.utils.typing.Address]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TokenNetworkGraphState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Secret.Hash,TransferTask]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"PaymentMappingState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"RouteState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChainID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChannelID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $raiden.utils.typing.BalanceHash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"BalanceProofUnsignedState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $raiden.utils.typing.BalanceHash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChainID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChannelID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"BalanceProofSignedState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.LockHash$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"HashTimeLockState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"UnlockPartialProofState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"UnlockProofState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 $"TransactionExecutionStatus"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"MerkleTreeState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $raiden.utils.typing.Balance$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Balance$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Balance$ 0 0 0 0 0 0 0 0 $SecretHashToLock$ 0 0 0 0 0 0 0 0 0 0 0 $SecretHashToPartialUnlockProof$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $SecretHashToPartialUnlockProof$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OptionalBalanceProofState$ 0 0 0 0 0 $raiden.utils.typing.Locksroot$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"NettingChannelEndState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List[TransactionOrder]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChannelID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.ChainID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Balance$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Balance$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"NettingChannelState"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TransactionChannelNewBalance"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TransactionOrder"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import raiden [EOL] from raiden . transfer . architecture import Event [EOL] from raiden . transfer . channel import get_status [EOL] from raiden . transfer . events import ContractSendSecretReveal [EOL] from raiden . transfer . state import ( CHANNEL_STATE_CLOSED , CHANNEL_STATES_PRIOR_TO_CLOSED , NettingChannelState , ) [EOL] from raiden . utils . typing import BlockExpiration , BlockHash , List , Secret , T_Secret [EOL] [EOL] [EOL] def events_for_onchain_secretreveal ( channel_state , secret , expiration , block_hash , ) : [EOL] events = list ( ) [EOL] [EOL] if not isinstance ( secret , T_Secret ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if get_status ( channel_state ) in CHANNEL_STATES_PRIOR_TO_CLOSED + ( CHANNEL_STATE_CLOSED , ) : [EOL] reveal_event = ContractSendSecretReveal ( expiration = expiration , secret = secret , triggered_by_block_hash = block_hash ) [EOL] events . append ( reveal_event ) [EOL] [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List[raiden.transfer.architecture.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import builtins [EOL] import raiden [EOL] from eth_utils import to_canonical_address , to_checksum_address [EOL] [EOL] from raiden . transfer . architecture import ( AuthenticatedSenderStateChange , BalanceProofStateChange , StateChange , ) [EOL] from raiden . transfer . mediated_transfer . state import ( LockedTransferSignedState , TransferDescriptionWithSecretState , ) [EOL] from raiden . transfer . state import BalanceProofSignedState , RouteState [EOL] from raiden . utils import pex , sha3 [EOL] from raiden . utils . serialization import deserialize_bytes , serialize_bytes [EOL] from raiden . utils . typing import ( Address , Any , BlockExpiration , Dict , List , MessageID , PaymentAmount , PaymentID , Secret , SecretHash , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class ActionInitInitiator ( StateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , transfer_description , routes ) : [EOL] if not isinstance ( transfer_description , TransferDescriptionWithSecretState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . transfer = transfer_description [EOL] self . routes = routes [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . transfer ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ActionInitInitiator ) [EOL] and self . transfer == other . transfer [EOL] and self . routes == other . routes ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . transfer , [string] : self . routes } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] return cls ( transfer_description = data [ [string] ] , routes = data [ [string] ] ) [EOL] [EOL] [EOL] class ActionInitMediator ( BalanceProofStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , routes , from_route , from_transfer , ) : [EOL] [EOL] if not isinstance ( from_route , RouteState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( from_transfer , LockedTransferSignedState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] super ( ) . __init__ ( from_transfer . balance_proof ) [EOL] self . routes = routes [EOL] self . from_route = from_route [EOL] self . from_transfer = from_transfer [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . from_route , self . from_transfer ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ActionInitMediator ) [EOL] and self . routes == other . routes [EOL] and self . from_route == other . from_route [EOL] and self . from_transfer == other . from_transfer ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . routes , [string] : self . from_route , [string] : self . from_transfer , [string] : self . balance_proof , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] return cls ( routes = data [ [string] ] , from_route = data [ [string] ] , from_transfer = data [ [string] ] , ) [EOL] [EOL] [EOL] class ActionInitTarget ( BalanceProofStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , route , transfer ) : [EOL] if not isinstance ( route , RouteState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not isinstance ( transfer , LockedTransferSignedState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] super ( ) . __init__ ( transfer . balance_proof ) [EOL] self . route = route [EOL] self . transfer = transfer [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . route , self . transfer ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ActionInitTarget ) [EOL] and self . route == other . route [EOL] and self . transfer == other . transfer ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . route , [string] : self . transfer , [string] : self . balance_proof , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] return cls ( route = data [ [string] ] , transfer = data [ [string] ] ) [EOL] [EOL] [EOL] class ReceiveLockExpired ( BalanceProofStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , balance_proof , secrethash , message_identifier , ) : [EOL] super ( ) . __init__ ( balance_proof ) [EOL] self . secrethash = secrethash [EOL] self . message_identifier = message_identifier [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . sender ) , self . balance_proof ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ReceiveLockExpired ) [EOL] and self . secrethash == other . secrethash [EOL] and self . message_identifier == other . message_identifier [EOL] and super ( ) . __eq__ ( other ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . balance_proof , [string] : serialize_bytes ( self . secrethash ) , [string] : str ( self . message_identifier ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] return cls ( balance_proof = data [ [string] ] , secrethash = SecretHash ( deserialize_bytes ( data [ [string] ] ) ) , message_identifier = MessageID ( int ( data [ [string] ] ) ) , ) [EOL] [EOL] [EOL] class ReceiveSecretRequest ( AuthenticatedSenderStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , payment_identifier , amount , expiration , secrethash , sender , ) : [EOL] super ( ) . __init__ ( sender ) [EOL] self . payment_identifier = payment_identifier [EOL] self . amount = amount [EOL] self . expiration = expiration [EOL] self . secrethash = secrethash [EOL] self . revealsecret = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . payment_identifier , self . amount , pex ( self . secrethash ) , pex ( self . sender ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ReceiveSecretRequest ) [EOL] and self . payment_identifier == other . payment_identifier [EOL] and self . amount == other . amount [EOL] and self . secrethash == other . secrethash [EOL] and self . sender == other . sender [EOL] and self . revealsecret == other . revealsecret [EOL] and super ( ) . __eq__ ( other ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : str ( self . payment_identifier ) , [string] : str ( self . amount ) , [string] : str ( self . expiration ) , [string] : serialize_bytes ( self . secrethash ) , [string] : to_checksum_address ( self . sender ) , [string] : self . revealsecret , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] instance = cls ( payment_identifier = PaymentID ( int ( data [ [string] ] ) ) , amount = PaymentAmount ( int ( data [ [string] ] ) ) , expiration = BlockExpiration ( int ( data [ [string] ] ) ) , secrethash = SecretHash ( deserialize_bytes ( data [ [string] ] ) ) , sender = to_canonical_address ( data [ [string] ] ) , ) [EOL] instance . revealsecret = data [ [string] ] [EOL] return instance [EOL] [EOL] [EOL] class ReceiveSecretReveal ( AuthenticatedSenderStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , secret , sender ) : [EOL] super ( ) . __init__ ( sender ) [EOL] secrethash = sha3 ( secret ) [EOL] [EOL] self . secret = secret [EOL] self . secrethash = secrethash [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . secrethash ) , pex ( self . sender ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ReceiveSecretReveal ) [EOL] and self . secret == other . secret [EOL] and self . secrethash == other . secrethash [EOL] and super ( ) . __eq__ ( other ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : serialize_bytes ( self . secret ) , [string] : serialize_bytes ( self . secrethash ) , [string] : to_checksum_address ( self . sender ) , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] instance = cls ( secret = Secret ( deserialize_bytes ( data [ [string] ] ) ) , sender = to_canonical_address ( data [ [string] ] ) , ) [EOL] instance . secrethash = deserialize_bytes ( data [ [string] ] ) [EOL] return instance [EOL] [EOL] [EOL] class ReceiveTransferRefundCancelRoute ( BalanceProofStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , routes , transfer , secret ) : [EOL] if not isinstance ( transfer , LockedTransferSignedState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] secrethash = sha3 ( secret ) [EOL] [EOL] super ( ) . __init__ ( transfer . balance_proof ) [EOL] self . transfer = transfer [EOL] self . routes = routes [EOL] self . secrethash = secrethash [EOL] self . secret = secret [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . sender ) , self . transfer ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ReceiveTransferRefundCancelRoute ) [EOL] and self . sender == other . sender [EOL] and self . transfer == other . transfer [EOL] and self . routes == other . routes [EOL] and self . secret == other . secret [EOL] and self . secrethash == other . secrethash [EOL] and super ( ) . __eq__ ( other ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : serialize_bytes ( self . secret ) , [string] : self . routes , [string] : self . transfer , [string] : self . balance_proof , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] instance = cls ( routes = data [ [string] ] , transfer = data [ [string] ] , secret = Secret ( deserialize_bytes ( data [ [string] ] ) ) , ) [EOL] return instance [EOL] [EOL] [EOL] class ReceiveTransferRefund ( BalanceProofStateChange ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , transfer , routes ) : [EOL] if not isinstance ( transfer , LockedTransferSignedState ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] super ( ) . __init__ ( transfer . balance_proof ) [EOL] self . transfer = transfer [EOL] self . routes = routes [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( pex ( self . sender ) , self . transfer ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , ReceiveTransferRefund ) [EOL] and self . transfer == other . transfer [EOL] and self . routes == other . routes [EOL] and super ( ) . __eq__ ( other ) ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . routes , [string] : self . transfer , [string] : self . balance_proof , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] instance = cls ( routes = data [ [string] ] , transfer = data [ [string] ] ) [EOL] return instance [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $raiden.transfer.mediated_transfer.state.TransferDescriptionWithSecretState$ 0 0 0 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state.TransferDescriptionWithSecretState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state.TransferDescriptionWithSecretState$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ActionInitInitiator"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $raiden.transfer.state.RouteState$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.transfer.state.RouteState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.transfer.state.RouteState$ 0 $raiden.transfer.state.RouteState$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ActionInitMediator"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $raiden.transfer.state.RouteState$ 0 0 0 0 0 0 0 0 0 $raiden.transfer.state.RouteState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.transfer.state.RouteState$ 0 $raiden.transfer.state.RouteState$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ActionInitTarget"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $raiden.transfer.state.BalanceProofSignedState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.transfer.state.BalanceProofSignedState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ReceiveLockExpired"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ReceiveSecretRequest"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveSecretRequest$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveSecretRequest$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveSecretRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ReceiveSecretReveal"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveSecretReveal$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveSecretReveal$ 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveSecretReveal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ReceiveTransferRefundCancelRoute"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveTransferRefundCancelRoute$ 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveTransferRefundCancelRoute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Any$ 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ReceiveTransferRefund"$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveTransferRefund$ 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.utils.typing.Dict[builtins.str,raiden.utils.typing.Any]$ 0 0 0 0 0 0 $raiden.transfer.mediated_transfer.state_change.ReceiveTransferRefund$ 0
from typing import Tuple , Dict [EOL] import raiden_contracts [EOL] import builtins [EOL] import raiden [EOL] import gevent [EOL] from eth_utils import is_binary_address [EOL] from gevent . lock import Semaphore [EOL] [EOL] from raiden . network . proxies . discovery import Discovery [EOL] from raiden . network . proxies . payment_channel import PaymentChannel [EOL] from raiden . network . proxies . secret_registry import SecretRegistry [EOL] from raiden . network . proxies . service_registry import ServiceRegistry [EOL] from raiden . network . proxies . token import Token [EOL] from raiden . network . proxies . token_network import TokenNetwork [EOL] from raiden . network . proxies . token_network_registry import TokenNetworkRegistry [EOL] from raiden . network . proxies . user_deposit import UserDeposit [EOL] from raiden . network . rpc . client import JSONRPCClient [EOL] from raiden . transfer . identifiers import CanonicalIdentifier [EOL] from raiden . utils . typing import ( Address , BlockHash , BlockNumber , ChainID , ChannelID , Dict , PaymentNetworkID , T_ChannelID , TokenNetworkAddress , Tuple , ) [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] [EOL] class BlockChainService : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , jsonrpc_client , contract_manager ) : [EOL] self . address_to_discovery = dict ( ) [EOL] self . address_to_secret_registry = dict ( ) [EOL] self . address_to_token = dict ( ) [EOL] self . address_to_token_network = dict ( ) [EOL] self . address_to_token_network_registry = dict ( ) [EOL] self . address_to_user_deposit = dict ( ) [EOL] self . address_to_service_registry = dict ( ) [EOL] self . identifier_to_payment_channel = dict ( ) [EOL] [EOL] self . client = jsonrpc_client [EOL] self . contract_manager = contract_manager [EOL] [EOL] [comment] [EOL] self . network_id = ChainID ( int ( self . client . web3 . version . network ) ) [EOL] [EOL] self . _token_creation_lock = Semaphore ( ) [EOL] self . _discovery_creation_lock = Semaphore ( ) [EOL] self . _token_network_creation_lock = Semaphore ( ) [EOL] self . _token_network_registry_creation_lock = Semaphore ( ) [EOL] self . _secret_registry_creation_lock = Semaphore ( ) [EOL] self . _service_registry_creation_lock = Semaphore ( ) [EOL] self . _payment_channel_creation_lock = Semaphore ( ) [EOL] self . _user_deposit_creation_lock = Semaphore ( ) [EOL] [EOL] @ property def node_address ( self ) : [EOL] return self . client . address [EOL] [EOL] def block_number ( self ) : [EOL] return self . client . block_number ( ) [EOL] [EOL] def block_hash ( self ) : [EOL] return self . client . blockhash_from_blocknumber ( [string] ) [EOL] [EOL] def get_block ( self , block_identifier ) : [EOL] return self . client . web3 . eth . getBlock ( block_identifier = block_identifier ) [EOL] [EOL] def is_synced ( self ) : [EOL] result = self . client . web3 . eth . syncing [EOL] [EOL] [comment] [EOL] if result is False : [EOL] return True [EOL] [EOL] current_block = self . block_number ( ) [EOL] highest_block = result [ [string] ] [EOL] [EOL] if highest_block - current_block > [number] : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def estimate_blocktime ( self , oldest = [number] ) : [EOL] [docstring] [EOL] last_block_number = self . block_number ( ) [EOL] [comment] [EOL] if last_block_number < [number] : [EOL] return [number] [EOL] [comment] [EOL] if last_block_number < oldest : [EOL] interval = ( last_block_number - [number] ) or [number] [EOL] else : [EOL] interval = last_block_number - oldest [EOL] assert interval > [number] [EOL] last_timestamp = self . get_block_header ( last_block_number ) [ [string] ] [EOL] first_timestamp = self . get_block_header ( last_block_number - interval ) [ [string] ] [EOL] delta = last_timestamp - first_timestamp [EOL] return delta / interval [EOL] [EOL] def get_block_header ( self , block_number ) : [EOL] return self . client . web3 . eth . getBlock ( block_number , False ) [EOL] [EOL] def next_block ( self ) : [EOL] target_block_number = self . block_number ( ) + [number] [EOL] self . wait_until_block ( target_block_number = target_block_number ) [EOL] return target_block_number [EOL] [EOL] def wait_until_block ( self , target_block_number ) : [EOL] current_block = self . block_number ( ) [EOL] [EOL] while current_block < target_block_number : [EOL] current_block = self . block_number ( ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] return current_block [EOL] [EOL] def token ( self , token_address ) : [EOL] [docstring] [EOL] if not is_binary_address ( token_address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _token_creation_lock : [EOL] if token_address not in self . address_to_token : [EOL] self . address_to_token [ token_address ] = Token ( jsonrpc_client = self . client , token_address = token_address , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_token [ token_address ] [EOL] [EOL] def discovery ( self , discovery_address ) : [EOL] [docstring] [EOL] if not is_binary_address ( discovery_address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _discovery_creation_lock : [EOL] if discovery_address not in self . address_to_discovery : [EOL] self . address_to_discovery [ discovery_address ] = Discovery ( jsonrpc_client = self . client , discovery_address = discovery_address , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_discovery [ discovery_address ] [EOL] [EOL] def token_network_registry ( self , address ) : [EOL] if not is_binary_address ( address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _token_network_registry_creation_lock : [EOL] if address not in self . address_to_token_network_registry : [EOL] self . address_to_token_network_registry [ address ] = TokenNetworkRegistry ( jsonrpc_client = self . client , registry_address = PaymentNetworkID ( address ) , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_token_network_registry [ address ] [EOL] [EOL] def token_network ( self , address ) : [EOL] if not is_binary_address ( address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _token_network_creation_lock : [EOL] if address not in self . address_to_token_network : [EOL] self . address_to_token_network [ address ] = TokenNetwork ( jsonrpc_client = self . client , token_network_address = address , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_token_network [ address ] [EOL] [EOL] def secret_registry ( self , address ) : [EOL] if not is_binary_address ( address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _secret_registry_creation_lock : [EOL] if address not in self . address_to_secret_registry : [EOL] self . address_to_secret_registry [ address ] = SecretRegistry ( jsonrpc_client = self . client , secret_registry_address = address , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_secret_registry [ address ] [EOL] [EOL] def service_registry ( self , address ) : [EOL] with self . _service_registry_creation_lock : [EOL] if address not in self . address_to_service_registry : [EOL] self . address_to_service_registry [ address ] = ServiceRegistry ( jsonrpc_client = self . client , service_registry_address = address , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_service_registry [ address ] [EOL] [EOL] def payment_channel ( self , canonical_identifier ) : [EOL] [EOL] token_network_address = TokenNetworkAddress ( canonical_identifier . token_network_address ) [EOL] channel_id = canonical_identifier . channel_identifier [EOL] [EOL] if not is_binary_address ( token_network_address ) : [EOL] raise ValueError ( [string] ) [EOL] if not isinstance ( channel_id , T_ChannelID ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _payment_channel_creation_lock : [EOL] dict_key = ( token_network_address , channel_id ) [EOL] [EOL] if dict_key not in self . identifier_to_payment_channel : [EOL] token_network = self . token_network ( token_network_address ) [EOL] [EOL] self . identifier_to_payment_channel [ dict_key ] = PaymentChannel ( token_network = token_network , channel_identifier = channel_id , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . identifier_to_payment_channel [ dict_key ] [EOL] [EOL] def user_deposit ( self , address ) : [EOL] if not is_binary_address ( address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] with self . _user_deposit_creation_lock : [EOL] if address not in self . address_to_user_deposit : [EOL] self . address_to_user_deposit [ address ] = UserDeposit ( jsonrpc_client = self . client , user_deposit_address = address , contract_manager = self . contract_manager , ) [EOL] [EOL] return self . address_to_user_deposit [ address ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.network.rpc.client.JSONRPCClient$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.network.proxies.discovery.Discovery]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.network.proxies.secret_registry.SecretRegistry]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.network.proxies.token.Token]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.TokenNetworkAddress,raiden.network.proxies.token_network.TokenNetwork]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.network.proxies.token_network_registry.TokenNetworkRegistry]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.network.proxies.user_deposit.UserDeposit]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Address,raiden.network.proxies.service_registry.ServiceRegistry]$ 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.Tuple[raiden.utils.typing.TokenNetworkAddress,raiden.utils.typing.ChannelID],raiden.network.proxies.payment_channel.PaymentChannel]$ 0 0 0 0 0 0 0 0 0 0 $raiden.network.rpc.client.JSONRPCClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockHash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.network.proxies.token.Token$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 $raiden.network.proxies.discovery.Discovery$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 $raiden.network.proxies.token_network_registry.TokenNetworkRegistry$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 $raiden.network.proxies.token_network.TokenNetwork$ 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenNetworkAddress$ 0 0 0 0 $raiden.network.proxies.secret_registry.SecretRegistry$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 $raiden.network.proxies.service_registry.ServiceRegistry$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 $raiden.network.proxies.payment_channel.PaymentChannel$ 0 0 0 $raiden.transfer.identifiers.CanonicalIdentifier$ 0 0 0 0 0 0 0 0 $raiden.transfer.identifiers.CanonicalIdentifier$ 0 0 0 0 0 0 $raiden.transfer.identifiers.CanonicalIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.network.proxies.user_deposit.UserDeposit$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Address$ 0 0
	0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import socket [EOL] [EOL] import structlog [EOL] from eth_utils import is_binary_address [EOL] [EOL] from raiden . exceptions import InvalidAddress , UnknownAddress [EOL] from raiden . network . proxies . discovery import Discovery as DiscoveryProxy [EOL] from raiden . utils import host_port_to_endpoint , pex , split_endpoint [EOL] from raiden . utils . typing import HostPort [EOL] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class Discovery : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . nodeid_to_hostport = dict ( ) [EOL] [EOL] def register ( self , node_address , host , port ) : [EOL] if not is_binary_address ( node_address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] try : [EOL] socket . inet_pton ( socket . AF_INET , host ) [EOL] except OSError : [EOL] raise ValueError ( [string] . format ( host ) ) [EOL] [EOL] if not isinstance ( port , int ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . nodeid_to_hostport [ node_address ] = ( host , port ) [EOL] [EOL] def get ( self , node_address ) : [EOL] try : [EOL] return self . nodeid_to_hostport [ node_address ] [EOL] except KeyError : [EOL] raise InvalidAddress ( [string] . format ( pex ( node_address ) ) ) [EOL] [EOL] [EOL] class ContractDiscovery ( Discovery ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_address , discovery_proxy ) : [EOL] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . node_address = node_address [EOL] self . discovery_proxy = discovery_proxy [EOL] [EOL] def register ( self , node_address , host , port ) : [EOL] if node_address != self . node_address : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not is_binary_address ( node_address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] try : [EOL] socket . inet_pton ( socket . AF_INET , host ) [EOL] except OSError : [EOL] raise ValueError ( [string] . format ( host ) ) [EOL] [EOL] if not isinstance ( port , int ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] try : [EOL] current_value = self . get ( node_address ) [EOL] if current_value == ( host , port ) : [EOL] log . info ( [string] , node_address = pex ( node_address ) , host = host , port = port , ) [EOL] return [EOL] except UnknownAddress : [EOL] pass [EOL] [EOL] endpoint = host_port_to_endpoint ( host , port ) [EOL] self . discovery_proxy . register_endpoint ( node_address , endpoint ) [EOL] log . info ( [string] , node_address = pex ( node_address ) , host = host , port = port , ) [EOL] [EOL] def get ( self , node_address ) : [EOL] endpoint = self . discovery_proxy . endpoint_by_address ( node_address ) [EOL] host_port = split_endpoint ( endpoint ) [EOL] return host_port [EOL] [EOL] def version ( self ) : [EOL] return self . discovery_proxy . version ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $raiden.utils.typing.HostPort$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from raiden . constants import RECEIPT_FAILURE_CODE [EOL] [EOL] [EOL] def check_transaction_threw ( client , transaction_hash ) : [EOL] [docstring] [EOL] receipt = client . get_transaction_receipt ( transaction_hash ) [EOL] [EOL] if [string] not in receipt : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if receipt [ [string] ] == RECEIPT_FAILURE_CODE : [EOL] return receipt [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] from typing import TYPE_CHECKING [EOL] [EOL] from eth_utils import to_normalized_address [EOL] from web3 . exceptions import BadFunctionCallOutput [EOL] [EOL] from raiden . exceptions import AddressWrongContract , ContractVersionMismatch [EOL] from raiden . network . rpc . smartcontract_proxy import ContractProxy [EOL] from raiden . transfer . identifiers import CanonicalIdentifier [EOL] from raiden . utils . typing import Address , BlockSpecification , Locksroot , Tuple [EOL] [EOL] if TYPE_CHECKING : [EOL] [comment] [EOL] from raiden . network . blockchain_service import BlockChainService [EOL] [EOL] [EOL] def compare_contract_versions ( proxy , expected_version , contract_name , address ) : [EOL] [docstring] [EOL] assert isinstance ( expected_version , str ) [EOL] try : [EOL] deployed_version = proxy . contract . functions . contract_version ( ) . call ( ) [EOL] except BadFunctionCallOutput : [EOL] raise AddressWrongContract ( [string] ) [EOL] [EOL] deployed_version = deployed_version . replace ( [string] , [string] ) [EOL] expected_version = expected_version . replace ( [string] , [string] ) [EOL] [EOL] deployed = [ int ( x ) for x in deployed_version . split ( [string] ) ] [EOL] expected = [ int ( x ) for x in expected_version . split ( [string] ) ] [EOL] [EOL] if deployed != expected : [EOL] raise ContractVersionMismatch ( f" [string] { contract_name } [string] { to_normalized_address ( address ) } [string] " f" [string] { expected_version } [string] { deployed_version }" ) [EOL] [EOL] [EOL] def get_onchain_locksroots ( chain , canonical_identifier , participant1 , participant2 , block_identifier , ) : [EOL] [docstring] [EOL] payment_channel = chain . payment_channel ( canonical_identifier = canonical_identifier ) [EOL] token_network = payment_channel . token_network [EOL] [EOL] participants_details = token_network . detail_participants ( participant1 = participant1 , participant2 = participant2 , channel_identifier = canonical_identifier . channel_identifier , block_identifier = block_identifier , ) [EOL] [EOL] our_details = participants_details . our_details [EOL] our_locksroot = our_details . locksroot [EOL] [EOL] partner_details = participants_details . partner_details [EOL] partner_locksroot = partner_details . locksroot [EOL] [EOL] return our_locksroot , partner_locksroot [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Tuple[raiden.utils.typing.Locksroot,raiden.utils.typing.Locksroot]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import raiden_contracts [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import structlog [EOL] from eth_utils import is_binary_address , to_checksum_address , to_normalized_address [EOL] [EOL] from raiden . constants import GAS_LIMIT_FOR_TOKEN_CONTRACT_CALL [EOL] from raiden . exceptions import RaidenUnrecoverableError , TransactionThrew [EOL] from raiden . network . rpc . client import check_address_has_code [EOL] from raiden . network . rpc . smartcontract_proxy import ContractProxy [EOL] from raiden . network . rpc . transactions import check_transaction_threw [EOL] from raiden . utils import pex , safe_gas_limit [EOL] from raiden . utils . typing import Address , BlockSpecification , TokenAmount [EOL] from raiden_contracts . constants import CONTRACT_HUMAN_STANDARD_TOKEN [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] log = structlog . get_logger ( __name__ ) [comment] [EOL] [EOL] [comment] [EOL] GAS_REQUIRED_FOR_APPROVE = [number] [EOL] [EOL] [EOL] class Token : [EOL] def __init__ ( self , jsonrpc_client , token_address , contract_manager ) : [EOL] contract = jsonrpc_client . new_contract ( contract_manager . get_contract_abi ( CONTRACT_HUMAN_STANDARD_TOKEN ) , to_normalized_address ( token_address ) , ) [EOL] proxy = ContractProxy ( jsonrpc_client , contract ) [EOL] [EOL] if not is_binary_address ( token_address ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] check_address_has_code ( jsonrpc_client , token_address , [string] ) [EOL] [EOL] self . address = token_address [EOL] self . client = jsonrpc_client [EOL] self . node_address = jsonrpc_client . address [EOL] self . proxy = proxy [EOL] [EOL] def allowance ( self , owner , spender , block_identifier ) : [EOL] return self . proxy . contract . functions . allowance ( to_checksum_address ( owner ) , to_checksum_address ( spender ) ) . call ( block_identifier = block_identifier ) [EOL] [EOL] def approve ( self , allowed_address , allowance ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] log_details = { [string] : pex ( self . node_address ) , [string] : pex ( self . address ) , [string] : pex ( allowed_address ) , [string] : allowance , } [EOL] [EOL] checking_block = self . client . get_checking_block ( ) [EOL] error_prefix = [string] [EOL] gas_limit = self . proxy . estimate_gas ( checking_block , [string] , to_checksum_address ( allowed_address ) , allowance ) [EOL] [EOL] if gas_limit : [EOL] error_prefix = [string] [EOL] log . debug ( [string] , ** log_details ) [EOL] transaction_hash = self . proxy . transact ( [string] , safe_gas_limit ( gas_limit ) , to_checksum_address ( allowed_address ) , allowance , ) [EOL] [EOL] self . client . poll ( transaction_hash ) [EOL] receipt_or_none = check_transaction_threw ( self . client , transaction_hash ) [EOL] [EOL] transaction_executed = gas_limit is not None [EOL] if not transaction_executed or receipt_or_none : [EOL] if transaction_executed : [EOL] block = receipt_or_none [ [string] ] [EOL] else : [EOL] block = checking_block [EOL] [EOL] self . proxy . jsonrpc_client . check_for_insufficient_eth ( transaction_name = [string] , transaction_executed = transaction_executed , required_gas = GAS_REQUIRED_FOR_APPROVE , block_identifier = block , ) [EOL] [EOL] msg = self . _check_why_approved_failed ( allowance , block ) [EOL] error_msg = f"{ error_prefix } [string] { msg }" [EOL] log . critical ( error_msg , ** log_details ) [EOL] raise RaidenUnrecoverableError ( error_msg ) [EOL] [EOL] log . info ( [string] , ** log_details ) [EOL] [EOL] def _check_why_approved_failed ( self , allowance , block_identifier ) : [EOL] user_balance = self . balance_of ( address = self . client . address , block_identifier = block_identifier ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if user_balance == [number] : [EOL] msg = ( [string] [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] elif user_balance < allowance : [EOL] msg = ( f" [string] " f" [string] { user_balance } [string] " f" [string] { allowance } [string] " f" [string] " f" [string] " ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] msg = ( f" [string] " f" [string] { user_balance } [string] " f" [string] " f" [string] " ) . format ( user_balance ) [EOL] [EOL] return msg [EOL] [EOL] def balance_of ( self , address , block_identifier = [string] ) : [EOL] [docstring] [EOL] return self . proxy . contract . functions . balanceOf ( to_checksum_address ( address ) ) . call ( block_identifier = block_identifier ) [EOL] [EOL] def total_supply ( self , block_identifier = [string] ) : [EOL] [docstring] [EOL] return self . proxy . contract . functions . totalSupply ( ) . call ( block_identifier = block_identifier ) [EOL] [EOL] def transfer ( self , to_address , amount ) : [EOL] [comment] [EOL] [comment] [EOL] log_details = { [string] : pex ( self . node_address ) , [string] : pex ( self . address ) , [string] : pex ( to_address ) , [string] : amount , } [EOL] log . debug ( [string] , ** log_details ) [EOL] [EOL] startgas = GAS_LIMIT_FOR_TOKEN_CONTRACT_CALL [EOL] transaction_hash = self . proxy . transact ( [string] , safe_gas_limit ( startgas ) , to_checksum_address ( to_address ) , amount ) [EOL] [EOL] self . client . poll ( transaction_hash ) [EOL] receipt_or_none = check_transaction_threw ( self . client , transaction_hash ) [EOL] if receipt_or_none : [EOL] log . critical ( [string] , ** log_details ) [EOL] raise TransactionThrew ( [string] , receipt_or_none ) [EOL] [EOL] [comment] [EOL] log . info ( [string] , ** log_details ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0
from typing import Any , Optional , List [EOL] import web3 [EOL] import builtins [EOL] import raiden [EOL] import typing [EOL] import raiden_contracts [EOL] from typing import Optional [EOL] [EOL] from eth_utils import decode_hex [EOL] from web3 . utils . filters import Filter [EOL] [EOL] from raiden . constants import GENESIS_BLOCK_NUMBER , UINT256_MAX [EOL] from raiden . network . proxies . token_network import ChannelDetails , TokenNetwork [EOL] from raiden . utils . filters import decode_event , get_filter_args_for_specific_event_from_channel [EOL] from raiden . utils . typing import ( AdditionalHash , Address , BalanceHash , BlockSpecification , ChannelID , Locksroot , MerkleTreeLeaves , Nonce , Signature , TokenAmount , ) [EOL] from raiden_contracts . constants import CONTRACT_TOKEN_NETWORK , ChannelEvent [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] [EOL] class PaymentChannel : [EOL] def __init__ ( self , token_network , channel_identifier , contract_manager , ) : [EOL] if channel_identifier <= [number] or channel_identifier > UINT256_MAX : [EOL] raise ValueError ( f" [string] { channel_identifier } [string] " ) [EOL] [EOL] [comment] [EOL] from_block = GENESIS_BLOCK_NUMBER [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] to_block = [string] [EOL] [EOL] filter_args = get_filter_args_for_specific_event_from_channel ( token_network_address = token_network . address , channel_identifier = channel_identifier , event_name = ChannelEvent . OPENED , contract_manager = contract_manager , from_block = from_block , to_block = to_block , ) [EOL] [EOL] events = token_network . proxy . contract . web3 . eth . getLogs ( filter_args ) [EOL] if not len ( events ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] event = decode_event ( contract_manager . get_contract_abi ( CONTRACT_TOKEN_NETWORK ) , events [ - [number] ] ) [EOL] participant1 = Address ( decode_hex ( event [ [string] ] [ [string] ] ) ) [EOL] participant2 = Address ( decode_hex ( event [ [string] ] [ [string] ] ) ) [EOL] [EOL] if token_network . node_address not in ( participant1 , participant2 ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if token_network . node_address == participant2 : [EOL] participant1 , participant2 = participant2 , participant1 [EOL] [EOL] self . channel_identifier = channel_identifier [EOL] self . participant1 = participant1 [EOL] self . participant2 = participant2 [EOL] self . token_network = token_network [EOL] self . client = token_network . client [EOL] self . contract_manager = contract_manager [EOL] [EOL] def token_address ( self ) : [EOL] [docstring] [EOL] return self . token_network . token_address ( ) [EOL] [EOL] def detail ( self , block_identifier ) : [EOL] [docstring] [EOL] return self . token_network . detail ( participant1 = self . participant1 , participant2 = self . participant2 , block_identifier = block_identifier , channel_identifier = self . channel_identifier , ) [EOL] [EOL] def settle_timeout ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] filter_args = get_filter_args_for_specific_event_from_channel ( token_network_address = self . token_network . address , channel_identifier = self . channel_identifier , event_name = ChannelEvent . OPENED , contract_manager = self . contract_manager , ) [EOL] [EOL] events = self . token_network . proxy . contract . web3 . eth . getLogs ( filter_args ) [EOL] assert len ( events ) > [number] , [string] [EOL] [EOL] [comment] [EOL] event = decode_event ( self . contract_manager . get_contract_abi ( CONTRACT_TOKEN_NETWORK ) , events [ - [number] ] ) [EOL] return event [ [string] ] [ [string] ] [EOL] [EOL] def close_block_number ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] filter_args = get_filter_args_for_specific_event_from_channel ( token_network_address = self . token_network . address , channel_identifier = self . channel_identifier , event_name = ChannelEvent . CLOSED , contract_manager = self . contract_manager , ) [EOL] [EOL] events = self . token_network . proxy . contract . web3 . eth . getLogs ( filter_args ) [EOL] if not events : [EOL] return None [EOL] [EOL] assert len ( events ) == [number] [EOL] event = decode_event ( self . contract_manager . get_contract_abi ( CONTRACT_TOKEN_NETWORK ) , events [ [number] ] ) [EOL] return event [ [string] ] [EOL] [EOL] def opened ( self , block_identifier ) : [EOL] [docstring] [EOL] return self . token_network . channel_is_opened ( participant1 = self . participant1 , participant2 = self . participant2 , block_identifier = block_identifier , channel_identifier = self . channel_identifier , ) [EOL] [EOL] def closed ( self , block_identifier ) : [EOL] [docstring] [EOL] return self . token_network . channel_is_closed ( participant1 = self . participant1 , participant2 = self . participant2 , block_identifier = block_identifier , channel_identifier = self . channel_identifier , ) [EOL] [EOL] def settled ( self , block_identifier ) : [EOL] [docstring] [EOL] return self . token_network . channel_is_settled ( participant1 = self . participant1 , participant2 = self . participant2 , block_identifier = block_identifier , channel_identifier = self . channel_identifier , ) [EOL] [EOL] def can_transfer ( self , block_identifier ) : [EOL] [docstring] [EOL] return self . token_network . can_transfer ( participant1 = self . participant1 , participant2 = self . participant2 , block_identifier = block_identifier , channel_identifier = self . channel_identifier , ) [EOL] [EOL] def set_total_deposit ( self , total_deposit , block_identifier ) : [EOL] self . token_network . set_total_deposit ( given_block_identifier = block_identifier , channel_identifier = self . channel_identifier , total_deposit = total_deposit , partner = self . participant2 , ) [EOL] [EOL] def close ( self , nonce , balance_hash , additional_hash , signature , block_identifier , ) : [EOL] [docstring] [EOL] self . token_network . close ( channel_identifier = self . channel_identifier , partner = self . participant2 , balance_hash = balance_hash , nonce = nonce , additional_hash = additional_hash , signature = signature , given_block_identifier = block_identifier , ) [EOL] [EOL] def update_transfer ( self , nonce , balance_hash , additional_hash , partner_signature , signature , block_identifier , ) : [EOL] [docstring] [EOL] self . token_network . update_transfer ( channel_identifier = self . channel_identifier , partner = self . participant2 , balance_hash = balance_hash , nonce = nonce , additional_hash = additional_hash , closing_signature = partner_signature , non_closing_signature = signature , given_block_identifier = block_identifier , ) [EOL] [EOL] def unlock ( self , merkle_tree_leaves , participant , partner , ) : [EOL] self . token_network . unlock ( channel_identifier = self . channel_identifier , participant = participant , partner = partner , merkle_tree_leaves = merkle_tree_leaves , ) [EOL] [EOL] def settle ( self , transferred_amount , locked_amount , locksroot , partner_transferred_amount , partner_locked_amount , partner_locksroot , block_identifier , ) : [EOL] [docstring] [EOL] self . token_network . settle ( channel_identifier = self . channel_identifier , transferred_amount = transferred_amount , locked_amount = locked_amount , locksroot = locksroot , partner = self . participant2 , partner_transferred_amount = partner_transferred_amount , partner_locked_amount = partner_locked_amount , partner_locksroot = partner_locksroot , given_block_identifier = block_identifier , ) [EOL] [EOL] def all_events_filter ( self , from_block = None , to_block = None ) : [EOL] [EOL] channel_topics = [ None , f" [string] { self . channel_identifier : [string] }" ] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] channel_filter = self . token_network . client . new_filter ( contract_address = self . token_network . address , topics = channel_topics , from_block = from_block , to_block = to_block , ) [EOL] [EOL] return channel_filter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.utils.filters.Filter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , Dict [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] import raiden [EOL] from http import HTTPStatus [EOL] [EOL] import requests [EOL] from eth_utils import to_bytes , to_hex [EOL] [EOL] from raiden . raiden_service import RaidenService [EOL] from raiden . storage . wal import WriteAheadLog [EOL] from raiden . transfer . mediated_transfer . events import SendSecretRequest [EOL] from raiden . transfer . mediated_transfer . state_change import ReceiveSecretReveal [EOL] [EOL] [EOL] def reveal_secret_with_resolver ( raiden , secret_request_event ) : [EOL] [EOL] if [string] not in raiden . config : [EOL] return False [EOL] [EOL] assert isinstance ( raiden . wal , WriteAheadLog ) , [string] [EOL] current_state = raiden . wal . state_manager . current_state [EOL] task = current_state . payment_mapping . secrethashes_to_task [ secret_request_event . secrethash ] [EOL] token = task . target_state . transfer . token [EOL] [EOL] request = { [string] : to_hex ( token ) , [string] : to_hex ( secret_request_event . secrethash ) , [string] : secret_request_event . amount , [string] : secret_request_event . payment_identifier , [string] : to_hex ( secret_request_event . recipient ) , [string] : secret_request_event . expiration , [string] : to_hex ( raiden . address ) , [string] : raiden . config [ [string] ] , [string] : raiden . config [ [string] ] , } [EOL] [EOL] try : [EOL] response = requests . post ( raiden . config [ [string] ] , json = request ) [EOL] except requests . exceptions . RequestException : [EOL] return False [EOL] [EOL] if response is None or response . status_code != HTTPStatus . OK : [EOL] return False [EOL] [EOL] state_change = ReceiveSecretReveal ( to_bytes ( hexstr = response . json ( ) [ [string] ] ) , secret_request_event . recipient ) [EOL] raiden . handle_and_track_state_change ( state_change ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from raiden . network . transport . matrix import MatrixTransport [comment] [EOL] from raiden . network . transport . udp import UDPTransport [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from raiden . network . transport . matrix . transport import MatrixTransport , _RetryQueue [comment] [EOL] from raiden . network . transport . matrix . utils import ( AddressReachability , UserPresence , join_global_room , login_or_register , make_client , make_room_alias , sort_servers_closest , validate_userid_signature , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import GMatrixClient [EOL] from typing import Union , List , Dict , Optional , Any , Iterable , Callable , Container [EOL] import raiden [EOL] import builtins [EOL] import gevent [EOL] import matrix_client [EOL] import typing [EOL] import requests [EOL] import json [EOL] import time [EOL] from functools import wraps [EOL] from itertools import repeat [EOL] from typing import Any , Callable , Container , Dict , Iterable , List , Optional [EOL] from urllib . parse import quote [EOL] [EOL] import gevent [EOL] import structlog [EOL] from gevent . lock import Semaphore [EOL] from matrix_client . api import MatrixHttpApi [EOL] from matrix_client . client import CACHE , MatrixClient [EOL] from matrix_client . errors import MatrixHttpLibError , MatrixRequestError [EOL] from matrix_client . room import Room as MatrixRoom [EOL] from matrix_client . user import User [EOL] from requests . adapters import HTTPAdapter [EOL] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class Room ( MatrixRoom ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , room_id ) : [EOL] super ( ) . __init__ ( client , room_id ) [EOL] self . _members = { } [EOL] [EOL] [comment] [EOL] self . account_data = dict ( ) [EOL] [EOL] def get_joined_members ( self , force_resync = False ) : [EOL] [docstring] [EOL] if force_resync : [EOL] response = self . client . api . get_room_members ( self . room_id ) [EOL] for event in response [ [string] ] : [EOL] if event [ [string] ] [ [string] ] == [string] : [EOL] user_id = event [ [string] ] [EOL] if user_id not in self . _members : [EOL] self . _mkmembers ( User ( self . client . api , user_id , event [ [string] ] . get ( [string] ) ) ) [EOL] return list ( self . _members . values ( ) ) [EOL] [EOL] def _mkmembers ( self , member ) : [EOL] if member . user_id not in self . _members : [EOL] self . _members [ member . user_id ] = member [EOL] [EOL] def _rmmembers ( self , user_id ) : [EOL] self . _members . pop ( user_id , None ) [EOL] [EOL] def __repr__ ( self ) : [EOL] if self . canonical_alias : [EOL] return f" [string] { self . room_id !r} [string] { self . canonical_alias !r} [string] " [EOL] return f" [string] { self . room_id !r} [string] { self . aliases !r} [string] " [EOL] [EOL] def update_aliases ( self ) : [EOL] [docstring] [EOL] changed = False [EOL] try : [EOL] response = self . client . api . get_room_state ( self . room_id ) [EOL] except MatrixRequestError : [EOL] return False [EOL] for chunk in response : [EOL] content = chunk . get ( [string] ) [EOL] if content : [EOL] if [string] in content : [EOL] aliases = content [ [string] ] [EOL] if aliases != self . aliases : [EOL] self . aliases = aliases [EOL] changed = True [EOL] if chunk . get ( [string] ) == [string] : [EOL] canonical_alias = content [ [string] ] [EOL] if self . canonical_alias != canonical_alias : [EOL] self . canonical_alias = canonical_alias [EOL] changed = True [EOL] if changed and self . aliases and not self . canonical_alias : [EOL] self . canonical_alias = self . aliases [ [number] ] [EOL] return changed [EOL] [EOL] def set_account_data ( self , type_ , content ) : [EOL] self . account_data [ type_ ] = content [EOL] return self . client . api . set_room_account_data ( quote ( self . client . user_id ) , quote ( self . room_id ) , quote ( type_ ) , content ) [EOL] [EOL] [EOL] class GMatrixHttpApi ( MatrixHttpApi ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , pool_maxsize = [number] , retry_timeout = [number] , retry_delay = None , long_paths = ( ) , ** kwargs , ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] http_adapter = HTTPAdapter ( pool_maxsize = pool_maxsize ) [EOL] https_adapter = HTTPAdapter ( pool_maxsize = pool_maxsize ) [EOL] self . session . mount ( [string] , http_adapter ) [EOL] self . session . mount ( [string] , https_adapter ) [EOL] [EOL] self . _long_paths = long_paths [EOL] if long_paths : [EOL] self . _semaphore = Semaphore ( pool_maxsize - [number] ) [EOL] self . _priority_lock = Semaphore ( ) [EOL] else : [EOL] self . _semaphore = Semaphore ( pool_maxsize ) [EOL] self . retry_timeout = retry_timeout [EOL] self . retry_delay = retry_delay [EOL] if self . retry_delay is None : [EOL] self . retry_delay = lambda : repeat ( [number] ) [EOL] [EOL] def _send ( self , method , path , * args , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] started = time . time ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if path in self . _long_paths : [EOL] with self . _priority_lock : [EOL] return super ( ) . _send ( method , path , * args , ** kwargs ) [EOL] last_ex = None [EOL] for delay in self . retry_delay ( ) : [EOL] try : [EOL] with self . _semaphore : [EOL] return super ( ) . _send ( method , path , * args , ** kwargs ) [EOL] except ( MatrixRequestError , MatrixHttpLibError ) as ex : [EOL] [comment] [EOL] if isinstance ( ex , MatrixRequestError ) and ex . code < [number] : [EOL] raise [EOL] if time . time ( ) > started + self . retry_timeout : [EOL] raise [EOL] last_ex = ex [EOL] log . debug ( [string] , wait_for = delay , _exception = ex , ) [EOL] gevent . sleep ( delay ) [EOL] else : [EOL] raise last_ex [EOL] [EOL] def send_to_device ( self , event_type , messages , txn_id = None ) : [comment] [EOL] started = time . time ( ) [EOL] last_ex = None [EOL] for delay in self . retry_delay ( ) : [EOL] try : [EOL] with self . _semaphore : [EOL] return super ( ) . send_to_device ( event_type , messages , txn_id = None ) [EOL] except ( MatrixRequestError , MatrixHttpLibError ) as ex : [EOL] [comment] [EOL] if isinstance ( ex , MatrixRequestError ) and ex . code < [number] : [EOL] raise [EOL] if time . time ( ) > started + self . retry_timeout : [EOL] raise [EOL] last_ex = ex [EOL] log . debug ( [string] , wait_for = delay , _exception = ex , ) [EOL] gevent . sleep ( delay ) [EOL] else : [EOL] raise last_ex [EOL] [EOL] [EOL] class GMatrixClient ( MatrixClient ) : [EOL] [docstring] [EOL] [EOL] sync_filter = ... [EOL] sync_thread = None [EOL] _handle_thread = None [EOL] [EOL] def __init__ ( self , base_url , token = None , user_id = None , valid_cert_check = True , sync_filter_limit = [number] , cache_level = CACHE . ALL , http_pool_maxsize = [number] , http_retry_timeout = [number] , http_retry_delay = lambda : repeat ( [number] ) , ) : [EOL] [comment] [EOL] self . account_data = dict ( ) [EOL] self . _post_hook_func = None [EOL] self . token = None [EOL] [EOL] super ( ) . __init__ ( base_url , token , user_id , valid_cert_check , sync_filter_limit , cache_level ) [EOL] self . api = GMatrixHttpApi ( base_url , token , pool_maxsize = http_pool_maxsize , retry_timeout = http_retry_timeout , retry_delay = http_retry_delay , long_paths = ( [string] , ) , ) [EOL] [EOL] def listen_forever ( self , timeout_ms = [number] , exception_handler = None , bad_sync_timeout = [number] , ) : [EOL] [docstring] [EOL] _bad_sync_timeout = bad_sync_timeout [EOL] self . should_listen = True [EOL] while self . should_listen : [EOL] try : [EOL] [comment] [EOL] self . _sync ( timeout_ms ) [EOL] _bad_sync_timeout = bad_sync_timeout [EOL] except MatrixRequestError as e : [EOL] log . warning ( [string] ) [EOL] if e . code >= [number] : [EOL] log . warning ( [string] , wait_for = _bad_sync_timeout ) [EOL] gevent . sleep ( _bad_sync_timeout ) [EOL] _bad_sync_timeout = min ( _bad_sync_timeout * [number] , self . bad_sync_timeout_limit ) [EOL] else : [EOL] raise [EOL] except MatrixHttpLibError : [EOL] log . exception ( [string] ) [EOL] if self . should_listen : [EOL] gevent . sleep ( _bad_sync_timeout ) [EOL] _bad_sync_timeout = min ( _bad_sync_timeout * [number] , self . bad_sync_timeout_limit ) [EOL] except Exception as e : [EOL] log . exception ( [string] ) [EOL] if exception_handler is not None : [EOL] exception_handler ( e ) [EOL] else : [EOL] raise [EOL] [EOL] def start_listener_thread ( self , timeout_ms = [number] , exception_handler = None ) : [EOL] [docstring] [EOL] assert not self . should_listen and self . sync_thread is None , [string] [EOL] self . should_listen = True [EOL] self . sync_thread = gevent . spawn ( self . listen_forever , timeout_ms , exception_handler ) [EOL] self . sync_thread . name = f" [string] { self . user_id }" [EOL] [EOL] def stop_listener_thread ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . should_listen = False [EOL] if self . sync_thread : [EOL] self . sync_thread . kill ( ) [EOL] self . sync_thread . get ( ) [EOL] if self . _handle_thread is not None : [EOL] self . _handle_thread . get ( ) [EOL] self . sync_thread = None [EOL] self . _handle_thread = None [EOL] [EOL] def logout ( self ) : [EOL] super ( ) . logout ( ) [EOL] self . api . session . close ( ) [EOL] [EOL] def search_user_directory ( self , term ) : [EOL] [docstring] [EOL] response = self . api . _send ( [string] , [string] , { [string] : term } ) [EOL] try : [EOL] return [ User ( self . api , _user [ [string] ] , _user [ [string] ] ) for _user in response [ [string] ] ] [EOL] except KeyError : [EOL] return [ ] [EOL] [EOL] def search_room_directory ( self , filter_term = None , limit = [number] ) : [EOL] filter_options = { } [EOL] if filter_term : [EOL] filter_options = { [string] : { [string] : filter_term } } [EOL] [EOL] response = self . api . _send ( [string] , [string] , { [string] : limit , ** filter_options } ) [EOL] rooms = [ ] [EOL] for room_info in response [ [string] ] : [EOL] room = Room ( self , room_info [ [string] ] ) [EOL] room . canonical_alias = room_info . get ( [string] ) [EOL] rooms . append ( room ) [EOL] return rooms [EOL] [EOL] def modify_presence_list ( self , add_user_ids = None , remove_user_ids = None ) : [EOL] if add_user_ids is None : [EOL] add_user_ids = [ ] [EOL] if remove_user_ids is None : [EOL] remove_user_ids = [ ] [EOL] return self . api . _send ( [string] , f" [string] { quote ( self . user_id ) }" , { [string] : add_user_ids , [string] : remove_user_ids } , ) [EOL] [EOL] def get_presence_list ( self ) : [EOL] return self . api . _send ( [string] , f" [string] { quote ( self . user_id ) }" ) [EOL] [EOL] def set_presence_state ( self , state ) : [EOL] return self . api . _send ( [string] , f" [string] { quote ( self . user_id ) } [string] " , { [string] : state } ) [EOL] [EOL] def typing ( self , room , timeout = [number] ) : [EOL] [docstring] [EOL] path = f" [string] { quote ( room . room_id ) } [string] { quote ( self . user_id ) }" [EOL] return self . api . _send ( [string] , path , { [string] : True , [string] : timeout } ) [EOL] [EOL] def _mkroom ( self , room_id ) : [EOL] [docstring] [EOL] if room_id not in self . rooms : [EOL] self . rooms [ room_id ] = Room ( self , room_id ) [EOL] room = self . rooms [ room_id ] [EOL] if not room . canonical_alias : [EOL] room . update_aliases ( ) [EOL] return room [EOL] [EOL] def get_user_presence ( self , user_id ) : [EOL] return self . api . _send ( [string] , f" [string] { quote ( user_id ) } [string] " ) . get ( [string] ) [EOL] [EOL] @ staticmethod def call ( callback , * args , ** kwargs ) : [EOL] return callback ( * args , ** kwargs ) [EOL] [EOL] def _sync ( self , timeout_ms = [number] ) : [EOL] [docstring] [EOL] response = self . api . sync ( self . sync_token , timeout_ms ) [EOL] prev_sync_token = self . sync_token [EOL] self . sync_token = response [ [string] ] [EOL] [EOL] if self . _handle_thread is not None : [EOL] [comment] [EOL] self . _handle_thread . get ( ) [EOL] [EOL] is_first_sync = prev_sync_token is None [EOL] self . _handle_thread = gevent . Greenlet ( self . _handle_response , response , is_first_sync ) [EOL] self . _handle_thread . name = ( f" [string] { self . user_id } [string] { prev_sync_token }" ) [EOL] self . _handle_thread . link_exception ( lambda g : self . sync_thread . kill ( g . exception ) ) [EOL] self . _handle_thread . start ( ) [EOL] [EOL] if self . _post_hook_func is not None : [EOL] self . _post_hook_func ( self . sync_token ) [EOL] [EOL] def _handle_response ( self , response , first_sync = False ) : [EOL] [comment] [EOL] for presence_update in response [ [string] ] [ [string] ] : [EOL] for callback in self . presence_listeners . values ( ) : [EOL] self . call ( callback , presence_update ) [EOL] [EOL] for to_device_message in response [ [string] ] [ [string] ] : [EOL] for listener in self . listeners : [EOL] if listener [ [string] ] == [string] : [EOL] self . call ( listener [ [string] ] , to_device_message ) [EOL] [EOL] for room_id , invite_room in response [ [string] ] [ [string] ] . items ( ) : [EOL] for listener in self . invite_listeners : [EOL] self . call ( listener , room_id , invite_room [ [string] ] ) [EOL] [EOL] for room_id , left_room in response [ [string] ] [ [string] ] . items ( ) : [EOL] for listener in self . left_listeners : [EOL] self . call ( listener , room_id , left_room ) [EOL] if room_id in self . rooms : [EOL] del self . rooms [ room_id ] [EOL] [EOL] for room_id , sync_room in response [ [string] ] [ [string] ] . items ( ) : [EOL] if room_id not in self . rooms : [EOL] self . _mkroom ( room_id ) [EOL] room = self . rooms [ room_id ] [EOL] [comment] [EOL] room . prev_batch = sync_room [ [string] ] [ [string] ] [EOL] [EOL] for event in sync_room [ [string] ] [ [string] ] : [EOL] event [ [string] ] = room_id [EOL] self . call ( room . _process_state_event , event ) [EOL] [EOL] for event in sync_room [ [string] ] [ [string] ] : [EOL] event [ [string] ] = room_id [EOL] self . call ( room . _put_event , event ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] for listener in self . listeners : [EOL] should_call = ( listener [ [string] ] is None or listener [ [string] ] == event [ [string] ] ) [EOL] if should_call : [EOL] self . call ( listener [ [string] ] , event ) [EOL] [EOL] for event in sync_room [ [string] ] [ [string] ] : [EOL] event [ [string] ] = room_id [EOL] self . call ( room . _put_ephemeral_event , event ) [EOL] [EOL] for listener in self . ephemeral_listeners : [EOL] should_call = ( listener [ [string] ] is None or listener [ [string] ] == event [ [string] ] ) [EOL] if should_call : [EOL] self . call ( listener [ [string] ] , event ) [EOL] [EOL] for event in sync_room [ [string] ] [ [string] ] : [EOL] room . account_data [ event [ [string] ] ] = event [ [string] ] [EOL] [EOL] if first_sync : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for event in response [ [string] ] [ [string] ] : [EOL] self . account_data [ event [ [string] ] ] = event [ [string] ] [EOL] [EOL] def set_account_data ( self , type_ , content ) : [EOL] [docstring] [EOL] self . account_data [ type_ ] = content [EOL] return self . api . set_account_data ( quote ( self . user_id ) , quote ( type_ ) , content ) [EOL] [EOL] def set_post_sync_hook ( self , hook ) : [EOL] self . _post_hook_func = hook [EOL] [EOL] def set_sync_token ( self , sync_token ) : [EOL] self . sync_token = sync_token [EOL] [EOL] def set_access_token ( self , user_id , token ) : [EOL] self . user_id = user_id [EOL] self . token = self . api . token = token [EOL] [EOL] def set_sync_limit ( self , limit ) : [EOL] [docstring] [EOL] try : [EOL] prev_limit = json . loads ( self . sync_filter ) [ [string] ] [ [string] ] [ [string] ] [EOL] except ( json . JSONDecodeError , KeyError ) : [EOL] prev_limit = None [EOL] self . sync_filter = json . dumps ( { [string] : { [string] : { [string] : limit } } } ) [EOL] return prev_limit [EOL] [EOL] [EOL] [comment] [EOL] @ wraps ( User . __repr__ ) def user__repr__ ( self ) : [EOL] return f" [string] { self . user_id !r} [string] " [EOL] [EOL] [EOL] User . __repr__ = user__repr__ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GMatrixClient.typing.List[Room]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $GMatrixClient.typing.List[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $Room$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $Room$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $Room$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $GMatrixClient.typing.Dict[builtins.str,GMatrixClient.typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $GMatrixClient.typing.Dict[builtins.str,GMatrixClient.typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $GMatrixClient.typing.Dict[builtins.str,GMatrixClient.typing.Any]$ 0 0 0 0 0 0 0 0 $GMatrixClient.typing.Callable[[builtins.str],None]$ 0 0 0 0 0 $typing.Optional[typing.Callable[[builtins.str],None]]$ 0 $GMatrixClient.typing.Callable[[builtins.str],None]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GMatrixClient.typing.Optional[builtins.int]$ 0 0 0 $GMatrixClient.typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GMatrixClient.typing.Optional[builtins.int]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from raiden . network . transport . udp . udp_transport import UDPTransport [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import structlog [EOL] [EOL] from raiden . constants import UINT64_MAX , UINT256_MAX [EOL] from raiden . encoding . encoders import integer [EOL] from raiden . encoding . format import make_field , namedbuffer , pad [EOL] [EOL] [EOL] def cmdid ( id_ ) : [EOL] return make_field ( [string] , [number] , [string] , integer ( id_ , id_ ) ) [EOL] [EOL] [EOL] PROCESSED = [number] [EOL] PING = [number] [EOL] PONG = [number] [EOL] SECRETREQUEST = [number] [EOL] UNLOCK = [number] [EOL] LOCKEDTRANSFER = [number] [EOL] REFUNDTRANSFER = [number] [EOL] REVEALSECRET = [number] [EOL] DELIVERED = [number] [EOL] LOCKEXPIRED = [number] [EOL] TODEVICE = [number] [EOL] [EOL] [EOL] [comment] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] nonce = make_field ( [string] , [number] , [string] , integer ( [number] , UINT64_MAX ) ) [EOL] updating_nonce = make_field ( [string] , [number] , [string] , integer ( [number] , UINT64_MAX ) ) [EOL] other_nonce = make_field ( [string] , [number] , [string] , integer ( [number] , UINT64_MAX ) ) [EOL] payment_identifier = make_field ( [string] , [number] , [string] , integer ( [number] , UINT64_MAX ) ) [EOL] chain_id = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] message_identifier = make_field ( [string] , [number] , [string] , integer ( [number] , UINT64_MAX ) ) [EOL] current_protocol_version = make_field ( [string] , [number] , [string] , integer ( [number] , [number] ) ) [EOL] delivered_message_identifier = make_field ( [string] , [number] , [string] , integer ( [number] , UINT64_MAX ) ) [EOL] expiration = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] [EOL] token_network_address = make_field ( [string] , [number] , [string] ) [EOL] token = make_field ( [string] , [number] , [string] ) [EOL] recipient = make_field ( [string] , [number] , [string] ) [EOL] target = make_field ( [string] , [number] , [string] ) [EOL] initiator = make_field ( [string] , [number] , [string] ) [EOL] updating_participant = make_field ( [string] , [number] , [string] ) [EOL] other_participant = make_field ( [string] , [number] , [string] ) [EOL] channel_identifier = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] [EOL] locksroot = make_field ( [string] , [number] , [string] ) [EOL] secrethash = make_field ( [string] , [number] , [string] ) [EOL] balance_hash = make_field ( [string] , [number] , [string] ) [EOL] additional_hash = make_field ( [string] , [number] , [string] ) [EOL] secret = make_field ( [string] , [number] , [string] ) [EOL] transferred_amount = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] locked_amount = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] amount = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] reward_amount = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] fee = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] reveal_timeout = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] updating_capacity = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] other_capacity = make_field ( [string] , [number] , [string] , integer ( [number] , UINT256_MAX ) ) [EOL] [EOL] signature = make_field ( [string] , [number] , [string] ) [EOL] non_closing_signature = make_field ( [string] , [number] , [string] ) [EOL] reward_proof_signature = make_field ( [string] , [number] , [string] ) [EOL] [EOL] Processed = namedbuffer ( [string] , [ cmdid ( PROCESSED ) , pad ( [number] ) , message_identifier , signature ] ) [EOL] [EOL] Delivered = namedbuffer ( [string] , [ cmdid ( DELIVERED ) , pad ( [number] ) , delivered_message_identifier , signature ] ) [EOL] [EOL] Ping = namedbuffer ( [string] , [ cmdid ( PING ) , pad ( [number] ) , nonce , current_protocol_version , signature ] ) [EOL] [EOL] Pong = namedbuffer ( [string] , [ cmdid ( PONG ) , pad ( [number] ) , nonce , signature ] ) [EOL] [EOL] SecretRequest = namedbuffer ( [string] , [ cmdid ( SECRETREQUEST ) , pad ( [number] ) , message_identifier , payment_identifier , secrethash , amount , expiration , signature , ] , ) [EOL] [EOL] Unlock = namedbuffer ( [string] , [ cmdid ( UNLOCK ) , pad ( [number] ) , chain_id , message_identifier , payment_identifier , token_network_address , secret , nonce , channel_identifier , transferred_amount , locked_amount , locksroot , signature , ] , ) [EOL] [EOL] RevealSecret = namedbuffer ( [string] , [ cmdid ( REVEALSECRET ) , pad ( [number] ) , message_identifier , secret , signature ] ) [EOL] [EOL] LockedTransfer = namedbuffer ( [string] , [ cmdid ( LOCKEDTRANSFER ) , pad ( [number] ) , nonce , chain_id , message_identifier , payment_identifier , expiration , token_network_address , token , channel_identifier , recipient , target , initiator , locksroot , secrethash , transferred_amount , locked_amount , amount , fee , signature , ] , ) [EOL] [EOL] RefundTransfer = namedbuffer ( [string] , [ cmdid ( REFUNDTRANSFER ) , pad ( [number] ) , nonce , chain_id , message_identifier , payment_identifier , expiration , token_network_address , token , channel_identifier , recipient , target , initiator , locksroot , secrethash , transferred_amount , locked_amount , amount , fee , signature , ] , ) [EOL] [EOL] LockExpired = namedbuffer ( [string] , [ cmdid ( LOCKEXPIRED ) , pad ( [number] ) , nonce , chain_id , message_identifier , token_network_address , channel_identifier , recipient , locksroot , secrethash , transferred_amount , locked_amount , signature , ] , ) [EOL] [EOL] [EOL] Lock = namedbuffer ( [string] , [ expiration , amount , secrethash ] ) [EOL] [EOL] [EOL] RequestMonitoring = namedbuffer ( [string] , [ nonce , chain_id , token_network_address , channel_identifier , balance_hash , additional_hash , signature , non_closing_signature , reward_amount , reward_proof_signature , ] , ) [EOL] [EOL] [EOL] UpdatePFS = namedbuffer ( [string] , [ chain_id , token_network_address , channel_identifier , updating_participant , other_participant , updating_nonce , other_nonce , updating_capacity , other_capacity , reveal_timeout , fee , signature , ] , ) [EOL] [EOL] ToDevice = namedbuffer ( [string] , [ cmdid ( TODEVICE ) , pad ( [number] ) , message_identifier , signature ] ) [EOL] [EOL] CMDID_MESSAGE = { PROCESSED : Processed , PING : Ping , PONG : Pong , SECRETREQUEST : SecretRequest , UNLOCK : Unlock , REVEALSECRET : RevealSecret , LOCKEDTRANSFER : LockedTransfer , REFUNDTRANSFER : RefundTransfer , DELIVERED : Delivered , LOCKEXPIRED : LockExpired , TODEVICE : ToDevice , } [EOL] [EOL] [EOL] def wrap ( data ) : [EOL] [docstring] [EOL] try : [EOL] cmdid = data [ [number] ] [EOL] except IndexError : [EOL] log . warning ( [string] ) [EOL] return None [EOL] [EOL] try : [EOL] message_type = CMDID_MESSAGE [ cmdid ] [EOL] except KeyError : [EOL] log . error ( [string] , cmdid ) [EOL] return None [EOL] [EOL] try : [EOL] message = message_type ( data ) [EOL] except ValueError : [EOL] log . error ( [string] ) [EOL] return None [EOL] [EOL] return message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Dict , Any , Tuple [EOL] import typing [EOL] import raiden [EOL] from collections import Counter , namedtuple [EOL] [EOL] from raiden . exceptions import InvalidProtocolMessage [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] Field = namedtuple ( [string] , ( [string] , [string] , [string] , [string] ) ) [EOL] [EOL] Pad = namedtuple ( [string] , ( [string] , [string] ) ) [EOL] [EOL] [EOL] def make_field ( name , size_bytes , format_string , encoder = None ) : [EOL] if size_bytes < [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return Field ( name , size_bytes , format_string , encoder ) [EOL] [EOL] [EOL] def pad ( bytes_ ) : [EOL] return Pad ( bytes_ , [string] . format ( bytes_ ) ) [EOL] [EOL] [EOL] def buffer_for ( klass ) : [EOL] [docstring] [EOL] return bytearray ( klass . size ) [EOL] [EOL] [EOL] def compute_slices ( fields_spec ) : [EOL] name_to_slice = dict ( ) [EOL] start = [number] [EOL] [EOL] for field in fields_spec : [EOL] end = start + field . size_bytes [EOL] [EOL] if not isinstance ( field , Pad ) : [comment] [EOL] name_to_slice [ field . name ] = slice ( start , end ) [EOL] [EOL] start = end [EOL] [EOL] return name_to_slice [EOL] [EOL] [EOL] def namedbuffer ( buffer_name , fields_spec ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] [EOL] if not len ( buffer_name ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not len ( fields_spec ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] fields = [ field for field in fields_spec if not isinstance ( field , Pad ) ] [EOL] [EOL] if any ( field . size_bytes < [number] for field in fields ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if any ( len ( field . name ) < [number] for field in fields ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] names_fields = { field . name : field for field in fields } [EOL] [EOL] if [string] in names_fields : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if any ( count > [number] for count in Counter ( field . name for field in fields ) . values ( ) ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [comment] [EOL] fields_format = [string] + [string] . join ( field . format_string for field in fields_spec ) [EOL] size = sum ( field . size_bytes for field in fields_spec ) [EOL] names_slices = compute_slices ( fields_spec ) [EOL] sorted_names = sorted ( names_fields . keys ( ) ) [EOL] [EOL] @ staticmethod def get_bytes_from ( buffer_ , name ) : [EOL] slice_ = names_slices [ name ] [EOL] return buffer_ [ slice_ ] [EOL] [EOL] def __init__ ( self , data ) : [EOL] if len ( data ) < size : [EOL] raise InvalidProtocolMessage ( [string] . format ( size ) ) [EOL] [EOL] object . __setattr__ ( self , [string] , data ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __getattribute__ ( self , name ) : [EOL] if name in names_slices : [EOL] slice_ = names_slices [ name ] [EOL] field = names_fields [ name ] [EOL] [EOL] data = object . __getattribute__ ( self , [string] ) [EOL] value = data [ slice_ ] [EOL] [EOL] if field . encoder : [EOL] value = field . encoder . decode ( value ) [EOL] [EOL] return value [EOL] [EOL] if name == [string] : [EOL] return object . __getattribute__ ( self , [string] ) [EOL] [EOL] raise AttributeError [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] if name in names_slices : [EOL] slice_ = names_slices [ name ] [EOL] field = names_fields [ name ] [EOL] [EOL] if field . encoder : [EOL] field . encoder . validate ( value ) [EOL] value = field . encoder . encode ( value , field . size_bytes ) [EOL] [EOL] length = len ( value ) [EOL] if length > field . size_bytes : [EOL] msg = [string] . format ( length = length , attr = name ) [EOL] raise ValueError ( msg ) [EOL] elif length < field . size_bytes : [EOL] pad_size = field . size_bytes - length [EOL] pad_value = [string] * pad_size [EOL] value = pad_value + value [EOL] [EOL] data = object . __getattribute__ ( self , [string] ) [EOL] if isinstance ( value , str ) : [EOL] value = value . encode ( ) [EOL] data [ slice_ ] = value [EOL] else : [EOL] super ( self . __class__ , self ) . __setattr__ ( name , value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( buffer_name ) [EOL] [EOL] def __len__ ( self ) : [EOL] return size [EOL] [EOL] def __dir__ ( self ) : [EOL] return sorted_names [EOL] [EOL] attributes = { [string] : __init__ , [string] : ( [string] , ) , [string] : __getattribute__ , [string] : __setattr__ , [string] : __repr__ , [string] : __len__ , [string] : __dir__ , [string] : fields_spec , [string] : fields_format , [string] : size , [string] : get_bytes_from , } [EOL] [EOL] return type ( buffer_name , ( ) , attributes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.encoding.format.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.encoding.format.Pad]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.encoding.format.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.encoding.format.Pad]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.encoding.format.Pad]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.encoding.format.Pad]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] from eth_utils import to_checksum_address [EOL] [EOL] from raiden . tests . utils . factories import HOP1 [EOL] [EOL] [EOL] def burn_eth ( raiden_service , amount_to_leave = [number] ) : [EOL] [docstring] [EOL] address = to_checksum_address ( raiden_service . address ) [EOL] client = raiden_service . chain . client [EOL] web3 = client . web3 [EOL] gas_price = web3 . eth . gasPrice [EOL] value = web3 . eth . getBalance ( address ) - gas_price * ( [number] + amount_to_leave ) [EOL] transaction_hash = client . send_transaction ( to = HOP1 , value = value , startgas = [number] ) [EOL] client . poll ( transaction_hash ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import raiden_contracts [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import os [EOL] from typing import List , Tuple [EOL] [EOL] from raiden . network . blockchain_service import BlockChainService [EOL] from raiden . network . pathfinding import get_random_service [EOL] from raiden . network . proxies . service_registry import ServiceRegistry [EOL] from raiden . network . rpc . client import JSONRPCClient [EOL] from raiden . network . rpc . smartcontract_proxy import ContractProxy [EOL] from raiden . utils import typing [EOL] from raiden . utils . smart_contracts import deploy_contract_web3 [EOL] from raiden . utils . solc import compile_files_cwd [EOL] from raiden_contracts . constants import CONTRACT_HUMAN_STANDARD_TOKEN [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] [EOL] def deploy_token ( deploy_client , contract_manager , initial_amount , decimals , token_name , token_symbol , ) : [EOL] token_address = deploy_contract_web3 ( contract_name = CONTRACT_HUMAN_STANDARD_TOKEN , deploy_client = deploy_client , contract_manager = contract_manager , constructor_arguments = ( initial_amount , decimals , token_name , token_symbol ) , ) [EOL] [EOL] contract_abi = contract_manager . get_contract_abi ( CONTRACT_HUMAN_STANDARD_TOKEN ) [EOL] return deploy_client . new_contract_proxy ( contract_interface = contract_abi , contract_address = token_address ) [EOL] [EOL] [EOL] def deploy_tokens_and_fund_accounts ( token_amount , number_of_tokens , deploy_service , participants , contract_manager , ) : [EOL] [docstring] [EOL] result = list ( ) [EOL] for _ in range ( number_of_tokens ) : [EOL] token_address = deploy_contract_web3 ( CONTRACT_HUMAN_STANDARD_TOKEN , deploy_service . client , contract_manager = contract_manager , constructor_arguments = ( token_amount , [number] , [string] , [string] ) , ) [EOL] [EOL] result . append ( token_address ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for transfer_to in participants : [EOL] deploy_service . token ( token_address ) . transfer ( to_address = transfer_to , amount = token_amount // len ( participants ) ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def deploy_service_registry_and_set_urls ( private_keys , web3 , contract_manager , service_registry_address ) : [EOL] urls = [ [string] , [string] , [string] ] [EOL] c1_client = JSONRPCClient ( web3 , private_keys [ [number] ] ) [EOL] c1_service_proxy = ServiceRegistry ( jsonrpc_client = c1_client , service_registry_address = service_registry_address , contract_manager = contract_manager , ) [EOL] c2_client = JSONRPCClient ( web3 , private_keys [ [number] ] ) [EOL] c2_service_proxy = ServiceRegistry ( jsonrpc_client = c2_client , service_registry_address = service_registry_address , contract_manager = contract_manager , ) [EOL] c3_client = JSONRPCClient ( web3 , private_keys [ [number] ] ) [EOL] c3_service_proxy = ServiceRegistry ( jsonrpc_client = c3_client , service_registry_address = service_registry_address , contract_manager = contract_manager , ) [EOL] [EOL] [comment] [EOL] pfs_address = get_random_service ( c1_service_proxy , [string] ) [EOL] assert pfs_address is None [EOL] [EOL] [comment] [EOL] c1_service_proxy . set_url ( urls [ [number] ] ) [EOL] c2_service_proxy . set_url ( urls [ [number] ] ) [EOL] c3_service_proxy . set_url ( urls [ [number] ] ) [EOL] [EOL] return c1_service_proxy , urls [EOL] [EOL] [EOL] def get_test_contract ( name ) : [EOL] contract_path = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , name ) ) [EOL] contracts = compile_files_cwd ( [ contract_path ] ) [EOL] [EOL] return contract_path , contracts [EOL] [EOL] [EOL] def deploy_rpc_test_contract ( deploy_client , name ) : [EOL] contract_path , contracts = get_test_contract ( f"{ name } [string] " ) [EOL] contract_proxy , _ = deploy_client . deploy_solidity_contract ( name , contracts , libraries = dict ( ) , constructor_parameters = None , contract_path = contract_path ) [EOL] [EOL] return contract_proxy [EOL] [EOL] [EOL] def get_list_of_block_numbers ( item ) : [EOL] [docstring] [EOL] if isinstance ( item , list ) : [EOL] return [ element [ [string] ] for element in item ] [EOL] [EOL] if isinstance ( item , dict ) : [EOL] block_number = item [ [string] ] [EOL] return [ block_number ] [EOL] [EOL] return list ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.network.rpc.smartcontract_proxy.ContractProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.List[raiden.utils.typing.TokenAddress]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Tuple[raiden.network.proxies.service_registry.ServiceRegistry,raiden.utils.typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import gevent [EOL] from gevent . event import AsyncResult [EOL] [EOL] [EOL] def raise_on_failure ( raiden_apps , test_function , ** kwargs ) : [EOL] [docstring] [EOL] result = AsyncResult ( ) [EOL] [EOL] for app in raiden_apps : [EOL] assert app . raiden [EOL] app . raiden . link ( result ) [EOL] [EOL] gevent . spawn ( test_function , ** kwargs ) . link ( result ) [EOL] result . get ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from eth_utils import denoms [EOL] [EOL] DEFAULT_PASSPHRASE = [string] [comment] [EOL] [EOL] DEFAULT_BALANCE = denoms . ether * [number] [comment] [EOL] DEFAULT_BALANCE_BIN = str ( DEFAULT_BALANCE ) [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0
	0
[comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import random [EOL] from enum import Enum [EOL] [EOL] import pytest [EOL] from eth_utils import remove_0x_prefix [EOL] [EOL] from raiden . constants import RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT , Environment [EOL] from raiden . network . utils import get_free_port [EOL] from raiden . settings import ( DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS , DEFAULT_RETRY_TIMEOUT , DEFAULT_TRANSPORT_THROTTLE_CAPACITY , DEFAULT_TRANSPORT_THROTTLE_FILL_RATE , ) [EOL] from raiden . tests . utils . factories import UNIT_CHAIN_ID [EOL] from raiden . utils import sha3 [EOL] from raiden_contracts . constants import TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] DUPLICATED_BRACKETS = str . maketrans ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] [EOL] class TransportProtocol ( Enum ) : [EOL] UDP = [string] [EOL] MATRIX = [string] [EOL] [EOL] [EOL] def escape_for_format ( string ) : [EOL] [docstring] [EOL] return string . translate ( DUPLICATED_BRACKETS ) [EOL] [EOL] [EOL] @ pytest . fixture def settle_timeout ( reveal_timeout ) : [EOL] [docstring] [EOL] return reveal_timeout * [number] [EOL] [EOL] [EOL] @ pytest . fixture def chain_id ( ) : [EOL] [comment] [EOL] return UNIT_CHAIN_ID [EOL] [EOL] [EOL] @ pytest . fixture def settle_timeout_min ( ) : [EOL] return TEST_SETTLE_TIMEOUT_MIN [EOL] [EOL] [EOL] @ pytest . fixture def settle_timeout_max ( ) : [EOL] return TEST_SETTLE_TIMEOUT_MAX [EOL] [EOL] [EOL] @ pytest . fixture def reveal_timeout ( number_of_nodes ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return number_of_nodes * [number] + DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS [EOL] [EOL] [EOL] @ pytest . fixture def retry_timeout ( ) : [EOL] return DEFAULT_RETRY_TIMEOUT [EOL] [EOL] [EOL] @ pytest . fixture def random_marker ( ) : [EOL] [docstring] [EOL] random_hex = hex ( random . getrandbits ( [number] ) ) [EOL] return remove_0x_prefix ( random_hex ) [EOL] [EOL] [EOL] @ pytest . fixture def deposit ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def number_of_tokens ( ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def register_tokens ( ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] [EOL] @ pytest . fixture def number_of_nodes ( ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def channels_per_node ( ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def retry_interval ( transport_protocol ) : [EOL] if transport_protocol is TransportProtocol . MATRIX : [EOL] return [number] [EOL] else : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def retries_before_backoff ( ) : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def throttle_capacity ( ) : [EOL] return DEFAULT_TRANSPORT_THROTTLE_CAPACITY [EOL] [EOL] [EOL] @ pytest . fixture def throttle_fill_rate ( ) : [EOL] return DEFAULT_TRANSPORT_THROTTLE_FILL_RATE [EOL] [EOL] [EOL] @ pytest . fixture def nat_invitation_timeout ( ) : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def nat_keepalive_retries ( ) : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def nat_keepalive_timeout ( ) : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def privatekey_seed ( request ) : [EOL] [docstring] [EOL] return escape_for_format ( request . node . name ) + [string] [EOL] [EOL] [EOL] @ pytest . fixture def token_amount ( number_of_nodes ) : [EOL] total_per_node = RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT * [number] [EOL] total_token = total_per_node * number_of_nodes [EOL] return total_token [EOL] [EOL] [EOL] @ pytest . fixture def network_wait ( ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def private_keys ( number_of_nodes , privatekey_seed ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] result = [ sha3 ( privatekey_seed . format ( position ) . encode ( ) ) for position in range ( number_of_nodes ) ] [EOL] [EOL] [comment] [EOL] assert len ( set ( result ) ) == number_of_nodes , [string] [EOL] [EOL] return result [EOL] [EOL] [EOL] @ pytest . fixture def deploy_key ( privatekey_seed ) : [EOL] return sha3 ( privatekey_seed . format ( [string] ) . encode ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def blockchain_type ( request ) : [EOL] return request . config . option . blockchain_type [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_extra_config ( ) : [EOL] return { } [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_number_of_nodes ( ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_key_seed ( request ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return escape_for_format ( request . node . name ) + [string] [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_private_keys ( blockchain_number_of_nodes , blockchain_key_seed ) : [EOL] [docstring] [EOL] return [ sha3 ( blockchain_key_seed . format ( position ) . encode ( ) ) for position in range ( blockchain_number_of_nodes ) ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def port_generator ( request ) : [EOL] [docstring] [EOL] return get_free_port ( request . config . getoption ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_rpc_ports ( blockchain_number_of_nodes , port_generator ) : [EOL] [docstring] [EOL] return [ next ( port_generator ) for _ in range ( blockchain_number_of_nodes ) ] [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_p2p_ports ( blockchain_number_of_nodes , port_generator ) : [EOL] [docstring] [EOL] return [ next ( port_generator ) for _ in range ( blockchain_number_of_nodes ) ] [EOL] [EOL] [EOL] @ pytest . fixture def raiden_udp_ports ( number_of_nodes , port_generator ) : [EOL] [docstring] [EOL] return [ next ( port_generator ) for _ in range ( number_of_nodes ) ] [EOL] [EOL] [EOL] @ pytest . fixture def rest_api_port_number ( port_generator ) : [EOL] [docstring] [EOL] return next ( port_generator ) [EOL] [EOL] [EOL] @ pytest . fixture def environment_type ( ) : [EOL] [docstring] [EOL] return Environment . DEVELOPMENT [EOL] [EOL] [EOL] @ pytest . fixture def unrecoverable_error_should_crash ( ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] [EOL] @ pytest . fixture def transport ( request ) : [EOL] [docstring] [EOL] return request . config . getoption ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def transport_protocol ( transport ) : [EOL] return TransportProtocol ( transport ) [EOL] [EOL] [EOL] @ pytest . fixture def skip_if_not_udp ( request ) : [EOL] [docstring] [EOL] if request . config . option . transport in ( [string] , [string] ) : [EOL] return [EOL] pytest . skip ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def skip_if_not_matrix ( request ) : [EOL] [docstring] [EOL] if request . config . option . transport in ( [string] , [string] ) : [EOL] return [EOL] pytest . skip ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def skip_if_parity ( blockchain_type ) : [EOL] [docstring] [EOL] if blockchain_type == [string] : [EOL] pytest . skip ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def skip_if_not_parity ( blockchain_type ) : [EOL] [docstring] [EOL] if blockchain_type != [string] : [EOL] pytest . skip ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def skip_if_not_geth ( blockchain_type ) : [EOL] [docstring] [EOL] if blockchain_type != [string] : [EOL] pytest . skip ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def override_capture_setting_for_hypothesis_tests ( request ) : [EOL] [docstring] [EOL] request . config . option . showcapture = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from raiden . constants import EthClient [EOL] from raiden . network . rpc . smartcontract_proxy import ClientErrorInspectResult , inspect_client_error [EOL] [EOL] [EOL] def test_inspect_client_error ( ) : [EOL] [docstring] [EOL] errorstr = ( [string] [string] ) [EOL] exception = ValueError ( errorstr ) [EOL] [EOL] result = inspect_client_error ( exception , EthClient . PARITY ) [EOL] assert result == ClientErrorInspectResult . ALWAYS_FAIL [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import pathlib [EOL] import unittest [EOL] import typing [EOL] import raiden [EOL] import json [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from unittest . mock import ANY , Mock , patch [EOL] [EOL] import raiden . utils . upgrades [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . tests . utils . migrations import create_fake_web3_for_block_hash [EOL] from raiden . utils . upgrades import VERSION_RE , UpgradeManager , UpgradeRecord , get_db_version [EOL] [EOL] [EOL] def test_version_regex ( ) : [EOL] assert VERSION_RE . match ( [string] ) [EOL] assert VERSION_RE . match ( [string] ) [EOL] assert VERSION_RE . match ( [string] ) [EOL] [EOL] assert not VERSION_RE . match ( [string] ) [EOL] assert not VERSION_RE . match ( [string] ) [EOL] assert not VERSION_RE . match ( [string] ) [EOL] assert not VERSION_RE . match ( [string] ) [EOL] assert not VERSION_RE . match ( [string] ) [EOL] assert not VERSION_RE . match ( [string] ) [EOL] assert not VERSION_RE . match ( [string] ) [EOL] [EOL] [EOL] def setup_storage ( db_path ) : [EOL] [comment] [EOL] state_changes_file = Path ( __file__ ) . parent / [string] [EOL] state_changes_data = json . loads ( state_changes_file . read_text ( ) ) [EOL] action_init_chain_data = json . dumps ( state_changes_data [ [number] ] [ [number] ] ) [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] storage . write_state_change ( state_change = action_init_chain_data , log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) , ) [EOL] return storage [EOL] [EOL] [EOL] def test_no_upgrade_executes_if_already_upgraded ( tmp_path ) : [EOL] [comment] [EOL] for version in [ [number] , [number] , [number] , [number] ] : [EOL] old_db_filename = tmp_path / Path ( f" [string] { version } [string] " ) [EOL] [EOL] with patch ( [string] , new = version ) : [EOL] storage = setup_storage ( old_db_filename ) [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] db_path = tmp_path / Path ( [string] ) [EOL] [EOL] with patch ( [string] ) as upgrade_mock : [EOL] with patch ( [string] , new = version ) : [EOL] UpgradeManager ( db_filename = db_path ) . run ( ) [EOL] [comment] [EOL] assert not upgrade_mock . called [EOL] [EOL] [EOL] def test_upgrade_executes_necessary_migration_functions ( tmp_path , monkeypatch ) : [EOL] old_db_filename = tmp_path / Path ( f" [string] " ) [EOL] [EOL] storage = setup_storage ( old_db_filename ) [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] db_path = tmp_path / Path ( [string] ) [EOL] [EOL] upgrade_functions = [ ] [EOL] for i in range ( [number] , [number] ) : [EOL] mock = Mock ( ) [EOL] mock . return_value = i + [number] [EOL] upgrade_functions . append ( UpgradeRecord ( from_version = i , function = mock ) ) [EOL] [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( raiden . utils . upgrades , [string] , upgrade_functions ) [EOL] m . setattr ( raiden . utils . upgrades , [string] , [number] ) [EOL] [EOL] UpgradeManager ( db_filename = db_path ) . run ( ) [EOL] [EOL] assert upgrade_functions [ [number] ] . function . call_count == [number] [EOL] assert upgrade_functions [ [number] ] . function . call_count == [number] [EOL] assert upgrade_functions [ [number] ] . function . call_count == [number] [EOL] assert upgrade_functions [ [number] ] . function . call_count == [number] [EOL] [EOL] [EOL] def test_upgrade_manager_restores_backup ( tmp_path , monkeypatch ) : [EOL] db_path = tmp_path / Path ( [string] ) [EOL] [EOL] old_db_filename = tmp_path / Path ( [string] ) [EOL] [EOL] storage = setup_storage ( old_db_filename ) [EOL] [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] upgrade_functions = [ UpgradeRecord ( from_version = [number] , function = Mock ( ) ) ] [EOL] [EOL] upgrade_functions [ [number] ] . function . return_value = [number] [EOL] [EOL] web3 , _ = create_fake_web3_for_block_hash ( number_of_blocks = [number] ) [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( raiden . utils . upgrades , [string] , upgrade_functions ) [EOL] m . setattr ( raiden . utils . upgrades , [string] , [number] ) [EOL] UpgradeManager ( db_filename = db_path , web3 = web3 ) . run ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] state_change_record = storage . get_latest_state_change_by_data_field ( { [string] : [string] } ) [EOL] assert state_change_record . data is not None [EOL] [EOL] [EOL] def test_sequential_version_numbers ( tmp_path , monkeypatch ) : [EOL] [docstring] [EOL] db_path = tmp_path / Path ( [string] ) [EOL] [EOL] old_db_filename = tmp_path / Path ( [string] ) [EOL] [EOL] upgrade_functions = [ ] [EOL] for i in range ( [number] , [number] ) : [EOL] mock = Mock ( ) [EOL] mock . return_value = i + [number] [EOL] upgrade_functions . append ( UpgradeRecord ( from_version = i , function = mock ) ) [EOL] [EOL] with patch ( [string] , new = [number] ) : [EOL] storage = setup_storage ( old_db_filename ) [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] with monkeypatch . context ( ) as m : [EOL] [EOL] def latest_db_file ( paths ) : [comment] [EOL] return old_db_filename [EOL] [EOL] m . setattr ( raiden . utils . upgrades , [string] , upgrade_functions ) [EOL] m . setattr ( raiden . utils . upgrades , [string] , [number] ) [EOL] m . setattr ( raiden . utils . upgrades , [string] , latest_db_file ) [EOL] [EOL] UpgradeManager ( db_filename = db_path ) . run ( ) [EOL] [EOL] upgrade_functions [ [number] ] . function . assert_called_once_with ( old_version = [number] , current_version = [number] , storage = ANY ) [EOL] upgrade_functions [ [number] ] . function . assert_called_once_with ( old_version = [number] , current_version = [number] , storage = ANY ) [EOL] upgrade_functions [ [number] ] . function . assert_called_once_with ( old_version = [number] , current_version = [number] , storage = ANY ) [EOL] [EOL] assert get_db_version ( db_path ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] from eth_utils import encode_hex [EOL] [EOL] from raiden . accounts import AccountManager [EOL] from raiden . ui . prompt import unlock_account_with_passwordfile [EOL] from raiden . utils import get_project_root [EOL] [EOL] KEYFILE_INACCESSIBLE = [string] [EOL] KEYFILE_INVALID = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def keystore_mock ( ) : [EOL] keystore = os . path . join ( get_project_root ( ) , [string] , [string] ) [EOL] [comment] [EOL] inaccessible_file = os . path . join ( keystore , KEYFILE_INACCESSIBLE ) [EOL] if not os . path . exists ( inaccessible_file ) : [EOL] open ( inaccessible_file , [string] ) . close ( ) [EOL] os . chmod ( inaccessible_file , [number] ) [EOL] yield keystore [EOL] [comment] [EOL] os . chmod ( inaccessible_file , [number] ) [EOL] os . unlink ( inaccessible_file ) [EOL] [EOL] [EOL] def test_get_accounts ( keystore_mock ) : [EOL] account_manager = AccountManager ( keystore_mock ) [EOL] expected_accounts = { [string] : os . path . join ( keystore_mock , [string] , ) , [string] : os . path . join ( keystore_mock , [string] ) , } [EOL] assert expected_accounts == account_manager . accounts [EOL] [EOL] [EOL] def test_get_account_in_keystore ( keystore_mock ) : [EOL] account_manager = AccountManager ( keystore_mock ) [EOL] assert account_manager . address_in_keystore ( [string] ) [EOL] assert account_manager . address_in_keystore ( [string] ) [EOL] assert account_manager . address_in_keystore ( [string] ) [EOL] assert account_manager . address_in_keystore ( [string] ) [EOL] assert account_manager . address_in_keystore ( [string] ) [EOL] assert not account_manager . address_in_keystore ( [string] ) [EOL] [EOL] [EOL] def test_get_privkey ( keystore_mock ) : [EOL] account_manager = AccountManager ( keystore_mock ) [EOL] assert [string] == encode_hex ( account_manager . get_privkey ( [string] , [string] ) ) [EOL] assert [string] == encode_hex ( account_manager . get_privkey ( [string] , [string] ) ) [EOL] assert [string] == encode_hex ( account_manager . get_privkey ( [string] , [string] ) ) [EOL] assert [string] == encode_hex ( account_manager . get_privkey ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exc : [EOL] account_manager . get_privkey ( [string] , [string] ) [EOL] assert [string] in str ( exc . value ) [EOL] with pytest . raises ( ValueError ) as exc : [EOL] account_manager . get_privkey ( [string] , [string] ) [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] def test_account_manager_invalid_files ( keystore_mock , caplog ) : [EOL] with caplog . at_level ( logging . DEBUG ) : [EOL] AccountManager ( keystore_mock ) [EOL] [EOL] logs = [ ( [string] , KEYFILE_INVALID , [string] , ) , ( [string] , KEYFILE_INACCESSIBLE , [string] ) , ] [EOL] [EOL] for msg , file_name , reason in logs : [EOL] for record in caplog . records : [EOL] message = record . getMessage ( ) [EOL] if msg in message and file_name in message and reason in message : [EOL] break [EOL] else : [EOL] assert False , [string] . format ( msg ) [EOL] [EOL] [EOL] def test_account_manager_invalid_directory ( caplog ) : [EOL] with patch . object ( os , [string] ) as mock_listdir : [EOL] mock_listdir . side_effect = OSError [EOL] AccountManager ( [string] ) [EOL] [EOL] logs = [ ( [string] , [string] , [string] ) ] [EOL] [EOL] for msg , path , reason in logs : [EOL] for record in caplog . records : [EOL] message = record . getMessage ( ) [EOL] if msg in message and path in message and reason in message : [EOL] break [EOL] else : [EOL] assert False , [string] . format ( msg ) [EOL] [EOL] [EOL] def test_unlock_account_with_passwordfile ( keystore_mock ) : [EOL] account_manager = AccountManager ( keystore_mock ) [EOL] password_file_path = os . path . join ( keystore_mock , [string] ) [EOL] [EOL] with open ( password_file_path , [string] ) as password_file : [EOL] privkey = unlock_account_with_passwordfile ( account_manager = account_manager , address_hex = [string] , password_file = password_file , ) [EOL] assert privkey [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] from copy import deepcopy [EOL] from typing import Any , Dict [EOL] [EOL] import pytest [EOL] from gevent import server [EOL] [EOL] from raiden . app import App [EOL] from raiden . constants import Environment , RoutingMode [EOL] from raiden . network . transport import UDPTransport [EOL] from raiden . tests . utils . factories import make_address [EOL] from raiden . tests . utils . mocks import MockChain , MockWeb3 , patched_get_for_succesful_pfs_info [EOL] from raiden . ui . checks import check_ethereum_network_id [EOL] from raiden . ui . startup import ( setup_contracts_or_exit , setup_environment , setup_proxies_or_exit , setup_udp_or_exit , ) [EOL] from raiden_contracts . constants import ( CONTRACT_ENDPOINT_REGISTRY , CONTRACT_SECRET_REGISTRY , CONTRACT_SERVICE_REGISTRY , CONTRACT_TOKEN_NETWORK_REGISTRY , CONTRACT_USER_DEPOSIT , ) [EOL] [EOL] [EOL] def test_check_network_id_raises_with_mismatching_ids ( ) : [EOL] check_ethereum_network_id ( [number] , MockWeb3 ( [number] ) ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] check_ethereum_network_id ( [number] , MockWeb3 ( [number] ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) def test_setup_does_not_raise_with_matching_ids ( netid ) : [EOL] [docstring] [EOL] check_ethereum_network_id ( netid , MockWeb3 ( netid ) ) [EOL] [EOL] [EOL] def test_setup_environment ( ) : [EOL] [comment] [EOL] config = deepcopy ( App . DEFAULT_CONFIG ) [EOL] setup_environment ( config , Environment . DEVELOPMENT ) [EOL] assert config [ [string] ] == Environment . DEVELOPMENT [EOL] [EOL] [comment] [EOL] config = deepcopy ( App . DEFAULT_CONFIG ) [EOL] setup_environment ( config , Environment . PRODUCTION ) [EOL] assert config [ [string] ] == Environment . PRODUCTION [EOL] assert config [ [string] ] [ [string] ] [ [string] ] is True [EOL] [EOL] [EOL] def raiden_contracts_in_data ( contracts ) : [EOL] return ( CONTRACT_SECRET_REGISTRY in contracts [EOL] and CONTRACT_TOKEN_NETWORK_REGISTRY in contracts [EOL] and CONTRACT_ENDPOINT_REGISTRY in contracts ) [EOL] [EOL] [EOL] def service_contracts_in_data ( contracts ) : [EOL] return CONTRACT_SERVICE_REGISTRY in contracts and CONTRACT_USER_DEPOSIT in contracts [EOL] [EOL] [EOL] def test_setup_contracts ( ) : [EOL] [comment] [EOL] config = { [string] : Environment . PRODUCTION } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert not service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . DEVELOPMENT } [EOL] with pytest . raises ( SystemExit ) : [EOL] setup_contracts_or_exit ( config , [number] ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . PRODUCTION } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert not service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . DEVELOPMENT } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . PRODUCTION } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert not service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . DEVELOPMENT } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . DEVELOPMENT } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . PRODUCTION } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert not service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . DEVELOPMENT } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert raiden_contracts_in_data ( contracts ) [EOL] assert service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . PRODUCTION } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert not raiden_contracts_in_data ( contracts ) [EOL] assert not service_contracts_in_data ( contracts ) [EOL] [EOL] [comment] [EOL] config = { [string] : Environment . DEVELOPMENT } [EOL] contracts = setup_contracts_or_exit ( config , [number] ) [EOL] assert [string] in config [EOL] assert not raiden_contracts_in_data ( contracts ) [EOL] assert not service_contracts_in_data ( contracts ) [EOL] [EOL] [EOL] def test_setup_proxies_raiden_addresses_are_given ( ) : [EOL] [docstring] [EOL] [EOL] network_id = [number] [EOL] config = { [string] : Environment . DEVELOPMENT , [string] : network_id , [string] : { } } [EOL] contracts = { } [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [EOL] proxies = setup_proxies_or_exit ( config = config , tokennetwork_registry_contract_address = make_address ( ) , secret_registry_contract_address = make_address ( ) , endpoint_registry_contract_address = make_address ( ) , user_deposit_contract_address = None , service_registry_contract_address = None , blockchain_service = blockchain_service , contracts = contracts , routing_mode = RoutingMode . BASIC , pathfinding_service_address = None , ) [EOL] assert proxies [EOL] assert proxies . token_network_registry [EOL] assert proxies . secret_registry [EOL] assert not proxies . user_deposit [EOL] assert not proxies . service_registry [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ RoutingMode . PFS , RoutingMode . BASIC ] ) def test_setup_proxies_all_addresses_are_given ( routing_mode ) : [EOL] [docstring] [EOL] [EOL] network_id = [number] [EOL] config = { [string] : Environment . DEVELOPMENT , [string] : network_id , [string] : { } } [EOL] contracts = { } [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [EOL] with patched_get_for_succesful_pfs_info ( ) : [EOL] proxies = setup_proxies_or_exit ( config = config , tokennetwork_registry_contract_address = make_address ( ) , secret_registry_contract_address = make_address ( ) , endpoint_registry_contract_address = make_address ( ) , user_deposit_contract_address = make_address ( ) , service_registry_contract_address = make_address ( ) , blockchain_service = blockchain_service , contracts = contracts , routing_mode = routing_mode , pathfinding_service_address = [string] , ) [EOL] assert proxies [EOL] assert proxies . token_network_registry [EOL] assert proxies . secret_registry [EOL] assert proxies . user_deposit [EOL] assert proxies . service_registry [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ RoutingMode . PFS , RoutingMode . BASIC ] ) def test_setup_proxies_all_addresses_are_known ( routing_mode ) : [EOL] [docstring] [EOL] [EOL] network_id = [number] [EOL] config = { [string] : Environment . DEVELOPMENT , [string] : network_id , [string] : { } } [EOL] contracts = setup_contracts_or_exit ( config , network_id ) [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [EOL] with patched_get_for_succesful_pfs_info ( ) : [EOL] proxies = setup_proxies_or_exit ( config = config , tokennetwork_registry_contract_address = None , secret_registry_contract_address = None , endpoint_registry_contract_address = None , user_deposit_contract_address = None , service_registry_contract_address = None , blockchain_service = blockchain_service , contracts = contracts , routing_mode = routing_mode , pathfinding_service_address = [string] , ) [EOL] assert proxies [EOL] assert proxies . token_network_registry [EOL] assert proxies . secret_registry [EOL] assert proxies . user_deposit [EOL] assert proxies . service_registry [EOL] [EOL] [EOL] def test_setup_proxies_no_service_registry_but_pfs ( ) : [EOL] [docstring] [EOL] [EOL] network_id = [number] [EOL] config = { [string] : Environment . DEVELOPMENT , [string] : network_id , [string] : { } } [EOL] contracts = { } [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [EOL] with patched_get_for_succesful_pfs_info ( ) : [EOL] proxies = setup_proxies_or_exit ( config = config , tokennetwork_registry_contract_address = make_address ( ) , secret_registry_contract_address = make_address ( ) , endpoint_registry_contract_address = make_address ( ) , user_deposit_contract_address = make_address ( ) , service_registry_contract_address = None , blockchain_service = blockchain_service , contracts = contracts , routing_mode = RoutingMode . PFS , pathfinding_service_address = [string] , ) [EOL] assert proxies [EOL] [EOL] [EOL] def test_setup_proxies_no_service_registry_and_no_pfs_address_but_requesting_pfs ( ) : [EOL] [docstring] [EOL] [EOL] network_id = [number] [EOL] config = { [string] : Environment . DEVELOPMENT , [string] : network_id , [string] : { } } [EOL] contracts = { } [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] with patched_get_for_succesful_pfs_info ( ) : [EOL] setup_proxies_or_exit ( config = config , tokennetwork_registry_contract_address = make_address ( ) , secret_registry_contract_address = make_address ( ) , endpoint_registry_contract_address = make_address ( ) , user_deposit_contract_address = make_address ( ) , service_registry_contract_address = None , blockchain_service = blockchain_service , contracts = contracts , routing_mode = RoutingMode . PFS , pathfinding_service_address = None , ) [EOL] [EOL] [EOL] def test_setup_udp_or_exit ( raiden_udp_ports ) : [EOL] network_id = [number] [EOL] config = deepcopy ( App . DEFAULT_CONFIG ) [EOL] config [ [string] ] = network_id [EOL] config [ [string] ] = Environment . DEVELOPMENT [EOL] host = [string] [EOL] port = raiden_udp_ports [ [number] ] [EOL] config [ [string] ] = server . _udp_socket ( ( host , port ) ) [comment] [EOL] contracts = { } [EOL] our_address = make_address ( ) [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [comment] [EOL] blockchain_service . client . balances_mapping [ our_address ] = [number] [EOL] transport , discovery = setup_udp_or_exit ( config = config , blockchain_service = blockchain_service , address = our_address , contracts = contracts , endpoint_registry_contract_address = make_address ( ) , ) [EOL] assert isinstance ( transport , UDPTransport ) [EOL] assert discovery [EOL] [EOL] [EOL] def test_setup_udp_or_exit_insufficient_balance ( ) : [EOL] network_id = [number] [EOL] config = deepcopy ( App . DEFAULT_CONFIG ) [EOL] config [ [string] ] = network_id [EOL] config [ [string] ] = Environment . DEVELOPMENT [EOL] contracts = { } [EOL] our_address = make_address ( ) [EOL] blockchain_service = MockChain ( network_id = network_id , node_address = make_address ( ) ) [EOL] [comment] [EOL] blockchain_service . client . balances_mapping [ our_address ] = [number] [EOL] with pytest . raises ( SystemExit ) : [EOL] setup_udp_or_exit ( config = config , blockchain_service = blockchain_service , address = our_address , contracts = contracts , endpoint_registry_contract_address = make_address ( ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Type , Dict , List [EOL] import typing [EOL] import raiden [EOL] import random [EOL] from collections import namedtuple [EOL] from copy import deepcopy [EOL] from itertools import cycle [EOL] [EOL] import pytest [EOL] [EOL] from raiden . constants import EMPTY_MERKLE_ROOT , UINT64_MAX [EOL] from raiden . messages import Unlock [EOL] from raiden . settings import DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS [EOL] from raiden . tests . utils . events import search_for_item [EOL] from raiden . tests . utils . factories import ( HOP1 , UNIT_CHAIN_ID , UNIT_TRANSFER_SENDER , BalanceProofProperties , LockedTransferSignedStateProperties , LockedTransferUnsignedStateProperties , NettingChannelEndStateProperties , NettingChannelStateProperties , TransactionExecutionStatusProperties , create , make_32bytes , make_address , make_block_hash , make_canonical_identifier , make_payment_network_identifier , make_privkey_address , make_secret , make_signed_balance_proof_from_unsigned , make_transaction_hash , replace , ) [EOL] from raiden . tests . utils . transfer import make_receive_expired_lock , make_receive_transfer_mediated [EOL] from raiden . transfer import channel [EOL] from raiden . transfer . events import ( ContractSendChannelBatchUnlock , ContractSendChannelUpdateTransfer , ) [EOL] from raiden . transfer . mediated_transfer . state_change import ReceiveLockExpired [EOL] from raiden . transfer . merkle_tree import ( LEAVES , MERKLEROOT , compute_layers , merkle_leaves_from_packed_data , merkleroot , ) [EOL] from raiden . transfer . state import ( CHANNEL_STATE_CLOSING , HashTimeLockState , MerkleTreeState , NettingChannelEndState , NettingChannelState , TransactionChannelNewBalance , TransactionExecutionStatus , UnlockPartialProofState , balanceproof_from_envelope , make_empty_merkle_tree , ) [EOL] from raiden . transfer . state_change import ( ActionChannelClose , Block , ContractReceiveChannelClosed , ContractReceiveChannelNewBalance , ContractReceiveChannelSettled , ContractReceiveUpdateTransfer , ReceiveUnlock , ) [EOL] from raiden . utils import random_secret , sha3 [EOL] from raiden . utils . signer import LocalSigner [EOL] [EOL] PartnerStateModel = namedtuple ( [string] , ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) , ) [EOL] [EOL] [EOL] def assert_partner_state ( end_state , partner_state , model ) : [EOL] [docstring] [EOL] assert end_state . address == model . participant_address [EOL] assert channel . get_amount_locked ( end_state ) == model . amount_locked [EOL] assert channel . get_balance ( end_state , partner_state ) == model . balance [EOL] assert channel . get_distributable ( end_state , partner_state ) == model . distributable [EOL] assert channel . get_next_nonce ( end_state ) == model . next_nonce [EOL] assert set ( end_state . merkletree . layers [ LEAVES ] ) == set ( model . merkletree_leaves ) [EOL] assert end_state . contract_balance == model . contract_balance [EOL] [EOL] [EOL] def create_model ( balance , merkletree_width = [number] ) : [EOL] privkey , address = make_privkey_address ( ) [EOL] [EOL] merkletree_leaves = [ random_secret ( ) for _ in range ( merkletree_width ) ] [EOL] [EOL] our_model = PartnerStateModel ( participant_address = address , amount_locked = [number] , balance = balance , distributable = balance , next_nonce = len ( merkletree_leaves ) + [number] , merkletree_leaves = merkletree_leaves , contract_balance = balance , ) [EOL] [EOL] return our_model , privkey [EOL] [EOL] [EOL] def create_channel_from_models ( our_model , partner_model , partner_pkey ) : [EOL] [docstring] [EOL] channel_state = create ( NettingChannelStateProperties ( reveal_timeout = [number] , settle_timeout = [number] , our_state = NettingChannelEndStateProperties ( address = our_model . participant_address , balance = our_model . balance , merkletree_leaves = our_model . merkletree_leaves , ) , partner_state = NettingChannelEndStateProperties ( address = partner_model . participant_address , balance = partner_model . balance , merkletree_leaves = partner_model . merkletree_leaves , ) , open_transaction = TransactionExecutionStatusProperties ( finished_block_number = [number] ) , ) ) [EOL] [EOL] our_nonce = our_model . next_nonce - [number] [EOL] assert our_nonce >= [number] , [string] [EOL] if our_nonce > [number] : [EOL] our_unsigned = create ( BalanceProofProperties ( nonce = our_nonce , transferred_amount = [number] , locked_amount = len ( our_model . merkletree_leaves ) , locksroot = merkleroot ( channel_state . our_state . merkletree ) , canonical_identifier = channel_state . canonical_identifier , ) ) [EOL] else : [EOL] our_unsigned = None [EOL] [EOL] partner_nonce = partner_model . next_nonce - [number] [EOL] assert partner_nonce >= [number] , [string] [EOL] if partner_nonce > [number] : [EOL] partner_unsigned = create ( BalanceProofProperties ( nonce = partner_nonce , transferred_amount = [number] , locked_amount = len ( partner_model . merkletree_leaves ) , locksroot = merkleroot ( channel_state . partner_state . merkletree ) , canonical_identifier = channel_state . canonical_identifier , ) ) [EOL] [EOL] partner_signed = make_signed_balance_proof_from_unsigned ( partner_unsigned , LocalSigner ( partner_pkey ) ) [EOL] else : [EOL] partner_signed = None [EOL] [EOL] channel_state . our_state . balance_proof = our_unsigned [EOL] channel_state . partner_state . balance_proof = partner_signed [EOL] [EOL] assert channel_state . our_total_deposit == our_model . contract_balance [EOL] assert channel_state . partner_total_deposit == partner_model . contract_balance [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model ) [EOL] [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model ) [EOL] [EOL] return channel_state [EOL] [EOL] [EOL] def test_new_end_state ( ) : [EOL] [docstring] [EOL] balance1 = [number] [EOL] node_address = make_address ( ) [EOL] end_state = NettingChannelEndState ( node_address , balance1 ) [EOL] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] [EOL] assert channel . is_lock_pending ( end_state , lock_secrethash ) is False [EOL] assert channel . is_lock_locked ( end_state , lock_secrethash ) is False [EOL] assert channel . get_next_nonce ( end_state ) == [number] [EOL] assert channel . get_amount_locked ( end_state ) == [number] [EOL] assert merkleroot ( end_state . merkletree ) == EMPTY_MERKLE_ROOT [EOL] [EOL] assert not end_state . secrethashes_to_lockedlocks [EOL] assert not end_state . secrethashes_to_unlockedlocks [EOL] assert not end_state . secrethashes_to_onchain_unlockedlocks [EOL] [EOL] [EOL] def test_endstate_update_contract_balance ( ) : [EOL] [docstring] [EOL] balance1 = [number] [EOL] node_address = make_address ( ) [EOL] [EOL] end_state = NettingChannelEndState ( node_address , balance1 ) [EOL] assert end_state . contract_balance == balance1 [EOL] [EOL] channel . update_contract_balance ( end_state , balance1 - [number] ) [EOL] assert end_state . contract_balance == balance1 [EOL] [EOL] channel . update_contract_balance ( end_state , balance1 + [number] ) [EOL] assert end_state . contract_balance == balance1 + [number] [EOL] [EOL] [EOL] def test_channelstate_update_contract_balance ( ) : [EOL] [docstring] [EOL] deposit_block_number = [number] [EOL] block_number = deposit_block_number + DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS + [number] [EOL] block_hash = make_block_hash ( ) [EOL] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_pkey1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_pkey1 ) [EOL] [EOL] deposit_amount = [number] [EOL] balance1_new = our_model1 . balance + deposit_amount [EOL] [EOL] deposit_transaction = TransactionChannelNewBalance ( our_model1 . participant_address , balance1_new , deposit_block_number ) [EOL] state_change = ContractReceiveChannelNewBalance ( transaction_hash = make_transaction_hash ( ) , canonical_identifier = channel_state . canonical_identifier , deposit_transaction = deposit_transaction , block_number = block_number , block_hash = block_hash , ) [EOL] [EOL] iteration = channel . state_transition ( channel_state = deepcopy ( channel_state ) , state_change = state_change , block_number = block_number , block_hash = block_hash , ) [EOL] new_state = iteration . new_state [EOL] [EOL] our_model2 = our_model1 . _replace ( balance = balance1_new , distributable = balance1_new , contract_balance = balance1_new ) [EOL] partner_model2 = partner_model1 [EOL] [EOL] assert_partner_state ( new_state . our_state , new_state . partner_state , our_model2 ) [EOL] assert_partner_state ( new_state . partner_state , new_state . our_state , partner_model2 ) [EOL] [EOL] [EOL] def test_channelstate_decreasing_contract_balance ( ) : [EOL] [docstring] [EOL] deposit_block_number = [number] [EOL] block_number = deposit_block_number + DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS + [number] [EOL] deposit_block_hash = make_block_hash ( ) [EOL] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_pkey1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_pkey1 ) [EOL] [EOL] amount = [number] [EOL] balance1_new = our_model1 . balance - amount [EOL] [EOL] deposit_transaction = TransactionChannelNewBalance ( our_model1 . participant_address , balance1_new , deposit_block_number ) [EOL] state_change = ContractReceiveChannelNewBalance ( transaction_hash = make_transaction_hash ( ) , canonical_identifier = channel_state . canonical_identifier , deposit_transaction = deposit_transaction , block_number = deposit_block_number , block_hash = deposit_block_hash , ) [EOL] [EOL] iteration = channel . state_transition ( channel_state = deepcopy ( channel_state ) , state_change = state_change , block_number = block_number , block_hash = make_block_hash ( ) , ) [EOL] new_state = iteration . new_state [EOL] [EOL] assert_partner_state ( new_state . our_state , new_state . partner_state , our_model1 ) [EOL] assert_partner_state ( new_state . partner_state , new_state . our_state , partner_model1 ) [EOL] [EOL] [EOL] def test_channelstate_repeated_contract_balance ( ) : [EOL] [docstring] [EOL] deposit_block_number = [number] [EOL] block_number = deposit_block_number + DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS + [number] [EOL] deposit_block_hash = make_block_hash ( ) [EOL] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_pkey1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_pkey1 ) [EOL] [EOL] deposit_amount = [number] [EOL] balance1_new = our_model1 . balance + deposit_amount [EOL] [EOL] deposit_transaction = TransactionChannelNewBalance ( our_model1 . participant_address , balance1_new , deposit_block_number ) [EOL] state_change = ContractReceiveChannelNewBalance ( transaction_hash = make_transaction_hash ( ) , canonical_identifier = channel_state . canonical_identifier , deposit_transaction = deposit_transaction , block_number = deposit_block_number , block_hash = deposit_block_hash , ) [EOL] [EOL] our_model2 = our_model1 . _replace ( balance = balance1_new , distributable = balance1_new , contract_balance = balance1_new ) [EOL] partner_model2 = partner_model1 [EOL] [EOL] for _ in range ( [number] ) : [EOL] iteration = channel . state_transition ( channel_state = deepcopy ( channel_state ) , state_change = state_change , block_number = block_number , block_hash = make_block_hash ( ) , ) [EOL] new_state = iteration . new_state [EOL] [EOL] assert_partner_state ( new_state . our_state , new_state . partner_state , our_model2 ) [EOL] assert_partner_state ( new_state . partner_state , new_state . our_state , partner_model2 ) [EOL] [EOL] [EOL] def test_deposit_must_wait_for_confirmation ( ) : [EOL] block_number = [number] [EOL] block_hash = make_block_hash ( ) [EOL] confirmed_deposit_block_number = block_number + DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS + [number] [EOL] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_key1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_key1 ) [EOL] [EOL] deposit_amount = [number] [EOL] balance1_new = our_model1 . balance + deposit_amount [EOL] our_model2 = our_model1 . _replace ( balance = balance1_new , distributable = balance1_new , contract_balance = balance1_new ) [EOL] partner_model2 = partner_model1 [EOL] [EOL] assert channel_state . our_state . contract_balance == [number] [EOL] assert channel_state . partner_state . contract_balance == [number] [EOL] [EOL] deposit_transaction = TransactionChannelNewBalance ( channel_state . our_state . address , deposit_amount , block_number ) [EOL] new_balance = ContractReceiveChannelNewBalance ( transaction_hash = make_transaction_hash ( ) , canonical_identifier = channel_state . canonical_identifier , deposit_transaction = deposit_transaction , block_number = block_number , block_hash = block_hash , ) [EOL] iteration = channel . state_transition ( channel_state = deepcopy ( channel_state ) , state_change = new_balance , block_number = block_number , block_hash = block_hash , ) [EOL] unconfirmed_state = iteration . new_state [EOL] [EOL] for block_number in range ( block_number , confirmed_deposit_block_number ) : [EOL] block_hash = make_transaction_hash ( ) [EOL] unconfirmed_block = Block ( block_number = block_number , gas_limit = [number] , block_hash = block_hash ) [EOL] iteration = channel . state_transition ( channel_state = deepcopy ( unconfirmed_state ) , state_change = unconfirmed_block , block_number = block_number , block_hash = block_hash , ) [EOL] unconfirmed_state = iteration . new_state [EOL] [EOL] assert_partner_state ( unconfirmed_state . our_state , unconfirmed_state . partner_state , our_model1 ) [EOL] assert_partner_state ( unconfirmed_state . partner_state , unconfirmed_state . our_state , partner_model1 ) [EOL] [EOL] confirmed_block_hash = make_transaction_hash ( ) [EOL] confirmed_block = Block ( block_number = confirmed_deposit_block_number , gas_limit = [number] , block_hash = confirmed_block_hash ) [EOL] iteration = channel . state_transition ( channel_state = deepcopy ( unconfirmed_state ) , state_change = confirmed_block , block_number = confirmed_deposit_block_number , block_hash = confirmed_block_hash , ) [EOL] confirmed_state = iteration . new_state [EOL] [EOL] assert_partner_state ( confirmed_state . our_state , confirmed_state . partner_state , our_model2 ) [EOL] assert_partner_state ( confirmed_state . partner_state , confirmed_state . our_state , partner_model2 ) [EOL] [EOL] [EOL] def test_channelstate_send_lockedtransfer ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_key1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_key1 ) [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] payment_identifier = [number] [EOL] message_identifier = random . randint ( [number] , UINT64_MAX ) [EOL] transfer_target = make_address ( ) [EOL] transfer_initiator = make_address ( ) [EOL] [EOL] channel . send_lockedtransfer ( channel_state , transfer_initiator , transfer_target , lock_amount , message_identifier , payment_identifier , lock_expiration , lock_secrethash , ) [EOL] [EOL] our_model2 = our_model1 . _replace ( distributable = our_model1 . distributable - lock_amount , amount_locked = lock_amount , next_nonce = [number] , merkletree_leaves = [ lock . lockhash ] , ) [EOL] partner_model2 = partner_model1 [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model2 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model2 ) [EOL] [EOL] [EOL] def test_channelstate_receive_lockedtransfer ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] signer2 = LocalSigner ( privkey2 ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] lock_amount = [number] [EOL] lock_expiration = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] our_model2 = our_model1 [EOL] partner_model2 = partner_model1 . _replace ( distributable = partner_model1 . distributable - lock_amount , amount_locked = lock_amount , next_nonce = [number] , merkletree_leaves = [ lock . lockhash ] , ) [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model2 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] channel . register_offchain_secret ( channel_state , lock_secret , lock_secrethash ) [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model2 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] transferred_amount = [number] [EOL] message_identifier = random . randint ( [number] , UINT64_MAX ) [EOL] token_network_identifier = channel_state . token_network_identifier [EOL] unlock_message = Unlock ( chain_id = UNIT_CHAIN_ID , message_identifier = message_identifier , payment_identifier = [number] , nonce = [number] , token_network_address = token_network_identifier , channel_identifier = channel_state . identifier , transferred_amount = transferred_amount + lock_amount , locked_amount = [number] , locksroot = EMPTY_MERKLE_ROOT , secret = lock_secret , ) [EOL] unlock_message . sign ( signer2 ) [EOL] [comment] [EOL] invalid_unlock_message = Unlock ( chain_id = UNIT_CHAIN_ID + [number] , message_identifier = message_identifier , payment_identifier = [number] , nonce = [number] , token_network_address = token_network_identifier , channel_identifier = channel_state . identifier , transferred_amount = transferred_amount + lock_amount , locked_amount = [number] , locksroot = EMPTY_MERKLE_ROOT , secret = lock_secret , ) [EOL] invalid_unlock_message . sign ( signer2 ) [EOL] [EOL] balance_proof = balanceproof_from_envelope ( unlock_message ) [EOL] unlock_state_change = ReceiveUnlock ( message_identifier = random . randint ( [number] , UINT64_MAX ) , secret = lock_secret , balance_proof = balance_proof , ) [EOL] [EOL] [comment] [EOL] invalid_balance_proof = balanceproof_from_envelope ( invalid_unlock_message ) [EOL] invalid_unlock_state_change = ReceiveUnlock ( message_identifier = random . randint ( [number] , UINT64_MAX ) , secret = lock_secret , balance_proof = invalid_balance_proof , ) [EOL] is_valid , _ , _ = channel . handle_unlock ( channel_state , invalid_unlock_state_change ) [EOL] assert not is_valid , [string] [string] [EOL] [EOL] is_valid , _ , msg = channel . handle_unlock ( channel_state , unlock_state_change ) [EOL] assert is_valid , msg [EOL] [EOL] our_model3 = our_model2 . _replace ( balance = our_model2 . balance + lock_amount , distributable = our_model2 . balance + lock_amount ) [EOL] partner_model3 = partner_model2 . _replace ( balance = partner_model2 . balance - lock_amount , amount_locked = [number] , next_nonce = [number] , merkletree_leaves = [ ] , ) [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model3 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model3 ) [EOL] [EOL] [EOL] def test_channelstate_lockedtransfer_overspent ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] distributable = channel . get_distributable ( channel_state . partner_state , channel_state . our_state ) [EOL] [EOL] lock_amount = distributable + [number] [EOL] lock_expiration = [number] [EOL] lock_secrethash = sha3 ( [string] ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock ) [EOL] [EOL] is_valid , _ , _ = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert not is_valid , [string] [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model1 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model1 ) [EOL] [EOL] [EOL] def test_channelstate_lockedtransfer_invalid_chainid ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] distributable = channel . get_distributable ( channel_state . partner_state , channel_state . our_state ) [EOL] [EOL] lock_amount = distributable - [number] [EOL] lock_expiration = [number] [EOL] lock_secrethash = sha3 ( [string] ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock , chain_id = UNIT_CHAIN_ID + [number] ) [EOL] [EOL] is_valid , _ , _ = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert not is_valid , [string] [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model1 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model1 ) [EOL] [EOL] [EOL] def test_channelstate_lockedtransfer_overspend_with_multiple_pending_transfers ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] lock1_amount = [number] [EOL] lock1_expiration = [number] + channel_state . settle_timeout [EOL] lock1_secrethash = sha3 ( [string] ) [EOL] lock1 = HashTimeLockState ( lock1_amount , lock1_expiration , lock1_secrethash ) [EOL] [EOL] nonce1 = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer1 = make_receive_transfer_mediated ( channel_state , privkey2 , nonce1 , transferred_amount , lock1 ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer1 ) [EOL] assert is_valid , msg [EOL] [EOL] our_model2 = our_model1 [EOL] partner_model2 = partner_model1 . _replace ( distributable = partner_model1 . distributable - lock1 . amount , amount_locked = lock1 . amount , next_nonce = [number] , merkletree_leaves = [ lock1 . lockhash ] , ) [EOL] [EOL] [comment] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model2 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] distributable = channel . get_distributable ( channel_state . partner_state , channel_state . our_state ) [EOL] lock2_amount = distributable + [number] [EOL] lock2_expiration = channel_state . settle_timeout [EOL] lock2_secrethash = sha3 ( [string] ) [EOL] lock2 = HashTimeLockState ( lock2_amount , lock2_expiration , lock2_secrethash ) [EOL] leaves = [ lock1 . lockhash , lock2 . lockhash ] [EOL] [EOL] nonce2 = [number] [EOL] receive_lockedtransfer2 = make_receive_transfer_mediated ( channel_state , privkey2 , nonce2 , transferred_amount , lock2 , merkletree_leaves = leaves ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer2 ) [EOL] assert not is_valid , [string] [EOL] [EOL] [comment] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model2 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model2 ) [EOL] [EOL] [EOL] def test_invalid_timeouts ( ) : [EOL] token_address = make_address ( ) [EOL] token_network_identifier = make_address ( ) [EOL] payment_network_identifier = make_payment_network_identifier ( ) [EOL] reveal_timeout = [number] [EOL] settle_timeout = [number] [EOL] identifier = make_address ( ) [EOL] [EOL] address1 = make_address ( ) [EOL] address2 = make_address ( ) [EOL] balance1 = [number] [EOL] balance2 = [number] [EOL] [EOL] opened_transaction = TransactionExecutionStatus ( None , [number] , TransactionExecutionStatus . SUCCESS ) [EOL] closed_transaction = None [EOL] settled_transaction = None [EOL] [EOL] our_state = NettingChannelEndState ( address1 , balance1 ) [EOL] partner_state = NettingChannelEndState ( address2 , balance2 ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] large_reveal_timeout = [number] [EOL] small_settle_timeout = [number] [EOL] [EOL] NettingChannelState ( canonical_identifier = make_canonical_identifier ( token_network_address = token_network_identifier , channel_identifier = identifier ) , token_address = token_address , payment_network_identifier = payment_network_identifier , reveal_timeout = large_reveal_timeout , settle_timeout = small_settle_timeout , mediation_fee = [number] , our_state = our_state , partner_state = partner_state , open_transaction = opened_transaction , close_transaction = closed_transaction , settle_transaction = settled_transaction , ) [EOL] [EOL] [comment] [EOL] for invalid_value in ( - [number] , [number] , [number] , [number] ) : [EOL] with pytest . raises ( ValueError ) : [EOL] NettingChannelState ( canonical_identifier = make_canonical_identifier ( token_network_address = token_network_identifier , channel_identifier = identifier ) , token_address = token_address , payment_network_identifier = payment_network_identifier , reveal_timeout = invalid_value , settle_timeout = settle_timeout , mediation_fee = [number] , our_state = our_state , partner_state = partner_state , open_transaction = opened_transaction , close_transaction = closed_transaction , settle_transaction = settled_transaction , ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] NettingChannelState ( canonical_identifier = make_canonical_identifier ( token_network_address = token_network_identifier , channel_identifier = identifier ) , token_address = token_address , payment_network_identifier = payment_network_identifier , reveal_timeout = reveal_timeout , settle_timeout = invalid_value , mediation_fee = [number] , our_state = our_state , partner_state = partner_state , open_transaction = opened_transaction , close_transaction = closed_transaction , settle_transaction = settled_transaction , ) [EOL] [EOL] [EOL] def test_interwoven_transfers ( ) : [EOL] [docstring] [EOL] number_of_transfers = [number] [EOL] balance_for_all_transfers = [number] * number_of_transfers [EOL] [EOL] lock_amounts = cycle ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] lock_secrets = [ make_secret ( i ) for i in range ( number_of_transfers ) ] [EOL] [EOL] our_model , _ = create_model ( [number] ) [EOL] partner_model , privkey2 = create_model ( balance_for_all_transfers ) [EOL] signer2 = LocalSigner ( privkey2 ) [EOL] channel_state = create_channel_from_models ( our_model , partner_model , privkey2 ) [EOL] [EOL] block_number = [number] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] locked_amount = [number] [EOL] our_model_current = our_model [EOL] partner_model_current = partner_model [EOL] token_network_address = channel_state . token_network_identifier [EOL] [EOL] for i , ( lock_amount , lock_secret ) in enumerate ( zip ( lock_amounts , lock_secrets ) ) : [EOL] nonce += [number] [EOL] block_number += [number] [EOL] locked_amount += lock_amount [EOL] [EOL] lock_expiration = block_number + channel_state . settle_timeout - [number] [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] merkletree_leaves = list ( partner_model_current . merkletree_leaves ) [EOL] merkletree_leaves . append ( lock . lockhash ) [EOL] [EOL] partner_model_current = partner_model_current . _replace ( distributable = partner_model_current . distributable - lock_amount , amount_locked = partner_model_current . amount_locked + lock_amount , next_nonce = partner_model_current . next_nonce + [number] , merkletree_leaves = merkletree_leaves , ) [EOL] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock , merkletree_leaves = merkletree_leaves , locked_amount = locked_amount , ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model_current ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model_current ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if i % [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] nonce += [number] [EOL] transferred_amount += lock_amount [EOL] locked_amount -= lock_amount [EOL] [EOL] merkletree_leaves = list ( partner_model_current . merkletree_leaves ) [EOL] merkletree_leaves . remove ( lock . lockhash ) [EOL] tree = compute_layers ( merkletree_leaves ) [EOL] locksroot = tree [ MERKLEROOT ] [ [number] ] [EOL] [EOL] partner_model_current = partner_model_current . _replace ( amount_locked = partner_model_current . amount_locked - lock_amount , balance = partner_model_current . balance - lock_amount , next_nonce = partner_model_current . next_nonce + [number] , merkletree_leaves = merkletree_leaves , ) [EOL] [EOL] our_model_current = our_model_current . _replace ( balance = our_model_current . balance + lock_amount , distributable = our_model_current . distributable + lock_amount , ) [EOL] [EOL] message_identifier = random . randint ( [number] , UINT64_MAX ) [EOL] unlock_message = Unlock ( chain_id = UNIT_CHAIN_ID , message_identifier = message_identifier , payment_identifier = nonce , nonce = nonce , token_network_address = token_network_address , channel_identifier = channel_state . identifier , transferred_amount = transferred_amount , locked_amount = locked_amount , locksroot = locksroot , secret = lock_secret , ) [EOL] unlock_message . sign ( signer2 ) [EOL] [EOL] balance_proof = balanceproof_from_envelope ( unlock_message ) [EOL] unlock_state_change = ReceiveUnlock ( message_identifier = random . randint ( [number] , UINT64_MAX ) , secret = lock_secret , balance_proof = balance_proof , ) [EOL] [EOL] is_valid , _ , msg = channel . handle_unlock ( channel_state , unlock_state_change ) [EOL] assert is_valid , msg [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model_current ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model_current ) [EOL] [EOL] [EOL] def test_channel_never_expires_lock_with_secret_onchain ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_key1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_key1 ) [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] [EOL] lock = HashTimeLockState ( amount = lock_amount , expiration = lock_expiration , secrethash = lock_secrethash ) [EOL] [EOL] payment_identifier = [number] [EOL] message_identifier = random . randint ( [number] , UINT64_MAX ) [EOL] transfer_target = make_address ( ) [EOL] transfer_initiator = make_address ( ) [EOL] [EOL] channel . send_lockedtransfer ( channel_state = channel_state , initiator = transfer_initiator , target = transfer_target , amount = lock_amount , message_identifier = message_identifier , payment_identifier = payment_identifier , expiration = lock_expiration , secrethash = lock_secrethash , ) [EOL] [EOL] assert lock . secrethash in channel_state . our_state . secrethashes_to_lockedlocks [EOL] [EOL] channel . register_onchain_secret ( channel_state = channel_state , secret = lock_secret , secrethash = lock . secrethash , secret_reveal_block_number = lock_expiration - [number] , delete_lock = True , ) [EOL] [EOL] assert lock . secrethash not in channel_state . our_state . secrethashes_to_lockedlocks [EOL] assert lock . secrethash in channel_state . our_state . secrethashes_to_onchain_unlockedlocks [EOL] [EOL] [EOL] def test_regression_must_update_balanceproof_remove_expired_lock ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] block_number = [number] [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = block_number - [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( amount = lock_amount , expiration = lock_expiration , secrethash = lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state = channel_state , privkey = privkey2 , nonce = nonce , transferred_amount = transferred_amount , lock = lock , ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state = channel_state , mediated_transfer = receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] [EOL] lock_expired = make_receive_expired_lock ( channel_state , privkey2 , receive_lockedtransfer . balance_proof . nonce + [number] , transferred_amount , lock , locked_amount = [number] , ) [EOL] [EOL] is_valid , msg , _ = channel . is_valid_lock_expired ( state_change = lock_expired , channel_state = channel_state , sender_state = channel_state . partner_state , receiver_state = channel_state . our_state , block_number = block_number , ) [EOL] [EOL] assert is_valid , msg [EOL] [EOL] iteration = channel . handle_receive_lock_expired ( channel_state = channel_state , state_change = lock_expired , block_number = block_number ) [EOL] [EOL] new_channel_state = iteration . new_state [EOL] assert lock . secrethash not in new_channel_state . partner_state . secrethashes_to_lockedlocks [EOL] msg = [string] [EOL] assert new_channel_state . partner_state . balance_proof == lock_expired . balance_proof , msg [EOL] assert new_channel_state . partner_state . merkletree == make_empty_merkle_tree ( ) [EOL] [EOL] [EOL] def test_channel_must_ignore_remove_expired_locks_if_secret_registered_onchain ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] block_number = [number] [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = block_number - [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( amount = lock_amount , expiration = lock_expiration , secrethash = lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state = channel_state , privkey = privkey2 , nonce = nonce , transferred_amount = transferred_amount , lock = lock , ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state = channel_state , mediated_transfer = receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] [EOL] channel . register_onchain_secret ( channel_state = channel_state , secret = lock_secret , secrethash = lock_secrethash , secret_reveal_block_number = [number] , delete_lock = False , ) [EOL] [EOL] lock_expired = ReceiveLockExpired ( balance_proof = receive_lockedtransfer . balance_proof , secrethash = lock_secrethash , message_identifier = [number] , ) [EOL] [EOL] is_valid , msg , _ = channel . is_valid_lock_expired ( state_change = lock_expired , channel_state = channel_state , sender_state = channel_state . partner_state , receiver_state = channel_state . our_state , block_number = block_number , ) [EOL] [EOL] assert not is_valid [EOL] assert [string] in msg , [string] [EOL] [EOL] channel . handle_receive_lock_expired ( channel_state = channel_state , state_change = lock_expired , block_number = block_number ) [EOL] [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] [EOL] [EOL] def test_channel_must_accept_expired_locks ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] block_number = [number] [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = block_number - [number] [EOL] lock_secrethash = sha3 ( [string] ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] [comment] [EOL] [comment] [EOL] our_model2 = our_model1 [EOL] partner_model2 = partner_model1 . _replace ( amount_locked = lock_amount , distributable = partner_model1 . distributable - lock_amount , next_nonce = partner_model1 . next_nonce + [number] , merkletree_leaves = [ lock . lockhash ] , ) [EOL] [EOL] assert_partner_state ( channel_state . our_state , channel_state . partner_state , our_model2 ) [EOL] assert_partner_state ( channel_state . partner_state , channel_state . our_state , partner_model2 ) [EOL] [EOL] [EOL] def test_channel_rejects_onchain_secret_reveal_with_expired_locks ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] block_number = [number] [EOL] lock_expiration = block_number - [number] [EOL] secret_reveal_block_number = block_number - [number] [EOL] [EOL] lock_amount = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( amount = lock_amount , expiration = lock_expiration , secrethash = lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state = channel_state , privkey = privkey2 , nonce = nonce , transferred_amount = transferred_amount , lock = lock , ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state = channel_state , mediated_transfer = receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] [EOL] [comment] [EOL] channel . register_onchain_secret ( channel_state = channel_state , secret = lock_secret , secrethash = lock_secrethash , secret_reveal_block_number = secret_reveal_block_number , delete_lock = False , ) [EOL] [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] assert { } == channel_state . partner_state . secrethashes_to_onchain_unlockedlocks [EOL] [EOL] [comment] [EOL] channel . register_onchain_secret ( channel_state = channel_state , secret = lock_secret , secrethash = lock_secrethash , secret_reveal_block_number = lock_expiration - [number] , delete_lock = True , ) [EOL] [EOL] assert lock . secrethash not in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_onchain_unlockedlocks [EOL] [EOL] [EOL] def test_receive_lockedtransfer_before_deposit ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [comment] [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] [EOL] [comment] [EOL] assert is_valid , msg [EOL] [EOL] [EOL] def test_channelstate_unlock_without_locks ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_key1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_key1 ) [EOL] [EOL] state_change = ContractReceiveChannelClosed ( transaction_hash = make_transaction_hash ( ) , transaction_from = our_model1 . participant_address , canonical_identifier = channel_state . canonical_identifier , block_number = [number] , block_hash = make_block_hash ( ) , ) [EOL] iteration = channel . handle_channel_closed ( channel_state , state_change ) [EOL] assert not iteration . events [EOL] [EOL] [EOL] def test_channelstate_get_unlock_proof ( ) : [EOL] number_of_transfers = [number] [EOL] lock_amounts = cycle ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] lock_secrets = [ make_secret ( i ) for i in range ( number_of_transfers ) ] [EOL] [EOL] block_number = [number] [EOL] locked_amount = [number] [EOL] settle_timeout = [number] [EOL] merkletree_leaves = [ ] [EOL] locked_locks = { } [EOL] unlocked_locks = { } [EOL] [EOL] for lock_amount , lock_secret in zip ( lock_amounts , lock_secrets ) : [EOL] block_number += [number] [EOL] locked_amount += lock_amount [EOL] [EOL] lock_expiration = block_number + settle_timeout [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] merkletree_leaves . append ( lock . lockhash ) [EOL] if random . randint ( [number] , [number] ) == [number] : [EOL] locked_locks [ lock_secrethash ] = lock [EOL] else : [EOL] unlocked_locks [ lock_secrethash ] = UnlockPartialProofState ( lock , lock_secret ) [EOL] [EOL] end_state = NettingChannelEndState ( HOP1 , [number] ) [EOL] end_state . secrethashes_to_lockedlocks = locked_locks [EOL] end_state . secrethashes_to_unlockedlocks = unlocked_locks [EOL] end_state . merkletree = MerkleTreeState ( compute_layers ( merkletree_leaves ) ) [EOL] [EOL] unlock_proof = channel . get_batch_unlock ( end_state ) [EOL] assert len ( unlock_proof ) == len ( end_state . merkletree . layers [ LEAVES ] ) [EOL] leaves_packed = [string] . join ( lock . encoded for lock in unlock_proof ) [EOL] [EOL] recomputed_merkle_tree = MerkleTreeState ( compute_layers ( merkle_leaves_from_packed_data ( leaves_packed ) ) ) [EOL] assert len ( recomputed_merkle_tree . layers [ LEAVES ] ) == len ( end_state . merkletree . layers [ LEAVES ] ) [EOL] [EOL] computed_merkleroot = merkleroot ( recomputed_merkle_tree ) [EOL] assert merkleroot ( end_state . merkletree ) == computed_merkleroot [EOL] [EOL] [EOL] def test_channelstate_unlock_unlocked_onchain ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] channel . register_onchain_secret ( channel_state = channel_state , secret = lock_secret , secrethash = lock_secrethash , secret_reveal_block_number = lock_expiration - [number] , ) [EOL] [EOL] closed_block_number = lock_expiration - channel_state . reveal_timeout - [number] [EOL] closed_block_hash = make_block_hash ( ) [EOL] close_state_change = ContractReceiveChannelClosed ( transaction_hash = make_transaction_hash ( ) , transaction_from = partner_model1 . participant_address , canonical_identifier = channel_state . canonical_identifier , block_number = closed_block_number , block_hash = closed_block_hash , ) [EOL] iteration = channel . handle_channel_closed ( channel_state , close_state_change ) [EOL] assert search_for_item ( iteration . events , ContractSendChannelBatchUnlock , { } ) is None [EOL] [EOL] settle_block_number = lock_expiration + channel_state . reveal_timeout + [number] [EOL] settle_state_change = ContractReceiveChannelSettled ( canonical_identifier = make_canonical_identifier ( token_network_address = channel_state . token_network_identifier , channel_identifier = channel_state . identifier , ) , transaction_hash = make_transaction_hash ( ) , block_number = settle_block_number , block_hash = make_block_hash ( ) , partner_onchain_locksroot = make_32bytes ( ) , our_onchain_locksroot = EMPTY_MERKLE_ROOT , ) [EOL] [EOL] iteration = channel . handle_channel_settled ( channel_state , settle_state_change ) [EOL] assert search_for_item ( iteration . events , ContractSendChannelBatchUnlock , { } ) is not None [EOL] [EOL] [EOL] def test_refund_transfer_matches_received ( ) : [EOL] same = LockedTransferSignedStateProperties ( amount = [number] , expiration = [number] ) [EOL] lower = replace ( same , expiration = [number] ) [EOL] [EOL] refund_lower_expiration = create ( lower ) [EOL] refund_same_expiration = create ( same ) [EOL] transfer = create ( same . extract ( LockedTransferUnsignedStateProperties ) ) [EOL] [EOL] assert channel . refund_transfer_matches_transfer ( refund_lower_expiration , transfer ) is False [EOL] assert channel . refund_transfer_matches_transfer ( refund_same_expiration , transfer ) is True [EOL] [EOL] [EOL] def test_refund_transfer_does_not_match_received ( ) : [EOL] amount = [number] [EOL] expiration = [number] [EOL] target = UNIT_TRANSFER_SENDER [EOL] transfer = create ( LockedTransferUnsignedStateProperties ( amount = amount , target = target , expiration = expiration ) ) [EOL] [EOL] refund_from_target = create ( LockedTransferSignedStateProperties ( amount = amount , expiration = expiration - [number] ) ) [EOL] [comment] [EOL] assert not channel . refund_transfer_matches_transfer ( refund_from_target , transfer ) [EOL] [EOL] [EOL] def test_action_close_must_change_the_channel_state ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_key1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_key1 ) [EOL] [EOL] block_number = [number] [EOL] state_change = ActionChannelClose ( canonical_identifier = channel_state . canonical_identifier ) [EOL] iteration = channel . state_transition ( channel_state = channel_state , state_change = state_change , block_number = block_number , block_hash = make_block_hash ( ) , ) [EOL] assert channel . get_status ( iteration . new_state ) == CHANNEL_STATE_CLOSING [EOL] [EOL] [EOL] def test_update_must_be_called_if_close_lost_race ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( lock_amount , lock_expiration , lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state , privkey2 , nonce , transferred_amount , lock ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state , receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] block_number = [number] [EOL] state_change = ActionChannelClose ( canonical_identifier = channel_state . canonical_identifier ) [EOL] iteration = channel . state_transition ( channel_state = channel_state , state_change = state_change , block_number = block_number , block_hash = make_block_hash ( ) , ) [EOL] [EOL] state_change = ContractReceiveChannelClosed ( transaction_hash = make_transaction_hash ( ) , transaction_from = partner_model1 . participant_address , canonical_identifier = channel_state . canonical_identifier , block_number = [number] , block_hash = make_block_hash ( ) , ) [EOL] iteration = channel . handle_channel_closed ( channel_state , state_change ) [EOL] assert search_for_item ( iteration . events , ContractSendChannelUpdateTransfer , { } ) is not None [EOL] [EOL] [EOL] def test_update_transfer ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , partner_key1 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , partner_key1 ) [EOL] [EOL] block_number = [number] [EOL] state_change = ActionChannelClose ( canonical_identifier = channel_state . canonical_identifier ) [EOL] iteration = channel . state_transition ( channel_state = channel_state , state_change = state_change , block_number = block_number , block_hash = make_block_hash ( ) , ) [EOL] [EOL] [comment] [EOL] channel_state = iteration . new_state [EOL] assert channel_state . update_transaction is None [EOL] [EOL] closed_block_number = [number] [EOL] closed_block_hash = make_block_hash ( ) [EOL] channel_close_state_change = ContractReceiveChannelClosed ( transaction_hash = make_transaction_hash ( ) , transaction_from = partner_model1 . participant_address , canonical_identifier = channel_state . canonical_identifier , block_number = closed_block_number , block_hash = closed_block_hash , ) [EOL] iteration2 = channel . handle_channel_closed ( channel_state , channel_close_state_change ) [EOL] [EOL] [comment] [EOL] channel_state = iteration2 . new_state [EOL] assert channel_state . update_transaction is None [EOL] [EOL] update_transfer_state_change = ContractReceiveUpdateTransfer ( transaction_hash = partner_model1 . participant_address , canonical_identifier = channel_state . canonical_identifier , nonce = [number] , block_number = closed_block_number + [number] , block_hash = make_block_hash ( ) , ) [EOL] [EOL] update_block_number = [number] [EOL] iteration3 = channel . handle_channel_updated_transfer ( channel_state , update_transfer_state_change , update_block_number ) [EOL] [EOL] [comment] [EOL] channel_state = iteration3 . new_state [EOL] assert channel_state . update_transaction == TransactionExecutionStatus ( started_block_number = None , finished_block_number = update_block_number , result = TransactionExecutionStatus . SUCCESS , ) [EOL] [EOL] [EOL] def test_get_amount_locked ( ) : [EOL] state = NettingChannelEndState ( address = make_address ( ) , balance = [number] ) [EOL] [EOL] assert channel . get_amount_locked ( state ) == [number] [EOL] [EOL] secrethash = sha3 ( make_secret ( [number] ) ) [EOL] state . secrethashes_to_lockedlocks [ secrethash ] = HashTimeLockState ( amount = [number] , expiration = [number] , secrethash = secrethash ) [EOL] assert channel . get_amount_locked ( state ) == [number] [EOL] [EOL] secret = make_secret ( [number] ) [EOL] secrethash = sha3 ( secret ) [EOL] lock = HashTimeLockState ( amount = [number] , expiration = [number] , secrethash = secrethash ) [EOL] state . secrethashes_to_unlockedlocks [ secrethash ] = UnlockPartialProofState ( lock = lock , secret = secret ) [EOL] assert channel . get_amount_locked ( state ) == [number] [EOL] [EOL] secret = make_secret ( [number] ) [EOL] secrethash = sha3 ( secret ) [EOL] lock = HashTimeLockState ( amount = [number] , expiration = [number] , secrethash = secrethash ) [EOL] state . secrethashes_to_onchain_unlockedlocks [ secrethash ] = UnlockPartialProofState ( lock = lock , secret = secret ) [EOL] assert channel . get_amount_locked ( state ) == [number] [EOL] [EOL] [EOL] def test_valid_lock_expired_for_unlocked_lock ( ) : [EOL] [docstring] [EOL] our_model1 , _ = create_model ( [number] ) [EOL] partner_model1 , privkey2 = create_model ( [number] ) [EOL] channel_state = create_channel_from_models ( our_model1 , partner_model1 , privkey2 ) [EOL] [EOL] block_number = [number] [EOL] [EOL] lock_amount = [number] [EOL] lock_expiration = block_number - [number] [EOL] lock_secret = sha3 ( [string] ) [EOL] lock_secrethash = sha3 ( lock_secret ) [EOL] lock = HashTimeLockState ( amount = lock_amount , expiration = lock_expiration , secrethash = lock_secrethash ) [EOL] [EOL] nonce = [number] [EOL] transferred_amount = [number] [EOL] receive_lockedtransfer = make_receive_transfer_mediated ( channel_state = channel_state , privkey = privkey2 , nonce = nonce , transferred_amount = transferred_amount , lock = lock , ) [EOL] [EOL] is_valid , _ , msg = channel . handle_receive_lockedtransfer ( channel_state = channel_state , mediated_transfer = receive_lockedtransfer ) [EOL] assert is_valid , msg [EOL] [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_lockedlocks [EOL] [EOL] channel . register_offchain_secret ( channel_state = channel_state , secret = lock_secret , secrethash = lock_secrethash ) [EOL] [EOL] lock_expired = ReceiveLockExpired ( balance_proof = receive_lockedtransfer . balance_proof , secrethash = lock_secrethash , message_identifier = [number] , ) [EOL] [EOL] is_valid , _ , _ = channel . is_valid_lock_expired ( state_change = lock_expired , channel_state = channel_state , sender_state = channel_state . partner_state , receiver_state = channel_state . our_state , block_number = block_number , ) [EOL] [EOL] assert not is_valid [EOL] assert lock . secrethash in channel_state . partner_state . secrethashes_to_unlockedlocks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.tests.unit.test_channelstate.PartnerStateModel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.tests.unit.test_channelstate.PartnerStateModel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Dict [EOL] import typing [EOL] import raiden [EOL] import random [EOL] [EOL] import pytest [EOL] from gevent import server [EOL] [EOL] from raiden . constants import UINT64_MAX [EOL] from raiden . messages import SecretRequest [EOL] from raiden . network . throttle import TokenBucket [EOL] from raiden . network . transport . udp import UDPTransport [EOL] from raiden . tests . utils . factories import ADDR , UNIT_SECRETHASH , make_address [EOL] from raiden . tests . utils . mocks import MockRaidenService [EOL] from raiden . tests . utils . transport import MockDiscovery [EOL] [EOL] pytestmark = pytest . mark . usefixtures ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_udp ( raiden_udp_ports , throttle_capacity , throttle_fill_rate , retry_interval , retries_before_backoff , nat_invitation_timeout , nat_keepalive_retries , nat_keepalive_timeout , ) : [EOL] throttle_policy = TokenBucket ( throttle_capacity , throttle_fill_rate ) [EOL] host = [string] [EOL] port = raiden_udp_ports [ [number] ] [EOL] address = make_address ( ) [EOL] [EOL] config = dict ( retry_interval = retry_interval , retries_before_backoff = retries_before_backoff , nat_invitation_timeout = nat_invitation_timeout , nat_keepalive_retries = nat_keepalive_retries , nat_keepalive_timeout = nat_keepalive_timeout , ) [EOL] [EOL] transport = UDPTransport ( address , MockDiscovery , server . _udp_socket ( ( host , port ) ) , throttle_policy , config , ) [EOL] [EOL] transport . raiden = MockRaidenService ( ADDR ) [EOL] [EOL] return transport [EOL] [EOL] [EOL] def test_token_bucket ( ) : [EOL] capacity = [number] [EOL] fill_rate = [number] [EOL] token_refill = [number] / fill_rate [EOL] [EOL] [comment] [EOL] time = lambda : [number] [EOL] [EOL] bucket = TokenBucket ( capacity , fill_rate , time ) [EOL] [EOL] assert bucket . consume ( [number] ) == [number] [EOL] assert bucket . consume ( [number] ) == [number] [EOL] [EOL] for num in range ( [number] , [number] ) : [EOL] assert num * token_refill == bucket . consume ( [number] ) [EOL] [EOL] [EOL] def test_udp_receive_invalid_length ( mock_udp ) : [EOL] data = bytearray ( random . getrandbits ( [number] ) for _ in range ( mock_udp . UDP_MAX_MESSAGE_SIZE + [number] ) ) [EOL] host_port = None [EOL] assert not mock_udp . receive ( data , host_port ) [EOL] [EOL] [EOL] def test_udp_decode_invalid_message ( mock_udp ) : [EOL] message = SecretRequest ( message_identifier = random . randint ( [number] , UINT64_MAX ) , payment_identifier = [number] , secrethash = UNIT_SECRETHASH , amount = [number] , expiration = [number] , ) [EOL] data = message . encode ( ) [EOL] wrong_command_id_data = [string] + data [ [number] : ] [EOL] host_port = None [EOL] assert not mock_udp . receive ( wrong_command_id_data , host_port ) [EOL] [EOL] [EOL] def test_udp_decode_invalid_size_message ( mock_udp ) : [EOL] message = SecretRequest ( message_identifier = random . randint ( [number] , UINT64_MAX ) , payment_identifier = [number] , secrethash = UNIT_SECRETHASH , amount = [number] , expiration = [number] , ) [EOL] data = message . encode ( ) [EOL] wrong_command_id_data = data [ : - [number] ] [EOL] host_port = None [EOL] assert not mock_udp . receive ( wrong_command_id_data , host_port ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] import pytest [EOL] [EOL] from raiden . exceptions import InvalidAddress [EOL] from raiden . network . discovery import Discovery [EOL] from raiden . tests . utils . factories import make_address [EOL] [EOL] [EOL] def test_mock_registry_api_compliance ( ) : [EOL] address = make_address ( ) [EOL] contract_discovery_instance = Discovery ( ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( InvalidAddress ) : [EOL] contract_discovery_instance . get ( address ) [EOL] [EOL] [comment] [EOL] contract_discovery_instance . register ( address , [string] , [number] ) [EOL] assert contract_discovery_instance . get ( address ) == ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] contract_discovery_instance . register ( address , [string] , [number] ) [EOL] assert contract_discovery_instance . get ( address ) == ( [string] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] import random [EOL] [EOL] import pytest [EOL] [EOL] from raiden . tests . utils import factories [EOL] from raiden . tests . utils . factories import UNIT_CHAIN_ID [EOL] from raiden . transfer . state import ChainState , PaymentNetworkState , TokenNetworkState [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture def our_address ( ) : [EOL] return factories . make_address ( ) [EOL] [EOL] [EOL] @ pytest . fixture def token_id ( ) : [EOL] return factories . make_address ( ) [EOL] [EOL] [EOL] @ pytest . fixture def token_network_id ( ) : [EOL] return factories . make_address ( ) [EOL] [EOL] [EOL] @ pytest . fixture def one_to_n_address ( ) : [EOL] return factories . make_address ( ) [EOL] [EOL] [EOL] @ pytest . fixture def payment_network_id ( ) : [EOL] return factories . make_address ( ) [EOL] [EOL] [EOL] @ pytest . fixture def chain_state ( our_address ) : [EOL] block_number = [number] [EOL] [EOL] return ChainState ( pseudo_random_generator = random . Random ( ) , block_number = block_number , block_hash = factories . make_block_hash ( ) , our_address = our_address , chain_id = UNIT_CHAIN_ID , ) [EOL] [EOL] [EOL] @ pytest . fixture def payment_network_state ( chain_state , payment_network_id ) : [EOL] payment_network = PaymentNetworkState ( payment_network_id , [ ] ) [EOL] chain_state . identifiers_to_paymentnetworks [ payment_network_id ] = payment_network [EOL] return payment_network [EOL] [EOL] [EOL] @ pytest . fixture def token_network_state ( chain_state , payment_network_state , payment_network_id , token_network_id , token_id ) : [EOL] token_network = TokenNetworkState ( token_network_id , token_id ) [EOL] payment_network_state . tokenidentifiers_to_tokennetworks [ token_network_id ] = token_network [EOL] payment_network_state . tokenaddresses_to_tokenidentifiers [ token_id ] = token_network_id [EOL] [EOL] mapping = chain_state . tokennetworkaddresses_to_paymentnetworkaddresses [EOL] mapping [ token_network_id ] = payment_network_id [EOL] [EOL] return token_network [EOL] [EOL] [EOL] @ pytest . fixture def netting_channel_state ( chain_state , token_network_state , payment_network_state ) : [EOL] partner = factories . make_address ( ) [EOL] canonical_identifier = factories . make_canonical_identifier ( token_network_address = token_network_state . address ) [EOL] channel_state = factories . create ( factories . NettingChannelStateProperties ( our_state = factories . NettingChannelEndStateProperties ( balance = [number] , address = chain_state . our_address ) , partner_state = factories . NettingChannelEndStateProperties ( balance = [number] , address = partner ) , token_address = token_network_state . token_address , payment_network_identifier = payment_network_state . address , canonical_identifier = canonical_identifier , ) ) [EOL] [EOL] channel_id = canonical_identifier . channel_identifier [EOL] token_network_state . partneraddresses_to_channelidentifiers [ partner ] . append ( channel_id ) [EOL] token_network_state . channelidentifiers_to_channels [ channel_id ] = channel_state [EOL] [EOL] return channel_state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] import pytest [EOL] [EOL] from raiden . encoding . encoders import integer [EOL] from raiden . encoding . format import Field , namedbuffer [EOL] [EOL] [comment] [EOL] byte = Field ( [string] , [number] , [string] , None ) [EOL] hugeint = Field ( [string] , [number] , [string] , integer ( [number] , [number] ** ( [number] * [number] ) ) ) [EOL] SingleByte = namedbuffer ( [string] , [ byte ] ) [EOL] HugeInt = namedbuffer ( [string] , [ hugeint ] ) [EOL] [EOL] [EOL] def test_byte ( ) : [EOL] data = bytearray ( [number] ) [comment] [EOL] [EOL] packed_data = SingleByte ( data ) [EOL] assert packed_data . byte == [string] [EOL] [EOL] packed_data . byte = [string] [EOL] assert packed_data . byte == [string] [EOL] [EOL] [EOL] def test_decoder_int ( ) : [EOL] data = bytearray ( [number] ) [EOL] [EOL] packed_data = HugeInt ( data ) [EOL] assert packed_data . huge == [number] [EOL] [EOL] packed_data . huge = [number] [EOL] assert packed_data . huge == [number] [EOL] [EOL] [EOL] def test_decoder_long ( ) : [EOL] data = bytearray ( [number] ) [EOL] [EOL] packed_data = HugeInt ( data ) [EOL] assert packed_data . huge == [number] [EOL] [EOL] packed_data . huge = [number] [EOL] assert packed_data . huge == [number] [EOL] [EOL] packed_data . huge = [number] ** [number] [EOL] assert packed_data . huge == [number] ** [number] [EOL] [EOL] huge = [number] ** ( [number] * [number] ) - [number] [EOL] packed_data . huge = huge [EOL] assert packed_data . huge == huge [EOL] [EOL] [EOL] def test_namedbuffer_does_not_expose_internals ( ) : [EOL] [comment] [EOL] data = bytearray ( [number] ) [EOL] packed_data = SingleByte ( data ) [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] packed_data . format [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] packed_data . fields_spec [EOL] [EOL] [comment] [EOL] assert dir ( packed_data ) == [ [string] ] [EOL] [EOL] [EOL] def test_namedbuffer_type_exposes_details ( ) : [EOL] assert SingleByte . format == [string] [EOL] assert SingleByte . fields_spec == [ byte ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 0 0 0 $raiden.encoding.format.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $raiden.encoding.format.Field$ 0 0
from . fixtures import * [comment] [EOL]	0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] import gevent [EOL] from gevent . event import Event [EOL] [EOL] from raiden . network . transport . udp . udp_utils import event_first_of [EOL] from raiden . utils . notifying_queue import NotifyingQueue [EOL] [EOL] [EOL] def add_element_to_queue ( queue , element ) : [EOL] queue . put ( element ) [EOL] [EOL] [EOL] def test_copy ( ) : [EOL] queue = NotifyingQueue ( ) [EOL] assert queue . copy ( ) == [ ] [EOL] [EOL] queue . put ( [number] ) [EOL] assert queue . copy ( ) == [ [number] ] [EOL] assert queue . peek ( ) == [number] , [string] [EOL] [EOL] queue . put ( [number] ) [EOL] assert queue . copy ( ) == [ [number] , [number] ] , [string] [EOL] [EOL] [EOL] def test_event_must_be_set ( ) : [EOL] queue = NotifyingQueue ( ) [EOL] event_stop = Event ( ) [EOL] [EOL] data_or_stop = event_first_of ( queue , event_stop ) [EOL] [EOL] spawn_after_seconds = [number] [EOL] element = [number] [EOL] gevent . spawn_later ( spawn_after_seconds , add_element_to_queue , queue , element ) [EOL] assert data_or_stop . wait ( ) [EOL] [EOL] [EOL] def test_not_empty ( ) : [EOL] queue = NotifyingQueue ( items = [ [number] , [number] ] ) [EOL] assert queue . is_set ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] import raiden [EOL] import pytest [EOL] [EOL] from raiden . api . python import event_filter_for_payments [EOL] from raiden . api . v1 . encoding import EventPaymentSentFailedSchema [EOL] from raiden . blockchain . events import get_contract_events [EOL] from raiden . exceptions import InvalidBlockNumberInput [EOL] from raiden . storage . utils import TimestampedEvent [EOL] from raiden . tests . utils import factories [EOL] from raiden . tests . utils . factories import ADDR [EOL] from raiden . transfer . events import ( EventPaymentReceivedSuccess , EventPaymentSentFailed , EventPaymentSentSuccess , ) [EOL] [EOL] [EOL] def test_get_contract_events_invalid_blocknumber ( ) : [EOL] with pytest . raises ( InvalidBlockNumberInput ) : [EOL] get_contract_events ( None , { } , ADDR , [ ] , - [number] , [number] ) [EOL] [EOL] with pytest . raises ( InvalidBlockNumberInput ) : [EOL] get_contract_events ( None , { } , ADDR , [ ] , [number] , [number] ) [EOL] [EOL] with pytest . raises ( InvalidBlockNumberInput ) : [EOL] get_contract_events ( None , { } , ADDR , [ ] , [number] , - [number] ) [EOL] [EOL] with pytest . raises ( InvalidBlockNumberInput ) : [EOL] get_contract_events ( None , { } , ADDR , [ ] , [number] , [number] ) [EOL] [EOL] [EOL] def test_v1_event_payment_sent_failed_schema ( ) : [EOL] event = EventPaymentSentFailed ( payment_network_identifier = factories . make_payment_network_identifier ( ) , token_network_identifier = factories . make_address ( ) , identifier = [number] , target = factories . make_address ( ) , reason = [string] , ) [EOL] log_time = [string] [EOL] [EOL] timestamped = TimestampedEvent ( event , log_time ) [EOL] [EOL] dumped = EventPaymentSentFailedSchema ( ) . dump ( timestamped ) [EOL] [EOL] expected = { [string] : [string] , [string] : log_time , [string] : [string] } [EOL] [EOL] assert all ( dumped . data . get ( key ) == value for key , value in expected . items ( ) ) [EOL] [EOL] [EOL] def test_event_filter_for_payments ( ) : [EOL] token_network_identifier = factories . make_address ( ) [EOL] payment_network_identifier = factories . make_payment_network_identifier ( ) [EOL] identifier = [number] [EOL] target = factories . make_address ( ) [EOL] event = EventPaymentSentSuccess ( payment_network_identifier = payment_network_identifier , token_network_identifier = token_network_identifier , identifier = identifier , amount = [number] , target = target , ) [EOL] assert event_filter_for_payments ( event , token_network_identifier , None ) [EOL] assert event_filter_for_payments ( event , token_network_identifier , target ) [EOL] assert not event_filter_for_payments ( event , token_network_identifier , factories . make_address ( ) ) [EOL] [EOL] event = EventPaymentReceivedSuccess ( payment_network_identifier = payment_network_identifier , token_network_identifier = token_network_identifier , identifier = identifier , amount = [number] , initiator = target , ) [EOL] assert event_filter_for_payments ( event , token_network_identifier , None ) [EOL] assert event_filter_for_payments ( event , token_network_identifier , target ) [EOL] assert not event_filter_for_payments ( event , token_network_identifier , factories . make_address ( ) ) [EOL] [EOL] event = EventPaymentSentFailed ( payment_network_identifier = factories . make_payment_network_identifier ( ) , token_network_identifier = token_network_identifier , identifier = identifier , target = target , reason = [string] , ) [EOL] assert event_filter_for_payments ( event , token_network_identifier , None ) [EOL] assert event_filter_for_payments ( event , token_network_identifier , target ) [EOL] assert not event_filter_for_payments ( event , token_network_identifier , factories . make_address ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] from raiden . constants import EMPTY_MERKLE_ROOT [EOL] from raiden . tests . utils . factories import HOP1 , HOP2 , UNIT_SECRETHASH , make_block_hash [EOL] from raiden . transfer . events import ContractSendChannelBatchUnlock [EOL] from raiden . transfer . node import is_transaction_effect_satisfied , state_transition [EOL] from raiden . transfer . state_change import ( ContractReceiveChannelBatchUnlock , ContractReceiveChannelSettled , ) [EOL] [EOL] [EOL] def test_is_transaction_effect_satisfied ( chain_state , token_network_id , netting_channel_state ) : [EOL] canonical_identifier = netting_channel_state . canonical_identifier [EOL] assert token_network_id == canonical_identifier . token_network_address [EOL] transaction = ContractSendChannelBatchUnlock ( canonical_identifier = canonical_identifier , participant = netting_channel_state . partner_state . address , triggered_by_block_hash = make_block_hash ( ) , ) [EOL] state_change = ContractReceiveChannelBatchUnlock ( transaction_hash = UNIT_SECRETHASH , canonical_identifier = canonical_identifier , participant = HOP1 , partner = HOP2 , locksroot = EMPTY_MERKLE_ROOT , unlocked_amount = [number] , returned_tokens = [number] , block_number = [number] , block_hash = make_block_hash ( ) , ) [EOL] [comment] [EOL] assert not is_transaction_effect_satisfied ( chain_state , transaction , state_change ) [EOL] [EOL] [comment] [EOL] state_change . partner = netting_channel_state . partner_state . address [EOL] state_change . participant = netting_channel_state . our_state . address [EOL] assert not is_transaction_effect_satisfied ( chain_state , transaction , state_change ) [EOL] [comment] [EOL] state_change . participant = netting_channel_state . partner_state . address [EOL] state_change . partner = netting_channel_state . our_state . address [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert not is_transaction_effect_satisfied ( chain_state , transaction , state_change ) [EOL] [EOL] channel_settled = ContractReceiveChannelSettled ( transaction_hash = bytes ( [number] ) , canonical_identifier = canonical_identifier , our_onchain_locksroot = EMPTY_MERKLE_ROOT , partner_onchain_locksroot = EMPTY_MERKLE_ROOT , block_number = [number] , block_hash = make_block_hash ( ) , ) [EOL] [EOL] iteration = state_transition ( chain_state = chain_state , state_change = channel_settled ) [EOL] [EOL] assert is_transaction_effect_satisfied ( iteration . new_state , transaction , state_change ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import List [EOL] import typing [EOL] import raiden [EOL] import os . path [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from raiden . storage . sqlite import RAIDEN_DB_VERSION , SQLiteStorage [EOL] from raiden . utils . upgrades import UpgradeManager , UpgradeRecord [EOL] [EOL] [EOL] def test_transaction_commit ( tmp_path ) : [EOL] filename = f" [string] { RAIDEN_DB_VERSION } [string] " [EOL] storage = SQLiteStorage ( f"{ tmp_path } [string] { filename }" ) [EOL] [EOL] with storage . transaction ( ) : [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] [EOL] assert storage . get_version ( ) == [number] [EOL] [EOL] [EOL] def test_transaction_rollback ( tmp_path ) : [EOL] filename = f" [string] { RAIDEN_DB_VERSION } [string] " [EOL] db_path = os . path . join ( tmp_path , filename ) [EOL] storage = SQLiteStorage ( db_path ) [EOL] storage . update_version ( ) [EOL] [EOL] assert storage . get_version ( ) == RAIDEN_DB_VERSION [EOL] [EOL] with pytest . raises ( RuntimeError ) : [EOL] with storage . transaction ( ) : [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] raise RuntimeError ( ) [EOL] assert storage . get_version ( ) == RAIDEN_DB_VERSION [EOL] [EOL] [EOL] def test_upgrade_manager_transaction_rollback ( tmp_path , monkeypatch ) : [EOL] FORMAT = os . path . join ( tmp_path , [string] ) [EOL] [EOL] def failure ( ** kwargs ) : [comment] [EOL] raise RuntimeError ( ) [EOL] [EOL] [comment] [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( [string] , [number] ) [EOL] storage = SQLiteStorage ( FORMAT . format ( [number] ) ) [EOL] storage . update_version ( ) [EOL] del storage [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( [string] , [number] ) [EOL] upgrade_list = [ UpgradeRecord ( from_version = [number] , function = failure ) ] [EOL] m . setattr ( [string] , upgrade_list ) [EOL] manager = UpgradeManager ( FORMAT . format ( [number] ) ) [EOL] manager . run ( ) [EOL] [EOL] storage = SQLiteStorage ( FORMAT . format ( [number] ) ) [EOL] assert storage . get_version ( ) == [number] , [string] [EOL] [EOL] [EOL] def test_regression_delete_should_not_commit_the_upgrade_transaction ( tmp_path , monkeypatch ) : [EOL] FORMAT = os . path . join ( tmp_path , [string] ) [EOL] [EOL] def failure ( storage , ** kwargs ) : [comment] [EOL] storage . delete_state_changes ( [ [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( [string] , [number] ) [EOL] storage = SQLiteStorage ( FORMAT . format ( [number] ) ) [EOL] storage . update_version ( ) [EOL] del storage [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] [comment] [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( [string] , [number] ) [EOL] upgrade_list = [ UpgradeRecord ( from_version = [number] , function = failure ) ] [EOL] m . setattr ( [string] , upgrade_list ) [EOL] manager = UpgradeManager ( FORMAT . format ( [number] ) ) [EOL] manager . run ( ) [EOL] [EOL] storage = SQLiteStorage ( FORMAT . format ( [number] ) ) [EOL] assert storage . get_version ( ) == [number] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import pathlib [EOL] import typing [EOL] import raiden [EOL] import json [EOL] import os [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from unittest . mock import patch [EOL] [EOL] from eth_utils import to_canonical_address [EOL] [EOL] from raiden . storage . migrations . v21_to_v22 import ( SOURCE_VERSION , TARGET_VERSION , constraint_has_canonical_identifier_or_values_removed , upgrade_v21_to_v22 , walk_dicts , ) [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . tests . utils . mocks import MockRaidenService [EOL] from raiden . utils . upgrades import UpgradeManager , UpgradeRecord [EOL] [EOL] [EOL] def setup_storage ( db_path ) : [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] [EOL] state_changes_file = Path ( __file__ ) . parent / f" [string] { SOURCE_VERSION } [string] " [EOL] state_changes_data = json . loads ( state_changes_file . read_text ( ) ) [EOL] for state_change_record in state_changes_data : [EOL] storage . write_state_change ( state_change = json . dumps ( state_change_record [ [number] ] ) , log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) , ) [EOL] [EOL] events_file = Path ( __file__ ) . parent / f" [string] { SOURCE_VERSION } [string] " [EOL] events_data = json . loads ( events_file . read_text ( ) ) [EOL] event_tuples = [ ] [EOL] for event in events_data : [EOL] state_change_identifier = event [ [number] ] [EOL] event_data = json . dumps ( event [ [number] ] ) [EOL] log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) [EOL] event_tuples . append ( ( None , state_change_identifier , log_time , event_data ) ) [EOL] storage . write_events ( event_tuples ) [EOL] [EOL] chain_state_data = Path ( __file__ ) . parent / f" [string] { SOURCE_VERSION } [string] " [EOL] chain_state = chain_state_data . read_text ( ) [EOL] snapshots = json . loads ( chain_state ) [EOL] for identifier , statechange_id , data in zip ( * [ snapshots [ i : : [number] ] for i in range ( [number] ) ] ) : [EOL] cursor = storage . conn . cursor ( ) [EOL] cursor . execute ( [string] , ( identifier , statechange_id , json . dumps ( data ) ) , ) [EOL] storage . conn . commit ( ) [EOL] storage . conn . close ( ) [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] return storage [EOL] [EOL] [EOL] def test_upgrade_v21_to_v22 ( tmp_path ) : [EOL] address = to_canonical_address ( [string] ) [EOL] with patch ( [string] ) as latest_db_file : [EOL] old_db_filename = tmp_path / Path ( f" [string] { SOURCE_VERSION } [string] " ) [EOL] latest_db_file . return_value = str ( old_db_filename ) [EOL] storage = setup_storage ( str ( old_db_filename ) ) [EOL] with patch ( [string] , new = SOURCE_VERSION ) : [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] raiden_service_mock = MockRaidenService ( ) [EOL] raiden_service_mock . address = address [EOL] [EOL] db_path = tmp_path / Path ( f" [string] { TARGET_VERSION } [string] " ) [EOL] manager = UpgradeManager ( db_filename = str ( db_path ) , raiden = raiden_service_mock ) [EOL] with patch ( [string] , new = [ UpgradeRecord ( from_version = SOURCE_VERSION , function = upgrade_v21_to_v22 ) ] , ) : [EOL] manager . run ( ) [EOL] [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] for batch in storage . batch_query_event_records ( batch_size = [number] ) : [EOL] for event in batch : [EOL] walk_dicts ( event , constraint_has_canonical_identifier_or_values_removed ) [EOL] for batch in storage . batch_query_state_changes ( batch_size = [number] ) : [EOL] for state_change in batch : [EOL] walk_dicts ( state_change , constraint_has_canonical_identifier_or_values_removed ) [EOL] for snapshot in storage . get_snapshots ( ) : [EOL] walk_dicts ( snapshot , constraint_has_canonical_identifier_or_values_removed ) [EOL] [EOL] assert os . path . isfile ( str ( db_path ) ) [EOL] assert os . path . isfile ( str ( old_db_filename ) ) [EOL] os . unlink ( str ( db_path ) ) [EOL] os . unlink ( str ( old_db_filename ) ) [EOL] assert not os . path . exists ( str ( db_path ) ) [EOL] assert not os . path . exists ( str ( old_db_filename ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pathlib [EOL] import unittest [EOL] import typing [EOL] import raiden [EOL] import json [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from raiden . storage . migrations . v19_to_v20 import upgrade_v19_to_v20 [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . tests . utils . factories import make_32bytes , make_address [EOL] from raiden . tests . utils . mocks import MockRaidenService [EOL] from raiden . utils . serialization import serialize_bytes [EOL] from raiden . utils . upgrades import UpgradeManager , UpgradeRecord [EOL] [EOL] [EOL] def setup_storage ( db_path ) : [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] [EOL] state_changes_file = Path ( __file__ ) . parent / [string] [EOL] state_changes_data = json . loads ( state_changes_file . read_text ( ) ) [EOL] for state_change_record in state_changes_data : [EOL] storage . write_state_change ( state_change = json . dumps ( state_change_record [ [number] ] ) , log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) , ) [EOL] [EOL] chain_state_data = Path ( __file__ ) . parent / [string] [EOL] chain_state = chain_state_data . read_text ( ) [EOL] cursor = storage . conn . cursor ( ) [EOL] cursor . execute ( [string] , ( chain_state , ) , ) [EOL] storage . conn . commit ( ) [EOL] return storage [EOL] [EOL] [EOL] def test_upgrade_v19_to_v20 ( tmp_path ) : [EOL] old_db_filename = tmp_path / Path ( [string] ) [EOL] with patch ( [string] ) as latest_db_file : [EOL] latest_db_file . return_value = str ( old_db_filename ) [EOL] storage = setup_storage ( str ( old_db_filename ) ) [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] raiden_service_mock = MockRaidenService ( ) [EOL] [EOL] our_onchain_locksroot = make_32bytes ( ) [EOL] partner_onchain_locksroot = make_32bytes ( ) [EOL] [EOL] details = Mock ( ) [EOL] details . our_details . address = make_address ( ) [EOL] details . our_details . locksroot = our_onchain_locksroot [EOL] details . partner_details . address = make_address ( ) [EOL] details . partner_details . locksroot = partner_onchain_locksroot [EOL] [EOL] payment_channel = Mock ( ) [EOL] payment_channel . token_network . detail_participants . return_value = details [EOL] [EOL] payment_channel_func = Mock ( ) [EOL] payment_channel_func . return_value = payment_channel [EOL] [EOL] raiden_service_mock . chain . payment_channel = payment_channel_func [EOL] [EOL] db_path = tmp_path / Path ( [string] ) [EOL] manager = UpgradeManager ( db_filename = str ( db_path ) , raiden = raiden_service_mock ) [EOL] with patch ( [string] , new = [ UpgradeRecord ( from_version = [number] , function = upgrade_v19_to_v20 ) ] , ) : [EOL] manager . run ( ) [EOL] [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = [number] , filters = [ ( [string] , [string] ) ] , ) [EOL] for state_changes_batch in batch_query : [EOL] for state_change_record in state_changes_batch : [EOL] data = json . loads ( state_change_record . data ) [EOL] assert [string] in data [ [string] ] [ [string] ] [EOL] assert [string] in data [ [string] ] [ [string] ] [EOL] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = [number] , filters = [ ( [string] , [string] ) ] , ) [EOL] for state_changes_batch in batch_query : [EOL] for state_change_record in state_changes_batch : [EOL] data = json . loads ( state_change_record . data ) [EOL] assert data [ [string] ] == serialize_bytes ( our_onchain_locksroot ) [EOL] assert data [ [string] ] == serialize_bytes ( partner_onchain_locksroot ) [EOL] [EOL] batch_query = storage . batch_query_event_records ( batch_size = [number] , filters = [ ( [string] , [string] ) ] ) [EOL] for events_batch in batch_query : [EOL] for event_record in events_batch : [EOL] data = json . loads ( event_record . data ) [EOL] assert [string] in data [EOL] [EOL] _ , snapshot = storage . get_latest_state_snapshot ( ) [EOL] assert snapshot is not None [EOL] [EOL] snapshot = json . loads ( snapshot ) [EOL] [EOL] for payment_network in snapshot [ [string] ] . values ( ) : [EOL] for token_network in payment_network [ [string] ] : [EOL] for channel in token_network [ [string] ] . values ( ) : [EOL] channel_our_locksroot = channel [ [string] ] [ [string] ] [EOL] channel_partner_locksroot = channel [ [string] ] [ [string] ] [EOL] assert channel_our_locksroot == serialize_bytes ( our_onchain_locksroot ) [EOL] assert channel_partner_locksroot == serialize_bytes ( partner_onchain_locksroot ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import pathlib [EOL] import typing [EOL] import raiden [EOL] import json [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from unittest . mock import patch [EOL] [EOL] from raiden . storage . migrations . v18_to_v19 import upgrade_v18_to_v19 [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . tests . utils . migrations import create_fake_web3_for_block_hash [EOL] from raiden . utils . upgrades import UpgradeManager , UpgradeRecord [EOL] [EOL] [EOL] def setup_storage ( db_path ) : [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] [EOL] [comment] [EOL] state_changes_file = Path ( __file__ ) . parent / [string] [EOL] state_changes_data = json . loads ( state_changes_file . read_text ( ) ) [EOL] for state_change_record in state_changes_data : [EOL] storage . write_state_change ( state_change = json . dumps ( state_change_record [ [number] ] ) , log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) , ) [EOL] [EOL] [comment] [EOL] events_file = Path ( __file__ ) . parent / [string] [EOL] events_data = json . loads ( events_file . read_text ( ) ) [EOL] event_tuples = [ ] [EOL] for event in events_data : [EOL] state_change_identifier = event [ [number] ] [EOL] event_data = json . dumps ( event [ [number] ] ) [EOL] log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) [EOL] event_tuples . append ( ( None , state_change_identifier , log_time , event_data ) ) [EOL] storage . write_events ( event_tuples ) [EOL] [EOL] chain_state_data = Path ( __file__ ) . parent / [string] [EOL] chain_state = chain_state_data . read_text ( ) [EOL] cursor = storage . conn . cursor ( ) [EOL] cursor . execute ( [string] , ( chain_state , ) , ) [EOL] storage . conn . commit ( ) [EOL] [EOL] return storage [EOL] [EOL] [EOL] def test_upgrade_v18_to_v19 ( tmp_path ) : [EOL] old_db_filename = tmp_path / Path ( [string] ) [EOL] with patch ( [string] ) as latest_db_file : [EOL] latest_db_file . return_value = str ( old_db_filename ) [EOL] storage = setup_storage ( str ( old_db_filename ) ) [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] web3 , block_to_blockhash = create_fake_web3_for_block_hash ( number_of_blocks = [number] ) [EOL] db_path = tmp_path / Path ( [string] ) [EOL] manager = UpgradeManager ( db_filename = str ( db_path ) , web3 = web3 ) [EOL] with patch ( [string] , new = [ UpgradeRecord ( from_version = [number] , function = upgrade_v18_to_v19 ) ] , ) : [EOL] manager . run ( ) [EOL] [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] [comment] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = [number] , filters = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , ) [EOL] for state_changes_batch in batch_query : [EOL] for state_change_record in state_changes_batch : [EOL] data = json . loads ( state_change_record . data ) [EOL] affected_state_change = ( [string] in data [ [string] ] or [string] in data [ [string] ] ) [EOL] assert affected_state_change , [string] [EOL] assert [string] in data [EOL] block_number = int ( data [ [string] ] ) [EOL] assert block_to_blockhash [ block_number ] . hex ( ) == data [ [string] ] [EOL] [EOL] [comment] [EOL] event_records = [ ] [EOL] batch_query = storage . batch_query_event_records ( batch_size = [number] , filters = [ ( [string] , [string] ) ] ) [EOL] [EOL] for events_batch in batch_query : [EOL] event_records . extend ( events_batch ) [EOL] [EOL] assert len ( event_records ) [EOL] for event_record in event_records : [EOL] data = json . loads ( event_record . data ) [EOL] assert [string] in data [ [string] ] [EOL] assert [string] in data [EOL] [EOL] [comment] [EOL] [comment] [EOL] _ , snapshot = storage . get_latest_state_snapshot ( ) [EOL] snapshot_data = json . loads ( snapshot ) [EOL] assert [string] in snapshot_data [EOL] assert len ( snapshot_data [ [string] ] ) == [number] [EOL] for transaction_data in snapshot_data [ [string] ] : [EOL] assert [string] in transaction_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pathlib [EOL] import typing [EOL] import raiden [EOL] import json [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from unittest . mock import patch [EOL] [EOL] from raiden . storage . migrations . v17_to_v18 import upgrade_v17_to_v18 [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . tests . utils . migrations import create_fake_web3_for_block_hash [EOL] from raiden . utils . upgrades import UpgradeManager , UpgradeRecord [EOL] [EOL] [EOL] def setup_storage ( db_path ) : [EOL] [comment] [EOL] state_changes_file = Path ( __file__ ) . parent / [string] [EOL] state_changes_data = json . loads ( state_changes_file . read_text ( ) ) [EOL] action_init_chain_data = json . dumps ( state_changes_data [ [number] ] [ [number] ] ) [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] storage . write_state_change ( state_change = action_init_chain_data , log_time = datetime . utcnow ( ) . isoformat ( timespec = [string] ) , ) [EOL] [EOL] [comment] [EOL] chain_state_data = Path ( __file__ ) . parent / [string] [EOL] chain_state = chain_state_data . read_text ( ) [EOL] cursor = storage . conn . cursor ( ) [EOL] cursor . execute ( [string] , ( chain_state , ) , ) [EOL] storage . conn . commit ( ) [EOL] return storage [EOL] [EOL] [EOL] def test_upgrade_v17_to_v18 ( tmp_path ) : [EOL] old_db_filename = tmp_path / Path ( [string] ) [EOL] with patch ( [string] ) as latest_db_file : [EOL] latest_db_file . return_value = str ( old_db_filename ) [EOL] storage = setup_storage ( str ( old_db_filename ) ) [EOL] with patch ( [string] , new = [number] ) : [EOL] storage . update_version ( ) [EOL] storage . conn . close ( ) [EOL] [EOL] web3 , _ = create_fake_web3_for_block_hash ( number_of_blocks = [number] ) [EOL] db_path = tmp_path / Path ( [string] ) [EOL] manager = UpgradeManager ( db_filename = str ( db_path ) , web3 = web3 ) [EOL] [EOL] with patch ( [string] , new = [ UpgradeRecord ( from_version = [number] , function = upgrade_v17_to_v18 ) ] , ) : [EOL] manager . run ( ) [EOL] [EOL] storage = SQLiteStorage ( str ( db_path ) ) [EOL] _ , snapshot = storage . get_latest_state_snapshot ( ) [EOL] [EOL] snapshot_data = json . loads ( snapshot ) [EOL] secrethash = list ( snapshot_data [ [string] ] [ [string] ] . keys ( ) ) [ [number] ] [EOL] mediator_task = snapshot_data [ [string] ] [ [string] ] [ secrethash ] [EOL] assert mediator_task [ [string] ] [ [string] ] is not None [EOL] assert mediator_task [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from raiden . tests . integration . fixtures . blockchain import * [comment] [EOL] from raiden . tests . integration . fixtures . raiden_network import * [comment] [EOL] from raiden . tests . integration . fixtures . smartcontracts import * [comment] [EOL] from raiden . tests . integration . fixtures . transport import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import raiden [EOL] import gevent [EOL] import pytest [EOL] from eth_utils import to_hex [EOL] [EOL] from raiden . api . python import RaidenAPI [EOL] from raiden . messages import Unlock [EOL] from raiden . tests . utils . detect_failure import raise_on_failure [EOL] from raiden . tests . utils . events import search_for_item [EOL] from raiden . tests . utils . network import CHAIN [EOL] from raiden . tests . utils . protocol import WaitForMessage [EOL] from raiden . transfer . events import EventPaymentReceivedSuccess [EOL] from raiden . utils import random_secret , sha3 , wait_until [EOL] from raiden . utils . echo_node import EchoNode [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . skip ( [string] ) def test_event_transfer_received_success ( token_addresses , raiden_chain ) : [EOL] raise_on_failure ( raiden_chain , run_test_event_transfer_received_success , token_addresses = token_addresses , raiden_chain = raiden_chain , ) [EOL] [EOL] [EOL] def run_test_event_transfer_received_success ( token_addresses , raiden_chain ) : [EOL] sender_apps = raiden_chain [ : - [number] ] [EOL] target_app = raiden_chain [ - [number] ] [EOL] [EOL] token_address = token_addresses [ [number] ] [EOL] registry_address = target_app . raiden . default_registry . address [EOL] target_address = target_app . raiden . address [EOL] [EOL] message_handler = WaitForMessage ( ) [EOL] target_app . raiden . message_handler = message_handler [EOL] [EOL] wait_for = list ( ) [EOL] for amount , app in enumerate ( sender_apps , [number] ) : [EOL] secret = random_secret ( ) [EOL] [EOL] wait = message_handler . wait_for_message ( Unlock , { [string] : secret } ) [EOL] wait_for . append ( ( wait , app . raiden . address , amount ) ) [EOL] [EOL] RaidenAPI ( app . raiden ) . transfer_async ( registry_address = registry_address , token_address = token_address , amount = amount , identifier = amount , target = target_address , secret = to_hex ( secret ) , secrethash = to_hex ( sha3 ( secret ) ) , ) [EOL] [EOL] for wait , sender , amount in wait_for : [EOL] wait . wait ( ) [EOL] assert search_for_item ( target_app . raiden . wal . storage . get_events ( ) , EventPaymentReceivedSuccess , { [string] : amount , [string] : amount , [string] : sender , [string] : registry_address , } , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . skip ( [string] ) def test_echo_node_response ( token_addresses , raiden_chain , network_wait ) : [EOL] raise_on_failure ( raiden_chain , run_test_echo_node_response , token_addresses = token_addresses , raiden_chain = raiden_chain , network_wait = network_wait , ) [EOL] [EOL] [EOL] def run_test_echo_node_response ( token_addresses , raiden_chain , network_wait ) : [EOL] app0 , app1 , app2 , echo_app = raiden_chain [EOL] address_to_app = { app . raiden . address : app for app in raiden_chain } [EOL] token_address = token_addresses [ [number] ] [EOL] echo_api = RaidenAPI ( echo_app . raiden ) [EOL] [EOL] echo_node = EchoNode ( echo_api , token_address ) [EOL] echo_node . ready . wait ( timeout = [number] ) [EOL] assert echo_node . ready . is_set ( ) [EOL] expected = list ( ) [EOL] [EOL] [comment] [EOL] for num , app in enumerate ( [ app0 , app1 , app2 ] ) : [EOL] amount = [number] + num [EOL] payment_status = RaidenAPI ( app . raiden ) . transfer_async ( app . raiden . default_registry . address , token_address , amount , echo_app . raiden . address , [number] ** ( num + [number] ) , ) [EOL] payment_status . payment_done . wait ( timeout = [number] ) [EOL] expected . append ( amount ) [EOL] [EOL] while echo_node . num_handled_transfers < len ( expected ) : [EOL] gevent . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] def test_events ( handled_transfer ) : [EOL] app = address_to_app [ handled_transfer . initiator ] [EOL] events = RaidenAPI ( app . raiden ) . get_raiden_events_payment_history ( token_address = token_address ) [EOL] [EOL] received = { event . identifier : event for event in events if type ( event ) == EventPaymentReceivedSuccess } [EOL] [EOL] if len ( received ) != [number] : [EOL] return None [EOL] transfer = received . popitem ( ) [ [number] ] [EOL] [EOL] is_not_valid = ( transfer . initiator != echo_app . raiden . address or transfer . identifier != handled_transfer . identifier + transfer . amount ) [EOL] [EOL] if is_not_valid : [EOL] return None [EOL] return transfer [EOL] [EOL] for handled_transfer in echo_node . seen_transfers : [EOL] assert wait_until ( lambda : test_events ( handled_transfer ) , network_wait ) [EOL] [EOL] echo_node . stop ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . skip ( [string] ) def test_echo_node_lottery ( token_addresses , raiden_chain , network_wait ) : [EOL] raise_on_failure ( raiden_chain , run_test_echo_node_lottery , token_addresses = token_addresses , raiden_chain = raiden_chain , network_wait = network_wait , ) [EOL] [EOL] [EOL] def run_test_echo_node_lottery ( token_addresses , raiden_chain , network_wait ) : [EOL] app0 , app1 , app2 , app3 , echo_app , app4 , app5 , app6 = raiden_chain [EOL] address_to_app = { app . raiden . address : app for app in raiden_chain } [EOL] token_address = token_addresses [ [number] ] [EOL] echo_api = RaidenAPI ( echo_app . raiden ) [EOL] [EOL] echo_node = EchoNode ( echo_api , token_address ) [EOL] echo_node . ready . wait ( timeout = [number] ) [EOL] assert echo_node . ready . is_set ( ) [EOL] [EOL] expected = list ( ) [EOL] [EOL] [comment] [EOL] amount = [number] [EOL] for num , app in enumerate ( [ app0 , app1 , app2 , app3 , app4 , app5 ] ) : [EOL] payment_status = RaidenAPI ( app . raiden ) . transfer_async ( app . raiden . default_registry . address , token_address , amount , echo_app . raiden . address , [number] ** ( num + [number] ) , ) [EOL] payment_status . payment_done . wait ( timeout = [number] ) [EOL] expected . append ( amount ) [EOL] [EOL] [comment] [EOL] payment_status = ( RaidenAPI ( app5 . raiden ) . transfer_async ( app . raiden . default_registry . address , token_address , amount , echo_app . raiden . address , [number] ** [number] , ) . payment_done . wait ( timeout = [number] ) ) [EOL] [EOL] [comment] [EOL] pool_query_identifier = [number] [comment] [EOL] payment_status = ( RaidenAPI ( app5 . raiden ) . transfer_async ( app . raiden . default_registry . address , token_address , amount , echo_app . raiden . address , pool_query_identifier , ) . payment_done . wait ( timeout = [number] ) ) [EOL] expected . append ( amount ) [EOL] [EOL] [comment] [EOL] payment_status = ( RaidenAPI ( app6 . raiden ) . transfer_async ( app . raiden . default_registry . address , token_address , amount , echo_app . raiden . address , [number] ** [number] , ) . payment_done . wait ( timeout = [number] ) ) [EOL] expected . append ( amount ) [EOL] [EOL] while echo_node . num_handled_transfers < len ( expected ) : [EOL] gevent . sleep ( [number] ) [EOL] [EOL] def get_echoed_transfer ( sent_transfer ) : [EOL] [docstring] [EOL] app = address_to_app [ sent_transfer . initiator ] [EOL] events = RaidenAPI ( app . raiden ) . get_raiden_events_payment_history ( token_address = token_address ) [EOL] [EOL] def is_valid ( event ) : [EOL] return ( type ( event ) == EventPaymentReceivedSuccess [EOL] and event . initiator == echo_app . raiden . address [EOL] and event . identifier == sent_transfer . identifier + event . amount ) [EOL] [EOL] received = { event . identifier : event for event in events if is_valid ( event ) } [EOL] [EOL] if len ( received ) != [number] : [EOL] return None [EOL] return received . popitem ( ) [ [number] ] [EOL] [EOL] def received_is_of_size ( size ) : [EOL] [docstring] [EOL] received = { } [EOL] [comment] [EOL] for handled_transfer in echo_node . seen_transfers : [EOL] event = get_echoed_transfer ( handled_transfer ) [EOL] if not event : [EOL] continue [EOL] received [ event . identifier ] = event [EOL] if len ( received ) == size : [EOL] return received [EOL] [EOL] return None [EOL] [EOL] [comment] [EOL] received = wait_until ( lambda : received_is_of_size ( [number] ) , [number] * network_wait ) [EOL] assert received [EOL] [EOL] received = sorted ( received . values ( ) , key = lambda transfer : transfer . amount ) [EOL] [EOL] pool_query = received [ [number] ] [EOL] assert pool_query . amount == [number] [EOL] assert pool_query . identifier == pool_query_identifier + [number] [EOL] [EOL] winning_transfer = received [ [number] ] [EOL] assert winning_transfer . initiator == echo_app . raiden . address [EOL] assert winning_transfer . amount == [number] [EOL] assert ( winning_transfer . identifier - [number] ) % [number] == [number] [EOL] [EOL] echo_node . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , List [EOL] import typing [EOL] import raiden [EOL] import os [EOL] [EOL] import pytest [EOL] from web3 import HTTPProvider , Web3 [EOL] [EOL] from raiden . constants import Environment , EthClient [EOL] from raiden . network . blockchain_service import BlockChainService [EOL] from raiden . network . discovery import ContractDiscovery [EOL] from raiden . network . rpc . client import JSONRPCClient [EOL] from raiden . settings import DEVELOPMENT_CONTRACT_VERSION , RED_EYES_CONTRACT_VERSION [EOL] from raiden . tests . utils . eth_node import ( EthNodeDescription , GenesisDescription , run_private_blockchain , ) [EOL] from raiden . tests . utils . network import jsonrpc_services [EOL] from raiden . tests . utils . tests import cleanup_tasks [EOL] from raiden . utils import privatekey_to_address [EOL] from raiden_contracts . contract_manager import ContractManager , contracts_precompiled_path [EOL] [EOL] [comment] [EOL] [EOL] _ETH_LOGDIR = os . environ . get ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def endpoint_discovery_services ( blockchain_services , endpoint_registry_address ) : [EOL] return [ ContractDiscovery ( chain . node_address , chain . discovery ( endpoint_registry_address ) ) for chain in blockchain_services . blockchain_services ] [EOL] [EOL] [EOL] @ pytest . fixture def web3 ( blockchain_p2p_ports , blockchain_private_keys , blockchain_rpc_ports , blockchain_type , blockchain_extra_config , deploy_key , private_keys , random_marker , request , tmpdir , chain_id , ) : [EOL] [docstring] [EOL] [comment] [EOL] keys_to_fund = set ( private_keys ) [EOL] keys_to_fund . add ( deploy_key ) [EOL] keys_to_fund = sorted ( keys_to_fund ) [EOL] [EOL] if blockchain_type not in { client . value for client in EthClient } : [EOL] raise ValueError ( f" [string] { blockchain_type }" ) [EOL] [EOL] host = [string] [EOL] rpc_port = blockchain_rpc_ports [ [number] ] [EOL] endpoint = f" [string] { host } [string] { rpc_port }" [EOL] web3 = Web3 ( HTTPProvider ( endpoint ) ) [EOL] [EOL] assert len ( blockchain_private_keys ) == len ( blockchain_rpc_ports ) [EOL] assert len ( blockchain_private_keys ) == len ( blockchain_p2p_ports ) [EOL] [EOL] eth_nodes = [ EthNodeDescription ( private_key = key , rpc_port = rpc , p2p_port = p2p , miner = ( pos == [number] ) , extra_config = blockchain_extra_config , blockchain_type = blockchain_type , ) for pos , ( key , rpc , p2p ) in enumerate ( zip ( blockchain_private_keys , blockchain_rpc_ports , blockchain_p2p_ports ) ) ] [EOL] [EOL] accounts_to_fund = [ privatekey_to_address ( key ) for key in keys_to_fund ] [EOL] [EOL] base_datadir = str ( tmpdir ) [EOL] [EOL] if _ETH_LOGDIR : [EOL] base_logdir = os . path . join ( _ETH_LOGDIR , request . node . name , blockchain_type ) [EOL] else : [EOL] base_logdir = os . path . join ( base_datadir , [string] ) [EOL] [EOL] genesis_description = GenesisDescription ( prefunded_accounts = accounts_to_fund , chain_id = chain_id , random_marker = random_marker ) [EOL] eth_node_runner = run_private_blockchain ( web3 = web3 , eth_nodes = eth_nodes , base_datadir = base_datadir , log_dir = base_logdir , verbosity = [string] , genesis_description = genesis_description , ) [EOL] with eth_node_runner : [EOL] yield web3 [EOL] [EOL] cleanup_tasks ( ) [EOL] [EOL] [EOL] @ pytest . fixture def deploy_client ( blockchain_rpc_ports , deploy_key , web3 , blockchain_type ) : [EOL] if blockchain_type == [string] : [EOL] return JSONRPCClient ( web3 , deploy_key , gas_estimate_correction = lambda gas : [number] * gas ) [EOL] return JSONRPCClient ( web3 , deploy_key ) [EOL] [EOL] [EOL] @ pytest . fixture def contracts_path ( environment_type ) : [EOL] version = RED_EYES_CONTRACT_VERSION [EOL] if environment_type == Environment . DEVELOPMENT : [EOL] version = DEVELOPMENT_CONTRACT_VERSION [EOL] [EOL] return contracts_precompiled_path ( version ) [EOL] [EOL] [EOL] @ pytest . fixture def contract_manager ( contracts_path ) : [EOL] return ContractManager ( contracts_path ) [EOL] [EOL] [EOL] @ pytest . fixture def deploy_service ( deploy_key , deploy_client , contract_manager ) : [EOL] return BlockChainService ( jsonrpc_client = deploy_client , contract_manager = contract_manager ) [EOL] [EOL] [EOL] @ pytest . fixture def blockchain_services ( deploy_service , private_keys , secret_registry_address , service_registry_address , token_network_registry_address , web3 , contract_manager , ) : [EOL] return jsonrpc_services ( deploy_service = deploy_service , private_keys = private_keys , secret_registry_address = secret_registry_address , service_registry_address = service_registry_address , token_network_registry_address = token_network_registry_address , web3 = web3 , contract_manager = contract_manager , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from raiden . constants import DISCOVERY_DEFAULT_ROOM , PATH_FINDING_BROADCASTING_ROOM [EOL] from raiden . network . transport import MatrixTransport [EOL] from raiden . tests . fixtures . variables import TransportProtocol [EOL] from raiden . tests . utils . transport import generate_synapse_config , matrix_server_starter [EOL] [EOL] [EOL] @ pytest . fixture def public_and_private_rooms ( ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def synapse_config_generator ( ) : [EOL] with generate_synapse_config ( ) as generator : [EOL] yield generator [EOL] [EOL] [EOL] @ pytest . fixture def matrix_server_count ( ) : [EOL] return [number] [EOL] [EOL] [EOL] @ pytest . fixture def local_matrix_servers ( request , transport_protocol , matrix_server_count , synapse_config_generator , port_generator ) : [EOL] if transport_protocol is not TransportProtocol . MATRIX : [EOL] yield [ None ] [EOL] return [EOL] [EOL] starter = matrix_server_starter ( free_port_generator = port_generator , count = matrix_server_count , config_generator = synapse_config_generator , log_context = request . node . name , ) [EOL] with starter as server_urls : [EOL] yield server_urls [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . fixture def global_rooms ( ) : [EOL] [comment] [EOL] return [ DISCOVERY_DEFAULT_ROOM , PATH_FINDING_BROADCASTING_ROOM ] [EOL] [EOL] [EOL] @ pytest . fixture def matrix_transports ( local_matrix_servers , retries_before_backoff , retry_interval , private_rooms , number_of_transports , global_rooms , ) : [EOL] transports = [ ] [EOL] for transport_index in range ( number_of_transports ) : [EOL] server = local_matrix_servers [ transport_index % len ( local_matrix_servers ) ] [EOL] transports . append ( MatrixTransport ( { [string] : global_rooms , [string] : retries_before_backoff , [string] : retry_interval , [string] : server , [string] : server . netloc , [string] : local_matrix_servers , [string] : private_rooms [ transport_index ] , } ) ) [EOL] [EOL] yield transports [EOL] [EOL] for transport in transports : [EOL] transport . stop ( ) [EOL] [EOL] for transport in transports : [EOL] [comment] [EOL] if transport . _started : [EOL] transport . get ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Union , List , Any , Literal , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] import gevent [EOL] import pytest [EOL] [EOL] from raiden . api . python import RaidenAPI [EOL] from raiden . tests . utils . detect_failure import raise_on_failure [EOL] from raiden . tests . utils . events import ( raiden_events_search_for_item , search_for_item , wait_for_raiden_event , wait_for_state_change , ) [EOL] from raiden . tests . utils . network import CHAIN [EOL] from raiden . tests . utils . protocol import ( dont_handle_lock_expired_mock , dont_handle_node_change_network_state , ) [EOL] from raiden . tests . utils . transfer import ( assert_synced_channel_state , get_channelstate , transfer , wait_assert , ) [EOL] from raiden . transfer import channel , views [EOL] from raiden . transfer . mediated_transfer . events import ( SendLockedTransfer , SendLockExpired , SendRefundTransfer , ) [EOL] from raiden . transfer . mediated_transfer . state_change import ReceiveLockExpired [EOL] from raiden . transfer . state_change import ContractReceiveChannelBatchUnlock , ReceiveProcessed [EOL] from raiden . transfer . views import state_from_raiden [EOL] from raiden . waiting import wait_for_block , wait_for_settle [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) def test_refund_messages ( raiden_chain , token_addresses , deposit , network_wait ) : [EOL] raise_on_failure ( raiden_chain , run_test_refund_messages , raiden_chain = raiden_chain , token_addresses = token_addresses , deposit = deposit , network_wait = network_wait , ) [EOL] [EOL] [EOL] def run_test_refund_messages ( raiden_chain , token_addresses , deposit , network_wait ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app0 , app1 , app2 = raiden_chain [comment] [EOL] token_address = token_addresses [ [number] ] [EOL] payment_network_identifier = app0 . raiden . default_registry . address [EOL] token_network_identifier = views . get_token_network_identifier_by_token_address ( views . state_from_app ( app0 ) , payment_network_identifier , token_address ) [EOL] [EOL] [comment] [EOL] exhaust_amount = deposit [EOL] transfer ( initiator_app = app1 , target_app = app2 , token_address = token_address , amount = exhaust_amount , identifier = [number] , ) [EOL] [EOL] refund_amount = deposit // [number] [EOL] identifier = [number] [EOL] payment_status = app0 . raiden . mediated_transfer_async ( token_network_identifier , refund_amount , app2 . raiden . address , identifier ) [EOL] msg = [string] [EOL] assert payment_status . payment_done . wait ( ) is False , msg [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] send_lockedtransfer = raiden_events_search_for_item ( app0 . raiden , SendLockedTransfer , { [string] : { [string] : { [string] : refund_amount } } } ) [EOL] assert send_lockedtransfer [EOL] [EOL] send_refundtransfer = raiden_events_search_for_item ( app1 . raiden , SendRefundTransfer , { } ) [EOL] assert send_refundtransfer [EOL] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit , [ send_lockedtransfer . transfer . lock ] , app1 , deposit , [ send_refundtransfer . transfer . lock ] , ) [EOL] [EOL] [comment] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , [number] , [ ] , app2 , deposit * [number] , [ ] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) def test_refund_transfer ( raiden_chain , number_of_nodes , token_addresses , deposit , network_wait , retry_timeout , skip_if_not_matrix , ) : [EOL] raise_on_failure ( raiden_chain , run_test_refund_transfer , raiden_chain = raiden_chain , number_of_nodes = number_of_nodes , token_addresses = token_addresses , deposit = deposit , network_wait = network_wait , retry_timeout = retry_timeout , ) [EOL] [EOL] [EOL] def run_test_refund_transfer ( raiden_chain , number_of_nodes , token_addresses , deposit , network_wait , retry_timeout ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app0 , app1 , app2 = raiden_chain [EOL] token_address = token_addresses [ [number] ] [EOL] payment_network_identifier = app0 . raiden . default_registry . address [EOL] token_network_identifier = views . get_token_network_identifier_by_token_address ( views . state_from_app ( app0 ) , payment_network_identifier , token_address ) [EOL] [EOL] [comment] [EOL] identifier_path = [number] [EOL] amount_path = [number] [EOL] transfer ( initiator_app = app0 , target_app = app2 , token_address = token_address , amount = amount_path , identifier = identifier_path , timeout = network_wait * number_of_nodes , ) [EOL] [EOL] [comment] [EOL] identifier_drain = [number] [EOL] amount_drain = deposit * [number] // [number] [EOL] transfer ( initiator_app = app1 , target_app = app2 , token_address = token_address , amount = amount_drain , identifier = identifier_drain , timeout = network_wait , ) [EOL] [EOL] [comment] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit - amount_path , [ ] , app1 , deposit + amount_path , [ ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , deposit - amount_path - amount_drain , [ ] , app2 , deposit + amount_path + amount_drain , [ ] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] identifier_refund = [number] [EOL] amount_refund = [number] [EOL] payment_status = app0 . raiden . mediated_transfer_async ( token_network_identifier , amount_refund , app2 . raiden . address , identifier_refund ) [EOL] msg = [string] [EOL] assert payment_status . payment_done . wait ( ) is False , msg [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] send_locked = raiden_events_search_for_item ( app0 . raiden , SendLockedTransfer , { [string] : { [string] : { [string] : amount_refund } } } ) [EOL] assert send_locked [EOL] secrethash = send_locked . transfer . lock . secrethash [EOL] [EOL] send_refund = raiden_events_search_for_item ( app1 . raiden , SendRefundTransfer , { } ) [EOL] assert send_refund [EOL] [EOL] lock = send_locked . transfer . lock [EOL] refund_lock = send_refund . transfer . lock [EOL] assert lock . amount == refund_lock . amount [EOL] assert lock . secrethash [EOL] assert lock . expiration [EOL] assert lock . secrethash == refund_lock . secrethash [EOL] [EOL] [comment] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit - amount_path , [ lock ] , app1 , deposit + amount_path , [ refund_lock ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , deposit - amount_path - amount_drain , [ ] , app2 , deposit + amount_path + amount_drain , [ ] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert secrethash in state_from_raiden ( app0 . raiden ) . payment_mapping . secrethashes_to_task [EOL] [EOL] [comment] [EOL] with dont_handle_lock_expired_mock ( app0 ) : [EOL] wait_for_block ( raiden = app0 . raiden , block_number = channel . get_sender_expiration_threshold ( lock ) + [number] , retry_timeout = retry_timeout , ) [EOL] [comment] [EOL] [comment] [EOL] assert secrethash in state_from_raiden ( app0 . raiden ) . payment_mapping . secrethashes_to_task [EOL] [EOL] [comment] [EOL] send_lock_expired = raiden_events_search_for_item ( app1 . raiden , SendLockExpired , { [string] : secrethash } ) [EOL] assert send_lock_expired [EOL] [comment] [EOL] state_changes = app0 . raiden . wal . storage . get_statechanges_by_identifier ( [number] , [string] ) [EOL] assert not search_for_item ( state_changes , ReceiveLockExpired , { [string] : secrethash } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] receive_lock_expired = wait_for_state_change ( app0 . raiden , ReceiveLockExpired , { [string] : secrethash } , retry_timeout ) [EOL] [comment] [EOL] wait_for_state_change ( app1 . raiden , ReceiveProcessed , { [string] : receive_lock_expired . message_identifier } , retry_timeout , ) [EOL] [EOL] [comment] [EOL] chain_state1 = views . state_from_app ( app1 ) [EOL] queues1 = views . get_all_messagequeues ( chain_state = chain_state1 ) [EOL] result = [ ( queue_id , queue ) for queue_id , queue in queues1 . items ( ) if queue_id . recipient == app0 . raiden . address and queue ] [EOL] assert not result [EOL] [EOL] [comment] [EOL] wait_for_block ( raiden = app0 . raiden , block_number = app0 . raiden . get_block_number ( ) + [number] , retry_timeout = retry_timeout , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert secrethash not in state_from_raiden ( app0 . raiden ) . payment_mapping . secrethashes_to_task [EOL] assert secrethash not in state_from_raiden ( app1 . raiden ) . payment_mapping . secrethashes_to_task [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) def test_different_view_of_last_bp_during_unlock ( raiden_chain , number_of_nodes , token_addresses , deposit , network_wait , retry_timeout , skip_if_not_matrix , blockchain_type , ) : [EOL] raise_on_failure ( raiden_chain , run_test_different_view_of_last_bp_during_unlock , raiden_chain = raiden_chain , number_of_nodes = number_of_nodes , token_addresses = token_addresses , deposit = deposit , network_wait = network_wait , retry_timeout = retry_timeout , blockchain_type = blockchain_type , ) [EOL] [EOL] [EOL] def run_test_different_view_of_last_bp_during_unlock ( raiden_chain , number_of_nodes , token_addresses , deposit , network_wait , retry_timeout , blockchain_type , ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app0 , app1 , app2 = raiden_chain [EOL] token_address = token_addresses [ [number] ] [EOL] payment_network_identifier = app0 . raiden . default_registry . address [EOL] token_network_identifier = views . get_token_network_identifier_by_token_address ( views . state_from_app ( app0 ) , payment_network_identifier , token_address ) [EOL] token_proxy = app0 . raiden . chain . token ( token_address ) [EOL] initial_balance0 = token_proxy . balance_of ( app0 . raiden . address ) [EOL] initial_balance1 = token_proxy . balance_of ( app1 . raiden . address ) [EOL] [EOL] [comment] [EOL] identifier_path = [number] [EOL] amount_path = [number] [EOL] transfer ( initiator_app = app0 , target_app = app2 , token_address = token_address , amount = amount_path , identifier = identifier_path , timeout = network_wait * number_of_nodes , ) [EOL] [EOL] [comment] [EOL] identifier_drain = [number] [EOL] amount_drain = deposit * [number] // [number] [EOL] transfer ( initiator_app = app1 , target_app = app2 , token_address = token_address , amount = amount_drain , identifier = identifier_drain , timeout = network_wait , ) [EOL] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit - amount_path , [ ] , app1 , deposit + amount_path , [ ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , deposit - amount_path - amount_drain , [ ] , app2 , deposit + amount_path + amount_drain , [ ] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] identifier_refund = [number] [EOL] amount_refund = [number] [EOL] payment_status = app0 . raiden . mediated_transfer_async ( token_network_identifier , amount_refund , app2 . raiden . address , identifier_refund ) [EOL] msg = [string] [EOL] assert payment_status . payment_done . wait ( ) is False , msg [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] send_locked = raiden_events_search_for_item ( app0 . raiden , SendLockedTransfer , { [string] : { [string] : { [string] : amount_refund } } } ) [EOL] assert send_locked [EOL] secrethash = send_locked . transfer . lock . secrethash [EOL] [EOL] send_refund = raiden_events_search_for_item ( app1 . raiden , SendRefundTransfer , { } ) [EOL] assert send_refund [EOL] [EOL] lock = send_locked . transfer . lock [EOL] refund_lock = send_refund . transfer . lock [EOL] assert lock . amount == refund_lock . amount [EOL] assert lock . secrethash [EOL] assert lock . expiration [EOL] assert lock . secrethash == refund_lock . secrethash [EOL] [EOL] [comment] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit - amount_path , [ lock ] , app1 , deposit + amount_path , [ refund_lock ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , deposit - amount_path - amount_drain , [ ] , app2 , deposit + amount_path + amount_drain , [ ] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert secrethash in state_from_raiden ( app0 . raiden ) . payment_mapping . secrethashes_to_task [EOL] [EOL] with dont_handle_node_change_network_state ( ) : [EOL] [comment] [EOL] app1 . raiden . stop ( ) [EOL] app1 . raiden . get ( ) [EOL] assert not app1 . raiden [EOL] [EOL] [comment] [EOL] wait_for_block ( raiden = app0 . raiden , block_number = channel . get_sender_expiration_threshold ( lock ) + [number] , retry_timeout = retry_timeout , ) [EOL] [EOL] [comment] [EOL] wait_for_raiden_event ( app0 . raiden , SendLockExpired , { [string] : secrethash } , retry_timeout ) [EOL] [EOL] [comment] [EOL] RaidenAPI ( app0 . raiden ) . channel_close ( registry_address = payment_network_identifier , token_address = token_address , partner_address = app1 . raiden . address , ) [EOL] [EOL] count = [number] [EOL] original_update = app1 . raiden . raiden_event_handler . handle_contract_send_channelupdate [EOL] [EOL] def patched_update ( raiden , event ) : [EOL] nonlocal count [EOL] count += [number] [EOL] original_update ( raiden , event ) [EOL] [EOL] app1 . raiden . raiden_event_handler . handle_contract_send_channelupdate = patched_update [EOL] [comment] [EOL] app1 . raiden . start ( ) [EOL] [comment] [EOL] assert count == [number] , [string] [EOL] channel_identifier = get_channelstate ( app0 , app1 , token_network_identifier ) . identifier [EOL] [EOL] [comment] [EOL] wait_for_settle ( raiden = app0 . raiden , payment_network_id = payment_network_identifier , token_address = token_address , channel_ids = [ channel_identifier ] , retry_timeout = app0 . raiden . alarm . sleep_time , ) [EOL] [EOL] timeout = [number] if blockchain_type == [string] else [number] [EOL] with gevent . Timeout ( timeout ) : [EOL] unlock_app0 = wait_for_state_change ( app0 . raiden , ContractReceiveChannelBatchUnlock , { [string] : app0 . raiden . address } , retry_timeout , ) [EOL] assert unlock_app0 . returned_tokens == [number] [EOL] with gevent . Timeout ( timeout ) : [EOL] unlock_app1 = wait_for_state_change ( app1 . raiden , ContractReceiveChannelBatchUnlock , { [string] : app1 . raiden . address } , retry_timeout , ) [EOL] assert unlock_app1 . returned_tokens == [number] [EOL] final_balance0 = token_proxy . balance_of ( app0 . raiden . address ) [EOL] final_balance1 = token_proxy . balance_of ( app1 . raiden . address ) [EOL] [EOL] assert final_balance0 - deposit - initial_balance0 == - [number] [EOL] assert final_balance1 - deposit - initial_balance1 == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ [number] ] ) @ pytest . mark . parametrize ( [string] , [ CHAIN ] ) def test_refund_transfer_after_2nd_hop ( raiden_chain , number_of_nodes , token_addresses , deposit , network_wait ) : [EOL] raise_on_failure ( raiden_chain , run_test_refund_transfer_after_2nd_hop , raiden_chain = raiden_chain , number_of_nodes = number_of_nodes , token_addresses = token_addresses , deposit = deposit , network_wait = network_wait , ) [EOL] [EOL] [EOL] def run_test_refund_transfer_after_2nd_hop ( raiden_chain , number_of_nodes , token_addresses , deposit , network_wait ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app0 , app1 , app2 , app3 = raiden_chain [EOL] token_address = token_addresses [ [number] ] [EOL] payment_network_identifier = app0 . raiden . default_registry . address [EOL] token_network_identifier = views . get_token_network_identifier_by_token_address ( views . state_from_app ( app0 ) , payment_network_identifier , token_address ) [EOL] [EOL] [comment] [EOL] identifier_path = [number] [EOL] amount_path = [number] [EOL] transfer ( initiator_app = app0 , target_app = app3 , token_address = token_address , amount = amount_path , identifier = identifier_path , timeout = network_wait * number_of_nodes , ) [EOL] [EOL] [comment] [EOL] identifier_drain = [number] [EOL] amount_drain = deposit * [number] // [number] [EOL] transfer ( initiator_app = app2 , target_app = app3 , token_address = token_address , amount = amount_drain , identifier = identifier_drain , timeout = network_wait , ) [EOL] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit - amount_path , [ ] , app1 , deposit + amount_path , [ ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , deposit - amount_path , [ ] , app2 , deposit + amount_path , [ ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app2 , deposit - amount_path - amount_drain , [ ] , app3 , deposit + amount_path + amount_drain , [ ] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] identifier_refund = [number] [EOL] amount_refund = [number] [EOL] payment_status = app0 . raiden . mediated_transfer_async ( token_network_identifier , amount_refund , app3 . raiden . address , identifier_refund ) [EOL] msg = [string] [EOL] assert payment_status . payment_done . wait ( ) is False , msg [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] send_locked1 = raiden_events_search_for_item ( app0 . raiden , SendLockedTransfer , { [string] : { [string] : { [string] : amount_refund } } } ) [EOL] assert send_locked1 [EOL] [EOL] send_refund1 = raiden_events_search_for_item ( app1 . raiden , SendRefundTransfer , { } ) [EOL] assert send_refund1 [EOL] [EOL] lock1 = send_locked1 . transfer . lock [EOL] refund_lock1 = send_refund1 . transfer . lock [EOL] assert lock1 . amount == refund_lock1 . amount [EOL] assert lock1 . secrethash == refund_lock1 . secrethash [EOL] [EOL] send_locked2 = raiden_events_search_for_item ( app1 . raiden , SendLockedTransfer , { [string] : { [string] : { [string] : amount_refund } } } ) [EOL] assert send_locked2 [EOL] [EOL] send_refund2 = raiden_events_search_for_item ( app2 . raiden , SendRefundTransfer , { } ) [EOL] assert send_refund2 [EOL] [EOL] lock2 = send_locked2 . transfer . lock [EOL] refund_lock2 = send_refund2 . transfer . lock [EOL] assert lock2 . amount == refund_lock2 . amount [EOL] assert lock2 . secrethash [EOL] assert lock2 . expiration [EOL] [EOL] [comment] [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app0 , deposit - amount_path , [ lock1 ] , app1 , deposit + amount_path , [ refund_lock1 ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app1 , deposit - amount_path , [ lock2 ] , app2 , deposit + amount_path , [ refund_lock2 ] , ) [EOL] with gevent . Timeout ( network_wait ) : [EOL] wait_assert ( assert_synced_channel_state , token_network_identifier , app2 , deposit - amount_path - amount_drain , [ ] , app3 , deposit + amount_path + amount_drain , [ ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] from eth_utils import is_same_address , to_canonical_address [EOL] [EOL] from raiden . constants import ( RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT , RED_EYES_PER_TOKEN_NETWORK_LIMIT , ) [EOL] from raiden . exceptions import AddressWithoutCode , InvalidToken , RaidenRecoverableError [EOL] from raiden . network . proxies . token import Token [EOL] from raiden . network . proxies . token_network_registry import TokenNetworkRegistry [EOL] from raiden . tests . utils . factories import make_address [EOL] from raiden . tests . utils . smartcontracts import deploy_token [EOL] from raiden_contracts . constants import TEST_SETTLE_TIMEOUT_MAX , TEST_SETTLE_TIMEOUT_MIN [EOL] [EOL] [EOL] def test_token_network_registry ( deploy_client , contract_manager , token_network_registry_address ) : [EOL] registry_address = to_canonical_address ( token_network_registry_address ) [EOL] [EOL] token_network_registry_proxy = TokenNetworkRegistry ( jsonrpc_client = deploy_client , registry_address = registry_address , contract_manager = contract_manager , ) [EOL] [EOL] assert token_network_registry_proxy . settlement_timeout_min ( ) == TEST_SETTLE_TIMEOUT_MIN [EOL] assert token_network_registry_proxy . settlement_timeout_max ( ) == TEST_SETTLE_TIMEOUT_MAX [EOL] [EOL] bad_token_address = make_address ( ) [EOL] [comment] [EOL] with pytest . raises ( AddressWithoutCode ) : [EOL] token_network_registry_proxy . add_token_with_limits ( token_address = bad_token_address , channel_participant_deposit_limit = RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT , token_network_deposit_limit = RED_EYES_PER_TOKEN_NETWORK_LIMIT , ) [EOL] [comment] [EOL] test_token = deploy_token ( deploy_client = deploy_client , contract_manager = contract_manager , initial_amount = [number] , decimals = [number] , token_name = [string] , token_symbol = [string] , ) [EOL] [EOL] test_token_address = to_canonical_address ( test_token . contract . address ) [EOL] [comment] [EOL] [EOL] with patch . object ( Token , [string] , return_value = [string] ) : [EOL] with pytest . raises ( InvalidToken ) : [EOL] token_network_registry_proxy . add_token_with_limits ( token_address = test_token_address , channel_participant_deposit_limit = RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT , token_network_deposit_limit = RED_EYES_PER_TOKEN_NETWORK_LIMIT , ) [EOL] [EOL] event_filter = token_network_registry_proxy . tokenadded_filter ( ) [EOL] token_network_address = token_network_registry_proxy . add_token_with_limits ( token_address = test_token_address , channel_participant_deposit_limit = RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT , token_network_deposit_limit = RED_EYES_PER_TOKEN_NETWORK_LIMIT , ) [EOL] [EOL] with pytest . raises ( RaidenRecoverableError ) as exc : [EOL] token_network_address = token_network_registry_proxy . add_token_with_limits ( token_address = test_token_address , channel_participant_deposit_limit = RED_EYES_PER_CHANNEL_PARTICIPANT_LIMIT , token_network_deposit_limit = RED_EYES_PER_TOKEN_NETWORK_LIMIT , ) [EOL] [EOL] assert [string] in str ( exc ) [EOL] [EOL] logs = event_filter . get_all_entries ( ) [EOL] assert len ( logs ) == [number] [EOL] decoded_event = token_network_registry_proxy . proxy . decode_event ( logs [ [number] ] ) [EOL] assert is_same_address ( decoded_event [ [string] ] [ [string] ] , test_token . contract . address ) [EOL] assert is_same_address ( decoded_event [ [string] ] [ [string] ] , token_network_address ) [EOL] [comment] [EOL] assert token_network_registry_proxy . get_token_network ( bad_token_address ) is None [EOL] assert is_same_address ( token_network_registry_proxy . get_token_network ( test_token_address ) , token_network_address ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] assert token_network_registry_proxy . get_token_network ( None ) is None [EOL] [EOL] assert token_network_registry_proxy . get_token_network ( bad_token_address ) is None [EOL] assert token_network_registry_proxy . get_token_network ( token_network_address ) is None [EOL] assert token_network_registry_proxy . get_token_network ( test_token_address ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import unittest [EOL] import typing [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import pytest [EOL] import requests [EOL] from eth_utils import is_checksum_address , to_checksum_address [EOL] [EOL] from raiden . constants import RoutingMode [EOL] from raiden . network . pathfinding import configure_pfs_or_exit , get_random_service [EOL] from raiden . tests . utils . factories import HOP1 [EOL] from raiden . tests . utils . smartcontracts import deploy_service_registry_and_set_urls [EOL] from raiden . utils import privatekey_to_address [EOL] [EOL] [EOL] def test_service_registry_random_pfs ( service_registry_address , private_keys , web3 , contract_manager ) : [EOL] addresses = [ to_checksum_address ( privatekey_to_address ( key ) ) for key in private_keys ] [EOL] c1_service_proxy , urls = deploy_service_registry_and_set_urls ( private_keys = private_keys , web3 = web3 , contract_manager = contract_manager , service_registry_address = service_registry_address , ) [EOL] assert c1_service_proxy . service_count ( [string] ) == [number] [EOL] [EOL] [comment] [EOL] for idx , address in enumerate ( addresses ) : [EOL] assert c1_service_proxy . get_service_url ( [string] , address ) == urls [ idx ] [EOL] [comment] [EOL] assert c1_service_proxy . get_service_url ( [string] , to_checksum_address ( HOP1 ) ) is None [EOL] [EOL] [comment] [EOL] for idx , address in enumerate ( addresses ) : [EOL] assert c1_service_proxy . get_service_address ( [string] , idx ) == address [EOL] [EOL] [comment] [EOL] assert not c1_service_proxy . get_service_address ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] assert get_random_service ( c1_service_proxy , [string] ) in urls [EOL] [EOL] [EOL] def test_configure_pfs ( service_registry_address , private_keys , web3 , contract_manager ) : [EOL] service_proxy , urls = deploy_service_registry_and_set_urls ( private_keys = private_keys , web3 = web3 , contract_manager = contract_manager , service_registry_address = service_registry_address , ) [EOL] json_data = { [string] : [number] , [string] : { [string] : [number] , [string] : [string] , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] response = Mock ( ) [EOL] response . configure_mock ( status_code = [number] ) [EOL] response . json = Mock ( return_value = json_data ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) : [EOL] config = configure_pfs_or_exit ( pfs_address = None , routing_mode = RoutingMode . BASIC , service_registry = service_proxy ) [EOL] [EOL] [comment] [EOL] with patch . object ( requests , [string] , return_value = response ) : [EOL] config = configure_pfs_or_exit ( pfs_address = [string] , routing_mode = RoutingMode . PFS , service_registry = service_proxy ) [EOL] assert config . url in urls [EOL] assert is_checksum_address ( config . eth_address ) [EOL] [EOL] [comment] [EOL] given_address = [string] [EOL] with patch . object ( requests , [string] , return_value = response ) : [EOL] config = configure_pfs_or_exit ( pfs_address = given_address , routing_mode = RoutingMode . PFS , service_registry = service_proxy ) [EOL] assert config . url == given_address [EOL] assert config . eth_address == json_data [ [string] ] [EOL] assert config . fee == json_data [ [string] ] [EOL] [EOL] [comment] [EOL] response = Mock ( ) [EOL] response . configure_mock ( status_code = [number] ) [EOL] bad_address = [string] [EOL] with pytest . raises ( SystemExit ) : [EOL] with patch . object ( requests , [string] , side_effect = requests . RequestException ( ) ) : [EOL] [comment] [EOL] config = configure_pfs_or_exit ( pfs_address = bad_address , routing_mode = RoutingMode . PFS , service_registry = service_proxy , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] import raiden [EOL] import pytest [EOL] from eth_utils import to_checksum_address [EOL] [EOL] from raiden . exceptions import ReplacementTransactionUnderpriced , TransactionAlreadyPending [EOL] from raiden . network . rpc . client import JSONRPCClient [EOL] from raiden . tests . utils . smartcontracts import deploy_rpc_test_contract [EOL] from raiden . utils import safe_gas_limit [EOL] [EOL] [EOL] def make_fixed_gas_price_strategy ( gas_price ) : [EOL] def fixed_gas_price_strategy ( _web3 , _transaction_params ) : [EOL] return gas_price [EOL] [EOL] return fixed_gas_price_strategy [EOL] [EOL] [EOL] def make_decreasing_gas_price_strategy ( gas_price ) : [EOL] [comment] [EOL] def increasing_gas_price_strategy ( web3 , _transaction_params ) : [EOL] old_counter = getattr ( web3 , [string] , gas_price ) [EOL] web3 . counter = old_counter - [number] [EOL] return old_counter [EOL] [EOL] return increasing_gas_price_strategy [EOL] [EOL] [EOL] def test_duplicated_transaction_same_gas_price_raises ( deploy_client ) : [EOL] [docstring] [EOL] gas_price = [number] [EOL] gas_price_strategy = make_fixed_gas_price_strategy ( gas_price ) [EOL] deploy_client . web3 . eth . setGasPriceStrategy ( gas_price_strategy ) [EOL] contract_proxy = deploy_rpc_test_contract ( deploy_client , [string] ) [EOL] [EOL] address = contract_proxy . contract_address [EOL] assert len ( deploy_client . web3 . eth . getCode ( to_checksum_address ( address ) ) ) > [number] [EOL] [EOL] second_client = JSONRPCClient ( web3 = deploy_client . web3 , privkey = deploy_client . privkey ) [EOL] [EOL] second_proxy = second_client . new_contract_proxy ( contract_proxy . contract . abi , contract_proxy . contract_address ) [EOL] [EOL] check_block = deploy_client . get_checking_block ( ) [EOL] gas_estimate = contract_proxy . estimate_gas ( check_block , [string] ) [EOL] assert gas_estimate , [string] [EOL] startgas = safe_gas_limit ( gas_estimate ) [EOL] [EOL] contract_proxy . transact ( [string] , startgas ) [EOL] with pytest . raises ( TransactionAlreadyPending ) : [EOL] second_proxy . transact ( [string] , startgas ) [EOL] [EOL] [EOL] def test_duplicated_transaction_different_gas_price_raises ( deploy_client ) : [EOL] [docstring] [EOL] gas_price = [number] [EOL] deploy_client . web3 . eth . setGasPriceStrategy ( make_decreasing_gas_price_strategy ( gas_price ) ) [EOL] contract_proxy = deploy_rpc_test_contract ( deploy_client , [string] ) [EOL] [EOL] address = contract_proxy . contract_address [EOL] assert len ( deploy_client . web3 . eth . getCode ( to_checksum_address ( address ) ) ) > [number] [EOL] [EOL] second_client = JSONRPCClient ( web3 = deploy_client . web3 , privkey = deploy_client . privkey ) [EOL] [EOL] second_proxy = second_client . new_contract_proxy ( contract_proxy . contract . abi , contract_proxy . contract_address ) [EOL] [EOL] check_block = deploy_client . get_checking_block ( ) [EOL] startgas = safe_gas_limit ( contract_proxy . estimate_gas ( check_block , [string] ) ) [EOL] [EOL] with pytest . raises ( ReplacementTransactionUnderpriced ) : [EOL] second_proxy . transact ( [string] , startgas ) [EOL] contract_proxy . transact ( [string] , startgas ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import pytest [EOL] from eth_utils import decode_hex , to_checksum_address [EOL] [EOL] from raiden . tests . utils . smartcontracts import deploy_rpc_test_contract , get_test_contract [EOL] [EOL] [EOL] def test_call_invalid_selector ( deploy_client ) : [EOL] [docstring] [EOL] contract_proxy = deploy_rpc_test_contract ( deploy_client , [string] ) [EOL] address = contract_proxy . contract_address [EOL] assert len ( deploy_client . web3 . eth . getCode ( to_checksum_address ( address ) ) ) > [number] [EOL] [EOL] selector = decode_hex ( contract_proxy . encode_function_call ( [string] , args = None ) ) [EOL] next_byte = chr ( selector [ [number] ] + [number] ) . encode ( ) [EOL] wrong_selector = next_byte + selector [ [number] : ] [EOL] call = deploy_client . web3 . eth . call [EOL] data = { [string] : to_checksum_address ( deploy_client . address ) , [string] : to_checksum_address ( address ) , [string] : wrong_selector , } [EOL] assert call ( data ) == [string] [EOL] [EOL] [EOL] def test_call_inexisting_address ( deploy_client ) : [EOL] [docstring] [EOL] [EOL] inexisting_address = [string] * [number] [EOL] [EOL] assert len ( deploy_client . web3 . eth . getCode ( to_checksum_address ( inexisting_address ) ) ) == [number] [EOL] transaction = { [string] : to_checksum_address ( deploy_client . address ) , [string] : to_checksum_address ( inexisting_address ) , [string] : [string] , [string] : [number] , } [EOL] assert deploy_client . web3 . eth . call ( transaction ) == [string] [EOL] [EOL] [EOL] def test_call_with_a_block_number_before_smart_contract_deployed ( deploy_client ) : [EOL] [docstring] [EOL] contract_path , contracts = get_test_contract ( [string] ) [EOL] contract_proxy , receipt = deploy_client . deploy_solidity_contract ( [string] , contracts , libraries = dict ( ) , constructor_parameters = None , contract_path = contract_path , ) [EOL] [EOL] deploy_block = receipt [ [string] ] [EOL] assert contract_proxy . contract . functions . ret ( ) . call ( block_identifier = deploy_block ) == [number] [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] contract_proxy . contract . functions . ret ( ) . call ( block_identifier = deploy_block - [number] ) [EOL] [EOL] [EOL] def test_call_throws ( deploy_client ) : [EOL] [docstring] [EOL] contract_proxy = deploy_rpc_test_contract ( deploy_client , [string] ) [EOL] [EOL] address = contract_proxy . contract_address [EOL] assert len ( deploy_client . web3 . eth . getCode ( to_checksum_address ( address ) ) ) > [number] [EOL] call = contract_proxy . contract . functions . fail ( ) . call [EOL] assert call ( ) == [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from raiden . tests . integration . api . utils import create_api_server [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ pytest . fixture def api_server_test_instance ( raiden_network , rest_api_port_number ) : [EOL] api_server = create_api_server ( raiden_network [ [number] ] , rest_api_port_number ) [EOL] [EOL] yield api_server [EOL] [EOL] if api_server : [EOL] api_server . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from raiden . tests . integration . api . fixtures import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any , Tuple , Callable , List [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] from datetime import datetime [EOL] [EOL] import gevent . lock [EOL] import structlog [EOL] [EOL] from raiden . storage . sqlite import SerializedSQLiteStorage [EOL] from raiden . transfer . architecture import Event , State , StateChange , StateManager [EOL] from raiden . utils . typing import Callable , Generic , List , Tuple , TypeVar [EOL] [EOL] log = structlog . get_logger ( __name__ ) [comment] [EOL] [EOL] [EOL] def restore_to_state_change ( transition_function , storage , state_change_identifier ) : [EOL] msg = [string] [EOL] assert state_change_identifier == [string] or state_change_identifier > [number] , msg [EOL] [EOL] from_state_change_id , chain_state = storage . get_snapshot_closest_to_state_change ( state_change_identifier = state_change_identifier ) [EOL] [EOL] if chain_state is not None : [EOL] log . debug ( [string] , from_state_change_id = from_state_change_id , to_state_change_id = state_change_identifier , ) [EOL] else : [EOL] log . debug ( [string] , to_state_change_id = state_change_identifier , ) [EOL] [EOL] unapplied_state_changes = storage . get_statechanges_by_identifier ( from_identifier = from_state_change_id , to_identifier = state_change_identifier ) [EOL] [EOL] state_manager = StateManager ( transition_function , chain_state ) [EOL] wal = WriteAheadLog ( state_manager , storage ) [EOL] [EOL] log . debug ( [string] , num_state_changes = len ( unapplied_state_changes ) ) [EOL] for state_change in unapplied_state_changes : [EOL] wal . state_manager . dispatch ( state_change ) [EOL] [EOL] return wal [EOL] [EOL] [EOL] ST = TypeVar ( [string] , bound = State ) [EOL] [EOL] [EOL] class WriteAheadLog ( Generic [ ST ] ) : [EOL] def __init__ ( self , state_manager , storage ) : [EOL] self . state_manager = state_manager [EOL] self . state_change_id = None [EOL] self . storage = storage [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _lock = gevent . lock . Semaphore ( ) [EOL] [EOL] def log_and_dispatch ( self , state_change ) : [EOL] [docstring] [EOL] [EOL] with self . _lock : [EOL] timestamp = datetime . utcnow ( ) . isoformat ( timespec = [string] ) [EOL] state_change_id = self . storage . write_state_change ( state_change , timestamp ) [EOL] self . state_change_id = state_change_id [EOL] [EOL] state , events = self . state_manager . dispatch ( state_change ) [EOL] [EOL] self . storage . write_events ( state_change_id , events , timestamp ) [EOL] [EOL] return state , events [EOL] [EOL] def snapshot ( self ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] current_state = self . state_manager . current_state [EOL] state_change_id = self . state_change_id [EOL] [EOL] [comment] [EOL] if state_change_id : [EOL] self . storage . write_state_snapshot ( state_change_id , current_state ) [EOL] [EOL] @ property def version ( self ) : [EOL] return self . storage . get_version ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from collections import namedtuple [EOL] [EOL] [EOL] class TimestampedEvent ( namedtuple ( [string] , [string] ) ) : [EOL] def __getattr__ ( self , item ) : [EOL] return getattr ( self . wrapped_event , item ) [EOL] [EOL] [EOL] DB_CREATE_SETTINGS = [string] [EOL] [EOL] DB_CREATE_STATE_CHANGES = [string] [EOL] [EOL] DB_CREATE_SNAPSHOT = [string] [EOL] [EOL] DB_CREATE_STATE_EVENTS = [string] [EOL] [EOL] DB_CREATE_RUNS = [string] [EOL] [EOL] DB_SCRIPT_CREATE_TABLES = [string] . format ( DB_CREATE_SETTINGS , DB_CREATE_STATE_CHANGES , DB_CREATE_SNAPSHOT , DB_CREATE_STATE_EVENTS , DB_CREATE_RUNS , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0
from typing import Any , Tuple , Dict , List [EOL] import builtins [EOL] import typing [EOL] import web3 [EOL] import raiden [EOL] import json [EOL] [EOL] from gevent . pool import Pool [EOL] from web3 import Web3 [EOL] [EOL] from raiden . exceptions import InvalidDBData [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] from raiden . utils . typing import Any , BlockNumber , Dict , NamedTuple , Tuple [EOL] [EOL] SOURCE_VERSION = [number] [EOL] TARGET_VERSION = [number] [EOL] [EOL] [EOL] class BlockHashCache : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , web3 ) : [EOL] self . web3 = web3 [EOL] self . mapping = { } [EOL] [EOL] def get ( self , block_number ) : [EOL] [docstring] [EOL] if block_number in self . mapping : [EOL] return self . mapping [ block_number ] [EOL] [EOL] block_hash = self . web3 . eth . getBlock ( block_number ) [ [string] ] [EOL] block_hash = block_hash . hex ( ) [EOL] self . mapping [ block_number ] = block_hash [EOL] return block_hash [EOL] [EOL] [EOL] class BlockQueryAndUpdateRecord ( NamedTuple ) : [EOL] block_number = ... [EOL] data = ... [EOL] state_change_identifier = ... [EOL] cache = ... [EOL] [EOL] [EOL] def _query_blocknumber_and_update_statechange_data ( record , ) : [EOL] data = record . data [EOL] data [ [string] ] = record . cache . get ( record . block_number ) [EOL] return json . dumps ( data ) , record . state_change_identifier [EOL] [EOL] [EOL] def _add_blockhash_to_state_changes ( storage , cache ) : [EOL] [docstring] [EOL] [EOL] batch_size = [number] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = batch_size , filters = [ ( [string] , [string] ) , ( [string] , [string] ) , ] , logical_and = False , ) [EOL] for state_changes_batch in batch_query : [EOL] [comment] [EOL] query_records = [ ] [EOL] for state_change in state_changes_batch : [EOL] data = json . loads ( state_change . data ) [EOL] assert [string] not in data , [string] [EOL] record = BlockQueryAndUpdateRecord ( block_number = BlockNumber ( int ( data [ [string] ] ) ) , data = data , state_change_identifier = state_change . state_change_identifier , cache = cache , ) [EOL] query_records . append ( record ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] updated_state_changes = [ ] [EOL] pool_generator = Pool ( batch_size ) . imap ( _query_blocknumber_and_update_statechange_data , query_records ) [EOL] for entry in pool_generator : [EOL] updated_state_changes . append ( entry ) [EOL] [EOL] [comment] [EOL] storage . update_state_changes ( updated_state_changes ) [EOL] [EOL] [EOL] def _add_blockhash_to_events ( storage , cache ) : [EOL] [docstring] [EOL] batch_query = storage . batch_query_event_records ( batch_size = [number] , filters = [ ( [string] , [string] ) ] ) [EOL] for events_batch in batch_query : [EOL] updated_events = [ ] [EOL] for event in events_batch : [EOL] data = json . loads ( event . data ) [EOL] assert [string] not in data , [string] [EOL] [comment] [EOL] matched_state_changes = storage . get_statechanges_by_identifier ( from_identifier = event . state_change_identifier , to_identifier = event . state_change_identifier , ) [EOL] result_length = len ( matched_state_changes ) [EOL] msg = [string] [EOL] assert result_length == [number] , msg [EOL] [EOL] statechange_data = json . loads ( matched_state_changes [ [number] ] ) [EOL] if [string] in statechange_data : [EOL] data [ [string] ] = statechange_data [ [string] ] [EOL] elif [string] in statechange_data : [EOL] block_number = BlockNumber ( int ( statechange_data [ [string] ] ) ) [EOL] data [ [string] ] = cache . get ( block_number ) [EOL] [EOL] updated_events . append ( ( json . dumps ( data ) , event . event_identifier ) ) [EOL] [EOL] storage . update_events ( updated_events ) [EOL] [EOL] [EOL] def _transform_snapshot ( raw_snapshot , storage , cache ) : [EOL] [docstring] [EOL] snapshot = json . loads ( raw_snapshot ) [EOL] block_number = BlockNumber ( int ( snapshot [ [string] ] ) ) [EOL] snapshot [ [string] ] = cache . get ( block_number ) [EOL] [EOL] pending_transactions = snapshot [ [string] ] [EOL] new_pending_transactions = [ ] [EOL] for transaction_data in pending_transactions : [EOL] if [string] not in transaction_data [ [string] ] : [EOL] raise InvalidDBData ( [string] [string] ) [EOL] [EOL] [comment] [EOL] event_record = storage . get_latest_event_by_data_field ( filters = transaction_data ) [EOL] if not event_record . data : [EOL] raise InvalidDBData ( [string] [string] ) [EOL] [EOL] event_record_data = json . loads ( event_record . data ) [EOL] transaction_data [ [string] ] = event_record_data [ [string] ] [EOL] new_pending_transactions . append ( transaction_data ) [EOL] [EOL] snapshot [ [string] ] = new_pending_transactions [EOL] return json . dumps ( snapshot ) [EOL] [EOL] [EOL] class TransformSnapshotRecord ( NamedTuple ) : [EOL] data = ... [EOL] identifier = ... [EOL] storage = ... [EOL] cache = ... [EOL] [EOL] [EOL] def _do_transform_snapshot ( record ) : [EOL] new_snapshot = _transform_snapshot ( raw_snapshot = record . data , storage = record . storage , cache = record . cache ) [EOL] return new_snapshot , record . identifier [EOL] [EOL] [EOL] def _transform_snapshots_for_blockhash ( storage , cache ) : [EOL] [docstring] [EOL] [EOL] snapshots = storage . get_snapshots ( ) [EOL] snapshot_records = [ TransformSnapshotRecord ( data = snapshot . data , identifier = snapshot . identifier , storage = storage , cache = cache ) for snapshot in snapshots ] [EOL] [EOL] pool_generator = Pool ( len ( snapshots ) ) . imap ( _do_transform_snapshot , snapshot_records ) [EOL] [EOL] updated_snapshots_data = [ ] [EOL] for result in pool_generator : [EOL] updated_snapshots_data . append ( result ) [EOL] [EOL] storage . update_snapshots ( updated_snapshots_data ) [EOL] [EOL] [EOL] def upgrade_v18_to_v19 ( storage , old_version , current_version , web3 , ** kwargs , ) : [EOL] if old_version == SOURCE_VERSION : [EOL] cache = BlockHashCache ( web3 ) [EOL] _add_blockhash_to_state_changes ( storage , cache ) [EOL] _add_blockhash_to_events ( storage , cache ) [EOL] [comment] [EOL] [comment] [EOL] _transform_snapshots_for_blockhash ( storage , cache ) [EOL] [EOL] return TARGET_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Dict[raiden.utils.typing.BlockNumber,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.BlockNumber$ 0 0 0 $raiden.utils.typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $BlockHashCache$ 0 0 0 0 0 0 $raiden.utils.typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $raiden.storage.sqlite.SQLiteStorage$ 0 0 0 $BlockHashCache$ 0 0 0 0 0 0 $raiden.utils.typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
from typing import Any , Tuple , Dict , List [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import json [EOL] from functools import partial [EOL] from typing import TYPE_CHECKING [EOL] [EOL] from eth_utils import to_canonical_address [EOL] from gevent . pool import Pool [EOL] [EOL] from raiden . constants import EMPTY_MERKLE_ROOT [EOL] from raiden . exceptions import RaidenUnrecoverableError [EOL] from raiden . network . proxies . utils import get_onchain_locksroots [EOL] from raiden . storage . sqlite import SnapshotRecord , SQLiteStorage , StateChangeRecord [EOL] from raiden . transfer . identifiers import CanonicalIdentifier [EOL] from raiden . utils . serialization import serialize_bytes [EOL] from raiden . utils . typing import ( Any , ChainID , ChannelID , Dict , Locksroot , TokenNetworkAddress , Tuple , ) [EOL] [EOL] if TYPE_CHECKING : [EOL] [comment] [EOL] from raiden . raiden_service import RaidenService [comment] [EOL] [EOL] [EOL] SOURCE_VERSION = [number] [EOL] TARGET_VERSION = [number] [EOL] [EOL] [EOL] def _find_channel_new_state_change ( storage , token_network_address , channel_identifier ) : [EOL] return storage . get_latest_state_change_by_data_field ( { [string] : [string] , [string] : token_network_address , [string] : channel_identifier , } ) [EOL] [EOL] [EOL] def _get_onchain_locksroots ( raiden , storage , token_network , channel , ) : [EOL] channel_new_state_change = _find_channel_new_state_change ( storage = storage , token_network_address = token_network [ [string] ] , channel_identifier = channel [ [string] ] , ) [EOL] [EOL] if not channel_new_state_change : [EOL] raise RaidenUnrecoverableError ( f' [string] { channel [ [string] ] } [string] ' f' [string] { token_network [ [string] ] } [string] ' ) [EOL] [EOL] canonical_identifier = CanonicalIdentifier ( chain_identifier = ChainID ( - [number] ) , token_network_address = TokenNetworkAddress ( to_canonical_address ( token_network [ [string] ] ) ) , channel_identifier = ChannelID ( int ( channel [ [string] ] ) ) , ) [EOL] [EOL] our_locksroot , partner_locksroot = get_onchain_locksroots ( chain = raiden . chain , canonical_identifier = canonical_identifier , participant1 = to_canonical_address ( channel [ [string] ] [ [string] ] ) , participant2 = to_canonical_address ( channel [ [string] ] [ [string] ] ) , block_identifier = [string] , ) [EOL] return our_locksroot , partner_locksroot [EOL] [EOL] [EOL] def _add_onchain_locksroot_to_channel_new_state_changes ( storage , ) : [EOL] [docstring] [EOL] batch_size = [number] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = batch_size , filters = [ ( [string] , [string] ) ] , ) [EOL] for state_changes_batch in batch_query : [EOL] updated_state_changes = list ( ) [EOL] for state_change in state_changes_batch : [EOL] state_change_data = json . loads ( state_change . data ) [EOL] [EOL] channel_state = state_change_data [ [string] ] [EOL] msg = [string] [EOL] assert [string] not in channel_state [ [string] ] , msg [EOL] [EOL] msg = [string] [EOL] assert [string] not in channel_state [ [string] ] , msg [EOL] [EOL] channel_state [ [string] ] [ [string] ] = serialize_bytes ( EMPTY_MERKLE_ROOT ) [EOL] channel_state [ [string] ] [ [string] ] = serialize_bytes ( EMPTY_MERKLE_ROOT ) [EOL] [EOL] updated_state_changes . append ( ( json . dumps ( state_change_data ) , state_change . state_change_identifier ) ) [EOL] storage . update_state_changes ( updated_state_changes ) [EOL] [EOL] [EOL] def _add_onchain_locksroot_to_channel_settled_state_changes ( raiden , storage ) : [EOL] [docstring] [EOL] batch_size = [number] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = batch_size , filters = [ ( [string] , [string] ) ] , ) [EOL] for state_changes_batch in batch_query : [EOL] updated_state_changes = list ( ) [EOL] for state_change in state_changes_batch : [EOL] state_change_data = json . loads ( state_change . data ) [EOL] msg = [string] [EOL] assert [string] not in state_change_data , msg [EOL] [EOL] msg = [string] [EOL] assert [string] not in state_change_data , msg [EOL] [EOL] token_network_identifier = state_change_data [ [string] ] [EOL] channel_identifier = state_change_data [ [string] ] [EOL] [EOL] channel_new_state_change = _find_channel_new_state_change ( storage = storage , token_network_address = token_network_identifier , channel_identifier = channel_identifier , ) [EOL] [EOL] if not channel_new_state_change . data : [EOL] raise RaidenUnrecoverableError ( f" [string] { channel_identifier } [string] " f" [string] { token_network_identifier } [string] " ) [EOL] [EOL] channel_state_data = json . loads ( channel_new_state_change . data ) [EOL] new_channel_state = channel_state_data [ [string] ] [EOL] [EOL] canonical_identifier = CanonicalIdentifier ( chain_identifier = ChainID ( - [number] ) , token_network_address = TokenNetworkAddress ( to_canonical_address ( token_network_identifier ) ) , channel_identifier = ChannelID ( int ( channel_identifier ) ) , ) [EOL] our_locksroot , partner_locksroot = get_onchain_locksroots ( chain = raiden . chain , canonical_identifier = canonical_identifier , participant1 = to_canonical_address ( new_channel_state [ [string] ] [ [string] ] ) , participant2 = to_canonical_address ( new_channel_state [ [string] ] [ [string] ] ) , block_identifier = [string] , ) [EOL] [EOL] state_change_data [ [string] ] = serialize_bytes ( our_locksroot ) [EOL] state_change_data [ [string] ] = serialize_bytes ( partner_locksroot ) [EOL] [EOL] updated_state_changes . append ( ( json . dumps ( state_change_data ) , state_change . state_change_identifier ) ) [EOL] storage . update_state_changes ( updated_state_changes ) [EOL] [EOL] [EOL] def _add_onchain_locksroot_to_snapshot ( raiden , storage , snapshot_record ) : [EOL] [docstring] [EOL] snapshot = json . loads ( snapshot_record . data ) [EOL] [EOL] for payment_network in snapshot . get ( [string] , dict ( ) ) . values ( ) : [EOL] for token_network in payment_network . get ( [string] , list ( ) ) : [EOL] channelidentifiers_to_channels = token_network . get ( [string] , dict ( ) ) [EOL] for channel in channelidentifiers_to_channels . values ( ) : [EOL] our_locksroot , partner_locksroot = _get_onchain_locksroots ( raiden = raiden , storage = storage , token_network = token_network , channel = channel ) [EOL] channel [ [string] ] [ [string] ] = serialize_bytes ( our_locksroot ) [EOL] channel [ [string] ] [ [string] ] = serialize_bytes ( partner_locksroot ) [EOL] [EOL] return json . dumps ( snapshot , indent = [number] ) , snapshot_record . identifier [EOL] [EOL] [EOL] def _add_onchain_locksroot_to_snapshots ( raiden , storage ) : [EOL] snapshots = storage . get_snapshots ( ) [EOL] [EOL] transform_func = partial ( _add_onchain_locksroot_to_snapshot , raiden , storage ) [EOL] [EOL] pool_generator = Pool ( len ( snapshots ) ) . imap ( transform_func , snapshots ) [EOL] [EOL] updated_snapshots_data = [ ] [EOL] for result in pool_generator : [EOL] updated_snapshots_data . append ( result ) [EOL] [EOL] storage . update_snapshots ( updated_snapshots_data ) [EOL] [EOL] [EOL] def upgrade_v19_to_v20 ( storage , old_version , current_version , raiden , ** kwargs , ) : [EOL] if old_version == SOURCE_VERSION : [EOL] _add_onchain_locksroot_to_channel_new_state_changes ( storage ) [EOL] _add_onchain_locksroot_to_channel_settled_state_changes ( raiden , storage ) [EOL] _add_onchain_locksroot_to_snapshots ( raiden , storage ) [EOL] [EOL] return TARGET_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import raiden [EOL] import typing [EOL] import builtins [EOL] import json [EOL] [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] [EOL] SOURCE_VERSION = [number] [EOL] TARGET_VERSION = [number] [EOL] [EOL] [EOL] def _transform_snapshot ( raw_snapshot ) : [EOL] [docstring] [EOL] snapshot = json . loads ( raw_snapshot ) [EOL] [EOL] for task in snapshot [ [string] ] [ [string] ] . values ( ) : [EOL] if [string] in task [ [string] ] : [EOL] for initiator in task [ [string] ] [ [string] ] . values ( ) : [EOL] msg = [string] [EOL] assert [string] not in initiator [ [string] ] , msg [EOL] initiator [ [string] ] [ [string] ] = [string] [EOL] [EOL] msg = [string] [EOL] assert [string] not in snapshot , msg [EOL] ids_to_addrs = dict ( ) [EOL] for payment_network in snapshot [ [string] ] . values ( ) : [EOL] for token_network in payment_network [ [string] ] : [EOL] ids_to_addrs [ token_network [ [string] ] ] = payment_network [ [string] ] [EOL] snapshot [ [string] ] = ids_to_addrs [EOL] [EOL] for payment_network in snapshot [ [string] ] . values ( ) : [EOL] for token_network in payment_network [ [string] ] : [EOL] for channel_state in token_network [ [string] ] . values ( ) : [EOL] msg = [string] [EOL] assert [string] not in channel_state , msg [EOL] channel_state [ [string] ] = [string] [EOL] [EOL] return json . dumps ( snapshot ) [EOL] [EOL] [EOL] def _update_snapshots ( storage ) : [EOL] updated_snapshots_data = [ ] [EOL] for snapshot in storage . get_snapshots ( ) : [EOL] new_snapshot = _transform_snapshot ( snapshot . data ) [EOL] updated_snapshots_data . append ( ( new_snapshot , snapshot . identifier ) ) [EOL] [EOL] storage . update_snapshots ( updated_snapshots_data ) [EOL] [EOL] [EOL] def _update_statechanges ( storage ) : [EOL] [docstring] [EOL] batch_size = [number] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = batch_size , filters = [ ( [string] , [string] ) ] , ) [EOL] [EOL] for state_changes_batch in batch_query : [EOL] updated_state_changes = list ( ) [EOL] for state_change in state_changes_batch : [EOL] data = json . loads ( state_change . data ) [EOL] msg = [string] [EOL] assert [string] not in data [ [string] ] , msg [EOL] data [ [string] ] [ [string] ] = [string] [EOL] [EOL] updated_state_changes . append ( ( json . dumps ( data ) , state_change . state_change_identifier ) ) [EOL] [EOL] storage . update_state_changes ( updated_state_changes ) [EOL] [EOL] batch_query = storage . batch_query_state_changes ( batch_size = batch_size , filters = [ ( [string] , [string] ) ] , ) [EOL] [EOL] for state_changes_batch in batch_query : [EOL] updated_state_changes = list ( ) [EOL] for state_change in state_changes_batch : [EOL] data = json . loads ( state_change . data ) [EOL] msg = [string] [EOL] assert [string] not in data [ [string] ] , msg [EOL] data [ [string] ] [ [string] ] = [string] [EOL] [EOL] updated_state_changes . append ( ( json . dumps ( data ) , state_change . state_change_identifier ) ) [EOL] [EOL] storage . update_state_changes ( updated_state_changes ) [EOL] [EOL] [EOL] def upgrade_v20_to_v21 ( storage , old_version , current_version , ** kwargs , ) : [EOL] if old_version == SOURCE_VERSION : [EOL] _update_snapshots ( storage ) [EOL] _update_statechanges ( storage ) [EOL] [EOL] return TARGET_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import json [EOL] [EOL] from raiden . storage . sqlite import SQLiteStorage [EOL] [EOL] SOURCE_VERSION = [number] [EOL] TARGET_VERSION = [number] [EOL] [EOL] [EOL] def _transform_snapshot ( raw_snapshot ) : [EOL] [docstring] [EOL] snapshot = json . loads ( raw_snapshot ) [EOL] secrethash_to_task = snapshot [ [string] ] [ [string] ] [EOL] for secrethash , task in secrethash_to_task . items ( ) : [EOL] if task [ [string] ] != [string] : [EOL] continue [EOL] [EOL] [comment] [EOL] transfer_secrethash = task [ [string] ] [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] task [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] task [ [string] ] [ [string] ] = { transfer_secrethash : task [ [string] ] [ [string] ] } [EOL] del task [ [string] ] [ [string] ] [EOL] secrethash_to_task [ secrethash ] = task [EOL] return json . dumps ( snapshot , indent = [number] ) [EOL] [EOL] [EOL] def _transform_snapshots ( storage ) : [EOL] updated_snapshots_data = [ ] [EOL] for snapshot in storage . get_snapshots ( ) : [EOL] new_snapshot = _transform_snapshot ( snapshot . data ) [EOL] updated_snapshots_data . append ( ( new_snapshot , snapshot . identifier ) ) [EOL] [EOL] storage . update_snapshots ( updated_snapshots_data ) [EOL] [EOL] [EOL] def upgrade_v16_to_v17 ( storage , old_version , current_version , ** kwargs ) : [comment] [EOL] [docstring] [EOL] if old_version == SOURCE_VERSION : [EOL] _transform_snapshots ( storage ) [EOL] [EOL] return TARGET_VERSION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
	0
from typing import Dict , Optional , Any , Tuple , Callable , TextIO [EOL] import urllib [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] import os [EOL] import sys [EOL] from typing import Any , Callable , Dict , TextIO [EOL] from urllib . parse import urlparse [EOL] [EOL] import click [EOL] import filelock [EOL] import structlog [EOL] from eth_utils import to_canonical_address , to_normalized_address [EOL] from web3 import HTTPProvider , Web3 [EOL] [EOL] from raiden . accounts import AccountManager [EOL] from raiden . constants import ( MONITORING_BROADCASTING_ROOM , PATH_FINDING_BROADCASTING_ROOM , RAIDEN_DB_VERSION , Environment , RoutingMode , ) [EOL] from raiden . exceptions import RaidenError [EOL] from raiden . message_handler import MessageHandler [EOL] from raiden . network . blockchain_service import BlockChainService [EOL] from raiden . network . rpc . client import JSONRPCClient [EOL] from raiden . network . transport import MatrixTransport [EOL] from raiden . raiden_event_handler import RaidenEventHandler [EOL] from raiden . settings import ( DEFAULT_MATRIX_KNOWN_SERVERS , DEFAULT_NAT_KEEPALIVE_RETRIES , DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS , ) [EOL] from raiden . ui . checks import ( check_ethereum_client_is_supported , check_ethereum_has_accounts , check_ethereum_network_id , check_sql_version , check_synced , ) [EOL] from raiden . ui . prompt import ( prompt_account , unlock_account_with_passwordfile , unlock_account_with_passwordprompt , ) [EOL] from raiden . ui . startup import ( setup_contracts_or_exit , setup_environment , setup_proxies_or_exit , setup_udp_or_exit , ) [EOL] from raiden . utils import BlockNumber , pex , split_endpoint [EOL] from raiden . utils . cli import get_matrix_servers [EOL] from raiden . utils . typing import Address , Optional , PrivateKey , Tuple [EOL] from raiden_contracts . constants import ID_TO_NETWORKNAME [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] [EOL] log = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] def _setup_matrix ( config ) : [EOL] if config [ [string] ] [ [string] ] . get ( [string] ) is None : [EOL] [comment] [EOL] available_servers_url = DEFAULT_MATRIX_KNOWN_SERVERS [ config [ [string] ] ] [EOL] available_servers = get_matrix_servers ( available_servers_url ) [EOL] log . debug ( [string] , available_servers = available_servers ) [EOL] config [ [string] ] [ [string] ] [ [string] ] = available_servers [EOL] [EOL] [comment] [EOL] [comment] [EOL] if config [ [string] ] [ [string] ] is not None : [EOL] if PATH_FINDING_BROADCASTING_ROOM not in config [ [string] ] [ [string] ] [ [string] ] : [EOL] config [ [string] ] [ [string] ] [ [string] ] . append ( PATH_FINDING_BROADCASTING_ROOM ) [EOL] [EOL] [comment] [EOL] if config [ [string] ] [ [string] ] is True : [EOL] config [ [string] ] [ [string] ] [ [string] ] . append ( MONITORING_BROADCASTING_ROOM ) [EOL] [EOL] try : [EOL] transport = MatrixTransport ( config [ [string] ] [ [string] ] ) [EOL] except RaidenError as ex : [EOL] click . secho ( f" [string] { ex }" , fg = [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] return transport [EOL] [EOL] [EOL] def get_account_and_private_key ( account_manager , address , password_file ) : [EOL] if not address : [EOL] address_hex = prompt_account ( account_manager ) [EOL] else : [EOL] address_hex = to_normalized_address ( address ) [EOL] [EOL] if password_file : [EOL] privatekey_bin = unlock_account_with_passwordfile ( account_manager = account_manager , address_hex = address_hex , password_file = password_file ) [EOL] else : [EOL] privatekey_bin = unlock_account_with_passwordprompt ( account_manager = account_manager , address_hex = address_hex ) [EOL] [EOL] return to_canonical_address ( address_hex ) , privatekey_bin [EOL] [EOL] [EOL] def rpc_normalized_endpoint ( eth_rpc_endpoint ) : [EOL] parsed_eth_rpc_endpoint = urlparse ( eth_rpc_endpoint ) [EOL] [EOL] if parsed_eth_rpc_endpoint . scheme : [EOL] return eth_rpc_endpoint [EOL] [EOL] return f" [string] { eth_rpc_endpoint }" [EOL] [EOL] [EOL] def run_app ( address , keystore_path , gas_price , eth_rpc_endpoint , tokennetwork_registry_contract_address , one_to_n_contract_address , secret_registry_contract_address , service_registry_contract_address , endpoint_registry_contract_address , user_deposit_contract_address , listen_address , mapped_socket , max_unresponsive_time , api_address , rpc , sync_check , console , password_file , web_ui , datadir , transport , matrix_server , network_id , environment_type , unrecoverable_error_should_crash , pathfinding_service_address , pathfinding_max_paths , enable_monitoring , resolver_endpoint , routing_mode , config , ** kwargs , ) : [EOL] [comment] [EOL] [EOL] from raiden . app import App [EOL] [EOL] if transport == [string] and not mapped_socket : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] if datadir is None : [EOL] datadir = os . path . join ( os . path . expanduser ( [string] ) , [string] ) [EOL] [EOL] account_manager = AccountManager ( keystore_path ) [EOL] web3 = Web3 ( HTTPProvider ( rpc_normalized_endpoint ( eth_rpc_endpoint ) ) ) [EOL] [EOL] check_sql_version ( ) [EOL] check_ethereum_has_accounts ( account_manager ) [EOL] check_ethereum_client_is_supported ( web3 ) [EOL] check_ethereum_network_id ( network_id , web3 ) [EOL] [EOL] ( address , privatekey_bin ) = get_account_and_private_key ( account_manager , address , password_file ) [EOL] [EOL] ( listen_host , listen_port ) = split_endpoint ( listen_address ) [EOL] ( api_host , api_port ) = split_endpoint ( api_address ) [EOL] [EOL] config [ [string] ] [ [string] ] [ [string] ] = listen_host [EOL] config [ [string] ] [ [string] ] [ [string] ] = listen_port [EOL] config [ [string] ] = console [EOL] config [ [string] ] = rpc [EOL] config [ [string] ] = rpc and web_ui [EOL] config [ [string] ] = api_host [EOL] config [ [string] ] = api_port [EOL] config [ [string] ] = resolver_endpoint [EOL] if mapped_socket : [EOL] config [ [string] ] = mapped_socket . socket [EOL] config [ [string] ] [ [string] ] [ [string] ] = mapped_socket . external_ip [EOL] config [ [string] ] [ [string] ] [ [string] ] = mapped_socket . external_port [EOL] config [ [string] ] = transport [EOL] config [ [string] ] [ [string] ] [ [string] ] = matrix_server [EOL] config [ [string] ] [ [string] ] [ [string] ] = DEFAULT_NAT_KEEPALIVE_RETRIES [EOL] timeout = max_unresponsive_time / DEFAULT_NAT_KEEPALIVE_RETRIES [EOL] config [ [string] ] [ [string] ] [ [string] ] = timeout [EOL] config [ [string] ] = unrecoverable_error_should_crash [EOL] config [ [string] ] [ [string] ] = pathfinding_max_paths [EOL] config [ [string] ] [ [string] ] = enable_monitoring [EOL] config [ [string] ] = network_id [EOL] [EOL] setup_environment ( config , environment_type ) [EOL] [EOL] contracts = setup_contracts_or_exit ( config , network_id ) [EOL] [EOL] rpc_client = JSONRPCClient ( web3 , privatekey_bin , gas_price_strategy = gas_price , block_num_confirmations = DEFAULT_NUMBER_OF_BLOCK_CONFIRMATIONS , uses_infura = [string] in eth_rpc_endpoint , ) [EOL] [EOL] blockchain_service = BlockChainService ( jsonrpc_client = rpc_client , contract_manager = ContractManager ( config [ [string] ] ) ) [EOL] [EOL] if sync_check : [EOL] check_synced ( blockchain_service ) [EOL] [EOL] proxies = setup_proxies_or_exit ( config = config , tokennetwork_registry_contract_address = tokennetwork_registry_contract_address , secret_registry_contract_address = secret_registry_contract_address , endpoint_registry_contract_address = endpoint_registry_contract_address , user_deposit_contract_address = user_deposit_contract_address , service_registry_contract_address = service_registry_contract_address , blockchain_service = blockchain_service , contracts = contracts , routing_mode = routing_mode , pathfinding_service_address = pathfinding_service_address , ) [EOL] [EOL] database_path = os . path . join ( datadir , f" [string] { pex ( address ) }" , f" [string] { network_id }" , f" [string] { pex ( proxies . token_network_registry . address ) }" , f" [string] { RAIDEN_DB_VERSION } [string] " , ) [EOL] config [ [string] ] = database_path [EOL] [EOL] print ( [string] . format ( ID_TO_NETWORKNAME . get ( network_id , network_id ) , database_path ) ) [EOL] [EOL] discovery = None [EOL] if transport == [string] : [EOL] transport , discovery = setup_udp_or_exit ( config , blockchain_service , address , contracts , endpoint_registry_contract_address ) [EOL] elif transport == [string] : [EOL] transport = _setup_matrix ( config ) [EOL] else : [EOL] raise RuntimeError ( f' [string] { transport } [string] ' ) [EOL] [EOL] raiden_event_handler = RaidenEventHandler ( ) [EOL] [EOL] message_handler = MessageHandler ( ) [EOL] [EOL] try : [EOL] start_block = [number] [EOL] if [string] in contracts : [EOL] start_block = contracts [ [string] ] [ [string] ] [EOL] [EOL] raiden_app = App ( config = config , chain = blockchain_service , query_start_block = BlockNumber ( start_block ) , default_one_to_n_address = one_to_n_contract_address , default_registry = proxies . token_network_registry , default_secret_registry = proxies . secret_registry , default_service_registry = proxies . service_registry , transport = transport , raiden_event_handler = raiden_event_handler , message_handler = message_handler , discovery = discovery , user_deposit = proxies . user_deposit , ) [EOL] except RaidenError as e : [EOL] click . secho ( f" [string] { e }" , fg = [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] try : [EOL] raiden_app . start ( ) [EOL] except RuntimeError as e : [EOL] click . secho ( f" [string] { e }" , fg = [string] ) [EOL] sys . exit ( [number] ) [EOL] except filelock . Timeout : [EOL] name_or_id = ID_TO_NETWORKNAME . get ( network_id , network_id ) [EOL] click . secho ( f" [string] " f"{ to_normalized_address ( address ) } [string] { name_or_id }" , fg = [string] , ) [EOL] sys . exit ( [number] ) [EOL] [EOL] return raiden_app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.Tuple[raiden.utils.typing.Address,raiden.utils.typing.PrivateKey]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Type [EOL] import builtins [EOL] import typing [EOL] import raiden [EOL] from flask import Blueprint [EOL] from flask_restful import Resource [EOL] from webargs . flaskparser import use_kwargs [EOL] [EOL] from raiden . api . v1 . encoding import ( BlockchainEventsRequestSchema , ChannelPatchSchema , ChannelPutSchema , ConnectionsConnectSchema , ConnectionsLeaveSchema , PaymentSchema , RaidenEventsRequestSchema , ) [EOL] from raiden . utils import typing [EOL] [EOL] [EOL] def create_blueprint ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] class BaseResource ( Resource ) : [EOL] def __init__ ( self , rest_api_object , ** kwargs ) : [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] self . rest_api = rest_api_object [EOL] [EOL] [EOL] class AddressResource ( BaseResource ) : [EOL] def get ( self ) : [EOL] return self . rest_api . get_our_address ( ) [EOL] [EOL] [EOL] class ChannelsResource ( BaseResource ) : [EOL] [EOL] put_schema = ChannelPutSchema [EOL] [EOL] def get ( self ) : [EOL] [docstring] [EOL] return self . rest_api . get_channel_list ( self . rest_api . raiden_api . raiden . default_registry . address ) [EOL] [EOL] @ use_kwargs ( put_schema , locations = ( [string] , ) ) def put ( self , ** kwargs ) : [EOL] return self . rest_api . open ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , ** kwargs ) [EOL] [EOL] [EOL] class ChannelsResourceByTokenAddress ( BaseResource ) : [EOL] def get ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . rest_api . get_channel_list ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , ** kwargs ) [EOL] [EOL] [EOL] class ChannelsResourceByTokenAndPartnerAddress ( BaseResource ) : [EOL] [EOL] patch_schema = ChannelPatchSchema [EOL] [EOL] @ use_kwargs ( patch_schema , locations = ( [string] , ) ) def patch ( self , ** kwargs ) : [EOL] return self . rest_api . patch_channel ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , ** kwargs ) [EOL] [EOL] def get ( self , ** kwargs ) : [EOL] return self . rest_api . get_channel ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , ** kwargs ) [EOL] [EOL] [EOL] class TokensResource ( BaseResource ) : [EOL] def get ( self ) : [EOL] [docstring] [EOL] return self . rest_api . get_tokens_list ( self . rest_api . raiden_api . raiden . default_registry . address ) [EOL] [EOL] [EOL] class PartnersResourceByTokenAddress ( BaseResource ) : [EOL] def get ( self , token_address ) : [EOL] return self . rest_api . get_partners_by_token ( self . rest_api . raiden_api . raiden . default_registry . address , token_address ) [EOL] [EOL] [EOL] class BlockchainEventsNetworkResource ( BaseResource ) : [EOL] [EOL] get_schema = BlockchainEventsRequestSchema ( ) [EOL] [EOL] @ use_kwargs ( get_schema , locations = ( [string] , ) ) def get ( self , from_block , to_block ) : [EOL] from_block = from_block or self . rest_api . raiden_api . raiden . query_start_block [EOL] to_block = to_block or [string] [EOL] [EOL] return self . rest_api . get_blockchain_events_network ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , from_block = from_block , to_block = to_block , ) [EOL] [EOL] [EOL] class BlockchainEventsTokenResource ( BaseResource ) : [EOL] [EOL] get_schema = BlockchainEventsRequestSchema ( ) [EOL] [EOL] @ use_kwargs ( get_schema , locations = ( [string] , ) ) def get ( self , token_address , from_block , to_block ) : [EOL] from_block = from_block or self . rest_api . raiden_api . raiden . query_start_block [EOL] to_block = to_block or [string] [EOL] [EOL] return self . rest_api . get_blockchain_events_token_network ( token_address = token_address , from_block = from_block , to_block = to_block ) [EOL] [EOL] [EOL] class ChannelBlockchainEventsResource ( BaseResource ) : [EOL] [EOL] get_schema = BlockchainEventsRequestSchema ( ) [EOL] [EOL] @ use_kwargs ( get_schema , locations = ( [string] , ) ) def get ( self , token_address , partner_address = None , from_block = None , to_block = None ) : [EOL] from_block = from_block or self . rest_api . raiden_api . raiden . query_start_block [EOL] to_block = to_block or [string] [EOL] [EOL] return self . rest_api . get_blockchain_events_channel ( token_address = token_address , partner_address = partner_address , from_block = from_block , to_block = to_block , ) [EOL] [EOL] [EOL] class RaidenInternalEventsResource ( BaseResource ) : [EOL] [EOL] get_schema = RaidenEventsRequestSchema ( ) [EOL] [EOL] @ use_kwargs ( get_schema , locations = ( [string] , ) ) def get ( self , limit = None , offset = None ) : [EOL] return self . rest_api . get_raiden_internal_events_with_timestamps ( limit = limit , offset = offset ) [EOL] [EOL] [EOL] class RegisterTokenResource ( BaseResource ) : [EOL] def get ( self , token_address ) : [EOL] return self . rest_api . get_token_network_for_token ( self . rest_api . raiden_api . raiden . default_registry . address , token_address ) [EOL] [EOL] def put ( self , token_address ) : [EOL] return self . rest_api . register_token ( self . rest_api . raiden_api . raiden . default_registry . address , token_address ) [EOL] [EOL] [EOL] class ConnectionsResource ( BaseResource ) : [EOL] [EOL] put_schema = ConnectionsConnectSchema ( ) [EOL] delete_schema = ConnectionsLeaveSchema ( ) [EOL] [EOL] @ use_kwargs ( put_schema ) def put ( self , token_address , funds , initial_channel_target , joinable_funds_target ) : [EOL] return self . rest_api . connect ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , token_address = token_address , funds = funds , initial_channel_target = initial_channel_target , joinable_funds_target = joinable_funds_target , ) [EOL] [EOL] @ use_kwargs ( delete_schema , locations = ( [string] , ) ) def delete ( self , token_address ) : [EOL] return self . rest_api . leave ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , token_address = token_address , ) [EOL] [EOL] [EOL] class ConnectionsInfoResource ( BaseResource ) : [EOL] def get ( self ) : [EOL] return self . rest_api . get_connection_managers_info ( self . rest_api . raiden_api . raiden . default_registry . address ) [EOL] [EOL] [EOL] class PaymentResource ( BaseResource ) : [EOL] [EOL] post_schema = PaymentSchema ( only = ( [string] , [string] , [string] , [string] ) ) [EOL] get_schema = RaidenEventsRequestSchema ( ) [EOL] [EOL] @ use_kwargs ( get_schema , locations = ( [string] , ) ) def get ( self , token_address = None , target_address = None , limit = None , offset = None , ) : [EOL] return self . rest_api . get_raiden_events_payment_history_with_timestamps ( token_address = token_address , target_address = target_address , limit = limit , offset = offset ) [EOL] [EOL] @ use_kwargs ( post_schema , locations = ( [string] , ) ) def post ( self , token_address , target_address , amount , identifier , secret , secret_hash , ) : [EOL] return self . rest_api . initiate_payment ( registry_address = self . rest_api . raiden_api . raiden . default_registry . address , token_address = token_address , target_address = target_address , amount = amount , identifier = identifier , secret = secret , secret_hash = secret_hash , ) [EOL] [EOL] [EOL] class PendingTransfersResource ( BaseResource ) : [EOL] def get ( self ) : [EOL] return self . rest_api . get_pending_transfers ( ) [EOL] [EOL] [EOL] class PendingTransfersResourceByTokenAddress ( BaseResource ) : [EOL] def get ( self , token_address ) : [EOL] return self . rest_api . get_pending_transfers ( token_address ) [EOL] [EOL] [EOL] class PendingTransfersResourceByTokenAndPartnerAddress ( BaseResource ) : [EOL] def get ( self , token_address , partner_address ) : [EOL] return self . rest_api . get_pending_transfers ( token_address , partner_address ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.ChannelsResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.ChannelsResourceByTokenAndPartnerAddress]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.BlockchainEventsNetworkResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.BlockchainEventsTokenResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.ChannelBlockchainEventsResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.RaidenInternalEventsResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.ConnectionsResource]$ 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.ConnectionsResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.PaymentResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[raiden.api.v1.resources.PaymentResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenAddress$ 0 0 0 $raiden.utils.typing.Address$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenAddress$ 0 $raiden.utils.typing.TokenAddress$ 0 $raiden.utils.typing.Address$ 0 $raiden.utils.typing.Address$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenAddress$ 0 $raiden.utils.typing.TargetAddress$ 0 $raiden.utils.typing.PaymentAmount$ 0 $raiden.utils.typing.PaymentID$ 0 $raiden.utils.typing.Secret$ 0 $raiden.utils.typing.SecretHash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden.utils.typing.TokenAddress$ 0 $raiden.utils.typing.TokenAddress$ 0 $raiden.utils.typing.TargetAddress$ 0 $raiden.utils.typing.TargetAddress$ 0 $raiden.utils.typing.PaymentAmount$ 0 $raiden.utils.typing.PaymentAmount$ 0 $raiden.utils.typing.PaymentID$ 0 $raiden.utils.typing.PaymentID$ 0 $raiden.utils.typing.Secret$ 0 $raiden.utils.typing.Secret$ 0 $raiden.utils.typing.SecretHash$ 0 $raiden.utils.typing.SecretHash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0