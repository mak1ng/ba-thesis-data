	0
[comment] [EOL] [EOL] from typing import Dict , Any , List [EOL] import argparse [EOL] import graphbook [EOL] import typing [EOL] import argparse [EOL] import curses [EOL] import os [EOL] import pdb [EOL] import sys [EOL] import textwrap [EOL] import graphbook . graph as graph [EOL] import graphbook . vm . uscheme as uscheme [EOL] from typing import Any , Dict [EOL] [EOL] active_node = None [EOL] selected_node = None [EOL] search_mode = False [EOL] search_buffer = [string] [EOL] search_index = [number] [EOL] [EOL] [EOL] class KeyMap : [EOL] _keymap = ... [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _keymap = { } [EOL] [EOL] def register ( self , key , func ) : [EOL] print ( [string] , key ) [EOL] if isinstance ( key , str ) : [EOL] key = ord ( key ) [EOL] self . _keymap [ key ] = func [EOL] [EOL] def press ( self , key , scr , * args ) : [EOL] if isinstance ( key , str ) : [EOL] key = ord ( key ) [EOL] func = self . _keymap . get ( key , None ) [EOL] if not func : [EOL] return None [EOL] return func ( scr , key , * args ) [EOL] [EOL] [EOL] def render_cell ( c , scr ) : [EOL] if c . is_executable ( ) : [EOL] pass [EOL] [EOL] [EOL] def main ( stdscr , args ) : [EOL] global active_node [EOL] global selected_node [EOL] global search_mode [EOL] global search_buffer [EOL] global search_index [EOL] [EOL] notebook = graph . notebook . Notebook ( args . path ) [EOL] pdb . set_trace ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def fine_python ( scr , * args ) : [EOL] global search_mode [EOL] search_mode = True [EOL] [EOL] kmap = KeyMap ( ) [EOL] kmap . register ( [string] , fine_python ) [EOL] kmap . register ( [string] , lambda scr , key : sys . exit ( [number] ) ) [EOL] kmap . register [EOL] [EOL] while True : [EOL] if not search_mode : [EOL] if active_node : [EOL] _node = notebook . noder ( active_node ) [EOL] [comment] [EOL] stdscr . clear ( ) [EOL] stdscr . addstr ( [string] . format ( _node . title ) ) [EOL] stdscr . addstr ( [string] ) [EOL] [EOL] for cell in _node . cells : [EOL] stdscr . addstr ( [string] ) [EOL] lines = textwrap . wrap ( cell . render ( ) , [number] ) [EOL] for line in lines : [EOL] stdscr . addstr ( line + [string] ) [EOL] [EOL] c = stdscr . getch ( ) [EOL] kmap . press ( c , stdscr ) [EOL] [EOL] if search_mode : [EOL] stdscr . addstr ( [string] + search_buffer + [string] ) [EOL] nodes = notebook . titles ( search_buffer ) [EOL] stdscr . addstr ( [string] + [string] . join ( [ node . title for node in nodes ] ) + [string] ) [EOL] stdscr . addstr ( search_index + [number] , [number] , [string] ) [EOL] c = stdscr . getch ( ) [EOL] stdscr . clear ( ) [EOL] [EOL] if c == curses . KEY_ENTER or c == [number] or c == [number] : [EOL] search_mode = False [EOL] search_buffer = [string] [EOL] if c == curses . KEY_ENTER or c == [number] : [EOL] active_node = selected_node [EOL] continue [EOL] if c == curses . KEY_BACKSPACE : [EOL] search_buffer = search_buffer [ : - [number] ] [EOL] elif nodes and c == curses . KEY_UP : [EOL] search_index -= [number] [EOL] search_index = search_index % len ( nodes ) [EOL] elif nodes and c == curses . KEY_DOWN : [EOL] search_index += [number] [EOL] search_index = search_index % len ( nodes ) [EOL] elif chr ( c ) . isalpha ( ) or c == [number] : [EOL] search_buffer += chr ( c ) [EOL] selected_node = nodes [ search_index ] . id [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( prog = [string] , description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] curses . wrapper ( main , args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $None$ 0 0 $None$ 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import builtins [EOL] import graphbook [EOL] import typing [EOL] import flask [EOL] from flask import Flask , Response [EOL] from typing import Any [EOL] import json [EOL] import os [EOL] import sys [EOL] from graphbook import graph [EOL] [EOL] [EOL] def to_json ( v , status = [number] ) : [EOL] return Response ( json . dumps ( v ) , status = status , mimetype = [string] ) [EOL] [EOL] [EOL] notebook_dir = os . getcwd ( ) [EOL] if len ( sys . argv ) > [number] : [EOL] notebook_dir = sys . argv [ [number] ] [EOL] [EOL] [EOL] app = Flask ( [string] ) [EOL] notebook = graph . notebook . Notebook ( notebook_dir ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def index ( ) : [EOL] nodes = notebook . select ( ) [EOL] return to_json ( { [string] : [ node . to_obj ( ) for node in nodes ] } ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] , [string] ] ) def node_route ( node_id ) : [EOL] node = notebook . noder ( node_id ) [EOL] if node : [EOL] node = node . to_obj ( ) [EOL] return to_json ( { [string] : node } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $graphbook.graph.notebook.Notebook$ 0 0 0 $graphbook.graph.notebook.Notebook$ 0 0 0 $builtins.str$ 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.notebook.Notebook$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.notebook.Notebook$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any , List [EOL] import argparse [EOL] import graphbook [EOL] import typing [EOL] from typing import List , Optional [EOL] import graphbook . graph as graph [EOL] import argparse [EOL] import textwrap [EOL] import urwid [comment] [EOL] [EOL] [EOL] main = None [EOL] notebook = None [EOL] node_stack = [ ] [EOL] DEFAULT_PATH = [string] [EOL] [EOL] [EOL] def build_node_display ( node_id ) : [EOL] node = notebook . noder ( node_id ) [EOL] body = [ urwid . Text ( [string] + node . title ) , urwid . Divider ( ) ] [EOL] for cell in node . cells : [EOL] body . append ( urwid . Text ( cell . render ( ) ) ) [EOL] body . append ( urwid . Text ( [string] ) ) [EOL] if node . links : [EOL] body . append ( urwid . Divider ( ) ) [EOL] body . append ( urwid . Text ( [string] ) ) [EOL] for link in node . links : [EOL] lnode = notebook . nodes [ link ] [EOL] button = urwid . Button ( lnode . title ) [EOL] urwid . connect_signal ( button , [string] , jump_nodes , ( node , lnode ) ) [EOL] body . append ( urwid . AttrMap ( button , None , focus_map = [string] ) ) [EOL] body . append ( urwid . Divider ( ) ) [EOL] return urwid . Pile ( body ) [EOL] [EOL] [EOL] def jump_nodes ( button , nodeinfo ) : [EOL] ( prev_node , lnode ) = nodeinfo [EOL] print ( prev_node ) [EOL] print ( lnode ) [EOL] node_stack . append ( prev_node ) [EOL] display_node ( button , lnode ) [EOL] [EOL] [EOL] def display_node ( button , node ) : [EOL] body = build_node_display ( node . id ) [EOL] [EOL] done = urwid . Button ( [string] ) [EOL] urwid . connect_signal ( done , [string] , display ) [EOL] main . original_widget = urwid . Filler ( urwid . Pile ( [ body , urwid . AttrMap ( done , None , focus_map = [string] ) ] ) ) [EOL] [EOL] [EOL] def menu ( ) : [EOL] body = [ urwid . Text ( [string] ) , urwid . Divider ( ) ] [EOL] nodes = notebook . select ( ) [EOL] for node in nodes : [EOL] button = urwid . Button ( node . title ) [EOL] urwid . connect_signal ( button , [string] , display_node , node ) [EOL] body . append ( urwid . AttrMap ( button , None , focus_map = [string] ) ) [EOL] return urwid . ListBox ( urwid . SimpleFocusListWalker ( body ) ) [EOL] [EOL] [EOL] def exit_program ( button ) : [EOL] raise urwid . ExitMainLoop ( ) [EOL] [EOL] [EOL] def keypress_exit ( key ) : [EOL] if key in [ [string] , [string] , [string] ] : [EOL] raise urwid . ExitMainLoop [EOL] [EOL] [EOL] def setup_notebook ( args ) : [EOL] global notebook [EOL] [EOL] if not notebook : [EOL] notebook = graph . notebook . Notebook ( args . path ) [EOL] [EOL] [EOL] def display ( * args ) : [EOL] global main [EOL] global node_stack [EOL] [EOL] base_widget = menu ( ) [EOL] if node_stack : [EOL] node = node_stack . pop ( ) [EOL] base_widget = display ( node ) [EOL] main = urwid . Padding ( base_widget , left = [number] , right = [number] ) [EOL] top = urwid . Overlay ( main , urwid . SolidFill ( [string] ) , align = [string] , width = ( [string] , [number] ) , valign = [string] , height = ( [string] , [number] ) , min_width = [number] , min_height = [number] , ) [EOL] urwid . MainLoop ( top , palette = [ ( [string] , [string] , [string] ) ] , unhandled_input = keypress_exit ) . run ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( prog = [string] , description = [string] ) [EOL] [EOL] [comment] [EOL] parser . add_argument ( [string] , help = [string] , default = DEFAULT_PATH , nargs = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] setup_notebook ( args ) [EOL] display ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 $typing.Optional[graphbook.graph.notebook.Notebook]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $None$ 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] import tkinter as tk [EOL] [EOL] [EOL] class Application ( tk . Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] self . super ( ) . __init__ ( master ) [EOL] self . master = master [EOL] self . pack ( ) [EOL] self . create_widgets ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Optional , Tuple , List , Any , Type , ChainMap [EOL] import builtins [EOL] import graphbook [EOL] import typing [EOL] import collections [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from collections import ChainMap as Environment [EOL] from collections import namedtuple [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import math [EOL] import operator as op [EOL] import sys [EOL] [EOL] Symbol = str [EOL] Number = ( int , float ) [EOL] Atom = ( Symbol , Number ) [EOL] List = list [comment] [EOL] Exp = ( Atom , List ) [EOL] [EOL] [EOL] def tokenise ( expr ) : [EOL] return expr . replace ( [string] , [string] ) . replace ( [string] , [string] ) . split ( ) [EOL] [EOL] [EOL] def atom ( token ) : [comment] [EOL] try : [EOL] return int ( token ) [EOL] except ValueError : [EOL] try : [EOL] return float ( token ) [EOL] except ValueError : [EOL] return Symbol ( token ) [EOL] [EOL] [EOL] def expression_from_tokens ( tokens ) : [comment] [EOL] [docstring] [EOL] if not tokens : [EOL] raise SyntaxError ( [string] ) [EOL] token = tokens . pop ( [number] ) [EOL] if token == [string] : [EOL] L = [ ] [comment] [EOL] while tokens [ [number] ] != [string] : [EOL] L . append ( expression_from_tokens ( tokens ) ) [EOL] tokens . pop ( [number] ) [comment] [EOL] return L [EOL] elif token == [string] : [EOL] raise SyntaxError ( [string] ) [EOL] else : [EOL] return atom ( token ) [EOL] [EOL] [EOL] def standard_env ( ) : [EOL] [docstring] [EOL] env = { } [EOL] env . update ( vars ( math ) ) [EOL] [EOL] scrub_keys = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] for key in scrub_keys : [EOL] env . pop ( key , None ) [EOL] [EOL] env . update ( { [string] : op . add , [string] : op . sub , [string] : op . mul , [string] : op . truediv , [string] : op . gt , [string] : op . lt , [string] : op . ge , [string] : op . le , [string] : op . eq , [string] : abs , [string] : op . add , [string] : lambda proc , args : proc ( * args ) , [string] : lambda * x : x [ - [number] ] , [string] : lambda x : x [ [number] ] , [string] : lambda x : x [ [number] : ] , [string] : lambda x , y : [ x ] + y , [string] : op . is_ , [string] : op . eq , [string] : len , [string] : lambda * x : list ( x ) , [string] : lambda x : isinstance ( x , list ) , [string] : lambda * args : list ( map ( * args ) ) , [string] : max , [string] : min , [string] : op . not_ , [string] : lambda x : x == [ ] , [string] : lambda x : isinstance ( x , Number ) , [string] : callable , [string] : round , [string] : lambda x : isinstance ( x , Symbol ) , } ) [EOL] [EOL] return env [EOL] [EOL] [EOL] def eval ( exp , env ) : [EOL] [docstring] [EOL] if isinstance ( exp , Symbol ) : [EOL] return env [ exp ] [EOL] elif not isinstance ( exp , List ) : [EOL] return exp [EOL] elif exp [ [number] ] == [string] : [EOL] return exp [ [number] : ] [EOL] elif exp [ [number] ] == [string] : [EOL] ( _ , cond , texp , fexp ) = exp [EOL] if eval ( cond , env ) : [EOL] return eval ( texp , env ) [EOL] return eval ( fexp , env ) [EOL] elif exp [ [number] ] == [string] : [EOL] ( _ , var , _exp ) = exp [EOL] env [ var ] = eval ( _exp , env ) [EOL] elif exp [ [number] ] == [string] : [EOL] ( _ , params , body ) = exp [EOL] return Procedure ( params , body , env ) [EOL] else : [EOL] proc = eval ( exp [ [number] ] , env ) [EOL] args = [ eval ( arg , env ) for arg in exp [ [number] : ] ] [EOL] return proc ( * args ) [EOL] [EOL] [EOL] class Procedure : [EOL] def __init__ ( self , params , body , env ) : [EOL] self . params = params [EOL] self . body = body [EOL] self . env = env [EOL] [EOL] def __call__ ( self , * args ) : [EOL] env = Environment ( dict ( zip ( self . params , args ) ) , self . env ) [EOL] return eval ( self . body , env ) [EOL] [EOL] [EOL] class Interpreter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , program = None ) : [EOL] [EOL] [docstring] [EOL] self . reset ( ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] def reset ( self ) : [EOL] [docstring] [EOL] self . env = standard_env ( ) [EOL] [EOL] def eval ( self , program ) : [comment] [EOL] [docstring] [EOL] tokens = tokenise ( program ) [EOL] result = None [EOL] while tokens : [EOL] expr = expression_from_tokens ( tokens ) [comment] [EOL] result = eval ( expr , self . env ) [EOL] if result is None : [EOL] return [string] [EOL] return result [EOL] [EOL] def load_file ( self , path ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as pgm_file : [EOL] return self . eval ( pgm_file . read ( ) ) [EOL] [EOL] [EOL] def standalone ( paths ) : [EOL] [docstring] [EOL] interpreter = Interpreter ( ) [EOL] result = None [EOL] for path in paths : [EOL] sys . stdout . write ( path + [string] ) [EOL] result = interpreter . load_file ( path ) [EOL] print ( result ) [EOL] return result [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) > [number] : [EOL] standalone ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Atom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Exp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.ChainMap[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.ChainMap[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $collections.ChainMap[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Exp$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] from graphbook . vm import uscheme [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , List , Set [EOL] import builtins [EOL] import graphbook [EOL] import typing [EOL] [docstring] [EOL] from __future__ import annotations [EOL] import graphbook . graph . cell as cell [EOL] from typing import List , Optional , Set [EOL] from uuid import uuid4 [EOL] [EOL] [EOL] class Node : [EOL] [docstring] [EOL] [EOL] id = ... [EOL] title = ... [EOL] cells = ... [EOL] links = ... [EOL] tags = ... [EOL] [EOL] def __init__ ( self , title ) : [EOL] [docstring] [EOL] self . id = str ( uuid4 ( ) ) [EOL] self . title = title [EOL] self . cells = [ ] [EOL] self . links = set ( ) [EOL] self . tags = set ( ) [EOL] [EOL] def add ( self , cell ) : [EOL] [docstring] [EOL] self . cells . append ( cell ) [EOL] [EOL] def remove ( self , index = None ) : [EOL] [docstring] [EOL] if index is not None : [EOL] self . cells = self . cells [ : index ] + self . cells [ index + [number] : ] [EOL] [EOL] def insert ( self , cell , index ) : [EOL] [docstring] [EOL] self . cells . insert ( index , cell ) [EOL] [EOL] def to_obj ( self ) : [EOL] [docstring] [EOL] return { [string] : self . id , [string] : self . title , [string] : list ( self . links ) , [string] : [ c . to_obj ( ) for c in self . cells ] , [string] : list ( self . tags ) , } [EOL] [EOL] def link ( self , node ) : [EOL] [docstring] [EOL] self . links . add ( node . id ) [EOL] [EOL] @ classmethod def from_obj ( cls , obj ) : [EOL] [docstring] [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] [EOL] n = cls ( obj [ [string] ] ) [EOL] n . id = obj [ [string] ] [EOL] n . links = set ( obj [ [string] ] ) [EOL] if [string] in obj : [EOL] n . cells = [ cell . load_cell ( cobj ) for cobj in obj [ [string] ] ] [EOL] [EOL] if [string] in obj : [EOL] n . tags = set ( obj [ [string] ] ) [EOL] [EOL] return n [EOL] [EOL] def tag ( self , tag ) : [EOL] [docstring] [EOL] self . tags . add ( tag ) [EOL] [EOL] def untag ( self , tag ) : [EOL] [docstring] [EOL] if tag in self . tags : [EOL] self . tags . remove ( tag ) [EOL] [EOL] def render ( self ) : [EOL] [docstring] [EOL] return [string] . join ( [ c . render ( ) for c in self . cells ] ) [EOL] [EOL] [comment] [EOL] [EOL] def __getitem__ ( self , i ) : [EOL] return self . cells [ i ] [EOL] [EOL] def __setitem__ ( self , i , c ) : [EOL] self . cells [ i ] = c [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , self . __class__ ) : [EOL] return NotImplemented [EOL] [EOL] if self . id != other . id : [EOL] return False [EOL] [EOL] if self . title != other . title : [EOL] return False [EOL] [EOL] if self . links != other . links : [EOL] return False [EOL] [EOL] if len ( self . cells ) != len ( other . cells ) : [EOL] return False [EOL] [EOL] for i in range ( len ( self . cells ) ) : [EOL] if self . cells [ i ] != other . cells [ i ] : [EOL] return False [EOL] [EOL] if self . tags != other . tags : [EOL] return False [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[graphbook.graph.cell.Cell]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[graphbook.graph.cell.Cell]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $graphbook.graph.cell.Cell$ 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.cell.Cell$ 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[graphbook.graph.cell.Cell]$ 0 0 0 $typing.List[graphbook.graph.cell.Cell]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.List[graphbook.graph.cell.Cell]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.cell.Cell$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $graphbook.graph.cell.Cell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 $builtins.str$ 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 $typing.List[graphbook.graph.cell.Cell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.cell.Cell$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $graphbook.graph.cell.Cell$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $graphbook.graph.cell.Cell$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import yaml [EOL] from typing import Any , Dict [EOL] [EOL] [EOL] def to_yaml ( obj ) : [EOL] [docstring] [EOL] return yaml . dump ( obj , Dumper = yaml . SafeDumper ) [EOL] [EOL] [EOL] def from_yaml ( data ) : [EOL] [docstring] [EOL] return yaml . load ( data , Loader = yaml . SafeLoader ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import graphbook . graph . cell as cell [EOL] import graphbook . graph . node as node [EOL] import graphbook . graph . notebook as notebook [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Optional , Set , List , Iterable , Any [EOL] import builtins [EOL] import graphbook [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] from collections import namedtuple [EOL] from typing import Any , Dict , Iterable , List , Optional , Set [EOL] import graphbook . graph . node as node [EOL] from graphbook . graph . serial import from_yaml , to_yaml [EOL] import os [EOL] from uuid import uuid4 [EOL] [EOL] [EOL] class NodeEntry : [EOL] [docstring] [EOL] [EOL] id = ... [EOL] title = ... [EOL] tags = ... [EOL] links = ... [EOL] [EOL] def __init__ ( self , id , title , tags , links ) : [EOL] self . id = id [EOL] self . title = title [EOL] self . tags = list ( tags ) [EOL] self . links = list ( links ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , self . __class__ ) : [EOL] return NotImplemented [EOL] [EOL] if self . id != other . id : [EOL] return False [EOL] [EOL] if self . title != other . title : [EOL] return False [EOL] [EOL] if self . tags != other . tags : [EOL] return False [EOL] [EOL] if self . links != other . links : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if not isinstance ( other , self . __class__ ) : [EOL] return NotImplemented [EOL] return self . id < other . id [EOL] [EOL] def to_obj ( self ) : [EOL] [docstring] [EOL] return { [string] : self . id , [string] : self . title , [string] : self . tags , [string] : self . links , } [EOL] [EOL] @ classmethod def from_obj ( cls , obj ) : [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] if [string] not in obj : [EOL] raise ( ValueError ( [string] ) ) [EOL] [EOL] return NodeEntry ( obj [ [string] ] , obj [ [string] ] , obj [ [string] ] , obj [ [string] ] ) [EOL] [EOL] [EOL] class Notebook : [EOL] [docstring] [EOL] [EOL] id = ... [EOL] path = ... [EOL] abspath = ... [EOL] tags = ... [EOL] nodes = ... [EOL] [EOL] def __init__ ( self , path = [string] ) : [EOL] self . id = str ( uuid4 ( ) ) [EOL] self . path = path [EOL] self . abspath = os . path . abspath ( self . path ) + os . sep [EOL] self . tags = { } [EOL] self . nodes = { } [EOL] if not os . path . isdir ( self . path ) : [EOL] os . mkdir ( self . path ) [EOL] self . scan ( ) [EOL] [EOL] def _is_maybe_node ( self , path ) : [EOL] [comment] [EOL] full_path = os . path . abspath ( os . path . join ( self . path , path ) ) [EOL] if not path . endswith ( [string] ) : [EOL] return False [EOL] if not os . path . isfile ( full_path ) : [EOL] return False [EOL] return True [EOL] [EOL] def scan ( self ) : [EOL] [docstring] [EOL] self . tags = { } [EOL] self . nodes = { } [EOL] [EOL] listing = os . listdir ( self . path ) [EOL] nodes = [ os . path . join ( self . path , path ) for path in listing if self . _is_maybe_node ( path ) ] [EOL] [EOL] for node_path in nodes : [EOL] self . _noder ( node_path ) [EOL] [EOL] return len ( nodes ) [EOL] [EOL] def noder ( self , node_id ) : [EOL] [docstring] [EOL] node_path = os . path . join ( self . abspath , node_id ) + [string] [EOL] return self . _noder ( node_path ) [EOL] [EOL] def _noder ( self , node_path ) : [EOL] try : [EOL] with open ( node_path , [string] ) as node_file : [EOL] nobj = from_yaml ( node_file . read ( ) ) [EOL] except FileNotFoundError : [EOL] return None [EOL] [EOL] _node = node . Node . from_obj ( nobj ) [EOL] self . _update_node ( _node ) [EOL] return node . Node . from_obj ( nobj ) [EOL] [EOL] def nodew ( self , _node ) : [EOL] [docstring] [EOL] self . _update_node ( _node ) [EOL] nobj = _node . to_obj ( ) [EOL] with open ( os . path . join ( self . path , _node . id + [string] ) , [string] ) as node_file : [EOL] node_file . write ( to_yaml ( nobj ) ) [EOL] [EOL] def _update_node ( self , _node ) : [EOL] self . nodes [ _node . id ] = NodeEntry ( _node . id , _node . title , _node . tags , _node . links ) [EOL] for tag in _node . tags : [EOL] if tag not in self . tags : [EOL] self . tags [ tag ] = set ( ) [EOL] self . tags [ tag ] . add ( tag ) [EOL] [EOL] def select ( self , text = [string] , cased = False , and_tags = None ) : [EOL] [docstring] [EOL] startswith = [ ] [EOL] contains = [ ] [EOL] [EOL] if text == [string] : [EOL] startswith = sorted ( self . nodes . values ( ) ) [EOL] else : [EOL] if not cased : [EOL] text = text . lower ( ) [EOL] [EOL] for n in self . nodes . values ( ) : [EOL] title = n . title [EOL] if not cased : [EOL] title = n . title . lower ( ) [EOL] if title . startswith ( text ) : [EOL] startswith . append ( n ) [EOL] elif text in title : [EOL] contains . append ( n ) [EOL] [EOL] startswith . extend ( contains ) [EOL] [EOL] if and_tags : [EOL] tagset = set ( and_tags ) [EOL] startswith = [ nentry for nentry in startswith if tagset . issubset ( nentry . tags ) ] [EOL] return startswith [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $NodeEntry$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,NodeEntry]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Optional[graphbook.graph.node.Node]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[graphbook.graph.node.Node]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 $typing.Any$ 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 0 $graphbook.graph.node.Node$ 0 0 0 $graphbook.graph.node.Node$ 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 $graphbook.graph.node.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[NodeEntry]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 $typing.List[NodeEntry]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 $builtins.str$ 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.List[NodeEntry]$ 0 0 0 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 $typing.List[NodeEntry]$ 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 0 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[graphbook.graph.notebook.NodeEntry]$ 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from context import cell , node , notebook [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] [EOL] demobook = notebook . Notebook ( [string] ) [EOL] [EOL] [EOL] def test_demobook ( ) : [EOL] assert ( len ( demobook . nodes ) == [number] ) [EOL] assert ( len ( demobook . nodes ) == len ( demobook . select ( ) ) ) [EOL] results = demobook . select ( [string] ) [EOL] assert ( len ( results ) == [number] ) [EOL] [EOL] node_ids = list ( demobook . nodes . keys ( ) ) [EOL] _node = demobook . noder ( node_ids [ [number] ] ) [EOL] assert ( _node . id == node_ids [ [number] ] ) [EOL] [EOL] assert ( len ( demobook . select ( [string] , and_tags = [ [string] ] ) ) < len ( demobook . nodes ) ) [EOL] [EOL] def test_is_maybe_path ( ) : [EOL] assert ( not ( demobook . _is_maybe_node ( [string] ) ) ) [EOL] assert ( not ( demobook . _is_maybe_node ( [string] + [string] ) ) ) [EOL] assert ( demobook . noder ( [string] ) is None ) [EOL] [EOL] def test_newnotebook ( ) : [EOL] try : [EOL] fd , tempdir = tempfile . mkstemp ( ) [EOL] os . close ( fd ) [EOL] os . unlink ( tempdir ) [EOL] [EOL] nb = notebook . Notebook ( tempdir ) [EOL] _node = node . Node ( [string] ) [EOL] _node . add ( cell . TextCell ( [string] ) ) [EOL] [EOL] nb . nodew ( _node ) [EOL] assert ( nb . scan ( ) == [number] ) [EOL] [EOL] finally : [EOL] shutil . rmtree ( tempdir ) [EOL] [EOL] def test_nodeentry ( ) : [EOL] nentry = demobook . select ( ) [ [number] ] [EOL] assert ( notebook . NodeEntry . from_obj ( nentry . to_obj ( ) ) == nentry ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from context import cell , uscheme [EOL] import os , tempfile [EOL] [EOL] def test_uscheme_cell ( ) : [EOL] program = [string] [EOL] program_bytes = program . encode ( [string] ) [EOL] uscheme_cell = cell . MicroSchemeCell ( program_bytes ) [EOL] assert ( uscheme_cell . render ( ) == program ) [EOL] assert ( uscheme_cell . is_executable ( ) ) [EOL] assert ( uscheme_cell . execute ( ) == [string] ) [EOL] [EOL] def test_uscheme_load_file ( ) : [EOL] program = [string] [EOL] fd , tfile = tempfile . mkstemp ( suffix = [string] , text = True ) [EOL] os . write ( fd , program . encode ( [string] ) ) [EOL] os . close ( fd ) [EOL] [EOL] try : [EOL] result = uscheme . standalone ( [ tfile ] ) [EOL] assert ( result == [number] ) [EOL] finally : [EOL] os . remove ( tfile ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from context import cell , node , to_yaml , from_yaml [EOL] [EOL] n1 = None [EOL] [EOL] def test_node ( ) : [EOL] global n1 [EOL] n1 = node . Node ( [string] ) [EOL] cells = [ [string] , [string] , [string] ] [EOL] cells = list ( map ( cell . TextCell , cells ) ) [EOL] for c in cells : [EOL] n1 . add ( c ) [EOL] [EOL] n1 . tag ( [string] ) [EOL] n1 . tag ( [string] ) [EOL] assert ( len ( n1 . tags ) == [number] ) [EOL] [EOL] assert ( len ( n1 . cells ) == len ( cells ) ) [EOL] nobj = n1 . to_obj ( ) [EOL] n2 = node . Node . from_obj ( nobj ) [EOL] assert ( n1 == n2 ) [EOL] [EOL] assert ( [string] in n2 . tags ) [EOL] [EOL] n1 . untag ( [string] ) [EOL] assert ( len ( n1 . tags ) == [number] ) [EOL] [EOL] [EOL] def test_node_yaml ( ) : [EOL] nobj = n1 . to_obj ( ) [EOL] nser = to_yaml ( nobj ) [EOL] n2 = node . Node . from_obj ( from_yaml ( nser ) ) [EOL] assert ( n1 == n2 ) [EOL] [EOL] def test_remove ( ) : [EOL] cells = n1 . cells [EOL] n1 . cells = [ [number] , [number] , [number] ] [EOL] n1 . remove ( [number] ) [EOL] assert ( [number] in n1 . cells ) [EOL] assert ( [number] in n1 . cells ) [EOL] [EOL] n1 . remove ( [number] ) [EOL] assert ( [number] in n1 . cells ) [EOL] n1 . remove ( ) [EOL] assert ( [number] in n1 . cells ) [EOL] n1 . remove ( [number] ) [EOL] assert ( len ( n1 . cells ) == [number] ) [EOL] [EOL] n1 . cells = [ [number] , [number] , [number] ] [EOL] assert ( n1 [ [number] ] == [number] ) [EOL] assert ( n1 [ [number] ] == [number] ) [EOL] assert ( n1 [ [number] ] == [number] ) [EOL] n1 [ [number] ] = [number] [EOL] assert ( n1 [ [number] ] == [number] ) [EOL] [EOL] n1 . cells = cells [EOL] [EOL] def test_insert ( ) : [EOL] cells = n1 . cells [EOL] n1 . cells = [ [number] , [number] , [number] ] [EOL] n1 . insert ( [number] , [number] ) [EOL] [EOL] assert ( n1 . cells [ [number] ] == [number] ) [EOL] [EOL] n1 . insert ( [number] , [number] ) [EOL] assert ( n1 . cells [ [number] ] == [number] ) [EOL] n1 . cells = cells [EOL] [EOL] def test_render ( ) : [EOL] cells = [ cell . TextCell ( [string] ) , cell . TextCell ( [string] ) , ] [EOL] [EOL] rendered = [string] [EOL] [EOL] n1 = node . Node ( [string] ) [EOL] n1 . add ( cells [ [number] ] ) [EOL] n1 . add ( cells [ [number] ] ) [EOL] assert ( n1 . render ( ) == rendered ) [EOL] [EOL] def test_link ( ) : [EOL] n2 = node . Node ( [string] ) [EOL] n2 . add ( cell . TextCell ( [string] ) ) [EOL] [EOL] n1 . link ( n2 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0
import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) ) [EOL] [EOL] import graphbook . graph . cell as cell [EOL] import graphbook . graph . node as node [EOL] import graphbook . graph . notebook as notebook [EOL] from graphbook . graph . serial import from_yaml , to_yaml [EOL] from graphbook . vm import uscheme [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from context import cell , to_yaml , from_yaml [EOL] import pytest [EOL] [EOL] def test_cell ( ) : [EOL] print ( [string] ) [EOL] c1 = cell . TextCell ( [string] ) [EOL] assert ( not ( c1 . is_executable ( ) ) ) [EOL] [EOL] print ( [string] ) [EOL] cobj = c1 . to_obj ( ) [EOL] [EOL] print ( [string] ) [EOL] c2 = cell . load_cell ( cobj ) [EOL] [EOL] print ( [string] ) [EOL] assert ( c1 == c2 ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def test_cell_yaml ( ) : [EOL] c1 = cell . TextCell ( [string] ) [EOL] cobj = c1 . to_obj ( ) [EOL] cser = to_yaml ( cobj ) [EOL] c2 = cell . load_cell ( from_yaml ( cser ) ) [EOL] assert ( c1 == c2 ) [EOL] [EOL] c3 = c1 . dup ( ) [EOL] assert ( c1 != c3 ) [EOL] [EOL] def test_load_cell ( ) : [EOL] c1 = cell . TextCell ( [string] ) [EOL] cobj = c1 . to_obj ( ) [EOL] [EOL] del ( cobj [ [string] ] ) [EOL] with pytest . raises ( TypeError ) : [EOL] cell . load_cell ( cobj ) [EOL] [EOL] cobj [ [string] ] = [string] [EOL] with pytest . raises ( KeyError ) : [EOL] cell . load_cell ( cobj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0