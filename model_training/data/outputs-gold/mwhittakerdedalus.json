from typing import Optional , List , Callable , Any [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] [EOL] import desugar [EOL] import parser [EOL] [EOL] class TestDesugar ( unittest . TestCase ) : [EOL] def _strip_leading_whitespace ( self , s ) : [EOL] lines = [ line . strip ( ) for line in s . split ( [string] ) if line . strip ( ) != [string] ] [EOL] return [string] . join ( lines ) [EOL] [EOL] def test_desugar ( self ) : [EOL] get_program = lambda : parser . parse ( [string] ) [EOL] program = get_program ( ) [EOL] desugared = desugar . desugar ( program ) [EOL] [EOL] expected = self . _strip_leading_whitespace ( [string] ) [EOL] [EOL] [comment] [EOL] self . maxDiff = None [comment] [EOL] self . assertEqual ( str ( desugared ) , expected ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( program , get_program ( ) ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import asts [EOL] import builtins [EOL] import typing [EOL] import copy [EOL] [EOL] import asts [EOL] [EOL] def _atom_contains_location ( atom ) : [EOL] return any ( term . is_location for term in atom . terms ) [EOL] [EOL] def desugar ( program ) : [EOL] program = copy . deepcopy ( program ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for rule in program . rules : [EOL] atoms = [ rule . head ] + [ literal . atom for literal in rule . body ] [EOL] if any ( _atom_contains_location ( atom ) for atom in atoms ) : [EOL] continue [EOL] L = asts . Variable ( [string] , is_location = True ) [EOL] for atom in atoms : [EOL] atom . terms . insert ( [number] , L ) [EOL] [EOL] return program [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asts.Program$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] import parsec [EOL] [EOL] import parser [EOL] [EOL] class TestParser ( unittest . TestCase ) : [EOL] def test_good_programs ( self ) : [EOL] good_programs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] [string] , ] [EOL] [EOL] for good_program in good_programs : [EOL] try : [EOL] parser . parse ( good_program ) [EOL] except parsec . ParseError as e : [EOL] print ( good_program ) [EOL] raise e [EOL] [EOL] def test_bad_programs ( self ) : [EOL] bad_programs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] for bad_program in bad_programs : [EOL] with self . assertRaises ( parsec . ParseError ) : [EOL] parser . parse ( bad_program ) [EOL] print ( bad_program ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , List , Tuple [EOL] import asts [EOL] import builtins [EOL] import typing [EOL] from typing import List , Set , Tuple [EOL] import unittest [EOL] [EOL] import networkx as nx [EOL] [EOL] from desugar import desugar [EOL] from typecheck import typecheck [EOL] import parser [EOL] import asts [EOL] [EOL] class TestAsts ( unittest . TestCase ) : [EOL] def predicate ( self , x ) : [EOL] return parser . predicate . parse_strict ( x ) [EOL] [EOL] def test_program_predicates ( self ) : [EOL] test_cases = [ ( [string] , { [string] } ) , ( [string] , { [string] , [string] } ) , ( [string] , { [string] , [string] , [string] } ) , ( [string] , { [string] , [string] , [string] , [string] , [string] , [string] } ) , ] [EOL] for source , predicates in test_cases : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] expected = { self . predicate ( p ) for p in predicates } [EOL] self . assertEqual ( program . predicates ( ) , expected ) [EOL] [EOL] def test_program_idb ( self ) : [EOL] test_cases = [ ( [string] , set ( ) ) , ( [string] , { [string] } ) , ( [string] , { [string] } ) , ( [string] , { [string] } ) , ] [EOL] for source , predicates in test_cases : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] expected = { self . predicate ( p ) for p in predicates } [EOL] self . assertEqual ( program . idb ( ) , expected ) [EOL] [EOL] def test_program_edb ( self ) : [EOL] test_cases = [ ( [string] , { [string] } ) , ( [string] , { [string] } ) , ( [string] , { [string] , [string] } ) , ( [string] , { [string] } ) , ] [EOL] for source , predicates in test_cases : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] expected = { self . predicate ( p ) for p in predicates } [EOL] self . assertEqual ( program . edb ( ) , expected ) [EOL] [EOL] def test_program_persistent_edb ( self ) : [EOL] test_cases = [ ( [string] , { [string] } ) , ( [string] , set ( ) ) , ( [string] , set ( ) ) , ( [string] , set ( ) ) , ] [EOL] for source , predicates in test_cases : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] expected = { self . predicate ( p ) for p in predicates } [EOL] self . assertEqual ( program . persistent_edb ( ) , expected ) [EOL] [EOL] def test_program_is_positive ( self ) : [EOL] positive_programs = [ [string] , [string] , [string] , ] [EOL] for source in positive_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertTrue ( program . is_positive ( ) ) [EOL] [EOL] negative_programs = [ [string] , [string] , ] [EOL] for source in negative_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertFalse ( program . is_positive ( ) ) [EOL] [EOL] def test_program_is_semipositive ( self ) : [EOL] semipositive_programs = [ [string] , [string] , [string] , [string] , ] [EOL] for source in semipositive_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertTrue ( program . is_semipositive ( ) ) [EOL] [EOL] not_semipositive_programs = [ [string] , ] [EOL] for source in not_semipositive_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertFalse ( program . is_semipositive ( ) ) [EOL] [EOL] def test_program_deductive_pdg ( self ) : [EOL] source = [string] [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] dpdg = program . deductive_pdg ( ) [EOL] [EOL] a = self . predicate ( [string] ) [EOL] b = self . predicate ( [string] ) [EOL] c = self . predicate ( [string] ) [EOL] expected = nx . DiGraph ( ) [EOL] expected . add_nodes_from ( [ a , b , c ] ) [EOL] expected . add_edges_from ( [ ( a , b ) , ( b , c ) ] ) [EOL] [EOL] self . assertEqual ( dpdg . nodes , expected . nodes ) [EOL] self . assertEqual ( dpdg . edges , expected . edges ) [EOL] self . assertFalse ( dpdg [ a ] [ b ] [ [string] ] ) [EOL] self . assertTrue ( dpdg [ b ] [ c ] [ [string] ] ) [EOL] [EOL] def test_program_is_stratified ( self ) : [EOL] stratified_programs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for source in stratified_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertTrue ( program . is_stratified ( ) , source ) [EOL] [EOL] not_stratified_programs = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] for source in not_stratified_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertFalse ( program . is_stratified ( ) , source ) [EOL] [EOL] def test_program_has_guarded_asynchrony ( self ) : [EOL] guarded_async_programs = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] for source in guarded_async_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertTrue ( program . has_guarded_asynchrony ( ) ) [EOL] [EOL] not_guarded_async_programs = [ [string] , [string] , [string] , ] [EOL] for source in not_guarded_async_programs : [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] self . assertFalse ( program . has_guarded_asynchrony ( ) , source ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , List , Tuple [EOL] import asts [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] from desugar import desugar [EOL] from run import ( Bindings , _eval_rule , _stratify , _subst , _unify , run , spawn , step ) [EOL] from typecheck import typecheck [EOL] import parser [EOL] import asts [EOL] [EOL] [EOL] class TestRun ( unittest . TestCase ) : [EOL] def var ( self , x ) : [EOL] return parser . variable . parse_strict ( x ) [EOL] [EOL] def predicate ( self , x ) : [EOL] return parser . predicate . parse_strict ( x ) [EOL] [EOL] def atom ( self , x ) : [EOL] return parser . atom . parse_strict ( x ) [EOL] [EOL] def test_subst ( self ) : [EOL] A = [string] [EOL] X = [string] [EOL] Y = [string] [EOL] Z = [string] [EOL] [EOL] GoodTestCase = Tuple [ asts . Atom , Bindings , Tuple [ Any , ... ] ] [EOL] good_test_cases = [ ( self . atom ( [string] ) , { } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] , Z : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] , Z : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] , Z : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] , Z : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] , Z : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { X : [string] , Y : [string] , Z : [string] } , ( [string] , [string] , [string] ) ) , ( self . atom ( [string] ) , { A : [string] , X : [string] } , ( [string] , ) ) , ] [EOL] for atom , bindings , expected in good_test_cases : [EOL] self . assertEqual ( _subst ( atom , bindings ) , expected ) [EOL] [EOL] BadTestCase = Tuple [ asts . Atom , Bindings ] [EOL] bad_test_cases = [ ( self . atom ( [string] ) , { } ) , ( self . atom ( [string] ) , { Y : [string] } ) , ( self . atom ( [string] ) , { Y : [string] } ) , ] [EOL] for atom , bindings in bad_test_cases : [EOL] with self . assertRaises ( AssertionError ) : [EOL] _subst ( atom , bindings ) [EOL] print ( atom , bindings ) [EOL] [EOL] def test_unify ( self ) : [EOL] A = [string] [EOL] B = [string] [EOL] C = [string] [EOL] X = [string] [EOL] Y = [string] [EOL] Z = [string] [EOL] a = [string] [EOL] b = [string] [EOL] c = [string] [EOL] x = [string] [EOL] y = [string] [EOL] z = [string] [EOL] [EOL] GoodTestCase = Tuple [ List [ asts . Atom ] , List [ Tuple [ Any , ... ] ] , Optional [ Bindings ] ] [EOL] good_test_cases = [ ( [ ] , [ ] , { } ) , ( [ self . atom ( [string] ) ] , [ ( x , y , z ) ] , { X : x , Y : y , Z : z } ) , ( [ self . atom ( [string] ) ] , [ ( a , y , z ) ] , { Y : y , Z : z } ) , ( [ self . atom ( [string] ) ] , [ ( a , b , z ) ] , { Z : z } ) , ( [ self . atom ( [string] ) ] , [ ( a , b , c ) ] , { } ) , ( [ self . atom ( [string] ) ] , [ ( b , y , z ) ] , None ) , ( [ self . atom ( [string] ) ] , [ ( a , c , z ) ] , None ) , ( [ self . atom ( [string] ) ] , [ ( a , b , a ) ] , None ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( a , b , c ) ] , { X : x , Y : y , Z : z , A : a , B : b , C : c } ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( z , b , c ) ] , { X : x , Y : y , Z : z , B : b , C : c } ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( y , z , c ) ] , { X : x , Y : y , Z : z , C : c } ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( x , y , z ) ] , { X : x , Y : y , Z : z } ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( z , y , x ) ] , { X : x , Y : y , Z : z } ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( a , b , c ) ] , None ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( y , y , c ) ] , None ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( x , y , x ) ] , None ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y , z ) , ( z , y , z ) ] , None ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , y ) , ( y , z ) , ( z , x ) ] , { X : x , Y : y , Z : z } ) , ] [EOL] for atoms , tuples , expected in good_test_cases : [EOL] self . assertEqual ( _unify ( atoms , tuples ) , expected ) [EOL] [EOL] BadTestCase = Tuple [ List [ asts . Atom ] , List [ Tuple [ Any , ... ] ] ] [EOL] bad_test_cases = [ ( [ self . atom ( [string] ) ] , [ ] ) , ( [ ] , [ ( x , ) ] ) , ( [ self . atom ( [string] ) ] , [ ( x , ) ] ) , ( [ self . atom ( [string] ) ] , [ ( x , y ) ] ) , ( [ self . atom ( [string] ) , self . atom ( [string] ) ] , [ ( x , ) ] ) , ] [EOL] for atoms , tuples in bad_test_cases : [EOL] with self . assertRaises ( AssertionError ) : [EOL] _unify ( atoms , tuples ) [EOL] print ( atoms , tuples ) [EOL] [EOL] def test_eval_rule ( self ) : [EOL] source = [string] [EOL] program = parser . parse ( source ) [EOL] program = desugar ( program ) [EOL] program = typecheck ( program ) [EOL] [EOL] q = self . predicate ( [string] ) [EOL] eq = self . predicate ( [string] ) [EOL] leq = self . predicate ( [string] ) [EOL] l , a , b , c , d , e = [string] [EOL] [EOL] process = spawn ( program ) [EOL] process . database [ q ] = { ( l , a , a ) , ( l , a , b ) , ( l , a , c ) , ( l , a , d ) , ( l , b , a ) , ( l , b , b ) , ( l , b , c ) , ( l , b , d ) , ( l , c , a ) , ( l , c , b ) , ( l , c , c ) , ( l , c , d ) , ( l , c , e ) , ( l , d , a ) , ( l , d , b ) , ( l , d , c ) , ( l , d , d ) , ( l , e , c ) , ( l , e , e ) , } [EOL] process . database [ eq ] = { ( l , a , a ) , ( l , b , b ) , ( l , c , c ) , ( l , d , d ) , ( l , e , e ) } [EOL] process . database [ leq ] = { ( l , a , a ) , ( l , a , b ) , ( l , a , c ) , ( l , a , d ) , ( l , a , e ) , ( l , b , b ) , ( l , b , c ) , ( l , b , d ) , ( l , b , e ) , ( l , c , c ) , ( l , c , d ) , ( l , c , e ) , ( l , d , d ) , ( l , d , e ) , ( l , e , e ) , } [EOL] expected = { ( l , a , b , c ) , ( l , a , b , d ) , ( l , a , c , d ) , ( l , b , c , d ) } [EOL] [EOL] actual = set ( _eval_rule ( process , program . rules [ [number] ] ) ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_stratify ( self ) : [EOL] source = [string] [EOL] program = typecheck ( desugar ( parser . parse ( source ) ) ) [EOL] pdg = program . pdg ( ) [EOL] stratification = _stratify ( pdg ) [EOL] [EOL] a = self . predicate ( [string] ) [EOL] b = self . predicate ( [string] ) [EOL] c = self . predicate ( [string] ) [EOL] d = self . predicate ( [string] ) [EOL] e = self . predicate ( [string] ) [EOL] f = self . predicate ( [string] ) [EOL] g = self . predicate ( [string] ) [EOL] h = self . predicate ( [string] ) [EOL] [EOL] self . assertEqual ( len ( stratification ) , [number] ) [EOL] self . assertEqual ( set ( stratification [ [number] ] . nodes ) , { a , b , c } ) [EOL] self . assertEqual ( set ( stratification [ [number] ] . nodes ) , { e , d } ) [EOL] self . assertEqual ( set ( stratification [ [number] ] . nodes ) , { f , g , h } ) [EOL] self . assertEqual ( set ( stratification [ [number] ] . edges ) , { ( a , b ) , ( b , c ) , ( c , a ) } ) [EOL] self . assertEqual ( set ( stratification [ [number] ] . edges ) , { ( e , d ) , ( d , e ) } ) [EOL] self . assertEqual ( set ( stratification [ [number] ] . edges ) , { ( f , g ) , ( g , h ) , ( h , f ) } ) [EOL] [EOL] def test_step ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Set , Generator , FrozenSet , Optional , List , Callable , Any , Type [EOL] import builtins [EOL] import typing [EOL] import asts [EOL] import networkx [EOL] import dedalus [EOL] from collections import defaultdict [EOL] from copy import deepcopy [EOL] from itertools import product [EOL] from typing import ( Any , Callable , DefaultDict , Dict , FrozenSet , Generator , List , NamedTuple , Optional , Set , Tuple ) [EOL] import random [EOL] [EOL] from tabulate import tabulate [EOL] from termcolor import colored [EOL] import networkx as nx [EOL] [EOL] import asts [EOL] [EOL] [EOL] Relation = Set [ Tuple [ Any , ... ] ] [EOL] Database = Dict [ asts . Predicate , Relation ] [EOL] DefaultDatabase = DefaultDict [ asts . Predicate , Relation ] [EOL] AsyncBuffer = DefaultDict [ int , DefaultDatabase ] [EOL] Bindings = Dict [ str , str ] [EOL] RandInt = Callable [ [ ] , int ] [EOL] [EOL] [EOL] class Process ( NamedTuple ) : [EOL] program = ... [EOL] timestep = ... [EOL] database = ... [EOL] async_buffer = ... [EOL] randint = ... [EOL] [EOL] def __str__ ( self ) : [EOL] def underline ( s ) : [EOL] return s + [string] + ( [string] * len ( s ) ) [EOL] [EOL] def colored_relation ( name , t ) : [EOL] return ( colored ( name , [string] , attrs = [ [string] ] ) + [string] + colored ( f' [string] { t } [string] ' , [string] ) ) [EOL] [EOL] def formatted_table ( r ) : [EOL] return tabulate ( sorted ( r ) , tablefmt = [string] ) [EOL] [EOL] ss = [ ] [EOL] [EOL] t = self . timestep - [number] [EOL] ss . append ( underline ( f' [string] { t } [string] ' ) ) [EOL] [EOL] for p in sorted ( self . database ) : [EOL] if len ( self . database [ p ] ) > [number] : [EOL] ss . append ( colored_relation ( p . x , t ) ) [EOL] ss . append ( formatted_table ( self . database [ p ] ) ) [EOL] [EOL] ss . append ( underline ( f' [string] ' ) ) [EOL] [EOL] for t in sorted ( self . async_buffer ) : [EOL] for p in sorted ( self . async_buffer [ t ] ) : [EOL] if len ( self . async_buffer [ t ] [ p ] ) > [number] : [EOL] ss . append ( colored_relation ( p . x , t ) ) [EOL] async_relation = self . async_buffer [ t ] [ p ] [EOL] ss . append ( formatted_table ( async_relation ) ) [EOL] [EOL] return [string] . join ( ss ) [EOL] [EOL] def _empty_database ( program ) : [EOL] return { p : set ( ) for p in program . predicates ( ) } [EOL] [EOL] def _empty_default_database ( ) : [EOL] return defaultdict ( set ) [EOL] [EOL] def _subst ( atom , bindings ) : [EOL] [docstring] [EOL] values = [ ] [EOL] for term in atom . terms : [EOL] if isinstance ( term , asts . Constant ) : [EOL] values . append ( term . x ) [EOL] else : [EOL] assert isinstance ( term , asts . Variable ) [EOL] assert term . x in bindings , ( term . x , bindings ) [EOL] values . append ( bindings [ term . x ] ) [EOL] return tuple ( values ) [EOL] [EOL] def _unify ( atoms , tuples ) : [EOL] [docstring] [EOL] bindings = { } [EOL] assert len ( atoms ) == len ( tuples ) , ( atoms , tuples ) [EOL] for ( atom , tuple_ ) in zip ( atoms , tuples ) : [EOL] assert len ( atom . terms ) == len ( tuple_ ) , ( atom , tuple_ ) [EOL] for ( term , value ) in zip ( atom . terms , tuple_ ) : [EOL] if isinstance ( term , asts . Constant ) : [EOL] if term . x != value : [EOL] return None [EOL] else : [EOL] assert isinstance ( term , asts . Variable ) [EOL] if term . x in bindings and bindings [ term . x ] != value : [EOL] return None [EOL] bindings [ term . x ] = value [EOL] return bindings [EOL] [EOL] def _eval_rule ( process , rule ) : [EOL] [docstring] [EOL] positive_atoms = [ l . atom for l in rule . body if l . is_positive ( ) ] [EOL] negative_atoms = [ l . atom for l in rule . body if l . is_negative ( ) ] [EOL] positive_predicates = [ atom . predicate for atom in positive_atoms ] [EOL] negative_predicates = [ atom . predicate for atom in negative_atoms ] [EOL] [EOL] db = process . database [EOL] positive_relations = [ db [ p ] for p in positive_predicates ] [EOL] for tuples in product ( * positive_relations ) : [EOL] bindings = _unify ( positive_atoms , tuples ) [EOL] if bindings is None : [EOL] continue [EOL] [EOL] if any ( _subst ( a , bindings ) in db [ a . predicate ] for a in negative_atoms ) : [EOL] continue [EOL] [EOL] yield _subst ( rule . head , bindings ) [EOL] [EOL] def _stratify ( pdg ) : [EOL] [docstring] [EOL] components = [ frozenset ( c ) for c in nx . strongly_connected_components ( pdg ) ] [EOL] components_by_node = { node : c for c in components for node in c } [EOL] [EOL] collapsed_pdg = nx . DiGraph ( ) [EOL] collapsed_pdg . add_nodes_from ( components ) [EOL] for ( src , dst ) in pdg . edges : [EOL] src_component = components_by_node [ src ] [EOL] dst_component = components_by_node [ dst ] [EOL] if src_component != dst_component : [EOL] collapsed_pdg . add_edge ( src_component , dst_component ) [EOL] [EOL] stratification = [ ] [EOL] for nodes in nx . topological_sort ( collapsed_pdg ) : [EOL] g = pdg . copy ( ) [EOL] g . remove_nodes_from ( set ( pdg . nodes ) - nodes ) [EOL] stratification . append ( g ) [EOL] return stratification [EOL] [EOL] def spawn ( program , randint = None ) : [EOL] [docstring] [EOL] database = _empty_database ( program ) [EOL] async_buffer = defaultdict ( _empty_default_database ) [EOL] randint = randint or ( lambda : random . randint ( [number] , [number] ) ) [EOL] return Process ( program , [number] , database , async_buffer , randint ) [EOL] [EOL] def step ( process ) : [EOL] [docstring] [EOL] process = deepcopy ( process ) [EOL] [EOL] def is_constant_rule ( rule ) : [EOL] rule_type = rule . rule_type [EOL] if isinstance ( rule . rule_type , asts . ConstantTimeRule ) : [EOL] return rule_type . time == process . timestep [EOL] else : [EOL] return False [EOL] [EOL] constant_rules = [ r for r in process . program . rules if is_constant_rule ( r ) ] [EOL] deductive_rules = [ r for r in process . program . rules if r . is_deductive ( ) ] [EOL] inductive_rules = [ r for r in process . program . rules if r . is_inductive ( ) ] [EOL] async_rules = [ r for r in process . program . rules if r . is_async ( ) ] [EOL] [EOL] db = process . database [EOL] [EOL] [comment] [EOL] for ( p , r ) in db . items ( ) : [EOL] db [ p ] = process . async_buffer [ process . timestep ] [ p ] [EOL] [EOL] [comment] [EOL] for rule in constant_rules : [EOL] for tuple_ in _eval_rule ( process , rule ) : [EOL] db [ rule . head . predicate ] . add ( tuple_ ) [EOL] [EOL] [comment] [EOL] for strata in _stratify ( process . program . deductive_pdg ( ) ) : [EOL] strata_rules = [ r for r in deductive_rules if r . head . predicate in strata . nodes ] [EOL] [EOL] data_changed = True [EOL] while data_changed : [EOL] data_changed = False [EOL] for rule in strata_rules : [EOL] tuples = set ( _eval_rule ( process , rule ) ) [EOL] if len ( tuples - db [ rule . head . predicate ] ) != [number] : [EOL] data_changed = True [EOL] db [ rule . head . predicate ] |= tuples [EOL] [EOL] [comment] [EOL] next_timestep = process . timestep + [number] [EOL] for rule in inductive_rules : [EOL] p = rule . head . predicate [EOL] tuples = set ( _eval_rule ( process , rule ) ) [EOL] process . async_buffer [ next_timestep ] [ p ] |= tuples [EOL] [EOL] [comment] [EOL] for rule in async_rules : [EOL] for tuple_ in _eval_rule ( process , rule ) : [EOL] p = rule . head . predicate [EOL] async_timestep = process . timestep + process . randint ( ) [EOL] process . async_buffer [ async_timestep ] [ p ] . add ( tuple_ ) [EOL] [EOL] timestep = process . timestep [EOL] process = process . _replace ( timestep = next_timestep ) [EOL] del process . async_buffer [ timestep ] [EOL] return process [EOL] [EOL] def run ( process , timesteps ) : [EOL] [docstring] [EOL] for _ in range ( timesteps ) : [EOL] process = step ( process ) [EOL] return process [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asts.Program$ 0 0 0 $builtins.int$ 0 0 0 $Database$ 0 0 0 $AsyncBuffer$ 0 0 0 $RandInt$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $Relation$ 0 0 0 0 0 0 0 0 $Relation$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import asts [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] import networkx as nx [EOL] [EOL] import asts [EOL] [EOL] [EOL] def _fixed_arities ( program ) : [EOL] [docstring] [EOL] arities = { } [EOL] for rule in program . rules : [EOL] for atom in [ rule . head ] + [ l . atom for l in rule . body ] : [EOL] p = atom . predicate . x [EOL] arity = len ( atom . terms ) [EOL] if p in arities and arities [ p ] != arity : [EOL] msg = f' [string] { p } [string] ' [EOL] raise ValueError ( msg ) [EOL] else : [EOL] arities [ p ] = arity [EOL] [EOL] def _range_restricted ( program ) : [EOL] [docstring] [EOL] def range_restricted_rule ( rule ) : [EOL] positive_atoms = [ l . atom for l in rule . body if l . is_positive ( ) ] [EOL] negative_atoms = [ l . atom for l in rule . body if l . is_negative ( ) ] [EOL] head_vars = { v . x for v in rule . head . variables ( ) } [EOL] postive_vars = { v . x for a in positive_atoms for v in a . variables ( ) } [EOL] negative_vars = { v . x for a in negative_atoms for v in a . variables ( ) } [EOL] [EOL] if not ( head_vars <= postive_vars ) : [EOL] unrestricted_head_vars = head_vars - postive_vars [EOL] msg = ( f' [string] { unrestricted_head_vars } [string] ' f' [string] { rule } [string] ' f' [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] if not ( negative_vars <= postive_vars ) : [EOL] unrestricted_body_vars = negative_vars - postive_vars [EOL] msg = ( f' [string] { unrestricted_body_vars } [string] ' f' [string] { rule } [string] ' f' [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] for rule in program . rules : [EOL] range_restricted_rule ( rule ) [EOL] [EOL] def _timestamp_restricted ( program ) : [EOL] [docstring] [EOL] for rule in program . rules : [EOL] if rule . is_constant_time ( ) and len ( rule . body ) != [number] : [EOL] msg = f' [string] { rule } [string] ' [EOL] raise ValueError ( msg ) [EOL] [EOL] def _location_restricted ( program ) : [EOL] [docstring] [EOL] def location_restricted_rule ( rule ) : [EOL] for atom in [ rule . head ] + [ l . atom for l in rule . body ] : [EOL] if len ( atom . terms ) == [number] : [EOL] msg = ( f' [string] { atom } [string] { rule } [string] ' f' [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] if not atom . terms [ [number] ] . is_location : [EOL] msg = ( f' [string] { atom } [string] { rule } [string] ' f' [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] if any ( t . is_location for t in atom . terms [ [number] : ] ) : [EOL] msg = ( f' [string] { atom } [string] { rule } [string] ' f' [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] head_location = rule . head . terms [ [number] ] [EOL] body_locations = { l . atom . terms [ [number] ] for l in rule . body } [EOL] locations = { head_location } | body_locations [EOL] [EOL] if len ( body_locations ) > [number] : [EOL] msg = ( f' [string] { rule } [string] ' f'{ body_locations } [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] if ( rule . is_deductive ( ) or rule . is_inductive ( ) ) and len ( locations ) != [number] : [EOL] msg = ( f' [string] { rule } [string] ' f' [string] ' ) [EOL] raise ValueError ( msg ) [EOL] [EOL] for rule in program . rules : [EOL] location_restricted_rule ( rule ) [EOL] [EOL] def _stratified_deductive_pdg ( program ) : [EOL] def is_negative_cycle ( g , cycle ) : [EOL] for src , dst in zip ( cycle [ : - [number] ] , cycle [ [number] : ] ) : [EOL] if g [ src ] [ dst ] [ [string] ] : [EOL] return True [EOL] return False [EOL] [EOL] if not program . is_deductive_stratified ( ) : [EOL] dpdg = program . deductive_pdg ( ) [EOL] [EOL] msgs = [ ( [string] [string] ) ] [EOL] msgs . append ( f' [string] { dpdg . nodes }' ) [EOL] msgs . append ( f' [string] { dpdg . edges }' ) [EOL] msgs . append ( [string] ) [EOL] for cycle in nx . simple_cycles ( dpdg ) : [EOL] if is_negative_cycle ( dpdg , cycle ) : [EOL] msgs . append ( f' [string] { cycle }' ) [EOL] [EOL] msg = [string] . join ( msgs ) [EOL] raise ValueError ( msg ) [EOL] [EOL] def typecheck ( program ) : [EOL] _fixed_arities ( program ) [EOL] _range_restricted ( program ) [EOL] _timestamp_restricted ( program ) [EOL] _location_restricted ( program ) [EOL] _stratified_deductive_pdg ( program ) [EOL] return program [EOL] [EOL] def typechecks ( program ) : [EOL] try : [EOL] typecheck ( program ) [EOL] return True [EOL] except ValueError : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asts.Program$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0