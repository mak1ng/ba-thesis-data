from typing import Any [EOL] import typing [EOL] from board . board import Board [EOL] from camera . camera import Camera [EOL] from ball . ball import Ball [EOL] from servo . servo import Servos [EOL] [EOL] [EOL] def run ( ) : [EOL] [comment] [EOL] cam = Camera ( ) [EOL] print ( cam . data ( ) ) [EOL] [docstring] [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import wiringpi [EOL] from ball . ball import Ball [EOL] from board . board import Point [EOL] [EOL] class Servo : [EOL] FREQUENCY = [number] [EOL] RANGE = [number] [EOL] DELAY_PERIOD = [number] [EOL] FORWARD = [number] [EOL] BACKWARD = [number] [EOL] STOP = [number] [EOL] [EOL] def __init__ ( self , pin ) : [EOL] self . pin = pin [EOL] self . wiring = wiringpi [EOL] [EOL] self . wiring . wiringPiSetupGpio ( ) [EOL] self . wiring . pinMode ( pin , self . wiring . GPIO . PWM_OUTPUT ) [EOL] self . wiring . pwmSetMode ( self . wiring . GPIO . PWM_MODE_MS ) [EOL] self . wiring . pwmSetClock ( FREQUENCY ) [EOL] self . wiring . pwmSetRange ( RANGE ) [EOL] [EOL] def move_forward ( self , msecs ) : [EOL] for count in range ( msecs ) : [EOL] self . wiring . pwmWrite ( self . pin , FORWARD ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def move_backward ( self , msecs ) : [EOL] for count in range ( msecs ) : [EOL] self . wiring . pwmWrite ( self . pin , BACKWARD ) [EOL] [EOL] [EOL] class Servos : [EOL] [EOL] def __init ( self ) : [EOL] [comment] [EOL] self . horizontal = Servo ( [number] ) [EOL] self . vertical = Servo ( [number] ) [EOL] pass [EOL] [EOL] def move ( self , ball , point ) : [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] import wiringpi [EOL] [EOL] [comment] [EOL] wiringpi . wiringPiSetupGpio ( ) [EOL] [EOL] [comment] [EOL] wiringpi . pinMode ( [number] , wiringpi . GPIO . PWM_OUTPUT ) [EOL] [EOL] [comment] [EOL] wiringpi . pwmSetMode ( wiringpi . GPIO . PWM_MODE_MS ) [EOL] [EOL] [comment] [EOL] wiringpi . pwmSetClock ( [number] ) [EOL] wiringpi . pwmSetRange ( [number] ) [EOL] [EOL] delay_period = [number] [EOL] [EOL] FORWARD = [number] [EOL] BACKWARD = [number] [EOL] STOP = [number] [EOL] [EOL] for i in range ( [number] , [number] ) : [EOL] for count in range ( [number] ) : [EOL] wiringpi . pwmWrite ( [number] , FORWARD ) [EOL] time . sleep ( delay_period ) [EOL] for count in range ( [number] ) : [EOL] wiringpi . pwmWrite ( [number] , BACKWARD ) [EOL] time . sleep ( delay_period ) [EOL] wiringpi . pwmWrite ( [number] , STOP ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
import time [EOL] import wiringpi [EOL] [EOL] wiringpi . wiringPiSetupGpio ( ) [EOL] [EOL] wiringpi . pinMode ( [number] , wiringpi . GPIO . PWM_OUTPUT ) [EOL] [EOL] wiringpi . pwmSetMode ( wiringpi . GPIO . PWM_MODE_MS ) [EOL] [EOL] wiringpi . pwmSetClock ( [number] ) [EOL] wiringpi . pwmSetRange ( [number] ) [EOL] [EOL] delay_period = [number] [EOL] [EOL] while True : [EOL] for pulse in range ( [number] , [number] , [number] ) : [EOL] wiringpi . pwmWrite ( [number] , pulse ) [EOL] time . sleep ( delay_period ) [EOL] for pulse in range ( [number] , [number] , - [number] ) : [EOL] wiringpi . pwmWrite ( [number] , pulse ) [EOL] time . sleep ( delay_period ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0
import sys , serial , struct [EOL] [EOL] class Camera : [EOL] [EOL] def __init__ ( self ) : [EOL] self . port = [string] [EOL] self . sp = Serial ( port , baudrate = [number] , bytesize = serial . EIGHTBITS , parity = serial . PARITY_NONE , xonxoff = False , rtscts = False , stopbits = serial . STOPBITS_ONE , timeout = None , dsrdtr = True ) [EOL] [EOL] def data ( self ) : [EOL] [comment] [EOL] size = [number] [EOL] return self . sp . read ( size ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Any [EOL] import typing [EOL] import src [EOL] import os [EOL] import cv2 [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] [EOL] from skimage import io [EOL] from skimage . feature import canny [EOL] from skimage . util import img_as_ubyte [EOL] from skimage . color import rgb2gray [EOL] from skimage . transform import hough_circle , hough_circle_peaks [EOL] [EOL] class Board : [EOL] def __init__ ( self , path , filename ) : [EOL] image_path = os . path . join ( path , filename ) [EOL] color_image = io . imread ( image_path ) [EOL] gray_image = rgb2gray ( color_image ) [EOL] self . image = img_as_ubyte ( gray_image ) [EOL] [EOL] def detect_circles ( self ) : [EOL] self . circles = [ ] [EOL] c = Circle ( [number] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] edges = canny ( self . image ) [comment] [EOL] radii = np . arange ( [number] , [number] ) [EOL] hough_circles = hough_circle ( edges , radii ) [EOL] [EOL] [comment] [EOL] count = [number] [EOL] for twodim in hough_circles : [EOL] for row in twodim : [EOL] for elem in row : [EOL] if elem != [number] : [EOL] count += [number] [EOL] print ( [string] + str ( count ) ) [EOL] [EOL] self . circles . append ( c ) [EOL] [EOL] def print_circles ( self ) : [EOL] for circle in self . circles : [EOL] print ( circle ) [EOL] [EOL] class Circle : [EOL] def __init__ ( self , x , y , r ) : [EOL] self . x = x [EOL] self . y = y [EOL] self . r = r [EOL] [EOL] def update_circle ( self , x , y , r ) : [EOL] pass [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.board.board_old.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $src.board.board_old.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] [EOL] from skimage import data , color [EOL] from skimage . transform import hough_circle , hough_circle_peaks [EOL] from skimage . feature import canny [EOL] from skimage . draw import circle_perimeter [EOL] from skimage . util import img_as_ubyte [EOL] [EOL] [EOL] import pdb ; pdb . set_trace ( ) [EOL] [comment] [EOL] image = img_as_ubyte ( data . coins ( ) [ [number] : [number] , [number] : [number] ] ) [EOL] edges = canny ( image , sigma = [number] , low_threshold = [number] , high_threshold = [number] ) [EOL] [EOL] [EOL] [comment] [EOL] hough_radii = np . arange ( [number] , [number] , [number] ) [EOL] hough_res = hough_circle ( edges , hough_radii ) [EOL] [EOL] [comment] [EOL] accums , cx , cy , radii = hough_circle_peaks ( hough_res , hough_radii , total_num_peaks = [number] ) [EOL] [EOL] [comment] [EOL] fig , ax = plt . subplots ( ncols = [number] , nrows = [number] , figsize = ( [number] , [number] ) ) [EOL] image = color . gray2rgb ( image ) [EOL] for center_y , center_x , radius in zip ( cy , cx , radii ) : [EOL] circy , circx = circle_perimeter ( center_y , center_x , radius ) [EOL] image [ circy , circx ] = ( [number] , [number] , [number] ) [EOL] [EOL] ax . imshow ( image , cmap = plt . cm . gray ) [EOL] plt . show ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from board . board import Lines [EOL] [EOL] [EOL] class Ball : [EOL] [EOL] def __init__ ( self , cam_data ) : [EOL] [comment] [EOL] self . x = [number] [EOL] self . y = [number] [EOL] self . update ( cam_data ) [EOL] [EOL] def update ( self , cam_data ) : [EOL] self . x = cam_data . x [EOL] self . y = cam_data . y [EOL] [EOL] def online ( self , lines ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def finished ( self ) : [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from time import sleep [EOL] from pyb import Pin , UART [EOL] [EOL] class BLE : [EOL] BLE_NONE = [number] [EOL] BLE_SHIELD = [number] [EOL] [EOL] def command ( self , cmd ) : [EOL] if self . type == self . BLE_SHIELD : [EOL] self . uart . write ( cmd ) [EOL] self . uart . write ( [string] ) [EOL] r = self . uart . read ( [number] ) [EOL] if r [ [number] ] != [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] == [number] : raise OSError ( [string] ) [EOL] if r [ [number] ] != [number] : raise OSError ( [string] ) [EOL] for i in range ( [number] , [number] ) : [EOL] if r [ i ] < [number] or [number] < r [ i ] : raise OSError ( [string] ) [EOL] if r [ [number] ] != [number] or r [ [number] ] != [number] : raise OSError ( [string] ) [EOL] l = ( ( r [ [number] ] - [number] ) * [number] ) + ( ( r [ [number] ] - [number] ) * [number] ) + ( ( r [ [number] ] - [number] ) * [number] ) + ( ( r [ [number] ] - [number] ) * [number] ) + ( ( r [ [number] ] - [number] ) * [number] ) [EOL] if not l : return None [EOL] if l == [number] or l == [number] : raise OSError ( [string] ) [EOL] response = self . uart . read ( l - [number] ) [EOL] if self . uart . readchar ( ) != [number] : raise OSError ( [string] ) [EOL] if self . uart . readchar ( ) != [number] : raise OSError ( [string] ) [EOL] return response [EOL] [EOL] def deinit ( self ) : [EOL] if self . type == self . BLE_SHIELD : [EOL] self . uart . deinit ( ) [EOL] self . rst = None [EOL] self . uart = None [EOL] self . type = self . BLE_NONE [EOL] [EOL] def init ( self , type = BLE_SHIELD ) : [EOL] self . deinit ( ) [EOL] if type == self . BLE_SHIELD : [EOL] self . rst = Pin ( [string] , Pin . OUT_OD , Pin . PULL_NONE ) [EOL] self . uart = UART ( [number] , [number] , timeout_char = [number] ) [EOL] self . type = self . BLE_SHIELD [EOL] self . rst . low ( ) [EOL] sleep ( [number] ) [EOL] self . rst . high ( ) [EOL] sleep ( [number] ) [EOL] self . uart . write ( [string] ) [EOL] sleep ( [number] ) [EOL] self . uart . readall ( ) [comment] [EOL] [EOL] def uart ( self ) : [EOL] if self . type == self . BLE_SHIELD : return self . uart [EOL] [EOL] def type ( self ) : [EOL] if self . type == self . BLE_SHIELD : return self . BLE_SHIELD [EOL] [EOL] def __init__ ( self ) : [EOL] self . rst = None [EOL] self . uart = None [EOL] self . type = self . BLE_NONE [EOL] [EOL] if __name__ == [string] : [EOL] ble = BLE ( ) [EOL] ble . init ( ) [EOL] print ( ble . command ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sensor , image , time [EOL] [EOL] sensor . reset ( ) [comment] [EOL] sensor . set_pixformat ( sensor . RGB565 ) [comment] [EOL] sensor . set_framesize ( sensor . QVGA ) [comment] [EOL] sensor . skip_frames ( time = [number] ) [comment] [EOL] sensor . sleep ( True ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time , pyb , machine [EOL] [EOL] [comment] [EOL] rtc = pyb . RTC ( ) [EOL] [comment] [EOL] rtc . datetime ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] print ( rtc . datetime ( ) ) [EOL] [EOL] [comment] [EOL] rtc . wakeup ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] machine . sleep ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import pyb , machine , sensor [EOL] [EOL] [comment] [EOL] rtc = pyb . RTC ( ) [EOL] [EOL] [comment] [EOL] rtc . datetime ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] print ( rtc . datetime ( ) ) [EOL] [EOL] sensor . reset ( ) [EOL] [comment] [EOL] [comment] [EOL] if ( sensor . get_id ( ) == sensor . OV7725 ) : [EOL] [comment] [EOL] sensor . __write_reg ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] sensor . sleep ( True ) [EOL] [EOL] [comment] [EOL] sensor . shutdown ( True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] rtc . wakeup ( [number] ) [EOL] [EOL] [comment] [EOL] machine . deepsleep ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pyb [EOL] [EOL] [comment] [EOL] [comment] [EOL] pinA = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] pinB = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] pinC = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] pinD = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tim = pyb . Timer ( [number] , freq = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] pinABPower = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] pinCDPower = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] [EOL] while (True) : [EOL] [EOL] pyb . delay ( [number] ) [EOL] pinA . value ( [number] ) [EOL] pinB . value ( [number] ) [EOL] pinC . value ( [number] ) [EOL] pinD . value ( [number] ) [EOL] [EOL] pyb . delay ( [number] ) [EOL] pinA . value ( [number] ) [EOL] pinB . value ( [number] ) [EOL] pinC . value ( [number] ) [EOL] pinD . value ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pyb [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pinADir0 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] pinADir1 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] pinBDir0 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] pinBDir1 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pinADir0 . value ( [number] ) [EOL] pinADir1 . value ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pinBDir0 . value ( [number] ) [EOL] pinBDir1 . value ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tim = pyb . Timer ( [number] , freq = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] chA = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) ) [EOL] chB = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) ) [EOL] [EOL] while (True) : [EOL] [EOL] for i in range ( [number] ) : [EOL] pyb . delay ( [number] ) [EOL] chA . pulse_width_percent ( i ) [EOL] chB . pulse_width_percent ( [number] - i ) [EOL] [EOL] for i in range ( [number] ) : [EOL] pyb . delay ( [number] ) [EOL] chA . pulse_width_percent ( [number] - i ) [EOL] chB . pulse_width_percent ( i ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from tb6612 import Motor [EOL] [EOL] m1 = Motor ( [number] ) [comment] [EOL] m2 = Motor ( [number] ) [comment] [EOL] [EOL] while (True) : [EOL] m1 . set_speed ( [number] ) [comment] [EOL] m2 . set_speed ( [number] ) [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] m1 . set_speed ( [number] ) [comment] [EOL] m2 . set_speed ( [number] ) [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] m1 . set_speed ( - [number] ) [comment] [EOL] m2 . set_speed ( - [number] ) [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] m1 . set_speed ( [number] ) [comment] [EOL] m2 . set_speed ( [number] ) [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] m1 . set_speed ( - [number] ) [comment] [EOL] m2 . set_speed ( - [number] ) [comment] [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from tb6612 import Stepper [EOL] [EOL] stepper = Stepper ( ) [comment] [EOL] stepper . set_speed ( [number] ) [comment] [EOL] stepper . set_power ( [number] ) [comment] [EOL] while (True) : [EOL] stepper . step ( [number] ) [comment] [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from machine import I2C [EOL] from bno055 import BNO055 , AXIS_P7 [EOL] import time [EOL] i2c = I2C ( [number] ) [EOL] imu = BNO055 ( i2c ) [EOL] while True : [EOL] [comment] [EOL] [comment] [EOL] yaw , roll , pitch = imu . euler ( ) [EOL] print ( [string] , yaw , roll , pitch ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time , pyb [EOL] [EOL] led = pyb . LED ( [number] ) [comment] [EOL] usb = pyb . USB_VCP ( ) [comment] [EOL] [comment] [EOL] [EOL] while ( not usb . isconnected ( ) ) : [EOL] led . on ( ) [EOL] time . sleep ( [number] ) [EOL] led . off ( ) [EOL] time . sleep ( [number] ) [EOL] led . on ( ) [EOL] time . sleep ( [number] ) [EOL] led . off ( ) [EOL] time . sleep ( [number] ) [EOL] [EOL] led = pyb . LED ( [number] ) [comment] [EOL] [EOL] while ( usb . isconnected ( ) ) : [EOL] led . on ( ) [EOL] time . sleep ( [number] ) [EOL] led . off ( ) [EOL] time . sleep ( [number] ) [EOL] led . on ( ) [EOL] time . sleep ( [number] ) [EOL] led . off ( ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] import pyb , sensor , image [EOL] [EOL] sensor . reset ( ) [EOL] sensor . set_framesize ( sensor . QVGA ) [EOL] [EOL] grayscale_thres = ( [number] , [number] ) [EOL] rgb565_thres = ( [number] , [number] , - [number] , [number] , - [number] , [number] ) [EOL] [EOL] while (True) : [EOL] [EOL] sensor . set_pixformat ( sensor . GRAYSCALE ) [EOL] for i in range ( [number] ) : [EOL] img = sensor . snapshot ( ) [EOL] img . binary ( [ grayscale_thres ] ) [EOL] img . erode ( [number] ) [EOL] for i in range ( [number] ) : [EOL] img = sensor . snapshot ( ) [EOL] img . binary ( [ grayscale_thres ] ) [EOL] img . dilate ( [number] ) [EOL] [EOL] sensor . set_pixformat ( sensor . RGB565 ) [EOL] for i in range ( [number] ) : [EOL] img = sensor . snapshot ( ) [EOL] img . binary ( [ rgb565_thres ] ) [EOL] img . erode ( [number] ) [EOL] for i in range ( [number] ) : [EOL] img = sensor . snapshot ( ) [EOL] img . binary ( [ rgb565_thres ] ) [EOL] img . dilate ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import usocket as socket [EOL] import ustruct as struct [EOL] from ubinascii import hexlify [EOL] [EOL] class MQTTException ( Exception ) : [EOL] pass [EOL] [EOL] class MQTTClient : [EOL] [EOL] def __init__ ( self , client_id , server , port = [number] , user = None , password = None , keepalive = [number] , ssl = False , ssl_params = { } ) : [EOL] if port == [number] : [EOL] port = [number] if ssl else [number] [EOL] self . client_id = client_id [EOL] self . sock = None [EOL] self . server = server [EOL] self . port = port [EOL] self . ssl = ssl [EOL] self . ssl_params = ssl_params [EOL] self . pid = [number] [EOL] self . cb = None [EOL] self . user = user [EOL] self . pswd = password [EOL] self . keepalive = keepalive [EOL] self . lw_topic = None [EOL] self . lw_msg = None [EOL] self . lw_qos = [number] [EOL] self . lw_retain = False [EOL] [EOL] def _send_str ( self , s ) : [EOL] self . sock . send ( struct . pack ( [string] , len ( s ) ) ) [EOL] self . sock . send ( s ) [EOL] [EOL] def _recv_len ( self ) : [EOL] n = [number] [EOL] sh = [number] [EOL] while [number] : [EOL] b = self . sock . recv ( [number] ) [ [number] ] [EOL] n |= ( b & [number] ) << sh [EOL] if not b & [number] : [EOL] return n [EOL] sh += [number] [EOL] [EOL] def set_callback ( self , f ) : [EOL] self . cb = f [EOL] [EOL] def set_last_will ( self , topic , msg , retain = False , qos = [number] ) : [EOL] assert [number] <= qos <= [number] [EOL] assert topic [EOL] self . lw_topic = topic [EOL] self . lw_msg = msg [EOL] self . lw_qos = qos [EOL] self . lw_retain = retain [EOL] [EOL] def connect ( self , clean_session = True ) : [EOL] self . sock = socket . socket ( ) [EOL] addr = None [EOL] addr = socket . getaddrinfo ( self . server , self . port ) [ [number] ] [ - [number] ] [EOL] self . sock . connect ( addr ) [EOL] if self . ssl : [EOL] import ussl [EOL] self . sock = ussl . wrap_socket ( self . sock , ** self . ssl_params ) [EOL] premsg = bytearray ( [string] ) [EOL] msg = bytearray ( [string] ) [EOL] [EOL] sz = [number] + [number] + len ( self . client_id ) [EOL] msg [ [number] ] = clean_session << [number] [EOL] if self . user is not None : [EOL] sz += [number] + len ( self . user ) + [number] + len ( self . pswd ) [EOL] msg [ [number] ] |= [number] [EOL] if self . keepalive : [EOL] assert self . keepalive < [number] [EOL] msg [ [number] ] |= self . keepalive >> [number] [EOL] msg [ [number] ] |= self . keepalive & [number] [EOL] if self . lw_topic : [EOL] sz += [number] + len ( self . lw_topic ) + [number] + len ( self . lw_msg ) [EOL] msg [ [number] ] |= [number] | ( self . lw_qos & [number] ) << [number] | ( self . lw_qos & [number] ) << [number] [EOL] msg [ [number] ] |= self . lw_retain << [number] [EOL] [EOL] i = [number] [EOL] while sz > [number] : [EOL] premsg [ i ] = ( sz & [number] ) | [number] [EOL] sz >>= [number] [EOL] i += [number] [EOL] premsg [ i ] = sz [EOL] [EOL] self . sock . send ( premsg [ [number] : i + [number] ] ) [EOL] self . sock . send ( msg ) [EOL] [comment] [EOL] self . _send_str ( self . client_id ) [EOL] if self . lw_topic : [EOL] self . _send_str ( self . lw_topic ) [EOL] self . _send_str ( self . lw_msg ) [EOL] if self . user is not None : [EOL] self . _send_str ( self . user ) [EOL] self . _send_str ( self . pswd ) [EOL] resp = self . sock . recv ( [number] ) [EOL] assert resp [ [number] ] == [number] and resp [ [number] ] == [number] [EOL] if resp [ [number] ] != [number] : [EOL] raise MQTTException ( resp [ [number] ] ) [EOL] return resp [ [number] ] & [number] [EOL] [EOL] def disconnect ( self ) : [EOL] self . sock . send ( [string] ) [EOL] self . sock . close ( ) [EOL] [EOL] def ping ( self ) : [EOL] self . sock . send ( [string] ) [EOL] [EOL] def publish ( self , topic , msg , retain = False , qos = [number] ) : [EOL] pkt = bytearray ( [string] ) [EOL] pkt [ [number] ] |= qos << [number] | retain [EOL] sz = [number] + len ( topic ) + len ( msg ) [EOL] if qos > [number] : [EOL] sz += [number] [EOL] assert sz < [number] [EOL] i = [number] [EOL] while sz > [number] : [EOL] pkt [ i ] = ( sz & [number] ) | [number] [EOL] sz >>= [number] [EOL] i += [number] [EOL] pkt [ i ] = sz [EOL] [comment] [EOL] self . sock . send ( pkt [ [number] : i + [number] ] ) [EOL] self . _send_str ( topic ) [EOL] if qos > [number] : [EOL] self . pid += [number] [EOL] pid = self . pid [EOL] struct . pack_into ( [string] , pkt , [number] , pid ) [EOL] self . sock . send ( pkt [ [number] : [number] ] ) [EOL] self . sock . send ( msg ) [EOL] if qos == [number] : [EOL] while [number] : [EOL] op = self . wait_msg ( ) [EOL] if op == [number] : [EOL] sz = self . sock . recv ( [number] ) [EOL] assert sz == [string] [EOL] rcv_pid = self . sock . recv ( [number] ) [EOL] rcv_pid = rcv_pid [ [number] ] << [number] | rcv_pid [ [number] ] [EOL] if pid == rcv_pid : [EOL] return [EOL] elif qos == [number] : [EOL] assert [number] [EOL] [EOL] def subscribe ( self , topic , qos = [number] ) : [EOL] assert self . cb is not None , [string] [EOL] pkt = bytearray ( [string] ) [EOL] self . pid += [number] [EOL] struct . pack_into ( [string] , pkt , [number] , [number] + [number] + len ( topic ) + [number] , self . pid ) [EOL] [comment] [EOL] self . sock . send ( pkt ) [EOL] self . _send_str ( topic ) [EOL] self . sock . send ( qos . to_bytes ( [number] , [string] ) ) [EOL] while [number] : [EOL] op = self . wait_msg ( ) [EOL] if op == [number] : [EOL] resp = self . sock . recv ( [number] ) [EOL] [comment] [EOL] assert resp [ [number] ] == pkt [ [number] ] and resp [ [number] ] == pkt [ [number] ] [EOL] if resp [ [number] ] == [number] : [EOL] raise MQTTException ( resp [ [number] ] ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def wait_msg ( self ) : [EOL] res = self . sock . recv ( [number] ) [EOL] self . sock . setblocking ( True ) [EOL] if res is None : [EOL] return None [EOL] if res == [string] : [EOL] raise OSError ( - [number] ) [EOL] if res == [string] : [comment] [EOL] sz = self . sock . recv ( [number] ) [ [number] ] [EOL] assert sz == [number] [EOL] return None [EOL] op = res [ [number] ] [EOL] if op & [number] != [number] : [EOL] return op [EOL] sz = self . _recv_len ( ) [EOL] topic_len = self . sock . recv ( [number] ) [EOL] topic_len = ( topic_len [ [number] ] << [number] ) | topic_len [ [number] ] [EOL] topic = self . sock . recv ( topic_len ) [EOL] sz -= topic_len + [number] [EOL] if op & [number] : [EOL] pid = self . sock . recv ( [number] ) [EOL] pid = pid [ [number] ] << [number] | pid [ [number] ] [EOL] sz -= [number] [EOL] msg = self . sock . recv ( sz ) [EOL] self . cb ( topic , msg ) [EOL] if op & [number] == [number] : [EOL] pkt = bytearray ( [string] ) [EOL] struct . pack_into ( [string] , pkt , [number] , pid ) [EOL] self . sock . send ( pkt ) [EOL] elif op & [number] == [number] : [EOL] assert [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def check_msg ( self ) : [EOL] self . sock . setblocking ( False ) [EOL] return self . wait_msg ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytearray$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bytearray$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bytearray$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bytearray$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bytearray$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import struct [EOL] import pyb [EOL] [EOL] CONFIG_MODE = [number] [EOL] ACCONLY_MODE = [number] [EOL] MAGONLY_MODE = [number] [EOL] GYRONLY_MODE = [number] [EOL] ACCMAG_MODE = [number] [EOL] ACCGYRO_MODE = [number] [EOL] MAGGYRO_MODE = [number] [EOL] AMG_MODE = [number] [EOL] IMUPLUS_MODE = [number] [EOL] COMPASS_MODE = [number] [EOL] M4G_MODE = [number] [EOL] NDOF_FMC_OFF_MODE = [number] [EOL] NDOF_MODE = [number] [EOL] [EOL] AXIS_P0 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P1 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P2 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P3 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P4 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P5 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P6 = bytes ( [ [number] , [number] ] ) [EOL] AXIS_P7 = bytes ( [ [number] , [number] ] ) [EOL] [EOL] _MODE_REGISTER = [number] [EOL] _POWER_REGISTER = [number] [EOL] _AXIS_MAP_CONFIG = [number] [EOL] [EOL] class BNO055 : [EOL] def __init__ ( self , i2c , address = [number] , mode = NDOF_MODE , axis = AXIS_P4 ) : [EOL] self . i2c = i2c [EOL] self . address = address [EOL] if self . read_id ( ) != bytes ( [ [number] , [number] , [number] , [number] ] ) : [EOL] raise RuntimeError ( [string] ) [EOL] self . operation_mode ( CONFIG_MODE ) [EOL] self . system_trigger ( [number] )[comment] [EOL] pyb . delay ( [number] ) [EOL] self . power_mode ( [number] )[comment] [EOL] self . axis ( axis ) [EOL] self . page ( [number] ) [EOL] pyb . delay ( [number] ) [EOL] self . operation_mode ( mode ) [EOL] self . system_trigger ( [number] ) [comment] [EOL] pyb . delay ( [number] ) [EOL] [EOL] def read_registers ( self , register , size = [number] ) : [EOL] return ( self . i2c . readfrom_mem ( self . address , register , size ) ) [EOL] def write_registers ( self , register , data ) : [EOL] self . i2c . writeto_mem ( self . address , register , data ) [EOL] def operation_mode ( self , mode = None ) : [EOL] if mode : [EOL] self . write_registers ( _MODE_REGISTER , bytes ( [ mode ] ) ) [EOL] else : [EOL] return ( self . read_registers ( _MODE_REGISTER , [number] ) [ [number] ] ) [EOL] def system_trigger ( self , data ) : [EOL] self . write_registers ( [number] , bytes ( [ data ] ) ) [EOL] def power_mode ( self , mode = None ) : [EOL] if mode : [EOL] self . write_registers ( _POWER_REGISTER , bytes ( [ mode ] ) ) [EOL] else : [EOL] return ( self . read_registers ( _POWER_REGISTER , [number] ) ) [EOL] def page ( self , num = None ) : [EOL] if num : [EOL] self . write_registers ( [number] , bytes ( [ num ] ) ) [EOL] else : [EOL] self . read_registers ( [number] ) [EOL] def temperature ( self ) : [EOL] return ( self . read_registers ( [number] , [number] ) [ [number] ] ) [EOL] def read_id ( self ) : [EOL] return ( self . read_registers ( [number] , [number] ) ) [EOL] def axis ( self , placement = None ) : [EOL] if placement : [EOL] self . write_registers ( _AXIS_MAP_CONFIG , placement ) [EOL] else : [EOL] return ( self . read_registers ( _AXIS_MAP_CONFIG , [number] ) ) [EOL] def quaternion ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / ( [number] << [number] ) for d in data ] [comment] [EOL] def euler ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / [number] for d in data ] [comment] [EOL] def accelerometer ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / [number] for d in data ] [comment] [EOL] def magnetometer ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / [number] for d in data ] [comment] [EOL] def gyroscope ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / [number] for d in data ] [comment] [EOL] def linear_acceleration ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / [number] for d in data ] [comment] [EOL] def gravity ( self ) : [EOL] data = struct . unpack ( [string] , self . read_registers ( [number] , [number] ) ) [EOL] return [ d / [number] for d in data ] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] import math [EOL] import umatrix [EOL] [EOL] [EOL] def zeros ( m , n , dtype = umatrix . ddtype ) : [EOL] return umatrix . matrix ( [ [ [number] for i in range ( n ) ] for j in range ( m ) ] , dtype = dtype ) [EOL] [EOL] [EOL] def ones ( m , n , dtype = umatrix . ddtype ) : [EOL] return zeros ( m , n , dtype ) + [number] [EOL] [EOL] [EOL] def eye ( m , dtype = umatrix . ddtype ) : [EOL] Z = zeros ( m , m , dtype = dtype ) [EOL] for i in range ( m ) : [EOL] Z [ i , i ] = [number] [EOL] return Z [EOL] [EOL] def det_inv ( x ) : [EOL] [docstring] [EOL] if not x . is_square : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] x = x . copy ( ) [EOL] inverse = eye ( len ( x ) , dtype = float ) [EOL] sign = [number] [EOL] factors = [ ] [EOL] p = [number] [EOL] while p < len ( x ) : [EOL] d = x [ p , p ] [EOL] if abs ( d ) < umatrix . flt_eps : [EOL] [comment] [EOL] [comment] [EOL] np = [number] [EOL] while ( p + np ) < len ( x ) and abs ( x [ p + np , p ] ) < umatrix . flt_eps : [EOL] np += [number] [EOL] if ( p + np ) == len ( x ) : [EOL] [comment] [EOL] return [ [number] , [ ] ] [EOL] [comment] [EOL] z = x [ p + np ] [EOL] x [ p + np , : ] = x [ p ] [EOL] x [ p , : ] = z [EOL] [comment] [EOL] z = inverse [ p + np ] [EOL] inverse [ p + np , : ] = inverse [ p ] [EOL] inverse [ p , : ] = z [EOL] [comment] [EOL] sign = - sign [EOL] continue [EOL] factors . append ( d ) [EOL] [comment] [EOL] for n in range ( p , len ( x ) ) : [EOL] x [ p , n ] = x [ p , n ] / d [EOL] [comment] [EOL] for n in range ( len ( x ) ) : [EOL] inverse [ p , n ] = inverse [ p , n ] / d [EOL] [comment] [EOL] for i in range ( p + [number] , len ( x ) ) : [EOL] [comment] [EOL] t = x [ i , p ] [EOL] for j in range ( p , len ( x ) ) : [EOL] x [ i , j ] = x [ i , j ] - ( t * x [ p , j ] ) [EOL] for j in range ( len ( x ) ) : [EOL] inverse [ i , j ] = inverse [ i , j ] - ( t * inverse [ p , j ] ) [EOL] p = p + [number] [EOL] s = sign [EOL] for i in factors : [EOL] s = s * i [comment] [EOL] [comment] [EOL] for i in range ( len ( x ) - [number] ) : [EOL] [comment] [EOL] [comment] [EOL] for p in range ( i + [number] , len ( x ) ) : [EOL] [comment] [EOL] t = x [ i , p ] [EOL] for j in range ( i + [number] , len ( x ) ) : [EOL] x [ i , j ] = x [ i , j ] - ( t * x [ p , j ] ) [EOL] for j in range ( len ( x ) ) : [EOL] inverse [ i , j ] = inverse [ i , j ] - ( t * inverse [ p , j ] ) [EOL] return ( s , inverse ) [EOL] [EOL] [EOL] def pinv ( X ) : [EOL] [docstring] [EOL] Xt = X . transpose ( ) [EOL] d , Z = det_inv ( dot ( Xt , X ) ) [EOL] return dot ( Z , Xt ) [EOL] [EOL] [EOL] def dot ( X , Y ) : [EOL] [docstring] [EOL] if X . size ( [number] ) == Y . size ( [number] ) : [EOL] Z = [ ] [EOL] for k in range ( X . size ( [number] ) ) : [EOL] for j in range ( Y . size ( [number] ) ) : [EOL] Z . append ( sum ( [ X [ k , i ] * Y [ i , j ] for i in range ( Y . size ( [number] ) ) ] ) ) [EOL] return umatrix . matrix ( Z , cstride = [number] , rstride = Y . size ( [number] ) ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def cross ( X , Y , axis = [number] ) : [EOL] [docstring] [EOL] if axis == [number] : [EOL] X = X . T [EOL] Y = Y . T [EOL] if ( X . n in ( [number] , [number] ) ) and ( Y . n in ( [number] , [number] ) ) : [EOL] if X . m == Y . m : [EOL] Z = [ ] [EOL] for k in range ( min ( X . m , Y . m ) ) : [EOL] z = X [ k , [number] ] * Y [ k , [number] ] - X [ k , [number] ] * Y [ k , [number] ] [EOL] if ( X . n == [number] ) and ( Y . n == [number] ) : [EOL] Z . append ( [ X [ k , [number] ] * Y [ k , [number] ] - X [ k , [number] ] * Y [ k , [number] ] , X [ k , [number] ] * Y [ k , [number] ] - X [ k , [number] ] * Y [ k , [number] ] , z ] ) [EOL] else : [EOL] Z . append ( [ z ] ) [EOL] if axis == [number] : [EOL] return umatrix . matrix ( Z ) . T [EOL] else : [EOL] return umatrix . matrix ( Z ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] def eps ( x = [number] ) : [EOL] [comment] [EOL] if x : [EOL] return [number] ** ( math . floor ( math . log ( abs ( x ) ) / math . log ( [number] ) ) ) * umatrix . flt_eps [EOL] else : [EOL] return umatrix . flt_eps [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pyb [EOL] [EOL] VL51L1X_DEFAULT_CONFIGURATION = bytes ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] class VL53L1X : [EOL] def __init__ ( self , i2c , address = [number] ) : [EOL] self . i2c = i2c [EOL] self . address = address [EOL] self . reset ( ) [EOL] pyb . delay ( [number] ) [EOL] if self . read_model_id ( ) != [number] : [EOL] raise RuntimeError ( [string] ) [EOL] [comment] [EOL] self . i2c . writeto_mem ( self . address , [number] , VL51L1X_DEFAULT_CONFIGURATION , addrsize = [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . writeReg16Bit ( [number] , self . readReg16Bit ( [number] ) * [number] ) [EOL] pyb . delay ( [number] ) [EOL] [EOL] def writeReg ( self , reg , value ) : [EOL] return self . i2c . writeto_mem ( self . address , reg , bytes ( [ value ] ) , addrsize = [number] ) [EOL] def writeReg16Bit ( self , reg , value ) : [EOL] return self . i2c . writeto_mem ( self . address , reg , bytes ( [ ( value >> [number] ) & [number] , value & [number] ] ) , addrsize = [number] ) [EOL] def readReg ( self , reg ) : [EOL] return self . i2c . readfrom_mem ( self . address , reg , [number] , addrsize = [number] ) [ [number] ] [EOL] def readReg16Bit ( self , reg ) : [EOL] data = self . i2c . readfrom_mem ( self . address , reg , [number] , addrsize = [number] ) [EOL] return ( data [ [number] ] << [number] ) + data [ [number] ] [EOL] def read_model_id ( self ) : [EOL] return self . readReg16Bit ( [number] ) [EOL] def reset ( self ) : [EOL] self . writeReg ( [number] , [number] ) [EOL] pyb . delay ( [number] ) [EOL] self . writeReg ( [number] , [number] ) [EOL] def read ( self ) : [EOL] data = self . i2c . readfrom_mem ( self . address , [number] , [number] , addrsize = [number] ) [comment] [EOL] range_status = data [ [number] ] [EOL] [comment] [EOL] stream_count = data [ [number] ] [EOL] dss_actual_effective_spads_sd0 = ( data [ [number] ] << [number] ) + data [ [number] ] [EOL] [comment] [EOL] ambient_count_rate_mcps_sd0 = ( data [ [number] ] << [number] ) + data [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] final_crosstalk_corrected_range_mm_sd0 = ( data [ [number] ] << [number] ) + data [ [number] ] [EOL] peak_signal_count_rate_crosstalk_corrected_mcps_sd0 = ( data [ [number] ] << [number] ) + data [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return final_crosstalk_corrected_range_mm_sd0 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import pyb [EOL] [EOL] class Motor ( ) : [EOL] def __init__ ( self , channel ) : [EOL] if channel == [number] : [EOL] self . pin1 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] self . pin2 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] tim = pyb . Timer ( [number] , freq = [number] ) [EOL] self . power = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] elif channel == [number] : [EOL] self . pin1 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] self . pin2 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] tim = pyb . Timer ( [number] , freq = [number] ) [EOL] self . power = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] def set_speed ( self , pwm ) : [EOL] if pwm < [number] : [EOL] self . pin1 . low ( ) [EOL] self . pin2 . high ( ) [EOL] else : [EOL] self . pin1 . high ( ) [EOL] self . pin2 . low ( ) [EOL] self . power . pulse_width_percent ( abs ( pwm ) ) [EOL] [EOL] class Stepper ( ) : [EOL] def __init__ ( self , stepnumber = [number] , rpms = [number] , power = [number] ) : [EOL] self . stepnumber = stepnumber [EOL] self . pin1 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] self . pin2 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] self . pin3 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] self . pin4 = pyb . Pin ( [string] , pyb . Pin . OUT_PP , pyb . Pin . PULL_NONE ) [EOL] tim = pyb . Timer ( [number] , freq = [number] ) [EOL] self . power1 = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] self . power2 = tim . channel ( [number] , pyb . Timer . PWM , pin = pyb . Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] self . set_speed ( rpms ) [EOL] self . set_power ( power ) [EOL] self . phase = self . phase_list ( ) [EOL] [EOL] def phase_list ( self ) : [EOL] phase_list = [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] [EOL] while True : [EOL] for p in phase_list : [EOL] yield p [EOL] [EOL] def set_speed ( self , rpms ) : [EOL] self . delay_time = int ( [number] / ( rpms * self . stepnumber ) / [number] ) [EOL] [EOL] def set_power ( self , power ) : [EOL] self . power1 . pulse_width_percent ( power ) [EOL] self . power2 . pulse_width_percent ( power ) [EOL] [EOL] def step ( self , num ) : [EOL] for i in range ( num ) : [EOL] phase = self . phase . __next__ ( ) [EOL] self . pin1 . value ( phase [ [number] ] ) [EOL] self . pin2 . value ( phase [ [number] ] ) [EOL] self . pin3 . value ( phase [ [number] ] ) [EOL] self . pin4 . value ( phase [ [number] ] ) [EOL] pyb . udelay ( self . delay_time ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pyb [EOL] from pyb import I2C [EOL] [EOL] [EOL] lidarReady = bytearray ( [ [number] ] ) [comment] [EOL] lidarReadyCheck = bytes ( [ [number] ] ) [comment] [EOL] [EOL] startBuf = bytearray ( [ [number] , [number] ] ) [comment] [EOL] readyBuf = bytearray ( [ [number] ] ) [comment] [EOL] distBuf = bytearray ( [ [number] ] ) [comment] [EOL] distance = - [number] [comment] [EOL] [EOL] [comment] [EOL] Lidar = I2C ( [number] , I2C . MASTER ) [comment] [EOL] [EOL] [EOL] while (True) : [EOL] distance = - [number] [comment] [EOL] [EOL] try : [comment] [EOL] [comment] [EOL] Lidar . send ( startBuf , [number] ) [comment] [EOL] [EOL] [comment] [EOL] while ( lidarReady [ [number] ] & readyBuf [ [number] ] ) : [EOL] Lidar . send ( readyBuf , [number] ) [EOL] lidarReady = Lidar . recv ( [number] , [number] ) [EOL] pyb . delay ( [number] ) [comment] [EOL] lidarReady = bytearray ( [ [number] ] ) [comment] [EOL] [EOL] [comment] [EOL] Lidar . send ( distBuf , [number] ) [EOL] dist = Lidar . recv ( [number] , [number] ) [EOL] distance = dist [ [number] ] [EOL] distance <<= [number] [comment] [EOL] distance |= dist [ [number] ] [EOL] pyb . delay ( [number] ) [comment] [EOL] [EOL] except OSError : [comment] [EOL] Lidar . init ( I2C . MASTER ) [EOL] print ( [string] ) [EOL] [EOL] if distance > - [number] : [EOL] print ( [string] , distance , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytearray$ 0 0 0 0 $builtins.bytearray$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytearray$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time , network [EOL] [EOL] wlan = network . WINC ( ) [EOL] print ( [string] , wlan . fw_version ( ) ) [EOL] [EOL] while (True) : [EOL] scan_result = wlan . scan ( ) [EOL] for ap in scan_result : [EOL] print ( [string] % (ap) ) [EOL] print ( ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import network , usocket , ustruct , utime [EOL] [EOL] SSID = [string] [comment] [EOL] KEY = [string] [comment] [EOL] [EOL] TIMESTAMP = [number] + [number] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] wlan = network . WINC ( ) [EOL] wlan . connect ( SSID , key = KEY , security = wlan . WPA_PSK ) [EOL] [EOL] [comment] [EOL] print ( wlan . ifconfig ( ) ) [EOL] [EOL] [comment] [EOL] client = usocket . socket ( usocket . AF_INET , usocket . SOCK_DGRAM ) [EOL] [EOL] [comment] [EOL] addr = usocket . getaddrinfo ( [string] , [number] ) [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] client . sendto ( [string] + [number] * [string] , addr ) [EOL] data , address = client . recvfrom ( [number] ) [EOL] [EOL] [comment] [EOL] t = ustruct . unpack ( [string] , data ) [ [number] ] - TIMESTAMP [EOL] print ( [string] % ( utime . localtime ( t ) [ [number] : [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import network , usocket [EOL] [EOL] [comment] [EOL] SSID = [string] [comment] [EOL] KEY = [string] [comment] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] wlan = network . WINC ( ) [EOL] wlan . connect ( SSID , key = KEY , security = wlan . WPA_PSK ) [EOL] [EOL] [comment] [EOL] print ( wlan . ifconfig ( ) ) [EOL] [EOL] [comment] [EOL] addr = usocket . getaddrinfo ( [string] , [number] ) [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] client = usocket . socket ( usocket . AF_INET , usocket . SOCK_STREAM ) [EOL] client . connect ( addr ) [EOL] [EOL] [comment] [EOL] client . settimeout ( [number] ) [EOL] [EOL] [comment] [EOL] client . send ( [string] ) [EOL] print ( client . recv ( [number] ) ) [EOL] [EOL] [comment] [EOL] client . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import sensor , image , time , network , usocket , sys [EOL] [EOL] SSID = [string] [comment] [EOL] KEY = [string] [comment] [EOL] HOST = [string] [comment] [EOL] PORT = [number] [comment] [EOL] [EOL] [comment] [EOL] sensor . reset ( ) [EOL] [EOL] [comment] [EOL] sensor . set_contrast ( [number] ) [EOL] sensor . set_brightness ( [number] ) [EOL] sensor . set_saturation ( [number] ) [EOL] sensor . set_gainceiling ( [number] ) [EOL] sensor . set_framesize ( sensor . QQVGA ) [EOL] sensor . set_pixformat ( sensor . GRAYSCALE ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] wlan = network . WINC ( ) [EOL] wlan . connect ( SSID , key = KEY , security = wlan . WPA_PSK ) [EOL] [EOL] [comment] [EOL] print ( wlan . ifconfig ( ) ) [EOL] [EOL] [comment] [EOL] s = usocket . socket ( usocket . AF_INET , usocket . SOCK_STREAM ) [EOL] [EOL] [comment] [EOL] s . bind ( [ HOST , PORT ] ) [EOL] s . listen ( [number] ) [EOL] [EOL] [comment] [EOL] s . settimeout ( [number] ) [EOL] [EOL] def start_streaming ( s ) : [EOL] print ( [string] ) [EOL] client , addr = s . accept ( ) [EOL] [comment] [EOL] client . settimeout ( [number] ) [EOL] print ( [string] + addr [ [number] ] + [string] + str ( addr [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] data = client . recv ( [number] ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] client . send ( [string] [string] [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] clock = time . clock ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] while (True) : [EOL] clock . tick ( ) [comment] [EOL] frame = sensor . snapshot ( ) [EOL] cframe = frame . compressed ( quality = [number] ) [EOL] header = [string] [string] [string] + str ( cframe . size ( ) ) + [string] [EOL] client . send ( header ) [EOL] client . send ( cframe ) [EOL] print ( clock . fps ( ) ) [EOL] [EOL] while (True) : [EOL] try : [EOL] start_streaming ( s ) [EOL] except OSError as e : [EOL] print ( [string] , e ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import network [EOL] [EOL] SSID = [string] [comment] [EOL] KEY = [string] [comment] [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] wlan = network . WINC ( ) [EOL] wlan . connect ( SSID , key = KEY , security = wlan . WPA_PSK ) [EOL] [EOL] [comment] [EOL] print ( wlan . ifconfig ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import sensor , image , network , usocket , fir [EOL] [EOL] SSID = [string] [comment] [EOL] KEY = [string] [comment] [EOL] HOST = [string] [comment] [EOL] PORT = [number] [comment] [EOL] [EOL] [comment] [EOL] sensor . reset ( ) [EOL] [EOL] [comment] [EOL] sensor . set_contrast ( [number] ) [EOL] sensor . set_brightness ( [number] ) [EOL] sensor . set_saturation ( [number] ) [EOL] sensor . set_gainceiling ( [number] ) [EOL] sensor . set_framesize ( sensor . QQVGA ) [EOL] sensor . set_pixformat ( sensor . RGB565 ) [EOL] [EOL] [comment] [EOL] fir . init ( ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] wlan = network . WINC ( ) [EOL] wlan . connect ( SSID , key = KEY , security = wlan . WPA_PSK ) [EOL] [EOL] [comment] [EOL] print ( wlan . ifconfig ( ) ) [EOL] [EOL] [comment] [EOL] s = usocket . socket ( usocket . AF_INET , usocket . SOCK_STREAM ) [EOL] [EOL] [comment] [EOL] s . bind ( ( HOST , PORT ) ) [EOL] s . listen ( [number] ) [EOL] [EOL] [comment] [EOL] s . settimeout ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] client , addr = s . accept ( ) [EOL] print ( [string] + addr [ [number] ] + [string] + str ( addr [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] data = client . recv ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] client . send ( [string] [string] [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] while (True) : [EOL] image = sensor . snapshot ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ta , ir , to_min , to_max = fir . read_ir ( ) [EOL] [EOL] [comment] [EOL] fir . draw_ir ( image , ir ) [EOL] [EOL] [comment] [EOL] image . draw_string ( [number] , [number] , [string] % ta , color = ( [number] , [number] , [number] ) ) [EOL] image . draw_string ( [number] , [number] , [string] % to_min , color = ( [number] , [number] , [number] ) ) [EOL] image . draw_string ( [number] , [number] , [string] % to_max , color = ( [number] , [number] , [number] ) ) [EOL] [EOL] cimage = image . compressed ( quality = [number] ) [EOL] client . send ( [string] [string] [string] + str ( cimage . size ( ) ) + [string] ) [EOL] client . send ( cimage ) [EOL] [EOL] client . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import network [EOL] [EOL] [comment] [EOL] wlan = network . WINC ( mode = network . WINC . MODE_FIRMWARE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] wlan . fw_update ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import Servo [EOL] [EOL] s1 = Servo ( [number] ) [comment] [EOL] s2 = Servo ( [number] ) [comment] [EOL] [EOL] while (True) : [EOL] for i in range ( [number] ) : [EOL] s1 . pulse_width ( [number] + i ) [EOL] s2 . pulse_width ( [number] - i ) [EOL] time . sleep ( [number] ) [EOL] for i in range ( [number] ) : [EOL] s1 . pulse_width ( [number] - i ) [EOL] s2 . pulse_width ( [number] + i ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pyb , ustruct [EOL] [EOL] text = [string] [EOL] data = ustruct . pack ( [string] % len ( text ) , text ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] bus = pyb . I2C ( [number] , pyb . I2C . SLAVE , addr = [number] ) [EOL] bus . deinit ( ) [comment] [EOL] bus = pyb . I2C ( [number] , pyb . I2C . SLAVE , addr = [number] ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] while (True) : [EOL] try : [EOL] bus . send ( ustruct . pack ( [string] , len ( data ) ) , timeout = [number] ) [comment] [EOL] try : [EOL] bus . send ( data , timeout = [number] ) [comment] [EOL] print ( [string] ) [comment] [EOL] except OSError as err : [EOL] pass [comment] [EOL] [comment] [EOL] [comment] [EOL] except OSError as err : [EOL] pass [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import UART [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] uart = UART ( [number] , [number] , timeout_char = [number] ) [EOL] [EOL] while (True) : [EOL] uart . write ( [string] ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import Pin , Timer [EOL] [EOL] def tick ( timer ) : [comment] [EOL] print ( [string] ) [EOL] [EOL] tim = Timer ( [number] , freq = [number] ) [comment] [EOL] tim . callback ( tick ) [comment] [EOL] [EOL] while (True) : [EOL] time . sleep ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import DAC [EOL] [EOL] dac = DAC ( [string] ) [comment] [EOL] [EOL] while (True) : [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] dac . write ( i ) [EOL] time . sleep ( [number] ) [EOL] for i in range ( [number] ) : [EOL] dac . write ( [number] - i ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import ADC [EOL] [EOL] adc = ADC ( [string] ) [comment] [EOL] [EOL] while (True) : [EOL] [comment] [EOL] print ( [string] % ( ( adc . read ( ) * [number] ) / [number] ) ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import LED [EOL] [EOL] red_led = LED ( [number] ) [EOL] green_led = LED ( [number] ) [EOL] blue_led = LED ( [number] ) [EOL] ir_led = LED ( [number] ) [EOL] [EOL] def led_control ( x ) : [EOL] if ( x & [number] ) == [number] : red_led . off ( ) [EOL] elif ( x & [number] ) == [number] : red_led . on ( ) [EOL] if ( x & [number] ) == [number] : green_led . off ( ) [EOL] elif ( x & [number] ) == [number] : green_led . on ( ) [EOL] if ( x & [number] ) == [number] : blue_led . off ( ) [EOL] elif ( x & [number] ) == [number] : blue_led . on ( ) [EOL] if ( x & [number] ) == [number] : ir_led . off ( ) [EOL] elif ( x & [number] ) == [number] : ir_led . on ( ) [EOL] [EOL] while (True) : [EOL] for i in range ( [number] ) : [EOL] led_control ( i ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import sensor , image , time , ustruct [EOL] from pyb import USB_VCP [EOL] [EOL] usb = USB_VCP ( ) [EOL] sensor . reset ( ) [comment] [EOL] sensor . set_pixformat ( sensor . RGB565 ) [comment] [EOL] sensor . set_framesize ( sensor . QVGA ) [comment] [EOL] sensor . skip_frames ( time = [number] ) [comment] [EOL] [EOL] while (True) : [EOL] cmd = usb . recv ( [number] , timeout = [number] ) [EOL] if ( cmd == [string] ) : [EOL] img = sensor . snapshot ( ) . compress ( ) [EOL] usb . send ( ustruct . pack ( [string] , img . size ( ) ) ) [EOL] usb . send ( img ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from pyb import I2C [EOL] [EOL] i2c = I2C ( [number] , I2C . MASTER ) [comment] [EOL] mem = i2c . mem_read ( [number] , [number] , [number] ) [comment] [EOL] [EOL] print ( [string] ) [EOL] for i in range ( [number] ) : [EOL] print ( [string] , end = [string] ) [EOL] for j in range ( [number] ) : [EOL] print ( [string] % mem [ ( i * [number] ) + j ] , end = [string] ) [EOL] if j != [number] : print ( [string] , end = [string] ) [EOL] print ( [string] if i != [number] else [string] ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import Pin , Timer [EOL] [EOL] tim = Timer ( [number] , freq = [number] ) [comment] [EOL] [comment] [EOL] ch1 = tim . channel ( [number] , Timer . PWM , pin = Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] ch2 = tim . channel ( [number] , Timer . PWM , pin = Pin ( [string] ) , pulse_width_percent = [number] ) [EOL] [EOL] while (True) : [EOL] time . sleep ( [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from pyb import RTC [EOL] [EOL] rtc = RTC ( ) [EOL] rtc . datetime ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] while (True) : [EOL] print ( rtc . datetime ( ) ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pyb , ustruct [EOL] [EOL] text = [string] [EOL] data = ustruct . pack ( [string] % len ( text ) , [number] , len ( text ) , text ) [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] data += [string] * ( [number] + ( len ( data ) % [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] spi = pyb . SPI ( [number] , pyb . SPI . SLAVE , polarity = [number] , phase = [number] ) [EOL] pin = pyb . Pin ( [string] , pyb . Pin . IN , pull = pyb . Pin . PULL_UP ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] while (True) : [EOL] while ( pin . value ( ) ) : pass [EOL] try : [EOL] spi . send ( data , timeout = [number] ) [EOL] [comment] [EOL] print ( [string] ) [comment] [EOL] except OSError as err : [EOL] pass [comment] [EOL] [comment] [EOL] [comment] [EOL] while ( not pin . value ( ) ) : pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pyb , time [EOL] [EOL] hid = pyb . USB_HID ( ) [EOL] [EOL] while (True) : [EOL] [comment] [EOL] [comment] [EOL] hid . send ( ( [number] , [number] , [number] , [number] ) ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from pyb import Pin [EOL] [EOL] [comment] [EOL] [comment] [EOL] pin0 = Pin ( [string] , Pin . IN , Pin . PULL_UP ) [EOL] pin1 = Pin ( [string] , Pin . OUT_PP , Pin . PULL_NONE ) [EOL] [EOL] while (True) : [EOL] pin1 . value ( not pin0 . value ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from machine import I2C [EOL] from vl53l1x import VL53L1X [EOL] import time [EOL] [EOL] i2c = I2C ( [number] ) [EOL] distance = VL53L1X ( i2c ) [EOL] [EOL] while True : [EOL] print ( [string] , distance . read ( ) ) [EOL] time . sleep ( [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pca9685 [EOL] import math [EOL] [EOL] class Servos : [EOL] def __init__ ( self , i2c , address = [number] , freq = [number] , min_us = [number] , max_us = [number] , degrees = [number] ) : [EOL] self . period = [number] / freq [EOL] self . min_duty = self . _us2duty ( min_us ) [EOL] self . max_duty = self . _us2duty ( max_us ) [EOL] self . degrees = degrees [EOL] self . freq = freq [EOL] self . pca9685 = pca9685 . PCA9685 ( i2c , address ) [EOL] self . pca9685 . freq ( freq ) [EOL] [EOL] def _us2duty ( self , value ) : [EOL] return int ( [number] * value / self . period ) [EOL] [EOL] def position ( self , index , degrees = None , radians = None , us = None , duty = None ) : [EOL] span = self . max_duty - self . min_duty [EOL] if degrees is not None : [EOL] duty = self . min_duty + span * degrees / self . degrees [EOL] elif radians is not None : [EOL] duty = self . min_duty + span * radians / math . radians ( self . degrees ) [EOL] elif us is not None : [EOL] duty = self . _us2duty ( us ) [EOL] elif duty is not None : [EOL] pass [EOL] else : [EOL] return self . pca9685 . duty ( index ) [EOL] duty = min ( self . max_duty , max ( self . min_duty , int ( duty ) ) ) [EOL] self . pca9685 . duty ( index , duty ) [EOL] [EOL] def release ( self , index ) : [EOL] self . pca9685 . duty ( index , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import utime [EOL] import ustruct [EOL] [EOL] class PCA9685 : [EOL] def __init__ ( self , i2c , address = [number] ) : [EOL] self . i2c = i2c [EOL] self . address = address [EOL] self . reset ( ) [EOL] [EOL] def _write ( self , address , value ) : [EOL] self . i2c . writeto_mem ( self . address , address , bytearray ( [ value ] ) ) [EOL] [EOL] def _read ( self , address ) : [EOL] return self . i2c . readfrom_mem ( self . address , address , [number] ) [ [number] ] [EOL] [EOL] def reset ( self ) : [EOL] self . _write ( [number] , [number] ) [comment] [EOL] [EOL] def freq ( self , freq = None ) : [EOL] if freq is None : [EOL] return int ( [number] / [number] / ( self . _read ( [number] ) - [number] ) ) [EOL] prescale = int ( [number] / [number] / freq + [number] ) [EOL] old_mode = self . _read ( [number] ) [comment] [EOL] self . _write ( [number] , ( old_mode & [number] ) | [number] ) [comment] [EOL] self . _write ( [number] , prescale ) [comment] [EOL] self . _write ( [number] , old_mode ) [comment] [EOL] utime . sleep_us ( [number] ) [EOL] self . _write ( [number] , old_mode | [number] ) [comment] [EOL] [EOL] def pwm ( self , index , on = None , off = None ) : [EOL] if on is None or off is None : [EOL] data = self . i2c . readfrom_mem ( self . address , [number] + [number] * index , [number] ) [EOL] return ustruct . unpack ( [string] , data ) [EOL] data = ustruct . pack ( [string] , on , off ) [EOL] self . i2c . writeto_mem ( self . address , [number] + [number] * index , data ) [EOL] [EOL] def duty ( self , index , value = None , invert = False ) : [EOL] if value is None : [EOL] pwm = self . pwm ( index ) [EOL] if pwm == ( [number] , [number] ) : [EOL] value = [number] [EOL] elif pwm == ( [number] , [number] ) : [EOL] value = [number] [EOL] value = pwm [ [number] ] [EOL] if invert : [EOL] value = [number] - value [EOL] return value [EOL] if not [number] <= value <= [number] : [EOL] raise ValueError ( [string] ) [EOL] if invert : [EOL] value = [number] - value [EOL] if value == [number] : [EOL] self . pwm ( index , [number] , [number] ) [EOL] elif value == [number] : [EOL] self . pwm ( index , [number] , [number] ) [EOL] else : [EOL] self . pwm ( index , [number] , value ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from servo import Servos [EOL] from machine import I2C , Pin [EOL] [EOL] i2c = I2C ( sda = Pin ( [string] ) , scl = Pin ( [string] ) ) [EOL] servo = Servos ( i2c , address = [number] , freq = [number] , min_us = [number] , max_us = [number] , degrees = [number] ) [EOL] [EOL] while True : [EOL] for i in range ( [number] , [number] ) : [EOL] servo . position ( i , [number] ) [EOL] time . sleep ( [number] ) [EOL] for i in range ( [number] , [number] ) : [EOL] servo . position ( i , [number] ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import sensor , image , pyb [EOL] [EOL] RED_LED_PIN = [number] [EOL] BLUE_LED_PIN = [number] [EOL] [EOL] sensor . reset ( ) [comment] [EOL] sensor . set_pixformat ( sensor . RGB565 ) [comment] [EOL] sensor . set_framesize ( sensor . QVGA ) [comment] [EOL] sensor . skip_frames ( time = [number] ) [comment] [EOL] [EOL] pyb . LED ( RED_LED_PIN ) . on ( ) [EOL] sensor . skip_frames ( time = [number] ) [comment] [EOL] [EOL] pyb . LED ( RED_LED_PIN ) . off ( ) [EOL] pyb . LED ( BLUE_LED_PIN ) . on ( ) [EOL] [EOL] print ( [string] ) [EOL] img = sensor . snapshot ( ) [EOL] [EOL] img . morph ( [number] , [ + [number] , + [number] , + [number] , + [number] , + [number] , - [number] , + [number] , - [number] , - [number] ] ) [comment] [EOL] [EOL] img . save ( [string] ) [comment] [EOL] [EOL] pyb . LED ( BLUE_LED_PIN ) . off ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Pattern , List , Optional , Match [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import argparse [EOL] import re [EOL] import struct [EOL] import sys [EOL] import usb . core [EOL] import usb . util [EOL] import zlib [EOL] import os [EOL] import time [EOL] [EOL] [comment] [EOL] __VID = [number] [EOL] __PID = [number] [EOL] [EOL] [comment] [EOL] __TIMEOUT = [number] [EOL] [EOL] [comment] [EOL] __DFU_DETACH = [number] [EOL] __DFU_DNLOAD = [number] [EOL] __DFU_UPLOAD = [number] [EOL] __DFU_GETSTATUS = [number] [EOL] __DFU_CLRSTATUS = [number] [EOL] __DFU_GETSTATE = [number] [EOL] __DFU_ABORT = [number] [EOL] [EOL] [comment] [EOL] __DFU_STATE_APP_IDLE = [number] [EOL] __DFU_STATE_APP_DETACH = [number] [EOL] __DFU_STATE_DFU_IDLE = [number] [EOL] __DFU_STATE_DFU_DOWNLOAD_SYNC = [number] [EOL] __DFU_STATE_DFU_DOWNLOAD_BUSY = [number] [EOL] __DFU_STATE_DFU_DOWNLOAD_IDLE = [number] [EOL] __DFU_STATE_DFU_MANIFEST_SYNC = [number] [EOL] __DFU_STATE_DFU_MANIFEST = [number] [EOL] __DFU_STATE_DFU_MANIFEST_WAIT_RESET = [number] [EOL] __DFU_STATE_DFU_UPLOAD_IDLE = [number] [EOL] __DFU_STATE_DFU_ERROR = [number] [EOL] [EOL] __DFU_STATUS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] _DFU_DESCRIPTOR_TYPE = [number] [EOL] [EOL] [comment] [EOL] __dev = None [EOL] [EOL] __verbose = None [EOL] [EOL] [comment] [EOL] __DFU_INTERFACE = [number] [EOL] [EOL] import inspect [EOL] if [string] in inspect . getargspec ( usb . util . get_string ) . args : [EOL] [comment] [EOL] def get_string ( dev , index ) : [EOL] return usb . util . get_string ( dev , [number] , index ) [EOL] else : [EOL] [comment] [EOL] def get_string ( dev , index ) : [EOL] return usb . util . get_string ( dev , index ) [EOL] [EOL] [EOL] def init ( ) : [EOL] [docstring] [EOL] global __dev [EOL] devices = get_dfu_devices ( idVendor = __VID , idProduct = __PID ) [EOL] if not devices : [EOL] raise ValueError ( [string] ) [EOL] if len ( devices ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] __dev = devices [ [number] ] [EOL] [EOL] [comment] [EOL] usb . util . claim_interface ( __dev , __DFU_INTERFACE ) [EOL] [EOL] [comment] [EOL] clr_status ( ) [EOL] [EOL] def clr_status ( ) : [EOL] [docstring] [EOL] while ( get_status ( ) != __DFU_STATE_DFU_IDLE ) : [EOL] __dev . ctrl_transfer ( [number] , __DFU_CLRSTATUS , [number] , __DFU_INTERFACE , None , __TIMEOUT ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def get_status ( ) : [EOL] [docstring] [EOL] stat = __dev . ctrl_transfer ( [number] , __DFU_GETSTATUS , [number] , __DFU_INTERFACE , [number] , [number] ) [EOL] [comment] [EOL] return stat [ [number] ] [EOL] [EOL] [EOL] def mass_erase ( ) : [EOL] [docstring] [EOL] [comment] [EOL] __dev . ctrl_transfer ( [number] , __DFU_DNLOAD , [number] , __DFU_INTERFACE , [string] , __TIMEOUT ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_BUSY : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_IDLE : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def page_erase ( addr ) : [EOL] [docstring] [EOL] if __verbose : [EOL] print ( [string] % (addr) ) [EOL] [EOL] [comment] [EOL] buf = struct . pack ( [string] , [number] , addr ) [EOL] __dev . ctrl_transfer ( [number] , __DFU_DNLOAD , [number] , __DFU_INTERFACE , buf , __TIMEOUT ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_BUSY : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_IDLE : [EOL] [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def set_address ( addr ) : [EOL] [docstring] [EOL] [comment] [EOL] buf = struct . pack ( [string] , [number] , addr ) [EOL] __dev . ctrl_transfer ( [number] , __DFU_DNLOAD , [number] , __DFU_INTERFACE , buf , __TIMEOUT ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_BUSY : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_IDLE : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def write_memory ( addr , buf , progress = None , progress_addr = [number] , progress_size = [number] ) : [EOL] [docstring] [EOL] [EOL] xfer_count = [number] [EOL] xfer_bytes = [number] [EOL] xfer_total = len ( buf ) [EOL] xfer_base = addr [EOL] [EOL] while xfer_bytes < xfer_total : [EOL] if __verbose and xfer_count % [number] == [number] : [EOL] print ( [string] % ( xfer_base + xfer_bytes , xfer_bytes // [number] , xfer_total // [number] ) ) [EOL] if progress and xfer_count % [number] == [number] : [EOL] progress ( progress_addr , xfer_base + xfer_bytes - progress_addr , progress_size ) [EOL] [EOL] [comment] [EOL] set_address ( xfer_base + xfer_bytes ) [EOL] [EOL] [comment] [EOL] chunk = min ( [number] , xfer_total - xfer_bytes ) [EOL] __dev . ctrl_transfer ( [number] , __DFU_DNLOAD , [number] , __DFU_INTERFACE , buf [ xfer_bytes : xfer_bytes + chunk ] , __TIMEOUT ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_BUSY : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_IDLE : [EOL] raise Exception ( [string] ) [EOL] [EOL] xfer_count += [number] [EOL] xfer_bytes += chunk [EOL] [EOL] [EOL] def write_page ( buf , xfer_offset ) : [EOL] [docstring] [EOL] [EOL] xfer_base = [number] [EOL] [EOL] [comment] [EOL] set_address ( xfer_base + xfer_offset ) [EOL] [EOL] [comment] [EOL] __dev . ctrl_transfer ( [number] , __DFU_DNLOAD , [number] , __DFU_INTERFACE , buf , __TIMEOUT ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_BUSY : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_DOWNLOAD_IDLE : [EOL] raise Exception ( [string] ) [EOL] [EOL] if __verbose : [EOL] print ( [string] % ( xfer_base + xfer_offset ) ) [EOL] [EOL] [EOL] def exit_dfu ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] set_address ( [number] ) [EOL] [EOL] [comment] [EOL] __dev . ctrl_transfer ( [number] , __DFU_DNLOAD , [number] , __DFU_INTERFACE , None , __TIMEOUT ) [EOL] [EOL] try : [EOL] [comment] [EOL] if get_status ( ) != __DFU_STATE_DFU_MANIFEST : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] usb . util . dispose_resources ( __dev ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] def named ( values , names ) : [EOL] [docstring] [EOL] return dict ( zip ( names . split ( ) , values ) ) [EOL] [EOL] [EOL] def consume ( fmt , data , names ) : [EOL] [docstring] [EOL] size = struct . calcsize ( fmt ) [EOL] return named ( struct . unpack ( fmt , data [ : size ] ) , names ) , data [ size : ] [EOL] [EOL] [EOL] def cstring ( string ) : [EOL] [docstring] [EOL] return string . decode ( [string] ) . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] [EOL] def compute_crc ( data ) : [EOL] [docstring] [EOL] return [number] & - zlib . crc32 ( data ) - [number] [EOL] [EOL] [EOL] def read_dfu_file ( filename ) : [EOL] [docstring] [EOL] [EOL] print ( [string] . format ( filename ) ) [EOL] with open ( filename , [string] ) as fin : [EOL] data = fin . read ( ) [EOL] crc = compute_crc ( data [ : - [number] ] ) [EOL] elements = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dfu_prefix , data = consume ( [string] , data , [string] ) [EOL] print ( [string] [string] % dfu_prefix ) [EOL] for target_idx in range ( dfu_prefix [ [string] ] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] img_prefix , data = consume ( [string] , data , [string] [string] ) [EOL] img_prefix [ [string] ] = target_idx [EOL] if img_prefix [ [string] ] : [EOL] img_prefix [ [string] ] = cstring ( img_prefix [ [string] ] ) [EOL] else : [EOL] img_prefix [ [string] ] = [string] [EOL] print ( [string] [string] % img_prefix ) [EOL] [EOL] target_size = img_prefix [ [string] ] [EOL] target_data , data = data [ : target_size ] , data [ target_size : ] [EOL] for elem_idx in range ( img_prefix [ [string] ] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] elem_prefix , target_data = consume ( [string] , target_data , [string] ) [EOL] elem_prefix [ [string] ] = elem_idx [EOL] print ( [string] % elem_prefix ) [EOL] elem_size = elem_prefix [ [string] ] [EOL] elem_data = target_data [ : elem_size ] [EOL] target_data = target_data [ elem_size : ] [EOL] elem_prefix [ [string] ] = elem_data [EOL] elements . append ( elem_prefix ) [EOL] [EOL] if len ( target_data ) : [EOL] print ( [string] % target_idx ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dfu_suffix = named ( struct . unpack ( [string] , data [ : [number] ] ) , [string] ) [EOL] print ( [string] [string] % dfu_suffix ) [EOL] if crc != dfu_suffix [ [string] ] : [EOL] print ( [string] % crc ) [EOL] return [EOL] data = data [ [number] : ] [EOL] if data : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] return elements [EOL] [EOL] [EOL] class FilterDFU ( object ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , device ) : [EOL] for cfg in device : [EOL] for intf in cfg : [EOL] return ( intf . bInterfaceClass == [number] and intf . bInterfaceSubClass == [number] ) [EOL] [EOL] [EOL] def get_dfu_devices ( * args , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] return list ( usb . core . find ( * args , find_all = True , custom_match = FilterDFU ( ) , ** kwargs ) ) [EOL] [EOL] [EOL] def get_memory_layout ( device ) : [EOL] [docstring] [EOL] cfg = device [ [number] ] [EOL] intf = cfg [ ( [number] , [number] ) ] [EOL] mem_layout_str = get_string ( device , intf . iInterface ) [EOL] mem_layout = mem_layout_str . split ( [string] ) [EOL] addr = int ( mem_layout [ [number] ] , [number] ) [EOL] segments = mem_layout [ [number] ] . split ( [string] ) [EOL] seg_re = re . compile ( [string] ) [EOL] result = [ ] [EOL] for segment in segments : [EOL] seg_match = seg_re . match ( segment ) [EOL] num_pages = int ( seg_match . groups ( ) [ [number] ] , [number] ) [EOL] page_size = int ( seg_match . groups ( ) [ [number] ] , [number] ) [EOL] multiplier = seg_match . groups ( ) [ [number] ] [EOL] if multiplier == [string] : [EOL] page_size *= [number] [EOL] if multiplier == [string] : [EOL] page_size *= [number] * [number] [EOL] size = num_pages * page_size [EOL] last_addr = addr + size - [number] [EOL] result . append ( named ( ( addr , last_addr , size , num_pages , page_size ) , [string] ) ) [EOL] addr += size [EOL] return result [EOL] [EOL] [EOL] def list_dfu_devices ( * args , ** kwargs ) : [EOL] [docstring] [EOL] devices = get_dfu_devices ( * args , ** kwargs ) [EOL] if not devices : [EOL] print ( [string] ) [EOL] return [EOL] for device in devices : [EOL] print ( [string] . format ( device . bus , device . address , device . idVendor , device . idProduct ) ) [EOL] layout = get_memory_layout ( device ) [EOL] print ( [string] ) [EOL] for entry in layout : [EOL] print ( [string] . format ( entry [ [string] ] , entry [ [string] ] , entry [ [string] ] // [number] ) ) [EOL] [EOL] [EOL] def write_elements ( elements , mass_erase_used , progress = None ) : [EOL] [docstring] [EOL] [EOL] mem_layout = get_memory_layout ( __dev ) [EOL] for elem in elements : [EOL] addr = elem [ [string] ] [EOL] size = elem [ [string] ] [EOL] data = elem [ [string] ] [EOL] elem_size = size [EOL] elem_addr = addr [EOL] if progress : [EOL] progress ( elem_addr , [number] , elem_size ) [EOL] while size > [number] : [EOL] write_size = size [EOL] if not mass_erase_used : [EOL] for segment in mem_layout : [EOL] if addr >= segment [ [string] ] and addr <= segment [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] page_size = segment [ [string] ] [EOL] page_addr = addr & ~ ( page_size - [number] ) [EOL] if addr + write_size > page_addr + page_size : [EOL] write_size = page_addr + page_size - addr [EOL] page_erase ( page_addr ) [EOL] break [EOL] write_memory ( addr , data [ : write_size ] , progress , elem_addr , elem_size ) [EOL] data = data [ write_size : ] [EOL] addr += write_size [EOL] size -= write_size [EOL] if progress : [EOL] progress ( elem_addr , addr - elem_addr , elem_size ) [EOL] [EOL] def write_bin ( path , progress = None ) : [EOL] try : [EOL] with open ( path , [string] ) as f : [EOL] buf = f . read ( ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] return [EOL] [EOL] xfer_bytes = [number] [EOL] xfer_total = len ( buf ) [EOL] [EOL] while xfer_bytes < xfer_total : [EOL] [comment] [EOL] chunk = min ( [number] , xfer_total - xfer_bytes ) [EOL] write_page ( buf [ xfer_bytes : xfer_bytes + chunk ] , xfer_bytes ) [EOL] xfer_bytes += chunk [EOL] if (progress) : [EOL] progress ( [number] + xfer_bytes , xfer_bytes , xfer_total ) [EOL] [EOL] def cli_progress ( addr , offset , size ) : [EOL] [docstring] [EOL] width = [number] [EOL] done = offset * width // size [EOL] print ( [string] . format ( addr , size , [string] * done , [string] * ( width - done ) , offset * [number] // size ) , end = [string] ) [EOL] sys . stdout . flush ( ) [EOL] if offset == size : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] global __verbose [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [comment] [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = False ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = False ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , dest = [string] , default = False ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = False ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] __verbose = args . verbose [EOL] [EOL] if args . list : [EOL] list_dfu_devices ( idVendor = __VID , idProduct = __PID ) [EOL] return [EOL] [EOL] init ( ) [EOL] [EOL] if args . mass_erase : [EOL] print ( [string] ) [EOL] mass_erase ( ) [EOL] [EOL] if args . path : [EOL] ext = os . path . splitext ( args . path ) [ [number] ] [EOL] if ext == [string] : [EOL] print ( [string] ) [EOL] write_bin ( args . path , progress = cli_progress ) [EOL] [EOL] print ( [string] ) [EOL] exit_dfu ( ) [EOL] elif ( ext == [string] ) : [EOL] elements = read_dfu_file ( args . path ) [EOL] if not elements : [EOL] return [EOL] print ( [string] ) [EOL] write_elements ( elements , args . mass_erase , progress = cli_progress ) [EOL] [EOL] print ( [string] ) [EOL] exit_dfu ( ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] return [EOL] [EOL] print ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0