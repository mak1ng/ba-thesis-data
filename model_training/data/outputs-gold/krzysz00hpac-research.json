[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple , Dict , Callable , List , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] from knuth_bendix import metadata [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] todo_include_todos = True [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = metadata . project [EOL] copyright = metadata . copyright [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = metadata . version [EOL] [comment] [EOL] release = metadata . version [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = metadata . project_no_spaces + [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( [string] , metadata . project_no_spaces + [string] , metadata . project + [string] , metadata . authors_string , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( [string] , metadata . package , metadata . project + [string] , metadata . authors_string , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( [string] , metadata . project_no_spaces , metadata . project + [string] , metadata . authors_string , metadata . project_no_spaces , metadata . description , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , [string] : ( [string] , None ) , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] autoclass_content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Optional , Tuple , Iterable , Container , Iterator , List , Any [EOL] import typing [EOL] import builtins [EOL] import matchpy [EOL] [docstring] [EOL] from . utils import substitute [EOL] [EOL] import matchpy [EOL] [EOL] from matchpy import ( Expression , get_variables , ManyToOneMatcher , rename_variables ) [EOL] from typing import ( Iterable , Optional , Iterator , Tuple , List , Container , Dict ) [EOL] [EOL] [EOL] class RewriteRule ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , left , right ) : [EOL] [docstring] [EOL] if not get_variables ( right ) <= get_variables ( left ) : [EOL] raise ( ValueError ( [string] ) ) [comment] [EOL] substitution = ManyToOneMatcher . _collect_variable_renaming ( left ) [EOL] self . left = rename_variables ( left , substitution ) [EOL] self . right = rename_variables ( right , substitution ) [EOL] self . lhs = matchpy . Pattern ( self . left ) [EOL] [EOL] def apply_match ( self , subst ) : [EOL] [docstring] [EOL] return substitute ( self . right , subst ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return [string] . format ( cls = self . __class__ , left = self . left , right = self . right ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return [string] . format ( ** self . __dict__ ) [EOL] [EOL] [EOL] class RewriteRuleList ( Iterable [ RewriteRule ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * rules ) : [EOL] [docstring] [EOL] self . rules = list ( rules ) [EOL] self . _rebuild ( ) [EOL] [EOL] def _rebuild ( self ) : [EOL] [docstring] [EOL] self . matcher = ManyToOneMatcher ( ) [comment] [EOL] for i in self . rules : [EOL] self . matcher . add ( i . lhs , i ) [EOL] [EOL] def append ( self , rule ) : [EOL] self . rules . append ( rule ) [EOL] self . matcher . add ( rule . lhs , rule ) [EOL] [EOL] def extend ( self , rules ) : [EOL] self . rules . extend ( rules ) [EOL] for i in rules : [EOL] self . matcher . add ( i . lhs , i ) [EOL] [EOL] def replace ( self , idx , rule ) : [EOL] [docstring] [EOL] self . rules [ idx ] = rule [EOL] self . _rebuild ( ) [EOL] [EOL] def delete ( self , idx ) : [EOL] [docstring] [EOL] del self . rules [ idx ] [EOL] self . _rebuild ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . rules ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . rules ) [EOL] [EOL] def __getitem__ ( self , idx ) : [EOL] return self . rules [ idx ] [EOL] [EOL] def apply_all ( self , expr , max_count = None ) : [EOL] [docstring] [EOL] any_change = True [EOL] apply_count = [number] [EOL] while any_change and ( max_count is None or apply_count < max_count ) : [EOL] any_change = False [EOL] for subexpr , pos in expr . preorder_iter ( ) : [EOL] try : [EOL] rule , subst = next ( iter ( self . matcher . match ( subexpr ) ) ) [EOL] new_subexpr = rule . apply_match ( subst ) [EOL] new_expr = matchpy . replace ( expr , pos , new_subexpr ) [EOL] if not isinstance ( new_expr , Expression ) : [EOL] raise TypeError ( [string] ) [comment] [EOL] else : [EOL] expr = new_expr [EOL] any_change = True [EOL] apply_count += [number] [EOL] break [EOL] except StopIteration : [EOL] pass [EOL] return expr [EOL] [EOL] def apply_each_once ( self , expr , only = None ) : [comment] [EOL] [docstring] [EOL] for subexpr , pos in expr . preorder_iter ( ) : [EOL] for rule , subst in self . matcher . match ( subexpr ) : [EOL] if only is None or rule in only : [EOL] new_subexpr = rule . apply_match ( subst ) [EOL] new_expr = matchpy . replace ( expr , pos , new_subexpr ) [EOL] if not isinstance ( new_expr , Expression ) : [EOL] raise TypeError ( [string] ) [comment] [EOL] yield ( rule , new_expr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $matchpy.Expression$ 0 0 0 $matchpy.Substitution$ 0 0 0 0 0 0 0 0 0 0 0 0 $matchpy.Substitution$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $RewriteRule$ 0 0 0 0 0 0 0 0 0 $RewriteRule$ 0 0 0 0 0 0 0 0 $RewriteRule$ 0 0 0 $RewriteRule$ 0 0 0 0 $None$ 0 0 0 $typing.List[RewriteRule]$ 0 0 0 0 0 $typing.List[RewriteRule]$ 0 0 0 $typing.List[RewriteRule]$ 0 0 0 0 0 $typing.List[RewriteRule]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $RewriteRule$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $RewriteRule$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[RewriteRule]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RewriteRule$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $matchpy.Expression$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.int$ 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[RewriteRule,matchpy.Expression]]$ 0 0 0 $matchpy.Expression$ 0 $typing.Optional[typing.Container[RewriteRule]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $matchpy.Expression$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Container[RewriteRule]]$ 0 0 0 0 0 $typing.Optional[typing.Container[RewriteRule]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $matchpy.Expression$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] import builtins [EOL] from typing import List , Callable [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] package = [string] [EOL] project = [string] [EOL] project_no_spaces = project . replace ( [string] , [string] ) [EOL] version = [string] [EOL] description = [string] [EOL] authors = [ [string] ] [EOL] authors_string = [string] . join ( authors ) [EOL] emails = [ [string] ] [EOL] license = [string] [EOL] copyright = [string] + authors_string [EOL] url = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from knuth_bendix import metadata [EOL] [EOL] [EOL] __version__ = metadata . version [EOL] __author__ = metadata . authors [ [number] ] [EOL] __license__ = metadata . license [EOL] __copyright__ = metadata . copyright [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , Set , TypeVar , List , Any , Type [EOL] import typing [EOL] import bendix [EOL] import matchpy [EOL] from matchpy import ( Expression , Substitution , get_head , Operation , Symbol ) [EOL] from matchpy import substitute as _substitute [EOL] [EOL] from typing import TypeVar , Set , Tuple , Optional , Union , cast , Type , List [EOL] [EOL] [EOL] _T = TypeVar ( [string] ) [EOL] PartialOrder = Set [ Tuple [ _T , _T ] ] [EOL] [EOL] [EOL] def transitive_closure ( order ) : [EOL] [docstring] [EOL] while True : [EOL] new_relations = set ( ( x , w ) for x , y in order for q , w in order if q == y ) [EOL] new_order = order | new_relations [EOL] if order == new_order : [EOL] return order [EOL] order = new_order [EOL] [EOL] [EOL] def substitute ( term , substitution ) : [EOL] [docstring] [EOL] ret = _substitute ( term , substitution ) [EOL] if not isinstance ( ret , Expression ) : [EOL] raise ( ValueError ( [string] , ret , [string] , substitution , [string] , term ) ) [EOL] return ret [EOL] [EOL] [EOL] Operator = Union [ Symbol , Type [ Operation ] ] [EOL] [docstring] [EOL] [EOL] [EOL] def to_operator ( term ) : [EOL] [docstring] [EOL] if isinstance ( term , Operation ) : [EOL] return cast ( Type [ Operation ] , get_head ( term ) ) [EOL] elif isinstance ( term , Symbol ) : [EOL] return term [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def operands ( term ) : [EOL] [docstring] [EOL] if not to_operator ( term ) : [EOL] return None [EOL] elif isinstance ( term , Operation ) : [EOL] return term . operands [EOL] elif isinstance ( term , Symbol ) : [EOL] return [ ] [EOL] else : [EOL] raise ( TypeError ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PartialOrder[_T]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $matchpy.Expression$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Operator]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[matchpy.Expression]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from knuth_bendix . unification import ( uniqify_variables , maybe_add_substitution , unify_expressions , find_overlaps , equal_mod_renaming , proper_contains ) [EOL] from matchpy import ( Operation , Arity , make_dot_variable , Symbol , get_variables , substitute ) [EOL] [EOL] plus = Operation . new ( [string] , Arity . polyadic , [string] , infix = True , associative = True , commutative = True ) [EOL] f = Operation . new ( [string] , Arity . binary ) [EOL] g = Operation . new ( [string] , Arity . unary ) [EOL] h = Operation . new ( [string] , Arity . binary ) [EOL] x = make_dot_variable ( [string] ) [EOL] y = make_dot_variable ( [string] ) [EOL] z = make_dot_variable ( [string] ) [EOL] w = make_dot_variable ( [string] ) [EOL] a = Symbol ( [string] ) [EOL] b = Symbol ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( x , x , True ) , ( x , y , False ) , ( y , x , False ) , ( a , x , False ) , ( a , b , False ) , ( x , a , False ) , ( f ( x , y ) , f ( x , z ) , True ) , ( f ( x , y ) , f ( x , y ) , True ) , ( g ( x ) , g ( x ) , True ) , ( g ( y ) , g ( z ) , False ) , ( plus ( x , y , z ) , plus ( x , y , z , a , b ) , True ) , ( plus ( x , y ) , plus ( z , a ) , False ) ] ) def test_uniqify_variables ( left , right , is_changed ) : [EOL] left_prime = uniqify_variables ( left , right ) [EOL] assert not ( get_variables ( left_prime ) & get_variables ( right ) ) [EOL] assert ( not ( left_prime == left ) ) == is_changed [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { [string] : y } , [string] , x , None ) , ( { [string] : y } , [string] , z , { [string] : z , [string] : z } ) , ( { [string] : g ( z ) } , [string] , x , { [string] : x , [string] : g ( x ) } ) , ( { [string] : g ( a ) } , [string] , x , { [string] : x , [string] : g ( a ) } ) , ( { [string] : z } , [string] , y , { [string] : y } ) , ( { [string] : f ( g ( y ) , z ) } , [string] , g ( x ) , None ) , ( { [string] : f ( g ( y ) , z ) } , [string] , g ( z ) , { [string] : g ( z ) , [string] : f ( g ( g ( z ) ) , z ) } ) ] ) def test_maybe_add_substitution ( subs , var , rule , expected ) : [EOL] assert maybe_add_substitution ( subs , var , rule ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( x , y , [ { [string] : y } ] ) , ( g ( x ) , y , [ { [string] : g ( x ) } ] ) , ( z , g ( a ) , [ { [string] : g ( a ) } ] ) , ( g ( x ) , g ( a ) , [ { [string] : a } ] ) , ( f ( x , b ) , f ( a , y ) , [ { [string] : a , [string] : b } ] ) , ( f ( x , y ) , g ( x ) , [ ] ) , ( f ( f ( x , y ) , z ) , f ( g ( x ) , z ) , [ ] ) , ( f ( x , y ) , f ( y , x ) , [ { [string] : y } ] ) , ( f ( g ( x ) , x ) , f ( g ( a ) , y ) , [ { [string] : a , [string] : a } ] ) , ( plus ( w , x ) , plus ( y , z ) , [ { [string] : y , [string] : z } , { [string] : z , [string] : y } ] ) , ( plus ( a , x ) , plus ( y , z ) , [ { [string] : a , [string] : y } , { [string] : a , [string] : z } ] ) , ( plus ( a , a , a ) , plus ( w , a ) , [ { [string] : plus ( a , a ) } ] ) , ( plus ( a , a , a ) , plus ( w , x ) , [ { [string] : plus ( a , a ) , [string] : a } , { [string] : plus ( a , a ) , [string] : a } ] ) , ( plus ( g ( w ) , g ( x ) ) , plus ( g ( y ) , g ( z ) ) , [ { [string] : z , [string] : y } , { [string] : y , [string] : z } ] ) , ( plus ( g ( w ) , g ( x ) ) , plus ( y , z ) , [ { [string] : g ( x ) , [string] : g ( w ) } , { [string] : g ( w ) , [string] : g ( x ) } ] ) , ( plus ( g ( w ) , g ( z ) ) , plus ( a , a ) , [ ] ) , ] ) def test_unify_expressions ( left , right , expected ) : [EOL] assert unify_expressions ( left , right ) == expected [EOL] subs = unify_expressions ( left , right ) [EOL] for sub in subs : [EOL] assert substitute ( left , sub ) == substitute ( right , sub ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( f ( a , x ) , f ( f ( x , y ) , z ) , [ f ( f ( a , y ) , z ) ] ) , ( f ( g ( x ) , x ) , f ( f ( x , y ) , z ) , [ f ( f ( g ( y ) , y ) , z ) ] ) , ( g ( g ( x ) ) , f ( y , z ) , [ ] ) , ( g ( x ) , g ( y ) , [ g ( y ) ] ) ] ) def test_find_overlaps ( term , within , expected ) : [EOL] assert list ( find_overlaps ( term , within ) ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( x , x , True ) , ( x , y , True ) , ( g ( x ) , g ( y ) , True ) , ( g ( x ) , g ( x ) , True ) , ( f ( x , y ) , f ( y , z ) , True ) , ( a , b , False ) , ( f ( x , y ) , f ( z , a ) , False ) , ( f ( x , x ) , f ( y , z ) , False ) , ( f ( x , y ) , g ( z ) , False ) , ( f ( f ( x , y ) , z ) , f ( x , f ( y , z ) ) , False ) , ( g ( a ) , g ( b ) , False ) , ] ) def test_equal_mod_renaming ( t1 , t2 , expected ) : [EOL] assert equal_mod_renaming ( t1 , t2 ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( x , x , False ) , ( x , y , False ) , ( x , g ( x ) , True ) , ( x , g ( y ) , True ) , ( f ( x , y ) , f ( y , z ) , False ) , ( f ( x , y ) , g ( f ( y , z ) ) , True ) , ( a , b , False ) , ( a , g ( a ) , True ) , ( f ( a , b ) , f ( f ( a , b ) , y ) , True ) , ] ) def test_proper_contains ( term , within , expected ) : [EOL] assert proper_contains ( term , within ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Any , Tuple [EOL] import typing [EOL] from knuth_bendix . knuth_bendix_ordering import KnuthBendixOrdering [EOL] from knuth_bendix . lex_path_ordering import LexPathOrdering [EOL] from knuth_bendix . rewrite_system import RewriteSystem [EOL] from knuth_bendix . rewrite_rule import RewriteRule [EOL] from knuth_bendix . unification import equal_mod_renaming [EOL] [EOL] from matchpy import ( Operation , Arity , make_dot_variable , Symbol ) [EOL] import pytest [EOL] [EOL] x , y , z = ( make_dot_variable ( t ) for t in [ [string] , [string] , [string] ] ) [EOL] times = Operation . new ( [string] , Arity . binary , [string] , infix = True ) [EOL] i = Operation . new ( [string] , Arity . unary ) [EOL] e = Symbol ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ KnuthBendixOrdering ( { times : [number] , i : [number] , e : [number] } , [number] , { ( i , times ) , ( times , e ) } ) , LexPathOrdering ( { ( i , times ) , ( times , e ) } ) ] ) def test_group_theory_completion ( order ) : [EOL] equations = [ ( times ( times ( x , y ) , z ) , times ( x , times ( y , z ) ) ) , ( times ( e , x ) , x ) , ( times ( i ( x ) , x ) , e ) ] [EOL] [EOL] expected_system = [ RewriteRule ( times ( x , e ) , x ) , RewriteRule ( times ( e , x ) , x ) , RewriteRule ( times ( i ( x ) , x ) , e ) , RewriteRule ( times ( x , i ( x ) ) , e ) , RewriteRule ( times ( times ( x , y ) , z ) , times ( x , times ( y , z ) ) ) , RewriteRule ( i ( e ) , e ) , RewriteRule ( times ( i ( x ) , times ( x , y ) ) , y ) , RewriteRule ( times ( x , times ( i ( x ) , y ) ) , y ) , RewriteRule ( i ( i ( x ) ) , x ) , RewriteRule ( i ( times ( y , x ) ) , times ( i ( x ) , i ( y ) ) ) , ] [EOL] [EOL] system = RewriteSystem . from_equations ( order , equations ) [EOL] system . complete ( order ) [EOL] [EOL] for r in expected_system : [EOL] assert any ( equal_mod_renaming ( r . left , s . left ) [EOL] and equal_mod_renaming ( r . right , s . right ) for s in system . rules ) [EOL] assert len ( expected_system ) == len ( system . rules ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from knuth_bendix . rewrite_rule import ( RewriteRule , RewriteRuleList ) [EOL] from matchpy import Operation , make_dot_variable , Symbol , Arity [EOL] [EOL] [EOL] @ pytest . fixture def inv_pattern ( ) : [EOL] [docstring] [EOL] inv = Operation . new ( [string] , Arity . unary ) [EOL] x = make_dot_variable ( [string] ) [EOL] lhs = inv ( x ) [EOL] rhs = x [EOL] rule = RewriteRule ( lhs , rhs ) [EOL] rules = RewriteRuleList ( rule ) [EOL] return { [string] : rule , [string] : x , [string] : inv , [string] : rules } [EOL] [EOL] [EOL] def test_subst ( inv_pattern ) : [EOL] const = Symbol ( [string] ) [EOL] lhs = inv_pattern [ [string] ] ( const ) [EOL] ret = inv_pattern [ [string] ] . apply_all ( lhs ) [EOL] assert ret == const [EOL] [EOL] [EOL] def test_print ( inv_pattern , capsys ) : [EOL] print ( inv_pattern [ [string] ] ) [EOL] assert capsys . readouterr ( ) == ( [string] , [string] ) [EOL] [EOL] [EOL] def test_apply_once ( inv_pattern ) : [EOL] const = Symbol ( [string] ) [EOL] inv = inv_pattern [ [string] ] [EOL] expr = inv ( inv ( const ) ) [EOL] rules = inv_pattern [ [string] ] [EOL] match_r , ret1 = next ( rules . apply_each_once ( expr ) ) [EOL] assert match_r == inv_pattern [ [string] ] [EOL] ret2 = rules . apply_all ( expr , max_count = [number] ) [EOL] assert ret1 == ret2 [EOL] assert ret1 == inv ( const ) [EOL] [EOL] [EOL] def test_apply_all ( inv_pattern ) : [EOL] const = Symbol ( [string] ) [EOL] inv = inv_pattern [ [string] ] [EOL] expr = inv ( inv ( const ) ) [EOL] ret = inv_pattern [ [string] ] . apply_all ( expr ) [EOL] assert ret == const [EOL] [EOL] [EOL] def test_apply_all_many_rules ( inv_pattern ) : [EOL] rules = inv_pattern [ [string] ] [EOL] inv = inv_pattern [ [string] ] [EOL] inv_rule = inv_pattern [ [string] ] [EOL] [EOL] g = Operation . new ( [string] , Arity . binary ) [EOL] y = make_dot_variable ( [string] ) [EOL] z = make_dot_variable ( [string] ) [EOL] g_rule = RewriteRule ( g ( y , z ) , y ) [EOL] [EOL] rules . append ( g_rule ) [EOL] [EOL] a = Symbol ( [string] ) [EOL] b = Symbol ( [string] ) [EOL] c = Symbol ( [string] ) [EOL] d = Symbol ( [string] ) [EOL] expr = g ( inv ( g ( g ( inv ( a ) , b ) , c ) ) , d ) [EOL] [EOL] ret = rules . apply_all ( expr ) [EOL] assert ret == a [EOL] [EOL] assert ( set ( rules . apply_each_once ( expr , only = [ inv_rule , g_rule ] ) ) == { ( inv_rule , g ( g ( g ( inv ( a ) , b ) , c ) , d ) ) , ( inv_rule , g ( inv ( g ( g ( a , b ) , c ) ) , d ) ) , ( g_rule , inv ( g ( g ( inv ( a ) , b ) , c ) ) ) , ( g_rule , g ( inv ( g ( inv ( a ) , b ) ) , d ) ) , ( g_rule , g ( inv ( g ( inv ( a ) , c ) ) , d ) ) } ) [EOL] [EOL] [EOL] def test_new_variable_failure ( ) : [EOL] x = make_dot_variable ( [string] ) [EOL] y = make_dot_variable ( [string] ) [EOL] z = make_dot_variable ( [string] ) [EOL] f = Operation . new ( [string] , Arity . binary ) [EOL] with pytest . raises ( ValueError ) : [EOL] RewriteRule ( f ( x , y ) , f ( z , x ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from pytest import raises [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import pytest [EOL] from knuth_bendix . main import main [EOL] [EOL] parametrize = pytest . mark . parametrize [EOL] [EOL] [EOL] class TestMain ( object ) : [EOL] @ parametrize ( [string] , [ [string] , [string] ] ) def test_help ( self , helparg , capsys ) : [EOL] with raises ( SystemExit ) as exc_info : [EOL] main ( [ [string] , helparg ] ) [EOL] out , err = capsys . readouterr ( ) [EOL] [comment] [EOL] [comment] [EOL] assert [string] in out [EOL] [comment] [EOL] [comment] [EOL] assert [string] in out [EOL] [comment] [EOL] assert exc_info . value . code == [number] [EOL] [EOL] @ parametrize ( [string] , [ [string] , [string] ] ) def test_version ( self , versionarg , capsys ) : [EOL] with raises ( SystemExit ) as exc_info : [EOL] main ( [ [string] , versionarg ] ) [EOL] out , err = capsys . readouterr ( ) [EOL] [comment] [EOL] [comment] [EOL] assert exc_info . value . code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from knuth_bendix . knuth_bendix_ordering import KnuthBendixOrdering [EOL] from matchpy import ( Operation , Arity , make_dot_variable , Symbol ) [EOL] [EOL] x , y , z = ( make_dot_variable ( t ) for t in [ [string] , [string] , [string] ] ) [EOL] times = Operation . new ( [string] , Arity . binary , [string] , infix = True ) [EOL] i = Operation . new ( [string] , Arity . unary ) [EOL] e = Symbol ( [string] ) [EOL] order = KnuthBendixOrdering ( { times : [number] , i : [number] , e : [number] } , [number] , { ( i , times ) , ( times , e ) } ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( times ( x , e ) , x ) , ( times ( e , x ) , x ) , ( times ( i ( x ) , x ) , e ) , ( times ( x , i ( x ) ) , e ) , ( times ( times ( x , y ) , z ) , times ( x , times ( y , z ) ) ) , ( i ( e ) , e ) , ( times ( i ( x ) , times ( x , y ) ) , y ) , ( times ( x , times ( i ( x ) , y ) ) , y ) , ( i ( i ( x ) ) , x ) , ( i ( times ( y , x ) ) , times ( i ( x ) , i ( y ) ) ) , ] ) def test_knuth_bendix_order ( left , right ) : [EOL] assert order ( left , right ) [EOL] assert not order ( right , left ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0